<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="wolfand11" />



<meta name="description" content="这篇主要是算法导论相关的笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="AlgorithmIntroduce">
<meta property="og:url" content="http://wolfand11.coding.me/2016/07/01/algorithm/AlgorithmIntroduce/index.html">
<meta property="og:site_name" content="wolfand11's blog">
<meta property="og:description" content="这篇主要是算法导论相关的笔记。">
<meta property="og:image" content="http://wolfand11.coding.me/Img_asymptotic_notation.jpg">
<meta property="og:image" content="http://wolfand11.coding.me/Img_recursion_tree.jpg">
<meta property="og:image" content="http://wolfand11.coding.me/Img_direct-address-table.jpg">
<meta property="og:image" content="http://wolfand11.coding.me/Img_hash-table.jpg">
<meta property="og:image" content="http://wolfand11.coding.me/Img_hash_dict_compare.jpg">
<meta property="og:updated_time" content="2017-04-02T12:45:46.168Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AlgorithmIntroduce">
<meta name="twitter:description" content="这篇主要是算法导论相关的笔记。">
<meta name="twitter:image" content="http://wolfand11.coding.me/Img_asymptotic_notation.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="wolfand11&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>AlgorithmIntroduce | wolfand11&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/m_lambda-320.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">wolfand11</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/wolfand11" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/people/wolfand11" title="豆瓣"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/InitPC/">InitPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animation/">animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elisp/">elisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/emacs/">emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/">game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gameplay/">gameplay</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphics/">graphics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gui/">gui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hot-update/">hot-update</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/language/">language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mvc/">mvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngui/">ngui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resource/">resource</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slua/">slua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-architecture/">software architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spacemacs/">spacemacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ugui/">ugui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity-doc/">unity-doc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/working-in-unity/">working-in-unity</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://xtutu.me/">xtutu</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">wolfand11</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/m_lambda-320.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">wolfand11</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/wolfand11" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/people/wolfand11" title="豆瓣"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-algorithm/AlgorithmIntroduce" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/01/algorithm/AlgorithmIntroduce/" class="article-date">
      <time datetime="2016-06-30T15:00:00.000Z" itemprop="datePublished">2016-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      AlgorithmIntroduce
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        

<p>
这篇主要是算法导论相关的笔记。<br>
</p>
<a id="more"></a>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">1</span> Foundations</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">1.1</span> 函数的增长</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="Img_asymptotic_notation.jpg"><br>
</p>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1"><span class="section-number-4">1.1.1</span> \(\Theta\) 记号</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\Theta(g(n))\) 来表示函数集合：<br>
\(\Theta(g(n)) = \{f(n):存在常数 c_1,c_2 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq c_1g(n) \leq f(n) \leq c_2g(n)\} \quad 也就是说，对于任一函数 f(n),若存在正常数 c_1,c_2,使当 n 充分大时，f(n)能被夹在 c_1g(n)和 c_2g(n)中间，则 f(n)属于集合 Theta(g(n))\)<br>
\(\Theta 记号 给出了函数 f(n)的上下界\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2"><span class="section-number-4">1.1.2</span> \(O\) 记号</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
对于一个给定函数 \(g(n)\) ,用 \(O(g(n))\) 来表示函数集合：<br>
\(O(g(n)) = \{f(n):存在常数 c 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq  f(n) \leq cg(n)\} \quad 也就是说，对于任一函数 f(n),若存在正常数 c,使当 n 充分大时，f(n)的值都在 cg(n)之下，则 f(n)属于集合 O(g(n))\)<br>
\(O 记号 给出了函数 f(n)的上界\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4">1.1.3</span> \(\Omega\) 记号</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\Omega(g(n))\) 来表示函数集合：<br>
\(\Omega(g(n)) = \{f(n):存在常数 c 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq cg(n) \leq  f(n) \} \quad 也就是说，对于任一函数 f(n),若存在正常数 c,使当 n 充分大时，f(n)的值都在 cg(n)之上，则 f(n)属于集合 \Omega(g(n))\)<br>
\(\Omega 记号 给出了函数 f(n)的下界\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">1.1.4</span> \(o\) 记号</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
对于一个给定函数 \(g(n)\) ,用 \(o(g(n))\) 来表示函数集合：<br>
\(o(g(n)) = \{f(n):存在常数 c ,存在常数 n_0 > 0，使对所有的 n \geq n_0 ,有 0 \leq  f(n) < cg(n)\}\)<br>
\(o 记号 给出了函数 f(n)的非渐近紧确上界\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">1.1.5</span> \(\omega\) 记号</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\omega(g(n))\) 来表示函数集合：<br>
\(\omega(g(n)) = \{f(n):存在常数 c ,存在常数 n_0 > 0，使对所有的 n \geq n_0 ,有 0 \leq cg(n) < f(n) \}\)<br>
\(\omega 记号 给出了函数 f(n)的非渐近紧确下界\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">1.1.6</span> 渐近记号的解释</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
\(X(g(n))是一个集合，可以用 f(n) \in X(g(n)) 来表示 f(n)属于 X(g(n))。不过通常写为 f(n) = X(g(n))来表示这种关系。需要注意的是不能写为 X(g(n)) = f(n)\)<br>
一般来说，当渐近记号出现在某个公式中时，我们将其解释为一个不在乎其名称的匿名函数。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">1.2</span> 递归式</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">1.2.1</span> 代换法</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>用代换法解递归式需要两个步骤：<br>
<ol class="org-ol">
<li>猜测解的形式<br></li>
<li>用数学归纳法找出使解真正有效的常数。<br></li>
</ol></li>
<li>使用数学归纳法进行证明的步骤<br>
<ol class="org-ol">
<li>证明当 m=1 时命题成立。<br></li>
<li>假设 m=n 时命题成立，推导出在 m=n+1 时命题也成立。（n 代表任意自然数）<br></li>
</ol></li>
</ul>
</div>
<ol class="org-ol"><li><a id="orgheadline8"></a>实例<br><div class="outline-text-5" id="text-1-2-1-1">
<ul class="org-ul">
<li><p>
求递归式 \(T(n) = 2T(\biggl\lfloor \frac{n}{2} \biggr\rfloor) + n\)<br>
</p>
\begin{align}  
&-\quad Step 1\, 猜测解的形式        \nonumber\\ 
&猜测\quad T(n) = O(nlgn),即存在常数 c 和 n_0 使得 T(n)的值都在 nlgn 之下 \nonumber\\ 
&-\quad Step 2\, 使用数学归纳法证明    \nonumber\\ 
&-\quad Step 2.1\, 证明 m=2,3 时成立 \nonumber\\ 
&n=1 时，T(1) = 2*0 + 1 > clg1 = 0     \, &(无论 c 取何值都不成立)    \nonumber\\ 
&n=2 时，T(2) = 2*1 + 2 = 4 \leq 2c    \, &(c\geq2 时成立) \nonumber\\ 
&n=3 时，T(3) = 2*1 + 3 = 5 \leq 3clg3 \, &(c\geq2 时成立) \nonumber\\ 
&-\quad Step 2.2\, 假设 n=\frac{k}{2}成立，证明 n = k 时也成立 \nonumber\\ 
&依据假设有 T(\frac{k}{2}) \leq c\frac{k}{2}lg\frac{k}{2}           \nonumber\\
&T(k) = 2T(\biggl\lfloor \frac{k}{2} \biggr\rfloor) + k \leq 2c\frac{k}{2}lg\frac{k}{2} + k \nonumber\\
&T(k) \leq cklg\frac{k}{2} + k = cklgk - ck + k <= 1="" 2="" cklgk="" \quad="" (c\geq="" 时成立)="" \nonumber\\="" &所以，当取="" c="" \geq="" 时，t(n)="" \leq="" cnlgn。即="" t(n)="O(nlgn)" \end{align}<="" li="">
<li><p>
求递归式 \(T(n) = 2T(n-1) + 1 \quad (n>0) \quad T(0) = 0\)<br>
</p>
\begin{align}  
&-\quad Step 1\, 猜测解的形式        \nonumber\\ 
&猜测\quad T(n) = O(2^n),即存在常数 c 和 n_0 使得 T(n)的值都在 2^n 之下 \nonumber\\ 
&-\quad Step 2\, 使用数学归纳法证明    \nonumber\\ 
&-\quad Step 2.1\, 证明 m=2,3 时成立 \nonumber\\ 
&n=1 时，T(1) = 2*0 + 1 = 1 \leq c2^1 \, &(c\geq1 时成立)    \nonumber\\ 
&n=2 时，T(2) = 2*1 + 1 = 3 \leq c2^2 \, &(c\geq1 时成立) \nonumber\\ 
&n=3 时，T(3) = 2*3 + 1 = 7 \leq c2^3 \, &(c\geq1 时成立) \nonumber\\ 
&-\quad Step 2.2\, 假设 n=k-1 时成立，证明 n = k 时也成立 \nonumber\\ 
&依据假设有 T(k-1) \leq c2^{k-1}                      \nonumber\\
&T(k) = 2T(k-1) + 1 \leq 2c2^{k-1} + 1             \nonumber\\
&T(k) \leq c2^k+1                                  \nonumber\\ 
&T(k) \leq c2^k (c\geq 2 时成立)                     \nonumber\\ 
&所以，当取 c \geq 2 时，T(n) \leq c2^n。即 T(n) = O(2^n)
\end{align}</li>
</=></li></ul>
</div></li></ol>
</div>
<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10"><span class="section-number-4">1.2.2</span> 递归树方法</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
如下图利用递归树方法求解 \(T(n) = 2T(n/4) + c n ^2\)<br>
<img src="Img_recursion_tree.jpg"><br>
</p>
\begin{align}  
T(n) &= cn^2 + \frac{3}{16}cn^2 + {\frac{3}{16}}^2cn^2 + \ldots + {\frac{3}{16}}^{log_4(n-1)}cn^2 + \Theta(n^{log_43}) \nonumber\\ 
& = \sum_{i=0}^{log_4n-1}(\frac{3}{16})^icn^2 + \Theta(n^{log_43})\nonumber\\ 
& = \frac{(3/16)^{log_4n}-1}{(3/16)-1}cn^2+\Theta(n^{log_43})     \nonumber\\ 
T(n) & < \sum_{i=0}^{\infty}(\frac{3}{16})^icn^2 + \Theta(n^{log_43})\nonumber\\ 
& = \frac{1}{1-(3/16)}cn^2+\Theta(n^{log_43})     \nonumber\\ 
& = \frac{16}{13}cn^2+\Theta(n^{log_43})          \nonumber\\ 
& = O(n^2)
\end{align}
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">1.2.3</span> 主方法</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
主方法是递归树的一种应用。可以通过递归树来证明主方法。主方法所依赖的主定理如下：<br>
</p>
\begin{align}  
&设 a \geq 1 和 b > 1 为常数，设 f(n)为一个函数，T(n)在非负整数上通过下列递归式来定义       \nonumber \\
&T(n) = aT(n/b) + f(n)                                                      \nonumber \\
&其中 n/b 为\biggl\lfloor n/b \biggr\rfloor 或  \biggl\lceil n/b \biggr\rceil,那么 T(n)有下列的渐近边界： \nonumber \\
&(1) \; 若对于某常数\epsilon >0,有 f(n)=O(n^{log_ba-\epsilon}),则 T(n) = \Theta(n^{log_ba}) \nonumber \\
&(2) \; 若 f(n) = \Theta(n^{log_ba}),则 T(n) = \Theta(n^{log_ba}lgn) \nonumber \\
&(3) \; 若对于某常数\epsilon >0,有 f(n)=\Omega(n^{log_ba+\epsilon}),且对常数 c<1 与足够大的="" n="" 有="" af(n="" b)="" \leq="" cf(n),则="" t(n)="\Theta(f(n))\nonumber" \\="" \end{align}="" <="" div="">
</1></div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.3</span> 概率分析和随机算法</h3>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-2">
<h2 id="orgheadline29"><span class="section-number-2">2</span> Sorting and Order Statistics</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">2.1</span> 堆排序</h3>
<div class="outline-text-3" id="text-2-1">
<p>
二叉堆在数组中构建的二叉树结构。其主要操作以及对应的时间复杂度如下：<br>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left">

<col class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Heapify</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapBuild</td>
<td class="org-left">\(O(nlgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapInsert</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapDelete</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapExtract</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapSort</td>
<td class="org-left">\(O(nlgn)\)</td>
</tr>
</tbody>
</table>

<p>
堆相关代码实现请参考如下文件<br>
<a href="Code_Heap.lua">Code_Heap.lua</a><br>
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">2.2</span> 快速排序</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>快速排序采用了分治法<br></li>
<li>快速排序是一种原地排序，不需要额外空间<br></li>
</ul>
</div>
<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16"><span class="section-number-4">2.2.1</span> 快速排序分析</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li><p>
当数据已经升序或降序拍好时，快速排序出现最坏情况<br>
</p>
\begin{align}
 T(n) &= T(0) + T(n-1) + O(n)  \nonumber \\
 &= O(1) + T(n-1) + O(n)       \nonumber \\
 &= T(n-1) + O(n)              \nonumber \\
 &= O(1) +  O(2) + \ldots + O(n-1) + O(n)              \nonumber \\
 &= O(n^2)                     \nonumber \\
 \end{align}</li>
<li><p>
当每次划分都在中间时<br>
</p>
      \begin{align}
T(n) &= 2T(n/2)  \nonumber \\
&= O(1) + T(n-1) + O(n)       \nonumber \\
&= O(nlog_2n)                 \nonumber \\
\end{align}</li>
<li><p>
假设每次划分都为 1/10 9/10<br>
</p>
\begin{align}
&T(n) = T(\frac{n}{10}) + T(\frac{n9}{10}) + O(n) \nonumber \\
&T(n) = knlog_{\frac{10}{9}}n + O(n) \nonumber \\
&T(n) = O(nlogn)                   \nonumber \\
\end{align}</li>
<li><p>
假设一步划分最优，一步划分最坏<br>
</p>
\begin{align}
&L(n) = 2U(n/2) + O(n)       \nonumber \\
&U(n) = L(n-1) + O(n)        \nonumber \\
&L(n) = 2(L(\frac{n}{2}-1) + O(\frac{n}{2})) + O(n) \nonumber \\
&L(n) = 2L(\frac{n}{2}-1) + O(n) \nonumber \\
&L(n) = O(nlogn)                 \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">2.2.2</span> 快速排序实现</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-lua"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">Partition</span>(arr, p, q)
    i = p
    <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">j</span>=p+1,q <span style="color: #00ffff;">do</span>
        <span style="color: #00ffff;">if</span> arr[j] &lt;= arr[p] <span style="color: #00ffff;">then</span>
            exchange(arr[i],arr[j])
            i++
        <span style="color: #00ffff;">end</span>
    <span style="color: #00ffff;">end</span>
    exchange(arr[i],arr[p])
    <span style="color: #00ffff;">return</span> i
<span style="color: #00ffff;">end</span>
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">QuickSort</span>(arr, p, q)
    <span style="color: #00ffff;">if</span> p&lt;0 <span style="color: #00ffff;">or</span> p&gt;=q <span style="color: #00ffff;">then</span>
        <span style="color: #00ffff;">return</span>
    <span style="color: #00ffff;">end</span>

    i = Partition(arr, p, q)
    QuickSort(arr, p, i-1)
    QuickSort(arr, i+1, q)
<span style="color: #00ffff;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19"><span class="section-number-4">2.2.3</span> 随机快速排序</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
每一次划分之前，将主元素和一个随机的元素交换。<br>
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline18"></a>随机快速排序分析<br><div class="outline-text-5" id="text-2-2-3-1">
<p>
随机快速排序的时间复杂度为 \(O(nlogn)\)<br>
</p>
</div></li></ol>
</div>
<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20"><span class="section-number-4">2.2.4</span> 随机快速排序实现</h4>
<div class="outline-text-4" id="text-2-2-4">
<div class="org-src-container">

<pre class="src src-lua"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">Partition</span>(arr, p, q)
    exchange(arr[p], arr[random(p,q)])
    i = p
    <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">j</span>=p+1,q <span style="color: #00ffff;">do</span>
        <span style="color: #00ffff;">if</span> arr[j] &lt;= arr[p] <span style="color: #00ffff;">then</span>
            exchange(arr[i],arr[j])
            i++
        <span style="color: #00ffff;">end</span>
    <span style="color: #00ffff;">end</span>
    exchange(arr[i],arr[p])
    <span style="color: #00ffff;">return</span> i
<span style="color: #00ffff;">end</span>
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">QuickSort</span>(arr, p, q)
    <span style="color: #00ffff;">if</span> p&lt;0 <span style="color: #00ffff;">or</span> p&gt;=q <span style="color: #00ffff;">then</span>
        <span style="color: #00ffff;">return</span>
    <span style="color: #00ffff;">end</span>

    i = Partition(arr, p, q)
    QuickSort(arr, p, i-1)
    QuickSort(arr, i+1, q)
<span style="color: #00ffff;">end</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">2.3</span> 线性时间排序</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">2.3.1</span> 比较排序的下界</h4>
</div>
<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23"><span class="section-number-4">2.3.2</span> 计数排序</h4>
</div>
<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">2.3.3</span> 基数排序</h4>
</div>
<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">2.3.4</span> 桶排序</h4>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">2.4</span> 中位数和顺序统计</h3>
</div>
<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28"><span class="section-number-3">2.5</span> Sorting implement</h3>
<div class="outline-text-3" id="text-2-5">
<p>
关于各种排序相关算法的实现，可以参考如下文件：<br>
<a href="Code_Heap.lua">Code_Heap.lua</a><br>
<a href="Code_Sort.lua">Code_Sort.lua</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline71" class="outline-2">
<h2 id="orgheadline71"><span class="section-number-2">3</span> DataStructure</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">3.1</span> Stack Queue</h3>
<div class="outline-text-3" id="text-3-1">
<p>
栈                后进先出<br>
队列                先进先出<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32"><span class="section-number-3">3.2</span> LinkList</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31"><span class="section-number-4">3.2.1</span> 单链表倒序</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Reverse</span> (<span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">list</span>)
{
    <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">pre</span> = null;
    <span style="color: #00ffff;">while</span>(list)
    {
        <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">next</span> = list.next;
        list.next = pre;
        pre = list;
        list = next;
    }
    <span style="color: #00ffff;">return</span> pre;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">3.3</span> SkipList</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34"><span class="section-number-4">3.3.1</span> SkipList 时间复杂度分析</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>两层的 SkipList<br>
对于包含 n 个元素，只有两层的 SkipList，时间消耗为 \(T(n) = |L_1| + \frac{n}{|L_1|} \quad 当|L_1| = \frac{n}{|L_1|}时，取到最小值，即 |L_1|=\sqrt{n}，所以 T(n) = 2\sqrt{n}\)<br></li>
<li>三层的 SkipList<br>
三层 SkipList，因为每层最多需要遍历 \(\sqrt[3]{n}\) 个元素， 所以时间消耗为 \(T(n) = 3\sqrt[3]{n}\)<br></li>
<li>\(log_2n\) 层的 SkipList<br>
当 SkipList 取 \(log_2n\) 层时，SkipList 最优。此时时间消耗为 \(T(n) = log_2n\sqrt[log_2n]{n} = 2log_2n\)<br></li>
</ul>
</div>
<ol class="org-ol"><li><a id="orgheadline33"></a>SkipList 高概率最优<br><div class="outline-text-5" id="text-3-3-1-1">
<p>
对于 n 个节点的 SkipList，每次查找元素的时间消耗高概率为 \(O(lgn)\)<br>
</p>
</div></li></ol>
</div>
<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35"><span class="section-number-4">3.3.2</span> SkipList 高度分析</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
对每层来说，一个节点会向上增长的概率为 \(\frac{1}{2}\) ，则第 m 层向上增长的概率为 \(\frac{1}{2^m}\)<br>
底层一共有 n 个元素，上升到 m 层时，m 层元素数目的期望为 \(E[C_m] = n\frac{1}{2^m} = \frac{n}{2^m}\)<br>
令 \(E[C_m] \leq 1 则 \frac{n}{2^m} \leq 1 即 n \leq 2^m 所以 lgn \leq m\)<br>
即 当 \(m \geq lgn\) 时，m 层的元素数目小于 1，即 m 层不存在元素了。<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36"><span class="section-number-4">3.3.3</span> SkipList Maintain</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>插入节点<br>
插入新节点的时候随机一个 1 到 100 的数字 randomV，如果 randomV 大于 50，则将这个数提升到更高层的表中，对这个节点继续执行前面的随机操作。<br></li>
<li>删除节点<br>
删除节点的时候，如果该节点在多层中出现，则直接将其在出现的层中都删除掉。<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">3.4</span> Tree</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>对于二叉树，每一个树的节点用 p,l,r,data 分别表示 指向父亲节点的指针， 指向左孩子的指针，指向右孩子的指针，节点的数据。<br></li>
<li>对于非二叉树，和二叉树同理，每个树的节点用 p,child1,child2 &#x2026; childn,data 来表示。因为可能有的节点有 n 个孩子，而有的节点只有 1 个或没有孩子, 所以这种方法对于有多个可变数目孩子的树来说会造成空间的浪费。<br></li>
<li>还有一种树的表示形式是，每个树的节点用 p,lChild,rSibling 来表示。这样就不会造成空间的浪费了。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-3">
<h3 id="orgheadline57"><span class="section-number-3">3.5</span> Hash Table</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">3.5.1</span> 直接寻址表 Direct-address table</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
<img src="Img_direct-address-table.jpg"><br>
缺点：<br>
</p>
<ul class="org-ul">
<li>如果关键字的全域 U 很大时，由于内存大小限制，无法在计算机中存储 U 中所有元素。<br></li>
<li>如果关键字的全域 U 和实际关键字集合相差很大时，存储 U 中所有元素会造成很多空间浪费。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline42" class="outline-4">
<h4 id="orgheadline42"><span class="section-number-4">3.5.2</span> 散列表 Hash table</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
散列函数 h 将关键字 k 散列到一个小范围域内，从而减弱直接寻址表缺点的影响。<br>
<img src="Img_hash-table.jpg"><br>
缺点：<br>
有可能不同的关键字会被 h 函数散列到同一槽上。这种情况被称为发生了碰撞。<br>
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline41"></a>链接法解决碰撞<br><div class="outline-text-5" id="text-3-5-2-1">
<p>
这种方法将 hash 值相同的元素，用链表存储。<br>
通过 hash 表查找某个元素 ki 的算法如下：<br>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Find</span>(hashTable, ki)
{
    <span style="color: #98fb98;">var</span> <span style="color: #eedd82;">hashValue</span> = h(ki);
    <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">list</span> = hashTable[hashValue];
    <span style="color: #00ffff;">while</span> (list)
    {
        <span style="color: #00ffff;">if</span> (list.key == ki)
        {
            <span style="color: #00ffff;">return</span> list.data
        }
        list = list.next;
    }
    <span style="color: #00ffff;">return</span> null;
}
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="orgheadline40"></a>装载因子<br><div class="outline-text-6" id="text-3-5-2-1-1">
<p>
给定一个能存放 n 个元素的、具有 m 个槽位的散列表 T，定义 T 的装载因子 \(\alpha\) 为 n/m，即一个链中平均存储的元素数。<br>
</p>
</div></li></ol></li></ol>
</div>
<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51"><span class="section-number-4">3.5.3</span> 散列函数</h4>
<div class="outline-text-4" id="text-3-5-3">
</div><ol class="org-ol"><li><a id="orgheadline43"></a>好的散列函数的特点<br><div class="outline-text-5" id="text-3-5-3-1">
<p>
散列函数应该尽可能让关键字平均分配到不同的槽上，这样可以保证碰撞发生的概率最小。<br>
</p>
</div></li>
<li><a id="orgheadline44"></a>将关键字解释为自然数<br><div class="outline-text-5" id="text-3-5-3-2">
<p>
例如，一个字符串关键字可以被解释为按适当的基数几号表示的整数。pt 可以被解释为十进制整数对(112,116),因为 ASCII 字符集中，p 为 112，t 为 116。按照 128 为基数来表示，pt = 112*128+126 = 14452；<br>
</p>
</div></li>
<li><a id="orgheadline45"></a>除法散列法<br><div class="outline-text-5" id="text-3-5-3-3">
\begin{equation}  
h(k) = k\ mod\ m;
\end{equation}
<p>
除法散列中，需要注意 m 的选择。例如，当 m 为 \(2^p\) 时，h(k)的值为 k 的 p 个最低位数字。<br>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-right">

<col class="org-right">

<col class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">公式</th>
<th scope="col" class="org-right">被取模数的二进制</th>
<th scope="col" class="org-right">结果的二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">8%7</td>
<td class="org-right">1000</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-right">9%7</td>
<td class="org-right">1001</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-right">10%7</td>
<td class="org-right">1010</td>
<td class="org-right">011</td>
</tr>

<tr>
<td class="org-right">11%7</td>
<td class="org-right">1011</td>
<td class="org-right">100</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">8%8</td>
<td class="org-right">1000</td>
<td class="org-right">000</td>
</tr>

<tr>
<td class="org-right">9%8</td>
<td class="org-right">1001</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-right">10%8</td>
<td class="org-right">1010</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-right">11%8</td>
<td class="org-right">1011</td>
<td class="org-right">011</td>
</tr>
</tbody>
</table>
<p>
从上表可以看出，当选择 \(m=2^3=8\) 时，他们之间有数据排布关系，h(k)的值为 k 的 p 个最低位数字。而当选择 \(m=7\) 时，则没有这种关系。<br>
m 通常选为和 2 的整数幂不太接近的指数。<br>
</p>
</div></li>
<li><a id="orgheadline46"></a>乘法散列法<br><div class="outline-text-5" id="text-3-5-3-4">
\begin{align}  
h(k) = \biggl\lfloor m(kA\: \: mod \:\:  1) \biggr\rfloor \quad (0\,< A\,< 1)
\end{align}  
<p>
乘法散列的优点是，它对 m 的选择没有特别的要求。但是，一般会选择 \(m=2^p\) ，因为这样方便实现散列函数。<br>
</p>
</div></li>
<li><a id="orgheadline50"></a>全域散列 Universal hashing<br><ol class="org-ol"><li><a id="orgheadline47"></a>定义<br><div class="outline-text-6" id="text-3-5-3-5-1">
<p>
随机地选择散列函数，使之独立于要存储的关键字，这种方法被称作全域散列。严格的定义如下：<br>
设 H 为有限的一组散列函数，它将给定的关键字域 U 映射到{0,1,&#x2026;&#x2026;,m-1}中。如果对于每一个不同的关键字 \(k,l \in U\) ，满足 \(h(k)=h(l)\) 的散列函数 \(h \in H\) 的个数至多为 \(|H| / m\) 。那么就称这样的一个函数组是全域的。<br>
\(|H|\) 为集合 H 中函数的个数。上面定义的另一种解释是，如果从 H 中随机取一个散列函数，当关键字 \(k \neq l\) 时，两者发生碰撞的概率 \(P(h(k)=h(l)) \leq \frac{|H|/m}{|H|}\) ， \(\frac{|H|/m}{|H|} = \frac{1}{m}\) 。<br>
</p>
</div></li>
<li><a id="orgheadline48"></a>定理 1<br><div class="outline-text-6" id="text-3-5-3-5-2">
<p>
如果 h 选自一组全域的散列函数，并用于将 n 个关键字散列到一个大小为 m 的用链接法解决碰撞的表 T 中。如果关键字 k 不在链表中，k 被散列至其中的链表的期望长度 \(E(n_{h(k)}) \leq \alpha=\frac{n}{m}\) (说明： \(n_{h(k)}\) 为链表 T[h(k)]的长度)。如果关键字 k 在链表中，则包含关键字 k 的链表的期望长度 \(E(n_{h(k)}) \leq 1+\alpha = 1+\frac{n}{m}\) <br>
也就是说使用全域的散列函数，可以将 key 均匀地散列到各个链表中。<br>
</p>
<ul class="org-ul">
<li><p>
证明<br>
定义指示器随机变量如下<br>
</p>
\begin{eqnarray}
c_{kl} = c\{h(k)=h(l)\} =
\begin{cases}
1   & h(k)=h(l) \\
0   & h(k) \leq h(l) \\
\end{cases} \nonumber
\end{eqnarray}
<p>
根据全域散列函数定义 \(Pr\{h(k)=h(l)\} \leq 1/m\) ，即 \(E[c_{kl}] \leq 1/m\) 。<br>
定义随机变量 \(C_k\) ，它表示对于每个关键字 k，非 k 的、和 k 散列到同一槽位中的其他关键字的数目。<br>
</p>
\begin{equation}  
C_k = \sum_{l \in T \, l \neq k}c_{kl} \nonumber
\end{equation}
<p>
从而有：<br>
</p>
\begin{equation}
E[C_k] = E[\sum_{l \in T \, l \neq k}c_{kl}] = \sum_{l \in T \, l \neq k}E[c_{kl}] \leq \sum_{l \in T \, l \neq k}\frac{1}{m} = \frac{n-1}{m}
\end{equation}</li>
</ul>
</div></li>
<li><a id="orgheadline49"></a>构造一种全域哈希的一种方案<br><div class="outline-text-6" id="text-3-5-3-5-3">
<p>
设定 m 为素数，用 m 将关键字 k 分解为 r+1 位数字，即用 m 进制来表示关键字 k。<br>
\(k = \{k_0\,k_1\,k_2\, \ldots \,k_r\}\) 其中 \(0 \leq k_i \leq m-1\)<br>
随机地选择一个数字 \(a=\{a_0\,a_1\,a_2\, \ldots \,a_r\}\) 其中 \(0 \leq a_i \leq m-1\)<br>
</p>
\begin{equation}
h_a(k) = (\sum_{i=0}^{r}a_i k_i) mod m
\end{equation}
<p>
即 \(h_a(k)\) 为 a 和 k 的点积再对 m 取模。<br>
这样构造出来的全域哈希函数组中一共有 \(m^{r+1}\) 个哈希函数，因为 a 一共有 r+1 位，每一位可以有 m 种选择。<br>
</p>
<ul class="org-ul">
<li><p>
证明<br>
\(x = \{x_0\,x_1\,x_2\, \ldots \,x_r\}\) 其中 \(0 \leq x_i \leq m-1\)<br>
\(y = \{y_0\,y_1\,x_2\, \ldots \,y_r\}\) 其中 \(0 \leq y_i \leq m-1\)<br>
  假设这两个不同的关键字 x，y 在第 0 位不同。如果哈希函数 \(h_a\) 使 x 和 y 关键字散列到同一个链表中，则有下面等式<br>
</p>
\begin{align}
&h_a(x)=h_a(y) \nonumber \\
&\sum_{i=0}^{r}a_i x_i \equiv \sum_{i=0}^{r}a_i y_i \quad mod \quad m \nonumber \\
&\sum_{i=0}^{r}a_i (x_i-y_i) \equiv 0 \quad mod \quad m \nonumber \\
&a_0(x_0-y_0)+\sum_{i=1}^{r}a_i (x_i-y_i) \equiv 0 \quad mod \quad m \nonumber \\
&a_0(x_0-y_0) \equiv -\sum_{i=1}^{r}a_i (x_i-y_i) \quad mod \quad m \nonumber \\
&\because x_0 \neq y_0 \therefore \exists(x_0-y_0)^{-1} \\
&a_0 \equiv -(\sum_{i=1}^{r}a_i (x_i-y_i))(x_0-y_0)^{-1} \quad mod \quad m \nonumber \\
\end{align}
<p>
所以，对于任意 \(a_1 a_2 \ldots a_r\) 只存在唯一的 \(a_0\) 使得 x 和 y 被散列到同一个链表中。<br>
\(h_a\) 的个数为 \(m*m \ldots *m*1 = m^r = \frac{|H|}{m} = \frac{m^{r+1}}{m}\)<br>
</p></li>
</ul>
</div></li></ol></li></ol>
</div>
<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55"><span class="section-number-4">3.5.4</span> 开放寻址法</h4>
<div class="outline-text-4" id="text-3-5-4">
<p>
在开放寻址法中，所有元素都存储在散列表中。即，每个表项中或存储一个元素，或存储 NIL 值表示不存储任何元素。<br>
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline52"></a>线性探查<br><div class="outline-text-5" id="text-3-5-4-1">
<p>
给定一个散列函数 h': U-&gt;{0,1,&#x2026;,m-1} （该函数被称为辅助散列函数），线性探查使用的散列函数为：<br>
</p>
\begin{equation}
h(k,i) = (h'(k)+i) \, mod \, m \quad i = 0,1,2 \ldots , m-1
\end{equation}
<p>
在线性探查方法中，初始探查位置确定了整个序列，故只有 m 种不同的探查序列。<br>
</p>
<ul class="org-ul">
<li>缺点<br>
线性探查存在一次群集问题。随着时间推移，连续被占用的槽不断增加，平均查找时间也不断随着增加。<br></li>
</ul>
</div></li>
<li><a id="orgheadline53"></a>二次探查<br><div class="outline-text-5" id="text-3-5-4-2">
<p>
二次探查使用的散列函数为：<br>
</p>
\begin{align}
&h(k,i) = (h'(k)+c_1i+c_2i^2) \, mod \, m \quad i = 0,1,2 \ldots , m-1 \nonumber \\
&h'为辅助散列函数，c_1 和 c_2（\neq 0）为辅助常数。\nonumber \\
\end{align}
<ul class="org-ul">
<li>缺点<br>
<ol class="org-ol">
<li>为了充分利用散列表，c1,c2,m 的值选取要受到限制<br></li>
<li>如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的，这种群集详细被称为二次群集。<br></li>
</ol></li>
</ul>
</div></li>

<li><a id="orgheadline54"></a>双重散列<br><div class="outline-text-5" id="text-3-5-4-3">
<p>
双重散列是用于开放寻址法的最好的方法之一，它使用的散列函数为：<br>
</p>
\begin{align}
&h(k,i) = (h_1(k) + ih_2(k)) \, mod \, m \quad i = 0,1,2 \ldots , m-1 \nonumber \\
&h_1 和 h_2 为辅助散列函数。\nonumber \\
\end{align}
<p>
双重散列使用了 \(\Theta(m^2)\) 种探查序列。而线性探查和二次探查都只使用了 m 中探查序列。<br>
</p>

<p>
下面是一组可行的双重散列函数：<br>
</p>
\begin{align}
&h_1(k) = k \, mod \, m  \nonumber \\
&h_2(k) = k \, mod \, m' \nonumber \\
&m 为素数，m' = m - 1 \nonumber \\
\end{align}
</div></li></ol>
</div>
<div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56"><span class="section-number-4">3.5.5</span> 完全散列 Perfect Hashing</h4>
<div class="outline-text-4" id="text-3-5-5">
<p>
给定 n 个关键字，构造一个静态的 hash 表，该表的大小 \(m=O(n)\) ，在最坏的情况下，查询某个关键字的时间复杂度为 \(O(1)\) ，构造出满足这些条件的哈希被称为完全哈希或完美哈希 Perfect Hashing。<br>
构造完美哈希的一种方法是使用两级哈希，并且每一级哈希都为全域哈希。要满足完美哈希就需要第二级全域哈希不会造成冲突。设 \(n_i\) 个关键字被哈希到一级哈希表的第 i 个槽内，在二级哈希表中使用 \(m_i = n_i^2\) 个空间来存储这 \(n_i\) 个元素，则可以使二级哈希不会造成冲突。<br>
</p>
<ul class="org-ul">
<li><p>
证明 1：二级全域哈希不会造成冲突<br>
</p>
\begin{align}
&随机变量 X 表示哈希产生冲突 \nonumber \\
&E[X] = P\{X\} = \frac{n_i(n_i-1)}{2} \frac{1}{n_i^2} = \frac{1-1/n_i}{2} < \frac{1}{2} \nonumber \\
&依据马尔可夫不等式可得： \nonumber \\
&P\{X \geq t\} \leq \frac{E[X]}{t} \nonumber \\
&P\{X \geq 1\} \leq \frac{1/2}{1}  \nonumber \\
&P\{X \geq 1\} \leq \frac{1}{2}    \nonumber \\
\end{align}</li>
<li><p>
证明 2：二级哈希的存储空间复杂度为 \(O(n)\)<br>
  取第一级 hash 表的大小 \(m=n\) ，随机变量 \(n_i\) 表示哈希到第 i 个槽的关键字的数目，在二级哈希表中槽的个数 \(m_i=n_i^2\) 则：<br>
</p>
\begin{align}
&E[totalStorage] = n + E[\sum_{i=0}^{m-1}\theta(n_i^2)] = O(n)    \nonumber
\end{align}</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline60" class="outline-3">
<h3 id="orgheadline60"><span class="section-number-3">3.6</span> Binary Search Trees</h3>
<div class="outline-text-3" id="text-3-6">
<p>
二叉查找树中关键字的存储方式满足以下性质：<br>
设 x 为二叉查找树中的节点。如果 y 是 x 的左子树中的节点，则 key[y]&lt;=key[x]。如果 y 是 x 右子树中的节点，则 key[x]&lt;=key[y]。<br>
</p>
</div>
<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58"><span class="section-number-4">3.6.1</span> 二叉查找树的操作</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
遍历 查找 最大关键字元素和最小关键字元素 前驱和后继 插入和删除<br>
具体实现可以参考如下文件：<br>
<a href="Code_BST.lua">Code_BST.lua</a><br>
</p>
</div>
</div>
<div id="outline-container-orgheadline59" class="outline-4">
<h4 id="orgheadline59"><span class="section-number-4">3.6.2</span> 随机构造的二叉查找树</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
随机二叉查找树高度的期望值为 \(log_2n\)<br>
</p>
<ul class="org-ul">
<li><p>
证明：<br>
step1- 证明 Jensens 不等式<br>
\(f(E[X]) \leq E[f(X)] \quad f(X)为凹函数。\)<br>
step2- 不直接分析 BST 的高度随机变量 \(X_n\) ,而是分析 \(X_n\) 的凹函数，这里分析的是 \(Y_n = 2^{X_n} \, 即 X_n 的指数函数\)<br>
step3- 证明 \(E[Y_n] = O(n^3)\)<br>
step4- 证明结论<br>
</p>
\begin{align}
&2^{E[X_n]} \leq E[2^{X_n}] = E[Y_n] = O(n^3) \nonumber \\
&对上面的公式两边取对数可得: \nonumber \\
&E[X_n] \leq log_2O(n^3) = 3log_2n+O(1) \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61"><span class="section-number-3">3.7</span> Balance Search Trees</h3>
<div class="outline-text-3" id="text-3-7">
<p>
平衡搜索树的数据结构维护一个 n 个元素的动态集的时间为 \(log_2n\) ，树的高度为 \(O(log_2n)\)<br>
常见的平衡搜索树有：<br>
</p>
<ul class="org-ul">
<li>AVL Trees<br></li>
<li>2-3 Trees<br></li>
<li>2-3-4 Trees<br></li>
<li>B-Trees<br></li>
<li>Red Black Trees<br></li>
<li>Skip lists<br></li>
<li>Treaps<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline66" class="outline-3">
<h3 id="orgheadline66"><span class="section-number-3">3.8</span> Red-Black Trees</h3>
<div class="outline-text-3" id="text-3-8">
<p>
红黑树是一种二叉搜索树，其中每个节点包含一个 color 属性，并且每个节点满足下面的条件<br>
</p>
<ul class="org-ul">
<li>每个节点为红色或者黑色<br></li>
<li>根节点和叶子节点都为黑色<br></li>
<li>每个红色节点的父节点都为黑色 即每个红色节点的两个子节点都为黑色节点<br></li>
<li>对于每个节点，从该节点到其子孙节点(叶子节点)的所有路径上包含相同数目的黑节点<br></li>
</ul>
</div>
<div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62"><span class="section-number-4">3.8.1</span> RBTree 的高度</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
包含 n 个关键字(内节点)的红黑树，它的高度满足 \(h \leq 2log_2(n+1) = O(log_2n)\)<br>
</p>
<ul class="org-ul">
<li><p>
证明<br>
将每个红节点并入它的黑色父节点中，会形成一个 2-3-4 树。<br>
</p>
<ol class="org-ol">
<li>2-3-4 树的每一个内节点中包含 2-4 个子节点<br></li>
<li>2-3-4 树的所有叶子节点有相同的深度，该深度等于叶子节点的黑高度<br></li>
</ol>
<p>
假设 生成的该 2-3-4 树的高度为 \(h'\) ，平衡二叉树外节点的个数比所有内节点个数多 1，所以，原来红黑树的外节点数为 \(n+1\) ，所以，该 2-3-4 树的叶子节点的个数 \(leaves = n+1\) 。<br>
</p>
\begin{align}
&而叶子节点的个数满足下面不等式： \nonumber \\
&2^{h'} \leq leaves \leq 4^{h'}  \nonumber \\
&2^{h'} \leq n+1                 \nonumber \\
&h' \leq log_2(n+1)              \nonumber \\
&h \leq 2h' \leq 2log_2(n+1)     \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63"><span class="section-number-4">3.8.2</span> RBTree Insert</h4>
<div class="outline-text-4" id="text-3-8-2">
<div class="org-src-container">

<pre class="src src-lua"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">RBTree_Insert</span>(T, x)
    Tree_Insert(T, x)
    color[x] = RED
    <span style="color: #00ffff;">while</span> x!=root[T] <span style="color: #00ffff;">and</span> color[p[x]]==RED <span style="color: #00ffff;">do</span>
        <span style="color: #00ffff;">if</span> p[x] == left[p[p[x]]] <span style="color: #00ffff;">then</span>    <span style="color: #ff0000;">-- </span><span style="color: #ff0000;">case A x &#30340;&#29238;&#20146;&#20026;&#24038;&#33410;&#28857;</span>
            y = right[p[p[x]]]
            <span style="color: #00ffff;">if</span> color[y] == RED <span style="color: #00ffff;">then</span>       <span style="color: #ff0000;">-- </span><span style="color: #ff0000;">case A-1 x &#30340;&#21460;&#21460;&#20026;&#32418;&#33394;</span>
                color[p[x]] = BLACK
                color[y] = BLACK
                color[p[p[x]]] = RED
                x = p[p[x]]
            <span style="color: #00ffff;">elseif</span> x == right[p[x]] <span style="color: #00ffff;">then</span> <span style="color: #ff0000;">-- </span><span style="color: #ff0000;">case A-2 x &#30340;&#21460;&#21460;&#20026;&#40657;&#33394;&#65292;&#24182;&#19988; x &#20026;&#21491;&#33410;&#28857;</span>
                x = p[x]
                LEFT-Rotate(T,x)
            <span style="color: #00ffff;">end</span>

            <span style="color: #ff0000;">-- </span><span style="color: #ff0000;">x == left[p[x]]           -- case A-3 x &#30340;&#21460;&#21460;&#20026;&#40657;&#33394;&#65292;&#24182;&#19988; x &#20026;&#24038;&#33410;&#28857;</span>
            color[p[x]] = BLACK
            color[p[p[x]]] = RED
            RIGHT-Rotate(T,p[p[x]])
        <span style="color: #00ffff;">else</span> <span style="color: #ff0000;">-- </span><span style="color: #ff0000;">p[x] == right[p[p[x]]]   -- case B</span>
            <span style="color: #b0c4de;">print</span>(<span style="color: #ffa07a;">"same as case A"</span>)
        <span style="color: #00ffff;">end</span>
    <span style="color: #00ffff;">end</span>
    color[root[T]] = BLACK
<span style="color: #00ffff;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64"><span class="section-number-4">3.8.3</span> <span class="todo TODO">TODO</span> RBTree Delete</h4>
<div class="outline-text-4" id="text-3-8-3">
<div class="org-src-container">

<pre class="src src-lua"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">RBTree_Delete</span>(T,x)
<span style="color: #00ffff;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">3.8.4</span> Red-Black Tree 实现</h4>
<div class="outline-text-4" id="text-3-8-4">
<p>
具体实现参考下面文件：<br>
<a href="Code_RBT.lua">Code_RBT.lua</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline70" class="outline-3">
<h3 id="orgheadline70"><span class="section-number-3">3.9</span> Augmenting Data Structures</h3>
<div class="outline-text-3" id="text-3-9">
</div><div id="outline-container-orgheadline67" class="outline-4">
<h4 id="orgheadline67"><span class="section-number-4">3.9.1</span> 动态顺序统计</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
用扩展的红黑树来实现动态顺序统计，OS-Select 和 OS-Rank 的时间复杂度为 \(lg(n)\) .<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68"><span class="section-number-4">3.9.2</span> 为什么不在红黑树中直接记录节点的秩？</h4>
<div class="outline-text-4" id="text-3-9-2">
<p>
秩 即为元素在序列中的顺序值。<br>
因为这样做的话，添加或删除节点，需要修改很多节点的秩，这样维护红黑树的时间复杂度为 \(O(n)\) 。<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline69" class="outline-4">
<h4 id="orgheadline69"><span class="section-number-4">3.9.3</span> 数据结构扩展</h4>
<div class="outline-text-4" id="text-3-9-3">
<p>
数据结构扩展的 4 个步骤：<br>
</p>
<ol class="org-ol">
<li>选择基础数据结构<br></li>
<li>确定要在基础数据结构中添加哪些信息<br></li>
<li>验证可用基础数据结构上的基本修改操作来维护这些添加的信息<br></li>
<li>设计新的操作。<br></li>
</ol>

<p>
以动态顺序统计为例来说，整个过程为以下步骤：<br>
</p>
<ol class="org-ol">
<li>选择红黑树来作为基础数据结构<br></li>
<li>在基础数据结构中添加额外的 size[x] 信息，size 为以 x 节点为根的子树的节点数目<br></li>
<li>插入-删除-节点旋转等操作对新加的 size 信息是可维护的。<br>
[重新实现这些修改操作，来支持对 size 信息的维护]<br></li>
<li>设计新的操作：OS-Select 和 OS-Rank。<br></li>
</ol>

<p>
以区间树为例来说，整个过程为以下步骤：<br>
</p>
<ol class="org-ol">
<li>选择红黑树来作为基础数据结构。在基础数据结构中存储区间信息，并以区间的低端点作为节点的关键字<br></li>
<li>在基础数据结构中添加额外的 max[x]信息，max[x]为以 x 节点为根的子树中端点最大的数值。<br></li>
<li>重新实现这些修改操作，来支持对 max 信息的维护<br></li>
<li>设计新的操作：Interval_Search(T, i)<br></li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline85" class="outline-2">
<h2 id="orgheadline85"><span class="section-number-2">4</span> Advanced Design And Analysis Techniques</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline78" class="outline-3">
<h3 id="orgheadline78"><span class="section-number-3">4.1</span> 动态规划法</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-orgheadline72" class="outline-4">
<h4 id="orgheadline72"><span class="section-number-4">4.1.1</span> 动态规划的特征</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>最优子结构<br>
      如果问题的一个最优解包含子问题的最优解，就称该问题具有最优子结构。<br>
例如： 如果 z = LCS(x,y)，那么任何 z 序列的前缀也是 x 序列前缀和 y 序列前缀的最长公共子序列<br></li>
<li>重叠子问题，一个递归的过程包含少数独立的子问题被反复计算多次。<br></li>
<li>在动态规划法中，每一步都要做出选择，但是这些选择依赖于子问题的解。因此，解动态规划问题一般是自底向上，从小子问题处理至大子问题。这样可以避免子问题被反复计算。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline73" class="outline-4">
<h4 id="orgheadline73"><span class="section-number-4">4.1.2</span> 找寻最优子结构的模式</h4>
<div class="outline-text-4" id="text-4-1-2">
<ol class="org-ol">
<li>问题的一个解可以是做一个选择。做这种选择会得到一个或多个有待解决的子问题。<br></li>
<li>假设对一个给定的问题，已知的是一个可以导致最优解的选择。不必关心如何确定这个选择，尽管假定它是已知的。<br></li>
<li>在已知这个选择后，要确定哪些子问题会随之发生，以及如何最好地描述所得到的子问题空间。<br>
描述子问题空间的一个有效经验是，尽量保持这个空间简单，然后在需要时再扩充它。<br>
      在装配线调度问题中，我们所考虑的子问题空间就是从工厂入口通过装配站 \(S_{1,j}和 S_{2,j}\) 的最快路线。这个子问题空间很合适，因而没必要再去尝试一个更具一般性的子问题空间了。<br>
在矩阵链乘积问题中，<br></li>
<li>利用 cut-and-paste 技术，来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline74" class="outline-4">
<h4 id="orgheadline74"><span class="section-number-4">4.1.3</span> 动态规划算法的设计步骤</h4>
<div class="outline-text-4" id="text-4-1-3">
<ol class="org-ol">
<li>描述最优解的结构。即寻找最优子结构，利用子问题的最优解来构造原问题的一个最优解。<br></li>
<li>递归定义最优解的值。<br></li>
<li>按自底向上计算最优解的值。<br></li>
<li>由计算出的结果构造一个最优解。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline77" class="outline-4">
<h4 id="orgheadline77"><span class="section-number-4">4.1.4</span> 最长公共子序列</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
有两个序列 x[1&#x2026;m] y[1&#x2026;n], (1) 求这两个序列的最长公共子序列之一的长度 (2) 输出所有最长公共子序列<br>
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline75"></a>穷举法<br><div class="outline-text-5" id="text-4-1-4-1">
<p>
取 x[1&#x2026;m]的所有子序列，分别遍历 y[1&#x2026;n]来查看是否该子序列是公共子序列，记录下当前最长的所有公共子序列。遍历完之后，依次输出。<br>
</p>
<ul class="org-ul">
<li>算法分析<br>
每次遍历 y[1&#x2026;n]的消耗为 n，x[1&#x2026;m]一共有 \(2^m\) 个子序列，所以总的时间消耗为 \(n2^m\)<br></li>
</ul>
</div></li>
<li><a id="orgheadline76"></a>动态规划法<br><div class="outline-text-5" id="text-4-1-4-2">
<p>
定义 \(LCS(x,y)\) 为序列 x 和 y 的最长公共子序列之一<br>
定义 \(|S|\) 为 \(S\) 序列的长度<br>
定义 \(c[i,j] = |LCS(x[1,i],y(1,j))|\)<br>
则 \(c[m,m] = |LCS(x,y)|\)<br>
</p>
\begin{eqnarray}
c[i,j] =
\begin{cases}
c[i-1,j-1]+1              & if \, x[i]==y[j] \\
max(c[i,j-1], c[i-1,j])   & other \, cases   \\
\end{cases} \nonumber
\end{eqnarray}
<ul class="org-ul">
<li>最坏情况分析<br>
取上面的递归公式中最耗时的部分 \(c[i,j] = max(c[i,j-1], c[i-1,j])\) ，将其转化为递归树，可以计算出树的高度为 $m+n$，这个树的节点数目为 \(2^{m+n}\)<br></li>
<li>子问题被重复计算<br>
LCS 问题的子问题空间包含 \(m*n\) 个独立的子问题(c[i,j]一共有 m*n 种组合)，而在最坏情况分析中，一共需要解决的问题数目为  \(2^{m+n}\) ，可以通过记录已经求解过的问题的结果来避免重复的计算。<br>
使用平摊分析可以得出采用记录求解过的问题结果后，LCS 的时间复杂度为 \(O(n*m)\)<br></li>
</ul>
</div></li></ol>
</div>
</div>
<div id="outline-container-orgheadline80" class="outline-3">
<h3 id="orgheadline80"><span class="section-number-3">4.2</span> 贪心算法</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-orgheadline79" class="outline-4">
<h4 id="orgheadline79"><span class="section-number-4">4.2.1</span> 贪心算法的特征</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>一个全局最优解可以通过局部最优选择来达到。换句话说就是，当我们考虑做选择时，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。<br></li>
<li>在贪心算法中，我们做的总是当前看似最佳的选择，然后再解决选择之后所出现的子问题。贪心算法所做的当前选择可能要依赖于已经做出的所有选择，但不依赖于有待做出的选择或子问题的解。因此，贪心策略通常是自顶先下，一个一个地做出贪心选择，不断地将给定的问题实例归约为更小的问题。<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline84" class="outline-3">
<h3 id="orgheadline84"><span class="section-number-3">4.3</span> 平摊分析</h3>
<div class="outline-text-3" id="text-4-3">
<p>
平摊分析是分析一系列数据结构操作的平均时间消耗。即，n 个操作总的时间消耗为 \(C\) ，则一个操作的的时间消耗为 \(\frac{C}{n}\) 。<br>
</p>
</div>
<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">4.3.1</span> 聚集分析</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
通过求总的时间消耗 \(C\) ，然后除以操作数目 \(n\) 得出每个操作的平摊代价。<br>
\(c = \frac{C}{n}\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline82" class="outline-4">
<h4 id="orgheadline82"><span class="section-number-4">4.3.2</span> 记账方法</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
通过为不同的操作收取不同的费用，操作没有花费掉的费用存入银行，用总价格 \(P\) 减去银行的存款 \(B\) 然后再除以总的操作数 $n$。<br>
\(总的平摊代价 C = P-B\)<br>
\(每个操作的平均平摊代价 c = \frac{P-B}{n}\)<br>
\(在 n 个操作中，令第 i 个操作的实际代价为 c_i,第 i 个操作的平摊代价为\widehat{c_i},则对于 n 个操作的所有序列需要满足 \sum_{i=1}^n\widehat{c_i} \geq \sum_{i=1}^nc_i, 这样总的平摊代价就是实际代价的一个上界。\)<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline83" class="outline-4">
<h4 id="orgheadline83"><span class="section-number-4">4.3.3</span> 势能方法</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
势能方法中不是将已预付的工作作为存储在数据结构特定对象中的存款来表示，而是表示成一种“势能”或“势”，它在需要时可以释放出来，以支付后面的操作。势是与整个数据结构而不是其中的个别对象发生联系的。<br>
\(\widehat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i-1})\)<br>
\(\sum_{i=1}^n\widehat{c_i} = \sum_{i=1}^n(c_i + \Phi(D_i) - \Phi(D_{i-1})) = \sum_{i=1}^nc_i + \Phi(D_i) - \Phi(D_0)\)<br>
如果能定义一个势能函数 \(\Phi\) 使得 \(\Phi(D_i) \geq \Phi(D_0)\) ,则总的平摊代价就是实际代价的一个上界。<br>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline95" class="outline-2">
<h2 id="orgheadline95"><span class="section-number-2">5</span> Graph Algorithms</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline89" class="outline-3">
<h3 id="orgheadline89"><span class="section-number-3">5.1</span> 图的基本算法</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-orgheadline86" class="outline-4">
<h4 id="orgheadline86"><span class="section-number-4">5.1.1</span> 图的表示</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>图的数学描述<br>
G=(V,E) 表示拥有顶点集合 V 和边集合 E 的图 G。|V|表示顶点的数量，|E|表示边的数量<br></li>
<li>邻接矩阵<br>
空间复杂度为 \(|V|^2\)<br>
矩阵中所存储的数值，可用来表示图中边的权值<br></li>
<li>邻接表<br>
如果 G 是一个有向图，则所有邻接表的长度之和为|E|。如果 G 是一个无向图，则所有邻接表的长度之和为 2|E|。不论是有向图还是无向图，邻接表的空间复杂度为 \(O(V+E)\)<br>
当 E 远小于 \(|V|^2\) 时，采用邻接表更省空间。<br>
邻接表中存储的节点可以携带权值，表示当前顶点到该节点的权值大小。<br>
邻接表在需要确定图中边(u,v)是否存在，只能在邻接表 Adj[u]中搜索是否存在 v。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline87" class="outline-4">
<h4 id="orgheadline87"><span class="section-number-4">5.1.2</span> 广度优先搜索</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
广度优先搜索的时间复杂度为 \(O(V+E)\)<br>
搜索过程中，通过给节点上色来避免节点重复被访问<br>
广度优先搜索需要利用队列来保证搜索过程基于广度优先。<br>
</p>
</div>
</div>
<div id="outline-container-orgheadline88" class="outline-4">
<h4 id="orgheadline88"><span class="section-number-4">5.1.3</span> 深度优先搜索</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
深度优先搜索的时间复杂度为 \(O(V+E)\)<br>
搜索过程中，通过给节点上色来避免节点重复被访问<br>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline91" class="outline-3">
<h3 id="orgheadline91"><span class="section-number-3">5.2</span> 最小权生成树</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Minimum Spanning Trees<br>
最小生成树算法 Prim_MST 的思路为 遍历所有顶点，每次取出度最小的节点 NodeMin 进行处理，处理过程中遍历 NodeMin 节点的所有邻接节点为他们更新最小出度值。需要注意的是处理邻接节点时，需要判断邻接节点是否已经被当做 NodeMin 处理过，若是，则不能再次更新其出度。<br>
Prim_MST 的时间复杂度为 \(O(V+E)\)<br>
</p>
</div>
<div id="outline-container-orgheadline90" class="outline-4">
<h4 id="orgheadline90"><span class="section-number-4">5.2.1</span> 应用</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
最小生成树可以用来解决整体耗费最小的问题。如下面所述问题<br>
</p>
<ol class="org-ol">
<li>旅游路线选择<br>
N 个旅游地点都得去，但是要总路费最小。<br></li>
<li>多个城市之间电缆架设等问题<br>
N 个城市都得连接，但是要总的电缆使用最少。<br></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline93" class="outline-3">
<h3 id="orgheadline93"><span class="section-number-3">5.3</span> 最短路径问题</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-orgheadline92" class="outline-4">
<h4 id="orgheadline92"><span class="section-number-4">5.3.1</span> 单源最短路径</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
单源最短路径 Dijkstra 的思路为 从源点开始对图进行广度优先遍历，判断当前顶点的邻接顶点到源点的距离是否比之前记录的距离短，如果是则更新邻接顶点的父节点和其到源点的距离。<br>
Dijkstra_SingleSourceShortestPath 的时间复杂度为 \(O(V+E)\)<br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline94" class="outline-3">
<h3 id="orgheadline94"><span class="section-number-3">5.4</span> Graph Implement</h3>
<div class="outline-text-3" id="text-5-4">
<p>
关于图的各种基础算法的实现，可以参考如下文件：<br>
<a href="Code_Graph.lua">Code_Graph.lua</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline105" class="outline-2">
<h2 id="orgheadline105"><span class="section-number-2">6</span> 数学概念</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgheadline96" class="outline-3">
<h3 id="orgheadline96"><span class="section-number-3">6.1</span> 对数</h3>
<div class="outline-text-3" id="text-6-1">
<p>
对数的性质<br>
</p>
\begin{align}
&1 \quad log_aX + log_aY = log_a(XY)          \nonumber \\
&2 \quad log_aX - log_aY = log_a(\frac{X}{Y}) \nonumber \\
&3 \quad log_aX^b = b\,log_aX                 \nonumber \\
&4 \quad \sqrt[log_an]{n} = a                 \nonumber \\
&5 \quad log_ab = \frac{log_cb}{log_ca}       \nonumber \\
&6 \quad a^{b\,log_an} = (a^{log_an})^b = n^b \nonumber \\
&7 \quad log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
&                                             \nonumber \\
证明 5 \quad &log_ab = \frac{log_cb}{log_ca}     \nonumber \\
&另 log_ab = X               \nonumber \\
&则 a^X = b                  \nonumber \\
&对上面的等式两边取 c 的对数有      \nonumber \\
&log_c(a^X) = log_cb         \nonumber \\
&X\,log_ca = log_cb          \nonumber \\
&X = \frac{log_cb}{log_cx}   \nonumber \\
&所以 \quad \frac{log_cb}{log_ca} = log_ab  \nonumber \\
证明 7 \quad &log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
&log_bn \cdot logb_a = log_ba^{log_bn} \nonumber \\
&log_ba \cdot logb_n = log_bn^{log_ba} \nonumber \\
&所以 \quad log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
\end{align}
</div>
</div>
<div id="outline-container-orgheadline102" class="outline-3">
<h3 id="orgheadline102"><span class="section-number-3">6.2</span> 概率论</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-orgheadline97" class="outline-4">
<h4 id="orgheadline97"><span class="section-number-4">6.2.1</span> 随机试验</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
在概率论中把符合下面三个特点的试验叫做随机试验：<br>
</p>
<ol class="org-ol">
<li>一次试验结果的随机性，即进行一次试验之前无法确定哪一个结果会出现。<br></li>
<li>全体测试结果的可知性，即每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果。<br></li>
<li>可重复性，即可以在同一条件下重复进行试验。<br></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline98" class="outline-4">
<h4 id="orgheadline98"><span class="section-number-4">6.2.2</span> 随机变量</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
设 E 是一个随机试验，其样本空间为 S，若对每一个样本点 \(e \in S\) ，都有唯一确定的实数 X(e) 与之对应，则称 S 上的实值函数 X(e) 是一个随机变量（简记为 X）。<br>
</p>
<ul class="org-ul">
<li>实例一<br>
随机投掷一枚硬币，可能的结果有正面朝上 ，反面朝上两种 ，若定义 X 为投掷一枚硬币时朝上的面 ， 则 X 为一随机变量，当正面朝上时，X 取值 1；当反面朝上时，X 取值 0。<br></li>
<li>实例二<br>
又如，掷一颗骰子，它的所有可能结果是出现 1 点、2 点、3 点、4 点、5 点和 6 点 ，若定义 X 为掷一颗骰子时出现的点数，则 X 为一随机变量，出现 1，2，3，4，5，6 点时 X 分别取值 1，2，3，4，5，6。<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline99" class="outline-4">
<h4 id="orgheadline99"><span class="section-number-4">6.2.3</span> 指示器随机变量</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
给定一个样本空间 S 和事件 A，那么事件 A 对应的指示器随机变量：<br>
</p>
\begin{eqnarray}
X_{a} =
\begin{cases}
1   & 如果 A 发生 \\
0   & 如果 A 没有发生 \\
\end{cases} \nonumber
\qquad E[X_a] = Pr{A} \nonumber
\end{eqnarray}
</div>
</div>
<div id="outline-container-orgheadline100" class="outline-4">
<h4 id="orgheadline100"><span class="section-number-4">6.2.4</span> 期望</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
离散型随机变量的一切可能的取值 xi 与对应的概率 Pi(=xi)之积的和称为该离散型随机变量的数学期望（设级数绝对收敛），记为 E（x）。<br>
设连续性随机变量 X 的概率密度函数为 f(x)，若积分绝对收敛，则称积分的值为随机变量的数学期望，记为 E(X)。<br>
<a href="http://www.zhihujingxuan.com/19043.html" target="_blank" rel="external">http://www.zhihujingxuan.com/19043.html</a><br>
</p>
</div>
</div>
<div id="outline-container-orgheadline101" class="outline-4">
<h4 id="orgheadline101"><span class="section-number-4">6.2.5</span> 马尔可夫不等式证明</h4>
<div class="outline-text-4" id="text-6-2-5">
\begin{align}
&结论： 对于随机变量 X \geq 0, \quad Pr\{X \geq t\} \leq \frac{E[X]}{t} \nonumber \\
&证明： \nonumber \\
E[X] &= \sum_{x=0}^{\infty} x \cdot P_r\{X=x\} \nonumber \\
&\geq \sum_{x=t}^{\infty} x \cdot P_r\{X=x\} \nonumber \\
&\geq \sum_{x=t}^{\infty} t \cdot P_r\{X=x\} \nonumber \\
&= t \cdot P_r\{X \geq t\}
\end{align}
</div>
</div>
</div>
<div id="outline-container-orgheadline104" class="outline-3">
<h3 id="orgheadline104"><span class="section-number-3">6.3</span> 组合数学</h3>
<div class="outline-text-3" id="text-6-3">
</div><div id="outline-container-orgheadline103" class="outline-4">
<h4 id="orgheadline103"><span class="section-number-4">6.3.1</span> <span class="todo TODO">TODO</span> 卡特兰数</h4>
</div>
</div>
</div>
<div id="outline-container-orgheadline108" class="outline-2">
<h2 id="orgheadline108"><span class="section-number-2">7</span> Q&amp;A</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline106" class="outline-3">
<h3 id="orgheadline106"><span class="section-number-3">7.1</span> 为什么 cocos2d-x js 和 c++对象的映射采用 hash table 而不使用 dictionary 呢？</h3>
<div class="outline-text-3" id="text-7-1">
<p>
hash table 的查询效率更高，而 c++和 javascript 交互的时候，需要对该表进行大量查询。<br>
采用链接法处理冲突时，hash table 的平均查询效率为 n/m。<br>
dictionary 的平均查询效率为 h=log(n) 。<br>
当 m=1000 时，n&lt;13746 时，哈希表的查询效率都比 dictionary 要高。<br>
<img src="Img_hash_dict_compare.jpg"><br>
</p>
</div>
</div>
<div id="outline-container-orgheadline107" class="outline-3">
<h3 id="orgheadline107"><span class="section-number-3">7.2</span> 关于 std::unordered_map</h3>
<div class="outline-text-3" id="text-7-2">
<p>
标准库的 std::unordered_map 内部实现为 hash 表，并且该哈希表的默认最大装载因子 max_load_factor 为 1，当哈希表的装载因子 load_factor 大于等于 max_load_factor 时，会触发 rehash 方法，增大 bucket_count 数目，重新生成 hash 表。<br>
rehash 方法的平均复杂度为 存储元素的个数( \(\frac{n}{m}\) )，最坏复杂度为 存储元素个数的二次方( \(\frac{n(1+n)}{2}\) 所有元素被散列到同一个槽内)。<br>
</p>
<ul class="org-ul">
<li>参考资料<br></li>
</ul>
<p>
cpp 官方文档 <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/" target="_blank" rel="external">http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline109" class="outline-2">
<h2 id="orgheadline109"><span class="section-number-2">8</span> 参考资料</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>对数公开课<br>
<a href="http://open.163.com/special/Khan/logarithms.html" target="_blank" rel="external">http://open.163.com/special/Khan/logarithms.html</a><br></li>
<li>算法导论公开课<br>
<a href="http://open.163.com/special/opencourse/algorithms.html" target="_blank" rel="external">http://open.163.com/special/opencourse/algorithms.html</a><br></li>
<li>全域哈希和完全哈希公开课笔记<br>
<a href="http://www.cnblogs.com/udld/p/4299695.html" target="_blank" rel="external">http://www.cnblogs.com/udld/p/4299695.html</a><br></li>
<li>什么是动态规划<br>
<a href="https://www.zhihu.com/question/23995189" target="_blank" rel="external">https://www.zhihu.com/question/23995189</a><br>
<a href="https://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="external">https://www.zhihu.com/question/23995189/answer/35429905</a><br></li>
<li>Advanced Data Structures 公开课<br>
MIT 官网视频<br>
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2012/lecture-videos/" target="_blank" rel="external">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2012/lecture-videos/</a><br>
Bilibili 视频<br>
      <a href="http://www.bilibili.com/video/av3372873/" target="_blank" rel="external">http://www.bilibili.com/video/av3372873/</a><br></li>
</ul>
</div>
</div>
</div>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/07/01/algorithm/AlgorithmIntroduce/">AlgorithmIntroduce</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">wolfand11</a></p>
        <p><span>发布时间:</span>2016-07-01, 00:00:00</p>
        <p><span>最后更新:</span>2017-04-02, 21:45:46</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/07/01/algorithm/AlgorithmIntroduce/" title="AlgorithmIntroduce">http://wolfand11.coding.me/2016/07/01/algorithm/AlgorithmIntroduce/</a>
            <span class="copy-path" data-clipboard-text="原文: http://wolfand11.coding.me/2016/07/01/algorithm/AlgorithmIntroduce/　　作者: wolfand11" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/07/16/architecture/GameModules/">
                    GameModules
                </a>
            </div>
        
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline14"><span class="toc-number">1.</span> <span class="toc-text">1 Foundations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline7"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 函数的增长</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 \(\Theta\) 记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline2"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 \(O\) 记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline3"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 \(\Omega\) 记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline4"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.4 \(o\) 记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline5"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.1.5 \(\omega\) 记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline6"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.1.6 渐近记号的解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline12"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 递归式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 代换法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline10"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 递归树方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline11"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 主方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline13"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 概率分析和随机算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline29"><span class="toc-number">2.</span> <span class="toc-text">2 Sorting and Order Statistics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline15"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline21"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline16"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 快速排序分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline17"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 快速排序实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline19"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 随机快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline20"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 随机快速排序实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline26"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 线性时间排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline22"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 比较排序的下界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline23"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline24"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline25"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 桶排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline27"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 中位数和顺序统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline28"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Sorting implement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline71"><span class="toc-number">3.</span> <span class="toc-text">3 DataStructure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline30"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Stack Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline32"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 LinkList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline31"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 单链表倒序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline37"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 SkipList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline34"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 SkipList 时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline35"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 SkipList 高度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline36"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 SkipList Maintain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline38"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline57"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Hash Table</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline39"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 直接寻址表 Direct-address table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline42"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 散列表 Hash table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline51"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 散列函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline55"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 开放寻址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline56"><span class="toc-number">3.5.5.</span> <span class="toc-text">3.5.5 完全散列 Perfect Hashing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline60"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 Binary Search Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline58"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 二叉查找树的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline59"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2 随机构造的二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline61"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 Balance Search Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline66"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 Red-Black Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline62"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1 RBTree 的高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline63"><span class="toc-number">3.8.2.</span> <span class="toc-text">3.8.2 RBTree Insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline64"><span class="toc-number">3.8.3.</span> <span class="toc-text">3.8.3 TODO RBTree Delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline65"><span class="toc-number">3.8.4.</span> <span class="toc-text">3.8.4 Red-Black Tree 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline70"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 Augmenting Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline67"><span class="toc-number">3.9.1.</span> <span class="toc-text">3.9.1 动态顺序统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline68"><span class="toc-number">3.9.2.</span> <span class="toc-text">3.9.2 为什么不在红黑树中直接记录节点的秩？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline69"><span class="toc-number">3.9.3.</span> <span class="toc-text">3.9.3 数据结构扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline85"><span class="toc-number">4.</span> <span class="toc-text">4 Advanced Design And Analysis Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline78"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 动态规划法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline72"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 动态规划的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline73"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 找寻最优子结构的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline74"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 动态规划算法的设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline77"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4 最长公共子序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline80"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline79"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 贪心算法的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline84"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 平摊分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline81"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 聚集分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline82"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 记账方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline83"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 势能方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline95"><span class="toc-number">5.</span> <span class="toc-text">5 Graph Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 图的基本算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline86"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 图的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline87"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 广度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline88"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 深度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline91"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 最小权生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline90"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline93"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline92"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 单源最短路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline94"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 Graph Implement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline105"><span class="toc-number">6.</span> <span class="toc-text">6 数学概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline96"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline102"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 概率论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline97"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 随机试验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline98"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 随机变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline99"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 指示器随机变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline100"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4 期望</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline101"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.5 马尔可夫不等式证明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline104"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#orgheadline103"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1 TODO 卡特兰数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline108"><span class="toc-number">7.</span> <span class="toc-text">7 Q&A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline106"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 为什么 cocos2d-x js 和 c++对象的映射采用 hash table 而不使用 dictionary 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orgheadline107"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 关于 std::unordered_map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orgheadline109"><span class="toc-number">8.</span> <span class="toc-text">8 参考资料</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"AlgorithmIntroduce　| wolfand11's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://wolfand11.coding.me/2016/07/01/algorithm/AlgorithmIntroduce/';
            this.page.identifier = '2016/07/01/algorithm/AlgorithmIntroduce/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//wolfand11.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/07/16/architecture/GameModules/" title="上一篇: GameModules">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/20/tools/Matlab/">Matlab</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/08/architecture/KSFrameworkNote/">KSFramework Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/26/unity/UnityHotUpdate/">Unity Hot Update</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/architecture/ActionScriptDeveloperGuideToPureMVC/">Action Script Developer Guide To PureMVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/gameplay/MoveSync/">Move Sync</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/01/unity/UnityGUI/">Unity GUI</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/23/unity/UnityDoc-AnimationFromExternalSources/">Animation From External Sources</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/22/unity/UnityDoc-AnimationClips/">Animation Clips</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/unity/UnityDoc-AnimationSystemOverview/">Animation System Overview</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/language/Lua/">Programming in Lua</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/28/unity/UnityNote/">Unity Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/tools/vim/">VIM</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/tools/GameDevTools/">Game Dev Tools</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/27/language/CSharp/">Programing in CSharp</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/24/unity/UnityDoc-SpecialFolders/">Special Folders</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/tools/InitMyCore/">Init My Core</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/unity/UnityDoc-LoadingResourcesatRuntime/">Loading Resources at Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/unity/Unity5LightingCookbook/">Unity 5 Lighting Cookbook</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/unity/UnityShaderAndEffectCookbook/">UnityShaderAndEffectCookbook</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/14/tools/Emacs/">Emacs</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/14/tools/InitPC/">Init My PC</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/14/language/Elisp/">Programing in Elisp</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/14/tools/GitAndGithub/">Git Github</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/14/language/Shell/">Shell</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/12/tools/CreateBlogWithHexo/">Create Blog With Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/12/tools/CreateBlogWithJeykll/">Create Blog With Jeykll</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/16/architecture/GameModules/">GameModules</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/algorithm/AlgorithmIntroduce/">AlgorithmIntroduce</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 wolfand11
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>