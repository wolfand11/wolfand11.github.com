<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-19 周一 21:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AlgorithmIntroduce</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">AlgorithmIntroduce</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org262cc89">Foundations</a>
<ul>
<li><a href="#org4630387">函数的增长</a>
<ul>
<li><a href="#org7562619">\(\Theta\) 记号</a></li>
<li><a href="#org0e02733">\(O\) 记号</a></li>
<li><a href="#org5be5b9e">\(\Omega\) 记号</a></li>
<li><a href="#org0c775b4">\(o\) 记号</a></li>
<li><a href="#org41aeeb2">\(\omega\) 记号</a></li>
<li><a href="#org095200f">渐近记号的解释</a></li>
</ul>
</li>
<li><a href="#org01b0f90">递归式</a>
<ul>
<li><a href="#orga6aed29">代换法</a>
<ul>
<li><a href="#org1543113">实例</a></li>
</ul>
</li>
<li><a href="#org8460d40">递归树方法</a></li>
<li><a href="#org7d3342b">主方法</a></li>
</ul>
</li>
<li><a href="#orge74ad63">概率分析和随机算法</a>
<ul>
<li><a href="#org2ae6442">随机排列数组</a></li>
<li><a href="#org5e89004">雇佣问题</a></li>
<li><a href="#orgf3fda20">生日悖论</a></li>
<li><a href="#org2df0ce4">球与盒子</a></li>
<li><a href="#org24333ee">序列</a></li>
<li><a href="#orgaaa6d88">在线雇佣问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgda89a88">Sorting and Order Statistics</a>
<ul>
<li><a href="#org471a887">比较排序</a>
<ul>
<li><a href="#orgb783199">堆排序</a></li>
<li><a href="#org335f31a">快速排序</a>
<ul>
<li><a href="#orgb04e151">快速排序分析</a></li>
<li><a href="#org2e25dbb">快速排序实现</a></li>
<li><a href="#org0e9da55">随机快速排序</a>
<ul>
<li><a href="#org5376480">随机快速排序分析</a></li>
</ul>
</li>
<li><a href="#org643997e">随机快速排序实现</a></li>
</ul>
</li>
<li><a href="#org1505552">决策树模型</a></li>
</ul>
</li>
<li><a href="#orgacc5958">线性时间排序</a>
<ul>
<li><a href="#org15913a4">计数排序</a></li>
<li><a href="#orgdaf7a19">基数排序</a></li>
<li><a href="#orgd57816d">桶排序</a></li>
</ul>
</li>
<li><a href="#org7d2d3ab">中位数和顺序统计</a></li>
<li><a href="#org4fee534">Sorting implement</a></li>
</ul>
</li>
<li><a href="#orgfda0037">DataStructure</a>
<ul>
<li><a href="#org1db2891">Stack Queue</a></li>
<li><a href="#org145dfad">LinkList</a>
<ul>
<li><a href="#orgbc0e959">单链表倒序</a></li>
</ul>
</li>
<li><a href="#orgbf49e9a">SkipList</a>
<ul>
<li><a href="#orgb6082ff">SkipList 时间复杂度分析</a>
<ul>
<li><a href="#org184f660">SkipList 高概率最优</a></li>
</ul>
</li>
<li><a href="#org9e4a1f2">SkipList 高度分析</a></li>
<li><a href="#org52c4ee1">SkipList Maintain</a></li>
</ul>
</li>
<li><a href="#org10ed9e4">Tree</a></li>
<li><a href="#orgb1d1369">Hash Table</a>
<ul>
<li><a href="#orgd3a94ba">直接寻址表 Direct-address table</a></li>
<li><a href="#org0682c0e">散列表 Hash table</a>
<ul>
<li><a href="#org248958b">链接法解决碰撞</a>
<ul>
<li><a href="#org51530fb">装载因子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org171818f">散列函数</a>
<ul>
<li><a href="#orgf032327">好的散列函数的特点</a></li>
<li><a href="#orgd4fec49">将关键字解释为自然数</a></li>
<li><a href="#org3c35c82">除法散列法</a></li>
<li><a href="#orgc41ecce">乘法散列法</a></li>
<li><a href="#org7598ed4">全域散列 Universal hashing</a>
<ul>
<li><a href="#orgaa163df">定义</a></li>
<li><a href="#org90fb653">定理 1</a></li>
<li><a href="#org68c7466">构造一种全域哈希的方案</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge85f1f6">开放寻址法</a>
<ul>
<li><a href="#org6ea2e81">线性探查</a></li>
<li><a href="#org99abae8">二次探查</a></li>
<li><a href="#orgd74dc78">双重散列</a></li>
<li><a href="#orgfd3b001">开放寻址散列的分析</a></li>
</ul>
</li>
<li><a href="#org671b444">完全散列 Perfect Hashing</a></li>
<li><a href="#orgc73a6d8">HashTable implement</a></li>
</ul>
</li>
<li><a href="#org0567a3d">Binary Search Trees</a>
<ul>
<li><a href="#org1db6ea4">二叉查找树的操作</a></li>
<li><a href="#orgfa9aaf8">随机构造的二叉查找树</a></li>
</ul>
</li>
<li><a href="#orgda612ef">Balance Search Trees</a></li>
<li><a href="#orgf5b1cba">Red-Black Trees</a>
<ul>
<li><a href="#org46524cf">RBTree 的高度</a></li>
<li><a href="#org681b7f5">RBTree Insert</a></li>
<li><a href="#orgae77ea0">RBTree Delete</a></li>
<li><a href="#org5bf9176">Red-Black Tree 实现</a></li>
</ul>
</li>
<li><a href="#org7f9f550">Augmenting Data Structures</a>
<ul>
<li><a href="#orge72c70f">动态顺序统计</a></li>
<li><a href="#org7b0c5ad">为什么不在红黑树中直接记录节点的秩？</a></li>
<li><a href="#orgd3b35de">数据结构扩展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbf3f88d">Advanced Design And Analysis Techniques</a>
<ul>
<li><a href="#org94c7c97">动态规划法</a></li>
<li><a href="#orgac3b314">贪心算法</a>
<ul>
<li><a href="#orgfdbac45">贪心算法的特征</a></li>
</ul>
</li>
<li><a href="#org9af87c0">平摊分析</a>
<ul>
<li><a href="#org3fed7b1">聚集分析</a></li>
<li><a href="#org1c50665">记账方法</a></li>
<li><a href="#org5965a3b">势能方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org26919c0">Graph Algorithms</a>
<ul>
<li><a href="#orge6aab50">图的基本算法</a>
<ul>
<li><a href="#orgcf68ee9">图的表示</a></li>
<li><a href="#orga08d247">广度优先搜索</a></li>
<li><a href="#org4fc4542">深度优先搜索</a></li>
</ul>
</li>
<li><a href="#orga9bb58b">最小权生成树</a>
<ul>
<li><a href="#org42c2719">应用</a></li>
</ul>
</li>
<li><a href="#org32ea297">最短路径问题</a>
<ul>
<li><a href="#org79768f6">单源最短路径</a></li>
</ul>
</li>
<li><a href="#orgeeb52f5">Graph Implement</a></li>
</ul>
</li>
<li><a href="#orgf1023e6">数学概念</a>
<ul>
<li><a href="#orga0c84b3">对数</a></li>
<li><a href="#org28a2fb3">概率论</a>
<ul>
<li><a href="#org544dac0">随机试验</a></li>
<li><a href="#org9566a0a">随机变量</a></li>
<li><a href="#org3a2865c">指示器随机变量</a></li>
<li><a href="#org133b547">期望</a></li>
<li><a href="#org61f4b35">马尔可夫不等式证明</a></li>
</ul>
</li>
<li><a href="#org06d14dc">组合数学</a>
<ul>
<li><a href="#org41ab28c"><span class="todo TODO">TODO</span> 卡特兰数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org75049b6">Q&amp;A</a>
<ul>
<li><a href="#org32e2bd9">为什么 cocos2d-x js 和 c++对象的映射采用 hash table 而不使用 dictionary 呢？</a></li>
<li><a href="#orga2c7b33">关于 std::unordered_map</a></li>
</ul>
</li>
<li><a href="#orgc553766">参考资料</a></li>
</ul>
</div>
</div>
<p>
这篇主要是算法导论相关的笔记。<br />
</p>
<div class="HTML">
<p>
&lt;!&#x2013;more&#x2013;&gt;<br />
</p>

</div>
<div id="outline-container-org262cc89" class="outline-2">
<h2 id="org262cc89">Foundations</h2>
<div class="outline-text-2" id="text-org262cc89">
</div>
<div id="outline-container-org4630387" class="outline-3">
<h3 id="org4630387">函数的增长</h3>
<div class="outline-text-3" id="text-org4630387">

<div class="figure">
<p><img src="AlgorithmIntroduce/Img_asymptotic_notation.jpg" alt="Img_asymptotic_notation.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org7562619" class="outline-4">
<h4 id="org7562619">\(\Theta\) 记号</h4>
<div class="outline-text-4" id="text-org7562619">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\Theta(g(n))\) 来表示函数集合：<br />
\(\Theta(g(n)) = \{f(n):存在常数 c_1,c_2 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq c_1g(n) \leq f(n) \leq c_2g(n)\} \quad 也就是说，对于任一函数 f(n),若存在正常数 c_1,c_2,使当 n 充分大时，f(n)能被夹在 c_1g(n)和 c_2g(n)中间，则 f(n)属于集合 \Theta(g(n))\)<br />
\(\Theta 记号 给出了函数 f(n)的上下界\)<br />
</p>
</div>
</div>
<div id="outline-container-org0e02733" class="outline-4">
<h4 id="org0e02733">\(O\) 记号</h4>
<div class="outline-text-4" id="text-org0e02733">
<p>
对于一个给定函数 \(g(n)\) ,用 \(O(g(n))\) 来表示函数集合：<br />
\(O(g(n)) = \{f(n):存在常数 c 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq  f(n) \leq cg(n)\} \quad 也就是说，对于任一函数 f(n),若存在正常数 c,使当 n 充分大时，f(n)的值都在 cg(n)之下，则 f(n)属于集合 O(g(n))\)<br />
\(O 记号 给出了函数 f(n)的上界\)<br />
</p>
</div>
</div>
<div id="outline-container-org5be5b9e" class="outline-4">
<h4 id="org5be5b9e">\(\Omega\) 记号</h4>
<div class="outline-text-4" id="text-org5be5b9e">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\Omega(g(n))\) 来表示函数集合：<br />
\(\Omega(g(n)) = \{f(n):存在常数 c 和 n_0，使对所有的 n \geq n_0 ,有 0 \leq cg(n) \leq  f(n) \} \quad 也就是说，对于任一函数 f(n),若存在正常数 c,使当 n 充分大时，f(n)的值都在 cg(n)之上，则 f(n)属于集合 \Omega(g(n))\)<br />
\(\Omega 记号 给出了函数 f(n)的下界\)<br />
</p>
</div>
</div>
<div id="outline-container-org0c775b4" class="outline-4">
<h4 id="org0c775b4">\(o\) 记号</h4>
<div class="outline-text-4" id="text-org0c775b4">
<p>
对于一个给定函数 \(g(n)\) ,用 \(o(g(n))\) 来表示函数集合：<br />
\(o(g(n)) = \{f(n):对任意正常数 c ,存在常数 n_0 > 0，使对所有的 n \geq n_0 ,有 0 \leq  f(n) < cg(n)\}\)<br />
\(o 记号 给出了函数 f(n)的非渐近紧确上界\)<br />
</p>
</div>
</div>
<div id="outline-container-org41aeeb2" class="outline-4">
<h4 id="org41aeeb2">\(\omega\) 记号</h4>
<div class="outline-text-4" id="text-org41aeeb2">
<p>
对于一个给定函数 \(g(n)\) ,用 \(\omega(g(n))\) 来表示函数集合：<br />
\(\omega(g(n)) = \{f(n):对任意正常数 c ,存在常数 n_0 > 0，使对所有的 n \geq n_0 ,有 0 \leq cg(n) < f(n) \}\)<br />
\(\omega 记号 给出了函数 f(n)的非渐近紧确下界\)<br />
</p>
</div>
</div>
<div id="outline-container-org095200f" class="outline-4">
<h4 id="org095200f">渐近记号的解释</h4>
<div class="outline-text-4" id="text-org095200f">
<p>
\(X(g(n))是一个集合，可以用 f(n) \in X(g(n)) 来表示 f(n)属于 X(g(n))。不过通常写为 f(n) = X(g(n))来表示这种关系。需要注意的是不能写为 X(g(n)) = f(n)\)<br />
一般来说，当渐近记号出现在某个公式中时，我们将其解释为一个不在乎其名称的匿名函数。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org01b0f90" class="outline-3">
<h3 id="org01b0f90">递归式</h3>
<div class="outline-text-3" id="text-org01b0f90">
</div>
<div id="outline-container-orga6aed29" class="outline-4">
<h4 id="orga6aed29">代换法</h4>
<div class="outline-text-4" id="text-orga6aed29">
<ul class="org-ul">
<li>用代换法解递归式需要两个步骤：<br />
<ol class="org-ol">
<li>猜测解的形式<br /></li>
<li>用数学归纳法找出使解真正有效的常数。<br /></li>
</ol></li>
<li>使用数学归纳法进行证明的步骤<br />
<ul class="org-ul">
<li>数学归纳法第一种形式<br />
<ol class="org-ol">
<li>证明当 m=1 时命题成立。<br /></li>
<li>假设 m=n 时命题成立，推导出在 m=n+1 时命题也成立。（n 代表任意自然数）<br /></li>
</ol></li>
<li>数学归纳法第二种形式<br />
<ol class="org-ol">
<li>证明当 m=1 时命题成立<br /></li>
<li>假设 m&lt;n 时命题成立，推导出在 m=n 时命题也成立。（n 代表任意自然数）<br /></li>
</ol></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1543113" class="outline-5">
<h5 id="org1543113">实例</h5>
<div class="outline-text-5" id="text-org1543113">
<ul class="org-ul">
<li><p>
求递归式 \(T(n) = 2T(\biggl\lfloor \frac{n}{2} \biggr\rfloor) + n\)<br />
</p>
\begin{align}
&-\quad Step 1\, 猜测解的形式        \nonumber\\ 
&猜测\quad T(n) = O(nlgn),即存在常数 c 和 n_0 使得 T(n)的值都在 nlgn 之下 \nonumber\\ 
&-\quad Step 2\, 使用数学归纳法证明    \nonumber\\ 
&-\quad Step 2.1\, 证明 m=2,3 时成立 \nonumber\\ 
&n=1 时，T(1) = 2*0 + 1 = 1 > c1lg1=0   \, &(无论 c 取何值都不成立)    \nonumber\\ 
&n=2 时，T(2) = 2*1 + 2 = 4 \leq c2lg2  \, &(c\geq2 时成立) \nonumber\\ 
&n=3 时，T(3) = 2*1 + 3 = 5 \leq c3lg3  \, &(c\geq2 时成立) \nonumber\\ 
&-\quad Step 2.2\, 假设 m < n 成立，证明 m=n 时也成立 \nonumber\\
&依据假设有 m < n 成立，所以对于 m=\frac{n}{2} 时，有 T(\frac{n}{2}) \leq c\frac{n}{2}lg\frac{n}{2}           \nonumber\\
&T(n) = 2T(\biggl\lfloor \frac{n}{2} \biggr\rfloor) + n \leq 2c\frac{n}{2}lg\frac{n}{2} + n \nonumber\\
&T(n) \leq cnlg\frac{n}{2} + n = cnlgn - cn + n <= cnlgn \quad (c\geq 1 时成立) \nonumber\\ 
&-\quad Step 2.3\, 依据数学归纳法可以可出结论 \nonumber\\
&所以，当取 c \geq 2 时，T(n) \leq cnlgn。即 T(n) = O(nlgn)
\end{align}</li>
<li><p>
求递归式 \(T(n) = 2T(n-1) + 1 \quad (n>0) \quad T(0) = 0\)<br />
</p>
\begin{align}  
&-\quad Step 1\, 猜测解的形式        \nonumber\\ 
&猜测\quad T(n) = O(2^n),即存在常数 c 和 n_0 使得 T(n)的值都在 2^n 之下 \nonumber\\ 
&-\quad Step 2\, 使用数学归纳法证明    \nonumber\\ 
&-\quad Step 2.1\, 证明 m=2,3 时成立 \nonumber\\ 
&n=1 时，T(1) = 2*0 + 1 = 1 \leq c2^1 \, &(c\geq1 时成立)    \nonumber\\ 
&n=2 时，T(2) = 2*1 + 1 = 3 \leq c2^2 \, &(c\geq1 时成立) \nonumber\\ 
&n=3 时，T(3) = 2*3 + 1 = 7 \leq c2^3 \, &(c\geq1 时成立) \nonumber\\ 
&-\quad Step 2.2\, 假设 n=k-1 时成立，证明 n = k 时也成立 \nonumber\\ 
&依据假设有 T(k-1) \leq c2^{k-1}                      \nonumber\\
&T(k) = 2T(k-1) + 1 \leq 2c2^{k-1} + 1             \nonumber\\
&T(k) \leq c2^k+1                                  \nonumber\\ 
&T(k) \leq c2^k (c\geq 2 时成立)                     \nonumber\\ 
&所以，当取 c \geq 2 时，T(n) \leq c2^n。即 T(n) = O(2^n)
\end{align}</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8460d40" class="outline-4">
<h4 id="org8460d40">递归树方法</h4>
<div class="outline-text-4" id="text-org8460d40">
<p>
如下图利用递归树方法求解 \(T(n) = 3T(n/4) + c n ^2\)<br />
<img src="AlgorithmIntroduce/Img_recursion_tree.jpg" alt="Img_recursion_tree.jpg" /><br />
</p>
\begin{align}  
T(n) &= cn^2 + \frac{3}{16}cn^2 + ({\frac{3}{16}})^2cn^2 + \ldots + ({\frac{3}{16}})^{log_4(n-1)}cn^2 + \Theta(n^{log_43}) \nonumber\\ 
& = \sum_{i=0}^{log_4n-1}(\frac{3}{16})^icn^2 + \Theta(n^{log_43})\nonumber\\ 
& = \frac{(3/16)^{log_4n}-1}{(3/16)-1}cn^2+\Theta(n^{log_43})     \nonumber\\ 
T(n) & < \sum_{i=0}^{\infty}(\frac{3}{16})^icn^2 + \Theta(n^{log_43})\nonumber\\ 
& = \frac{1}{1-(3/16)}cn^2+\Theta(n^{log_43})     \nonumber\\ 
& = \frac{16}{13}cn^2+\Theta(n^{log_43})          \nonumber\\ 
& = O(n^2)
\end{align}
</div>
</div>
<div id="outline-container-org7d3342b" class="outline-4">
<h4 id="org7d3342b">主方法</h4>
<div class="outline-text-4" id="text-org7d3342b">
<p>
主方法是递归树的一种应用。可以通过递归树来证明主方法。主方法所依赖的主定理如下：<br />
</p>
\begin{align}  
&设 a \geq 1 和 b > 1 为常数，设 f(n)为一个函数，T(n)在非负整数上通过下列递归式来定义       \nonumber \\
&T(n) = aT(n/b) + f(n)                                                      \nonumber \\
&其中 n/b 为\biggl\lfloor n/b \biggr\rfloor 或  \biggl\lceil n/b \biggr\rceil,那么 T(n)有下列的渐近边界： \nonumber \\
&(1) \; 若对于某常数\epsilon >0,有 f(n)=O(n^{log_ba-\epsilon}),则 T(n) = \Theta(n^{log_ba}) \nonumber \\
&(2) \; 若 f(n) = \Theta(n^{log_ba}),则 T(n) = \Theta(n^{log_ba}lgn) \nonumber \\
&(3) \; 若对于某常数\epsilon >0,有 f(n)=\Omega(n^{log_ba+\epsilon}),且对常数 c<1 与足够大的 n 有 af(n/b) \leq cf(n),则 T(n) = \Theta(f(n))\nonumber \\
\end{align}
</div>
</div>
</div>
<div id="outline-container-orge74ad63" class="outline-3">
<h3 id="orge74ad63">概率分析和随机算法</h3>
<div class="outline-text-3" id="text-orge74ad63">
</div>
<div id="outline-container-org2ae6442" class="outline-4">
<h4 id="org2ae6442">随机排列数组</h4>
<div class="outline-text-4" id="text-org2ae6442">
<div class="org-src-container">
<pre class="src src-lua">function PermuteBySorting(lst)
    local priority = {}
    local len = #lst
    local max_random = len*len*len
    for i=1,len do
        priority[i] = random(1, max_random)
    end

    -- sort list with priority
    sort(lst, priority)
end

function RandomInPlace(lst)
    local len = #lst
    for i=1,len do
        local random_idx = random(i, len)
        local tmp = lst[i]
        lst[i] = lst[random_idx]
        lst[random_idx] = tmp
    end
end
</pre>
</div>
</div>
</div>
<div id="outline-container-org5e89004" class="outline-4">
<h4 id="org5e89004">雇佣问题</h4>
<div class="outline-text-4" id="text-org5e89004">
<div class="org-src-container">
<pre class="src src-lua">HIRE-ASSISTANT(n)
  best = 0 // candidate 0 is a least-qualified dummy candidate
  for i=1 to n
    do interview candidate i
    if candidate i is better than candidate best
      then best = i
           hire candidate i
</pre>
</div>

<p>
计算雇佣一个新的办公助理的期望次数<br />
</p>
\begin{align}
  &令 X 为随机变量，其值等于雇佣一个新的办公助理的次数。 \\
  &按照期望的概念可得 \\
  &E[X]=\sum_{x=1}^{n}xPr\{X=x\} \\
  &但是，上面这种方法计算会很麻烦。利用指示器随机变量可以大大简化计算。 \\
  &令 X_i 对应于第 i 个应聘者被雇用这个事件的指示器随机变量。 \\
  &X_i = I\{第 i 位应聘者被雇佣\} =
  \begin{cases}
  1   & 如果第 i 位应聘者被雇佣 \\
  0   & 如果第 i 位应聘者没有被雇佣 \\
  \end{cases} \nonumber \\
  &X = X_1 + X_2 + \ldots + X_n \nonumber \\
  &E[X_i]=Pr{应聘者 i 被雇佣} \nonumber \\
  &因为应聘者以随机顺序出现，所以这些前 i 个应聘者中的任何一个都等可能地是当前最有资格的。所以 \nonumber \\
  &E[X_i]=1/i \nonumber \\
  &E[X]=E[\sum_{i=1}^{n}X_i] = \sum_{i=1}^{n}E[X_i] = \sum_{i=1}^{n}1/i=lnn + O(1) \nonumber \\
\end{align}
</div>
</div>
<div id="outline-container-orgf3fda20" class="outline-4">
<h4 id="orgf3fda20">生日悖论</h4>
</div>
<div id="outline-container-org2df0ce4" class="outline-4">
<h4 id="org2df0ce4">球与盒子</h4>
</div>
<div id="outline-container-org24333ee" class="outline-4">
<h4 id="org24333ee">序列</h4>
</div>
<div id="outline-container-orgaaa6d88" class="outline-4">
<h4 id="orgaaa6d88">在线雇佣问题</h4>
</div>
</div>
</div>
<div id="outline-container-orgda89a88" class="outline-2">
<h2 id="orgda89a88">Sorting and Order Statistics</h2>
<div class="outline-text-2" id="text-orgda89a88">
</div>
<div id="outline-container-org471a887" class="outline-3">
<h3 id="org471a887">比较排序</h3>
<div class="outline-text-3" id="text-org471a887">
</div>
<div id="outline-container-orgb783199" class="outline-4">
<h4 id="orgb783199">堆排序</h4>
<div class="outline-text-4" id="text-orgb783199">
<p>
二叉堆在数组中构建的二叉树结构。其主要操作以及对应的时间复杂度如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Heapify</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapBuild</td>
<td class="org-left">\(O(nlgn)\) 更紧确的上界为\(O(n)\)</td>
</tr>

<tr>
<td class="org-left">HeapInsert</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapDelete</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapExtract</td>
<td class="org-left">\(O(lgn)\)</td>
</tr>

<tr>
<td class="org-left">HeapSort</td>
<td class="org-left">\(O(nlgn)\)</td>
</tr>
</tbody>
</table>

<p>
堆相关代码实现请参考如下文件<br />
<a href="AlgorithmIntroduce/Code_Heap.lua">AlgorithmIntroduce/Code_Heap.lua</a><br />
</p>
</div>
</div>

<div id="outline-container-org335f31a" class="outline-4">
<h4 id="org335f31a">快速排序</h4>
<div class="outline-text-4" id="text-org335f31a">
<ul class="org-ul">
<li>快速排序的思路<br />
选择数组中第一个元素 A 为主元素(标准元素)，将数组元素分两部分第一部分为小于等于 A 的元素，第二部分为大于 A 的元素，然后递归对这两部分继续使用快速排序。<br /></li>
<li>快速排序采用了分治法<br /></li>
<li>快速排序是一种原地排序，不需要额外空间<br /></li>
</ul>
</div>
<div id="outline-container-orgb04e151" class="outline-5">
<h5 id="orgb04e151">快速排序分析</h5>
<div class="outline-text-5" id="text-orgb04e151">
<ul class="org-ul">
<li><p>
当数据已经升序或降序拍好时，快速排序出现最坏情况<br />
</p>
\begin{align}
 T(n) &= T(0) + T(n-1) + O(n)  \nonumber \\
 &= O(1) + T(n-1) + O(n)       \nonumber \\
 &= T(n-1) + O(n)              \nonumber \\
 &= O(1) +  O(2) + \ldots + O(n-1) + O(n)              \nonumber \\
 &= O(n^2)                     \nonumber \\
 \end{align}</li>
<li><p>
当每次划分都在中间时<br />
</p>
\begin{align}
T(n) &= 2T(n/2)  \nonumber \\
&= O(nlog_2n)                 \nonumber \\
\end{align}</li>
<li><p>
假设每次划分都为 1/10 9/10<br />
</p>
\begin{align}
&T(n) = T(\frac{n}{10}) + T(\frac{n9}{10}) + O(n) \nonumber \\
&T(n) = knlog_{\frac{10}{9}}n      \nonumber \\
&T(n) = O(nlogn)                   \nonumber \\
\end{align}</li>
<li><p>
假设一步划分最优，一步划分最坏<br />
</p>
\begin{align}
&L=Lucky
&U=Unlucky
&L(n) = 2U(n/2) + O(n)       \nonumber \\
&U(n) = L(n-1) + O(n)        \nonumber \\
&L(n) = 2(L(\frac{n}{2}-1) + O(\frac{n}{2})) + O(n) \nonumber \\
&L(n) = 2L(\frac{n}{2}-1) + O(n) \nonumber \\
&L(n) = O(nlogn)                 \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
<div id="outline-container-org2e25dbb" class="outline-5">
<h5 id="org2e25dbb">快速排序实现</h5>
<div class="outline-text-5" id="text-org2e25dbb">
<div class="org-src-container">
<pre class="src src-lua">function Partition(arr, p, q)
    i = p
    for j=p+1,q do
        if arr[j] &lt;= arr[p] then
            exchange(arr[i],arr[j])
            i++
        end
    end
    exchange(arr[i],arr[p])
    return i
end
function QuickSort(arr, p, q)
    if p&lt;0 or p&gt;=q then
        return
    end

    i = Partition(arr, p, q)
    QuickSort(arr, p, i-1)
    QuickSort(arr, i+1, q)
end
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e9da55" class="outline-5">
<h5 id="org0e9da55">随机快速排序</h5>
<div class="outline-text-5" id="text-org0e9da55">
<p>
每一次划分之前，将主元素和一个随机的元素交换。<br />
</p>
</div>
<div id="outline-container-org5376480" class="outline-6">
<h6 id="org5376480">随机快速排序分析</h6>
<div class="outline-text-6" id="text-org5376480">
<p>
随机快速排序的时间复杂度为 \(O(nlogn)\)<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org643997e" class="outline-5">
<h5 id="org643997e">随机快速排序实现</h5>
<div class="outline-text-5" id="text-org643997e">
<div class="org-src-container">
<pre class="src src-lua">function Partition(arr, p, q)
    exchange(arr[p], arr[random(p,q)])
    i = p
    for j=p+1,q do
        if arr[j] &lt;= arr[p] then
            exchange(arr[i],arr[j])
            i++
        end
    end
    exchange(arr[i],arr[p])
    return i
end
function QuickSort(arr, p, q)
    if p&lt;0 or p&gt;=q then
        return
    end

    i = Partition(arr, p, q)
    QuickSort(arr, p, i-1)
    QuickSort(arr, i+1, q)
end
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1505552" class="outline-4">
<h4 id="org1505552">决策树模型</h4>
<div class="outline-text-4" id="text-org1505552">
<p>
比较排序可以被抽象为决策树。一棵决策树是一棵满二叉树，表示某排序算法作用于给定输入所做的所有比较，而控制结构、数据移动等都被忽略。<br />
</p>
\begin{align}
&令 h 为决策树高度，l 为叶子节点数，n 为输入的元素数目 \nonumber \\
&n 个输入元素共有 n! 种排列           \nonumber\\
&高度为 h 的二叉树，其叶子节点小于 2^h   \nonumber\\
& n! \leq l \leq 2^h             \nonumber \\
& h \geq lg(n!) = \Omega(nlgn)   \nonumber \\
\end{align}
</div>
</div>
</div>
<div id="outline-container-orgacc5958" class="outline-3">
<h3 id="orgacc5958">线性时间排序</h3>
<div class="outline-text-3" id="text-orgacc5958">
</div>
<div id="outline-container-org15913a4" class="outline-4">
<h4 id="org15913a4">计数排序</h4>
<div class="outline-text-4" id="text-org15913a4">
<p>
计数排序的思路为：确定数组中数据范围 Range(a,b)，创建一个计数数组，该数组以范围 Range(a,b)内的所有数据为索引，初始化计数数组的值为 0，遍历数组中元素，将其对应于计数数组的元素加 1，最后遍历计数数组得到排序后的元素。<br />
计数排序的时间复杂度为 \(\Theta(n)\)<br />
计数排序具有稳定性。排序算法的稳定性是指具有相同值的元素在输出数组中的相对次序与它们在输入数组中的次序相同。<br />
</p>
</div>
</div>
<div id="outline-container-orgdaf7a19" class="outline-4">
<h4 id="orgdaf7a19">基数排序</h4>
<div class="outline-text-4" id="text-orgdaf7a19">
<p>
基数排序的思路为：从低位到高位，对数组中每个元素的各个数据位进行排序，对位的排序完成，就得到了排序后的数据。<br />
如果基数排序用到的稳定排序的时间复杂度为 \(\Theta(n)\) ,基数排序中最大数的位数为 mdn(即 max_digit_number),则基数排序的时间复杂度为 \(\Theta(mdn*n)=\Theta(n)\)<br />
</p>
</div>
</div>
<div id="outline-container-orgd57816d" class="outline-4">
<h4 id="orgd57816d">桶排序</h4>
<div class="outline-text-4" id="text-orgd57816d">
<p>
桶排序的思路为：将[0,1]范围化分为 bucket_size 部分，此处 0 对应数组元素最小值，1对应数组元素最大值，bucket_size 部分也就对应着将数组数据分为 bucket_size 部分，遍历数组数据将其分配到各个部分同时对各个部分排序。最后遍历各个部分得到排序后的数据。<br />
桶排序的时间复杂度为 \(\Theta(n)\)<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7d2d3ab" class="outline-3">
<h3 id="org7d2d3ab">中位数和顺序统计</h3>
<div class="outline-text-3" id="text-org7d2d3ab">
<p>
Randomized_Select 的时间复杂度为 \(\Theta(n)\)<br />
</p>
</div>
</div>
<div id="outline-container-org4fee534" class="outline-3">
<h3 id="org4fee534">Sorting implement</h3>
<div class="outline-text-3" id="text-org4fee534">
<p>
关于各种排序相关算法的实现，可以参考如下文件：<br />
<a href="AlgorithmIntroduce/Code_Heap.lua">AlgorithmIntroduce/Code_Heap.lua</a><br />
<a href="AlgorithmIntroduce/Code_Sort.lua">AlgorithmIntroduce/Code_Sort.lua</a><br />
<a href="AlgorithmIntroduce/Code_Select.lua">AlgorithmIntroduce/Code_Select.lua</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfda0037" class="outline-2">
<h2 id="orgfda0037">DataStructure</h2>
<div class="outline-text-2" id="text-orgfda0037">
</div>
<div id="outline-container-org1db2891" class="outline-3">
<h3 id="org1db2891">Stack Queue</h3>
<div class="outline-text-3" id="text-org1db2891">
<p>
栈		后进先出<br />
队列		先进先出<br />
</p>
</div>
</div>
<div id="outline-container-org145dfad" class="outline-3">
<h3 id="org145dfad">LinkList</h3>
<div class="outline-text-3" id="text-org145dfad">
</div>
<div id="outline-container-orgbc0e959" class="outline-4">
<h4 id="orgbc0e959">单链表倒序</h4>
<div class="outline-text-4" id="text-orgbc0e959">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Reverse</span> (<span style="color: #ce537a; font-weight: bold;">Node</span>* <span style="color: #7590db;">list</span>)
{
    <span style="color: #ce537a; font-weight: bold;">Node</span>* <span style="color: #7590db;">pre</span> = null;
    <span style="color: #4f97d7; font-weight: bold;">while</span>(list)
    {
        <span style="color: #ce537a; font-weight: bold;">Node</span>* <span style="color: #7590db;">next</span> = list.next;
        list.next = pre;
        pre = list;
        list = next;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> pre;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbf49e9a" class="outline-3">
<h3 id="orgbf49e9a">SkipList</h3>
<div class="outline-text-3" id="text-orgbf49e9a">
</div>
<div id="outline-container-orgb6082ff" class="outline-4">
<h4 id="orgb6082ff">SkipList 时间复杂度分析</h4>
<div class="outline-text-4" id="text-orgb6082ff">
<ul class="org-ul">
<li>两层的 SkipList<br />
对于包含 n 个元素，只有两层的 SkipList，时间消耗为 \(T(n) = |L_1| + \frac{n}{|L_1|} \quad 当|L_1| = \frac{n}{|L_1|}时，取到最小值，即 |L_1|=\sqrt{n}，所以 T(n) = 2\sqrt{n}\)<br /></li>
<li>三层的 SkipList<br />
三层 SkipList，因为每层最多需要遍历 \(\sqrt[3]{n}\) 个元素， 所以时间消耗为 \(T(n) = 3\sqrt[3]{n}\)<br /></li>
<li>\(log_2n\) 层的 SkipList<br />
当 SkipList 取 \(log_2n\) 层时，SkipList 最优。此时时间消耗为 \(T(n) = log_2n\sqrt[log_2n]{n} = 2log_2n\)<br /></li>
</ul>
</div>
<div id="outline-container-org184f660" class="outline-5">
<h5 id="org184f660">SkipList 高概率最优</h5>
<div class="outline-text-5" id="text-org184f660">
<p>
对于 n 个节点的 SkipList，每次查找元素的时间消耗高概率为 \(O(lgn)\)<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9e4a1f2" class="outline-4">
<h4 id="org9e4a1f2">SkipList 高度分析</h4>
<div class="outline-text-4" id="text-org9e4a1f2">
<p>
对每层来说，一个节点会向上增长的概率为 \(\frac{1}{2}\) ，则第 m 层向上增长的概率为 \(\frac{1}{2^m}\)<br />
底层一共有 n 个元素，上升到 m 层时，m 层元素数目的期望为 \(E[C_m] = n\frac{1}{2^m} = \frac{n}{2^m}\)<br />
令 \(E[C_m] \leq 1 则 \frac{n}{2^m} \leq 1 即 n \leq 2^m 所以 lgn \leq m\)<br />
即 当 \(m \geq lgn\) 时，m 层的元素数目小于 1，即 m 层不存在元素了。<br />
</p>
</div>
</div>
<div id="outline-container-org52c4ee1" class="outline-4">
<h4 id="org52c4ee1">SkipList Maintain</h4>
<div class="outline-text-4" id="text-org52c4ee1">
<ul class="org-ul">
<li>插入节点<br />
插入新节点的时候随机一个 1 到 100 的数字 randomV，如果 randomV 大于 50，则将这个数提升到更高层的表中，对这个节点继续执行前面的随机操作。<br /></li>
<li>删除节点<br />
删除节点的时候，如果该节点在多层中出现，则直接将其在出现的层中都删除掉。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org10ed9e4" class="outline-3">
<h3 id="org10ed9e4">Tree</h3>
<div class="outline-text-3" id="text-org10ed9e4">
<ul class="org-ul">
<li>对于二叉树，每一个树的节点用 p,l,r,data 分别表示 指向父亲节点的指针， 指向左孩子的指针，指向右孩子的指针，节点的数据。<br /></li>
<li>对于非二叉树，和二叉树同理，每个树的节点用 p,child1,child2 &#x2026; childn,data 来表示。因为可能有的节点有 n 个孩子，而有的节点只有 1 个或没有孩子, 所以这种方法对于有多个可变数目孩子的树来说会造成空间的浪费。<br /></li>
<li>还有一种树的表示形式是，每个树的节点用 p,lChild,rSibling 来表示。这样就不会造成空间的浪费了。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1d1369" class="outline-3">
<h3 id="orgb1d1369">Hash Table</h3>
<div class="outline-text-3" id="text-orgb1d1369">
</div>
<div id="outline-container-orgd3a94ba" class="outline-4">
<h4 id="orgd3a94ba">直接寻址表 Direct-address table</h4>
<div class="outline-text-4" id="text-orgd3a94ba">
<p>
<img src="AlgorithmIntroduce/Img_direct-address-table.jpg" alt="Img_direct-address-table.jpg" /><br />
缺点：<br />
</p>
<ul class="org-ul">
<li>如果关键字的全域 U 很大时，由于内存大小限制，无法在计算机中存储 U 中所有元素。<br /></li>
<li>如果关键字的全域 U 和实际关键字集合相差很大时，存储 U 中所有元素会造成很多空间浪费。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0682c0e" class="outline-4">
<h4 id="org0682c0e">散列表 Hash table</h4>
<div class="outline-text-4" id="text-org0682c0e">
<p>
散列函数 h 将关键字 k 散列到一个小范围域内，从而减弱直接寻址表缺点的影响。<br />
<img src="AlgorithmIntroduce/Img_hash-table.jpg" alt="Img_hash-table.jpg" /><br />
缺点：<br />
有可能不同的关键字会被 h 函数散列到同一槽上。这种情况被称为发生了碰撞。<br />
</p>
</div>
<div id="outline-container-org248958b" class="outline-5">
<h5 id="org248958b">链接法解决碰撞</h5>
<div class="outline-text-5" id="text-org248958b">
<p>
这种方法将 hash 值相同的元素，用链表存储。<br />
通过 hash 表查找某个元素 ki 的算法如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Find</span>(hashTable, ki)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">hashValue</span> = h(ki);
    <span style="color: #ce537a; font-weight: bold;">Node</span>* <span style="color: #7590db;">list</span> = hashTable[hashValue];
    <span style="color: #4f97d7; font-weight: bold;">while</span> (list)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (list.key == ki)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> list.data
        }
        list = list.next;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> null;
}
</pre>
</div>
</div>
<div id="outline-container-org51530fb" class="outline-6">
<h6 id="org51530fb">装载因子</h6>
<div class="outline-text-6" id="text-org51530fb">
<p>
给定一个能存放 n 个元素的、具有 m 个槽位的散列表 T，定义 T 的装载因子 \(\alpha\) 为 n/m，即一个链中平均存储的元素数。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org171818f" class="outline-4">
<h4 id="org171818f">散列函数</h4>
<div class="outline-text-4" id="text-org171818f">
</div>
<div id="outline-container-orgf032327" class="outline-5">
<h5 id="orgf032327">好的散列函数的特点</h5>
<div class="outline-text-5" id="text-orgf032327">
<p>
散列函数应该尽可能让关键字平均分配到不同的槽上，这样可以保证碰撞发生的概率最小。<br />
</p>
</div>
</div>
<div id="outline-container-orgd4fec49" class="outline-5">
<h5 id="orgd4fec49">将关键字解释为自然数</h5>
<div class="outline-text-5" id="text-orgd4fec49">
<p>
例如，一个字符串关键字可以被解释为按适当的基数符号表示的整数。pt 可以被解释为十进制整数对(112,116),因为 ASCII 字符集中，p 为 112，t 为 116。按照 128 为基数来表示，pt = 112*128+126 = 14452；<br />
</p>
</div>
</div>
<div id="outline-container-org3c35c82" class="outline-5">
<h5 id="org3c35c82">除法散列法</h5>
<div class="outline-text-5" id="text-org3c35c82">
\begin{equation}  
h(k) = k\ mod\ m;
\end{equation}
<p>
除法散列中，需要注意 m 的选择。例如，当 m 为 \(2^p\) 时，h(k)的值为 k 的 p 个最低位数字。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">公式</th>
<th scope="col" class="org-right">被取模数的二进制</th>
<th scope="col" class="org-right">结果的二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">8%7</td>
<td class="org-right">1000</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-right">9%7</td>
<td class="org-right">1001</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-right">10%7</td>
<td class="org-right">1010</td>
<td class="org-right">011</td>
</tr>

<tr>
<td class="org-right">11%7</td>
<td class="org-right">1011</td>
<td class="org-right">100</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">8%8</td>
<td class="org-right">1000</td>
<td class="org-right">000</td>
</tr>

<tr>
<td class="org-right">9%8</td>
<td class="org-right">1001</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-right">10%8</td>
<td class="org-right">1010</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-right">11%8</td>
<td class="org-right">1011</td>
<td class="org-right">011</td>
</tr>
</tbody>
</table>
<p>
从上表可以看出，当选择 \(m=2^3=8\) 时，他们之间有数据排布关系，h(k)的值为 k 的 p 个最低位数字。而当选择 \(m=7\) 时，则没有这种关系。<br />
m 通常选为和 2 的整数幂不太接近的指数。<br />
</p>
</div>
</div>
<div id="outline-container-orgc41ecce" class="outline-5">
<h5 id="orgc41ecce">乘法散列法</h5>
<div class="outline-text-5" id="text-orgc41ecce">
\begin{align}  
h(k) = \biggl\lfloor m(kA\: \: mod \:\:  1) \biggr\rfloor \quad (0\,< A\,< 1)
\end{align}  
<p>
乘法散列的优点是，它对 m 的选择没有特别的要求。但是，一般会选择 \(m=2^p\) ，因为这样方便实现散列函数。<br />
</p>
</div>
</div>
<div id="outline-container-org7598ed4" class="outline-5">
<h5 id="org7598ed4">全域散列 Universal hashing</h5>
<div class="outline-text-5" id="text-org7598ed4">
</div>
<div id="outline-container-orgaa163df" class="outline-6">
<h6 id="orgaa163df">定义</h6>
<div class="outline-text-6" id="text-orgaa163df">
<p>
随机地选择散列函数，使之独立于要存储的关键字，这种方法被称作全域散列。严格的定义如下：<br />
设 H 为有限的一组散列函数，它将给定的关键字域 U 映射到{0,1,&#x2026;&#x2026;,m-1}中。如果对于每一个不同的关键字 \(k,l \in U\) ，满足 \(h(k)=h(l)\) 的散列函数 \(h \in H\) 的个数至多为 \(|H| / m\) 。那么就称这样的一个函数组是全域的。<br />
\(|H|\) 为集合 H 中函数的个数。上面定义的另一种解释是，如果从 H 中随机取一个散列函数，当关键字 \(k \neq l\) 时，两者发生碰撞的概率 \(P(h(k)=h(l)) \leq \frac{|H|/m}{|H|}\) ， \(\frac{|H|/m}{|H|} = \frac{1}{m}\) 。<br />
</p>
</div>
</div>
<div id="outline-container-org90fb653" class="outline-6">
<h6 id="org90fb653">定理 1</h6>
<div class="outline-text-6" id="text-org90fb653">
<p>
如果 h 选自一组全域的散列函数，并用于将 n 个关键字散列到一个大小为 m 的用链接法解决碰撞的表 T 中。如果关键字 k 不在链表中，k 被散列至其中的链表的期望长度 \(E(n_{h(k)}) \leq \alpha=\frac{n}{m}\) (说明： \(n_{h(k)}\) 为链表 T[h(k)]的长度)。如果关键字 k 在链表中，则包含关键字 k 的链表的期望长度 \(E(n_{h(k)}) \leq 1+\alpha = 1+\frac{n}{m}\) <br />
也就是说使用全域的散列函数，可以将 key 均匀地散列到各个链表中。<br />
</p>
<ul class="org-ul">
<li><p>
证明<br />
定义指示器随机变量如下<br />
</p>
\begin{eqnarray}
c_{kl} = c\{h(k)=h(l)\} =
\begin{cases}
1   & h(k)=h(l) \\
0   & h(k) \leq h(l) \\
\end{cases} \nonumber
\end{eqnarray}
<p>
根据全域散列函数定义 \(Pr\{h(k)=h(l)\} \leq 1/m\) ，即 \(E[c_{kl}] \leq 1/m\) 。<br />
定义随机变量 \(C_k\) ，它表示对于每个关键字 k，非 k 的、和 k 散列到同一槽位中的其他关键字的数目。<br />
</p>
\begin{equation}  
C_k = \sum_{l \in T \, l \neq k}c_{kl} \nonumber
\end{equation}
<p>
从而有：<br />
</p>
\begin{equation}
E[C_k] = E[\sum_{l \in T \, l \neq k}c_{kl}] = \sum_{l \in T \, l \neq k}E[c_{kl}] \leq \sum_{l \in T \, l \neq k}\frac{1}{m} = \frac{n-1}{m}
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org68c7466" class="outline-6">
<h6 id="org68c7466">构造一种全域哈希的方案</h6>
<div class="outline-text-6" id="text-org68c7466">
</div>
<ul class="org-ul">
<li><a id="org8deabb3"></a>第一种方案<br />
<div class="outline-text-7" id="text-org8deabb3">
<p>
设定 m 为素数，用 m 将关键字 k 分解为 r+1 位数字，即用 m 进制来表示关键字 k。<br />
\(k = \{k_0\,k_1\,k_2\, \ldots \,k_r\}\) 其中 \(0 \leq k_i \leq m-1\)<br />
随机地选择一个数字 \(a=\{a_0\,a_1\,a_2\, \ldots \,a_r\}\) 其中 \(0 \leq a_i \leq m-1\)<br />
</p>
\begin{equation}
h_a(k) = (\sum_{i=0}^{r}a_i k_i)\, mod\, m
\end{equation}
<p>
即 \(h_a(k)\) 为 a 和 k 的点积再对 m 取模。<br />
这样构造出来的全域哈希函数组中一共有 \(m^{r+1}\) 个哈希函数，因为 a 一共有 r+1 位，每一位可以有 m 种选择。<br />
</p>
<ul class="org-ul">
<li><p>
证明<br />
\(x = \{x_0\,x_1\,x_2\, \ldots \,x_r\}\) 其中 \(0 \leq x_i \leq m-1\)<br />
\(y = \{y_0\,y_1\,x_2\, \ldots \,y_r\}\) 其中 \(0 \leq y_i \leq m-1\)<br />
假设这两个不同的关键字 x，y 在第 0 位不同。如果哈希函数 \(h_a\) 使 x 和 y 关键字散列到同一个链表中，则有下面等式<br />
</p>
\begin{align}
&h_a(x)=h_a(y) \nonumber \\
&\sum_{i=0}^{r}a_i x_i \equiv \sum_{i=0}^{r}a_i y_i \quad mod \quad m \nonumber \\
&\sum_{i=0}^{r}a_i (x_i-y_i) \equiv 0 \quad mod \quad m \nonumber \\
&a_0(x_0-y_0)+\sum_{i=1}^{r}a_i (x_i-y_i) \equiv 0 \quad mod \quad m \nonumber \\
&a_0(x_0-y_0) \equiv -\sum_{i=1}^{r}a_i (x_i-y_i) \quad mod \quad m \nonumber \\
&\because x_0 \neq y_0 \therefore \exists(x_0-y_0)^{-1} \\
&a_0 \equiv -(\sum_{i=1}^{r}a_i (x_i-y_i))(x_0-y_0)^{-1} \quad mod \quad m \nonumber \\
\end{align}
<p>
所以，对于任意 \(a_1 a_2 \ldots a_r\) 只存在唯一的 \(a_0\) 使得 x 和 y 被散列到同一个链表中。<br />
\(h_a\) 的个数为 \(m*m \ldots *m*1 = m^r = \frac{|H|}{m} = \frac{m^{r+1}}{m}\)<br />
</p></li>
</ul>
</div>
</li>

<li><a id="org505373f"></a>第二种方案<br />
<div class="outline-text-7" id="text-org505373f">
<p>
选择一个足够大的素数 p,使得每一个可能的关键字 k 都落在 0 到 p-1 的范围内（包括 0 和 p-1）。设 \(Z_p\) 表示集合｛0,1, \(\ldots\) ,p-1｝, \(Z_{p}{*}\) 表示集合｛1, \(\ldots\) ,p-1｝。对于任何 \(a \in Z_{p}^{*}\) 和任何 \(b \in Z_p\) ,定义散列函数如下：<br />
\(h_{ab}(k) = ((ak+b) \, mod \, p) \, mod \, m\)<br />
所有这样的散列函数构成的函数簇为<br />
\(H_{pm} = \{h_{ab}:a \in Z_{p}^{*}, b \in Z_p\}\)<br />
该函数簇是全域的。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge85f1f6" class="outline-4">
<h4 id="orge85f1f6">开放寻址法</h4>
<div class="outline-text-4" id="text-orge85f1f6">
<p>
在开放寻址法中，所有元素都存储在散列表中。即，每个表项中或存储一个元素，或存储 NIL 值表示不存储任何元素。<br />
</p>
</div>
<div id="outline-container-org6ea2e81" class="outline-5">
<h5 id="org6ea2e81">线性探查</h5>
<div class="outline-text-5" id="text-org6ea2e81">
<p>
给定一个散列函数 h': U-&gt;{0,1,&#x2026;,m-1} （该函数被称为辅助散列函数），线性探查使用的散列函数为：<br />
</p>
\begin{equation}
h(k,i) = (h'(k)+i) \, mod \, m \quad i = 0,1,2 \ldots , m-1
\end{equation}
<p>
在线性探查方法中，初始探查位置确定了整个序列，故只有 m 种不同的探查序列。<br />
</p>
<ul class="org-ul">
<li>缺点<br />
线性探查存在一次群集问题。随着时间推移，连续被占用的槽不断增加，平均查找时间也不断随着增加。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org99abae8" class="outline-5">
<h5 id="org99abae8">二次探查</h5>
<div class="outline-text-5" id="text-org99abae8">
<p>
二次探查使用的散列函数为：<br />
</p>
\begin{align}
&h(k,i) = (h'(k)+c_1i+c_2i^2) \, mod \, m \quad i = 0,1,2 \ldots , m-1 \nonumber \\
&h'为辅助散列函数，c_1 和 c_2（\neq 0）为辅助常数。\nonumber \\
\end{align}
<p>
和线性探查一样，初始探查位置决定了整个序列，所以也只有 m 中不同的探查序列。<br />
</p>
<ul class="org-ul">
<li>缺点<br />
<ol class="org-ol">
<li>为了充分利用散列表，c1,c2,m 的值选取要受到限制<br /></li>
<li>如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的，这种群集被称为二次群集。<br /></li>
</ol></li>
<li>实例<br />
当 m 为 2 的 n 次幂时，选择 c1=c2=1/2,i 从 0 增加到 m 可以探查一遍所有的元素。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd74dc78" class="outline-5">
<h5 id="orgd74dc78">双重散列</h5>
<div class="outline-text-5" id="text-orgd74dc78">
<p>
双重散列是用于开放寻址法的最好的方法之一，它使用的散列函数为：<br />
</p>
\begin{align}
&h(k,i) = (h_1(k) + ih_2(k)) \, mod \, m \quad i = 0,1,2 \ldots , m-1 \nonumber \\
&h_1 和 h_2 为辅助散列函数。\nonumber \\
\end{align}
<p>
双重散列使用了 \(\Theta(m^2)\) 种探查序列。而线性探查和二次探查都只使用了 m 中探查序列。<br />
</p>

<p>
下面是一组可行的双重散列函数：<br />
</p>
\begin{align}
&h_1(k) = k \, mod \, m  \nonumber \\
&h_2(k) = k \, mod \, m' \nonumber \\
&m 为素数，m' = m - 1 \nonumber \\
\end{align}
</div>
</div>
<div id="outline-container-orgfd3b001" class="outline-5">
<h5 id="orgfd3b001">开放寻址散列的分析</h5>
<div class="outline-text-5" id="text-orgfd3b001">
<ul class="org-ul">
<li>给定一个装载因子为 \(\alpha = n/m < 1\) 的开放寻址散列表，并假设是均匀散列的，则对于一次不成功的查找，其期望的探查次数至多为 \(1/(1-\alpha)\)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org671b444" class="outline-4">
<h4 id="org671b444">完全散列 Perfect Hashing</h4>
<div class="outline-text-4" id="text-org671b444">
<p>
给定 n 个关键字，构造一个静态的 hash 表，该表的大小 \(m=O(n)\) ，在最坏的情况下，查询某个关键字的时间复杂度为 \(O(1)\) ，构造出满足这些条件的哈希被称为完全哈希或完美哈希 Perfect Hashing。<br />
构造完美哈希的一种方法是使用两级哈希，并且每一级哈希都为全域哈希。要满足完美哈希就需要第二级全域哈希不会造成冲突。设 \(n_i\) 个关键字被哈希到一级哈希表的第 i 个槽内，在二级哈希表中使用 \(m_i = n_i^2\) 个空间来存储这 \(n_i\) 个元素，则可以使二级哈希不会造成冲突。<br />
</p>
<ul class="org-ul">
<li><p>
证明 1：二级全域哈希不会造成冲突<br />
</p>
\begin{align}
&随机变量 X 表示哈希产生冲突 \nonumber \\
&E[X] = P\{X\} = \frac{n_i(n_i-1)}{2} \frac{1}{n_i^2} = \frac{1-1/n_i}{2} < \frac{1}{2} \nonumber \\
&依据马尔可夫不等式可得： \nonumber \\
&P\{X \geq t\} \leq \frac{E[X]}{t} \nonumber \\
&P\{X \geq 1\} \leq \frac{1/2}{1}  \nonumber \\
&P\{X \geq 1\} \leq \frac{1}{2}    \nonumber \\
\end{align}</li>
<li><p>
证明 2：二级哈希的存储空间复杂度为 \(O(n)\)<br />
取第一级 hash 表的大小 \(m=n\) ，随机变量 \(n_i\) 表示哈希到第 i 个槽的关键字的数目，在二级哈希表中槽的个数 \(m_i=n_i^2\) 则：<br />
</p>
\begin{align}
&E[totalStorage] = n + E[\sum_{i=0}^{m-1}\theta(n_i^2)] = O(n)    \nonumber
\end{align}</li>
</ul>
</div>
</div>
<div id="outline-container-orgc73a6d8" class="outline-4">
<h4 id="orgc73a6d8">HashTable implement</h4>
<div class="outline-text-4" id="text-orgc73a6d8">
<p>
HashTable 相关算法的实现：<br />
<a href="AlgorithmIntroduce/Code_Hash.lua">AlgorithmIntroduce/Code_Hash.lua</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0567a3d" class="outline-3">
<h3 id="org0567a3d">Binary Search Trees</h3>
<div class="outline-text-3" id="text-org0567a3d">
<p>
二叉查找树中关键字的存储方式满足以下性质：<br />
设 x 为二叉查找树中的节点。如果 y 是 x 的左子树中的节点，则 key[y]&lt;=key[x]。如果 y 是 x 右子树中的节点，则 key[x]&lt;=key[y]。<br />
</p>
</div>
<div id="outline-container-org1db6ea4" class="outline-4">
<h4 id="org1db6ea4">二叉查找树的操作</h4>
<div class="outline-text-4" id="text-org1db6ea4">
<p>
遍历 查找 最大关键字元素和最小关键字元素 前驱和后继 插入和删除<br />
具体实现可以参考如下文件：<br />
<a href="AlgorithmIntroduce/Code_BST.lua">AlgorithmIntroduce/Code_BST.lua</a><br />
</p>
</div>
</div>
<div id="outline-container-orgfa9aaf8" class="outline-4">
<h4 id="orgfa9aaf8">随机构造的二叉查找树</h4>
<div class="outline-text-4" id="text-orgfa9aaf8">
<p>
随机二叉查找树高度的期望值为 \(log_2n\)<br />
</p>
<ul class="org-ul">
<li><p>
证明：<br />
step1- 证明 Jensens 不等式<br />
\(f(E[X]) \leq E[f(X)] \quad f(X)为凹函数。\)<br />
step2- 不直接分析 BST 的高度随机变量 \(X_n\) ,而是分析 \(X_n\) 的凹函数，这里分析的是 \(Y_n = 2^{X_n} \, 即 X_n 的指数函数\)<br />
step3- 证明 \(E[Y_n] = O(n^3)\)<br />
step4- 证明结论<br />
</p>
\begin{align}
&2^{E[X_n]} \leq E[2^{X_n}] = E[Y_n] = O(n^3) \nonumber \\
&对上面的公式两边取对数可得: \nonumber \\
&E[X_n] \leq log_2O(n^3) = 3log_2n+O(1) \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgda612ef" class="outline-3">
<h3 id="orgda612ef">Balance Search Trees</h3>
<div class="outline-text-3" id="text-orgda612ef">
<p>
平衡搜索树的数据结构维护一个 n 个元素的动态集的时间为 \(log_2n\) ，树的高度为 \(O(log_2n)\)<br />
常见的平衡搜索树有：<br />
</p>
<ul class="org-ul">
<li>AVL Trees<br /></li>
<li>2-3 Trees<br /></li>
<li>2-3-4 Trees<br /></li>
<li>B-Trees<br /></li>
<li>Red Black Trees<br /></li>
<li>Skip lists<br /></li>
<li>Treaps<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf5b1cba" class="outline-3">
<h3 id="orgf5b1cba">Red-Black Trees</h3>
<div class="outline-text-3" id="text-orgf5b1cba">
<p>
红黑树是一种二叉搜索树，其中每个节点包含一个 color 属性，并且每个节点满足下面的条件<br />
</p>
<ul class="org-ul">
<li>每个节点为红色或者黑色<br /></li>
<li>根节点和叶子节点都为黑色<br /></li>
<li>每个红色节点的父节点都为黑色 即每个红色节点的两个子节点都为黑色节点<br /></li>
<li>对于每个节点，从该节点到其子孙节点(叶子节点)的所有路径上包含相同数目的黑节点<br /></li>
</ul>
</div>
<div id="outline-container-org46524cf" class="outline-4">
<h4 id="org46524cf">RBTree 的高度</h4>
<div class="outline-text-4" id="text-org46524cf">
<p>
包含 n 个关键字(内节点)的红黑树，它的高度满足 \(h \leq 2log_2(n+1) = O(log_2n)\)<br />
</p>
<ul class="org-ul">
<li><p>
证明<br />
将每个红节点并入它的黑色父节点中，会形成一个 2-3-4 树。<br />
</p>
<ol class="org-ol">
<li>2-3-4 树的每一个内节点中包含 2-4 个子节点<br /></li>
<li>2-3-4 树的所有叶子节点有相同的深度，该深度等于叶子节点的黑高度<br /></li>
</ol>
<p>
假设 生成的该 2-3-4 树的高度为 \(h'\) ，平衡二叉树外节点的个数比所有内节点个数多 1，所以，原来红黑树的外节点数为 \(n+1\) ，所以，该 2-3-4 树的叶子节点的个数 \(leaves = n+1\) 。<br />
</p>
\begin{align}
&而叶子节点的个数满足下面不等式： \nonumber \\
&2^{h'} \leq leaves \leq 4^{h'}  \nonumber \\
&2^{h'} \leq n+1                 \nonumber \\
&h' \leq log_2(n+1)              \nonumber \\
&h \leq 2h' \leq 2log_2(n+1)     \nonumber \\
\end{align}</li>
</ul>
</div>
</div>
<div id="outline-container-org681b7f5" class="outline-4">
<h4 id="org681b7f5">RBTree Insert</h4>
<div class="outline-text-4" id="text-org681b7f5">
<div class="org-src-container">
<pre class="src src-lua">function RBTree_Insert(T, x)
    Tree_Insert(T, x)
    color[x] = RED
    while x!=root[T] and color[p[x]]==RED do
        if p[x] == left[p[p[x]]] then    -- case A x 的父亲为左节点
            y = right[p[p[x]]]
            if color[y] == RED then       -- case A-1 x 的叔叔为红色
                color[p[x]] = BLACK
                color[y] = BLACK
                color[p[p[x]]] = RED
                x = p[p[x]]
            elseif x == right[p[x]] then -- case A-2 x 的叔叔为黑色，并且 x 为右节点
                x = p[x]
                LEFT-Rotate(T,x)
            end

            -- x == left[p[x]]           -- case A-3 x 的叔叔为黑色，并且 x 为左节点
            color[p[x]] = BLACK
            color[p[p[x]]] = RED
            RIGHT-Rotate(T,p[p[x]])
        else -- p[x] == right[p[p[x]]]   -- case B
            print("same as case A")
        end
    end
    color[root[T]] = BLACK
end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgae77ea0" class="outline-4">
<h4 id="orgae77ea0">RBTree Delete</h4>
<div class="outline-text-4" id="text-orgae77ea0">
<ul class="org-ul">
<li>case1 x 的兄弟 w 是红色的<br /></li>
<li>case2 x 的兄弟 w 是黑色的，而且 w 的两个孩子都是黑色的<br /></li>
<li>case3 x 的兄弟 w 是黑色的，w 的左孩子是红色的，右孩子是黑色的<br /></li>
<li>case4 x 的兄弟 w 是黑色的，而且 w 的右孩子是红色的<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5bf9176" class="outline-4">
<h4 id="org5bf9176">Red-Black Tree 实现</h4>
<div class="outline-text-4" id="text-org5bf9176">
<p>
具体实现参考下面文件：<br />
<a href="AlgorithmIntroduce/Code_RBT.lua">AlgorithmIntroduce/Code_RBT.lua</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7f9f550" class="outline-3">
<h3 id="org7f9f550">Augmenting Data Structures</h3>
<div class="outline-text-3" id="text-org7f9f550">
</div>
<div id="outline-container-orge72c70f" class="outline-4">
<h4 id="orge72c70f">动态顺序统计</h4>
<div class="outline-text-4" id="text-orge72c70f">
<p>
用扩展的红黑树来实现动态顺序统计，OS-Select 和 OS-Rank 的时间复杂度为 \(lg(n)\) .<br />
</p>
</div>
</div>
<div id="outline-container-org7b0c5ad" class="outline-4">
<h4 id="org7b0c5ad">为什么不在红黑树中直接记录节点的秩？</h4>
<div class="outline-text-4" id="text-org7b0c5ad">
<p>
秩 即为元素在序列中的顺序值。<br />
因为这样做的话，添加或删除节点，需要修改很多节点的秩，这样维护红黑树的时间复杂度为 \(O(n)\) 。<br />
</p>
</div>
</div>
<div id="outline-container-orgd3b35de" class="outline-4">
<h4 id="orgd3b35de">数据结构扩展</h4>
<div class="outline-text-4" id="text-orgd3b35de">
<p>
数据结构扩展的 4 个步骤：<br />
</p>
<ol class="org-ol">
<li>选择基础数据结构<br /></li>
<li>确定要在基础数据结构中添加哪些信息<br /></li>
<li>验证可用基础数据结构上的基本修改操作来维护这些添加的信息<br /></li>
<li>设计新的操作。<br /></li>
</ol>

<p>
以动态顺序统计为例来说，整个过程为以下步骤：<br />
</p>
<ol class="org-ol">
<li>选择红黑树来作为基础数据结构<br /></li>
<li>在基础数据结构中添加额外的 size[x] 信息，size 为以 x 节点为根的子树的节点数目<br /></li>
<li>插入-删除-节点旋转等操作对新加的 size 信息是可维护的。<br />
[重新实现这些修改操作，来支持对 size 信息的维护]<br /></li>
<li>设计新的操作：OS-Select 和 OS-Rank。<br /></li>
</ol>

<p>
以区间树为例来说，整个过程为以下步骤：<br />
</p>
<ol class="org-ol">
<li>选择红黑树来作为基础数据结构。在基础数据结构中存储区间信息，并以区间的低端点作为节点的关键字<br /></li>
<li>在基础数据结构中添加额外的 max[x]信息，max[x]为以 x 节点为根的子树中端点最大的数值。<br /></li>
<li>重新实现这些修改操作，来支持对 max 信息的维护<br /></li>
<li>设计新的操作：Interval_Search(T, i)<br /></li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbf3f88d" class="outline-2">
<h2 id="orgbf3f88d">Advanced Design And Analysis Techniques</h2>
<div class="outline-text-2" id="text-orgbf3f88d">
</div>
<div id="outline-container-org94c7c97" class="outline-3">
<h3 id="org94c7c97">动态规划法</h3>
<div class="outline-text-3" id="text-org94c7c97">
<p>
详细内容请参考本博客 DynamicProgramming 一文。<br />
</p>
</div>
</div>
<div id="outline-container-orgac3b314" class="outline-3">
<h3 id="orgac3b314">贪心算法</h3>
<div class="outline-text-3" id="text-orgac3b314">
</div>
<div id="outline-container-orgfdbac45" class="outline-4">
<h4 id="orgfdbac45">贪心算法的特征</h4>
<div class="outline-text-4" id="text-orgfdbac45">
<ul class="org-ul">
<li>一个全局最优解可以通过局部最优选择来达到。换句话说就是，当我们考虑做选择时，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。<br /></li>
<li>在贪心算法中，我们做的总是当前看似最佳的选择，然后再解决选择之后所出现的子问题。贪心算法所做的当前选择可能要依赖于已经做出的所有选择，但不依赖于有待做出的选择或子问题的解。因此，贪心策略通常是自顶先下，一个一个地做出贪心选择，不断地将给定的问题实例归约为更小的问题。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9af87c0" class="outline-3">
<h3 id="org9af87c0">平摊分析</h3>
<div class="outline-text-3" id="text-org9af87c0">
<p>
平摊分析是分析一系列数据结构操作的平均时间消耗。即，n 个操作总的时间消耗为 \(C\) ，则一个操作的的时间消耗为 \(\frac{C}{n}\) 。<br />
</p>
</div>
<div id="outline-container-org3fed7b1" class="outline-4">
<h4 id="org3fed7b1">聚集分析</h4>
<div class="outline-text-4" id="text-org3fed7b1">
<p>
通过求总的时间消耗 \(C\) ，然后除以操作数目 \(n\) 得出每个操作的平摊代价。<br />
\(c = \frac{C}{n}\)<br />
</p>
</div>
</div>
<div id="outline-container-org1c50665" class="outline-4">
<h4 id="org1c50665">记账方法</h4>
<div class="outline-text-4" id="text-org1c50665">
<p>
通过为不同的操作收取不同的费用，操作没有花费掉的费用存入银行，用总价格 \(P\) 减去银行的存款 \(B\) 然后再除以总的操作数 $n$。<br />
\(总的平摊代价 C = P-B\)<br />
\(每个操作的平均平摊代价 c = \frac{P-B}{n}\)<br />
\(在 n 个操作中，令第 i 个操作的实际代价为 c_i,第 i 个操作的平摊代价为\widehat{c_i},则对于 n 个操作的所有序列需要满足 \sum_{i=1}^n\widehat{c_i} \geq \sum_{i=1}^nc_i, 这样总的平摊代价就是实际代价的一个上界。\)<br />
</p>
</div>
</div>
<div id="outline-container-org5965a3b" class="outline-4">
<h4 id="org5965a3b">势能方法</h4>
<div class="outline-text-4" id="text-org5965a3b">
<p>
势能方法中不是将已预付的工作作为存储在数据结构特定对象中的存款来表示，而是表示成一种“势能”或“势”，它在需要时可以释放出来，以支付后面的操作。势是与整个数据结构而不是其中的个别对象发生联系的。<br />
\(\widehat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i-1})\)<br />
\(\sum_{i=1}^n\widehat{c_i} = \sum_{i=1}^n(c_i + \Phi(D_i) - \Phi(D_{i-1})) = \sum_{i=1}^nc_i + \Phi(D_i) - \Phi(D_0)\)<br />
如果能定义一个势能函数 \(\Phi\) 使得 \(\Phi(D_i) \geq \Phi(D_0)\) ,则总的平摊代价就是实际代价的一个上界。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org26919c0" class="outline-2">
<h2 id="org26919c0">Graph Algorithms</h2>
<div class="outline-text-2" id="text-org26919c0">
</div>
<div id="outline-container-orge6aab50" class="outline-3">
<h3 id="orge6aab50">图的基本算法</h3>
<div class="outline-text-3" id="text-orge6aab50">
</div>
<div id="outline-container-orgcf68ee9" class="outline-4">
<h4 id="orgcf68ee9">图的表示</h4>
<div class="outline-text-4" id="text-orgcf68ee9">
<ul class="org-ul">
<li>图的数学描述<br />
G=(V,E) 表示拥有顶点集合 V 和边集合 E 的图 G。|V|表示顶点的数量，|E|表示边的数量<br /></li>
<li>邻接矩阵<br />
空间复杂度为 \(|V|^2\)<br />
矩阵中所存储的数值，可用来表示图中边的权值<br /></li>
<li>邻接表<br />
如果 G 是一个有向图，则所有邻接表的长度之和为|E|。如果 G 是一个无向图，则所有邻接表的长度之和为 2|E|。不论是有向图还是无向图，邻接表的空间复杂度为 \(O(V+E)\)<br />
当 E 远小于 \(|V|^2\) 时，采用邻接表更省空间。<br />
邻接表中存储的节点可以携带权值，表示当前顶点到该节点的权值大小。<br />
邻接表在需要确定图中边(u,v)是否存在，只能在邻接表 Adj[u]中搜索是否存在 v。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga08d247" class="outline-4">
<h4 id="orga08d247">广度优先搜索</h4>
<div class="outline-text-4" id="text-orga08d247">
<p>
广度优先搜索的时间复杂度为 \(O(V+E)\)<br />
搜索过程中，通过给节点上色来避免节点重复被访问<br />
广度优先搜索需要利用队列来保证搜索过程基于广度优先。<br />
</p>
</div>
</div>
<div id="outline-container-org4fc4542" class="outline-4">
<h4 id="org4fc4542">深度优先搜索</h4>
<div class="outline-text-4" id="text-org4fc4542">
<p>
深度优先搜索的时间复杂度为 \(O(V+E)\)<br />
搜索过程中，通过给节点上色来避免节点重复被访问<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orga9bb58b" class="outline-3">
<h3 id="orga9bb58b">最小权生成树</h3>
<div class="outline-text-3" id="text-orga9bb58b">
<p>
Minimum Spanning Trees<br />
最小生成树算法 Prim_MST 的思路为 遍历所有顶点，每次取出度最小的节点 NodeMin 进行处理，处理过程中遍历 NodeMin 节点的所有邻接节点为他们更新最小出度值。需要注意的是处理邻接节点时，需要判断邻接节点是否已经被当做 NodeMin 处理过，若是，则不能再次更新其出度。<br />
Prim_MST 的时间复杂度如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">最小优先队列数据结构</th>
<th scope="col" class="org-left">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组</td>
<td class="org-left">\(O(V^2+E)=O(V^2)\)</td>
</tr>

<tr>
<td class="org-left">二叉堆</td>
<td class="org-left">\(O((V+E)lgV)\)</td>
</tr>

<tr>
<td class="org-left">斐波那契堆</td>
<td class="org-left">\(O(VlgV+E)\)</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org42c2719" class="outline-4">
<h4 id="org42c2719">应用</h4>
<div class="outline-text-4" id="text-org42c2719">
<p>
最小生成树可以用来解决整体耗费最小的问题。如下面所述问题<br />
</p>
<ol class="org-ol">
<li>旅游路线选择<br />
N 个旅游地点都得去，但是要总路费最小。<br /></li>
<li>多个城市之间电缆架设等问题<br />
N 个城市都得连接，但是要总的电缆使用最少。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org32ea297" class="outline-3">
<h3 id="org32ea297">最短路径问题</h3>
<div class="outline-text-3" id="text-org32ea297">
</div>
<div id="outline-container-org79768f6" class="outline-4">
<h4 id="org79768f6">单源最短路径</h4>
<div class="outline-text-4" id="text-org79768f6">
<p>
单源最短路径 Dijkstra 的思路为 维护一个集合 \(S\) ,让该集合内的所有元素到源点 \(s\) 的距离为最短距离, 然后不断扩大这个集合让其包含所有的顶点。为了保证新加入集合 \(S\) 的元素符合条件，必须取 \(V-S\) 中距离 \(S\) 最小的元素。具体操作是，从源点开始对图进行广度优先遍历，判断当前顶点的邻接顶点到源点的距离是否比之前记录的距离短，如果是则更新邻接顶点的父节点和其到源点的距离，选出离源点最近的节点进行下次循环操作。<br />
Dijkstra_SingleSourceShortestPath 的时间复杂度如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">最小优先队列数据结构</th>
<th scope="col" class="org-left">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组</td>
<td class="org-left">\(O(V^2+E)=O(V^2)\)</td>
</tr>

<tr>
<td class="org-left">二叉堆</td>
<td class="org-left">\(O((V+E)lgV)\)</td>
</tr>

<tr>
<td class="org-left">斐波那契堆</td>
<td class="org-left">\(O(VlgV+E)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgeeb52f5" class="outline-3">
<h3 id="orgeeb52f5">Graph Implement</h3>
<div class="outline-text-3" id="text-orgeeb52f5">
<p>
关于图的各种基础算法的实现，可以参考如下文件：<br />
<a href="AlgorithmIntroduce/Code_Graph.lua">AlgorithmIntroduce/Code_Graph.lua</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf1023e6" class="outline-2">
<h2 id="orgf1023e6">数学概念</h2>
<div class="outline-text-2" id="text-orgf1023e6">
</div>
<div id="outline-container-orga0c84b3" class="outline-3">
<h3 id="orga0c84b3">对数</h3>
<div class="outline-text-3" id="text-orga0c84b3">
<p>
对数的性质<br />
</p>
\begin{align}
&1 \quad log_aX + log_aY = log_a(XY)          \nonumber \\
&2 \quad log_aX - log_aY = log_a(\frac{X}{Y}) \nonumber \\
&3 \quad log_aX^b = b\,log_aX                 \nonumber \\
&4 \quad \sqrt[log_an]{n} = a                 \nonumber \\
&5 \quad log_ab = \frac{log_cb}{log_ca}       \nonumber \\
&6 \quad a^{b\,log_an} = (a^{log_an})^b = n^b \nonumber \\
&7 \quad log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
&                                             \nonumber \\
证明 5 \quad &log_ab = \frac{log_cb}{log_ca}     \nonumber \\
&另 log_ab = X               \nonumber \\
&则 a^X = b                  \nonumber \\
&对上面的等式两边取 c 的对数有      \nonumber \\
&log_c(a^X) = log_cb         \nonumber \\
&X\,log_ca = log_cb          \nonumber \\
&X = \frac{log_cb}{log_cx}   \nonumber \\
&所以 \quad \frac{log_cb}{log_ca} = log_ab  \nonumber \\
证明 7 \quad &log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
&log_bn \cdot logb_a = log_ba^{log_bn} \nonumber \\
&log_ba \cdot logb_n = log_bn^{log_ba} \nonumber \\
&所以 \quad log_ba^{log_bn} = log_bn^{log_ba}    \nonumber \\
\end{align}
</div>
</div>
<div id="outline-container-org28a2fb3" class="outline-3">
<h3 id="org28a2fb3">概率论</h3>
<div class="outline-text-3" id="text-org28a2fb3">
</div>
<div id="outline-container-org544dac0" class="outline-4">
<h4 id="org544dac0">随机试验</h4>
<div class="outline-text-4" id="text-org544dac0">
<p>
在概率论中把符合下面三个特点的试验叫做随机试验：<br />
</p>
<ol class="org-ol">
<li>一次试验结果的随机性，即进行一次试验之前无法确定哪一个结果会出现。<br /></li>
<li>全体测试结果的可知性，即每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果。<br /></li>
<li>可重复性，即可以在同一条件下重复进行试验。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org9566a0a" class="outline-4">
<h4 id="org9566a0a">随机变量</h4>
<div class="outline-text-4" id="text-org9566a0a">
<p>
设 E 是一个随机试验，其样本空间为 S，若对每一个样本点 \(e \in S\) ，都有唯一确定的实数 X(e) 与之对应，则称 S 上的实值函数 X(e) 是一个随机变量（简记为 X）。<br />
</p>
<ul class="org-ul">
<li>实例一<br />
随机投掷一枚硬币，可能的结果有正面朝上 ，反面朝上两种 ，若定义 X 为投掷一枚硬币时朝上的面 ， 则 X 为一随机变量，当正面朝上时，X 取值 1；当反面朝上时，X 取值 0。<br /></li>
<li>实例二<br />
又如，掷一颗骰子，它的所有可能结果是出现 1 点、2 点、3 点、4 点、5 点和 6 点 ，若定义 X 为掷一颗骰子时出现的点数，则 X 为一随机变量，出现 1，2，3，4，5，6 点时 X 分别取值 1，2，3，4，5，6。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3a2865c" class="outline-4">
<h4 id="org3a2865c">指示器随机变量</h4>
<div class="outline-text-4" id="text-org3a2865c">
<p>
给定一个样本空间 S 和事件 A，那么事件 A 对应的指示器随机变量：<br />
</p>
\begin{eqnarray}
X_{a} =
\begin{cases}
1   & 如果 A 发生 \\
0   & 如果 A 没有发生 \\
\end{cases} \nonumber
\qquad E[X_a] = Pr{A} \nonumber
\end{eqnarray}
</div>
</div>
<div id="outline-container-org133b547" class="outline-4">
<h4 id="org133b547">期望</h4>
<div class="outline-text-4" id="text-org133b547">
<p>
离散型随机变量的一切可能的取值 xi 与对应的概率 Pi(=xi)之积的和称为该离散型随机变量的数学期望（设级数绝对收敛），记为 E（x）。<br />
设连续性随机变量 X 的概率密度函数为 f(x)，若积分绝对收敛，则称积分的值为随机变量的数学期望，记为 E(X)。<br />
<a href="http://www.zhihujingxuan.com/19043.html">http://www.zhihujingxuan.com/19043.html</a><br />
</p>
</div>
</div>
<div id="outline-container-org61f4b35" class="outline-4">
<h4 id="org61f4b35">马尔可夫不等式证明</h4>
<div class="outline-text-4" id="text-org61f4b35">
\begin{align}
&结论： 对于随机变量 X \geq 0, \quad Pr\{X \geq t\} \leq \frac{E[X]}{t} \nonumber \\
&证明： \nonumber \\
E[X] &= \sum_{x=0}^{\infty} x \cdot P_r\{X=x\} \nonumber \\
&\geq \sum_{x=t}^{\infty} x \cdot P_r\{X=x\} \nonumber \\
&\geq \sum_{x=t}^{\infty} t \cdot P_r\{X=x\} \nonumber \\
&= t \cdot P_r\{X \geq t\}
\end{align}
</div>
</div>
</div>
<div id="outline-container-org06d14dc" class="outline-3">
<h3 id="org06d14dc">组合数学</h3>
<div class="outline-text-3" id="text-org06d14dc">
</div>
<div id="outline-container-org41ab28c" class="outline-4">
<h4 id="org41ab28c"><span class="todo TODO">TODO</span> 卡特兰数</h4>
</div>
</div>
</div>
<div id="outline-container-org75049b6" class="outline-2">
<h2 id="org75049b6">Q&amp;A</h2>
<div class="outline-text-2" id="text-org75049b6">
</div>
<div id="outline-container-org32e2bd9" class="outline-3">
<h3 id="org32e2bd9">为什么 cocos2d-x js 和 c++对象的映射采用 hash table 而不使用 dictionary 呢？</h3>
<div class="outline-text-3" id="text-org32e2bd9">
<p>
hash table 的查询效率更高，而 c++和 javascript 交互的时候，需要对该表进行大量查询。<br />
采用链接法处理冲突时，hash table 的平均查询效率为 n/m。<br />
dictionary 的平均查询效率为 h=log(n) 。<br />
当 m=1000 时，n&lt;13746 时，哈希表的查询效率都比 dictionary 要高。<br />
<img src="AlgorithmIntroduce/Img_hash_dict_compare.jpg" alt="Img_hash_dict_compare.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orga2c7b33" class="outline-3">
<h3 id="orga2c7b33">关于 std::unordered_map</h3>
<div class="outline-text-3" id="text-orga2c7b33">
<p>
标准库的 std::unordered_map 内部实现为 hash 表，并且该哈希表的默认最大装载因子 max_load_factor 为 1，当哈希表的装载因子 load_factor 大于等于 max_load_factor 时，会触发 rehash 方法，增大 bucket_count 数目，重新生成 hash 表。<br />
rehash 方法的平均复杂度为 存储元素的个数( \(\frac{n}{m}\) )，最坏复杂度为 存储元素个数的二次方( \(\frac{n(1+n)}{2}\) 所有元素被散列到同一个槽内)。<br />
</p>
<ul class="org-ul">
<li>参考资料<br /></li>
</ul>
<p>
cpp 官方文档 <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/">http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc553766" class="outline-2">
<h2 id="orgc553766">参考资料</h2>
<div class="outline-text-2" id="text-orgc553766">
<ul class="org-ul">
<li>对数公开课<br />
<a href="http://open.163.com/special/Khan/logarithms.html">http://open.163.com/special/Khan/logarithms.html</a><br /></li>
<li>算法导论公开课<br />
<a href="http://open.163.com/special/opencourse/algorithms.html">http://open.163.com/special/opencourse/algorithms.html</a><br /></li>
<li><a href="http://www.bilibili.com/video/av2253077/">http://www.bilibili.com/video/av2253077/</a><br /></li>
<li>全域哈希和完全哈希公开课笔记<br />
<a href="http://www.cnblogs.com/udld/p/4299695.html">http://www.cnblogs.com/udld/p/4299695.html</a><br /></li>
<li>什么是动态规划<br />
<a href="https://www.zhihu.com/question/23995189">https://www.zhihu.com/question/23995189</a><br />
<a href="https://www.zhihu.com/question/23995189/answer/35429905">https://www.zhihu.com/question/23995189/answer/35429905</a><br /></li>
<li>Advanced Data Structures 公开课<br />
MIT 官网视频<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2012/lecture-videos/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2012/lecture-videos/</a><br />
Bilibili 视频<br />
<a href="http://www.bilibili.com/video/av3372873/">http://www.bilibili.com/video/av3372873/</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
