<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-03-02 周六 01:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Dynamic Programming</title>
<meta  name="generator" content="Org-mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.coding.me/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.coding.me/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.coding.me/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="http://wolfand11.coding.me/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.coding.me"> HOME </a>
</div><div id="content">
<h1 class="title">Dynamic Programming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline6">动态规划法</a>
<ul>
<li><a href="#orgheadline1">动态规划的特征</a></li>
<li><a href="#orgheadline2">找寻最优子结构的模式</a></li>
<li><a href="#orgheadline5">动态规划算法的设计步骤</a>
<ul>
<li><a href="#orgheadline3">算法导论列出的设计步骤</a></li>
<li><a href="#orgheadline4">另一种设计步骤</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline28">实例</a>
<ul>
<li><a href="#orgheadline7">最长公共子序列</a>
<ul>
<li><a href="#orgheadline8">穷举法</a></li>
<li><a href="#orgheadline18">动态规划法</a>
<ul>
<li><a href="#orgheadline9">教科书方式</a></li>
<li><a href="#orgheadline17">另一种方式</a>
<ul>
<li><a href="#orgheadline10">所有涉及到的变量</a></li>
<li><a href="#orgheadline11">定义问题的状态</a></li>
<li><a href="#orgheadline15">定义状态转移方程</a></li>
<li><a href="#orgheadline16">求解问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline19">背包问题</a>
<ul>
<li><a href="#orgheadline26">求解过程</a>
<ul>
<li><a href="#orgheadline20">所有涉及到的变量</a></li>
<li><a href="#orgheadline21">定义问题的状态</a></li>
<li><a href="#orgheadline25">定义状态转移方程</a>
<ul>
<li><a href="#orgheadline22">方案 1</a></li>
<li><a href="#orgheadline23">方案 2</a></li>
<li><a href="#orgheadline24">方案 3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline27">相关代码实现</a></li>
</ul>
</li>
<li><a href="#orgheadline29">参考资料</a></li>
</ul>
</div>
</div>
<p>
这篇主要是动态规划算法设计相关的笔记。关于算法其他方面的笔记，可以参考本博客 AlgorithmIntroduce 这篇文章。<br  />
</p>
<!--more-->
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">动态规划法</h2>
<div class="outline-text-2" id="text-orgheadline6">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">动态规划的特征</h3>
<div class="outline-text-3" id="text-orgheadline1">
<ul class="org-ul">
<li>最优子结构<br  />
  如果问题的一个最优解包含子问题的最优解，就称该问题具有最优子结构。<br  />
例如： 如果 z = LCS(x,y)，那么任何 z 序列的前缀也是 x 序列前缀和 y 序列前缀的最长公共子序列<br  /></li>
<li>重叠子问题，一个递归的过程包含少数独立的子问题被反复计算多次。<br  /></li>
<li>在动态规划法中，每一步都要做出选择，但是这些选择依赖于子问题的解。因此，解动态规划问题一般是自底向上，从小子问题处理至大子问题。这样可以避免子问题被反复计算。<br  /></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">找寻最优子结构的模式</h3>
<div class="outline-text-3" id="text-orgheadline2">
<ol class="org-ol">
<li>问题的一个解可以是做一个选择。做这种选择会得到一个或多个有待解决的子问题。<br  /></li>
<li>假设对一个给定的问题，已知的是一个可以导致最优解的选择。不必关心如何确定这个选择，尽管假定它是已知的。<br  /></li>
<li>在已知这个选择后，要确定哪些子问题会随之发生，以及如何最好地描述所得到的子问题空间。<br  />
描述子问题空间的一个有效经验是，尽量保持这个空间简单，然后在需要时再扩充它。<br  />
  在装配线调度问题中，我们所考虑的子问题空间就是从工厂入口通过装配站 \(S_{1,j}和 S_{2,j}\) 的最快路线。这个子问题空间很合适，因而没必要再去尝试一个更具一般性的子问题空间了。<br  />
在矩阵链乘积问题中，考虑的子问题空间是从第 1 个矩阵到第 j 个矩阵相乘时，最优化的加括号方法。<br  /></li>
<li>利用 cut-and-paste 技术，来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的。<br  /></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">动态规划算法的设计步骤</h3>
<div class="outline-text-3" id="text-orgheadline5">
</div><div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">算法导论列出的设计步骤</h4>
<div class="outline-text-4" id="text-orgheadline3">
<ol class="org-ol">
<li>描述最优解的结构。即寻找最优子结构，利用子问题的最优解来构造原问题的一个最优解。<br  /></li>
<li>递归定义最优解的值。<br  /></li>
<li>按自底向上计算最优解的值。<br  /></li>
<li>由计算出的结果构造一个最优解。<br  /></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">另一种设计步骤</h4>
<div class="outline-text-4" id="text-orgheadline4">
<ol class="org-ol">
<li>列出所有涉及到的变量<br  /></li>
<li>定义问题的状态<br  /></li>
<li>定义状态转移方程<br  />
这一步的本质，其实就是寻找最优子结构。找到最优子结构，就可以定义出状态转移方程！<br  />
<ul class="org-ul">
<li><p>
首先，将问题划分为子问题。<br  />
划分子问题的方法：<br  />
</p>
<ul class="org-ul">
<li>问题的一个解可以是做一个选择。做这种选择会得到一个或多个有待解决的子问题。<br  /></li>
</ul>
<ul class="org-ul">
<li>观察状态转移方程。将自变量减去一个值（一般为 1），看看得到的子问题是什么问题。<br  /></li>
</ul></li>
<li>然后，通过子问题来定义原问题，从而得出状态转移方程<br  /></li>
</ul></li>
<li>求解问题<br  /></li>
</ol>

<p>
下面<a href="#orgtarget1">No description for this link</a>中使用了该设计步骤。<br  />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline28" class="outline-2">
<h2 id="orgheadline28">实例</h2>
<div class="outline-text-2" id="text-orgheadline28">
</div><div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">最长公共子序列</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
有两个序列 x[1&#x2026;m] y[1&#x2026;n], (1) 求这两个序列的最长公共子序列之一的长度 (2) 输出所有最长公共子序列<br  />
</p>
</div>
<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8">穷举法</h4>
<div class="outline-text-4" id="text-orgheadline8">
<p>
取 x[1&#x2026;m]的所有子序列，分别遍历 y[1&#x2026;n]来查看是否该子序列是公共子序列，记录下当前最长的所有公共子序列。遍历完之后，依次输出。<br  />
</p>
<ul class="org-ul">
<li>算法分析<br  />
每次遍历 y[1&#x2026;n]的消耗为 n，x[1&#x2026;m]一共有 \(2^m\) 个子序列，所以总的时间消耗为 \(n2^m\)<br  /></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18">动态规划法</h4>
<div class="outline-text-4" id="text-orgheadline18">
</div><div id="outline-container-orgheadline9" class="outline-5">
<h5 id="orgheadline9">教科书方式</h5>
<div class="outline-text-5" id="text-orgheadline9">
<p>
定义 \(LCS(x,y)\) 为序列 x 和 y 的最长公共子序列之一<br  />
定义 \(|S|\) 为 \(S\) 序列的长度<br  />
定义 \(c[i,j] = |LCS(x[1,i],y(1,j))|\)<br  />
则 \(c[m,m] = |LCS(x,y)|\)<br  />
</p>
\begin{eqnarray}
c[i,j] =
\begin{cases}
c[i-1,j-1]+1              & if \, x[i]==y[j] \\
max(c[i,j-1], c[i-1,j])   & other \, cases   \\
\end{cases} \nonumber
\end{eqnarray}
<ul class="org-ul">
<li>最坏情况分析<br  />
取上面的递归公式中最耗时的部分 \(c[i,j] = max(c[i,j-1], c[i-1,j])\) ，将其转化为递归树，可以计算出树的高度为 $m+n$，这个树的节点数目为 \(2^{m+n}\)<br  /></li>
<li>子问题被重复计算<br  />
LCS 问题的子问题空间包含 \(m*n\) 个独立的子问题(c[i,j]一共有 m*n 种组合)，而在最坏情况分析中，一共需要解决的问题数目为  \(2^{m+n}\) ，可以通过记录已经求解过的问题的结果来避免重复的计算。<br  />
使用平摊分析可以得出采用记录求解过的问题结果后，LCS 的时间复杂度为 \(O(n*m)\)<br  /></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-5">
<h5 id="orgheadline17">另一种方式</h5>
<div class="outline-text-5" id="text-orgheadline17">
</div><div id="outline-container-orgheadline10" class="outline-6">
<h6 id="orgheadline10">所有涉及到的变量</h6>
<div class="outline-text-6" id="text-orgheadline10">
<p>
\(序列 S1、序列 S2、最长公共子序列 S、最长公共子序列长度 LCS\)<br  />
\(隐含的变量 S1 第 i 个元素 S1_i、S2 第 j 个元素 S2_j\)<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-6">
<h6 id="orgheadline11">定义问题的状态</h6>
<div class="outline-text-6" id="text-orgheadline11">
<ul class="org-ul">
<li>方案 1<br  />
  LCS(S1,S2) 表示序列 S1 和序列 S2 的最长公共子序列的长度<br  />
更一般的描述是，LCS(s1,s2) 表示序列 s1 和序列 s2 的最长公共子序列的长度<br  />
使用序列最后一个值的索引值来表示也是等价的。即，LCS(i,j)<br  /></li>
<li>方案 2<br  />
LCS(S1) 表示序列 S1 和序列 S2 的最长公共子序列的长度<br  />
更一般的描述是，LCS(s1) 表示序列 s1 和序列 S2 的最长公共子序列的长度<br  />
使用序列最后一个值的索引值来表示也是等价的。即，LCS(i)<br  /></li>
<li>方案 3<br  />
LCS(S) 表示序列 S1 和序列 S2 的最长公共子序列 S 的长度<br  />
更一般的描述是，LCS(s) 表示序列 s1 和序列 s2 的最长公共子序列的长度<br  />
使用序列最后一个值的索引值来表示也是等价的。即，LCS(k)<br  /></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-6">
<h6 id="orgheadline15">定义状态转移方程</h6>
<div class="outline-text-6" id="text-orgheadline15">
</div><ul class="org-ul"><li><a id="orgheadline12"></a>方案 1<br  /><div class="outline-text-7" id="text-orgheadline12">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以最长公共子序列中是否包含当前 s1 序列中最后一个值来划分问题<br  />
</p>
\begin{align}
&LCS(i-1,j)      如果不包含 s1 的最后一个值        \nonumber \\
&LCS(i-1,j)+1    如果包含 s1 的最后一个值         \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
LCS(i,j) =
\begin{cases}
LCS(i-1,j)        & 包含 s1_i     \\
LCS(i-1,j)+1      & 不包含 s1_i    \\
\end{cases} \nonumber
\end{eqnarray}</li>
</ul>
</div></li>
<li><a id="orgheadline13"></a>方案 2<br  /><div class="outline-text-7" id="text-orgheadline13">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以最长公共子序列中是否包含当前 s1 序列中最后一个值来划分问题<br  />
</p>
\begin{align}
&LCS(i-1)      如果不包含 s1 的最后一个值        \nonumber \\
&LCS(i-1)+1    如果包含 s1 的最后一个值         \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
LCS(i) =
\begin{cases}
LCS(i-1)        & 包含 s1_i     \\
LCS(i-1)+1      & 不包含 s1_i    \\
\end{cases} \nonumber
\end{eqnarray}</li>
</ul>
<p>
这种方案的缺点是去掉 s2 这个自变量以后，很难有效定义包含和不包含 \(s1_i\) 的条件。<br  />
</p>
</div></li>
<li><a id="orgheadline14"></a>方案 3<br  /><div class="outline-text-7" id="text-orgheadline14">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以最长公共子序列中是否包含当前 s1 序列中最后一个值来划分问题<br  />
</p>
\begin{align}
&LCS(k)        如果不包含 s1 的最后一个值        \nonumber \\
&LCS(k-1)+1    如果包含 s1 的最后一个值         \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
LCS(k) =
\begin{cases}
LCS(k-1)        & 包含 s1_i     \\
LCS(k-1)+1      & 不包含 s1_i    \\
\end{cases} \nonumber
\end{eqnarray}</li>
</ul>
</div></li></ul>
</div>
<div id="outline-container-orgheadline16" class="outline-6">
<h6 id="orgheadline16">求解问题</h6>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">背包问题</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
<a id="orgtarget1"></a><br  />
</p>
</div>
<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26">求解过程</h4>
<div class="outline-text-4" id="text-orgheadline26">
</div><div id="outline-container-orgheadline20" class="outline-5">
<h5 id="orgheadline20">所有涉及到的变量</h5>
<div class="outline-text-5" id="text-orgheadline20">
<p>
\(物品总数量 N；物品编号 i（物品 i 的价值 W_i 物品 i 的体积 C_i）；背包容量 V；装完背包后获得的最大总价值 F\)<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-5">
<h5 id="orgheadline21">定义问题的状态</h5>
<div class="outline-text-5" id="text-orgheadline21">
<ul class="org-ul">
<li>方案 1<br  />
通过两个自变量来描述问题，即 F(N,V) 表示从 N 个物体中进行选取放入 V 空间中所获得的最大总价值<br  />
更一般的描述就是，F(i,v)表示从 i 个物体中进行选取放入 v 空间中所获得的最大总价值<br  /></li>
<li>方案 2<br  />
通过物品总数量这个自变量来描述问题，即 F(N)表示从 N 个物体中进行选取放入 V 空间中所获得的最大总价值<br  />
更一般的描述就是，F(i)表示从 i 个物体中进行选取放入 V 空间中所获得的最大总价值<br  /></li>
<li>方案 3<br  />
通过背包体积这个自变量来描述问题，即 F(V)表示从 N 个物体中进行选取放入 V 空间中所获得的最大总价值<br  />
更一般的描述就是，F(v)表示从 N 个物体中进行选取放入 v 空间中所获得的最大总价值<br  /></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-5">
<h5 id="orgheadline25">定义状态转移方程</h5>
<div class="outline-text-5" id="text-orgheadline25">
</div><div id="outline-container-orgheadline22" class="outline-6">
<h6 id="orgheadline22">方案 1</h6>
<div class="outline-text-6" id="text-orgheadline22">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以是否选择第 i 个物品来划分问题就会得到下面的子问题。<br  />
</p>
\begin{align}
&F(i-1,v) 如果不选择第 i 个物品        \nonumber \\
&F(i-1,v-C_i)+W_i 如果选择第 i 个物品 \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
F(i,v) =
\begin{cases}
F(i-1,v)           & 不选择物品 i \\
F(i-1,v-C_i)+W_i   & 选择物品 i    \\
\end{cases} \nonumber
\end{eqnarray}</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-6">
<h6 id="orgheadline23">方案 2</h6>
<div class="outline-text-6" id="text-orgheadline23">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以是否选择第 i 个物品来划分问题就会得到下面的子问题。<br  />
</p>
\begin{align}
&F(i-1)     如果不选择第 i 个物品        \nonumber \\
&F(i-1)+W_i 如果选择第 i 个物品 \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
F(i) =
\begin{cases}
F(i-1)       & 不选择物品 i  \\
F(i-1)+W_i   & 选择物品 i    \\
\end{cases} \nonumber
\end{eqnarray}
<p>
从上面定义中可以看出没有考虑背包容量，所以通过子问题定义的原问题是错误的。<br  />
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-6">
<h6 id="orgheadline24">方案 3</h6>
<div class="outline-text-6" id="text-orgheadline24">
<ul class="org-ul">
<li><p>
将问题划分为多个子问题<br  />
以是否选择第 i 个物品来划分问题就会得到下面的子问题。<br  />
</p>
\begin{align}
&F(v)         如果不选择第 i 个物品        \nonumber \\
&F(v-C_i)+W_i 如果选择第 i 个物品         \nonumber \\
\end{align}</li>
<li><p>
通过子问题来定义原问题<br  />
</p>
\begin{eqnarray}
F(v) =
\begin{cases}
F(v)         & 不选择物品 i \\
F(v-C_i)+W_i & 选择物品 i    \\
\end{cases} \nonumber
\end{eqnarray}</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">相关代码实现</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
<a href="DynamicProgramming/Code_DP_LCS.lua">DynamicProgramming/Code_DP_LCS.lua</a><br  />
<a href="DynamicProgramming/Code_DP_Pack.lua">DynamicProgramming/Code_DP_Pack.lua</a><br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-2">
<h2 id="orgheadline29">参考资料</h2>
<div class="outline-text-2" id="text-orgheadline29">
<ul class="org-ul">
<li>什么是动态规划<br  />
<a href="https://www.zhihu.com/question/23995189">https://www.zhihu.com/question/23995189</a><br  />
<a href="https://www.zhihu.com/question/23995189/answer/35429905">https://www.zhihu.com/question/23995189/answer/35429905</a><br  /></li>
<li>背包九讲<br  />
<a href="https://github.com/tianyicui/pack">https://github.com/tianyicui/pack</a><br  /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="gitment-ctn"></div>
           <link rel="stylesheet" href="https://dn-coding-net-public-file.qbox.me/Coding-Comments/v0.0.3/default.css">
           <script src="https://dn-coding-net-public-file.qbox.me/Coding-Comments/v0.0.3/gitment.min.js"></script>
           <script>
           var gitment = new Gitment({
               owner: 'wolfand11',
               repo: 'blog_comments',
               oauth: {
                   client_id: '25bc4077d166c8858dca999bcd070cca',
                   client_secret: 'c9a758cc154771b25162f537ad711c96ae5ac87c',
               },
           });
           gitment.render('gitment-ctn')
           </script>
</div>
</body>
</html>
