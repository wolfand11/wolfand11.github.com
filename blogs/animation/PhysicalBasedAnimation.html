<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-24 周一 10:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PhysicalBasedAnimation</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">PhysicalBasedAnimation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9833842">基于物理的计算机动画入门</a>
<ul>
<li><a href="#org2ed6587">Intro to Physics-Based Animation</a>
<ul>
<li><a href="#orge5d26c4">What’s computer graphics?</a>
<ul>
<li><a href="#org3a519c4">Geometry 的表示-Mesh</a></li>
<li><a href="#org456c5f4">Geometry 的表示-Point Cloud</a></li>
<li><a href="#org72600f4">Geometry 的表示-Grid</a></li>
<li><a href="#org200eb46">Animation</a></li>
<li><a href="#org650335e">Rendering</a></li>
</ul>
</li>
<li><a href="#orgcde12ab">What’s physics-based animation?</a>
<ul>
<li><a href="#org28e73eb">动画的范式</a></li>
<li><a href="#orgd2364e1">Physics-based Aniamtion 研究的内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org960d634">Math Background: Vector, Matrix and Tensor Calculus</a>
<ul>
<li><a href="#org5f4de6e">Vector</a></li>
<li><a href="#org21ec90f">Matrix</a>
<ul>
<li><a href="#org1ed20f3">Singular Value Decomposition</a></li>
<li><a href="#org05a1660">Eigenvalue Decomposition</a></li>
<li><a href="#org3e0d2fc">Symmetric Positive Definiteness (s.p.d)</a></li>
<li><a href="#org6cf78a5">Linear Solver</a>
<ul>
<li><a href="#orgbd6da31">Direct Linear Solver</a></li>
<li><a href="#orgcfde9b2">Iterative Linear Solver</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf099fb3">Tensor Calculus</a>
<ul>
<li><a href="#org93a4453">一阶导数</a></li>
<li><a href="#orgd5c6c4f">二阶导数</a></li>
<li><a href="#org7f5f1d1">Taylor Expansion</a></li>
</ul>
</li>
<li><a href="#org0251e13">Examples</a>
<ul>
<li><a href="#orgf7201d9">向量长度的偏导数</a></li>
<li><a href="#orga05ef92">A Spring</a></li>
<li><a href="#orgf4748f7">A Spring with Two Ends</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org55ce41a">Rigid Body Contacts（Lab 1 ）</a>
<ul>
<li><a href="#orge3fa9ac">Rigid Body Simulation</a></li>
<li><a href="#org11765f7">Translational Motion</a>
<ul>
<li><a href="#org84f3038">Integration Methods</a></li>
<li><a href="#orgdce722e">Apply Intergration For Translational Motion</a></li>
<li><a href="#orgf880b7d">Types of Forces</a></li>
</ul>
</li>
<li><a href="#orgf889788">Rotational Motion</a>
<ul>
<li><a href="#org1a58234">Rotation Represented</a></li>
<li><a href="#org6027fca">Quaternion</a></li>
<li><a href="#org817a4eb">Torque and Inertia</a></li>
</ul>
</li>
<li><a href="#org6f7d13d">Translational and Rotational Motion</a></li>
<li><a href="#org8e61f0e">Particle Collision Detection and Response</a>
<ul>
<li><a href="#orgdfbc659">Penalty methods</a>
<ul>
<li><a href="#orgcfbd04d">Summary of Penalty Methods</a></li>
</ul>
</li>
<li><a href="#orgf3bfff5">Impulse methods</a></li>
</ul>
</li>
<li><a href="#org36179ef">Rigid Collision Detection and Response by Impulse</a></li>
<li><a href="#org7112baf">Shape Matching method</a>
<ul>
<li><a href="#org8698869">优缺点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgedef0af">Mass-Spring Systems</a>
<ul>
<li><a href="#org202ad53">Spring</a></li>
<li><a href="#orgbf6c614">Explicit Integration</a></li>
<li><a href="#org7159b07">Implicit Integration</a>
<ul>
<li><a href="#orgc2cb60d">Newton-Raphson Method</a></li>
<li><a href="#org077c217">Simulation by Newton's Method</a>
<ul>
<li><a href="#org5829d1f">Spring Hessian</a></li>
<li><a href="#org0710075">Positive Definiteness of Hessian</a></li>
<li><a href="#org48231cc">Enforcement of Positive Definiteness</a></li>
<li><a href="#org66db2a6">Jacobi Method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge4280e0">Bending and Locking Issues</a>
<ul>
<li><a href="#orgbdc9953">The Bending Spring Issues</a>
<ul>
<li><a href="#orgb2fe7fa">A Dihedral Angle Model</a></li>
<li><a href="#orgca49dfb">A Quadratic Bending Model</a></li>
</ul>
</li>
<li><a href="#orgcf5f80f">The Locking Issues</a></li>
</ul>
</li>
<li><a href="#org17c6917">Shape Matching</a></li>
</ul>
</li>
<li><a href="#orgbec8297">Constrained Approaches: PBD, PD and others （Lab 2 ）</a>
<ul>
<li><a href="#org388ef65">Position Based Dynamics</a>
<ul>
<li><a href="#orgfb8220e">The Stiffness Issue</a></li>
<li><a href="#orgaf332d6">PBD</a></li>
</ul>
</li>
<li><a href="#orgb179c2a">Strain Limiting</a>
<ul>
<li><a href="#org365a6af">Spring Strain Limit</a></li>
<li><a href="#org9fab488">Triangle Area Limit</a></li>
<li><a href="#orga1fe2f3">Strain Limiting in Simulation</a></li>
</ul>
</li>
<li><a href="#org730a272">Projective Dynamics</a></li>
<li><a href="#orgb45c035">Constrained Dynamics</a></li>
<li><a href="#org54f4ca0">Stable Constrained Dynamics</a></li>
<li><a href="#orgc65306b">Summary</a></li>
</ul>
</li>
<li><a href="#orge28dfec">Collision Handling</a></li>
<li><a href="#org316f16c">Soft Body Dynamics and Finite Element Method （Lab 3）</a>
<ul>
<li><a href="#org27586a3">Linear Finite Element Method</a></li>
<li><a href="#org93dcee1">Finite Volume Method</a>
<ul>
<li><a href="#org3392063">Sumarry</a></li>
</ul>
</li>
<li><a href="#org2b7981c">Hyperelastic Models</a>
<ul>
<li><a href="#orgb13fc8c">Summary</a></li>
</ul>
</li>
<li><a href="#org47343ab">Nonlinear Optimization</a>
<ul>
<li><a href="#org966831b">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbcf2851">Surface Waves （Lab 4）</a>
<ul>
<li><a href="#org2d24df3">Two Types of Simulation Approaches</a></li>
<li><a href="#org9112a08">A Height Field Model</a></li>
<li><a href="#orgd20aec1">Shallow Wave Equation</a>
<ul>
<li><a href="#org4cf776a">Finite Differencing</a></li>
<li><a href="#orgbfd55ee">Second-Order Derivatives</a></li>
<li><a href="#orgfcd3cf0">Discretized Shallow Wave Equation</a></li>
<li><a href="#org924b468">Volume Preservation</a></li>
<li><a href="#org926a037">Pressure</a></li>
<li><a href="#orga18e51e">Viscosity</a></li>
<li><a href="#org8b02da5">Boundary Conditions</a></li>
<li><a href="#org38df689">Two-Way Coupling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7a2d795">Incompressible Fluid Dynamics and Eulerian Fluids</a></li>
<li><a href="#org9a34398">SPH and Position-Based Fluids</a></li>
<li><a href="#org753ec7a">参考资料</a></li>
</ul>
</li>
<li><a href="#orgc707cfe">基于物理的计算机动画入门作业</a>
<ul>
<li><a href="#org2889d94">homework01</a>
<ul>
<li><a href="#orgf7beacf">ERROR ShapeMatching 模拟中兔子没有旋转效果</a></li>
</ul>
</li>
<li><a href="#org606a173">homework02</a></li>
<li><a href="#orgb4c6160">homework03</a>
<ul>
<li><a href="#org32f40ba">ERROR 第一帧模型就炸裂了</a></li>
<li><a href="#org61dc554">ERROR 碰撞后模型炸裂</a></li>
<li><a href="#org3120bbc">ERROR 使用 homework01 中，Impulse 方法处理碰撞，碰撞后模型缓慢往下陷</a></li>
<li><a href="#org6f7fadf">ERROR svd 版本中，房子会被压扁，然后炸裂</a></li>
<li><a href="#orga534945">ERROR svd 版本不开启 LaplacianSmooth 时，开始几秒后炸裂</a></li>
</ul>
</li>
<li><a href="#org93801dd">homework04</a>
<ul>
<li><a href="#org85bba77">ERROR 立方体会陷入水中越来越深</a></li>
<li><a href="#orgc963901">ERROR 部分水波会从漂浮的立方体内部穿出来</a></li>
<li><a href="#org87fb2e9">ERROR 立方体下面水波会反向突出一大块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbcbd062">高级物理引擎实战指南 2020</a>
<ul>
<li><a href="#orge6745f2">参考资料</a></li>
</ul>
</li>
<li><a href="#org71308e2">PhysicalBasedAnimation</a>
<ul>
<li><a href="#org5c3ae5f">Harmonic Oscillator 简谐振子</a></li>
<li><a href="#org725422d">Mechanical Energy 机械能</a></li>
<li><a href="#org0b3f61c">Conservation Laws 守恒定律</a></li>
<li><a href="#org39bcf19">Symplecticity</a></li>
<li><a href="#org677db22">Numerical Integration</a></li>
<li><a href="#org24c25fe">Integrator Properties</a></li>
<li><a href="#orgc237c76">Solving Implicit Integrators</a></li>
<li><a href="#orgcc5e939">Optimization</a></li>
<li><a href="#org6ec7922">Newtons Method</a></li>
<li><a href="#org603002f">Nonconvexity</a></li>
<li><a href="#orgc130b0f">Direct Solvers</a></li>
<li><a href="#orgafe5eab">Iterative Methods</a></li>
<li><a href="#org9ec17ac">Finite Elements</a></li>
<li><a href="#org49ec894">FE Potential</a></li>
<li><a href="#org6b63618">Final FEM notes and Wrap up</a></li>
<li><a href="#org623a3ee">Constraints</a></li>
<li><a href="#orge165639">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
PhysicalBasedAnimation note.<br />
</p>
<div class="HTML" id="orgdd80062">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org9833842" class="outline-2">
<h2 id="org9833842">基于物理的计算机动画入门</h2>
<div class="outline-text-2" id="text-org9833842">
</div>
<div id="outline-container-org2ed6587" class="outline-3">
<h3 id="org2ed6587">Intro to Physics-Based Animation</h3>
<div class="outline-text-3" id="text-org2ed6587">
</div>
<div id="outline-container-orge5d26c4" class="outline-4">
<h4 id="orge5d26c4">What’s computer graphics?</h4>
<div class="outline-text-4" id="text-orge5d26c4">
<p>
计算机图形学分为三个部分：<br />
</p>
<ul class="org-ul">
<li>Geometry : Modeling the 3D World<br /></li>
<li>Animation : Animate the 3D World<br /></li>
<li>Rendering : Visualize the 3D World<br /></li>
</ul>

<p>
下图为实时图形学整体的管线：<br />
<img src="./PhysicalBasedAnimation/games103_realtime_graphics_pipeline.jpg" alt="games103_realtime_graphics_pipeline.jpg" /><br />
</p>
</div>

<div id="outline-container-org3a519c4" class="outline-5">
<h5 id="org3a519c4">Geometry 的表示-Mesh</h5>
<div class="outline-text-5" id="text-org3a519c4">
<ul class="org-ul">
<li>mesh 由顶点和元素构成。顶点就是节点，元素可以是三角形、多边形、四面体等等<br /></li>
<li>三角形 mesh 是当前图形学的基础。显卡都是基于三角形 mesh 所设计的<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>构建 mesh(meshing) : Delaunay triangulation<br /></li>
<li>简化 mesh、细分 mesh<br /></li>
<li>mesh 优化 : smoothing, flows<br /></li>
<li>volume mesh<br /></li>
</ul></li>
<li>mesh 又分为两种类型：Structured Mesh 和 Unstructured Mesh<br /></li>
</ul>


<div id="org113aa86" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_mesh.jpg" alt="games103_mesh.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org456c5f4" class="outline-5">
<h5 id="org456c5f4">Geometry 的表示-Point Cloud</h5>
<div class="outline-text-5" id="text-org456c5f4">
<ul class="org-ul">
<li>点云表示几何体很简单，表面扫描就可以得到点云表示的几何体<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>从点云构造 Mesh<br /></li>
<li>对点云进行采样<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org72600f4" class="outline-5">
<h5 id="org72600f4">Geometry 的表示-Grid</h5>
<div class="outline-text-5" id="text-org72600f4">
<ul class="org-ul">
<li>使用 grid 对整个空间进行分割，每个 cell 存储对应点的物理信息<br /></li>
<li>体积扫描(如 CT)可以获得 grid 表示的几何体<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>grid 表示几何体内存占用比较大，如何优化？<br /></li>
<li>体积渲染<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org200eb46" class="outline-5">
<h5 id="org200eb46">Animation</h5>
<div class="outline-text-5" id="text-org200eb46">
<p>
动画分为角色动画(Character Animation)和基于物理的动画(Physics-Based Aniamtion)<br />
</p>
</div>
</div>
<div id="outline-container-org650335e" class="outline-5">
<h5 id="org650335e">Rendering</h5>
<div class="outline-text-5" id="text-org650335e">
<p>
渲染分为两大类：真实感渲染和非真实感渲染<br />
材质是渲染相关的一个重要话题。材质扫描（物体、人）<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcde12ab" class="outline-4">
<h4 id="orgcde12ab">What’s physics-based animation?</h4>
<div class="outline-text-4" id="text-orgcde12ab">
</div>
<div id="outline-container-org28e73eb" class="outline-5">
<h5 id="org28e73eb">动画的范式</h5>
<div class="outline-text-5" id="text-org28e73eb">
<p>
动画的目的是在每段时间间隔内更新物体的状态。被更新的状态可以是 位置、朝向、速度、外观、密度等等。time step 不必和 frame rate 相匹配，通常动画的 time step 要比渲染的 time step 要小，即动画帧率大于渲染帧率。<br />
<img src="./PhysicalBasedAnimation/games103_animation_paradigm.jpg" alt="games103_animation_paradigm.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd2364e1" class="outline-5">
<h5 id="orgd2364e1">Physics-based Aniamtion 研究的内容</h5>
<div class="outline-text-5" id="text-orgd2364e1">
<p>
下图展示了基于物理动画的研究内容：<br />
<img src="./PhysicalBasedAnimation/games103_animation_topics01.jpg" alt="games103_animation_topics01.jpg" /><br />
</p>

<p>
SIGGRAPH 2013 A Material Point Method for Snow Simulation 论文中使用 Hybrid Method 来模拟雪。<br />
</p>

<p>
下图展示了本课程所设计的内容：<br />
<img src="./PhysicalBasedAnimation/games103_animation_topics02.jpg" alt="games103_animation_topics02.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org960d634" class="outline-3">
<h3 id="org960d634">Math Background: Vector, Matrix and Tensor Calculus</h3>
<div class="outline-text-3" id="text-org960d634">
</div>
<div id="outline-container-org5f4de6e" class="outline-4">
<h4 id="org5f4de6e">Vector</h4>
<div class="outline-text-4" id="text-org5f4de6e">
<ul class="org-ul">
<li>利用 Vector 点积表示平面<br /></li>
<li>利用 Vector 叉积判断点是否在三角形内<br /></li>
<li>利用 Vector 叉积计算 barycentric coordinates<br /></li>
<li>利用 Vector 表示四面体, 求四面体内一点的 barycentric weights<br /></li>
<li>利用 Vector 检测运动粒子和三角形的相交<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org21ec90f" class="outline-4">
<h4 id="org21ec90f">Matrix</h4>
<div class="outline-text-4" id="text-org21ec90f">
</div>
<div id="outline-container-org1ed20f3" class="outline-5">
<h5 id="org1ed20f3">Singular Value Decomposition</h5>
<div class="outline-text-5" id="text-org1ed20f3">
<p>
一个矩阵 A 可以被分解为 UDV<sup>T</sup>。U和 V 为正交矩阵，D为对角矩阵。<br />
奇异值分解的直观解释： 任何一个线性变形都可以被分解为三个步骤，1 旋转(U),2 缩放(D),3 旋转(V<sup>T</sup>)<br />
</p>


<div id="org4816044" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_singular_value_decomposition.jpg" alt="games103_singular_value_decomposition.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org05a1660" class="outline-5">
<h5 id="org05a1660">Eigenvalue Decomposition</h5>
<div class="outline-text-5" id="text-org05a1660">
<p>
图形学中只考虑对称矩阵的特征值分解。对称矩阵（Symmetric Matrices）是指以主对角线为对称轴，各元素对应相等的矩阵。<br />
一个对称矩阵 A 可以被分解为 UDU<sup>-1</sup>。U为特征向量组成的正交矩阵，D为特征值组成的对角矩阵。<br />
</p>

<p>
非对称矩阵 A 也可以进行特征值分解，此时特征值和特征向量为虚数。<br />
</p>
</div>
</div>
<div id="outline-container-org3e0d2fc" class="outline-5">
<h5 id="org3e0d2fc">Symmetric Positive Definiteness (s.p.d)</h5>
<div class="outline-text-5" id="text-org3e0d2fc">
<p>
对于任意不等于 0 的向量 v，如果 v<sup>T</sup>Av &gt; 0, 则对称矩阵 A 对称正定(symmetric positive definiteness)<br />
对于任意不等于 0 的向量 v，如果 v<sup>T</sup>Av &gt;= 0, 则对称矩阵 A 对称半正定(symmetric semi-definite)<br />
</p>

<p>
上面定义的直观理解：<br />
<img src="./PhysicalBasedAnimation/games103_spd_matrix.jpg" alt="games103_spd_matrix.jpg" /><br />
</p>

<ul class="org-ul">
<li>矩阵 A 特征值都大于 0 则矩阵 A 是正定的(Positive Definiteness)。通常不使用特征值分解来判断矩阵是否是正定的，因为这样特征值分解比较耗时<br /></li>
<li>对角占优的矩阵是正定的，但正定矩阵不一定是对角占优的<br />
<img src="./PhysicalBasedAnimation/games103_spd_diagonally_nominant.jpg" alt="games103_spd_diagonally_nominant.jpg" /><br /></li>
<li>s.p.d 矩阵是可逆的<br />
<img src="./PhysicalBasedAnimation/games103_spd_invertible.jpg" alt="games103_spd_invertible.jpg" /><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6cf78a5" class="outline-5">
<h5 id="org6cf78a5">Linear Solver</h5>
<div class="outline-text-5" id="text-org6cf78a5">
<p>
很多数值计算问题最终都会被化解为求解一个线性系统，一个线性系统可以被形式化地表示为：<br />
<img src="./PhysicalBasedAnimation/games103_linear_system.jpg" alt="games103_linear_system.jpg" /><br />
</p>
<ul class="org-ul">
<li>A 为方阵<br /></li>
<li>x 为未知量<br /></li>
<li>b 为边界条件<br /></li>
</ul>
<p>
如果可以直接计算 A<sup>-1</sup>，则 x = A{-1}b<br />
但是，A<sup>-1</sup>的计算通常比较耗时，而且如果 A 为稀疏矩阵，A{-1}可能不是稀疏矩阵，则存储 A{-1}占用的空间会比较多。<br />
</p>

<p>
通常有两种方法来求解线性系统：直接法(direct)和迭代法(iterative)<br />
</p>
</div>
<div id="outline-container-orgbd6da31" class="outline-6">
<h6 id="orgbd6da31">Direct Linear Solver</h6>
<div class="outline-text-6" id="text-orgbd6da31">
<p>
直接法通常会基于 LU 分解或 LU 分解的变种(Cholesky,LDL<sup>T</sup> 等等)。LU 分解和其变种的差别主要在内存占用上，LU 分解 &gt; LDL<sup>T</sup> &gt; Cholesky<br />
LU 分解就是将矩阵 A 分解为上三角矩阵和下三角矩阵：<br />
<img src="./PhysicalBasedAnimation/games103_lu_factorization.jpg" alt="games103_lu_factorization.jpg" /><br />
</p>

<p>
LU 分解求解线性系统的原理如下：<br />
<img src="./PhysicalBasedAnimation/games103_lu_linear_solver.jpg" alt="games103_lu_linear_solver.jpg" /><br />
</p>

<p>
直接法的特点：<br />
</p>
<ul class="org-ul">
<li>如果 A 是稀疏矩阵，L和 U 稀疏性会减低。稀疏性和矩阵的行列的排列有关<br /></li>
<li>直接法分两部：1 LU 分解；2 求解。如果多个问题公用 A，则第一步 LU 分解可以被公用<br /></li>
<li>LU 分解部分被不易于并行<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcfde9b2" class="outline-6">
<h6 id="orgcfde9b2">Iterative Linear Solver</h6>
<div class="outline-text-6" id="text-orgcfde9b2">
<p>
迭代法的基本形式是每次迭代对 x 进行更新，如：一开始知道 x0, 对其更新一次后得到 x1，再更新一次后得到 x2，迭代多次后，xn 就是满足 Ax=b 条件的 x。形式化表示如下图：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver01.jpg" alt="games103_iterative_linear_solver01.jpg" /><br />
</p>

<p>
若 b-Ax[k] 趋近于 0 时，上面迭代法收敛，通过考察 b-Ax[k+1] 来进一步细化迭代法的收敛条件：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver02.jpg" alt="games103_iterative_linear_solver02.jpg" /><br />
</p>

<ul class="org-ul">
<li>矩阵谱半径 <a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E8%B0%B1%E5%8D%8A%E5%BE%84/7905023?fr=aladdin">https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E8%B0%B1%E5%8D%8A%E5%BE%84/7905023?fr=aladdin</a><br /></li>
</ul>

<p>
上面形式化的表达式中的矩阵 M 是迭代矩阵，矩阵 M 的逆矩阵必须是容易被求解的，因此 M 的选择为矩阵 A 的对角矩阵或矩阵 A 的下三角矩阵：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver03.jpg" alt="games103_iterative_linear_solver03.jpg" /><br />
</p>


<div id="orgb138fdc" class="figure">
<p><img src="./PhysicalBasedAnimation/matrix_inverse.png" alt="matrix_inverse.png" /><br />
</p>
</div>

<p>
和直接法相比，迭代法的优缺点如下：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver04.jpg" alt="games103_iterative_linear_solver04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf099fb3" class="outline-4">
<h4 id="orgf099fb3">Tensor Calculus</h4>
<div class="outline-text-4" id="text-orgf099fb3">
</div>
<div id="outline-container-org93a4453" class="outline-5">
<h5 id="org93a4453">一阶导数</h5>
<div class="outline-text-5" id="text-org93a4453">
<p>
一元函数的微分、导数<br />
二元函数的偏微分、方向导数、梯度<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base01.jpg" alt="games103_calculus_base01.jpg" /><br />
</p>

<p>
多元向量值函数、多元向量值函数的偏微分组成的雅可比矩阵、散度(通量密度)、旋度(环流量密度)<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base02.jpg" alt="games103_calculus_base02.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd5c6c4f" class="outline-5">
<h5 id="orgd5c6c4f">二阶导数</h5>
<div class="outline-text-5" id="text-orgd5c6c4f">
<p>
多元函数的二阶偏微分组成的 Hessian 矩阵、Lapacian<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base03.jpg" alt="games103_calculus_base03.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org7f5f1d1" class="outline-5">
<h5 id="org7f5f1d1">Taylor Expansion</h5>
<div class="outline-text-5" id="text-org7f5f1d1">
<p>
下图为一元函数和多元函数的泰勒展开<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base04.jpg" alt="games103_calculus_base04.jpg" /><br />
</p>

<ul class="org-ul">
<li>如何通俗地解释泰勒公式？ <a href="https://www.zhihu.com/question/21149770">https://www.zhihu.com/question/21149770</a><br /></li>
<li>如何通俗地解释泰勒公式？ <a href="https://www.matongxue.com/madocs/7">https://www.matongxue.com/madocs/7</a><br /></li>
<li>使用泰勒展开求积分 <a href="https://zhuanlan.zhihu.com/p/250461761">https://zhuanlan.zhihu.com/p/250461761</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0251e13" class="outline-4">
<h4 id="org0251e13">Examples</h4>
<div class="outline-text-4" id="text-org0251e13">
</div>
<div id="outline-container-orgf7201d9" class="outline-5">
<h5 id="orgf7201d9">向量长度的偏导数</h5>
<div class="outline-text-5" id="text-orgf7201d9">
<p>
向量长度的偏导数为向量转置后的单位向量，梯度的方向为偏导数向量的转置，因此向量长度的梯度为向量对应的单位向量，即沿着向量方向生长，向量的长度变长。<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_01.jpg" alt="games103_calculus_base_app_01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orga05ef92" class="outline-5">
<h5 id="orga05ef92">A Spring</h5>
<div class="outline-text-5" id="text-orga05ef92">
<p>
能量求导得到力，力求导得到 stiffness（stiffness 是 Hessian 矩阵）：<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_02.jpg" alt="games103_calculus_base_app_02.jpg" /><br />
</p>

<p>
上面 Tangent stiffness 的推导如果看不懂，可以直接看视频讲解。<br />
</p>
</div>
</div>
<div id="outline-container-orgf4748f7" class="outline-5">
<h5 id="orgf4748f7">A Spring with Two Ends</h5>
<div class="outline-text-5" id="text-orgf4748f7">
<p>
弹簧两端都可以移动的情况：<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_03.jpg" alt="games103_calculus_base_app_03.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org55ce41a" class="outline-3">
<h3 id="org55ce41a">Rigid Body Contacts（Lab 1 ）</h3>
<div class="outline-text-3" id="text-org55ce41a">
<p>
刚体只允许平移和旋转两种运动，这两种运动不会让物体产生形变。<br />
</p>
</div>
<div id="outline-container-orge3fa9ac" class="outline-4">
<h4 id="orge3fa9ac">Rigid Body Simulation</h4>
<div class="outline-text-4" id="text-orge3fa9ac">
<p>
模拟刚体就是随着时间不断更新刚体的状态变量。图示如下：<br />
</p>


<div id="org333ea6b" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_001.jpg" alt="games103_rigid_body_simu_001.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org11765f7" class="outline-4">
<h4 id="org11765f7">Translational Motion</h4>
<div class="outline-text-4" id="text-org11765f7">
<p>
只考虑平移运动时，物体的状态变量包括：位置和速度。使用下面方法，利用 t0 时刻的状态，求出 t1 时刻的状态：<br />
</p>


<div id="org914c0c0" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_002.jpg" alt="games103_rigid_body_simu_002.jpg" /><br />
</p>
</div>

<p>
从上图可以看出，模拟涉及到的主要运算就是求积分。<br />
</p>
</div>
<div id="outline-container-org84f3038" class="outline-5">
<h5 id="org84f3038">Integration Methods</h5>
<div class="outline-text-5" id="text-org84f3038">
<p>
显式 Euler 方法求积分如下：(该方法一阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_001.jpg" alt="games103_rigid_body_simu_integration_001.jpg" /><br />
</p>

<p>
隐式 Euler 方法求积分如下：(该方法一阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_002.jpg" alt="games103_rigid_body_simu_integration_002.jpg" /><br />
</p>

<p>
上述泰勒展开的推导：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_003.jpg" alt="games103_rigid_body_simu_integration_003.jpg" /><br />
</p>

<p>
Mid-point 方法求积分如下：(该方法二阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_004.jpg" alt="games103_rigid_body_simu_integration_004.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgdce722e" class="outline-5">
<h5 id="orgdce722e">Apply Intergration For Translational Motion</h5>
<div class="outline-text-5" id="text-orgdce722e">
<p>
显式、隐式方法（半隐式方法）：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_apply_001.jpg" alt="games103_rigid_body_simu_apply_001.jpg" /><br />
</p>

<p>
Leapfrog 方法：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_apply_002.jpg" alt="games103_rigid_body_simu_apply_002.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgf880b7d" class="outline-5">
<h5 id="orgf880b7d">Types of Forces</h5>
<div class="outline-text-5" id="text-orgf880b7d">

<div id="orgd652ea6" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_forces.jpg" alt="games103_rigid_body_simu_forces.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf889788" class="outline-4">
<h4 id="orgf889788">Rotational Motion</h4>
<div class="outline-text-4" id="text-orgf889788">
</div>
<div id="outline-container-org1a58234" class="outline-5">
<h5 id="org1a58234">Rotation Represented</h5>
<div class="outline-text-5" id="text-org1a58234">
<p>
矩阵表示旋转的优缺点：<br />
</p>
<ul class="org-ul">
<li>优点:<br />
<ul class="org-ul">
<li>使用矩阵和向量的乘法就可以表示物体的旋转<br /></li>
</ul></li>
<li>缺点<br />
<ul class="org-ul">
<li>3x3 矩阵有 9 个元素，而旋转只有 3 个自由度，因此矩阵表示旋转有很多冗余<br /></li>
<li>不直观<br /></li>
<li>定义旋转速度比较困难<br /></li>
</ul></li>
</ul>

<p>
欧拉角表示旋转的优缺点：<br />
</p>
<ul class="org-ul">
<li>优点：<br />
<ul class="org-ul">
<li>直观<br /></li>
<li>Unity 用户操作界面中使用了欧拉角表示旋转，euler 角所使用的旋转顺序为：Z，X，Y<br /></li>
</ul></li>
<li>缺点：<br />
<ul class="org-ul">
<li>存在万向锁问题<br /></li>
<li>定义旋转速度比较困难<br /></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6027fca" class="outline-5">
<h5 id="org6027fca">Quaternion</h5>
<div class="outline-text-5" id="text-org6027fca">
<p>
在复数系统中，a+bi 可以表示一个二维的点，a+bi+cj+dk 可以表示一个三维的点。<br />
</p>

<p>
四元数计算法则如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_quaternion.jpg" alt="games103_rigid_body_quaternion.jpg" /><br />
</p>

<p>
四元数表示旋转可以避免万向锁、而且定义旋转速度比较容易。<br />
关于四元数详情，请参考 <a href="../theory/ComputerGraphicMath.html#org387c6eb">ComputerGraphicMath 中 Quaternions 部分</a><br />
</p>
</div>
</div>

<div id="outline-container-org817a4eb" class="outline-5">
<h5 id="org817a4eb">Torque and Inertia</h5>
<div class="outline-text-5" id="text-org817a4eb">
<p>
力矩描述了力所引起的旋转的趋势。力矩越大旋转越强烈、力矩越小旋转越弱。(等价于平移运动中的力)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_torque.jpg" alt="games103_rigid_body_simu_torque.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_torque_01.jpg" alt="games103_rigid_body_simu_torque_01.jpg" /><br />
</p>

<p>
转动惯量(Inertia)描述了对旋转趋势的抵抗。和质量不同，转动惯量不是一个常数，其为一个矩阵。(等价于平移运动中的质量)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_inertia.jpg" alt="games103_rigid_body_simu_inertia.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org6f7d13d" class="outline-4">
<h4 id="org6f7d13d">Translational and Rotational Motion</h4>
<div class="outline-text-4" id="text-org6f7d13d">

<div id="orge92f876" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_sum.jpg" alt="games103_rigid_body_simu_sum.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org8e61f0e" class="outline-4">
<h4 id="org8e61f0e">Particle Collision Detection and Response</h4>
<div class="outline-text-4" id="text-org8e61f0e">
<p>
质点的碰撞检测和响应。<br />
有符号的距离函数（signed distance function）来描述一个点到表面的距离。符合指示了点在表面的哪一侧。<br />
<img src="./PhysicalBasedAnimation/games103_signed_distance_func_01.jpg" alt="games103_signed_distance_func_01.jpg" /><br />
</p>

<p>
使用有符号距离函数的具体实例：<br />
<img src="./PhysicalBasedAnimation/games103_signed_distance_func_02.jpg" alt="games103_signed_distance_func_02.jpg" /><br />
</p>
</div>

<div id="outline-container-orgdfbc659" class="outline-5">
<h5 id="orgdfbc659">Penalty methods</h5>
<div class="outline-text-5" id="text-orgdfbc659">
<p>
Penalty 方法首先检测当前是否发生碰撞，若发生则应用一个力将粒子弹开。<br />
当使用的力和粒子进入物体的距离为线性关系时，此时的能量和进入物体的距离为二次关系，因此称该 Penalty 方法为 Quadratic Penalty Method.<br />
</p>


<div id="orgc5bec52" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func.jpg" alt="games103_rigid_body_simu_penalty_func.jpg" /><br />
</p>
</div>

<p>
上面的方法中，无论 k 多大都无法严格避免穿透，因为只有穿透时，才会应用 Penalty 力将粒子弹开。因此，可以在表面之上增加一个缓存区，进入缓冲区就对粒子应用 Penalty 力。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func_01.jpg" alt="games103_rigid_body_simu_penalty_func_01.jpg" /><br />
</p>

<p>
上面的方法中，当 k 比较小时，若粒子猛烈撞向物体时，粒子依然有可能进入物体内；当 k 比较大时，粒子缓缓撞向物体时，粒子可能会被弹很远（overshooting 问题）。<br />
为了缓解这些问题，可以将 k 和碰撞距离关联起来，碰撞距离越小 k 越大，碰撞距离越大 k 越小。新的方法被称为 Log-Barrier Penalty Method。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func_02.jpg" alt="games103_rigid_body_simu_penalty_func_02.jpg" /><br />
</p>

<p>
上面方法无法完全避免 overshooting。而且当粒子穿透物体时，会越陷越深，因此需要小步长来保证不会发生穿透。<br />
</p>
</div>

<div id="outline-container-orgcfbd04d" class="outline-6">
<h6 id="orgcfbd04d">Summary of Penalty Methods</h6>
<div class="outline-text-6" id="text-orgcfbd04d">
<ul class="org-ul">
<li>使用 Penalty 方法，通常都需要调整步长<br />
<ul class="org-ul">
<li>调整步长用于避免 overshooting<br /></li>
<li>在 log-barrier 方法中，调整步长用于避免穿透<br /></li>
</ul></li>
<li>log-barrier 方法可以和 buffer 相结合<br /></li>
<li>Penalty 方法无法处理摩擦交互<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf3bfff5" class="outline-5">
<h5 id="orgf3bfff5">Impulse methods</h5>
<div class="outline-text-5" id="text-orgf3bfff5">
<p>
Penalty 方法是通过施加力来起作用的，力的影响会在下一帧生效，其不会在当前帧影响物体的位置和速度。<br />
Impulse 方法则是在碰撞发生时立刻对位置和速度进行修改。<br />
</p>


<div id="org869bdf7" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func.jpg" alt="games103_rigid_body_simu_impulse_func.jpg" /><br />
</p>
</div>

<p>
刚体一般使用 Impulse 方法，衣服和弹性体一般使用 Penalty 方法。物理世界中，本质上碰撞是由于分子之间的互斥导致的，摩擦是由于表面的不平整导致的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org36179ef" class="outline-4">
<h4 id="org36179ef">Rigid Collision Detection and Response by Impulse</h4>
<div class="outline-text-4" id="text-org36179ef">
<p>
由多个顶点组成的物体，循环判断每个顶点的碰撞情况来进行处理。但是，更新每个顶点的位置、速度、朝向、角速度是不可行的，最终，还是需要修改刚体整体的位置、速度、朝向以及角速度。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_001.jpg" alt="games103_rigid_body_simu_impulse_func_001.jpg" /><br />
整个算法流程如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_002.jpg" alt="games103_rigid_body_simu_impulse_func_002.jpg" /><br />
</p>

<p>
实现注意事项：<br />
</p>
<ul class="org-ul">
<li>当同时有多个点产生碰撞时，取多个点位置的平均值，来进行碰撞计算。如果多个点都进行单独处理的化，会导致冲量过大。<br /></li>
<li>当存在重力时，使得速度永远都有一个往下的量，而碰撞的冲量又使得物体反弹。这样就使得物体在平面上反复振荡（oscillation）, 可以通过衰减 μ<sub>N</sub> 来减少 oscillation.<br /></li>
<li>为什么不直接更新位置？<br />
<ul class="org-ul">
<li>因为位置不是线性问题<br /></li>
<li>在后续讲约束时，会再讲该问题 TODO<br /></li>
</ul></li>
</ul>

<p>
多个物体接触的情况：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_003.jpg" alt="games103_rigid_body_simu_impulse_func_003.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org7112baf" class="outline-4">
<h4 id="org7112baf">Shape Matching method</h4>
<div class="outline-text-4" id="text-org7112baf">
<p>
Shape Matching 方法的背后理念：假设刚体可以变形，单独模拟刚体每个顶点的运动，然后，再将物体变回原来的形状。如下图所示：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_01.jpg" alt="games103_rigid_body_simu_shape_matching_01.jpg" /><br />
数学原理描述如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_02.jpg" alt="games103_rigid_body_simu_shape_matching_02.jpg" /><br />
整体的实现如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_03.jpg" alt="games103_rigid_body_simu_shape_matching_03.jpg" /><br />
</p>
</div>

<div id="outline-container-org8698869" class="outline-5">
<h5 id="org8698869">优缺点</h5>
<div class="outline-text-5" id="text-org8698869">
<ul class="org-ul">
<li>易于实现，和其他质点系统容易结合（如：衣服，软体，粒子流体, 前面这些都是基于质点进行模拟的）<br /></li>
<li>不易于严格满足所有的约束（例如，摩擦的约束）<br /></li>
<li>通常不需要精确的摩擦、或碰撞时，可以使用该方法（例如：衣服上的扣子）<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgedef0af" class="outline-3">
<h3 id="orgedef0af">Mass-Spring Systems</h3>
<div class="outline-text-3" id="text-orgedef0af">
</div>
<div id="outline-container-org202ad53" class="outline-4">
<h4 id="org202ad53">Spring</h4>
<div class="outline-text-4" id="text-org202ad53">
<p>
下面为质点弹簧系统的理论基础：<br />
<img src="./PhysicalBasedAnimation/games103_spring_01.jpg" alt="games103_spring_01.jpg" /><br />
</p>

<p>
下面为利用质点弹簧系统构造结构化的质点弹簧网络来实现模拟。<br />
<img src="./PhysicalBasedAnimation/games103_spring_02.jpg" alt="games103_spring_02.jpg" /><br />
</p>

<p>
下面为利用质点弹簧系统构造非结构化的质点弹簧网络来实现模拟。<br />
<img src="./PhysicalBasedAnimation/games103_spring_03.jpg" alt="games103_spring_03.jpg" /><br />
</p>

<p>
下面为三角形表示的物体时，质点弹簧系统的构造：<br />
<img src="./PhysicalBasedAnimation/games103_spring_04.jpg" alt="games103_spring_04.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgbf6c614" class="outline-4">
<h4 id="orgbf6c614">Explicit Integration</h4>
<div class="outline-text-4" id="text-orgbf6c614">

<div id="orgd025b5d" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_explicit_integration.jpg" alt="games103_spring_explicit_integration.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7159b07" class="outline-4">
<h4 id="org7159b07">Implicit Integration</h4>
<div class="outline-text-4" id="text-org7159b07">

<div id="orga01939c" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration.jpg" alt="games103_spring_implicit_integration.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgc2cb60d" class="outline-5">
<h5 id="orgc2cb60d">Newton-Raphson Method</h5>
<div class="outline-text-5" id="text-orgc2cb60d">

<div id="org245f803" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method01.jpg" alt="games103_spring_implicit_integration-newton-method01.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org077c217" class="outline-5">
<h5 id="org077c217">Simulation by Newton's Method</h5>
<div class="outline-text-5" id="text-org077c217">

<div id="org635a48a" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method02.jpg" alt="games103_spring_implicit_integration-newton-method02.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org5829d1f" class="outline-6">
<h6 id="org5829d1f">Spring Hessian</h6>
<div class="outline-text-6" id="text-org5829d1f">

<div id="org5586ec0" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method03.jpg" alt="games103_spring_implicit_integration-newton-method03.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0710075" class="outline-6">
<h6 id="org0710075">Positive Definiteness of Hessian</h6>
<div class="outline-text-6" id="text-org0710075">

<div id="org3a91252" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method04.jpg" alt="games103_spring_implicit_integration-newton-method04.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org48231cc" class="outline-6">
<h6 id="org48231cc">Enforcement of Positive Definiteness</h6>
<div class="outline-text-6" id="text-org48231cc">

<div id="orgebd8aa2" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method05.jpg" alt="games103_spring_implicit_integration-newton-method05.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org66db2a6" class="outline-6">
<h6 id="org66db2a6">Jacobi Method</h6>
<div class="outline-text-6" id="text-org66db2a6">
<p>
<img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method06.jpg" alt="games103_spring_implicit_integration-newton-method06.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method07.jpg" alt="games103_spring_implicit_integration-newton-method07.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge4280e0" class="outline-4">
<h4 id="orge4280e0">Bending and Locking Issues</h4>
<div class="outline-text-4" id="text-orge4280e0">
</div>
<div id="outline-container-orgbdc9953" class="outline-5">
<h5 id="orgbdc9953">The Bending Spring Issues</h5>
<div class="outline-text-5" id="text-orgbdc9953">

<div id="org0405435" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending01.jpg" alt="games103_05cloth_bending01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgb2fe7fa" class="outline-6">
<h6 id="orgb2fe7fa">A Dihedral Angle Model</h6>
<div class="outline-text-6" id="text-orgb2fe7fa">

<div id="org275071c" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending02.jpg" alt="games103_05cloth_bending02.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgca49dfb" class="outline-6">
<h6 id="orgca49dfb">A Quadratic Bending Model</h6>
<div class="outline-text-6" id="text-orgca49dfb">

<div id="orgbd396f4" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending03.jpg" alt="games103_05cloth_bending03.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcf5f80f" class="outline-5">
<h5 id="orgcf5f80f">The Locking Issues</h5>
<div class="outline-text-5" id="text-orgcf5f80f">
<p>
目前为止，我们讨论模拟模型(质点弹簧模型、其他弯曲模型)时，假设拉伸和弯曲是互相独立的。现实情况也是如此，例如，纸可以弯曲但不可以拉伸。<br />
</p>


<div id="orge2dfae7" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending04.jpg" alt="games103_05cloth_bending04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org17c6917" class="outline-4">
<h4 id="org17c6917">Shape Matching</h4>
<div class="outline-text-4" id="text-org17c6917">
<p>
TODO<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbec8297" class="outline-3">
<h3 id="orgbec8297">Constrained Approaches: PBD, PD and others （Lab 2 ）</h3>
<div class="outline-text-3" id="text-orgbec8297">
<p>
约束用于解决模拟和真实世界差异的问题。<br />
</p>
</div>
<div id="outline-container-org388ef65" class="outline-4">
<h4 id="org388ef65">Position Based Dynamics</h4>
<div class="outline-text-4" id="text-org388ef65">
</div>
<div id="outline-container-orgfb8220e" class="outline-5">
<h5 id="orgfb8220e">The Stiffness Issue</h5>
<div class="outline-text-5" id="text-orgfb8220e">
<p>
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_01.jpg" alt="games103_06stiffness_issue_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_02.jpg" alt="games103_06stiffness_issue_02.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_03.jpg" alt="games103_06stiffness_issue_03.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgaf332d6" class="outline-5">
<h5 id="orgaf332d6">PBD</h5>
<div class="outline-text-5" id="text-orgaf332d6">

<div id="org6e4bef2" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06pbd_01.jpg" alt="games103_06pbd_01.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb179c2a" class="outline-4">
<h4 id="orgb179c2a">Strain Limiting</h4>
<div class="outline-text-4" id="text-orgb179c2a">
<p>
PBD 直接利用投影方法来模拟顶点运动，StrainLimiting 只是利用投影方法来修正顶点位置。<br />
<img src="./PhysicalBasedAnimation/games103_06strain_limiting_01.jpg" alt="games103_06strain_limiting_01.jpg" /><br />
</p>
</div>
<div id="outline-container-org365a6af" class="outline-5">
<h5 id="org365a6af">Spring Strain Limit</h5>
<div class="outline-text-5" id="text-org365a6af">

<div id="orga653e26" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_02.jpg" alt="games103_06strain_limiting_02.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9fab488" class="outline-5">
<h5 id="org9fab488">Triangle Area Limit</h5>
<div class="outline-text-5" id="text-org9fab488">

<div id="org2c1ebd5" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_03.jpg" alt="games103_06strain_limiting_03.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga1fe2f3" class="outline-5">
<h5 id="orga1fe2f3">Strain Limiting in Simulation</h5>
<div class="outline-text-5" id="text-orga1fe2f3">

<div id="orgbe45ce7" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_04.jpg" alt="games103_06strain_limiting_04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org730a272" class="outline-4">
<h4 id="org730a272">Projective Dynamics</h4>
<div class="outline-text-4" id="text-org730a272">
<p>
PBD 直接利用投影方法来修改顶点位置。Projective Dynamics 则利用投影方法计算出新的顶点位置后，利用新的顶点位置构造一个能量函数。<br />
</p>

<p>
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_01.jpg" alt="games103_06projective_dynamics_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_02.jpg" alt="games103_06projective_dynamics_02.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_03.jpg" alt="games103_06projective_dynamics_03.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_04.jpg" alt="games103_06projective_dynamics_04.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgb45c035" class="outline-4">
<h4 id="orgb45c035">Constrained Dynamics</h4>
<div class="outline-text-4" id="text-orgb45c035">
<p>
前面的方法中，模拟 stiffness 非常大的物体时，需要迭代的次数非常多。该方法用于使用很少的迭代次数，就可以模拟 stiffness 非常大的物体。<br />
</p>

<p>
<img src="./PhysicalBasedAnimation/games103_06constrained_dynamics_01.jpg" alt="games103_06constrained_dynamics_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06constrained_dynamics_02.jpg" alt="games103_06constrained_dynamics_02.jpg" /><br />
</p>

<p>
Constrained Dynamics 通常用于模拟 articulated rigid body, 也被称为 ragdoll animation(布娃娃动画)<br />
articulated rigid body 假设人体是由多个刚体组成，刚体有一系列约束。<br />
</p>
</div>
</div>
<div id="outline-container-org54f4ca0" class="outline-4">
<h4 id="org54f4ca0">Stable Constrained Dynamics</h4>
<div class="outline-text-4" id="text-org54f4ca0">
<p>
隐式积分的方法中缺失了 geometric stiffness matrix，添加该 stiffness matrix 可以让 constrained dynamics 更加稳定。<br />
</p>

<p>
TODO<br />
</p>
</div>
</div>
<div id="outline-container-orgc65306b" class="outline-4">
<h4 id="orgc65306b">Summary</h4>
<div class="outline-text-4" id="text-orgc65306b">

<div id="org5410044" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06_summary.jpg" alt="games103_06_summary.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge28dfec" class="outline-3">
<h3 id="orge28dfec">Collision Handling</h3>
</div>
<div id="outline-container-org316f16c" class="outline-3">
<h3 id="org316f16c">Soft Body Dynamics and Finite Element Method （Lab 3）</h3>
<div class="outline-text-3" id="text-org316f16c">
</div>
<div id="outline-container-org27586a3" class="outline-4">
<h4 id="org27586a3">Linear Finite Element Method</h4>
<div class="outline-text-4" id="text-org27586a3">
<p>
有限元方法<br />
<img src="./PhysicalBasedAnimation/games103_08fem_001.jpg" alt="games103_08fem_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08fem_002.jpg" alt="games103_08fem_002.jpg" /><br />
strain 是一个数学的量，用来描述物体的形变，其可以为一个实数（如，物体为一维的弹簧），其也可以为一个矩阵（如，上面描述的三维中的三角形）<br />
<img src="./PhysicalBasedAnimation/games103_08fem_003.jpg" alt="games103_08fem_003.jpg" /><br />
能量对位移求导得到的是力，上面能量密度对形变求导应该类似地对应于力的密度，力的密度矩阵被称为 stress tensor。<br />
<img src="./PhysicalBasedAnimation/games103_08fem_004.jpg" alt="games103_08fem_004.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org93dcee1" class="outline-4">
<h4 id="org93dcee1">Finite Volume Method</h4>
<div class="outline-text-4" id="text-org93dcee1">
<p>
有限体积方法和有限元方法是等价的。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_001.jpg" alt="games103_08fvm_001.jpg" /><br />
有限体积方法本质上基于力从何而来。假如两个弹性体被一个界面分割，为了计算界面上的总的力，假设界面上单位面积的力为 traction t，则界面上总的力，就为 traction t 在整个界面上的积分。通过 stress tensor 矩阵可以求出 traction 力。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_002.jpg" alt="games103_08fvm_002.jpg" /><br />
现在只剩下柯西 stress tensor 是未知的，下面为柯西 stress tensor 的求解:<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_003.jpg" alt="games103_08fvm_003.jpg" /><br />
本节的 stress tensor 和上一节的 stress tensor 有稍微差别，上节课的 stress tensor 为未形变时的 stress tensor，而本节课的 stress tensor 为形变后的 stress tensor。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_004.jpg" alt="games103_08fvm_004.jpg" /><br />
</p>
</div>
<div id="outline-container-org3392063" class="outline-5">
<h5 id="org3392063">Sumarry</h5>
<div class="outline-text-5" id="text-org3392063">

<div id="org2ffdde0" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08fvm_005.jpg" alt="games103_08fvm_005.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org2b7981c" class="outline-4">
<h4 id="org2b7981c">Hyperelastic Models</h4>
<div class="outline-text-4" id="text-org2b7981c">
<p>
个性同性的材质横着拉和竖着拉形变是相同的（具有旋转不变性），如橡胶。因此 stress tensor P 中的旋转矩阵 U 和 V^T 可以被提出来。<br />
<img src="./PhysicalBasedAnimation/games103_08h-model_001.jpg" alt="games103_08h-model_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_002.jpg" alt="games103_08h-model_002.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_003.jpg" alt="games103_08h-model_003.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_004.jpg" alt="games103_08h-model_004.jpg" /><br />
</p>
</div>
<div id="outline-container-orgb13fc8c" class="outline-5">
<h5 id="orgb13fc8c">Summary</h5>
<div class="outline-text-5" id="text-orgb13fc8c">

<div id="org323dfda" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08h-model_005.jpg" alt="games103_08h-model_005.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org47343ab" class="outline-4">
<h4 id="org47343ab">Nonlinear Optimization</h4>
<div class="outline-text-4" id="text-org47343ab">
<p>
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_001.jpg" alt="games103_08nonlinear-opt_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_002.jpg" alt="games103_08nonlinear-opt_002.jpg" /><br />
下降方法的性能分析：<br />
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_003.jpg" alt="games103_08nonlinear-opt_003.jpg" /><br />
</p>
</div>
<div id="outline-container-org966831b" class="outline-5">
<h5 id="org966831b">Summary</h5>
<div class="outline-text-5" id="text-org966831b">

<div id="orgd49b5a8" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_004.jpg" alt="games103_08nonlinear-opt_004.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbcf2851" class="outline-3">
<h3 id="orgbcf2851">Surface Waves （Lab 4）</h3>
<div class="outline-text-3" id="text-orgbcf2851">
</div>
<div id="outline-container-org2d24df3" class="outline-4">
<h4 id="org2d24df3">Two Types of Simulation Approaches</h4>
<div class="outline-text-4" id="text-org2d24df3">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave01.jpg" alt="games103_10surfacewave01.jpg" /><br />
前面学过的刚体、布料、弹性体模拟都属于拉格朗日方法<br />
今天将会学习的高度场模型属于欧拉方法<br />
</p>
</div>
</div>
<div id="outline-container-org9112a08" class="outline-4">
<h4 id="org9112a08">A Height Field Model</h4>
<div class="outline-text-4" id="text-org9112a08">
<p>
高度场模型无法模拟一个位置对应多个高度值的情况。因此，2D 情况下称对应的高度场为 1.5D，3D 情况下称对应的高度场为 2.5D。<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave02.jpg" alt="games103_10surfacewave02.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd20aec1" class="outline-4">
<h4 id="orgd20aec1">Shallow Wave Equation</h4>
<div class="outline-text-4" id="text-orgd20aec1">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave03.jpg" alt="games103_10surfacewave03.jpg" /><br />
上面将公式变换最终将速度场移除，从而可以在只使用高度场的情况下对水面进行模拟。<br />
</p>
</div>
<div id="outline-container-org4cf776a" class="outline-5">
<h5 id="org4cf776a">Finite Differencing</h5>
<div class="outline-text-5" id="text-org4cf776a">

<div id="org1e023fe" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave04.jpg" alt="games103_10surfacewave04.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbfd55ee" class="outline-5">
<h5 id="orgbfd55ee">Second-Order Derivatives</h5>
<div class="outline-text-5" id="text-orgbfd55ee">

<div id="orgbd11953" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave05.jpg" alt="games103_10surfacewave05.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfcd3cf0" class="outline-5">
<h5 id="orgfcd3cf0">Discretized Shallow Wave Equation</h5>
<div class="outline-text-5" id="text-orgfcd3cf0">

<div id="orgc7575d6" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave06.jpg" alt="games103_10surfacewave06.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org924b468" class="outline-5">
<h5 id="org924b468">Volume Preservation</h5>
<div class="outline-text-5" id="text-org924b468">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave07.jpg" alt="games103_10surfacewave07.jpg" /><br />
结合下面压强的定义，可以更容易上面的公式。<br />
</p>
</div>
</div>
<div id="outline-container-org926a037" class="outline-5">
<h5 id="org926a037">Pressure</h5>
<div class="outline-text-5" id="text-org926a037">

<div id="org369920a" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave08.jpg" alt="games103_10surfacewave08.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga18e51e" class="outline-5">
<h5 id="orga18e51e">Viscosity</h5>
<div class="outline-text-5" id="text-orga18e51e">
<p>
前面刚体动力学中位置的更新方式为:<br />
x(t0+dt) = x(t0) + v(t0)*dt<br />
v(t0) = (x(t0)-x(t0-dt))/dt<br />
x(t0+dt) = x(t0) + x(t0) - x(t0-dt)<br />
</p>

<p>
结合上面推导，可以理解下面公式：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave09.jpg" alt="games103_10surfacewave09.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8b02da5" class="outline-5">
<h5 id="org8b02da5">Boundary Conditions</h5>
<div class="outline-text-5" id="text-org8b02da5">

<div id="org2025042" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave10.jpg" alt="games103_10surfacewave10.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org38df689" class="outline-5">
<h5 id="org38df689">Two-Way Coupling</h5>
<div class="outline-text-5" id="text-org38df689">
<p>
流体和刚体的耦合是双向的。流体对刚体有浮力，刚体会占用流体的空间。<br />
</p>

<p>
刚体对流体的影响如下：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave11.jpg" alt="games103_10surfacewave11.jpg" /><br />
</p>

<p>
流体对刚体的浮力影响如下：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave11.jpg" alt="games103_10surfacewave11.jpg" /><br />
</p>

<ul class="org-ul">
<li>泊松方程 <a href="https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E6%96%B9%E7%A8%8B</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7a2d795" class="outline-3">
<h3 id="org7a2d795">Incompressible Fluid Dynamics and Eulerian Fluids</h3>
</div>
<div id="outline-container-org9a34398" class="outline-3">
<h3 id="org9a34398">SPH and Position-Based Fluids</h3>
</div>
<div id="outline-container-org753ec7a" class="outline-3">
<h3 id="org753ec7a">参考资料</h3>
<div class="outline-text-3" id="text-org753ec7a">
<ul class="org-ul">
<li><a href="http://games-cn.org/games103/">http://games-cn.org/games103/</a><br /></li>
<li>Bilibili 视频主页 <a href="https://www.bilibili.com/video/BV12Q4y1S73g?spm_id_from=444.41.0.0">https://www.bilibili.com/video/BV12Q4y1S73g?spm_id_from=444.41.0.0</a><br /></li>
<li>Physically Based Modeling <a href="https://graphics.pixar.com/pbm2001/">https://graphics.pixar.com/pbm2001/</a><br /></li>
<li>王华民老师主页 <a href="https://web.cse.ohio-state.edu/~wang.3602/index.html">https://web.cse.ohio-state.edu/~wang.3602/index.html</a><br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc707cfe" class="outline-2">
<h2 id="orgc707cfe">基于物理的计算机动画入门作业</h2>
<div class="outline-text-2" id="text-orgc707cfe">
</div>
<div id="outline-container-org2889d94" class="outline-3">
<h3 id="org2889d94">homework01</h3>
<div class="outline-text-3" id="text-org2889d94">
<p>
作业 1 使用两种方法对刚体进行模拟。<br />
</p>

<p>
Impulse 方法：<br />
</p>
<ul class="org-ul">
<li>根据力计算出速度 (重力、空气阻力)<br /></li>
<li>判断刚体和表面是否产生碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的冲量<br /></li>
<li>依据冲量更新速度<br /></li>
<li>依据冲量更新角速度<br /></li>
</ul></li>
<li>利用速度和角速度更新刚体的位置和旋转<br /></li>
</ul>

<p>
ShapeMatching 方法<br />
</p>
<ul class="org-ul">
<li>对组成刚体的每个顶点单独进行模拟<br />
<ul class="org-ul">
<li>根据力计算出顶点的速度<br /></li>
<li>根据顶点的速度更新顶点的位置<br /></li>
</ul></li>
<li>判断刚体和表面是否产生碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的 Penalty 力<br /></li>
</ul></li>
<li>将变形后的刚体重新变回原来形状<br />
<ul class="org-ul">
<li>计算变形后刚体的中心<br /></li>
<li>计算变形对应的矩阵，并取出其中旋转部分<br /></li>
<li>利用新的中心和旋转矩阵求出刚体新的位置<br /></li>
</ul></li>
</ul>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_rigidbody.mp4" />
</video>
</div>

<div id="outline-container-orgf7beacf" class="outline-4">
<h4 id="orgf7beacf">ERROR ShapeMatching 模拟中兔子没有旋转效果</h4>
<div class="outline-text-4" id="text-orgf7beacf">
<p>
一开始以为构建 Shape Matching 矩阵时是以前一次模拟的结果为起点构造的。实际上每次构建 Shape Matching 矩阵都是以一开始的状态为起点。仔细分析一下，就算以前一次模拟为起点构造也没错，但是，对应后续的 QQt.inverse 矩阵也应该以前一次模拟结果为起点进行更新。而以起始状态为起点构建可以省去 QQt 的更新，因此以起始状态为起点构造 Shape Matching 矩阵更高效。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#26041;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">YiMinusC</span> = Y[i] - c;
mat1.m00 += YiMinusC.x * X[i].x;
mat1.m01 += YiMinusC.x * X[i].y;
mat1.m02 += YiMinusC.x * X[i].z;
mat1.m10 += YiMinusC.y * X[i].x;
mat1.m11 += YiMinusC.y * X[i].y;
mat1.m12 += YiMinusC.y * X[i].z;
mat1.m20 += YiMinusC.z * X[i].x;
mat1.m21 += YiMinusC.z * X[i].y;
mat1.m22 += YiMinusC.z * X[i].z;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#26041;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">YiMinusC</span> = Y[i] - c;
mat1.m00 += YiMinusC.x * Q[i].x;
mat1.m01 += YiMinusC.x * Q[i].y;
mat1.m02 += YiMinusC.x * Q[i].z;
mat1.m10 += YiMinusC.y * Q[i].x;
mat1.m11 += YiMinusC.y * Q[i].y;
mat1.m12 += YiMinusC.y * Q[i].z;
mat1.m20 += YiMinusC.z * Q[i].x;
mat1.m21 += YiMinusC.z * Q[i].y;
mat1.m22 += YiMinusC.z * Q[i].z;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org606a173" class="outline-3">
<h3 id="org606a173">homework02</h3>
<div class="outline-text-3" id="text-org606a173">
<p>
作业 2 使用两种方法对布料进行模拟<br />
</p>

<p>
Implicit 方法:<br />
</p>
<ul class="org-ul">
<li>依据每个顶点的速度对对应顶点的位置进行更新<br /></li>
<li>隐式积分问题等价于函数的优化问题，利用牛顿迭代法求解该优化问题<br />
<ul class="org-ul">
<li>求解每个顶点位置对应的梯度<br /></li>
<li>利用梯度以及 Magic Hessian Matrix 更新顶点位置<br /></li>
</ul></li>
<li>判断布料顶点是否和球体产生碰撞, 使用 Impulse 方法处理碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的位置变化量<br /></li>
<li>计算碰撞导致的冲量<br /></li>
<li>依据冲量更新速度<br /></li>
</ul></li>
</ul>

<p>
PBD 方法:<br />
</p>
<ul class="org-ul">
<li>质点模拟<br />
<ul class="org-ul">
<li>根据力计算出每个顶点的速度 (重力、空气阻力)<br /></li>
<li>根据速度更新每个顶点的位置<br /></li>
</ul></li>
<li>使用 PBD 方法，进行迭代模拟<br />
<ul class="org-ul">
<li>遍历所有的边，求应用约束后得到的新的顶点位置<br /></li>
<li>遍历所有的顶点，更新顶点位置, 利用老位置和新位置更新顶点速度<br /></li>
</ul></li>
<li><p>
判断布料顶点是否和球体产生碰撞, 使用 Impulse 方法处理碰撞 (和 Implicit 方法一样)<br />
</p>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_cloth.mp4" />
</video></li>
</ul>
</div>
</div>

<div id="outline-container-orgb4c6160" class="outline-3">
<h3 id="orgb4c6160">homework03</h3>
<div class="outline-text-3" id="text-orgb4c6160">
<p>
作业 3 使用有限体积方法对弹性体进行模拟<br />
</p>

<p>
F-&gt;G-&gt;P-&gt;ElasticForce:<br />
</p>
<ul class="org-ul">
<li>求形变梯度矩阵 F<br /></li>
<li>求 GreenStrain G （G从 F 中去除了形变后的旋转）<br /></li>
<li>求 Second PK Stress S<br /></li>
<li>求 First PK Stress P<br /></li>
<li>求 四面体各个顶点的弹力<br /></li>
</ul>

<p>
F-&gt;svd(F)-&gt;P-&gt;ElasticForce:<br />
</p>
<ul class="org-ul">
<li>求形变梯度矩阵 F<br /></li>
<li>对 F 进行 svd 分解，得到 svdU svdS svdV ，其中 svdS 的对角就是 Principal Stretches<br /></li>
<li>求 P = U P(svdS) V^T<br /></li>
<li>求四面体各个顶点的弹力<br /></li>
</ul>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_fvm.mp4" />
</video>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_fvm-svd.mp4" />
</video>

<ul class="org-ul">
<li>拉普拉斯平滑 <a href="https://blog.csdn.net/weixin_43868020/article/details/106602799">https://blog.csdn.net/weixin_43868020/article/details/106602799</a> 有道云笔记有备份<br /></li>
</ul>
</div>
<div id="outline-container-org32f40ba" class="outline-4">
<h4 id="org32f40ba">ERROR 第一帧模型就炸裂了</h4>
<div class="outline-text-4" id="text-org32f40ba">
<p>
去掉 Elastic Force, 模型不炸裂了。因此，计算 Elastic Force 有问题。<br />
第 1 步计算 Deformation Gradient，如果房子还没有变形，F 矩阵应该为单位矩阵。<br />
第 2 步计算 Green Strain，如果房子还没有变形，G矩阵应该为 0 矩阵<br />
第 3 步计算 Second PK Stress，如果房子还没有变形，P矩阵应该为 0 矩阵<br />
第 4 步计算 Elastic Force. 力应该为 0；<br />
</p>

<p>
问题 1：<br />
计算矩阵 G 的 trace 时，将 G.m33 也加进去了。<br />
</p>

<p>
问题 2：<br />
计算速度时，漏掉了 dt。<br />
错误的速度计算： V[i] = V[i] + Force[i] / mass;<br />
正确的速度计算： V[i] = V[i] + dt * Force[i] / mass;<br />
</p>
</div>
</div>
<div id="outline-container-org61dc554" class="outline-4">
<h4 id="org61dc554">ERROR 碰撞后模型炸裂</h4>
<div class="outline-text-4" id="text-org61dc554">
<p>
这是由于 collisionThreshold 不为 0 时，dis 的计算不连续导致的。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#20195;&#30721;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">dis</span> = Vector3.Dot(X[i] - localFloorP, localFloorN);
<span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; collisionThreshold)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; 0) dis = -dis + collisionThreshold;
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">Xnew</span> = X[i] + dis * localFloorN;
    V[i] = V[i] + (Xnew-X[i]) / dt;
}
X[i] = X[i] + V[i] * dt;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#20195;&#30721;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">dis</span> = Vector3.Dot(X[i] - localFloorP, localFloorN);
<span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; collisionThreshold)
{
    dis = collisionThreshold - dis;
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">Xnew</span> = X[i] + dis * localFloorN;
    V[i] = V[i] + (Xnew-X[i]) / dt;
}
X[i] = X[i] + V[i] * dt;
</pre>
</div>

<p>
另外，Penalty Force 方法很容易炸，需要调节 rho，并且处理顶点进入平面之下的情况。<br />
</p>
</div>
</div>
<div id="outline-container-org3120bbc" class="outline-4">
<h4 id="org3120bbc">ERROR 使用 homework01 中，Impulse 方法处理碰撞，碰撞后模型缓慢往下陷</h4>
<div class="outline-text-4" id="text-org3120bbc">
<p>
这是因为 Impulse 碰撞处理中的速度没有及时作用到位移导致。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#26041;&#24335;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
X[i] = X[i] + V[i] * dt;
<span style="color: #4f97d7; font-weight: bold;">if</span>(collision)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use impulse method update V[i]</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    V[i] = vinew;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#26041;&#24335;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #4f97d7; font-weight: bold;">if</span>(collision)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use impulse method update V[i]</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    V[i] = vinew;
}
X[i] = X[i] + V[i] * dt;
</pre>
</div>
</div>
</div>
<div id="outline-container-org6f7fadf" class="outline-4">
<h4 id="org6f7fadf">ERROR svd 版本中，房子会被压扁，然后炸裂</h4>
<div class="outline-text-4" id="text-org6f7fadf">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#22914;&#19979;&#26041;&#24335;&#35745;&#31639;lambda0,1,2&#65292;&#20250;&#23548;&#33268;&#21387;&#25153;&#21518;&#28856;&#35010;</span>
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">C</span> = F.transpose * F;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda0</span> = Mathf.Sqrt(C.m00);
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda1</span> = Mathf.Sqrt(C.m11);
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda2</span> = Mathf.Sqrt(C.m22);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#22914;&#19979;&#26041;&#24335;&#35745;&#31639;lambda0,1,2, &#19981;&#20250;&#23548;&#33268;&#35813;&#38382;&#39064;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda0</span> = svdS.m00;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda1</span> = svdS.m11;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda2</span> = svdS.m22;

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda00</span> = lambda0*lambda0;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda11</span> = lambda1*lambda1;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda22</span> = lambda2*lambda2;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga534945" class="outline-4">
<h4 id="orga534945">ERROR svd 版本不开启 LaplacianSmooth 时，开始几秒后炸裂</h4>
<div class="outline-text-4" id="text-orga534945">
<p>
需要将 stiffness0 缩小为原来 1/4, 该系数和 王华民老师 2016 年 Descent Methods for Elastic Body Simulation on the GPU 论文对应的 cuda 代码中的系数一致。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org93801dd" class="outline-3">
<h3 id="org93801dd">homework04</h3>
<div class="outline-text-3" id="text-org93801dd">
<p>
作业 4 使用 ShallowWave 模型对水面进行模拟。<br />
</p>

<ul class="org-ul">
<li>离散化水面的高度场<br /></li>
<li>模拟水面<br />
<ul class="org-ul">
<li>使用 ShallowWave 模型更新水面高度场 new_h = h[i,j] + beta*(h[i,j]-old_h[i,j]) + alpha*(h[i-1, j] + h[i+1,j] + h[i,j-1] + h[i,j+1] - 4*h[i,j])<br /></li>
<li>利用虚拟高度模拟 Block 对 Water 的影响<br /></li>
<li>利用浮力模拟 Water 对 Block 的影响<br /></li>
</ul></li>
<li>利用更新后的高度场，更新水面模型的顶点<br /></li>
</ul>
</div>

<div id="outline-container-org85bba77" class="outline-4">
<h4 id="org85bba77">ERROR 立方体会陷入水中越来越深</h4>
<div class="outline-text-4" id="text-org85bba77">
<p>
按照 ppt 浮力 = rho * g * areaA * (h[i,j] - new_h[i,j])，h和 new_h 会越来越接近，浮力会消失。<br />
修改浮力公式如下：<br />
floatingF = rho * g * areaA * (-boxBottomY)<br />
</p>
</div>
</div>
<div id="outline-container-orgc963901" class="outline-4">
<h4 id="orgc963901">ERROR 部分水波会从漂浮的立方体内部穿出来</h4>
<div class="outline-text-4" id="text-orgc963901">
<p>
需要处理立方体整体进入水中的情况。此时 浮力 = rho*g*h(下表面) - rho*g*h(上表面)<br />
</p>
</div>
</div>
<div id="outline-container-org87fb2e9" class="outline-4">
<h4 id="org87fb2e9">ERROR 立方体下面水波会反向突出一大块</h4>
<div class="outline-text-4" id="text-org87fb2e9">
<p>
这是因为求解出来的虚拟高度过大，导致排出的水过多。 适当减小 gamma 参数可以减弱该问题。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbcbd062" class="outline-2">
<h2 id="orgbcbd062">高级物理引擎实战指南 2020</h2>
<div class="outline-text-2" id="text-orgbcbd062">
</div>
<div id="outline-container-orge6745f2" class="outline-3">
<h3 id="orge6745f2">参考资料</h3>
<div class="outline-text-3" id="text-orge6745f2">
<ul class="org-ul">
<li>Bilibili 视频主页 <a href="https://www.bilibili.com/video/BV1ZK411H7Hc">https://www.bilibili.com/video/BV1ZK411H7Hc</a><br /></li>
<li>课程主页 <a href="https://yuanming.taichi.graphics/teaching/2020-games201/">https://yuanming.taichi.graphics/teaching/2020-games201/</a><br /></li>
<li>TaiChi 官方文档 <a href="https://taichi.readthedocs.io/zh_CN/latest/">https://taichi.readthedocs.io/zh_CN/latest/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org71308e2" class="outline-2">
<h2 id="org71308e2">PhysicalBasedAnimation</h2>
<div class="outline-text-2" id="text-org71308e2">
</div>
<div id="outline-container-org5c3ae5f" class="outline-3">
<h3 id="org5c3ae5f">Harmonic Oscillator 简谐振子</h3>
</div>
<div id="outline-container-org725422d" class="outline-3">
<h3 id="org725422d">Mechanical Energy 机械能</h3>
</div>
<div id="outline-container-org0b3f61c" class="outline-3">
<h3 id="org0b3f61c">Conservation Laws 守恒定律</h3>
</div>
<div id="outline-container-org39bcf19" class="outline-3">
<h3 id="org39bcf19">Symplecticity</h3>
</div>
<div id="outline-container-org677db22" class="outline-3">
<h3 id="org677db22">Numerical Integration</h3>
</div>
<div id="outline-container-org24c25fe" class="outline-3">
<h3 id="org24c25fe">Integrator Properties</h3>
</div>
<div id="outline-container-orgc237c76" class="outline-3">
<h3 id="orgc237c76">Solving Implicit Integrators</h3>
</div>
<div id="outline-container-orgcc5e939" class="outline-3">
<h3 id="orgcc5e939">Optimization</h3>
</div>
<div id="outline-container-org6ec7922" class="outline-3">
<h3 id="org6ec7922">Newtons Method</h3>
</div>
<div id="outline-container-org603002f" class="outline-3">
<h3 id="org603002f">Nonconvexity</h3>
</div>
<div id="outline-container-orgc130b0f" class="outline-3">
<h3 id="orgc130b0f">Direct Solvers</h3>
</div>
<div id="outline-container-orgafe5eab" class="outline-3">
<h3 id="orgafe5eab">Iterative Methods</h3>
</div>
<div id="outline-container-org9ec17ac" class="outline-3">
<h3 id="org9ec17ac">Finite Elements</h3>
</div>
<div id="outline-container-org49ec894" class="outline-3">
<h3 id="org49ec894">FE Potential</h3>
</div>
<div id="outline-container-org6b63618" class="outline-3">
<h3 id="org6b63618">Final FEM notes and Wrap up</h3>
</div>
<div id="outline-container-org623a3ee" class="outline-3">
<h3 id="org623a3ee">Constraints</h3>
</div>
<div id="outline-container-orge165639" class="outline-3">
<h3 id="orge165639">参考资料</h3>
<div class="outline-text-3" id="text-orge165639">
<ul class="org-ul">
<li>YouTube 视频 <a href="https://www.youtube.com/watch?v=sSKyQIxdhdA&amp;list=PL_a9tY9IhJuPc7e6r-3DMw_PbYbloKoWM">https://www.youtube.com/watch?v=sSKyQIxdhdA&amp;list=PL_a9tY9IhJuPc7e6r-3DMw_PbYbloKoWM</a><br /></li>
<li>课程主页 <a href="https://my.eng.utah.edu/~cs6660/">https://my.eng.utah.edu/~cs6660/</a><br /></li>
<li>教师主页 <a href="https://www.cs.utah.edu/~ladislav/">https://www.cs.utah.edu/~ladislav/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
