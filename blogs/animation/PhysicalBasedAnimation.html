<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-27 Tue 22:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PhysicalBasedAnimation</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.github.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.github.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.github.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.github.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.github.io/res/blog-tools.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.github.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">PhysicalBasedAnimation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf954f70">基于物理的计算机动画入门</a>
<ul>
<li><a href="#org1cd977f">Intro to Physics-Based Animation</a>
<ul>
<li><a href="#org384a861">What’s computer graphics?</a>
<ul>
<li><a href="#orgdead1ea">Geometry 的表示-Mesh</a></li>
<li><a href="#orgefa7134">Geometry 的表示-Point Cloud</a></li>
<li><a href="#orgba1836d">Geometry 的表示-Grid</a></li>
<li><a href="#orge137842">Animation</a></li>
<li><a href="#orgdfcf1fc">Rendering</a></li>
</ul>
</li>
<li><a href="#orga470a46">What’s physics-based animation?</a>
<ul>
<li><a href="#org9323162">动画的范式</a></li>
<li><a href="#orgf5b7a18">Physics-based Aniamtion 研究的内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org551bb59">Math Background: Vector, Matrix and Tensor Calculus</a>
<ul>
<li><a href="#orgfd813c7">Vector</a></li>
<li><a href="#org21444aa">Matrix</a>
<ul>
<li><a href="#orgd793b5e">Singular Value Decomposition</a></li>
<li><a href="#orgacd3114">Eigenvalue Decomposition</a></li>
<li><a href="#org9ee3124">Symmetric Positive Definiteness (s.p.d)</a></li>
<li><a href="#orga29a080">Linear Solver</a>
<ul>
<li><a href="#org6ade3e9">Direct Linear Solver</a></li>
<li><a href="#org93088e8">Iterative Linear Solver</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf9a8008">Tensor Calculus</a>
<ul>
<li><a href="#org0bd3204">一阶导数</a></li>
<li><a href="#org66c8a68">二阶导数</a></li>
<li><a href="#org5a4811c">Taylor Expansion</a></li>
</ul>
</li>
<li><a href="#orgf64d4fd">Examples</a>
<ul>
<li><a href="#orga3803f5">向量长度的偏导数</a></li>
<li><a href="#org29905fc">A Spring</a></li>
<li><a href="#org34dbec9">A Spring with Two Ends</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8fba452">Rigid Body Contacts（Lab 1 ）</a>
<ul>
<li><a href="#org8ee5fe2">Rigid Body Simulation</a></li>
<li><a href="#org814e3e7">Translational Motion</a>
<ul>
<li><a href="#orgcf5511b">Integration Methods</a></li>
<li><a href="#orgb30a8ae">Apply Intergration For Translational Motion</a></li>
<li><a href="#org82bc7d0">Types of Forces</a></li>
</ul>
</li>
<li><a href="#org6dd9113">Rotational Motion</a>
<ul>
<li><a href="#org973d468">Rotation Represented</a></li>
<li><a href="#org7611cc7">Quaternion</a></li>
<li><a href="#org84ed346">Torque and Inertia</a></li>
</ul>
</li>
<li><a href="#org333963a">Translational and Rotational Motion</a></li>
<li><a href="#orgc9f9958">Particle Collision Detection and Response</a>
<ul>
<li><a href="#org428831b">Penalty methods</a>
<ul>
<li><a href="#org6c8bf82">Summary of Penalty Methods</a></li>
</ul>
</li>
<li><a href="#org7a5b279">Impulse methods</a></li>
</ul>
</li>
<li><a href="#org54c33cb">Rigid Collision Detection and Response by Impulse</a></li>
<li><a href="#orgde41a3d">Shape Matching method</a>
<ul>
<li><a href="#org4f3cef0">优缺点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6c3c752">Mass-Spring Systems</a>
<ul>
<li><a href="#orgbe75b2b">Spring</a></li>
<li><a href="#orgf656cca">Explicit Integration</a></li>
<li><a href="#org29afe03">Implicit Integration</a>
<ul>
<li><a href="#org46d7704">Newton-Raphson Method</a></li>
<li><a href="#orgadf67d0">Simulation by Newton's Method</a>
<ul>
<li><a href="#org9356443">Spring Hessian</a></li>
<li><a href="#org8ad522c">Positive Definiteness of Hessian</a></li>
<li><a href="#org2655098">Enforcement of Positive Definiteness</a></li>
<li><a href="#orgad7244b">Jacobi Method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb709eb9">Bending and Locking Issues</a>
<ul>
<li><a href="#orgdbeabfe">The Bending Spring Issues</a>
<ul>
<li><a href="#orgf938a10">A Dihedral Angle Model</a></li>
<li><a href="#org3738f5a">A Quadratic Bending Model</a></li>
</ul>
</li>
<li><a href="#org29b8f3d">The Locking Issues</a></li>
</ul>
</li>
<li><a href="#org1f275f1">Shape Matching</a></li>
</ul>
</li>
<li><a href="#org733247e">Constrained Approaches: PBD, PD and others （Lab 2 ）</a>
<ul>
<li><a href="#orgb158110">Position Based Dynamics</a>
<ul>
<li><a href="#org66045de">The Stiffness Issue</a></li>
<li><a href="#org6420cc5">PBD</a></li>
</ul>
</li>
<li><a href="#org4630faa">Strain Limiting</a>
<ul>
<li><a href="#org132c6d6">Spring Strain Limit</a></li>
<li><a href="#org16f0bd7">Triangle Area Limit</a></li>
<li><a href="#org5173a60">Strain Limiting in Simulation</a></li>
</ul>
</li>
<li><a href="#org717194d">Projective Dynamics</a></li>
<li><a href="#org2367d29">Constrained Dynamics</a></li>
<li><a href="#org88582ef">Stable Constrained Dynamics</a></li>
<li><a href="#org78bf8c3">Summary</a></li>
</ul>
</li>
<li><a href="#org6e9a75a">Collision Handling</a></li>
<li><a href="#org68cc38f">Soft Body Dynamics and Finite Element Method （Lab 3）</a>
<ul>
<li><a href="#org35e81f2">Linear Finite Element Method</a></li>
<li><a href="#org94849b1">Finite Volume Method</a>
<ul>
<li><a href="#orgf21f0d0">Sumarry</a></li>
</ul>
</li>
<li><a href="#org275d66f">Hyperelastic Models</a>
<ul>
<li><a href="#orgddf504a">Summary</a></li>
</ul>
</li>
<li><a href="#org695fe2f">Nonlinear Optimization</a>
<ul>
<li><a href="#orge258d39">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org95c12c0">Surface Waves （Lab 4）</a>
<ul>
<li><a href="#orgbd536c9">Two Types of Simulation Approaches</a></li>
<li><a href="#org3d4c2a0">A Height Field Model</a></li>
<li><a href="#org8f547c4">Shallow Wave Equation</a>
<ul>
<li><a href="#org315efe1">Finite Differencing</a></li>
<li><a href="#orgf5b55f8">Second-Order Derivatives</a></li>
<li><a href="#org4ea3dac">Discretized Shallow Wave Equation</a></li>
<li><a href="#org8dfdb60">Volume Preservation</a></li>
<li><a href="#org935409f">Pressure</a></li>
<li><a href="#orgc69edc7">Viscosity</a></li>
<li><a href="#org789311a">Boundary Conditions</a></li>
<li><a href="#org581a28b">Two-Way Coupling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2f6bc3b">Incompressible Fluid Dynamics and Eulerian Fluids</a></li>
<li><a href="#orgbf070f5">SPH and Position-Based Fluids</a></li>
<li><a href="#orgab4b43e">参考资料</a></li>
</ul>
</li>
<li><a href="#org7c66502">基于物理的计算机动画入门作业</a>
<ul>
<li><a href="#org856037e">homework01</a>
<ul>
<li><a href="#org41df23d">ERROR ShapeMatching 模拟中兔子没有旋转效果</a></li>
</ul>
</li>
<li><a href="#orgc9e125f">homework02</a></li>
<li><a href="#orga7a9263">homework03</a>
<ul>
<li><a href="#orgd874669">ERROR 第一帧模型就炸裂了</a></li>
<li><a href="#org7862f57">ERROR 碰撞后模型炸裂</a></li>
<li><a href="#orgde35bea">ERROR 使用 homework01 中，Impulse 方法处理碰撞，碰撞后模型缓慢往下陷</a></li>
<li><a href="#org9eeff20">ERROR svd 版本中，房子会被压扁，然后炸裂</a></li>
<li><a href="#org3ccb200">ERROR svd 版本不开启 LaplacianSmooth 时，开始几秒后炸裂</a></li>
</ul>
</li>
<li><a href="#org3d8e141">homework04</a>
<ul>
<li><a href="#org869a39e">ERROR 立方体会陷入水中越来越深</a></li>
<li><a href="#orgec075af">ERROR 部分水波会从漂浮的立方体内部穿出来</a></li>
<li><a href="#org89101c9">ERROR 立方体下面水波会反向突出一大块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd3abbd2">高级物理引擎实战指南 2020</a>
<ul>
<li><a href="#org243be7e">参考资料</a></li>
</ul>
</li>
<li><a href="#org1b1e840">PhysicalBasedAnimation</a>
<ul>
<li><a href="#org73f7187">Harmonic Oscillator 简谐振子</a></li>
<li><a href="#orga8447a3">Mechanical Energy 机械能</a></li>
<li><a href="#org8b846a1">Conservation Laws 守恒定律</a></li>
<li><a href="#org2d7a843">Symplecticity</a></li>
<li><a href="#orged63103">Numerical Integration</a></li>
<li><a href="#org990e476">Integrator Properties</a></li>
<li><a href="#org8fae8e5">Solving Implicit Integrators</a></li>
<li><a href="#org3b4613c">Optimization</a></li>
<li><a href="#org1d4b5b6">Newtons Method</a></li>
<li><a href="#orgdb1521d">Nonconvexity</a></li>
<li><a href="#org2a1f0ae">Direct Solvers</a></li>
<li><a href="#org4c42129">Iterative Methods</a></li>
<li><a href="#orgff0778f">Finite Elements</a></li>
<li><a href="#org0ff345a">FE Potential</a></li>
<li><a href="#org28d458b">Final FEM notes and Wrap up</a></li>
<li><a href="#orgcb58540">Constraints</a></li>
<li><a href="#org51e4294">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
PhysicalBasedAnimation note.<br />
</p>
<div class="HTML" id="org065560a">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgf954f70" class="outline-2">
<h2 id="orgf954f70">基于物理的计算机动画入门</h2>
<div class="outline-text-2" id="text-orgf954f70">
</div>
<div id="outline-container-org1cd977f" class="outline-3">
<h3 id="org1cd977f">Intro to Physics-Based Animation</h3>
<div class="outline-text-3" id="text-org1cd977f">
</div>
<div id="outline-container-org384a861" class="outline-4">
<h4 id="org384a861">What’s computer graphics?</h4>
<div class="outline-text-4" id="text-org384a861">
<p>
计算机图形学分为三个部分：<br />
</p>
<ul class="org-ul">
<li>Geometry : Modeling the 3D World<br /></li>
<li>Animation : Animate the 3D World<br /></li>
<li>Rendering : Visualize the 3D World<br /></li>
</ul>

<p>
下图为实时图形学整体的管线：<br />
<img src="./PhysicalBasedAnimation/games103_realtime_graphics_pipeline.jpg" alt="games103_realtime_graphics_pipeline.jpg" /><br />
</p>
</div>

<div id="outline-container-orgdead1ea" class="outline-5">
<h5 id="orgdead1ea">Geometry 的表示-Mesh</h5>
<div class="outline-text-5" id="text-orgdead1ea">
<ul class="org-ul">
<li>mesh 由顶点和元素构成。顶点就是节点，元素可以是三角形、多边形、四面体等等<br /></li>
<li>三角形 mesh 是当前图形学的基础。显卡都是基于三角形 mesh 所设计的<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>构建 mesh(meshing) : Delaunay triangulation<br /></li>
<li>简化 mesh、细分 mesh<br /></li>
<li>mesh 优化 : smoothing, flows<br /></li>
<li>volume mesh<br /></li>
</ul></li>
<li>mesh 又分为两种类型：Structured Mesh 和 Unstructured Mesh<br /></li>
</ul>


<div id="orgab91929" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_mesh.jpg" alt="games103_mesh.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgefa7134" class="outline-5">
<h5 id="orgefa7134">Geometry 的表示-Point Cloud</h5>
<div class="outline-text-5" id="text-orgefa7134">
<ul class="org-ul">
<li>点云表示几何体很简单，表面扫描就可以得到点云表示的几何体<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>从点云构造 Mesh<br /></li>
<li>对点云进行采样<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgba1836d" class="outline-5">
<h5 id="orgba1836d">Geometry 的表示-Grid</h5>
<div class="outline-text-5" id="text-orgba1836d">
<ul class="org-ul">
<li>使用 grid 对整个空间进行分割，每个 cell 存储对应点的物理信息<br /></li>
<li>体积扫描(如 CT)可以获得 grid 表示的几何体<br /></li>
<li>相关的问题 :<br />
<ul class="org-ul">
<li>grid 表示几何体内存占用比较大，如何优化？<br /></li>
<li>体积渲染<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge137842" class="outline-5">
<h5 id="orge137842">Animation</h5>
<div class="outline-text-5" id="text-orge137842">
<p>
动画分为角色动画(Character Animation)和基于物理的动画(Physics-Based Aniamtion)<br />
</p>
</div>
</div>
<div id="outline-container-orgdfcf1fc" class="outline-5">
<h5 id="orgdfcf1fc">Rendering</h5>
<div class="outline-text-5" id="text-orgdfcf1fc">
<p>
渲染分为两大类：真实感渲染和非真实感渲染<br />
材质是渲染相关的一个重要话题。材质扫描（物体、人）<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga470a46" class="outline-4">
<h4 id="orga470a46">What’s physics-based animation?</h4>
<div class="outline-text-4" id="text-orga470a46">
</div>
<div id="outline-container-org9323162" class="outline-5">
<h5 id="org9323162">动画的范式</h5>
<div class="outline-text-5" id="text-org9323162">
<p>
动画的目的是在每段时间间隔内更新物体的状态。被更新的状态可以是 位置、朝向、速度、外观、密度等等。time step 不必和 frame rate 相匹配，通常动画的 time step 要比渲染的 time step 要小，即动画帧率大于渲染帧率。<br />
<img src="./PhysicalBasedAnimation/games103_animation_paradigm.jpg" alt="games103_animation_paradigm.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgf5b7a18" class="outline-5">
<h5 id="orgf5b7a18">Physics-based Aniamtion 研究的内容</h5>
<div class="outline-text-5" id="text-orgf5b7a18">
<p>
下图展示了基于物理动画的研究内容：<br />
<img src="./PhysicalBasedAnimation/games103_animation_topics01.jpg" alt="games103_animation_topics01.jpg" /><br />
</p>

<p>
SIGGRAPH 2013 A Material Point Method for Snow Simulation 论文中使用 Hybrid Method 来模拟雪。<br />
</p>

<p>
下图展示了本课程所涉及的内容：<br />
<img src="./PhysicalBasedAnimation/games103_animation_topics02.jpg" alt="games103_animation_topics02.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org551bb59" class="outline-3">
<h3 id="org551bb59">Math Background: Vector, Matrix and Tensor Calculus</h3>
<div class="outline-text-3" id="text-org551bb59">
</div>
<div id="outline-container-orgfd813c7" class="outline-4">
<h4 id="orgfd813c7">Vector</h4>
<div class="outline-text-4" id="text-orgfd813c7">
<ul class="org-ul">
<li>利用 Vector 点积表示平面<br /></li>
<li>利用 Vector 叉积判断点是否在三角形内<br /></li>
<li>利用 Vector 叉积计算 barycentric coordinates<br /></li>
<li>利用 Vector 表示四面体, 求四面体内一点的 barycentric weights<br /></li>
<li>利用 Vector 检测运动粒子和三角形的相交<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org21444aa" class="outline-4">
<h4 id="org21444aa">Matrix</h4>
<div class="outline-text-4" id="text-org21444aa">
</div>
<div id="outline-container-orgd793b5e" class="outline-5">
<h5 id="orgd793b5e">Singular Value Decomposition</h5>
<div class="outline-text-5" id="text-orgd793b5e">
<p>
一个矩阵 A 可以被分解为 UDV<sup>T</sup>。U和 V 为正交矩阵，D为对角矩阵。<br />
奇异值分解的直观解释： 任何一个线性变形都可以被分解为三个步骤，1 旋转(U),2 缩放(D),3 旋转(V<sup>T</sup>)<br />
</p>


<div id="org007326d" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_singular_value_decomposition.jpg" alt="games103_singular_value_decomposition.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgacd3114" class="outline-5">
<h5 id="orgacd3114">Eigenvalue Decomposition</h5>
<div class="outline-text-5" id="text-orgacd3114">
<p>
图形学中只考虑对称矩阵的特征值分解。对称矩阵（Symmetric Matrices）是指以主对角线为对称轴，各元素对应相等的矩阵。<br />
一个对称矩阵 A 可以被分解为 UDU<sup>-1</sup>。U为特征向量组成的正交矩阵，D为特征值组成的对角矩阵。<br />
</p>

<p>
非对称矩阵 A 也可以进行特征值分解，此时特征值和特征向量为虚数。<br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3">https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9ee3124" class="outline-5">
<h5 id="org9ee3124">Symmetric Positive Definiteness (s.p.d)</h5>
<div class="outline-text-5" id="text-org9ee3124">
<p>
对于任意不等于 0 的向量 v，如果 v<sup>T</sup>Av &gt; 0, 则对称矩阵 A 对称正定(symmetric positive definiteness)<br />
对于任意不等于 0 的向量 v，如果 v<sup>T</sup>Av &gt;= 0, 则对称矩阵 A 对称半正定(symmetric semi-definite)<br />
</p>

<p>
上面定义的直观理解：<br />
<img src="./PhysicalBasedAnimation/games103_spd_matrix.jpg" alt="games103_spd_matrix.jpg" /><br />
</p>

<ul class="org-ul">
<li>矩阵 A 特征值都大于 0 则矩阵 A 是正定的(Positive Definiteness)。通常不使用特征值分解来判断矩阵是否是正定的，因为这样特征值分解比较耗时<br /></li>
<li>对角占优的矩阵是正定的，但正定矩阵不一定是对角占优的<br />
<img src="./PhysicalBasedAnimation/games103_spd_diagonally_nominant.jpg" alt="games103_spd_diagonally_nominant.jpg" /><br /></li>
<li>s.p.d 矩阵是可逆的<br />
<img src="./PhysicalBasedAnimation/games103_spd_invertible.jpg" alt="games103_spd_invertible.jpg" /><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga29a080" class="outline-5">
<h5 id="orga29a080">Linear Solver</h5>
<div class="outline-text-5" id="text-orga29a080">
<p>
很多数值计算问题最终都会被化解为求解一个线性系统，一个线性系统可以被形式化地表示为：<br />
<img src="./PhysicalBasedAnimation/games103_linear_system.jpg" alt="games103_linear_system.jpg" /><br />
</p>
<ul class="org-ul">
<li>A 为方阵<br /></li>
<li>x 为未知量<br /></li>
<li>b 为边界条件<br /></li>
</ul>
<p>
如果可以直接计算 A<sup>-1</sup> ，则 x = A{-1}b<br />
但是，A<sup>-1</sup> 的计算通常比较耗时，而且如果 A 为稀疏矩阵，A{-1} 可能不是稀疏矩阵，则存储 A{-1} 占用的空间会比较多。<br />
</p>

<p>
通常有两种方法来求解线性系统：直接法(direct)和迭代法(iterative)<br />
</p>
</div>
<div id="outline-container-org6ade3e9" class="outline-6">
<h6 id="org6ade3e9">Direct Linear Solver</h6>
<div class="outline-text-6" id="text-org6ade3e9">
<p>
直接法通常会基于 LU 分解或 LU 分解的变种(Cholesky,LDL<sup>T</sup> 等等)。LU 分解和其变种的差别主要在内存占用上，LU 分解 &gt; LDL<sup>T</sup> &gt; Cholesky<br />
LU 分解就是将矩阵 A 分解为上三角矩阵和下三角矩阵：<br />
<img src="./PhysicalBasedAnimation/games103_lu_factorization.jpg" alt="games103_lu_factorization.jpg" /><br />
</p>

<p>
LU 分解求解线性系统的原理如下：<br />
<img src="./PhysicalBasedAnimation/games103_lu_linear_solver.jpg" alt="games103_lu_linear_solver.jpg" /><br />
</p>

<p>
直接法的特点：<br />
</p>
<ul class="org-ul">
<li>如果 A 是稀疏矩阵，L和 U 稀疏性会减低。稀疏性和矩阵的行列的排列有关<br /></li>
<li>直接法分两部：1 LU 分解；2 求解。如果多个问题公用 A，则第一步 LU 分解可以被公用<br /></li>
<li>LU 分解部分不容易被并行<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org93088e8" class="outline-6">
<h6 id="org93088e8">Iterative Linear Solver</h6>
<div class="outline-text-6" id="text-org93088e8">
<p>
迭代法的基本形式是每次迭代对 x 进行更新，如：一开始知道 x0, 对其更新一次后得到 x1，再更新一次后得到 x2，迭代多次后，xn 就是满足 Ax=b 条件的 x。形式化表示如下图：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver01.jpg" alt="games103_iterative_linear_solver01.jpg" /><br />
</p>

<p>
若 b-Ax[k] 趋近于 0 时，上面迭代法收敛，通过考察 b-Ax[k+1] 来进一步细化迭代法的收敛条件：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver02.jpg" alt="games103_iterative_linear_solver02.jpg" /><br />
</p>

<ul class="org-ul">
<li>矩阵谱半径 <a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E8%B0%B1%E5%8D%8A%E5%BE%84/7905023?fr=aladdin">https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E8%B0%B1%E5%8D%8A%E5%BE%84/7905023?fr=aladdin</a><br /></li>
</ul>

<p>
上面形式化的表达式中的矩阵 M 是迭代矩阵，矩阵 M 的逆矩阵必须是容易被求解的，因此 M 的选择为矩阵 A 的对角矩阵或矩阵 A 的下三角矩阵：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver03.jpg" alt="games103_iterative_linear_solver03.jpg" /><br />
</p>


<div id="org587297e" class="figure">
<p><img src="./PhysicalBasedAnimation/matrix_inverse.png" alt="matrix_inverse.png" /><br />
</p>
</div>

<p>
和直接法相比，迭代法的优缺点如下：<br />
<img src="./PhysicalBasedAnimation/games103_iterative_linear_solver04.jpg" alt="games103_iterative_linear_solver04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf9a8008" class="outline-4">
<h4 id="orgf9a8008">Tensor Calculus</h4>
<div class="outline-text-4" id="text-orgf9a8008">
</div>
<div id="outline-container-org0bd3204" class="outline-5">
<h5 id="org0bd3204">一阶导数</h5>
<div class="outline-text-5" id="text-org0bd3204">
<p>
一元函数的微分、导数<br />
二元函数的偏微分、方向导数、梯度<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base01.jpg" alt="games103_calculus_base01.jpg" /><br />
</p>

<p>
多元向量值函数、多元向量值函数的偏微分组成的雅可比矩阵、散度(通量密度)、旋度(环流量密度)<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base02.jpg" alt="games103_calculus_base02.jpg" /><br />
</p>

<ul class="org-ul">
<li>向量值函数 <a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0</a><br /></li>
<li>梯度、散度、旋度 <a href="https://zhuanlan.zhihu.com/p/97545154">https://zhuanlan.zhihu.com/p/97545154</a><br /></li>
<li>矩阵求导 <a href="https://zhuanlan.zhihu.com/p/263777564">https://zhuanlan.zhihu.com/p/263777564</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org66c8a68" class="outline-5">
<h5 id="org66c8a68">二阶导数</h5>
<div class="outline-text-5" id="text-org66c8a68">
<p>
多元函数的二阶偏微分组成的 Hessian 矩阵、Lapacian<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base03.jpg" alt="games103_calculus_base03.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org5a4811c" class="outline-5">
<h5 id="org5a4811c">Taylor Expansion</h5>
<div class="outline-text-5" id="text-org5a4811c">
<p>
下图为一元函数和多元函数的泰勒展开。泰勒展开的本质是利用多项式函数逼近目标函数，目标函数可以是任意函数(自然也包含积分函数了)。<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base04.jpg" alt="games103_calculus_base04.jpg" /><br />
</p>

<ul class="org-ul">
<li>怎样更好地理解并记忆泰勒展开式？ <a href="https://www.zhihu.com/question/25627482/answer/313088784">https://www.zhihu.com/question/25627482/answer/313088784</a><br /></li>
<li>如何通俗地解释泰勒公式？ <a href="https://www.zhihu.com/question/21149770">https://www.zhihu.com/question/21149770</a><br /></li>
<li>如何通俗地解释泰勒公式？ <a href="https://www.matongxue.com/madocs/7">https://www.matongxue.com/madocs/7</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf64d4fd" class="outline-4">
<h4 id="orgf64d4fd">Examples</h4>
<div class="outline-text-4" id="text-orgf64d4fd">
</div>
<div id="outline-container-orga3803f5" class="outline-5">
<h5 id="orga3803f5">向量长度的偏导数</h5>
<div class="outline-text-5" id="text-orga3803f5">
<p>
向量长度的偏导数为向量转置后的单位向量，梯度的方向为偏导数向量的转置，因此向量长度的梯度为向量对应的单位向量，即沿着向量方向生长，向量的长度变长。<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_01.jpg" alt="games103_calculus_base_app_01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org29905fc" class="outline-5">
<h5 id="org29905fc">A Spring</h5>
<div class="outline-text-5" id="text-org29905fc">
<p>
能量求导得到力，力求导得到 stiffness（stiffness 是 Hessian 矩阵）：<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_02.jpg" alt="games103_calculus_base_app_02.jpg" /><br />
</p>

<p>
上面 Tangent stiffness 的推导如果看不懂，可以直接看视频讲解。<br />
</p>
</div>
</div>
<div id="outline-container-org34dbec9" class="outline-5">
<h5 id="org34dbec9">A Spring with Two Ends</h5>
<div class="outline-text-5" id="text-org34dbec9">
<p>
弹簧两端都可以移动的情况：<br />
<img src="./PhysicalBasedAnimation/games103_calculus_base_app_03.jpg" alt="games103_calculus_base_app_03.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8fba452" class="outline-3">
<h3 id="org8fba452">Rigid Body Contacts（Lab 1 ）</h3>
<div class="outline-text-3" id="text-org8fba452">
<p>
刚体只允许平移和旋转两种运动，这两种运动不会让物体产生形变。<br />
</p>
</div>
<div id="outline-container-org8ee5fe2" class="outline-4">
<h4 id="org8ee5fe2">Rigid Body Simulation</h4>
<div class="outline-text-4" id="text-org8ee5fe2">
<p>
模拟刚体就是随着时间不断更新刚体的状态变量。图示如下：<br />
</p>


<div id="org0f8e770" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_001.jpg" alt="games103_rigid_body_simu_001.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org814e3e7" class="outline-4">
<h4 id="org814e3e7">Translational Motion</h4>
<div class="outline-text-4" id="text-org814e3e7">
<p>
只考虑平移运动时，物体的状态变量包括：位置和速度。使用下面方法，利用 t0 时刻的状态，求出 t1 时刻的状态：<br />
</p>


<div id="org6e38b26" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_002.jpg" alt="games103_rigid_body_simu_002.jpg" /><br />
</p>
</div>

<p>
从上图可以看出，模拟涉及到的主要运算就是求积分。<br />
</p>
</div>
<div id="outline-container-orgcf5511b" class="outline-5">
<h5 id="orgcf5511b">Integration Methods</h5>
<div class="outline-text-5" id="text-orgcf5511b">
<p>
显式 Euler 方法求积分如下：(该方法一阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_001.jpg" alt="games103_rigid_body_simu_integration_001.jpg" /><br />
</p>

<p>
隐式 Euler 方法求积分如下：(该方法一阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_002.jpg" alt="games103_rigid_body_simu_integration_002.jpg" /><br />
</p>

<p>
上述泰勒展开的推导：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_003.jpg" alt="games103_rigid_body_simu_integration_003.jpg" /><br />
</p>

<p>
Mid-point 方法求积分如下：(该方法二阶正确)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_integration_004.jpg" alt="games103_rigid_body_simu_integration_004.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgb30a8ae" class="outline-5">
<h5 id="orgb30a8ae">Apply Intergration For Translational Motion</h5>
<div class="outline-text-5" id="text-orgb30a8ae">
<p>
显式、隐式方法（半隐式方法）：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_apply_001.jpg" alt="games103_rigid_body_simu_apply_001.jpg" /><br />
</p>

<p>
Leapfrog 方法：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_apply_002.jpg" alt="games103_rigid_body_simu_apply_002.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org82bc7d0" class="outline-5">
<h5 id="org82bc7d0">Types of Forces</h5>
<div class="outline-text-5" id="text-org82bc7d0">

<div id="org73d3f07" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_forces.jpg" alt="games103_rigid_body_simu_forces.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org6dd9113" class="outline-4">
<h4 id="org6dd9113">Rotational Motion</h4>
<div class="outline-text-4" id="text-org6dd9113">
</div>
<div id="outline-container-org973d468" class="outline-5">
<h5 id="org973d468">Rotation Represented</h5>
<div class="outline-text-5" id="text-org973d468">
<p>
矩阵表示旋转的优缺点：<br />
</p>
<ul class="org-ul">
<li>优点:<br />
<ul class="org-ul">
<li>使用矩阵和向量的乘法就可以表示物体的旋转<br /></li>
</ul></li>
<li>缺点<br />
<ul class="org-ul">
<li>3x3 矩阵有 9 个元素，而旋转只有 3 个自由度，因此矩阵表示旋转有很多冗余<br /></li>
<li>不直观<br /></li>
<li>定义旋转速度比较困难<br /></li>
</ul></li>
</ul>

<p>
欧拉角表示旋转的优缺点：<br />
</p>
<ul class="org-ul">
<li>优点：<br />
<ul class="org-ul">
<li>直观<br /></li>
<li>Unity 用户操作界面中使用了欧拉角表示旋转，euler 角所使用的旋转顺序为：Z，X，Y<br /></li>
</ul></li>
<li>缺点：<br />
<ul class="org-ul">
<li>存在万向锁问题<br /></li>
<li>定义旋转速度比较困难<br /></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org7611cc7" class="outline-5">
<h5 id="org7611cc7">Quaternion</h5>
<div class="outline-text-5" id="text-org7611cc7">
<p>
在复数系统中，a+bi 可以表示一个二维的点，a+bi+cj+dk 可以表示一个三维的点。<br />
</p>

<p>
四元数计算法则如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_quaternion.jpg" alt="games103_rigid_body_quaternion.jpg" /><br />
</p>

<p>
四元数表示旋转可以避免万向锁、而且定义旋转速度比较容易。<br />
关于四元数详情，请参考 <a href="../theory/ComputerGraphicMath.html#orgf97f2f7">ComputerGraphicMath 中 Quaternions 部分</a><br />
</p>
</div>
</div>

<div id="outline-container-org84ed346" class="outline-5">
<h5 id="org84ed346">Torque and Inertia</h5>
<div class="outline-text-5" id="text-org84ed346">
<p>
力矩描述了力所引起的旋转的趋势。力矩越大旋转越强烈、力矩越小旋转越弱。(等价于平移运动中的力)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_torque.jpg" alt="games103_rigid_body_simu_torque.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_torque_01.jpg" alt="games103_rigid_body_simu_torque_01.jpg" /><br />
</p>

<p>
转动惯量(Inertia)描述了对旋转趋势的抵抗。和质量不同，转动惯量不是一个常数，其为一个矩阵。(等价于平移运动中的质量)<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_inertia.jpg" alt="games103_rigid_body_simu_inertia.jpg" /><br />
</p>

<p>
Tips:<br />
这里说的转动惯量，其实是惯性张量。当然，也有人说转动惯量和惯性张量是同一个概念。<br />
</p>

<ul class="org-ul">
<li>转动惯量 <a href="https://baike.sogou.com/v64484710.htm">https://baike.sogou.com/v64484710.htm</a><br /></li>
<li>惯性张量 <a href="https://baike.baidu.com/item/%E6%83%AF%E6%80%A7%E5%BC%A0%E9%87%8F">https://baike.baidu.com/item/%E6%83%AF%E6%80%A7%E5%BC%A0%E9%87%8F</a><br /></li>
<li>转动惯量是标量还是矢量？ <a href="https://www.zhihu.com/question/348221712">https://www.zhihu.com/question/348221712</a><br /></li>
<li>Moment of inertia <a href="https://en.wikipedia.org/wiki/Moment_of_inertia">https://en.wikipedia.org/wiki/Moment_of_inertia</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org333963a" class="outline-4">
<h4 id="org333963a">Translational and Rotational Motion</h4>
<div class="outline-text-4" id="text-org333963a">

<div id="orgb031f0f" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_sum.jpg" alt="games103_rigid_body_simu_sum.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc9f9958" class="outline-4">
<h4 id="orgc9f9958">Particle Collision Detection and Response</h4>
<div class="outline-text-4" id="text-orgc9f9958">
<p>
质点的碰撞检测和响应。<br />
有符号的距离函数（signed distance function）来描述一个点到表面的距离。符合指示了点在表面的哪一侧。<br />
<img src="./PhysicalBasedAnimation/games103_signed_distance_func_01.jpg" alt="games103_signed_distance_func_01.jpg" /><br />
</p>

<p>
使用有符号距离函数的具体实例：<br />
<img src="./PhysicalBasedAnimation/games103_signed_distance_func_02.jpg" alt="games103_signed_distance_func_02.jpg" /><br />
</p>
</div>

<div id="outline-container-org428831b" class="outline-5">
<h5 id="org428831b">Penalty methods</h5>
<div class="outline-text-5" id="text-org428831b">
<p>
Penalty 方法首先检测当前是否发生碰撞，若发生则应用一个力将粒子弹开。<br />
当使用的力和粒子进入物体的距离为线性关系时，此时的能量和进入物体的距离为二次关系，因此称该 Penalty 方法为 Quadratic Penalty Method.<br />
</p>


<div id="orga8f7b3b" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func.jpg" alt="games103_rigid_body_simu_penalty_func.jpg" /><br />
</p>
</div>

<p>
上面的方法中，无论 k 多大都无法严格避免穿透，因为只有穿透时，才会应用 Penalty 力将粒子弹开。因此，可以在表面之上增加一个缓存区，进入缓冲区就对粒子应用 Penalty 力。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func_01.jpg" alt="games103_rigid_body_simu_penalty_func_01.jpg" /><br />
</p>

<p>
上面的方法中，当 k 比较小时，若粒子猛烈撞向物体时，粒子依然有可能进入物体内；当 k 比较大时，粒子缓缓撞向物体时，粒子可能会被弹很远（overshooting 问题）。<br />
为了缓解这些问题，可以将 k 和碰撞距离关联起来，碰撞距离越小 k 越大，碰撞距离越大 k 越小。新的方法被称为 Log-Barrier Penalty Method。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_penalty_func_02.jpg" alt="games103_rigid_body_simu_penalty_func_02.jpg" /><br />
</p>

<p>
上面方法无法完全避免 overshooting。而且当粒子穿透物体时，会越陷越深，因此需要小步长来保证不会发生穿透。<br />
</p>
</div>

<div id="outline-container-org6c8bf82" class="outline-6">
<h6 id="org6c8bf82">Summary of Penalty Methods</h6>
<div class="outline-text-6" id="text-org6c8bf82">
<ul class="org-ul">
<li>使用 Penalty 方法，通常都需要调整步长<br />
<ul class="org-ul">
<li>调整步长用于避免 overshooting<br /></li>
<li>在 log-barrier 方法中，调整步长用于避免穿透<br /></li>
</ul></li>
<li>log-barrier 方法可以和 buffer 相结合<br /></li>
<li>Penalty 方法无法处理摩擦交互<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7a5b279" class="outline-5">
<h5 id="org7a5b279">Impulse methods</h5>
<div class="outline-text-5" id="text-org7a5b279">
<p>
Penalty 方法是通过施加力来起作用的，力的影响会在下一帧生效，其不会在当前帧影响物体的位置和速度。<br />
Impulse 方法则是在碰撞发生时立刻对位置和速度进行修改。<br />
</p>


<div id="org6acc5a3" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func.jpg" alt="games103_rigid_body_simu_impulse_func.jpg" /><br />
</p>
</div>

<p>
刚体一般使用 Impulse 方法，衣服和弹性体一般使用 Penalty 方法。物理世界中，本质上碰撞是由于分子之间的互斥导致的，摩擦是由于表面的不平整导致的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org54c33cb" class="outline-4">
<h4 id="org54c33cb">Rigid Collision Detection and Response by Impulse</h4>
<div class="outline-text-4" id="text-org54c33cb">
<p>
由多个顶点组成的物体，循环判断每个顶点的碰撞情况来进行处理。但是，更新每个顶点的位置、速度、朝向、角速度是不可行的，最终，还是需要修改刚体整体的位置、速度、朝向以及角速度。<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_001.jpg" alt="games103_rigid_body_simu_impulse_func_001.jpg" /><br />
整个算法流程如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_002.jpg" alt="games103_rigid_body_simu_impulse_func_002.jpg" /><br />
</p>

<p>
实现注意事项：<br />
</p>
<ul class="org-ul">
<li>当同时有多个点产生碰撞时，取多个点位置的平均值，来进行碰撞计算。如果多个点都进行单独处理的化，会导致冲量过大。<br /></li>
<li>当存在重力时，使得速度永远都有一个往下的量，而碰撞的冲量又使得物体反弹。这样就使得物体在平面上反复振荡（oscillation）, 可以通过衰减 μ<sub>N</sub> 来减少 oscillation.<br /></li>
<li>为什么不直接更新位置？<br />
<ul class="org-ul">
<li>因为位置不是线性问题<br /></li>
<li>在后续讲约束时，会再讲该问题 TODO<br /></li>
</ul></li>
</ul>

<p>
多个物体接触的情况：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_impulse_func_003.jpg" alt="games103_rigid_body_simu_impulse_func_003.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgde41a3d" class="outline-4">
<h4 id="orgde41a3d">Shape Matching method</h4>
<div class="outline-text-4" id="text-orgde41a3d">
<p>
Shape Matching 方法的背后理念：假设刚体可以变形，单独模拟刚体每个顶点的运动，然后，再将物体变回原来的形状。如下图所示：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_01.jpg" alt="games103_rigid_body_simu_shape_matching_01.jpg" /><br />
数学原理描述如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_02.jpg" alt="games103_rigid_body_simu_shape_matching_02.jpg" /><br />
整体的实现如下：<br />
<img src="./PhysicalBasedAnimation/games103_rigid_body_simu_shape_matching_03.jpg" alt="games103_rigid_body_simu_shape_matching_03.jpg" /><br />
</p>
</div>

<div id="outline-container-org4f3cef0" class="outline-5">
<h5 id="org4f3cef0">优缺点</h5>
<div class="outline-text-5" id="text-org4f3cef0">
<ul class="org-ul">
<li>易于实现，和其他质点系统容易结合（如：衣服，软体，粒子流体, 前面这些都是基于质点进行模拟的）<br /></li>
<li>不易于严格满足所有的约束（例如，摩擦的约束）<br /></li>
<li>通常不需要精确的摩擦、或碰撞时，可以使用该方法（例如：衣服上的扣子）<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org6c3c752" class="outline-3">
<h3 id="org6c3c752">Mass-Spring Systems</h3>
<div class="outline-text-3" id="text-org6c3c752">
</div>
<div id="outline-container-orgbe75b2b" class="outline-4">
<h4 id="orgbe75b2b">Spring</h4>
<div class="outline-text-4" id="text-orgbe75b2b">
<p>
下面为质点弹簧系统的理论基础：<br />
<img src="./PhysicalBasedAnimation/games103_spring_01.jpg" alt="games103_spring_01.jpg" /><br />
</p>

<p>
下面为利用质点弹簧系统构造结构化的质点弹簧网络来实现模拟。<br />
<img src="./PhysicalBasedAnimation/games103_spring_02.jpg" alt="games103_spring_02.jpg" /><br />
</p>

<p>
下面为利用质点弹簧系统构造非结构化的质点弹簧网络来实现模拟。<br />
<img src="./PhysicalBasedAnimation/games103_spring_03.jpg" alt="games103_spring_03.jpg" /><br />
</p>

<p>
下面为三角形表示的物体时，质点弹簧系统的构造：<br />
<img src="./PhysicalBasedAnimation/games103_spring_04.jpg" alt="games103_spring_04.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgf656cca" class="outline-4">
<h4 id="orgf656cca">Explicit Integration</h4>
<div class="outline-text-4" id="text-orgf656cca">

<div id="org11a3348" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_explicit_integration.jpg" alt="games103_spring_explicit_integration.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org29afe03" class="outline-4">
<h4 id="org29afe03">Implicit Integration</h4>
<div class="outline-text-4" id="text-org29afe03">

<div id="org20f7762" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration.jpg" alt="games103_spring_implicit_integration.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org46d7704" class="outline-5">
<h5 id="org46d7704">Newton-Raphson Method</h5>
<div class="outline-text-5" id="text-org46d7704">

<div id="orgd1b04f9" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method01.jpg" alt="games103_spring_implicit_integration-newton-method01.jpg" /><br />
</p>
</div>

<p>
简单来说，牛顿法其实就是使用一阶泰勒展开近似 f(x)，从而求出 x。所以，关键是要构造 f(x) 函数，使得 f(x)和 f'(x)都可以计算。<br />
<img src="./PhysicalBasedAnimation/newton-method01.jpg" alt="newton-method01.jpg" /><br />
</p>

<p>
对于求 a 的平方根这个问题来说，假设 a 的平方根为 b（即 √a = b)，则 b^2 = a。所以可以将 f(x) 构造为 b^2-a，即 f(x)=x^2-a，f'(x)=2x<br />
对于求多项式的根这个问题来说，可以直接将 f(x) 构造为多项式<br />
</p>

<ul class="org-ul">
<li>如何通俗易懂地讲解牛顿迭代法？ <a href="https://www.matongxue.com/madocs/205">https://www.matongxue.com/madocs/205</a><br /></li>
<li>一文看懂牛顿法（附 Python 实现）<a href="https://zhuanlan.zhihu.com/p/105265432">https://zhuanlan.zhihu.com/p/105265432</a> 有道云备份<br /></li>
<li>Newton-Raphson Method geogebra <a href="https://www.geogebra.org/m/DGFGBJyU">https://www.geogebra.org/m/DGFGBJyU</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgadf67d0" class="outline-5">
<h5 id="orgadf67d0">Simulation by Newton's Method</h5>
<div class="outline-text-5" id="text-orgadf67d0">
<p>
对于物理模拟问题来说，我们并不会令 F(x)=0<br />
</p>


<div id="orgde6f5dd" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method02.jpg" alt="games103_spring_implicit_integration-newton-method02.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org9356443" class="outline-6">
<h6 id="org9356443">Spring Hessian</h6>
<div class="outline-text-6" id="text-org9356443">

<div id="org6d38c9f" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method03.jpg" alt="games103_spring_implicit_integration-newton-method03.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8ad522c" class="outline-6">
<h6 id="org8ad522c">Positive Definiteness of Hessian</h6>
<div class="outline-text-6" id="text-org8ad522c">

<div id="orge8b03a4" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method04.jpg" alt="games103_spring_implicit_integration-newton-method04.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2655098" class="outline-6">
<h6 id="org2655098">Enforcement of Positive Definiteness</h6>
<div class="outline-text-6" id="text-org2655098">

<div id="org39a0bfb" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method05.jpg" alt="games103_spring_implicit_integration-newton-method05.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgad7244b" class="outline-6">
<h6 id="orgad7244b">Jacobi Method</h6>
<div class="outline-text-6" id="text-orgad7244b">

<div id="orgbd96593" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method06.jpg" alt="games103_spring_implicit_integration-newton-method06.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>定常迭代：Jacobi 法、Gauss-Seidel <a href="https://zhuanlan.zhihu.com/p/151808535">https://zhuanlan.zhihu.com/p/151808535</a>  有道云备份<br /></li>
</ul>


<div id="orgc95dc69" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_spring_implicit_integration-newton-method07.jpg" alt="games103_spring_implicit_integration-newton-method07.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb709eb9" class="outline-4">
<h4 id="orgb709eb9">Bending and Locking Issues</h4>
<div class="outline-text-4" id="text-orgb709eb9">
</div>
<div id="outline-container-orgdbeabfe" class="outline-5">
<h5 id="orgdbeabfe">The Bending Spring Issues</h5>
<div class="outline-text-5" id="text-orgdbeabfe">

<div id="orgebd1606" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending01.jpg" alt="games103_05cloth_bending01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgf938a10" class="outline-6">
<h6 id="orgf938a10">A Dihedral Angle Model</h6>
<div class="outline-text-6" id="text-orgf938a10">

<div id="orgfc919ce" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending02.jpg" alt="games103_05cloth_bending02.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3738f5a" class="outline-6">
<h6 id="org3738f5a">A Quadratic Bending Model</h6>
<div class="outline-text-6" id="text-org3738f5a">

<div id="orgecf5e48" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending03.jpg" alt="games103_05cloth_bending03.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org29b8f3d" class="outline-5">
<h5 id="org29b8f3d">The Locking Issues</h5>
<div class="outline-text-5" id="text-org29b8f3d">
<p>
目前为止，我们讨论模拟模型(质点弹簧模型、其他弯曲模型)时，假设拉伸和弯曲是互相独立的。现实情况也是如此，例如，纸可以弯曲但不可以拉伸。<br />
</p>


<div id="org37168ac" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_05cloth_bending04.jpg" alt="games103_05cloth_bending04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f275f1" class="outline-4">
<h4 id="org1f275f1">Shape Matching</h4>
<div class="outline-text-4" id="text-org1f275f1">
<p>
TODO<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org733247e" class="outline-3">
<h3 id="org733247e">Constrained Approaches: PBD, PD and others （Lab 2 ）</h3>
<div class="outline-text-3" id="text-org733247e">
<p>
约束用于解决模拟和真实世界差异的问题。<br />
</p>
</div>
<div id="outline-container-orgb158110" class="outline-4">
<h4 id="orgb158110">Position Based Dynamics</h4>
<div class="outline-text-4" id="text-orgb158110">
</div>
<div id="outline-container-org66045de" class="outline-5">
<h5 id="org66045de">The Stiffness Issue</h5>
<div class="outline-text-5" id="text-org66045de">
<p>
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_01.jpg" alt="games103_06stiffness_issue_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_02.jpg" alt="games103_06stiffness_issue_02.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06stiffness_issue_03.jpg" alt="games103_06stiffness_issue_03.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org6420cc5" class="outline-5">
<h5 id="org6420cc5">PBD</h5>
<div class="outline-text-5" id="text-org6420cc5">

<div id="orgd1be865" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06pbd_01.jpg" alt="games103_06pbd_01.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org4630faa" class="outline-4">
<h4 id="org4630faa">Strain Limiting</h4>
<div class="outline-text-4" id="text-org4630faa">
<p>
PBD 直接利用投影方法来模拟顶点运动，StrainLimiting 只是利用投影方法来修正顶点位置。<br />
<img src="./PhysicalBasedAnimation/games103_06strain_limiting_01.jpg" alt="games103_06strain_limiting_01.jpg" /><br />
</p>
</div>
<div id="outline-container-org132c6d6" class="outline-5">
<h5 id="org132c6d6">Spring Strain Limit</h5>
<div class="outline-text-5" id="text-org132c6d6">

<div id="orga1ae068" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_02.jpg" alt="games103_06strain_limiting_02.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org16f0bd7" class="outline-5">
<h5 id="org16f0bd7">Triangle Area Limit</h5>
<div class="outline-text-5" id="text-org16f0bd7">

<div id="orge42200c" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_03.jpg" alt="games103_06strain_limiting_03.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5173a60" class="outline-5">
<h5 id="org5173a60">Strain Limiting in Simulation</h5>
<div class="outline-text-5" id="text-org5173a60">

<div id="org2826cff" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06strain_limiting_04.jpg" alt="games103_06strain_limiting_04.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org717194d" class="outline-4">
<h4 id="org717194d">Projective Dynamics</h4>
<div class="outline-text-4" id="text-org717194d">
<p>
PBD 直接利用投影方法来修改顶点位置。Projective Dynamics 则利用投影方法计算出新的顶点位置后，利用新的顶点位置构造一个能量函数。<br />
</p>

<p>
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_01.jpg" alt="games103_06projective_dynamics_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_02.jpg" alt="games103_06projective_dynamics_02.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_03.jpg" alt="games103_06projective_dynamics_03.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06projective_dynamics_04.jpg" alt="games103_06projective_dynamics_04.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org2367d29" class="outline-4">
<h4 id="org2367d29">Constrained Dynamics</h4>
<div class="outline-text-4" id="text-org2367d29">
<p>
前面的方法中，模拟 stiffness 非常大的物体时，需要迭代的次数非常多。该方法用于使用很少的迭代次数，就可以模拟 stiffness 非常大的物体。<br />
</p>

<p>
<img src="./PhysicalBasedAnimation/games103_06constrained_dynamics_01.jpg" alt="games103_06constrained_dynamics_01.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_06constrained_dynamics_02.jpg" alt="games103_06constrained_dynamics_02.jpg" /><br />
</p>

<p>
Constrained Dynamics 通常用于模拟 articulated rigid body, 也被称为 ragdoll animation(布娃娃动画)<br />
articulated rigid body 假设人体是由多个刚体组成，刚体有一系列约束。<br />
</p>
</div>
</div>
<div id="outline-container-org88582ef" class="outline-4">
<h4 id="org88582ef">Stable Constrained Dynamics</h4>
<div class="outline-text-4" id="text-org88582ef">
<p>
隐式积分的方法中缺失了 geometric stiffness matrix，添加该 stiffness matrix 可以让 constrained dynamics 更加稳定。<br />
</p>

<p>
TODO<br />
</p>
</div>
</div>
<div id="outline-container-org78bf8c3" class="outline-4">
<h4 id="org78bf8c3">Summary</h4>
<div class="outline-text-4" id="text-org78bf8c3">

<div id="org0533586" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_06_summary.jpg" alt="games103_06_summary.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org6e9a75a" class="outline-3">
<h3 id="org6e9a75a">Collision Handling</h3>
</div>
<div id="outline-container-org68cc38f" class="outline-3">
<h3 id="org68cc38f">Soft Body Dynamics and Finite Element Method （Lab 3）</h3>
<div class="outline-text-3" id="text-org68cc38f">
</div>
<div id="outline-container-org35e81f2" class="outline-4">
<h4 id="org35e81f2">Linear Finite Element Method</h4>
<div class="outline-text-4" id="text-org35e81f2">
<p>
有限元方法<br />
<img src="./PhysicalBasedAnimation/games103_08fem_001.jpg" alt="games103_08fem_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08fem_002.jpg" alt="games103_08fem_002.jpg" /><br />
strain 是一个数学的量，用来描述物体的形变，其可以为一个实数（如，物体为一维的弹簧），其也可以为一个矩阵（如，上面描述的三维中的三角形）<br />
<img src="./PhysicalBasedAnimation/games103_08fem_003.jpg" alt="games103_08fem_003.jpg" /><br />
能量对位移求导得到的是力，上面能量密度对形变求导应该类似地对应于力的密度，力的密度矩阵被称为 stress tensor。<br />
<img src="./PhysicalBasedAnimation/games103_08fem_004.jpg" alt="games103_08fem_004.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org94849b1" class="outline-4">
<h4 id="org94849b1">Finite Volume Method</h4>
<div class="outline-text-4" id="text-org94849b1">
<p>
有限体积方法和有限元方法是等价的。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_001.jpg" alt="games103_08fvm_001.jpg" /><br />
有限体积方法本质上基于力从何而来。假如两个弹性体被一个界面分割，为了计算界面上的总的力，假设界面上单位面积的力为 traction t，则界面上总的力，就为 traction t 在整个界面上的积分。通过 stress tensor 矩阵可以求出 traction 力。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_002.jpg" alt="games103_08fvm_002.jpg" /><br />
现在只剩下柯西 stress tensor 是未知的，下面为柯西 stress tensor 的求解:<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_003.jpg" alt="games103_08fvm_003.jpg" /><br />
本节的 stress tensor 和上一节的 stress tensor 有稍微差别，上节课的 stress tensor 为未形变时的 stress tensor，而本节课的 stress tensor 为形变后的 stress tensor。<br />
<img src="./PhysicalBasedAnimation/games103_08fvm_004.jpg" alt="games103_08fvm_004.jpg" /><br />
</p>
</div>
<div id="outline-container-orgf21f0d0" class="outline-5">
<h5 id="orgf21f0d0">Sumarry</h5>
<div class="outline-text-5" id="text-orgf21f0d0">

<div id="orgf1d55b9" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08fvm_005.jpg" alt="games103_08fvm_005.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org275d66f" class="outline-4">
<h4 id="org275d66f">Hyperelastic Models</h4>
<div class="outline-text-4" id="text-org275d66f">
<p>
个性同性的材质横着拉和竖着拉形变是相同的（具有旋转不变性），如橡胶。因此 stress tensor P 中的旋转矩阵 U 和 V^T 可以被提出来。<br />
<img src="./PhysicalBasedAnimation/games103_08h-model_001.jpg" alt="games103_08h-model_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_002.jpg" alt="games103_08h-model_002.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_003.jpg" alt="games103_08h-model_003.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08h-model_004.jpg" alt="games103_08h-model_004.jpg" /><br />
</p>
</div>
<div id="outline-container-orgddf504a" class="outline-5">
<h5 id="orgddf504a">Summary</h5>
<div class="outline-text-5" id="text-orgddf504a">

<div id="org3016df3" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08h-model_005.jpg" alt="games103_08h-model_005.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org695fe2f" class="outline-4">
<h4 id="org695fe2f">Nonlinear Optimization</h4>
<div class="outline-text-4" id="text-org695fe2f">
<p>
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_001.jpg" alt="games103_08nonlinear-opt_001.jpg" /><br />
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_002.jpg" alt="games103_08nonlinear-opt_002.jpg" /><br />
下降方法的性能分析：<br />
<img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_003.jpg" alt="games103_08nonlinear-opt_003.jpg" /><br />
</p>
</div>
<div id="outline-container-orge258d39" class="outline-5">
<h5 id="orge258d39">Summary</h5>
<div class="outline-text-5" id="text-orge258d39">

<div id="orgd50b4b3" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_08nonlinear-opt_004.jpg" alt="games103_08nonlinear-opt_004.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org95c12c0" class="outline-3">
<h3 id="org95c12c0">Surface Waves （Lab 4）</h3>
<div class="outline-text-3" id="text-org95c12c0">
</div>
<div id="outline-container-orgbd536c9" class="outline-4">
<h4 id="orgbd536c9">Two Types of Simulation Approaches</h4>
<div class="outline-text-4" id="text-orgbd536c9">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave01.jpg" alt="games103_10surfacewave01.jpg" /><br />
前面学过的刚体、布料、弹性体模拟都属于拉格朗日方法<br />
今天将会学习的高度场模型属于欧拉方法<br />
</p>
</div>
</div>
<div id="outline-container-org3d4c2a0" class="outline-4">
<h4 id="org3d4c2a0">A Height Field Model</h4>
<div class="outline-text-4" id="text-org3d4c2a0">
<p>
高度场模型无法模拟一个位置对应多个高度值的情况。因此，2D 情况下称对应的高度场为 1.5D，3D 情况下称对应的高度场为 2.5D。<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave02.jpg" alt="games103_10surfacewave02.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8f547c4" class="outline-4">
<h4 id="org8f547c4">Shallow Wave Equation</h4>
<div class="outline-text-4" id="text-org8f547c4">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave03.jpg" alt="games103_10surfacewave03.jpg" /><br />
上面将公式变换最终将速度场移除，从而可以在只使用高度场的情况下对水面进行模拟。<br />
</p>
</div>
<div id="outline-container-org315efe1" class="outline-5">
<h5 id="org315efe1">Finite Differencing</h5>
<div class="outline-text-5" id="text-org315efe1">

<div id="orgee5bbc7" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave04.jpg" alt="games103_10surfacewave04.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf5b55f8" class="outline-5">
<h5 id="orgf5b55f8">Second-Order Derivatives</h5>
<div class="outline-text-5" id="text-orgf5b55f8">

<div id="org376d6fb" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave05.jpg" alt="games103_10surfacewave05.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4ea3dac" class="outline-5">
<h5 id="org4ea3dac">Discretized Shallow Wave Equation</h5>
<div class="outline-text-5" id="text-org4ea3dac">

<div id="org1717200" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave06.jpg" alt="games103_10surfacewave06.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8dfdb60" class="outline-5">
<h5 id="org8dfdb60">Volume Preservation</h5>
<div class="outline-text-5" id="text-org8dfdb60">
<p>
<img src="./PhysicalBasedAnimation/games103_10surfacewave07.jpg" alt="games103_10surfacewave07.jpg" /><br />
结合下面压强的定义，可以更容易上面的公式。<br />
</p>
</div>
</div>
<div id="outline-container-org935409f" class="outline-5">
<h5 id="org935409f">Pressure</h5>
<div class="outline-text-5" id="text-org935409f">

<div id="orgb95d99b" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave08.jpg" alt="games103_10surfacewave08.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc69edc7" class="outline-5">
<h5 id="orgc69edc7">Viscosity</h5>
<div class="outline-text-5" id="text-orgc69edc7">
<p>
前面刚体动力学中位置的更新方式为:<br />
x(t0+dt) = x(t0) + v(t0)*dt<br />
v(t0) = (x(t0)-x(t0-dt))/dt<br />
x(t0+dt) = x(t0) + x(t0) - x(t0-dt)<br />
</p>

<p>
结合上面推导，可以理解下面公式：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave09.jpg" alt="games103_10surfacewave09.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org789311a" class="outline-5">
<h5 id="org789311a">Boundary Conditions</h5>
<div class="outline-text-5" id="text-org789311a">

<div id="org05a3d24" class="figure">
<p><img src="./PhysicalBasedAnimation/games103_10surfacewave10.jpg" alt="games103_10surfacewave10.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org581a28b" class="outline-5">
<h5 id="org581a28b">Two-Way Coupling</h5>
<div class="outline-text-5" id="text-org581a28b">
<p>
流体和刚体的耦合是双向的。流体对刚体有浮力，刚体会占用流体的空间。<br />
</p>

<p>
刚体对流体的影响如下：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave11.jpg" alt="games103_10surfacewave11.jpg" /><br />
</p>

<p>
流体对刚体的浮力影响如下：<br />
<img src="./PhysicalBasedAnimation/games103_10surfacewave11.jpg" alt="games103_10surfacewave11.jpg" /><br />
</p>

<ul class="org-ul">
<li>泊松方程 <a href="https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E6%96%B9%E7%A8%8B</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2f6bc3b" class="outline-3">
<h3 id="org2f6bc3b">Incompressible Fluid Dynamics and Eulerian Fluids</h3>
</div>
<div id="outline-container-orgbf070f5" class="outline-3">
<h3 id="orgbf070f5">SPH and Position-Based Fluids</h3>
</div>
<div id="outline-container-orgab4b43e" class="outline-3">
<h3 id="orgab4b43e">参考资料</h3>
<div class="outline-text-3" id="text-orgab4b43e">
<ul class="org-ul">
<li><a href="http://games-cn.org/games103/">http://games-cn.org/games103/</a><br /></li>
<li>Bilibili 视频主页 <a href="https://www.bilibili.com/video/BV12Q4y1S73g?spm_id_from=444.41.0.0">https://www.bilibili.com/video/BV12Q4y1S73g?spm_id_from=444.41.0.0</a><br /></li>
<li>Physically Based Modeling <a href="https://graphics.pixar.com/pbm2001/">https://graphics.pixar.com/pbm2001/</a><br /></li>
<li>王华民老师主页 <a href="https://web.cse.ohio-state.edu/~wang.3602/index.html">https://web.cse.ohio-state.edu/~wang.3602/index.html</a><br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7c66502" class="outline-2">
<h2 id="org7c66502">基于物理的计算机动画入门作业</h2>
<div class="outline-text-2" id="text-org7c66502">
</div>
<div id="outline-container-org856037e" class="outline-3">
<h3 id="org856037e">homework01</h3>
<div class="outline-text-3" id="text-org856037e">
<p>
作业 1 使用两种方法对刚体进行模拟。<br />
</p>

<p>
Impulse 方法：<br />
</p>
<ul class="org-ul">
<li>根据力计算出速度 (重力、空气阻力)<br /></li>
<li>判断刚体和表面是否产生碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的冲量<br /></li>
<li>依据冲量更新速度<br /></li>
<li>依据冲量更新角速度<br /></li>
</ul></li>
<li>利用速度和角速度更新刚体的位置和旋转<br /></li>
</ul>

<p>
ShapeMatching 方法<br />
</p>
<ul class="org-ul">
<li>对组成刚体的每个顶点单独进行模拟<br />
<ul class="org-ul">
<li>根据力计算出顶点的速度<br /></li>
<li>根据顶点的速度更新顶点的位置<br /></li>
</ul></li>
<li>判断刚体和表面是否产生碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的 Penalty 力<br /></li>
</ul></li>
<li>将变形后的刚体重新变回原来形状<br />
<ul class="org-ul">
<li>计算变形后刚体的中心<br /></li>
<li>计算变形对应的矩阵，并取出其中旋转部分<br /></li>
<li>利用新的中心和旋转矩阵求出刚体新的位置<br /></li>
</ul></li>
</ul>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_rigidbody.mp4" />
</video>

<iframe height=498 width=510 src='https://player.youku.com/embed/XNTg0NDE1ODQxMg==' frameborder=0 'allowfullscreen'></iframe>
</div>

<div id="outline-container-org41df23d" class="outline-4">
<h4 id="org41df23d">ERROR ShapeMatching 模拟中兔子没有旋转效果</h4>
<div class="outline-text-4" id="text-org41df23d">
<p>
一开始以为构建 Shape Matching 矩阵时是以前一次模拟的结果为起点构造的。实际上每次构建 Shape Matching 矩阵都是以一开始的状态为起点。仔细分析一下，就算以前一次模拟为起点构造也没错，但是，对应后续的 QQt.inverse 矩阵也应该以前一次模拟结果为起点进行更新。而以起始状态为起点构建可以省去 QQt 的更新，因此以起始状态为起点构造 Shape Matching 矩阵更高效。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#26041;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">YiMinusC</span> = Y[i] - c;
mat1.m00 += YiMinusC.x * X[i].x;
mat1.m01 += YiMinusC.x * X[i].y;
mat1.m02 += YiMinusC.x * X[i].z;
mat1.m10 += YiMinusC.y * X[i].x;
mat1.m11 += YiMinusC.y * X[i].y;
mat1.m12 += YiMinusC.y * X[i].z;
mat1.m20 += YiMinusC.z * X[i].x;
mat1.m21 += YiMinusC.z * X[i].y;
mat1.m22 += YiMinusC.z * X[i].z;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#26041;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">YiMinusC</span> = Y[i] - c;
mat1.m00 += YiMinusC.x * Q[i].x;
mat1.m01 += YiMinusC.x * Q[i].y;
mat1.m02 += YiMinusC.x * Q[i].z;
mat1.m10 += YiMinusC.y * Q[i].x;
mat1.m11 += YiMinusC.y * Q[i].y;
mat1.m12 += YiMinusC.y * Q[i].z;
mat1.m20 += YiMinusC.z * Q[i].x;
mat1.m21 += YiMinusC.z * Q[i].y;
mat1.m22 += YiMinusC.z * Q[i].z;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc9e125f" class="outline-3">
<h3 id="orgc9e125f">homework02</h3>
<div class="outline-text-3" id="text-orgc9e125f">
<p>
作业 2 使用两种方法对布料进行模拟<br />
</p>

<p>
Implicit 方法:<br />
</p>
<ul class="org-ul">
<li>依据每个顶点的速度对对应顶点的位置进行更新<br /></li>
<li>隐式积分问题等价于函数的优化问题，利用牛顿迭代法求解该优化问题<br />
<ul class="org-ul">
<li>求解每个顶点位置对应的梯度<br /></li>
<li>利用梯度以及 Magic Hessian Matrix 更新顶点位置<br /></li>
</ul></li>
<li>判断布料顶点是否和球体产生碰撞, 使用 Impulse 方法处理碰撞<br />
<ul class="org-ul">
<li>计算碰撞导致的位置变化量<br /></li>
<li>计算碰撞导致的冲量<br /></li>
<li>依据冲量更新速度<br /></li>
</ul></li>
</ul>

<p>
PBD 方法:<br />
</p>
<ul class="org-ul">
<li>质点模拟<br />
<ul class="org-ul">
<li>根据力计算出每个顶点的速度 (重力、空气阻力)<br /></li>
<li>根据速度更新每个顶点的位置<br /></li>
</ul></li>
<li>使用 PBD 方法，进行迭代模拟<br />
<ul class="org-ul">
<li>遍历所有的边，求应用约束后得到的新的顶点位置<br /></li>
<li>遍历所有的顶点，更新顶点位置, 利用老位置和新位置更新顶点速度<br /></li>
</ul></li>
<li><p>
判断布料顶点是否和球体产生碰撞, 使用 Impulse 方法处理碰撞 (和 Implicit 方法一样)<br />
</p>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_cloth.mp4" />
</video>

<iframe height=498 width=510 src='https://player.youku.com/embed/XNTg0NDYyMjE0OA==' frameborder=0 'allowfullscreen'></iframe></li>
</ul>
</div>
</div>

<div id="outline-container-orga7a9263" class="outline-3">
<h3 id="orga7a9263">homework03</h3>
<div class="outline-text-3" id="text-orga7a9263">
<p>
作业 3 使用有限体积方法对弹性体进行模拟<br />
</p>

<p>
F-&gt;G-&gt;P-&gt;ElasticForce:<br />
</p>
<ul class="org-ul">
<li>求形变梯度矩阵 F<br /></li>
<li>求 GreenStrain G （G从 F 中去除了形变后的旋转）<br /></li>
<li>求 Second PK Stress S<br /></li>
<li>求 First PK Stress P<br /></li>
<li>求 四面体各个顶点的弹力<br /></li>
</ul>

<p>
F-&gt;svd(F)-&gt;P-&gt;ElasticForce:<br />
</p>
<ul class="org-ul">
<li>求形变梯度矩阵 F<br /></li>
<li>对 F 进行 svd 分解，得到 svdU svdS svdV ，其中 svdS 的对角就是 Principal Stretches<br /></li>
<li>求 P = U P(svdS) V^T<br /></li>
<li>求四面体各个顶点的弹力<br /></li>
</ul>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_fvm.mp4" />
</video>

<iframe height=498 width=510 src='https://player.youku.com/embed/XNTg0NDYyMDY2NA==' frameborder=0 'allowfullscreen'></iframe>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_fvm-svd.mp4" />
</video>

<iframe height=498 width=510 src='https://player.youku.com/embed/XNTg0NDYyMDY4OA==' frameborder=0 'allowfullscreen'></iframe>

<ul class="org-ul">
<li>拉普拉斯平滑 <a href="https://blog.csdn.net/weixin_43868020/article/details/106602799">https://blog.csdn.net/weixin_43868020/article/details/106602799</a> 有道云笔记有备份<br /></li>
</ul>
</div>
<div id="outline-container-orgd874669" class="outline-4">
<h4 id="orgd874669">ERROR 第一帧模型就炸裂了</h4>
<div class="outline-text-4" id="text-orgd874669">
<p>
去掉 Elastic Force, 模型不炸裂了。因此，计算 Elastic Force 有问题。<br />
第 1 步计算 Deformation Gradient，如果房子还没有变形，F 矩阵应该为单位矩阵。<br />
第 2 步计算 Green Strain，如果房子还没有变形，G矩阵应该为 0 矩阵<br />
第 3 步计算 Second PK Stress，如果房子还没有变形，P矩阵应该为 0 矩阵<br />
第 4 步计算 Elastic Force. 力应该为 0；<br />
</p>

<p>
问题 1：<br />
计算矩阵 G 的 trace 时，将 G.m33 也加进去了。<br />
</p>

<p>
问题 2：<br />
计算速度时，漏掉了 dt。<br />
错误的速度计算： V[i] = V[i] + Force[i] / mass;<br />
正确的速度计算： V[i] = V[i] + dt * Force[i] / mass;<br />
</p>
</div>
</div>
<div id="outline-container-org7862f57" class="outline-4">
<h4 id="org7862f57">ERROR 碰撞后模型炸裂</h4>
<div class="outline-text-4" id="text-org7862f57">
<p>
这是由于 collisionThreshold 不为 0 时，dis 的计算不连续导致的。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#20195;&#30721;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">dis</span> = Vector3.Dot(X[i] - localFloorP, localFloorN);
<span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; collisionThreshold)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; 0) dis = -dis + collisionThreshold;
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">Xnew</span> = X[i] + dis * localFloorN;
    V[i] = V[i] + (Xnew-X[i]) / dt;
}
X[i] = X[i] + V[i] * dt;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#20195;&#30721;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">dis</span> = Vector3.Dot(X[i] - localFloorP, localFloorN);
<span style="color: #4f97d7; font-weight: bold;">if</span> (dis &lt; collisionThreshold)
{
    dis = collisionThreshold - dis;
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">Xnew</span> = X[i] + dis * localFloorN;
    V[i] = V[i] + (Xnew-X[i]) / dt;
}
X[i] = X[i] + V[i] * dt;
</pre>
</div>

<p>
另外，Penalty Force 方法很容易炸，需要调节 rho，并且处理顶点进入平面之下的情况。<br />
</p>
</div>
</div>
<div id="outline-container-orgde35bea" class="outline-4">
<h4 id="orgde35bea">ERROR 使用 homework01 中，Impulse 方法处理碰撞，碰撞后模型缓慢往下陷</h4>
<div class="outline-text-4" id="text-orgde35bea">
<p>
这是因为 Impulse 碰撞处理中的速度没有及时作用到位移导致。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38169;&#35823;&#30340;&#26041;&#24335;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
X[i] = X[i] + V[i] * dt;
<span style="color: #4f97d7; font-weight: bold;">if</span>(collision)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use impulse method update V[i]</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    V[i] = vinew;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#26041;&#24335;</span>
V[i] = V[i] + dt * Force[i] / mass;
V[i] = V[i] * damp;
<span style="color: #4f97d7; font-weight: bold;">if</span>(collision)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use impulse method update V[i]</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    V[i] = vinew;
}
X[i] = X[i] + V[i] * dt;
</pre>
</div>
</div>
</div>
<div id="outline-container-org9eeff20" class="outline-4">
<h4 id="org9eeff20">ERROR svd 版本中，房子会被压扁，然后炸裂</h4>
<div class="outline-text-4" id="text-org9eeff20">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#22914;&#19979;&#26041;&#24335;&#35745;&#31639;lambda0,1,2&#65292;&#20250;&#23548;&#33268;&#21387;&#25153;&#21518;&#28856;&#35010;</span>
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">C</span> = F.transpose * F;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda0</span> = Mathf.Sqrt(C.m00);
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda1</span> = Mathf.Sqrt(C.m11);
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda2</span> = Mathf.Sqrt(C.m22);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#22914;&#19979;&#26041;&#24335;&#35745;&#31639;lambda0,1,2, &#19981;&#20250;&#23548;&#33268;&#35813;&#38382;&#39064;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda0</span> = svdS.m00;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda1</span> = svdS.m11;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda2</span> = svdS.m22;

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda00</span> = lambda0*lambda0;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda11</span> = lambda1*lambda1;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lambda22</span> = lambda2*lambda2;
</pre>
</div>
</div>
</div>
<div id="outline-container-org3ccb200" class="outline-4">
<h4 id="org3ccb200">ERROR svd 版本不开启 LaplacianSmooth 时，开始几秒后炸裂</h4>
<div class="outline-text-4" id="text-org3ccb200">
<p>
需要将 stiffness0 缩小为原来 1/4, 该系数和 王华民老师 2016 年 Descent Methods for Elastic Body Simulation on the GPU 论文对应的 cuda 代码中的系数一致。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org3d8e141" class="outline-3">
<h3 id="org3d8e141">homework04</h3>
<div class="outline-text-3" id="text-org3d8e141">
<p>
作业 4 使用 ShallowWave 模型对水面进行模拟。<br />
</p>

<ul class="org-ul">
<li>离散化水面的高度场<br /></li>
<li>模拟水面<br />
<ul class="org-ul">
<li>使用 ShallowWave 模型更新水面高度场 new_h = h[i,j] + beta*(h[i,j]-old_h[i,j]) + alpha*(h[i-1, j] + h[i+1,j] + h[i,j-1] + h[i,j+1] - 4*h[i,j])<br /></li>
<li>利用虚拟高度模拟 Block 对 Water 的影响<br /></li>
<li>利用浮力模拟 Water 对 Block 的影响<br /></li>
</ul></li>
<li>利用更新后的高度场，更新水面模型的顶点<br /></li>
</ul>

<video class="wp-video-shortcode" width="640" height="360" preload="metadata" controls="controls">
<source type="video/mp4" src="./PhysicalBasedAnimation/games103_shallow_wave.mp4" />
</video>

<iframe height=498 width=510 src='https://player.youku.com/embed/XNTg0NDYyMjIzNg==' frameborder=0 'allowfullscreen'></iframe>
</div>


<div id="outline-container-org869a39e" class="outline-4">
<h4 id="org869a39e">ERROR 立方体会陷入水中越来越深</h4>
<div class="outline-text-4" id="text-org869a39e">
<p>
按照 ppt 浮力 = rho * g * areaA * (h[i,j] - new_h[i,j])，h和 new_h 会越来越接近，浮力会消失。<br />
修改浮力公式如下：<br />
floatingF = rho * g * areaA * (-boxBottomY)<br />
</p>
</div>
</div>
<div id="outline-container-orgec075af" class="outline-4">
<h4 id="orgec075af">ERROR 部分水波会从漂浮的立方体内部穿出来</h4>
<div class="outline-text-4" id="text-orgec075af">
<p>
需要处理立方体整体进入水中的情况。此时 浮力 = rho*g*h(下表面) - rho*g*h(上表面)<br />
</p>
</div>
</div>
<div id="outline-container-org89101c9" class="outline-4">
<h4 id="org89101c9">ERROR 立方体下面水波会反向突出一大块</h4>
<div class="outline-text-4" id="text-org89101c9">
<p>
这是因为求解出来的虚拟高度过大，导致排出的水过多。 适当减小 gamma 参数可以减弱该问题。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3abbd2" class="outline-2">
<h2 id="orgd3abbd2">高级物理引擎实战指南 2020</h2>
<div class="outline-text-2" id="text-orgd3abbd2">
</div>
<div id="outline-container-org243be7e" class="outline-3">
<h3 id="org243be7e">参考资料</h3>
<div class="outline-text-3" id="text-org243be7e">
<ul class="org-ul">
<li>Bilibili 视频主页 <a href="https://www.bilibili.com/video/BV1ZK411H7Hc">https://www.bilibili.com/video/BV1ZK411H7Hc</a><br /></li>
<li>课程主页 <a href="https://yuanming.taichi.graphics/teaching/2020-games201/">https://yuanming.taichi.graphics/teaching/2020-games201/</a><br /></li>
<li>TaiChi 官方文档 <a href="https://taichi.readthedocs.io/zh_CN/latest/">https://taichi.readthedocs.io/zh_CN/latest/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1b1e840" class="outline-2">
<h2 id="org1b1e840">PhysicalBasedAnimation</h2>
<div class="outline-text-2" id="text-org1b1e840">
</div>
<div id="outline-container-org73f7187" class="outline-3">
<h3 id="org73f7187">Harmonic Oscillator 简谐振子</h3>
</div>
<div id="outline-container-orga8447a3" class="outline-3">
<h3 id="orga8447a3">Mechanical Energy 机械能</h3>
</div>
<div id="outline-container-org8b846a1" class="outline-3">
<h3 id="org8b846a1">Conservation Laws 守恒定律</h3>
</div>
<div id="outline-container-org2d7a843" class="outline-3">
<h3 id="org2d7a843">Symplecticity</h3>
</div>
<div id="outline-container-orged63103" class="outline-3">
<h3 id="orged63103">Numerical Integration</h3>
</div>
<div id="outline-container-org990e476" class="outline-3">
<h3 id="org990e476">Integrator Properties</h3>
</div>
<div id="outline-container-org8fae8e5" class="outline-3">
<h3 id="org8fae8e5">Solving Implicit Integrators</h3>
</div>
<div id="outline-container-org3b4613c" class="outline-3">
<h3 id="org3b4613c">Optimization</h3>
</div>
<div id="outline-container-org1d4b5b6" class="outline-3">
<h3 id="org1d4b5b6">Newtons Method</h3>
</div>
<div id="outline-container-orgdb1521d" class="outline-3">
<h3 id="orgdb1521d">Nonconvexity</h3>
</div>
<div id="outline-container-org2a1f0ae" class="outline-3">
<h3 id="org2a1f0ae">Direct Solvers</h3>
</div>
<div id="outline-container-org4c42129" class="outline-3">
<h3 id="org4c42129">Iterative Methods</h3>
</div>
<div id="outline-container-orgff0778f" class="outline-3">
<h3 id="orgff0778f">Finite Elements</h3>
</div>
<div id="outline-container-org0ff345a" class="outline-3">
<h3 id="org0ff345a">FE Potential</h3>
</div>
<div id="outline-container-org28d458b" class="outline-3">
<h3 id="org28d458b">Final FEM notes and Wrap up</h3>
</div>
<div id="outline-container-orgcb58540" class="outline-3">
<h3 id="orgcb58540">Constraints</h3>
</div>
<div id="outline-container-org51e4294" class="outline-3">
<h3 id="org51e4294">参考资料</h3>
<div class="outline-text-3" id="text-org51e4294">
<ul class="org-ul">
<li>YouTube 视频 <a href="https://www.youtube.com/watch?v=sSKyQIxdhdA&amp;list=PL_a9tY9IhJuPc7e6r-3DMw_PbYbloKoWM">https://www.youtube.com/watch?v=sSKyQIxdhdA&amp;list=PL_a9tY9IhJuPc7e6r-3DMw_PbYbloKoWM</a><br /></li>
<li>课程主页 <a href="https://my.eng.utah.edu/~cs6660/">https://my.eng.utah.edu/~cs6660/</a><br /></li>
<li>教师主页 <a href="https://www.cs.utah.edu/~ladislav/">https://www.cs.utah.edu/~ladislav/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'PhysicalBasedAnimation',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>