<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-12 Sat 13:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Doom3 Engine</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Doom3 Engine</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2fb24e9">Doom3</a>
<ul>
<li><a href="#org23a30ea">Introduction</a>
<ul>
<li><a href="#org1304ff5">Architecture</a></li>
<li><a href="#org0e16ee7">Main Loop</a></li>
<li><a href="#org5f6ea34">Doom3 sdk documents</a>
<ul>
<li><a href="#org819d1ff">IDLib</a></li>
<li><a href="#org09e6d4c">Game System</a>
<ul>
<li><a href="#org22c3197">GameSys</a></li>
<li><a href="#org2492514">AI</a></li>
<li><a href="#org2fa03f9">Physics</a></li>
<li><a href="#orga2451c4">Anim</a></li>
<li><a href="#org10b210f">Script</a></li>
</ul>
</li>
<li><a href="#org2efcb4f">Game Utility Files</a>
<ul>
<li><a href="#orgf1372eb">Network</a></li>
<li><a href="#orgd490898">Game/GameLocal</a></li>
<li><a href="#orgebfa9d9">Pvs</a></li>
<li><a href="#org4d1108d">AF</a></li>
<li><a href="#orge2bfc06">IK</a></li>
<li><a href="#org275df2a">PlayerIcon</a></li>
<li><a href="#org09baa47">PlayerView</a></li>
<li><a href="#org20fe45b">SmokeParticles</a></li>
<li><a href="#org9cb9dbb">GameEdit</a></li>
</ul>
</li>
<li><a href="#org89993aa">Game Entities</a>
<ul>
<li><a href="#org9ba90fa">Entity</a></li>
<li><a href="#org188ec06">WorldSpawn</a></li>
<li><a href="#orge0b6d78">Camera</a></li>
<li><a href="#orga5b6236">SecurityCamera</a></li>
<li><a href="#org027ad69">BrittleFracture</a></li>
<li><a href="#org1db0eb4">Fx</a></li>
<li><a href="#orgd5e675a">Light</a></li>
<li><a href="#org7a46671">Sound</a></li>
<li><a href="#orgc9c7869">Item</a></li>
<li><a href="#org009c1a3">Moveable</a></li>
<li><a href="#org3079d7e">Trigger</a></li>
<li><a href="#org75c5034">Target</a></li>
<li><a href="#orgf23a79e">Misc</a></li>
<li><a href="#org9a325c8">AFEntity</a></li>
<li><a href="#org3766f9b">Actor</a></li>
<li><a href="#org3f710ac">Player</a></li>
<li><a href="#org4c265b0">Projectile</a></li>
<li><a href="#org3d554d5">Weapon</a></li>
</ul>
</li>
<li><a href="#orgb87d276">The Engine Code</a>
<ul>
<li><a href="#orgecb95a6">System</a></li>
<li><a href="#orge44bea2">Common</a></li>
<li><a href="#org94a585a">Command System</a></li>
<li><a href="#org3e5021f">CVar System</a></li>
<li><a href="#org2f80aed">File System</a></li>
<li><a href="#org62a4581">Networking System</a></li>
<li><a href="#orgcc5b990">Render System</a></li>
<li><a href="#org290e9f1">Sound System</a></li>
<li><a href="#org6ffca88">Render Model Manager</a></li>
<li><a href="#org8db620f">User Interface Manager</a></li>
<li><a href="#org170d5a3">Declaration Manager</a></li>
<li><a href="#org8456009">AAS file Manager</a></li>
<li><a href="#org15c77c4">Collision Model Manager</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga6e050e">DMap</a>
<ul>
<li><a href="#orgf001518">The editor</a></li>
<li><a href="#org42cb526">Code overview</a></li>
<li><a href="#orgdd239ff">0. Loading the level geometry</a></li>
<li><a href="#org15ccffd">1. MakeStructuralBspFaceList &amp; FaceBSP</a></li>
<li><a href="#org5768b19">2. MakeTreePortals</a></li>
<li><a href="#orgfc7e073">3. FilterBrushesIntoTree</a></li>
<li><a href="#org623dfba">4. FloodEntities &amp; FillOutside</a></li>
<li><a href="#orgc3ea429">5. ClipSidesByTree</a></li>
<li><a href="#org45dcffd">6. FloodAreas</a></li>
<li><a href="#org292f7f1">7. PutPrimitivesInAreas</a></li>
<li><a href="#org7079410">8. Prelight</a></li>
<li><a href="#orgd7bfa7e">9. FixGlobalTjunctions</a></li>
<li><a href="#org59a3d57">10. Write output</a></li>
</ul>
</li>
<li><a href="#org2411704">Renderer</a>
<ul>
<li><a href="#org429de74">Architecture</a></li>
<li><a href="#org632c2f6">Frontend/Backend/GPU collaboration</a></li>
<li><a href="#orgda4271e">Doom3 Renderer Frontend</a></li>
<li><a href="#org8c7e272">Doom3 Renderer Backend</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3a8e44d">Doom3BFG</a>
<ul>
<li><a href="#orge68f0bb">Introduction</a>
<ul>
<li><a href="#org9bad7eb">Architecture</a></li>
</ul>
</li>
<li><a href="#orgbb52c3f">Threading</a>
<ul>
<li><a href="#orga455012">Doom 3 BFG Threading Model</a></li>
<li><a href="#org1642d91">Core idea</a></li>
<li><a href="#org228aeba">Building blocks</a>
<ul>
<li><a href="#orgb7b63ee">Jobs</a></li>
<li><a href="#org7c50542">Workers</a></li>
<li><a href="#org71a062c">Synchronization</a>
<ul>
<li><a href="#orgc9785ba">Monitors (idSysSignal)</a></li>
<li><a href="#org9820868">Mutexes (idSysMutex)</a></li>
<li><a href="#org7118ada">Atomic operations (idSysInterlockedInteger)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9146f14">Architecture</a></li>
<li><a href="#org9ad1e51">Usage</a></li>
<li><a href="#org537b5f3">How a Worker works</a>
<ul>
<li><a href="#orgc22528f">The infinite loop</a></li>
<li><a href="#orgc821241">Where jobs are run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org50cc57d">Rendering</a>
<ul>
<li><a href="#org9940b5e">Architecture</a>
<ul>
<li><a href="#org600771f">为什么需要多线程渲染？</a></li>
<li><a href="#org25c0ff2">Frontend 和 Backend 工作流程</a></li>
<li><a href="#orge1ee246">Render Frontend 和 Backend 的同步</a></li>
<li><a href="#orgf7048a2">CPU 和 GPU 如何同步？</a></li>
<li><a href="#org6968cac">CPU 和 GPU 数据传输</a></li>
<li><a href="#org948e9ff">GPU 和 显示器同步</a></li>
<li><a href="#org14d7910">shader</a></li>
</ul>
</li>
<li><a href="#org2b7f1c2">Threading Model</a></li>
<li><a href="#org6f16431">One Path</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4757e8e">参考资料</a></li>
</ul>
</div>
</div>
<p>
Doom3 Engine note.<br />
</p>
<div class="HTML" id="org6b6b88d">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org2fb24e9" class="outline-2">
<h2 id="org2fb24e9">Doom3</h2>
<div class="outline-text-2" id="text-org2fb24e9">
</div>
<div id="outline-container-org23a30ea" class="outline-3">
<h3 id="org23a30ea">Introduction</h3>
<div class="outline-text-3" id="text-org23a30ea">
</div>
<div id="outline-container-org1304ff5" class="outline-4">
<h4 id="org1304ff5">Architecture</h4>
<div class="outline-text-4" id="text-org1304ff5">
<p>
Solution structure 如下:<br />
</p>

<!-- This HTML table template is generated by emacs 28.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;Projects&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Observations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Windows&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;MacO&nbsp;SX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;Game&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;gamex86.dll&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;gamex86.so&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Doom3&nbsp;gameplay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;Game-d3xp&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;gamex86.dll&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;gamex86.so&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Doom3&nbsp;eXPension(Ressurecton)&nbsp;gameplay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;Doom3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Doom3.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Doom3.app&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Doom&nbsp;3&nbsp;Engine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;MayaImport&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;MayaImport.dll&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;部分资源创作工具链：在运行时加载该&nbsp;dll，为了打开&nbsp;Maya&nbsp;文件并导入&nbsp;monsters,&nbsp;camera&nbsp;路径以及地图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;TypeInfo&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;TypeInfo.exe&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;内部的运行时类型识别（RTTI）helper:&nbsp;生成&nbsp;GameTypeInfo.h,&nbsp;其为&nbsp;Doom3&nbsp;中所有类型和每个成员内存大小的字典。通过&nbsp;TypeInfo&nbsp;类可以进行内存调试&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;CurlLib&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;CurlLib.lib&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;HTTP&nbsp;客户端，用于下载文件。静态连接到&nbsp;gamex86.dll&nbsp;和&nbsp;doom3.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;idLib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;idLib.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;idLib.a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;id&nbsp;software&nbsp;库。包含&nbsp;parser,lexer,dictionary&nbsp;等。静态连接到&nbsp;gamex86.dll&nbsp;和&nbsp;doom3.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
架构图如下：<br />
<img src="./doom3/doom3_diagram2.png" alt="doom3_diagram2.png" /><br />
</p>

<p>
当 Doom3.exe 启动以后，其会执行如下三个操作：<br />
</p>
<ol class="org-ol">
<li>通过 LoadLibrary 加载 gamex86.dll 到其进程的内存空间中<br /></li>
<li>使用 win32 API GetProcAddress 来获得 dll 中 GetGameAPI 的地址<br /></li>
<li>调用 GetGameAPI，将 Doom3 中的 system 注册到 game.dll 中，并将 game 、gameEdit 对象通过 gameExport_t 返回给 Doom3<br /></li>
</ol>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GetGameAPI &#30340;&#23454;&#29616;&#22312;game.dll  Game_local.cpp &#25991;&#20214;&#20013;</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #2d9574;">"C"</span> <span style="color: #ce537a; font-weight: bold;">gameExport_t</span> *<span style="color: #bc6ec5; font-weight: bold;">GetGameAPI</span>( <span style="color: #ce537a; font-weight: bold;">gameImport_t</span> *<span style="color: #7590db;">import</span> )
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( import-&gt;version == GAME_API_VERSION )
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set interface pointers used by the game</span>
        sys                         = import-&gt;sys;
        common                      = import-&gt;common;
        cmdSystem                   = import-&gt;cmdSystem;
        cvarSystem                  = import-&gt;cvarSystem;
        fileSystem                  = import-&gt;fileSystem;
        networkSystem               = import-&gt;networkSystem;
        renderSystem                = import-&gt;renderSystem;
        soundSystem                 = import-&gt;soundSystem;
        renderModelManager          = import-&gt;renderModelManager;
        uiManager                   = import-&gt;uiManager;
        declManager                 = import-&gt;declManager;
        AASFileManager              = import-&gt;AASFileManager;
        collisionModelManager       = import-&gt;collisionModelManager;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set interface pointers used by idLib</span>
    <span style="color: #a45bad;">idLib</span>::sys                  = sys;
    <span style="color: #a45bad;">idLib</span>::common               = common;
    <span style="color: #a45bad;">idLib</span>::cvarSystem           = cvarSystem;
    <span style="color: #a45bad;">idLib</span>::fileSystem           = fileSystem;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">setup export interface</span>
    gameExport.version = GAME_API_VERSION;
    gameExport.game = game;
    gameExport.gameEdit = gameEdit;

    <span style="color: #4f97d7; font-weight: bold;">return</span> &amp;gameExport;
}
</pre>
</div>

<p>
最后，Doom3.exe 会有一个指向 idGame 对象的指针，game.dll 会有一个指向 gameImport_t 对象的指针，gameImport_t 对象中包含了所有缺失的子系统的引用(如：idFileSystem)<br />
</p>

<p>
gamex86 中所看到的 Doom3.exe 为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">struct</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span>                         <span style="color: #7590db;">version</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">API version</span>
    <span style="color: #ce537a; font-weight: bold;">idSys</span> *                     <span style="color: #7590db;">sys</span>;                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">non-portable system services</span>
    <span style="color: #ce537a; font-weight: bold;">idCommon</span> *                  <span style="color: #7590db;">common</span>;                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">common</span>
    idCmdSystem *               cmdSystem              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">console command system</span>
    idCVarSystem *              cvarSystem;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">console variable system</span>
    <span style="color: #ce537a; font-weight: bold;">idFileSystem</span> *              <span style="color: #7590db;">fileSystem</span>;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">file system</span>
    <span style="color: #ce537a; font-weight: bold;">idNetworkSystem</span> *           <span style="color: #7590db;">networkSystem</span>;         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">network system</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderSystem</span> *            <span style="color: #7590db;">renderSystem</span>;          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render system</span>
    <span style="color: #ce537a; font-weight: bold;">idSoundSystem</span> *             <span style="color: #7590db;">soundSystem</span>;           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sound system</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderModelManager</span> *      <span style="color: #7590db;">renderModelManager</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render model manager</span>
    <span style="color: #ce537a; font-weight: bold;">idUserInterfaceManager</span> *    <span style="color: #7590db;">uiManager</span>;             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">user interface manager</span>
    <span style="color: #ce537a; font-weight: bold;">idDeclManager</span> *             <span style="color: #7590db;">declManager</span>;           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">declaration manager</span>
    <span style="color: #ce537a; font-weight: bold;">idAASFileManager</span> *          <span style="color: #7590db;">AASFileManager</span>;        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">AAS file manager</span>
    <span style="color: #ce537a; font-weight: bold;">idCollisionModelManager</span> *   <span style="color: #7590db;">collisionModelManager</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">collision model manager</span>
} <span style="color: #ce537a; font-weight: bold;">gameImport_t</span>;
</pre>
</div>

<p>
Doom3 中所看到的 gamex86 为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">struct</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span>            <span style="color: #7590db;">version</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">API version</span>
    <span style="color: #ce537a; font-weight: bold;">idGame</span> *       <span style="color: #7590db;">game</span>;        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">interface to run the game</span>
    <span style="color: #ce537a; font-weight: bold;">idGameEdit</span> *   <span style="color: #7590db;">gameEdit</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">interface for in-game editing</span>
} <span style="color: #ce537a; font-weight: bold;">gameExport_t</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e16ee7" class="outline-4">
<h4 id="org0e16ee7">Main Loop</h4>
<div class="outline-text-4" id="text-org0e16ee7">
<p>
下面是展开的主循环代码, 其中只包含了引擎相关的重要的部分：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#22312; Doom.exe win_main.cpp &#25991;&#20214;&#20013;</span>
<span style="color: #ce537a; font-weight: bold;">idCommonLocal</span>    <span style="color: #7590db;">commonLocal</span>;                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OS Specialized object</span>
<span style="color: #ce537a; font-weight: bold;">idCommon</span> *       <span style="color: #7590db;">common</span> = &amp;commonLocal;         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interface pointer (since Init is OS dependent it is an abstract method</span>

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">WINAPI</span> WinMain( <span style="color: #ce537a; font-weight: bold;">HINSTANCE</span> <span style="color: #7590db;">hInstance</span>, <span style="color: #ce537a; font-weight: bold;">HINSTANCE</span> <span style="color: #7590db;">hPrevInstance</span>, <span style="color: #ce537a; font-weight: bold;">LPSTR</span> <span style="color: #7590db;">lpCmdLine</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nCmdShow</span> )
{
    Sys_SetPhysicalWorkMemory( 192 &lt;&lt; 20, 1024 &lt;&lt; 20 );   <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Min = 201,326,592  Max = 1,073,741,824</span>
    Sys_CreateConsole();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Since the engine is multi-threaded mutexes are initialized here: One mutex per "critical" (concurrent execution) section of code.</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; MAX_CRITICAL_SECTIONS; i++ ) {
        InitializeCriticalSection( &amp;win32.criticalSections[i] );
    }

    common-&gt;Init( 0, <span style="color: #a45bad;">NULL</span>, lpCmdLine );              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Assess how much VRAM is available (not done via OpenGL but OS call)</span>

    Sys_StartAsyncThread(){                          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">The next look runs is a separate thread.</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span> ( 1 ){
            usleep( 16666 );                         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Run at 60Hz</span>
            common-&gt;Async();                         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Do the job</span>
            Sys_TriggerEvent( TRIGGER_EVENT_ONE );   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Unlock other thread waiting for inputs</span>
            pthread_testcancel();                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Check if we have been cancelled by the main thread (on shutdown).</span>
        }
    }

    Sys_ShowConsole(1, <span style="color: #a45bad;">true</span>);                        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Show or hide the console</span>

    <span style="color: #4f97d7; font-weight: bold;">while</span>( 1 ) {
        Win_Frame();
        common-&gt;Frame(){
            session-&gt;Frame()                         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Game logic</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0 ; i &lt; gameTicsToRun ; i++ )
                    RunGameTic(){
                        game-&gt;RunFrame( &amp;cmd );      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">From this point execution jumps in the GameX86.dll address space.</span>
                        <span style="color: #4f97d7; font-weight: bold;">for</span>( ent = activeEntities.Next(); ent != <span style="color: #a45bad;">NULL</span>; ent = ent-&gt;activeNode.Next() )
                            ent-&gt;GetPhysics()-&gt;UpdateTime( time );  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">let entities think</span>
                    }
            }

            session-&gt;UpdateScreen( <span style="color: #a45bad;">false</span> );      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal, in-sequence screen update</span>
            {
                renderSystem-&gt;BeginFrame();
                {
                    <span style="color: #a45bad;">idGame</span>::Draw();              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Renderer front-end. Doesn't actually communicate with the GPU !!</span>
                }
                renderSystem-&gt;EndFrame();
                {
                    R_IssueRenderCommands();     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Renderer back-end. Issue GPU optimized commands to the GPU.</span>
                }
            }
        }
    }
}
</pre>
</div>
<p>
完整的主循环展开如下：<br />
<a href="./doom3/doom3_unrolled.txt">doom3_unrolled.txt</a><br />
</p>

<ul class="org-ul">
<li><a href="https://fabiensanglard.net/doom3/doom3_unrolled.php">https://fabiensanglard.net/doom3/doom3_unrolled.php</a><br /></li>
</ul>

<p>
从 Sys_StartAsyncThread 函数可以看出，Doom3 是基于多线程的。该线程的目的是为了处理时间敏感的函数，为了不让这些函数的调用频率受到帧率限制。<br />
</p>

<p>
冷知识：<br />
</p>
<ol class="org-ol">
<li><p>
idTech4 高层对象都属于包含虚函数的抽象类。这通常会影响性能，因为每个虚函数调用都会导致虚函数表的查询。如下面代码所示，所有对象都进行静态实例化，可以避免这样的性能消耗。因为对象是静态分配到数据段的，其类型是已知的，编译器可以将虚表查询优化掉。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">   <span style="color: #ce537a; font-weight: bold;">idCommonLocal</span>    <span style="color: #7590db;">commonLocal</span>;                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Implementation</span>
   <span style="color: #ce537a; font-weight: bold;">idCommon</span> *       <span style="color: #7590db;">common</span> = &amp;commonLocal;         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pointer for gamex86.dll</span>
</pre>
</div>
<p>
但是，在 handshake 阶段会使用接口指针，doom3.exe 可以和 gamex86.dll 交换对象引用, 此时虚表查询的消耗是无法被优化掉。<br />
</p></li>
<li>很多代码从 idTech1 开始就一直没有变过。如用于获取鼠标和摇杆输入的函数依然叫 IN_frame(). （IN 表示 input）<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org5f6ea34" class="outline-4">
<h4 id="org5f6ea34">Doom3 sdk documents</h4>
<div class="outline-text-4" id="text-org5f6ea34">
<p>
该部分来自 <a href="https://github.com/dhewm/iddevnet/blob/main/doom3/code.html">https://github.com/dhewm/iddevnet/blob/main/doom3/code.html</a><br />
</p>
</div>
<div id="outline-container-org819d1ff" class="outline-5">
<h5 id="org819d1ff">IDLib</h5>
<div class="outline-text-5" id="text-org819d1ff">
<p>
idLib 是一个通用的代码库。其包含了字符串代码、解析器、几个哈希表、数学库、计时器、容器等。它也是存储所有 SSE 代码的地方，如果你对此感兴趣，可以查看名称为 idLib/Math/Simd_*.* 的文件。<br />
</p>
</div>
</div>
<div id="outline-container-org09e6d4c" class="outline-5">
<h5 id="org09e6d4c">Game System</h5>
<div class="outline-text-5" id="text-org09e6d4c">
<p>
游戏代码中有很多部分与 Doom 3 没有任何关系，而是构建游戏代码的基础部分。<br />
</p>
</div>
<div id="outline-container-org22c3197" class="outline-6">
<h6 id="org22c3197">GameSys</h6>
<div class="outline-text-6" id="text-org22c3197">
<p>
GameSys 是游戏代码的核心。 其包含基本的 idClass 类，以及事件系统和保存游戏系统。 GameSys 非常的抽象，对建立在它之上的实际游戏一无所知。 它所知道的只是创建对象、触发事件并遍历对象以进行保存和恢复。<br />
</p>

<p>
当你在 entitydef 中指定 spawnclass 时，他会调用 idClass::CreateInstance 来创建该 spawn 类的实例。 使用 Class.h 中定义的 CLASS_DECLARATION 宏可以用 idClass 来注册一个类。<br />
</p>
</div>
</div>
<div id="outline-container-org2492514" class="outline-6">
<h6 id="org2492514">AI</h6>
<div class="outline-text-6" id="text-org2492514">
<p>
AI 文件夹实际上并不包含怪物的 AI（它们在脚本中定义）。相反，C++ AI 代码是将脚本与游戏其余部分联系起来的“粘合剂”。它包含利用 AAS（Area Awareness System 区域感知系统）进行路由和寻路，以及事件处理。核心对象是 idAI，它派生自 idActor-&gt;idAFEntity_Gibbable-&gt;idAFEntity_Base-&gt;idAnimatedEntity-&gt;idEntity-&gt;idClass。<br />
</p>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>AF 是关节体型的缩写(articulated figure)<br /></li>
<li>Gibbable 表示可破碎，Gibbable Bodies 可破碎尸体 <a href="https://www.youtube.com/watch?v=hjrv2sPI020">https://www.youtube.com/watch?v=hjrv2sPI020</a><br /></li>
</ul>

<p>
在 Doom 3 中，路由是“我如何从地图的一个区域到达另一个区域”，而寻路是“我如何绕过那把椅子”。差异是微妙的但很重要。<br />
</p>

<p>
AI 是与正在制作的实际游戏最密切相关的游戏系统。一个示例是 idAI_Vagary，其中包含 Vagary 用于拾取和向玩家投掷物体的特殊代码。<br />
</p>

<p>
AI_events.cpp 包含处理 AI 脚本中事件的所有代码。大多数函数只是调用 AI.cpp 中的实现。一个例子是 Event_KickObstacles，它只是修正了参数并调用 AI.cpp 中的 KickObstacles()。<br />
</p>
</div>
</div>
<div id="outline-container-org2fa03f9" class="outline-6">
<h6 id="org2fa03f9">Physics</h6>
<div class="outline-text-6" id="text-org2fa03f9">
<p>
Doom 3 游戏代码随整个 Doom 3 物理系统一起提供。核心引擎本身绝对没有物理代码。甚至 LCP 求解器也在 idLib 中。物理代码非常庞大，但幸运的是，您不必拥有物理学博士学位即可了解其中大部分内容以及如何使用它。<br />
</p>

<p>
idPhysics 对象是一种操纵实体位置和方向的工具。物理对象是用于碰撞检测的 idClipModels 的容器。物理系统根据物理定律或其他规则处理这些碰撞模型在世界中的移动。<br />
</p>

<p>
每个 idEntity 都有一个指向 idPhysics 对象的指针，可以使用 idForces 移动该对象，尽管还有其他方法可以移动它。 idEntity 每一帧都会根据物理系统中的原点和轴信息更新自己的视觉模型。<br />
</p>

<p>
渲染系统有每个实体的视觉模型，物理系统有每个实体的裁剪模型（有时称为战斗模型）。碰撞模型可以从地图模型加载（使用标记为 clip 的任何 surfaces），也可以从渲染模型生成（默认情况下它使用渲染模型中的所有表面，但可以使用“ textures/common/collision”材质，在这种情况下，它使用简化模型代替），或者也可以从 .cm 文件加载（使用 DOOMEdit 创建）。<br />
</p>

<p>
idPhysics 有多个子类，它们都实现了专门的物理类型。例如，门使用 idPhysics_Parametric，布娃娃使用 idPhysics_AF 等。大多数物理类型都是不言自明的，所有这些类型的 .h 文件顶部都有简要说明。<br />
</p>

<p>
如果不希望在对象上运行物理，请确保清除 TH_PHYSICS 标志（例如，当对象停止时）。如果不希望对象被触摸，则应取消链接剪辑模型（而不仅仅是将内容掩码设置为 0）。这样做可以加速碰撞检测，因为它甚至不会访问该剪辑模型。你应该确保没有小的抖动，其可能会导致物理会在一个物体上不断运行。有一些控制台命令可以帮助调试物理减速。最有用的可能是 g_showActiveEntities。<br />
</p>
</div>
</div>
<div id="outline-container-orga2451c4" class="outline-6">
<h6 id="orga2451c4">Anim</h6>
<div class="outline-text-6" id="text-orga2451c4">
<p>
动画系统不决定播放哪些动画（在脚本中完成），而是负责混合动画、帧之间的 lerping、混合骨骼权重和调用帧命令。<br />
</p>

<p>
在 Doom 3 中，有 4 个不同的动画通道（“躯干”、“腿”、“头”、“眼睑”）以及第五个伪通道（“全部”）。不同的动画可以同时在每个动画通道上播放。这避免了 quake 2 的“射击时跑”问题，以及 quake 3 的“模型成为碎片”问题。只有一个网格，但每个动画都会影响一组不同的骨骼。所有这些都在 Anim_Blend 中处理。它还处理两个完全不同的动画之间的混合（例如，当你在武器之间切换时）。<br />
</p>

<p>
帧命令（在 modelDef 中定义）是在 ServiceAnims 中被调用的。每次更新动画时，它都会查看是否通过了定义帧命令的“边界”。添加自己的帧命令实际上也非常容易。你只需将一个项目添加到 frameCommandType_t 枚举类型中，然后在 AddFrameCommand 和 CallFrameCommands 中为它实现对应逻辑即可。<br />
</p>
</div>
</div>
<div id="outline-container-org10b210f" class="outline-6">
<h6 id="org10b210f">Script</h6>
<div class="outline-text-6" id="text-org10b210f">
<p>
与 Anim 类似，Script 子系统非常通用，对具体游戏完全不可知。脚本系统的 main 入口点在 idProgram。系统中只有一个 idProgram（它是 idGameLocal 的成员）。它扫描脚本目录并编译其中包含的所有脚本。它持有了所有函数和变量信息。idProgram 是唯一使用 idCompiler 的类。 idCompiler 是操作码生成器。它使用了 idLib 中定义的词法分析器和解析器。<br />
</p>

<p>
要实际调用脚本函数，需要创建一个新的 idThread（应该用 new 分配，而不是在堆栈上创建）。 idThread 中有一些静态函数来处理当前活动线程的跟踪。每个线程都有一个 idInterpreter，其中包含一个线程的所有堆栈信息和指令指针。这些游戏线程不是实际的操作系统线程。这种方式使得脚本系统为每个线程在每一帧都提供了运行机会。线程会一直运行，直到它获得一个多帧事件或遇到一个暂停事件，例如 sys.pause、sys.waitFor 或 sys.wait（还有一个对 ai 对象的等待命令）。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2efcb4f" class="outline-5">
<h5 id="org2efcb4f">Game Utility Files</h5>
<div class="outline-text-5" id="text-org2efcb4f">
</div>
<div id="outline-container-orgf1372eb" class="outline-6">
<h6 id="orgf1372eb">Network</h6>
<div class="outline-text-6" id="text-orgf1372eb">
<p>
原始网络代码仍在引擎内部，但 Doom 3 暴露了许多以前的 id 引擎没有的网络部分。 在 Doom 3 中，你可以自定义位消息，以包含你想要的任何内容，这些消息可以通过网络发送到你想要的任何客户端。 这显然是一个非常强大的工具。 大部分代码在 Game_network.cpp 中，但网络代码分布在几乎所有游戏文件中。 两个最重要的函数是 WriteToSnapshot 和 ReadFromSnapshot。 这两个函数处理实体的定期更新。 所有客户端实际上都在运行与服务器完全相同的游戏代码，因此理论上它们永远不会不同步，但众所周知，它们确实会不同步。 快照机制将定期将客户端快照恢复到服务器同步。 还有其他发送更新的方法，例如客户端事件和可靠消息，很容易就可以确定你是否需要使用它们。<br />
</p>
</div>
</div>
<div id="outline-container-orgd490898" class="outline-6">
<h6 id="orgd490898">Game/GameLocal</h6>
<div class="outline-text-6" id="text-orgd490898">
<p>
idGame 是整个 game.dll 的接口类。 这是核心引擎唯一看到的东西。 引擎加载 game.dll 时做的第一件事是调用 GetGameAPI，将接口指针传递给一堆内部系统类。 该函数将系统类指针复制到 dll 中的全局指针，然后返回一个指向 idGameLocal 对象（被强制转换为 idGame）的指针。 idGameLocal 是 game 接口的实际实现。 由于 gameLocal 是 game.dll 中的全局对象，因此许多真正随机的函数最终被扔在那里。 真正重要的函数也在 idGame 中定义（例如 InitFromNewMap、RunFrame 和 Draw）。<br />
</p>

<p>
MultiplayerGame 定义了所有多人特定的游戏代码，例如记分和投票。<br />
</p>
</div>
</div>
<div id="outline-container-orgebfa9d9" class="outline-6">
<h6 id="orgebfa9d9">Pvs</h6>
<div class="outline-text-6" id="text-orgebfa9d9">
<p>
PVS（Potentially Visible Set 潜在可见集）跟踪从哪些区域可以看到其他哪些区域。在加载地图时计算 PVS。 它允许游戏代码确定对象或怪物是否应该进入休眠状态，网络代码也使用它来确定将哪些更新发送给哪些客户端。<br />
</p>
</div>
</div>
<div id="outline-container-org4d1108d" class="outline-6">
<h6 id="org4d1108d">AF</h6>
<div class="outline-text-6" id="text-org4d1108d">
<p>
idAF 是一个关节体型(articulated figure)的 辅助类。它包含一个指向 animator 的指针，animator 用于对象做动画。 它不进行任何求解（全部在 idPhysics_AF 中完成），而是将求解的 AF 位置应用于实体模型（请记住，物理模型是与渲染系统完全分离的系统）。<br />
</p>
</div>
</div>
<div id="outline-container-orge2bfc06" class="outline-6">
<h6 id="orge2bfc06">IK</h6>
<div class="outline-text-6" id="text-orge2bfc06">
<p>
idIK 是逆运动学辅助类。 它目前只被 actors 用来保持脚在地面上，但它可以很容易地用于更多用途。 它的使用与 idAF 类似。<br />
</p>
</div>
</div>
<div id="outline-container-org275df2a" class="outline-6">
<h6 id="org275df2a">PlayerIcon</h6>
<div class="outline-text-6" id="text-org275df2a">
<p>
idPlayerIcon 是一个辅助类，用于在多人游戏中在玩家头部上方绘制延迟和聊天图标。<br />
</p>
</div>
</div>
<div id="outline-container-org09baa47" class="outline-6">
<h6 id="org09baa47">PlayerView</h6>
<div class="outline-text-6" id="text-org09baa47">
<p>
idPlayerView 是一个辅助工具，可以从玩家的角度呈现场景。 它是绘制 PDA 的地方，也是处理最后一分钟效果的地方，例如屏幕血溅、狂暴、影响和双重视觉视图，以及屏幕渐变。<br />
</p>
</div>
</div>
<div id="outline-container-org20fe45b" class="outline-6">
<h6 id="org20fe45b">SmokeParticles</h6>
<div class="outline-text-6" id="text-org20fe45b">
<p>
烟雾粒子系统用于以完全非参数方式不断改变位置或方向的粒子效果。<br />
</p>
</div>
</div>
<div id="outline-container-org9cb9dbb" class="outline-6">
<h6 id="org9cb9dbb">GameEdit</h6>
<div class="outline-text-6" id="text-org9cb9dbb">
<p>
idGameEdit 是一个实用程序类，允许编辑器（如 AFEditor）在游戏运行时操作实体。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org89993aa" class="outline-5">
<h5 id="org89993aa">Game Entities</h5>
<div class="outline-text-5" id="text-org89993aa">
<p>
现在我已经了解了游戏构建的主要系统，我可以开始讨论实际的游戏代码了。 我要讲的其余代码几乎都是从 idEntity 派生的。 如门、怪物、玩家、物品、火车、触发器、灯光等待许多其他东西。 我认为最简单的方法是逐个讨论每个文件。<br />
</p>
</div>
<div id="outline-container-org9ba90fa" class="outline-6">
<h6 id="org9ba90fa">Entity</h6>
<div class="outline-text-6" id="text-org9ba90fa">
<p>
idEntity 是派生所有实体的基类。 它处理所有实体共有的大多数“低级”维护功能，例如生成、思考、运行物理、绑定、播放声音、显示、隐藏等。<br />
</p>

<p>
Entity.cpp 还包含 idAnimatedEntity，它只是一个关联了 animator（可以播放动画）的实体。<br />
</p>
</div>
</div>
<div id="outline-container-org188ec06" class="outline-6">
<h6 id="org188ec06">WorldSpawn</h6>
<div class="outline-text-6" id="text-org188ec06">
<p>
worldspawn 是一个代表整个关卡本身的实体。其负责从地图中读取一些属性来设置重力和耐力，并调用关卡脚本。<br />
</p>
</div>
</div>
<div id="outline-container-orge0b6d78" class="outline-6">
<h6 id="orge0b6d78">Camera</h6>
<div class="outline-text-6" id="text-orge0b6d78">
<p>
idCamera 用于目标截图（当目标工具提示弹出时），也用于过场动画摄影机。大部分代码都是处理跟随动画（在 md5camera 类中定义）。 相机也可以绑定到移动实体（因为任何实体都可以绑定到任何其他实体）。<br />
</p>
</div>
</div>
<div id="outline-container-orga5b6236" class="outline-6">
<h6 id="orga5b6236">SecurityCamera</h6>
<div class="outline-text-6" id="text-orga5b6236">
<p>
安全摄像机用于制作平移、可破碎的安全摄像机（例如 CPU 摄像机-Computer Played Unit Camera）。 他们只是左右移动，只管自己的事。<br />
</p>

<ul class="org-ul">
<li><a href="https://www.quora.com/What-does-CPU-stand-for-in-non-playable-characters-in-video-games">https://www.quora.com/What-does-CPU-stand-for-in-non-playable-characters-in-video-games</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org027ad69" class="outline-6">
<h6 id="org027ad69">BrittleFracture</h6>
<div class="outline-text-6" id="text-org027ad69">
<p>
BrittleFracture 是指任何物体在受损时会非常壮观地破碎的术语。通常用于玻璃，但从技术上讲，你可以在 BrittleFracture 对象上放置你想要的任何纹理。 brittle fracture 会将一个平面细分为许多碎片，然后跟踪碎片之间的链接，因此当两个碎片之间有足够的损坏时，链接就会断裂。单个碎片作为 idPhysics_StaticMulti 的一部分在物理系统中运行。 这使得制作破碎非常耗时。可以通过将碎片视为粒子来进行加速（这样碎片就不需要经过物理系统的处理），但这看起来不太好。<br />
</p>
</div>
</div>
<div id="outline-container-org1db0eb4" class="outline-6">
<h6 id="org1db0eb4">Fx</h6>
<div class="outline-text-6" id="text-org1db0eb4">
<p>
Fx 实体是一个用于特殊效果的容器对象。Fx.h 文件中还包含一个 idTeleporter, 其为传送器目标实体。<br />
</p>
</div>
</div>
<div id="outline-container-orgd5e675a" class="outline-6">
<h6 id="orgd5e675a">Light</h6>
<div class="outline-text-6" id="text-orgd5e675a">
<p>
idLight 实体代表了几乎所有可以用灯光完成的事情：打开和关闭、随声音颤动、淡入和淡出等。<br />
</p>
</div>
</div>
<div id="outline-container-org7a46671" class="outline-6">
<h6 id="org7a46671">Sound</h6>
<div class="outline-text-6" id="text-org7a46671">
<p>
idSound 和 idLight 一样，只适用于声音。<br />
</p>
</div>
</div>
<div id="outline-container-orgc9c7869" class="outline-6">
<h6 id="orgc9c7869">Item</h6>
<div class="outline-text-6" id="text-orgc9c7869">
<p>
Items 是玩家可以捡起来获得的东西。 武器，医疗包，盔甲等都是物品。 该文件定义了基本的 idItem（用于大多数事物），以及 idMoveableItem（用于盔甲，以及一些其他较大的对象）、idItemPowerup（隐身、狂暴等）、idObjective（表示一个目标）、idVideoCDItem、idPDAItem 和 idMoveablePDAItem。 它还定义了 idItemRemover 和 idObjectiveComplete，它们是从玩家物品中移除物品的实体。 物品和可移动物品之间的区别在于环境（如门）在接触物品时的反应。 对于常规物品，对象将直接穿过它，但对于可移动物品，物品将被移动器推动。<br />
</p>
</div>
</div>
<div id="outline-container-org009c1a3" class="outline-6">
<h6 id="org009c1a3">Moveable</h6>
<div class="outline-text-6" id="text-org009c1a3">
<p>
idMoveable 就像无法拾取的可移动物品。例如，人们喜欢打孔的汉堡包、板条箱、汽水罐、垃圾桶、垃圾等。定义了两种特殊情况的可移动物品：idBarrel 和 idExplodingBarrel。<br />
</p>
</div>
</div>
<div id="outline-container-org3079d7e" class="outline-6">
<h6 id="org3079d7e">Trigger</h6>
<div class="outline-text-6" id="text-org3079d7e">
<p>
触发器是在某事发生时触发目标实体或调用脚本的实体。“某事”取决于触发器的类型。有用于玩家触摸的触发器，还有用于怪物触摸的触发器，计时器触发器，伤害触发器，淡入淡出触发器，仅在触发一定次数后触发的触发器，仅针对某些实体触发的触发器等。 只要触发器被触发，它就会向它的任何目标实体发送一个激活事件。<br />
</p>
</div>
</div>
<div id="outline-container-org75c5034" class="outline-6">
<h6 id="org75c5034">Target</h6>
<div class="outline-text-6" id="text-org75c5034">
<p>
目标用作触发器的目标。 大约有 30 种不同的目标实体类型，它们做的事情大相径庭，所以我不打算提及它们。 幸运的是，大多数目标都相当小（只有一个 Event_Activate 函数）。<br />
</p>
</div>
</div>
<div id="outline-container-orgf23a79e" class="outline-6">
<h6 id="orgf23a79e">Misc</h6>
<div class="outline-text-6" id="text-orgf23a79e">
<p>
Misc 是我们放置不适合其他任何地方的实体的地方。 它包含诸如 idVacuumEntity 和 idPlayerStart 之类的东西。 它也包含大约 30 种实体，所以我也不打算讨论这些。<br />
</p>
</div>
</div>
<div id="outline-container-org9a325c8" class="outline-6">
<h6 id="org9a325c8">AFEntity</h6>
<div class="outline-text-6" id="text-org9a325c8">
<p>
AFEntity 是具有关联的关节体型（articulated figure）的实体。 它实际上可以是许多不同类型的实体之一。 玩家、怪物、车辆、锁链（如起重机）和一般的尸体都是 AF 实体。 有一个 idAFEntity_Base 类，其中包含所有 AF 实体共享的一些基本功能，idAFEntity_Gibbable、idAFEntity_Vehicle、idAFEntity_SteamPipe 和 idAFEntity_ClawFourFingers 都派生自 idAFEntity_Base。 AFEntity 实际上除了生成和销毁 AF 实体之外并没有做太多事情，因为所有实际工作都在 idAF 和 idPhysics_AF 中完成。<br />
</p>
<pre class="example" id="org7a992ba">
idClass
+-idEntity
  +-idAnimatedEntity
    |-idWeapon
    |-idAFAttachment
    +-idAFEntity_Base  ---- Uses idAF
      |-idAFEntity_ClawFourFingers
      |-idAFEntity_Vehicle
      | |-idAFEntity_VehicleFourWheels
      | +-idAFEntity_VehicleSixWheels
      +-idAFEntity_Gibbable
        |-idAFEntity_WithAttachedHead
        |-idAFEntity_Generic
        |-idAnimated
        +-idActor      ---- Uses idIK
          |-idPlayer
          +-idAI
</pre>
</div>
</div>
<div id="outline-container-org3766f9b" class="outline-6">
<h6 id="org3766f9b">Actor</h6>
<div class="outline-text-6" id="text-org3766f9b">
<p>
Actor 是任何需要一一些 AI 的东西。 一般来说，Actor 有一个 .script 与之关联，但它并不总是如此（没有 script 的 actor 只是站在那里眨眼——就像在现实生活中一样）。 idActor 派生自 idAFEntity_Gibbable。<br />
</p>
</div>
</div>
<div id="outline-container-org3f710ac" class="outline-6">
<h6 id="org3f710ac">Player</h6>
<div class="outline-text-6" id="text-org3f710ac">
<p>
idPlayer 就是玩家。其包含输入处理，物品处理，过场，动画，传送，以及一大堆其他事情（大约有 8000 行代码）。Player.cpp 中还包含 idInverntory, 其为玩家库存的一个辅助类。<br />
</p>
</div>
</div>
<div id="outline-container-org4c265b0" class="outline-6">
<h6 id="org4c265b0">Projectile</h6>
<div class="outline-text-6" id="text-org4c265b0">
<p>
idProjectile 是一种飞过世界并对击中的任何东西造成伤害的实体。 通常，它们是由武器发射的（见下文），但并非必须如此。 例如，Revenant（亡魂）会产生炮弹，但从技术上讲，他没有任何武器（肩扛式火箭发射器是他模型的一部分，而火箭是在脚本中生成的）。<br />
<img src="./doom3/Revenants.jpg" alt="Revenants.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://doom.fandom.com/wiki/Revenant/Doom_3">https://doom.fandom.com/wiki/Revenant/Doom_3</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3d554d5" class="outline-6">
<h6 id="org3d554d5">Weapon</h6>
<div class="outline-text-6" id="text-org3d554d5">
<p>
idWeapon 是玩家在游戏中四处奔跑时拿在他面前的实体。 它可能会或可能不会发射弹丸，但大多数时候它会。 idWeapon 的有趣之处在于每个玩家一个，而不是每个武器一个。 当玩家切换武器时，它只是将一个新的武器脚本加载到现有的 idWeapon 中。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb87d276" class="outline-5">
<h5 id="orgb87d276">The Engine Code</h5>
<div class="outline-text-5" id="text-orgb87d276">
</div>
<div id="outline-container-orgecb95a6" class="outline-6">
<h6 id="orgecb95a6">System</h6>
<div class="outline-text-6" id="text-orgecb95a6">
<p>
Sys 是所有操作系统特定调用的地方。诸如锁定内存和生成线程之类的东西都在这里。所有函数和类都在 “sys”文件夹中的 sys_public.h 中定义。 游戏可访问的所有函数都是 idSys 单例的成员。<br />
</p>
</div>
</div>
<div id="outline-container-orge44bea2" class="outline-6">
<h6 id="orge44bea2">Common</h6>
<div class="outline-text-6" id="text-orge44bea2">
<p>
idCommon 处理启动和关闭所有其他系统（包括 game system）。 它还执行错误、警告和调试消息打印（它将消息路由到日志文件、控制台、早期控制台、专用控制台或其他需要它的地方）。<br />
在引擎中，代码如下所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>) {
    Sys_Init();
    common-&gt;Init();
    <span style="color: #4f97d7; font-weight: bold;">while</span> (1) {
        common-&gt;Frame();
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org94a585a" class="outline-6">
<h6 id="org94a585a">Command System</h6>
<div class="outline-text-6" id="text-org94a585a">
<p>
idCmdSystem 处理用户输入到任何一个控制台（游戏内控制台、专用控制台或编辑器控制台）的命令。 游戏代码也可以直接将命令传递给命令系统进行处理。 在每一帧命令系统将解析出命令缓冲区并通过调用与命令相关的回调函数来执行任何等待的命令。 例如，“quit”将调用 Com_Quit_f 回调函数（该函数又会调用 common-&gt;Quit()）。<br />
</p>
</div>
</div>
<div id="outline-container-org3e5021f" class="outline-6">
<h6 id="org3e5021f">CVar System</h6>
<div class="outline-text-6" id="text-org3e5021f">
<p>
idCVarSystem 用于管理控制台变量。 Doom 3 中的控制台变量比以前引擎中的控制台变量要酷得多。 这些变量可以按照如下方式添加到 CVar 系统中：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">idCVar</span> <span style="color: #7590db;">com_showFPS</span>( <span style="color: #2d9574;">"com_showFPS"</span>, <span style="color: #2d9574;">"0"</span>, CVAR_BOOL|CVAR_SYSTEM, <span style="color: #2d9574;">""</span> );
</pre>
</div>
<p>
idCVar 的构造函数会将 cvar 添加到 cvar 的静态列表中，然后在启动时将其添加到 cvar system 中。 之后，你可以通过实例化的对象访问该 cvar。 你还可以通过 cvar system 中的函数访问 cvar，但这有点慢（因为它必须每次都进行查找，而不是将其存储在 cvar 对象中）。<br />
</p>
</div>
</div>

<div id="outline-container-org2f80aed" class="outline-6">
<h6 id="org2f80aed">File System</h6>
<div class="outline-text-6" id="text-org2f80aed">
<p>
idFileSystem 允许访问文件。 你请求的文件可能在真实文件系统中，也可能在 pack 文件系统中。 它也可能在 mod 目录或游戏目录中。 当您请求“cheese/gouda.jpg”时，它将搜索游戏目录，然后是游戏包文件，然后是基本目录，然后是基本包文件。 如果服务器在纯模式下运行，那么文件系统将只检查包文件。 文件系统跟踪服务器上访问的所有文件以进行纯检查，它也可以设置为复制模式（fs_copyfiles）以帮助构建。<br />
</p>
</div>
</div>

<div id="outline-container-org62a4581" class="outline-6">
<h6 id="org62a4581">Networking System</h6>
<div class="outline-text-6" id="text-org62a4581">
<p>
游戏系统实际上只能访问网络系统的两个部分，第一部分为读/写（idGame::ClientReadSnapshot / idGame::ServerWriteSnapshot）的回调函数，第二部分为发送和接收可靠消息的函数（在 idNetworkSystem 中）。 idNetworkSystem 中还有一些其他函数可以获取 ping 和丢包等统计信息。<br />
</p>
</div>
</div>

<div id="outline-container-orgcc5b990" class="outline-6">
<h6 id="orgcc5b990">Render System</h6>
<div class="outline-text-6" id="text-orgcc5b990">
<p>
渲染器分为 3 个不同的概念部分：<br />
</p>

<ul class="org-ul">
<li>RenderWorld 与场景图非常相似。 它包含场景中的所有渲染模型和纹理，以某种易于剔除的方式排列。 它处理剔除并将命令发送到后端。<br /></li>
<li>后端是一个高度优化的系统，用于渲染三角形 soups。 Doom 3 支持的每个主要硬件架构（NV20、R300、ARB、ARB2、CG）都有一个单独的后端。<br /></li>
<li>渲染系统管理所有渲染世界（可以有多个 render worlds），并作为渲染系统的入口点。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org290e9f1" class="outline-6">
<h6 id="org290e9f1">Sound System</h6>
<div class="outline-text-6" id="text-org290e9f1">
<p>
声音系统与渲染系统非常相似，因为有一个声音世界（或两个，或三个）来处理所有真正困难的东西，而声音系统只是作为一个环形领导者。 声音世界会跟踪所有发声体的位置、它们的状态以及听者的位置。<br />
</p>
</div>
</div>

<div id="outline-container-org6ffca88" class="outline-6">
<h6 id="org6ffca88">Render Model Manager</h6>
<div class="outline-text-6" id="text-org6ffca88">
<p>
idRenderModelManager 处理渲染模型的加载和释放。 模型可以采用多种文件格式，包括 BSP、LWO 和 ASE。 在第一次被请求模型数据时时模型管理器会缓存该模型数据。 在关卡加载期间，关卡使用的每一个模型都有模型管理器来加载（在 BeginLevelLoad 和 EndLevelLoad 调用之间）。 这将确保在实际游戏过程中最小的磁盘命中。<br />
</p>
</div>
</div>

<div id="outline-container-org8db620f" class="outline-6">
<h6 id="org8db620f">User Interface Manager</h6>
<div class="outline-text-6" id="text-org8db620f">
<p>
idUserInterfaceManager 的行为与模型管理器完全相同，只是 idUserInterfaceManager 是用于 GUI。<br />
</p>
</div>
</div>

<div id="outline-container-org170d5a3" class="outline-6">
<h6 id="org170d5a3">Declaration Manager</h6>
<div class="outline-text-6" id="text-org170d5a3">
<p>
idDeclManager 处理加载、缓存、读取和写入任何类型的 decl。 它扫描目录并解析出 decl，自动为每种类型创建正确的 decl 对象。 你可以使用 decl 管理器注册你自定义的 decl 类型。 就像其他管理器一样，它加载的任何 decls 都应该在指定的加载阶段完成，以防止不必要的磁盘命中。<br />
</p>
</div>
</div>

<div id="outline-container-org8456009" class="outline-6">
<h6 id="org8456009">AAS file Manager</h6>
<div class="outline-text-6" id="text-org8456009">
<p>
idAASFileManager 加载和释放 AAS（area awareness system 区域感知系统）文件。 这是在游戏代码中获取 idAASFile 的唯一方法。<br />
</p>
</div>
</div>

<div id="outline-container-org15c77c4" class="outline-6">
<h6 id="org15c77c4">Collision Model Manager</h6>
<div class="outline-text-6" id="text-org15c77c4">
<p>
碰撞模型管理器与渲染模型管理器完全一样，只是其用于物理系统而不是渲染系统。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga6e050e" class="outline-3">
<h3 id="orga6e050e">DMap</h3>
<div class="outline-text-3" id="text-orga6e050e">
<p>
和每一代 id software engine 一样，地图是由策划组生成的，其会被一个工具预处理从而提升运行时性能。<br />
</p>

<p>
对于 idTech4 引擎来说，处理地图的工具为 dmap。其目标是从 .map 文件中读取多面体数据，通过区域间门户(inter-area-portals)来识别区域，并将这些区域保存在 .proc 文件中。<br />
</p>

<p>
Seth Teller 在 1992 年发表了一篇令人惊叹的论文：密集遮挡多面体环境中的可见性计算（Visibility Computations in Densely Occluded Polyhedral environment）：它使用了许多解释性图示很好地描述了 idTech4 是如何工作的。<br />
</p>
</div>
<div id="outline-container-orgf001518" class="outline-4">
<h4 id="orgf001518">The editor</h4>
<div class="outline-text-4" id="text-orgf001518">
<p>
设计师通过 CSG（构造实体几何 Constructive Solid Geometry）制作关卡地图：他们使用的多面体通常有 6 个面，通过将它们放置在地图上来制作关卡。<br />
这些块被称为画笔，下图显示了使用的 8 个画笔（我使用如下地图来解释 dmap 中的每个步骤）。<br />
</p>


<div id="orgfab3be9" class="figure">
<p><img src="./doom3/simple-dmap-00.jpg" alt="simple-dmap-00.jpg" /><br />
</p>
</div>

<p>
设计师可能很清楚什么是“内部”（左侧），但 dmap 收到了一个画笔汤，里面什么都没有，外面什么都没有（右侧）。画笔不是通过面定义的，而是通过面对应的平面定义的。使用平面而不是面似乎效率很低，但稍后在检查两个面是否在同一平面上时非常有用。 因为平面朝向不是一致的，所以没有内部或外部。平面方向可以无差别地指向体积外部或内部（平面方向指向体积内部或外部都没有差别）。<br />
</p>


<div id="orgc7ca08b" class="figure">
<p><img src="./doom3/dmap_brush.png" alt="dmap_brush.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org42cb526" class="outline-4">
<h4 id="org42cb526">Code overview</h4>
<div class="outline-text-4" id="text-org42cb526">
<p>
Dmap 源码注释非常清晰。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">ProcessModel</span>( <span style="color: #ce537a; font-weight: bold;">uEntity_t</span> *<span style="color: #7590db;">e</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">floodFill</span> )
{
    <span style="color: #ce537a; font-weight: bold;">bspface_t</span>        *<span style="color: #7590db;">faces</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">build a bsp tree using all of the sides</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of all of the structural brushes</span>
    faces = MakeStructuralBspFaceList ( e-&gt;primitives );
    e-&gt;tree = FaceBSP( faces );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create portals at every leaf intersection</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to allow flood filling</span>
    MakeTreePortals( e-&gt;tree );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">classify the leafs as opaque or areaportal</span>
    FilterBrushesIntoTree( e );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">see if the bsp is completely enclosed</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( floodFill &amp;&amp; <span style="color: #a45bad;">!</span>dmapGlobals.noFlood ) {
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( FloodEntities( e-&gt;tree ) ) {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set the outside leafs to opaque</span>
            FillOutside( e );
        } <span style="color: #4f97d7; font-weight: bold;">else</span> {
            common-&gt;Printf ( <span style="color: #2d9574;">"**********************\n"</span> );
            common-&gt;Warning( <span style="color: #2d9574;">"******* leaked *******"</span> );
            common-&gt;Printf ( <span style="color: #2d9574;">"**********************\n"</span> );
            LeakFile( e-&gt;tree );
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bail out here.  If someone really wants to</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">process a map that leaks, they should use</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-noFlood</span>
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        }
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get minimum convex hulls for each visible side</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this must be done before creating area portals,</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">because the visible hull is used as the portal</span>
    ClipSidesByTree( e );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">determine areas before clipping tris into the</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tree, so tris will never cross area boundaries</span>
    FloodAreas( e );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we now have a BSP tree with solid and non-solid leafs marked with areas</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">all primitives will now be clipped into this, throwing away</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fragments in the solid areas</span>
    PutPrimitivesInAreas( e );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now build shadow volumes for the lights and split</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the optimize lists by the light beam trees</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">so there won't be unneeded overdraw in the static</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case</span>
    Prelight( e );

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">optimizing is a superset of fixing tjunctions</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( <span style="color: #a45bad;">!</span>dmapGlobals.noOptimize ) {
        OptimizeEntity( e );
    } <span style="color: #4f97d7; font-weight: bold;">else</span>  <span style="color: #4f97d7; font-weight: bold;">if</span> ( <span style="color: #a45bad;">!</span>dmapGlobals.noTJunc ) {
        FixEntityTjunctions( e );
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now fix t junctions across areas</span>
    FixGlobalTjunctions( e );

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd239ff" class="outline-4">
<h4 id="orgdd239ff">0. Loading the level geometry</h4>
<div class="outline-text-4" id="text-orgdd239ff">
<p>
.map 文件是一个 entities 列表。关卡是列表中的第一个 entity，其 classname 字段的值为 "worldspawn"。一个 entity 包含了一个 primitives 列表，primitives 大多数为 brushes。剩余的 entities 为 lights,monsters,player spawning location, weapons 等等。每个 brush 被表示为一组平面。brush 的边被称为面(faces)也被称为 windings，用其他平面来裁剪一个平面可以得到 brush 的面。<br />
</p>
<div class="org-src-container">
<pre class="src src-js">Version 2
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">entity 0</span>
{
    <span style="color: #2d9574;">"classname"</span> <span style="color: #2d9574;">"worldspawn"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">primitive 0</span>
    {
        brushDef3
        {
            ( 0 0 -1 -272 ) ( ( 0.0078125 0 -8.5 ) ( 0 0.03125 -16 ) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
            ( 0 0 1 -56   ) ( ( 0.0078125 0 -8.5 ) ( 0 0.03125 16  ) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
            ( 0 -1 0 -3776) ( ( 0.0078125 0 4    ) ( 0 0.03125 0   ) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
            ( -1 0 0 192  ) ( ( 0.0078125 0 8.5  ) ( 0 0.03125 0   ) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
            ( 0 1 0 3712  ) ( ( 0.006944  0 4.7  ) ( 0 0.034   1.90) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
            ( 1 0 0 -560  ) ( ( 0.0078125 0 -4   ) ( 0 0.03125 0   ) ) <span style="color: #2d9574;">"textures/base_wall/stelabwafer1"</span> 0 0 0
        }
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">primitive 1</span>
    {
        brushDef3
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">primitive 2</span>
    {
        brushDef3
    }
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">....</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">entity 37</span>
{
    <span style="color: #2d9574;">"classname"</span> <span style="color: #2d9574;">"light"</span>
    <span style="color: #2d9574;">"name"</span> <span style="color: #2d9574;">"light_51585"</span>
    <span style="color: #2d9574;">"origin"</span> <span style="color: #2d9574;">"48 1972 -52"</span>
    <span style="color: #2d9574;">"texture"</span> <span style="color: #2d9574;">"lights/round_sin"</span>
    <span style="color: #2d9574;">"_color"</span> <span style="color: #2d9574;">"0.55 0.06 0.01"</span>
    <span style="color: #2d9574;">"light_radius"</span> <span style="color: #2d9574;">"32 32 32"</span>
    <span style="color: #2d9574;">"light_center"</span> <span style="color: #2d9574;">"1 3 -1"</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org15ccffd" class="outline-4">
<h4 id="org15ccffd">1. MakeStructuralBspFaceList &amp; FaceBSP</h4>
<div class="outline-text-4" id="text-org15ccffd">
<p>
第一步是使用 Binary Space Partition 对地图进行分割。地图中的每个非透明面都会被用作分割平面。<br />
</p>

<ul class="org-ul">
<li>如果地图大于 5000 个单位，则在空间的中部使用轴对称的平面进行分割。如下图的所示的地图为 6000x6000 大小，需要分割三次：<br />
<img src="./doom3/dmap_bsp_heuristic.png" alt="dmap_bsp_heuristic.png" /><br /></li>
<li>分割地图为多个部分后，若各个部分大小都小于 5000 个单位，则使用标记为 portal 的面（他们使用的材质为 textures/editor/visportal）进行分割。下图中使用蓝色表示 portal brushes。<br />
<img src="./doom3/bsp_building.png" alt="bsp_building.png" /><br /></li>
<li>最后使用剩余的面进行分割。<br />
优先选择与大多数其他平面共线的面并分割较少的面； 也优先选择轴对齐的面进行分割。 如下图分割平面用红色标记。<br />
<img src="./doom3/simple-dmap-01.jpg" alt="simple-dmap-01.jpg" /><br />
当没有更多面可用时，分割完成。此时，BSP 树的叶子都表示一个 凸子空间(convex subspace)<br />
<img src="./doom3/dmap_bsp_building3.png" alt="dmap_bsp_building3.png" /><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org5768b19" class="outline-4">
<h4 id="org5768b19">2. MakeTreePortals</h4>
<div class="outline-text-4" id="text-org5768b19">
<p>
地图现在被划分为凸子空间，但这些子空间彼此之间没有感知。此步骤的目标是通过自动创建门户，将每个叶子连接到其邻居。 这个想法是从地图边界的六个门户开始：将“外部”连接到“内部”（BSP 的根）。 然后对于 BSP 中的每个节点：拆分节点中的每个门户，将拆分平面添加为门户并递归。<br />
<img src="./doom3/dmap_portal_building.png" alt="dmap_portal_building.png" /><br />
原始的 6 个 portals 被分割，从根节点到叶子节点逐步进行分割。这并不像看起来那么简单，因为每次拆分节点时：它连接的每个门户也必须拆分。<br />
在下面的图中，一个门户连接了两个 BSP 兄弟节点。 随着左边节点的分割，其分割平面将门户也一分为二。我们可以看到此时兄弟节点的门户也必须更新，以便他们不再连接到同级节点，而是连接到侄子节点。<br />
<img src="./doom3/portal_propagation.png" alt="portal_propagation.png" /><br />
</p>

<p>
在该过程结束时，六个原始门户已拆分为数百个门户，并在拆分平面上创建了新门户： BSP 中的每个叶子都对邻居是有感知的，通过叶子节点的 portals 链表可以找到和其共边的其他叶子节点。<br />
<img src="./doom3/dmap_portal_building2.png" alt="dmap_portal_building2.png" /><br />
</p>
</div>
</div>

<div id="outline-container-orgfc7e073" class="outline-4">
<h4 id="orgfc7e073">3. FilterBrushesIntoTree</h4>
<div class="outline-text-4" id="text-orgfc7e073">
<p>
这一步就像一个形状分类游戏，BSP 是板，brushes 是形状。 每个 brush 都被发送到 BSP 以确定哪些叶子是不透明的。<br />
<img src="./doom3/shapesorter.jpg" alt="shapesorter.jpg" /><br />
</p>

<p>
如果 brush 穿过分割平面一点但不超过 EPSILON，则它不会被分割。相反，会将 brush 发送到分割平面的另一侧，brush 的其他面都在该侧。这样就可以区分出“内部”和“外部”了。<br />
叶子节点被一个 brush 击中，则该叶子节点被认为是不透明的，并做对应的标记。<br />
</p>



<div id="org5da4f57" class="figure">
<p><img src="./doom3/post_filter.png" alt="post_filter.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org623dfba" class="outline-4">
<h4 id="org623dfba">4. FloodEntities &amp; FillOutside</h4>
<div class="outline-text-4" id="text-org623dfba">
<p>
使用玩家生成实体，从每个叶子触发洪水填充算法（floodfill algorithm）。 该算法标记出实体可到达的叶子。<br />
<img src="./doom3/floodEntities.png" alt="floodEntities.png" /><br />
在最后一步中，FillOutside 会遍历每个叶子节点，如果该叶子节点无法到达，则将其标记为不透明。<br />
<img src="./doom3/post_FillOutside.png" alt="post_FillOutside.png" /><br />
现在我们关卡的每个子空间要么是可以到达的，要么就是不透明的。通过检查目标叶子是否不透明，现在可以通过叶子节点的门户进行导航了。<br />
</p>
</div>
</div>
<div id="outline-container-orgc3ea429" class="outline-4">
<h4 id="orgc3ea429">5. ClipSidesByTree</h4>
<div class="outline-text-4" id="text-orgc3ea429">
<p>
现在就可以丢弃掉 brushes 中无用的部分了：原始的 brush 的每个面会被发送到 BSP。如果一个面在一个不透明空间内，则该面就会被丢弃，否则将其添加到 visibleHull 列表中。最终，将得到关卡的“skin”，只有可见部分被保留。<br />
<img src="./doom3/only_skin_remaining.png" alt="only_skin_remaining.png" /><br />
从此处开始，就只需要考虑 visibleHull 列表中存储的面了。<br />
</p>
</div>
</div>
<div id="outline-container-org45dcffd" class="outline-4">
<h4 id="org45dcffd">6. FloodAreas</h4>
<div class="outline-text-4" id="text-org45dcffd">
<p>
现在 dmp 将叶子节点按照区域 ID 组织在一起：对每个叶子，触发洪水填充算法。该算法尝试按照叶子节点关联的门户进行遍历。<br />
</p>

<p>
这就是设计师工作非常重要的地方：只有在地图上手动放置可视化门户(visportals)才能识别区域。 没有它们，dmap 将只识别一个区域，此时每帧都会将整个地图发送到 GPU。<br />
</p>

<p>
Floodfilling 递归算法只会在遇到 areaportals 和不透明节点时才停止。 在下图中，自动生成的门户（红色）将允许洪水通过，但设计师放置的 visportal（蓝色，也称为 areaportal ）将阻止它，从而形成两个区域：<br />
<img src="./doom3/FloodAreas.png" alt="FloodAreas.png" /><br />
<img src="./doom3/FloodAreas2.png" alt="FloodAreas2.png" /><br />
在该过程结束时每个可到达叶子节点都属于一个区域，并且区域间的门户(inter-area-portals)被识别出来，下图中的蓝色线表示 inter-area-portals。<br />
<img src="./doom3/FloodAreas3.png" alt="FloodAreas3.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org292f7f1" class="outline-4">
<h4 id="org292f7f1">7. PutPrimitivesInAreas</h4>
<div class="outline-text-4" id="text-org292f7f1">
<p>
此步骤将步骤 6 中确定的区域与步骤 5 中计算得到的 visibleHull 结合起来，再进行一次形状分类游戏：这次区域是板，visibleHull 是形状。<br />
</p>

<p>
分配一个区域数组，每个 brush 的 visibleHull 都被发送到 BSP 中：表面被添加到区域数组的元素中，元素对应的索引为 areaID。<br />
</p>

<p>
注意：<br />
这样做非常巧妙，其也优化了实体的生成。 如果某些实体被标记为“func_static”，它们会被实例化并关联到一个区域。 这是一种将盒子、桶、椅子“融”成一个区域的方法（也可以让它的阴影体预先生成）。<br />
</p>
</div>
</div>
<div id="outline-container-org7079410" class="outline-4">
<h4 id="org7079410">8. Prelight</h4>
<div class="outline-text-4" id="text-org7079410">
<p>
对于每个静态光照, dmap 预先计算阴影体几何。 这些阴影体稍后会保存在 .proc 中。 唯一的技巧是阴影体的名称为“_prelight_light”与灯光 ID 连接而成，因此引擎可以匹配来自 .map 文件的灯光和来自 .proc 文件的阴影体积：<br />
</p>
<div class="org-src-container">
<pre class="src src-js">shadowModel
{
    <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">name =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> <span style="color: #2d9574;">"_prelight_light_2900"</span>

    <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">numVerts =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> 24 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">noCaps =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> 72 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">noFrontCaps =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> 84 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">numIndexes =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> 96 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">planeBits =</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> 5

    ( -1008 976 183.125 ) ( -1008 976 183.125 ) ( -1013.34375 976 184 ) ( -1013.34375 976 184 ) ( -1010 978 184 )
    ( -1008 976 184 ) ( -1013.34375 976 168 ) ( -1013.34375 976 168 ) ( -1008 976 168.875 ) ( -1008 976 168.875 )
    ( -1010 978 168 ) ( -1008 976 167.3043518066 ) ( -1008 976 183.125 ) ( -1008 976 183.125 ) ( -1010 978 184 )
    ( -1008 976 184 ) ( -1008 981.34375 184 ) ( -1008 981.34375 184 ) ( -1008 981.34375 168 ) ( -1008 981.34375 168 )
    ( -1010 978 168 ) ( -1008 976 167.3043518066 ) ( -1008 976 168.875 ) ( -1008 976 168.875 )

    4 0 1 4 1 5 2 4 3 4 5 3 0 2 1 2 3 1
    8 10 11 8 11 9 6 8 7 8 9 7 10 6 7 10 7 11
    14 13 12 14 15 13 16 12 13 16 13 17 14 16 15 16 17 15
    22 21 20 22 23 21 22 18 19 22 19 23 18 20 21 18 21 19
    1 3 5 7 9 11 13 15 17 19 21 23 4 2 0 10 8 6
    16 14 12 22 20 18
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7bfa7e" class="outline-4">
<h4 id="orgd7bfa7e">9. FixGlobalTjunctions</h4>
<div class="outline-text-4" id="text-orgd7bfa7e">
<p>
为了避免 visual artifacts，修复 TJunction 通常很重要，这在 idTech4 中更为重要：因为几何图形还用于在写入模板缓冲区时生成阴影。<br />
</p>
</div>
</div>

<div id="outline-container-org59a3d57" class="outline-4">
<h4 id="org59a3d57">10. Write output</h4>
<div class="outline-text-4" id="text-org59a3d57">
<p>
最后，所有这些预处理都保存到 .proc 文件中：<br />
</p>
<ul class="org-ul">
<li>对于每个区域，一组按材质分组的表面<br /></li>
<li>BSP 树，并且叶子被赋予了 areaID<br /></li>
<li>区域间门户（inter-area-portals）<br /></li>
<li>阴影体<br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2411704" class="outline-3">
<h3 id="org2411704">Renderer</h3>
<div class="outline-text-3" id="text-org2411704">
<p>
idTech4 渲染器具有三项关键创新：<br />
</p>

<ul class="org-ul">
<li>统一的照明和阴影：关卡的表面和实体的表面通过相同的管线和着色器<br /></li>
<li>可见表面确定：门户系统允许在运行时执行 VSD(Visible Surface Determination)：不再有 PVS(Potentially visible Set)<br /></li>
<li>多 pass 渲染<br /></li>
</ul>

<p>
到目前为止，最重要的是 idTech4 是一个多 pass 渲染器。 视图中每个灯光的贡献通过加法混合累积在 GPU 帧缓冲区中。Doom 3 充分利用了颜色帧缓冲区寄存器 saturate 而不是 wrapping around 的事实。<br />
</p>
<pre class="example" id="orgc19a058">
CPU register (wrap around) :
============================

  1111 1111
+ 0000 0100
  ---------
= 0000 0011


GPU register ( saturate) :
==========================

  1111 1111
+ 0000 0100
---------
= 1111 1111
</pre>
</div>

<div id="outline-container-org429de74" class="outline-4">
<h4 id="org429de74">Architecture</h4>
<div class="outline-text-4" id="text-org429de74">
<p>
渲染器不再和之前的 idTech 引擎一样是一个整体，而是被分为 Frontend 和 Backend 两部分<br />
</p>
<ul class="org-ul">
<li>Frontend<br />
<ul class="org-ul">
<li>分析世界数据库，确定哪些会显示到 view<br /></li>
<li>将结果存储为中间表示(def_view_t) 并且上传几何数据到 GPU 的 VBO 中，或直接复用 GPU 的 VBO 缓存的几何数据<br /></li>
<li>发布一个 RC_DRAW_VIEW 命令<br /></li>
</ul></li>
<li>Backend<br />
<ul class="org-ul">
<li>RC_DRAW_VIEW 命令唤醒 backend<br /></li>
<li>以中间表示为输入并发布命令给 GPU<br /></li>
</ul></li>
</ul>


<div id="org227dd09" class="figure">
<p><img src="./doom3/fb_design_renderer.png" alt="fb_design_renderer.png" /><br />
</p>
</div>

<p>
如此设计渲染器是为了多线程渲染（Doom3 并没有使用多线程渲染，而 Doom3BFG 中则引入了多线程渲染）。<br />
</p>
</div>
</div>
<div id="outline-container-org632c2f6" class="outline-4">
<h4 id="org632c2f6">Frontend/Backend/GPU collaboration</h4>
<div class="outline-text-4" id="text-org632c2f6">
<p>
下图展示了 frontend 、backend 以及 GPU 之间是如何协作的：<br />
<img src="./doom3/rendere_big_picture.png" alt="rendere_big_picture.png" /><br />
</p>
<ol class="org-ol">
<li>frontend 分析世界状态并生成两种数据：<br />
<ul class="org-ul">
<li>中间表示数据： 一个中间表示包含一个 light 列表，这些 light 对显示都有贡献。每个 light 又包含一个实体表面列表，这些表面和该 light 有交互<br /></li>
<li>交互表数据：每个有交互的 light - 实体对将被用于生成当前这帧图像，他们被缓存到一个交互表中。数据通常会被上传到 GPU 的 VBO 中。<br /></li>
</ul></li>
<li>backend 以中间表示数据为输入。其遍历每个 light，并为每个和该 light 交互的实体生成 OpenGL 绘制调用。绘制命令很显然会引用 VBO 和贴图。<br /></li>
<li>GPU 接受 OpenGL 命令并渲染到屏幕上<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgda4271e" class="outline-4">
<h4 id="orgda4271e">Doom3 Renderer Frontend</h4>
<div class="outline-text-4" id="text-orgda4271e">
<p>
前端执行最困难的部分：可见表面测定 (VSD)。 目标是找到影响视图的每个灯光/实体组合。 这些组合称为交互。 确定了每对交互组合后，前端确保后端所需的所有内容都上传到 GPU Ram（它通过“交互表”跟踪所有内容）。 最后一步是生成中间表示，中介表示由后端读取，以便可以生成对应的 OpenGL 命令。<br />
</p>

<p>
在代码中是这样的：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">  - <span style="color: #a45bad;">idCommon</span>::Frame
   - <span style="color: #a45bad;">idSession</span>::UpdateScreen
     - <span style="color: #a45bad;">idSession</span>::Draw
       - <span style="color: #a45bad;">idGame</span>::Draw
         - <span style="color: #a45bad;">idPlayerView</span>::RenderPlayerView
           - <span style="color: #a45bad;">idPlayerView</span>::SingleView
             - <span style="color: #a45bad;">idRenderWorld</span>::RenderScene
                - build params
                - ::R_RenderView(params)    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">This is the frontend</span>
                  {
                      R_SetViewMatrix
                      <span style="color: #ce537a; font-weight: bold;">R_SetupViewFrustum</span>
                      <span style="color: #7590db;">R_SetupProjection</span>

                      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Most of the beef is here.</span>
                      <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">idRenderWorldLocal</span> *&gt;(parms-&gt;renderWorld)-&gt;FindViewLightsAndEntities()
                      {
                          <span style="color: #ce537a; font-weight: bold;">PointInArea</span>              <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Walk the BSP and find the current Area</span>
                          <span style="color: #7590db;">FlowViewThroughPortals</span>   <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Recursively pass portals to find lights and entities interacting with the view.</span>
                      }

                      R_ConstrainViewFrustum       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Improve Z-buffer accuracy by moving far plan as close as the farthest entity.</span>
                      R_AddLightSurfaces           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Find entities that are not in a visible area but still casting a shadow (usually enemies)</span>
                      R_AddModelSurfaces           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Instantiate animated models (for monsters)</span>
                      R_RemoveUnecessaryViewLights
                      R_SortDrawSurfs              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">A simple C qsort call. C++ sort would have been faster thanks to inlining.</span>
                      <span style="color: #ce537a; font-weight: bold;">R_GenerateSubViews</span>
                      <span style="color: #7590db;">R_AddDrawViewCmd</span>
                  }
</pre>
</div>
<p>
使用图示更容易理解一些，如下图所示，由于设计师添加的 visportals, 引擎只看到了 4 个区域：<br />
<img src="./doom3/renderer_room.png" alt="renderer_room.png" /><br />
在加载 .proc 时，引擎还加载了.map 文件，其中包含了所有灯光和移动实体的定义。对于每个灯，引擎都建立一个受影响区域的列表：<br />
<img src="./doom3/renderer_room_light.png" alt="renderer_room_light.png" /><br />
</p>
<pre class="example" id="org0343bf8">
Light 1 :
=========
  - Area 0
  - Area 1

Light 2 :
=========
  - Area 1
  - Area 2
  - Area 3
</pre>

<p>
运行时，我们有一个玩家的位置以及 monsters 投射的阴影。为了正确性，必须找到所有的怪物及其阴影。<br />
<img src="./doom3/renderer_room_light_entities.png" alt="renderer_room_light_entities.png" /><br />
</p>

<p>
处理过程如下：<br />
</p>
<ol class="org-ol">
<li>通过遍历 PointInArea 中的 BSP 树确定玩家在哪个区域<br /></li>
<li><p>
FlowViewThroughPortals : 利用门户系统，从当前的区域开始洪水填充其他可见区域。每经过一个门户就对 view frustrum 进行一次变形。如下图所示：<br />
<img src="./doom3/frustrum_portal_division.png" alt="frustrum_portal_division.png" /><br />
如此，我们就可以得到对屏幕有贡献的 light 和实体的列表。他们被存储在交互表(interaction table)中。<br />
</p>
<pre class="example" id="orgbf0f363">
Interaction table (Light/Entity) :
==================================
Light 1 - Area    0
Light 1 - Area    1
Light 1 - Monster 1

Light 2 - Area    1
Light 2 - Monster 1
</pre>
<p>
上面的交互表还不完整：缺少 Light2 和 Monster2 的交互，还缺少 Monster2 投射的阴影<br />
</p></li>
<li><p>
R_AddLightSurfaces 通过遍历每个 light 的区域列表，将会找到不再视野中，但是投射了阴影的实体。<br />
</p>
<pre class="example" id="orgcfa69a3">
Interaction table (Light/Entity) :
==================================

Light 1 - Area    0
Light 1 - Area    1
Light 1 - Monster 1

Light 2 - Area    1
Light 2 - Monster 1
Light 2 - Monster 2
</pre></li>
<li>R_AddModelSurfaces : 获得所有的交互后，就可以上传所有顶点和索引数据到 GPU 的 VBO 了。播动画的 monster 的几何也会在这里被实例化(包括模型和阴影体)<br /></li>
<li>所有工作都完成后，通过 R_AddDrawViewCmd 发布一个 RC_DRAW_VIEW 命令，其将会触发 backend 去渲染屏幕。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org8c7e272" class="outline-4">
<h4 id="org8c7e272">Doom3 Renderer Backend</h4>
<div class="outline-text-4" id="text-org8c7e272">
<p>
后端负责渲染中间表示，同时考虑到 GPU 的限制, Doom3 支持五种 GPU 渲染路径：<br />
</p>
<ul class="org-ul">
<li>R10 (GeForce256)<br /></li>
<li>R20 (GeForce3)<br /></li>
<li>R200 (Radeon 8500)<br /></li>
<li>ARB (OpenGL 1.X)<br /></li>
<li>ARB2 (OpenGL 2.0)<br /></li>
</ul>

<p>
截至 2012 年，只有 ARB2 与现代 GPU 相关，标准不仅提供了可移植性，而且还延长了使用寿命。<br />
</p>

<p>
idtech4 根据显卡的能力来启用凹凸贴图和高光贴图，但所有 GPU rendering path 都尽最大努力通过以下方式节省尽可能多的填充率：<br />
</p>
<ul class="org-ul">
<li>对每个灯光进行 OpenGL Scissor 测试（由前端生成)<br /></li>
<li>使用 Pre Depth Pass，先填充 Z 缓冲区，从而减低 overdraw<br /></li>
</ul>

<p>
后端代码展开后如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">idRenderSystemLocal</span>::EndFrame
R_IssueRenderCommands
RB_ExecuteBackEndCommands
RB_DrawView
<span style="color: #ce537a; font-weight: bold;">RB_ShowOverdraw</span>
<span style="color: #7590db;">RB_STD_DrawView</span>
{
    RB_BeginDrawingView     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">clear the z buffer, set the projection matrix, etc</span>
    RB_DetermineLightScale

    <span style="color: #ce537a; font-weight: bold;">RB_STD_FillDepthBuffer</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fill the depth buffer and clear color buffer to black.</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Go through each light and draw a pass, accumulating result in the framebuffer</span>
    _DrawInteractions
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5 GPU specific path</span>
        <span style="color: #4f97d7; font-weight: bold;">switch</span> (renderer)
        {
            R10  (GeForce256)
            R20  (geForce3)
            R200 (Radeon 8500)
            ARB  (OpenGL 1.X)
            ARB2 (OpenGL 2.0)
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">disable stencil shadow test</span>
        qglStencilFunc( GL_ALWAYS, 128, 255 );

        RB_STD_LightScale

        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">draw any non-light dependent shading passes (screen,neon, etc...)</span>
        <span style="color: #ce537a; font-weight: bold;">int</span>  <span style="color: #7590db;">processed</span> = RB_STD_DrawShaderPasses( drawSurfs, numDrawSurfs )

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fob and blend lights</span>
        RB_STD_FogAllLights();

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now draw any post-processing effects using _currentRender</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( processed &lt; numDrawSurfs )
            RB_STD_DrawShaderPasses( drawSurfs+processed, numDrawSurfs-processed );
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3a8e44d" class="outline-2">
<h2 id="org3a8e44d">Doom3BFG</h2>
<div class="outline-text-2" id="text-org3a8e44d">
</div>
<div id="outline-container-orge68f0bb" class="outline-3">
<h3 id="orge68f0bb">Introduction</h3>
<div class="outline-text-3" id="text-orge68f0bb">
</div>
<div id="outline-container-org9bad7eb" class="outline-4">
<h4 id="org9bad7eb">Architecture</h4>
<div class="outline-text-4" id="text-org9bad7eb">
<p>
Solution structure 如下:<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Projects</th>
<th scope="col" class="org-left">Builds</th>
<th scope="col" class="org-left">Observations</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Doom3BFG</td>
<td class="org-left">Doom3BFG.exe</td>
<td class="org-left">Doom3 BFG 引擎</td>
</tr>

<tr>
<td class="org-left">doomclassic</td>
<td class="org-left">doomclassic.lib</td>
<td class="org-left">Doom1/2 游戏引擎的重构</td>
</tr>

<tr>
<td class="org-left">external</td>
<td class="org-left">external.lib</td>
<td class="org-left">jpeg-6 zlib 源码</td>
</tr>

<tr>
<td class="org-left">Game-d3xp</td>
<td class="org-left">Game-d3xp.lib</td>
<td class="org-left">通用的游戏库，提供了原创+扩展+新创造的关卡。以静态库形式代替之前的 DLL</td>
</tr>

<tr>
<td class="org-left">idLib</td>
<td class="org-left">idLib.lib</td>
<td class="org-left">id software 工具库，提供了 filesystem, threading, containers.</td>
</tr>

<tr>
<td class="org-left">Amplitude</td>
<td class="org-left">Amplitude.lib</td>
<td class="org-left">Doom Classic 所使用的工具：用于调整 WAV 的振幅</td>
</tr>

<tr>
<td class="org-left">timidity</td>
<td class="org-left">timidity.lib</td>
<td class="org-left">Doom Classic 所使用的工具：将 MIDI 输入转化为 WAV 格式</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgbb52c3f" class="outline-3">
<h3 id="orgbb52c3f">Threading</h3>
<div class="outline-text-3" id="text-orgbb52c3f">
</div>
<div id="outline-container-orga455012" class="outline-4">
<h4 id="orga455012">Doom 3 BFG Threading Model</h4>
<div class="outline-text-4" id="text-orga455012">
<p>
doom3 bfg 所用游戏引擎被称为 idTech4, 由 John Carmack 设计。该引擎是基于多线程设计的，其在 PC 平台开始时会启动如下 3 个线程：<br />
</p>
<ol class="org-ol">
<li>专用于渲染器后端的线程（该线程发送绘制命令给 GPU）   主线程就是 renderer backend<br /></li>
<li>专用于渲染器前端和游戏逻辑的线程(该线程生成绘制命令)  Common_local.h 文件中 idCommonLocal 类有一个 idGameThread 类型的 gameThread 成员<br /></li>
<li>专用于高频率(250HZ)控制摇杆采样的线程<br /></li>
</ol>
<p>
除此以外，还会生成两个工作线程。他们作为上面 3 个主要线程的助理。他们由内部调度器所管理。<br />
</p>


<div id="orgc9227e3" class="figure">
<p><img src="./doom3/doom3BFG_threading_model.png" alt="doom3BFG_threading_model.png" /><br />
</p>
</div>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>common_frame.cpp 文件 idCommonLocal::Frame 函数会调用 renderSystem-&gt;RenderCommandBuffers( renderCommands ); 来执行渲染命令<br /></li>
<li>Common.cpp 文件 idCommonLocal::Init 函数会调用 gameThread.StartWorkerThread( "Game/Draw", CORE_1B, THREAD_BELOW_NORMAL, 0x100000 ); 开启 Game 线程<br /></li>
<li>ParallelJobList.cpp 文件 idParallelJobManagerLocal 类有一个 idJobThread[] 类型的成员，其定义了工作线程数组<br /></li>
<li>ParallelJobList.cpp 文件 idParallelJobManagerLocal::Init() 函数会调用 idJobThread::Start 方法来开启工作线程<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org1642d91" class="outline-4">
<h4 id="org1642d91">Core idea</h4>
<div class="outline-text-4" id="text-org1642d91">
<p>
对于 CPU 多核化的发展趋势，id software 在 2009 年的 siggraph 演讲中提出了他们的解决方案，其中主要的核心概念有两点：<br />
</p>
<ul class="org-ul">
<li>分解需要处理的任务为 jobs, 由多个工作线程来执行这些 jobs<br /></li>
<li>不要将同步代理给操作系统完成：自己通过原子操作来完成同步<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org228aeba" class="outline-4">
<h4 id="org228aeba">Building blocks</h4>
<div class="outline-text-4" id="text-org228aeba">
<p>
该系统包含以下三种元素：Jobs, Workers, Synchronization<br />
</p>
</div>
<div id="outline-container-orgb7b63ee" class="outline-5">
<h5 id="orgb7b63ee">Jobs</h5>
<div class="outline-text-5" id="text-orgb7b63ee">
<p>
一个 "Job" 包含了具体需要做的事情。其对应的代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">job_t</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span>  (* <span style="color: #bc6ec5; font-weight: bold;">function</span> )(<span style="color: #ce537a; font-weight: bold;">void</span> *);   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Job instructions</span>
    <span style="color: #ce537a; font-weight: bold;">void</span>   * <span style="color: #7590db;">data</span>;                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Job parameters</span>
    <span style="color: #ce537a; font-weight: bold;">int</span>    <span style="color: #7590db;">executed</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Job end marker...Not used.</span>
};
</pre>
</div>
<p>
一个 job 应该至少需要消耗几千个时钟周期，从而才能超过任何作业切换导致的开销。 另一方面，一个 job 的消耗不应超过 100,000 个时钟周期，从而在多个处理单元上保持良好的负载平衡。<br />
</p>
</div>
</div>
<div id="outline-container-org7c50542" class="outline-5">
<h5 id="org7c50542">Workers</h5>
<div class="outline-text-5" id="text-org7c50542">
<p>
一个 Worker 就是一个线程，其会保持空闲等待。当它醒来时，它会尝试从 JobList 获取一个 job，此时其通过使用原子操作来避免同步。<br />
</p>
</div>
</div>

<div id="outline-container-org71a062c" class="outline-5">
<h5 id="org71a062c">Synchronization</h5>
<div class="outline-text-5" id="text-org71a062c">
<p>
通过 3 个元素来实现同步：Signals，Mutexes 以及 Atomic operations。原子操作允许引擎保持 CPU 执行权，因此更受青睐。<br />
</p>
</div>

<div id="outline-container-orgc9785ba" class="outline-6">
<h6 id="orgc9785ba">Monitors (idSysSignal)</h6>
<div class="outline-text-6" id="text-orgc9785ba">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Abstraction</th>
<th scope="col" class="org-left">Operations</th>
<th scope="col" class="org-left">Implemented with</th>
<th scope="col" class="org-left">Details</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">idSysSignal</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Event Objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Raise</td>
<td class="org-left">SetEvent</td>
<td class="org-left">将指定的事件对象设置为信号触发状态。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Clear</td>
<td class="org-left">ResetEvent</td>
<td class="org-left">将指定的事件对象设置为信号未触发状态</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Wait</td>
<td class="org-left">WaitForSingleObject</td>
<td class="org-left">等待指定的事件对象变为信号触发状态或者等待时长超过指定时间</td>
</tr>
</tbody>
</table>

<p>
Signal 主要用于将一个线程变为 sleep 状态。Workers 使用 idSysSignal.Wait() 将他们自己从操作系统调度器中移除，直到有新的 job 需要执行。<br />
</p>
</div>
</div>
<div id="outline-container-org9820868" class="outline-6">
<h6 id="org9820868">Mutexes (idSysMutex)</h6>
<div class="outline-text-6" id="text-org9820868">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Abstraction</th>
<th scope="col" class="org-left">Operations</th>
<th scope="col" class="org-left">Implemented with</th>
<th scope="col" class="org-left">Details</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">idSysMutex</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Critical Section Objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Lock</td>
<td class="org-left">EnterCriticalSection</td>
<td class="org-left">获取临界区域对象的所有权。当获得所有权时，该函数返回。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Unlock</td>
<td class="org-left">LeaveCriticalSection</td>
<td class="org-left">释放临界区域对象的所有权</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7118ada" class="outline-6">
<h6 id="org7118ada">Atomic operations (idSysInterlockedInteger)</h6>
<div class="outline-text-6" id="text-org7118ada">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Abstraction</th>
<th scope="col" class="org-left">Operations</th>
<th scope="col" class="org-left">Implemented with</th>
<th scope="col" class="org-left">Details</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">idSysInterlockedInteger</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Interlocked Variables</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Increment</td>
<td class="org-left">InterlockedIncrementAcquire</td>
<td class="org-left">以原子操作方式递增指定的 32 位整型变量。操作采用 acquire memory ordering 语义</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Decrement</td>
<td class="org-left">InterlockedIncrementRelease</td>
<td class="org-left">以原子操作方式递减指定的 32 位整型变量。操作采用 release memory ordering 语义</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-org9146f14" class="outline-4">
<h4 id="org9146f14">Architecture</h4>
<div class="outline-text-4" id="text-org9146f14">
<p>
ParalleleJobManager 是该多线程系统的大脑，由其生成工作线程并创建队列来存储 jobs。这种方式可以避免同步：将引擎的 job 发布系统划分为多个 sections（多个队列），仅由一个线程来访问，因此不需要同步。在 idTech4 引擎中，队列对应的类为 idParallelJobList。<br />
ParalleleJobManager 结构图如下：<br />
<img src="./doom3/doom3_idParallelJobManager.png" alt="doom3_idParallelJobManager.png" /><br />
</p>

<p>
在 Doom III BFG 中 job 发布系统只有三个部分：<br />
</p>
<ul class="org-ul">
<li>Renderer FrontEnd<br /></li>
<li>Renderer BackEnd<br /></li>
<li>Utilities<br /></li>
</ul>

<p>
按照 id software 在 2009 年的 siggraph 演讲中的介绍，idTech5 把 job 发布系统划分出了更多部分：<br />
</p>
<ul class="org-ul">
<li>Collision detection<br /></li>
<li>Animation blend<br /></li>
<li>Obstacle avoidance<br /></li>
<li>Virtual texturing<br /></li>
<li>Transparency processing (foliage, particles)<br /></li>
<li>Cloth simulation<br /></li>
<li>Water surface simulation<br /></li>
<li>Detail model generation (rocks, pebbles etc.)<br /></li>
</ul>

<p>
Tips: 在 2009 年的 ppt 中，还提到了延迟一帧的概念，在 Doom III BFG 的源代码中没有该实现。<br />
</p>

<p>
在 PC 平台，开始时会创建两个工作线程，在 XBox360 和 PS3 平台上会创建更多的工作线程。工作线程会不断运行并尝试获取一个 job。该过程不需要 mutexes 或 monitors，一个原子整型变量就可以实现不重复地发布 jobs。如下所示：<br />
<img src="./doom3/worker_atomic_sync.png" alt="worker_atomic_sync.png" /><br />
</p>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>currentJob 是 idParallelJobList 中变量<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9ad1e51" class="outline-4">
<h4 id="org9ad1e51">Usage</h4>
<div class="outline-text-4" id="text-org9ad1e51">
<p>
jobs 被隔离到多个 sections 中，这些 sections 只能被一个线程访问，因此，添加一个 job 时不需要同步。但是，提交一个 job 给 worker 系统时，确实涉及到互斥。下面代码是一个使用实例，该实例中渲染器尝试找到哪些光照和 view frustum 产生了相交:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">tr.frontEndJobList is a idParallelJobList object.</span>

<span style="color: #4f97d7; font-weight: bold;">for</span> ( <span style="color: #ce537a; font-weight: bold;">viewLight_t</span> * <span style="color: #7590db;">vLight</span> = tr.viewDef-&gt;viewLights; vLight != <span style="color: #a45bad;">NULL</span>; vLight = vLight-&gt;next )
{
    tr.frontEndJobList-&gt;AddJob( (<span style="color: #ce537a; font-weight: bold;">jobRun_t</span>)R_AddSingleLight, vLight );
}

tr.frontEndJobList-&gt;Submit();
tr.frontEndJobList-&gt;Wait();
</pre>
</div>

<p>
使用 job system 需要如下三步：<br />
</p>
<ul class="org-ul">
<li>AddJob : 不需要同步，job 被添加到一个列表中<br /></li>
<li>Submit : 互斥锁同步，每个工作线程将 JobList 添加到自己本地的环形缓冲区列表中（环形缓冲区列表中每个 item 存储一个 JobList）<br /></li>
<li>Wait   : 信号同步(代理给 OS 来实现同步)，等待工作线程完成工作。<br /></li>
</ul>

<p>
下图展示了第一步和第二步：<br />
<img src="./doom3/add_submit.png" alt="add_submit.png" /><br />
</p>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>idWorkerThread 对应的类其实为 idJobThread<br /></li>
<li>idJobThread 的 jobLists 成员为环形缓冲区。向环形缓冲区添加 jobList 时，需要使用互斥锁。(idJobThread::AddJobList 函数中，使用了 addJobMutex)<br /></li>
<li>idJobThread 的 firstJobList 成员为 unsinged int 类型的变量。用于记录 jobLists 中存储的 jobList 的起始索引，当 firstJobList 指示的 jobList 被 Worker 添加到本地栈上后，执行 firstJobList++<br /></li>
<li>idJobThread 的 lastJobList 成员为 unsinged int 类型的变量。用于记录 jobLists 中存储的 jobList 的末尾索引，当调用 AddJobList 向环形缓冲区中添加一个 jobList 时，执行 lastJobList++<br /></li>
<li>游戏中的 jobList 的数量是固定的，并且不会超过 MAX_JOBLISTS，因此，firstJobList 和 lastJobList 只增不减。<br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">idJobThread</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">idSysThread</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #ce537a; font-weight: bold;">void</span>                        <span style="color: #bc6ec5; font-weight: bold;">AddJobList</span>( <span style="color: #ce537a; font-weight: bold;">idParallelJobList_Threads</span> * <span style="color: #7590db;">jobList</span> );

<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">threadJobList_t</span>             <span style="color: #7590db;">jobLists</span>[MAX_JOBLISTS]; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cyclic buffer with job lists</span>
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span>                <span style="color: #7590db;">firstJobList</span>;           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">index of the last job list the thread grabbed</span>
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span>                <span style="color: #7590db;">lastJobList</span>;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">index where the next job list to work on will be added</span>
    <span style="color: #ce537a; font-weight: bold;">idSysMutex</span>                  <span style="color: #7590db;">addJobMutex</span>;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span>                <span style="color: #7590db;">threadNum</span>;

    <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">int</span>                 <span style="color: #bc6ec5; font-weight: bold;">Run</span>();
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org537b5f3" class="outline-4">
<h4 id="org537b5f3">How a Worker works</h4>
<div class="outline-text-4" id="text-org537b5f3">
<p>
Workers 都是无限循环。每次循环中会检查是否有更多的 JobList 已添加到环形缓冲区，如果是，则将引用复制到本地堆栈。<br />
</p>

<p>
使用线程本地堆栈存储 JobLists 地址，作为一种 anti-stalling 机制。如果工作线程 lock 一个 JobList 失败，它就会进入 RUN_STALLED 模式。通过对本地堆栈的 JobLists 列表进行遍历来找到另一个合适的 jobList 就可以从 STALLED 模式中恢复。这样，就避免了“Yielding”。<br />
</p>

<p>
有趣的是，一切都是在没有互斥机制的情况下完成的：只使用了原子操作。<br />
</p>


<div id="org2b2cf1d" class="figure">
<p><img src="./doom3/data_to_stack_copy.png" alt="data_to_stack_copy.png" /><br />
</p>
</div>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>Worker 对应的类为 idJobThread<br /></li>
<li>numJobLists currentJobList lastStalledJobList 都是 idJobThread::Run()函数的局部 int 类型变量<br /></li>
<li>threadJobListState 也为 idJobThread::Run()函数的局部变量。该变量中存储了 jobList 指针。<br /></li>
</ul>

<p>
注意：<br />
这里避免 mutexes 被推到了极致。尽管 mutexes 可以保证正确性，但是有时候并不会使用他们。例如：从堆到堆栈的 copy 操作使用没有互斥锁的 lastJobList 和 firstJobList。在环形缓冲区上添加一个 JobList 的操作和 copy 操作之间的同步就可以省略。这是错误的但没关系，work 线程只会进入 STALL 状态并等待一个环形缓冲区操作完成的信号。<br />
</p>
</div>
<div id="outline-container-orgc22528f" class="outline-5">
<h5 id="orgc22528f">The infinite loop</h5>
<div class="outline-text-5" id="text-orgc22528f">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #a45bad;">idJobThread</span>::<span style="color: #bc6ec5; font-weight: bold;">Run</span>()
{
    <span style="color: #ce537a; font-weight: bold;">threadJobListState_t</span> <span style="color: #7590db;">threadJobListState</span>[MAX_JOBLISTS];

    <span style="color: #4f97d7; font-weight: bold;">while</span> ( <span style="color: #a45bad;">!</span>IsTerminating() )
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">currentJobList</span> = 0;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fetch any new job lists and add them to the local list in threadJobListState</span>
        {}

        <span style="color: #4f97d7; font-weight: bold;">if</span>  ( lastStalledJobList &lt; 0 )
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">find the job list with the highest priority</span>
        <span style="color: #4f97d7; font-weight: bold;">else</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">try to hide the stall with a job from a list that has equal or higher priority</span>

            currentJobList = X;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">try running one or more jobs from the current job list</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">result</span> = threadJobListState[currentJobList].jobList-&gt;RunJobs( threadNum, threadJobListState[currentJobList], singleJob );

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Analyze how job running went</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>  ( ( result &amp; <span style="color: #a45bad;">idParallelJobList_Threads</span>::RUN_DONE ) != 0 ) {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">done with this job list so remove it from the local list (threadJobListState[currentJobList])</span>
        } <span style="color: #4f97d7; font-weight: bold;">else</span>  <span style="color: #4f97d7; font-weight: bold;">if</span>  ( ( result &amp; <span style="color: #a45bad;">idParallelJobList_Threads</span>::RUN_STALLED ) != 0 ) {
            lastStalledJobList = currentJobList;
        } <span style="color: #4f97d7; font-weight: bold;">else</span>  {
            lastStalledJobList = -1;
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc821241" class="outline-5">
<h5 id="orgc821241">Where jobs are run</h5>
<div class="outline-text-5" id="text-orgc821241">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #a45bad;">idParallelJobList</span>::<span style="color: #bc6ec5; font-weight: bold;">RunJobs</span>( <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span>  <span style="color: #7590db;">threadNum</span>, <span style="color: #ce537a; font-weight: bold;">threadJobListState_t</span> &amp; <span style="color: #7590db;">state</span>, <span style="color: #ce537a; font-weight: bold;">bool</span>  <span style="color: #7590db;">singleJob</span> )
{
    <span style="color: #4f97d7; font-weight: bold;">do</span>
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">try to lock to fetch a new job</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( fetchLock.Increment() == 1 )
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">grab a new job</span>
            state.nextJobIndex = currentJob.Increment() - 1;

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">release the fetch lock</span>
            fetchLock.Decrement();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">release the fetch lock</span>
            fetchLock.Decrement();
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">another thread is fetching right now so consider stalled</span>
            <span style="color: #4f97d7; font-weight: bold;">return</span>  ( result | RUN_STALLED );
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Run job</span>
        jobList[state.nextJobIndex].function( jobList[state.nextJobIndex].data );

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">if at the end of the job list we're done</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>  ( state.nextJobIndex &gt;= jobList.Num() ) {
            <span style="color: #4f97d7; font-weight: bold;">return</span>  ( result | RUN_DONE );
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span>  ( result | RUN_PROGRESS );
    }
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>singleJob);

    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org50cc57d" class="outline-3">
<h3 id="org50cc57d">Rendering</h3>
<div class="outline-text-3" id="text-org50cc57d">
</div>
<div id="outline-container-org9940b5e" class="outline-4">
<h4 id="org9940b5e">Architecture</h4>
<div class="outline-text-4" id="text-org9940b5e">
<p>
和 Doom3 的架构一样，渲染器仍然被分为两部分：Frontend 和 Backend。Frontend 确定哪些需要被绘制，Backend 花费大部分时间调用绘制命令并等待 GPU 执行这些命令，GPU 还会等待 VSync。<br />
</p>


<div id="org6ef1c95" class="figure">
<p><img src="./doom3/rendere_big_picture.png" alt="rendere_big_picture.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org600771f" class="outline-5">
<h5 id="org600771f">为什么需要多线程渲染？</h5>
<div class="outline-text-5" id="text-org600771f">
<p>
图形 API 调用可能会阻塞，将图形 API 调用和游戏逻辑放在一个线程时，图形 API 的阻塞会导致游戏逻辑也阻塞。下图是别人项目在实际运行两万次的过程中，Unity 渲染指令调用耗时峰值发生次数 TOP5 统计详情：<br />
<img src="./doom3/opengles_api_stall.jpg" alt="opengles_api_stall.jpg" /><br />
</p>

<p>
如果将图形 API 调用即渲染和游戏逻辑分离到不同线程，渲染线程阻塞时，游戏线程依然可以继续执行，从而就可以从整体上提升帧率。<br />
</p>

<p>
glFlush : OPENGL 是使用一条渲染管线线性处理命令的，一般情况下，我们提交给 OPENGL 的指令并不是马上送到驱动程序里执行的，而是放到一个缓冲区里面，等这个缓冲区满了再一次过发到驱动程序里执行；很多时候只有几条指令是填充不满那个缓冲区的，这就是说这些指令根本没有被发送到驱动里，所以我们要调用 glFlush 来强制把这些指令送到驱动里进行处理。<br />
<a id="org726a2d1"></a> glutSwapBuffers : 执行缓冲区交换。具体来说， glutSwapBuffers 将当前窗口使用的图层的 back 缓冲区的内容提升为 front 缓冲区的内容。 然后, back 缓冲区的内容变为未定义。窗口内容的更新通常发生在 monitor 的 Vertical blanking interval 期间，而不是在调用 glutSwapBuffers 之后立即发生。在 glutSwapBuffers 返回前，会有一个隐式的 glFlush 执行完成。调用 glutSwapBuffers 完成后，可以立即发布后续的 OpenGL 命令, 但是这些命令不会被执行，直到缓冲区交换完成。<br />
</p>

<ul class="org-ul">
<li>多线程渲染 <a href="https://zhuanlan.zhihu.com/p/44116722">https://zhuanlan.zhihu.com/p/44116722</a><br /></li>
<li>glutSwapBuffers <a href="https://www.opengl.org/resources/libraries/glut/spec3/node21.html">https://www.opengl.org/resources/libraries/glut/spec3/node21.html</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org25c0ff2" class="outline-5">
<h5 id="org25c0ff2">Frontend 和 Backend 工作流程</h5>
<div class="outline-text-5" id="text-org25c0ff2">
<p>
Renderer Frontend 逻辑在 Game/Draw 线程执行，该线程会一直执行 idGameThread::Run 函数。<br />
</p>

<p>
RendererFrontend 分析世界状态生成两种数据：<br />
</p>
<ul class="org-ul">
<li>中间表示数据: tr_local.h 文件中声明了 idRenderSystemLocal 类型变量 tr，idRenderSystemLocal 类包含一个 viewDef_t 类型成员 viewDef 用于存储中间数据。tr_frontend_main.cpp 文件中的 R_RenderView 中执行填充 viewDef 逻辑。<br /></li>
<li>中间交互数据: RenderWorld_local.h 文件中的 idRenderWorldLocal 类包含一个 idInteraction** 类型成员 interactionTable 用于存储交互数据。Common_load.cpp 文件中的 idCommonLocal::ExecuteMapChange 会调用 idRenderWorldLocal::GenerateAllInteractions() 来填充 interactionTable 数据。<br /></li>
</ul>

<p>
下面代码是 frontend 生成中间表示数据的部分<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Common.cpp &#25991;&#20214; idCommonLocal::Init &#20989;&#25968;&#20250;&#35843;&#29992; gameThread.StartWorkerThread( "Game/Draw", CORE_1B, THREAD_BELOW_NORMAL, 0x100000 ); &#24320;&#21551; Game &#32447;&#31243;</span>
- <span style="color: #a45bad;">idGameThread</span>::Run
  - <span style="color: #a45bad;">idCommonLocal</span>::Draw
    - <span style="color: #a45bad;">idGame</span>::Draw
      - <span style="color: #a45bad;">idPlayerView</span>::RenderPlayerView
        - <span style="color: #a45bad;">idPlayerView</span>::SingleView
          - <span style="color: #a45bad;">idRenderWorld</span>::RenderScene
            - build params
            - ::R_RenderView(params)    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">This is the frontend (tr_frontend_main.cpp)</span>
              {
                  <span style="color: #ce537a; font-weight: bold;">R_SetupViewMatrix</span>
                  <span style="color: #7590db;">R_SetupProjectionMatrix</span>

                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">identify all the visible portal areas, and create view lights and view entities for all the the entityDefs and lightDefs that are in the visible portal areas</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; tr.viewDef.viewLights &#21644; tr.viewDef.viewEntitys</span>
                  <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">idRenderWorldLocal</span> *&gt;(parms-&gt;renderWorld)-&gt;FindViewLightsAndEntities()
                  {
                      <span style="color: #ce537a; font-weight: bold;">PointInArea</span>              <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Walk the BSP and find the current Area</span>
                      <span style="color: #7590db;">FlowViewThroughPortals</span>   <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Recursively pass portals to find lights and entities interacting with the view.</span>
                  }

                  tr.frontEndJobList-&gt;Wait();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wait for any shadow volume jobs from the previous frame to finish</span>
                  R_AddLights();               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">add any pre-generated light shadows, and calculate the light shader values</span>
                  R_AddModels();               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">adds ambient surfaces and create any necessary interaction surfaces to add to the light lists</span>

                  <span style="color: #ce537a; font-weight: bold;">R_AddInGameGuis</span>(...);        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">build up the GUIs on world surfaces</span>
                  R_OptimizeViewLightsList();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">any viewLight that didn't have visible surfaces can have it's shadows removed</span>
                  <span style="color: #ce537a; font-weight: bold;">R_SortDrawSurfs</span>(...);        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sort all the ambient surfaces for translucency ordering</span>
                  <span style="color: #ce537a; font-weight: bold;">R_GenerateSubViews</span>

                  <span style="color: #7590db;">R_AddDrawViewCmd</span>();          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">add the rendering commands for this viewDef</span>
              }
</pre>
</div>

<p>
下面代码是生成中间交互数据的部分<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render backend thread</span>
- WinMain
  - <span style="color: #a45bad;">idCommonLocal</span>::Frame()
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;&#38745;&#24577;&#20013;&#38388;&#20132;&#20114;&#25968;&#25454; idRenderWorldLocal::interactionTable</span>
    - <span style="color: #a45bad;">idCommonLocal</span>::ExecuteMapChange
      - <span style="color: #a45bad;">idRenderWorldLocal</span>::InitFromMap
        - <span style="color: #a45bad;">idRenderWorldLocal</span>::ReadBinaryModel
          - <span style="color: #a45bad;">idRenderModelMD5</span>::LoadBinaryModel
            - vertexCache.AllocStaticVertex(deform.verts, ALIGN(..., VERTEX_CACHE_ALIGN ) );
      - <span style="color: #a45bad;">idRenderWorldLocal</span>::GenerateAllInteractions()
        - idInteraction** R_ClearedStaticAlloc(size)   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;interactionTable&#20998;&#37197;&#20869;&#23384; interactionTable&#20013;&#23384;&#20648;&#30340;&#26159;idInteraction* &#25351;&#38024;</span>
        - <span style="color: #a45bad;">idInteraction</span>::AllocAndLink(edef, ldef)
          - interaction = <span style="color: #a45bad;">idRenderWorldLocal</span>::interactionAllocator                     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; idInteraction&#20998;&#37197;&#20869;&#23384;</span>
          - <span style="color: #a45bad;">idRenderEntityLocal</span>::firstInteraction/lastInteraction = interaction        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805;&#26356;&#26032; idRenderEntityLocal</span>
          - <span style="color: #a45bad;">idRenderLightLocal</span>::firstInteraction/lastInteraction  = interaction        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805;&#26356;&#26032; idRenderLightLocal</span>
          - interaction.entityDef = edef; interaction.lightDef  = ldef;                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; interaction &#30340; entityDef lightDef</span>
          - interactionTable[index] = interaction                                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805;/&#26356;&#26032; interactionTable &#20869;&#23481;</span>
        - <span style="color: #a45bad;">idInteraction</span>::UnlinkAndFree
          - interactionTable[index] = <span style="color: #a45bad;">NULL</span>                                             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37325;&#32622; interactionTable &#25351;&#23450;&#39033;&#20026; NULL</span>
          - <span style="color: #a45bad;">idRenderWorldLocal</span>::interactionAllocator.Free(interaction);                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37322;&#25918; interaction</span>
        - <span style="color: #a45bad;">idInteraction</span>::CreateStaticInteraction
          - interaction.surfaces                                                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; interaction &#30340; entityDef lightDef</span>
          - <span style="color: #a45bad;">idInteraction</span>::MakeEmpty
            - interactionTable[index] = INTERACTION_EMPTY                              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; interactionTable &#20869;&#23481;</span>
      - <span style="color: #a45bad;">idRenderSystemLocal</span>::EndLevelLoad
          - <span style="color: #a45bad;">idRenderModelManagerLocal</span>::EndLevelLoad
            - R_CreateStaticBuffersForTri
              - vertexCache.AllocStaticIndex( tri.indexes, ALIGN(..., INDEX_CACHE_ALIGN ) );
              - vertexCache.AllocStaticVertex( tri.verts, ALIGN(..., VERTEX_CACHE_ALIGN ) );
              - vertexCache.AllocStaticVertex( tri.staticShadowVertexes, shadowSize );

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render frontend thread</span>
- R_AddModels
  - R_AddSingleModel
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#21160;&#24577;&#29289;&#20307;</span>
    - R_EntityDefDynamicModel
    - <span style="color: #a45bad;">idRenderMatrix</span>::CullBoundsToMVP( vEntity-&gt;mvp, tris-&gt;bounds );               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#27169;&#22411;&#21487;&#35265;&#24615;</span>
    - vertexCache.AllocIndex(tri-&gt;indexes, ALIGN(..., INDEX_CACHE_ALIGN ) );       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#20256;&#32034;&#24341;&#25968;&#25454;</span>
    - vertexCache.AllocVertex(tri-&gt;verts, ALIGN(..., VERTEX_CACHE_ALIGN ) );       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#20256;&#39030;&#28857;&#25968;&#25454;</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#38745;&#24577;&#20013;&#38388;&#20132;&#20114;&#25968;&#25454;</span>
    - staticInteractions[numContactedLights] = world-&gt;interactionTable[];          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31579;&#20986;&#25668;&#20687;&#26426;&#21487;&#35265;&#30340;&#20132;&#20114;</span>
    - surfInter = &amp;interaction-&gt;surfaces[surfaceNum];                              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24471;&#21040;&#23545;&#24212;&#30340;surf</span>
    - surfInter-&gt;lightTrisIndexCache; surfInter-&gt;shadowIndexCache;                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; viewEntity_t::drawSurfs</span>
  - R_LinkDrawSurfToView                                                           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#21069;&#19968;&#27493;&#24471;&#21040;&#30340; drawSurfs &#36716;&#31227;&#21040; tr.viewDef&#65288;viewDef_t::drawSurfs&#65289;</span>
</pre>
</div>

<p>
下面代码是中间表示数据和中间交互数据相关的数据结构:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#20854;&#20013;&#19968;&#31181; render frontend &#29983;&#25104;&#30340;&#32472;&#21046;&#21629;&#20196;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">drawSurfsCommand_t</span>
{
    <span style="color: #ce537a; font-weight: bold;">renderCommand_t</span>     <span style="color: #7590db;">commandId</span>;
    <span style="color: #ce537a; font-weight: bold;">renderCommand_t</span> *   <span style="color: #7590db;">next</span>;
    <span style="color: #ce537a; font-weight: bold;">viewDef_t</span> *         <span style="color: #7590db;">viewDef</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">viewDefs are allocated on the frame temporary stack memory</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">viewDef_t</span> {
    <span style="color: #ce537a; font-weight: bold;">renderView_t</span>        <span style="color: #7590db;">renderView</span>;             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">specified in the call to DrawScene()</span>

    <span style="color: #ce537a; font-weight: bold;">float</span>               <span style="color: #7590db;">projectionMatrix</span>[16];
    <span style="color: #ce537a; font-weight: bold;">idRenderMatrix</span>      <span style="color: #7590db;">projectionRenderMatrix</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tech5 version of projectionMatrix</span>
    <span style="color: #ce537a; font-weight: bold;">viewEntity_t</span>        <span style="color: #7590db;">worldSpace</span>;

    <span style="color: #ce537a; font-weight: bold;">idRenderWorldLocal</span> *<span style="color: #7590db;">renderWorld</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">drawSurfs are the visible surfaces of the viewEntities, sorted</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">by the material sort parameter</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> **       <span style="color: #7590db;">drawSurfs</span>;              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we don't use an idList for this, because</span>
    <span style="color: #ce537a; font-weight: bold;">int</span>                 <span style="color: #7590db;">numDrawSurfs</span>;           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">it is allocated in frame temporary memory</span>
    <span style="color: #ce537a; font-weight: bold;">int</span>                 <span style="color: #7590db;">maxDrawSurfs</span>;           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">may be resized</span>

    <span style="color: #ce537a; font-weight: bold;">viewLight_t</span> *       <span style="color: #7590db;">viewLights</span>;             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">chain of all viewLights effecting view</span>
    <span style="color: #ce537a; font-weight: bold;">viewEntity_t</span> *      <span style="color: #7590db;">viewEntitys</span>;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">chain of all viewEntities effecting view, including off screen ones casting shadows</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">viewLights are allocated on the frame temporary stack memory</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">a viewLight contains everything that the back end needs out of an idRenderLightLocal,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">which the front end may be modifying simultaniously if running in SMP mode.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">a viewLight may exist even without any surfaces, and may be relevent for fogging,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">but should never exist if its volume does not intersect the view frustum</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">viewLight_t</span> {
    <span style="color: #ce537a; font-weight: bold;">viewLight_t</span> *           <span style="color: #7590db;">next</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">back end should NOT reference the lightDef, because it can change when running SMP</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderLightLocal</span> *    <span style="color: #7590db;">lightDef</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">R_AddSingleLight builds this list of entities that need to be added</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to the viewEntities list because they potentially cast shadows into</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the view, even though the aren't directly visible</span>
    <span style="color: #ce537a; font-weight: bold;">shadowOnlyEntity_t</span> *    <span style="color: #7590db;">shadowOnlyViewEntities</span>;

    <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">interactionState_t</span> {
        <span style="color: #7590db;">INTERACTION_UNCHECKED</span>,
        <span style="color: #7590db;">INTERACTION_NO</span>,
        <span style="color: #7590db;">INTERACTION_YES</span>
    };
    <span style="color: #ce537a; font-weight: bold;">byte</span> *                  <span style="color: #7590db;">entityInteractionState</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[numEntities]</span>

    <span style="color: #ce537a; font-weight: bold;">idVec3</span>                  <span style="color: #7590db;">globalLightOrigin</span>;          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">global light origin used by backend</span>
    <span style="color: #ce537a; font-weight: bold;">idPlane</span>                 <span style="color: #7590db;">lightProject</span>[4];            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">light project used by backend</span>
    <span style="color: #ce537a; font-weight: bold;">idPlane</span>                 <span style="color: #7590db;">fogPlane</span>;                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fog plane for backend fog volume rendering</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderMatrix</span>          <span style="color: #7590db;">inverseBaseLightProject</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the matrix for deforming the 'zeroOneCubeModel' to exactly cover the light volume in world space</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">idMaterial</span> *      <span style="color: #7590db;">lightShader</span>;                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">light shader used by backend</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> *           <span style="color: #7590db;">shaderRegisters</span>;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">shader registers used by backend</span>
    <span style="color: #ce537a; font-weight: bold;">idImage</span> *               <span style="color: #7590db;">falloffImage</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">falloff image used by backend</span>

    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">globalShadows</span>;              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">shadow everything</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">localInteractions</span>;          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don't get local shadows</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">localShadows</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don't shadow local surfaces</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">globalInteractions</span>;         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get shadows from everything</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">translucentInteractions</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">translucent interactions don't get shadows</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">R_AddSingleLight will build a chain of parameters here to setup shadow volumes</span>
    <span style="color: #ce537a; font-weight: bold;">preLightShadowVolumeParms_t</span> *   <span style="color: #7590db;">preLightShadowVolumes</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">a viewEntity is created whenever a idRenderEntityLocal is considered for inclusion</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in the current view, but it may still turn out to be culled.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">viewEntity are allocated on the frame temporary stack memory</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">a viewEntity contains everything that the back end needs out of a idRenderEntityLocal,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">which the front end may be modifying simultaneously if running in SMP mode.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">A single entityDef can generate multiple viewEntity_t in a single frame, as when seen in a mirror</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">viewEntity_t</span> {
    <span style="color: #ce537a; font-weight: bold;">viewEntity_t</span> *          <span style="color: #7590db;">next</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">back end should NOT reference the entityDef, because it can change when running SMP</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderEntityLocal</span> *   <span style="color: #7590db;">entityDef</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">for scissor clipping, local inside renderView viewport</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scissorRect.Empty() is true if the viewEntity_t was never actually</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">seen through any portals, but was created for shadow casting.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">a viewEntity can have a non-empty scissorRect, meaning that an area</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">that it is in is visible, and still not be visible.</span>
    <span style="color: #ce537a; font-weight: bold;">idScreenRect</span>            <span style="color: #7590db;">scissorRect</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span>                   <span style="color: #7590db;">modelMatrix</span>[16];        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">local coords to global coords</span>
    <span style="color: #ce537a; font-weight: bold;">float</span>                   <span style="color: #7590db;">modelViewMatrix</span>[16];    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">local coords to eye coords</span>

    <span style="color: #ce537a; font-weight: bold;">idRenderMatrix</span>          <span style="color: #7590db;">mvp</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">parallelAddModels will build a chain of surfaces here that will need to</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">be linked to the lights or added to the drawsurf list in a serial code section</span>
    <span style="color: #ce537a; font-weight: bold;">drawSurf_t</span> *            <span style="color: #7590db;">drawSurfs</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">R_AddSingleModel will build a chain of parameters here to setup shadow volumes</span>
    <span style="color: #ce537a; font-weight: bold;">staticShadowVolumeParms_t</span> *     <span style="color: #7590db;">staticShadowVolumes</span>;
    <span style="color: #ce537a; font-weight: bold;">dynamicShadowVolumeParms_t</span> *    <span style="color: #7590db;">dynamicShadowVolumes</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">idInteraction</span> {
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this may be 0 if the light and entity do not actually intersect</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-1 = an untested interaction</span>
    <span style="color: #ce537a; font-weight: bold;">int</span>                     <span style="color: #7590db;">numSurfaces</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">if there is a whole-entity optimized shadow hull, it will</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">be present as a surfaceInteraction_t with a NULL ambientTris, but</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">possibly having a shader to specify the shadow sorting order</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(FIXME: actually try making shadow hulls?  we never did.)</span>
    <span style="color: #ce537a; font-weight: bold;">surfaceInteraction_t</span> *  <span style="color: #7590db;">surfaces</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get space from here, if NULL, it is a pre-generated shadow volume from dmap</span>
    <span style="color: #ce537a; font-weight: bold;">idRenderEntityLocal</span> *   <span style="color: #7590db;">entityDef</span>;
    <span style="color: #ce537a; font-weight: bold;">idRenderLightLocal</span> *    <span style="color: #7590db;">lightDef</span>;

    <span style="color: #ce537a; font-weight: bold;">idInteraction</span> *         <span style="color: #7590db;">lightNext</span>;              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">for lightDef chains</span>
    <span style="color: #ce537a; font-weight: bold;">idInteraction</span> *         <span style="color: #7590db;">lightPrev</span>;
    <span style="color: #ce537a; font-weight: bold;">idInteraction</span> *         <span style="color: #7590db;">entityNext</span>;             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">for entityDef chains</span>
    <span style="color: #ce537a; font-weight: bold;">idInteraction</span> *         <span style="color: #7590db;">entityPrev</span>;

    <span style="color: #ce537a; font-weight: bold;">bool</span>                    <span style="color: #7590db;">staticInteraction</span>;      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">true if the interaction was created at map load time in static buffer space</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orge1ee246" class="outline-5">
<h5 id="orge1ee246">Render Frontend 和 Backend 的同步</h5>
<div class="outline-text-5" id="text-orge1ee246">
<ul class="org-ul">
<li>smpFrameData 是包含两个 idFrameData 对象的数组，render frontend 和 render backend 会交替使用数组中两个 idFrameData 对象。render backend 等待 GPU 空闲后，交换 render frontend 和 render backend 所使用的 idFrameData 对象。紧接着触发 render frontend 工作。<br />
<ul class="org-ul">
<li>render frontend 执行游戏逻辑，生成渲染命令将其保存到 idFrameData A 中。<br /></li>
<li>render backend 执行 idFrameData B 中存储的渲染命令。<br /></li>
</ul></li>
<li>render backend 等待 frontend 执行完成<br /></li>
</ul>

<p>
Renderer Backend 逻辑在主线程执行。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render backend thread</span>
- WinMain
  - <span style="color: #a45bad;">idCommonLocal</span>::Frame()
    - <span style="color: #a45bad;">idRenderSystemLocal</span>::SwapCommandBuffers
      - SwapCommandBuffers_FinishRendering()                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#20043;&#21069;&#30340;commandBuffers &#25191;&#34892;&#23436;&#25104;</span>
        - GL_BlockingSwapBuffers()
          - GLimp_SwapBuffers()
      - SwapCommandBuffers_FinishCommandBuffers()                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36820;&#22238;&#21069;&#19968;&#24103; render front&#29983;&#25104;&#30340; commandBuffer</span>
          - R_ToggleSmpFrame()                                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20999;&#25442;commandBuffer (&#20132;&#26367;&#20351;&#29992;&#20004;&#20010;frameData &#23545;&#35937;)</span>
    - gameThread.RunGameAndDraw();
      - gameThread.WaitForThread()                                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453; frontend &#25191;&#34892;&#23436;&#25104; (&#36825;&#37324; signalWorkerDone &#20449;&#21495;&#24212;&#35813;&#24050;&#32463;&#26159;&#35302;&#21457;&#29366;&#24577;&#65292;&#22240;&#27492;&#35813; Wait &#20250;&#31435;&#21363;&#36820;&#22238;)</span>
        - signalWorkerDone.Wait( <span style="color: #a45bad;">idSysSignal</span>::WAIT_INFINITE )
      - <span style="color: #a45bad;">idGameThread</span>::SignalWork()                                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35302;&#21457; frontend &#32487;&#32493;&#25191;&#34892;</span>
        - moreWorkToDo = <span style="color: #a45bad;">true</span>;
        - signalWorkerDone.Clear();
        - signalMoreWorkToDo.Raise();
    - <span style="color: #a45bad;">idRenderSystemLocal</span>::RenderCommandBuffers                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28210;&#26579;&#21069;&#19968;&#24103;&#35760;&#24405;&#30340; commandBuffer</span>
      - RB_ExecuteBackEndCommands
        - RB_DrawView(cmds, 0)
          - RB_DrawViewInternal(cmd-&gt;viewDef, stereoEye)
    - gameThread.WaitForThread()                                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453; frontend &#25191;&#34892;&#23436;&#25104; ()</span>
        - signalWorkerDone.Wait( <span style="color: #a45bad;">idSysSignal</span>::WAIT_INFINITE )
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render frontend thread</span>
<span style="color: #a45bad;">idSysThread</span>::<span style="color: #bc6ec5; font-weight: bold;">ThreadProc</span>() <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Thread.cpp</span>
{
    <span style="color: #4f97d7; font-weight: bold;">for</span>( ; ; ) {
        thread-&gt;signalMutex.Lock();
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( thread-&gt;moreWorkToDo )
        {
            thread-&gt;moreWorkToDo = <span style="color: #a45bad;">false</span>;
            thread-&gt;signalMoreWorkToDo.Clear();                                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26412;&#27425;&#24490;&#29615;&#21363;&#23558;&#23436;&#25104;&#24037;&#20316;&#65292;&#22240;&#27492;&#35774;&#32622;signalMoreWorkToDo &#20449;&#21495;&#20026;&#26410;&#35302;&#21457;&#65292;&#21363;&#27809;&#26377;&#26356;&#22810;&#24037;&#20316;&#38656;&#35201;&#20570;</span>
            thread-&gt;signalMutex.Unlock();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            thread-&gt;signalWorkerDone.Raise();                                     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21069;&#19968;&#27425;&#24490;&#29615;&#23436;&#25104;&#20102;&#24037;&#20316;&#65292;&#22240;&#27492;&#35774;&#32622; signalWorkerDone &#20449;&#21495;&#20026;&#35302;&#21457;&#65292;&#21363;&#24037;&#20316;&#23436;&#25104;</span>
            thread-&gt;signalMutex.Unlock();
            thread-&gt;signalMoreWorkToDo.Wait( <span style="color: #a45bad;">idSysSignal</span>::WAIT_INFINITE );        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38459;&#22622;&#31561;&#24453;&#26356;&#22810;&#24037;&#20316;</span>
            <span style="color: #4f97d7; font-weight: bold;">continue</span>;
        }

        <span style="color: #4f97d7; font-weight: bold;">if</span> ( thread-&gt;isTerminating ) {
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }

        retVal = thread-&gt;Run();                                                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892; render frontend &#24037;&#20316;</span>
    }
}

- <span style="color: #a45bad;">idGameThread</span>::Run
  - <span style="color: #a45bad;">idGameLocal</span>::RunFrame                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">game &#26356;&#26032;&#36923;&#36753;</span>
    - SortActiveEntityList()
    - entity-&gt;GetPhysics()-&gt;UpdateTime(time)
    - RunEntityThink
    - entity-&gt;activeNode.Remove
  - <span style="color: #a45bad;">idCommonLocal</span>::Draw()                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render frontend &#29983;&#25104;&#20013;&#38388;&#34920;&#31034;&#25968;&#25454;&#12289;&#20013;&#38388;&#20132;&#20114;&#25968;&#25454;</span>
    - R_RenderView(params)                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(tr_frontend_main.cpp)</span>
      - R_AddDrawViewCmd                        
        - R_GetCommandBuffer                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#26032;&#29983;&#25104;&#30340;&#28210;&#26579;&#21629;&#20196;&#28155;&#21152;&#21040; frameData &#20013;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf7048a2" class="outline-5">
<h5 id="orgf7048a2">CPU 和 GPU 如何同步？</h5>
<div class="outline-text-5" id="text-orgf7048a2">
<p>
利用 OpenGL 的 Sync Object 可以查询 GPU 是否已经将 render backend 提交的绘制命令执行完毕。但是，设备的驱动可能并不支持 Sync Object，此时可以使用 glFinish 来阻塞等待 GPU 渲染完成。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">if</span> ( glConfig.syncAvailable ) {
    swapIndex ^= 1;

    <span style="color: #4f97d7; font-weight: bold;">if</span> ( qglIsSync( renderSync[swapIndex] ) ) {                                               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; renderSync[swapIndex] &#26159;&#21542;&#26159;&#21516;&#27493;&#23545;&#35937;</span>
        qglDeleteSync( renderSync[swapIndex] );                                               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21024;&#38500;&#21516;&#27493;&#23545;&#35937;</span>
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">draw something tiny to ensure the sync is after the swap</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">start</span> = Sys_Milliseconds();
    qglScissor( 0, 0, 1, 1 );
    qglEnable( GL_SCISSOR_TEST );
    qglClear( GL_COLOR_BUFFER_BIT );
    renderSync[swapIndex] = qglFenceSync( GL_SYNC_GPU_COMMANDS_COMPLETE, 0 );                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314;&#21516;&#27493;&#23545;&#35937;</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">end</span> = Sys_Milliseconds();
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( r_showSwapBuffers.GetBool() &amp;&amp; end - start &gt; 1 ) {
        common-&gt;Printf( <span style="color: #2d9574;">"%i msec to start fence\n"</span>, end - start );
    }

    <span style="color: #ce537a; font-weight: bold;">GLsync</span>  <span style="color: #7590db;">syncToWaitOn</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( r_syncEveryFrame.GetBool() ) {
        syncToWaitOn = renderSync[swapIndex];
    } <span style="color: #4f97d7; font-weight: bold;">else</span> {
        syncToWaitOn = renderSync[<span style="color: #a45bad;">!</span>swapIndex];
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> ( qglIsSync( syncToWaitOn ) ) {
        <span style="color: #4f97d7; font-weight: bold;">for</span> ( <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">r</span> = GL_TIMEOUT_EXPIRED; r == GL_TIMEOUT_EXPIRED; ) {
            r = qglClientWaitSync( syncToWaitOn, GL_SYNC_FLUSH_COMMANDS_BIT, 1000 * 1000 );   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#21516;&#27493;&#23545;&#35937;&#23436;&#25104;</span>
        }
    }
}
</pre>
</div>

<ul class="org-ul">
<li>glFinsh <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml</a><br /></li>
<li>Sync Object <a href="https://www.khronos.org/opengl/wiki/Sync_Object">https://www.khronos.org/opengl/wiki/Sync_Object</a><br /></li>
<li>图形渲染中关于 CPU 和 GPU 的一些问题？ <a href="https://www.zhihu.com/question/59732134/answer/168975408">https://www.zhihu.com/question/59732134/answer/168975408</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org6968cac" class="outline-5">
<h5 id="org6968cac">CPU 和 GPU 数据传输</h5>
<div class="outline-text-5" id="text-org6968cac">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Material Property</td>
<td class="org-left">rpColor</td>
</tr>

<tr>
<td class="org-left">Object Property</td>
<td class="org-left">rpModelMatrixX rpModelMatrixY rpModelMatrixZ</td>
</tr>

<tr>
<td class="org-left">Global Property</td>
<td class="org-left">rpLocalViewOrigin</td>
</tr>

<tr>
<td class="org-left">Mesh Data</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Texture Data</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org948e9ff" class="outline-5">
<h5 id="org948e9ff">GPU 和 显示器同步</h5>
<div class="outline-text-5" id="text-org948e9ff">
<p>
开启 vsync 后，swapbuffers 会和显示器的 vertical blanks 进行同步。swapbuffers 执行完毕后，可以继续发布 opengl 命令，但是，这些命令都会被放到缓冲区，等待 front back buffer 真正交换完毕后(GPU 会等待一个 v-blank 来进行缓冲区交换)，才会执行。<br />
</p>

<ul class="org-ul">
<li><a href="https://www.khronos.org/opengl/wiki/Swap_Interval">https://www.khronos.org/opengl/wiki/Swap_Interval</a><br /></li>
<li><a href="#org726a2d1">glutSwapBuffers</a><br /></li>
<li>游戏锁 60fps 和 60hz 屏幕开垂直同步有什么区别？ vsync <a href="https://www.zhihu.com/question/310558703">https://www.zhihu.com/question/310558703</a><br /></li>
<li><a href="https://stackoverflow.com/questions/589064/how-to-enable-vertical-sync-in-opengl">https://stackoverflow.com/questions/589064/how-to-enable-vertical-sync-in-opengl</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org14d7910" class="outline-5">
<h5 id="org14d7910">shader</h5>
<div class="outline-text-5" id="text-org14d7910">
<p>
shader 目录: DOOM-3-BFG\base\renderprogs<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DOOM-3-BFG\base\renderprogs\bumpyenvironment_skinned.vertex</td>
<td class="org-left">gpu skin vertex shader</td>
</tr>

<tr>
<td class="org-left">DOOM-3-BFG\base\renderprogs\bumpyenvironment_skinned.pixel</td>
<td class="org-left">gpu skin pixel shader</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org2b7f1c2" class="outline-4">
<h4 id="org2b7f1c2">Threading Model</h4>
<div class="outline-text-4" id="text-org2b7f1c2">
<ul class="org-ul">
<li>默认情况下，前端和后端都在自己的线程中运行。<br /></li>
<li><p>
前端使用 Worker 系统来并行执行下面三个任务：<br />
</p>
<ol class="org-ol">
<li>交互检测： 找到产生相互的灯光（和视锥有交叉的灯光）<br /></li>
</ol>
<ol class="org-ol">
<li>交互检测： 找到可见的模型以及和前一步选出的灯光有交互的模型（用于阴影）<br /></li>
<li>阴影生成： 构建动态阴影体<br /></li>
</ol></li>
</ul>


<div id="org3e4e2c9" class="figure">
<p><img src="./doom3/renderer_threading_model.png" alt="renderer_threading_model.png" /><br />
</p>
</div>

<p>
具体执行逻辑如下：<br />
</p>
<ol class="org-ol">
<li>Find lights(R_AddLights): 构建一个链表，对元素进行标记，清除指定标记的元素<br />
<ul class="org-ul">
<li>Build : frontend 线程构建一个链表，其中包含了场景中的所有灯光<br /></li>
<li>Mark : 所有线程都运行起来，并执行 JobSystem 中的 jobs，工作线程并行地对灯光进行标记。(产生交互的即可见的标记为 1，没有产生交互的即不可见的标记为 0)<br /></li>
<li>Sweep : frontend 线程将链表中被标记为不可见的灯光移除<br /></li>
</ul></li>
<li>Find models(R_AddModels): 每个 job 处理一个特定模型。当所有工作线程都完成后，最后由单个线程将顶点数据组合起来<br /></li>
<li>Build Dynamic Shadow Volumes(R_AddModels): 和前一步一样，每个 job 存储一个模型对应的 shadow volumes。最后由单个线程将结果组合起来。<br /></li>
</ol>
</div>
</div>

<div id="outline-container-org6f16431" class="outline-4">
<h4 id="org6f16431">One Path</h4>
<div class="outline-text-4" id="text-org6f16431">
<p>
以前的渲染器具有许多渲染路径：每个 Nvidia 和 ATI GPU 一个。 该实现不是很优雅，因为它依赖于 switch case。<br />
</p>

<p>
新的渲染器新加了一个抽象层，该抽象层的方法名称基于 OpenGL 的方法名称。 抽象层的具体实现有如下三种：<br />
</p>
<ul class="org-ul">
<li>OpenGL (PC)<br /></li>
<li>DirectX (Xbox360)<br /></li>
<li>GCM (PS3)<br /></li>
</ul>
<p>
项目链接器决定使用哪个实现。<br />
</p>


<div id="org71ea6c6" class="figure">
<p><img src="./doom3/renderer_abstraction.png" alt="renderer_abstraction.png" /><br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org4757e8e" class="outline-2">
<h2 id="org4757e8e">参考资料</h2>
<div class="outline-text-2" id="text-org4757e8e">
<ul class="org-ul">
<li>DOOM3 源码 <a href="https://github.com/id-Software/DOOM-3">https://github.com/id-Software/DOOM-3</a><br /></li>
<li>DOOM3 SDK 相关文档备份 <a href="https://github.com/dhewm/iddevnet">https://github.com/dhewm/iddevnet</a><br /></li>
<li>DOOM3 BFG 源码 <a href="https://github.com/id-Software/DOOM-3-BFG">https://github.com/id-Software/DOOM-3-BFG</a><br /></li>
<li>Doom3 source code review <a href="https://fabiensanglard.net/doom3/index.php">https://fabiensanglard.net/doom3/index.php</a><br /></li>
<li>DOOM3 BFG source code review <a href="https://fabiensanglard.net/doom3_bfg/index.php">https://fabiensanglard.net/doom3_bfg/index.php</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'Doom3 Engine',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
