<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-21 Wed 23:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OpenGL</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">OpenGL</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgca3b8cc">OpenGL Programming Guide ver8</a>
<ul>
<li><a href="#orgee278ab">Introduction to OpenGL</a>
<ul>
<li><a href="#org8ff0e36">一 搭建开发环境</a></li>
<li><a href="#org99f0d52">二 OpenGL 渲染管线</a>
<ul>
<li><a href="#orgb3ae996">1 准备向 OpenGL 传输数据</a></li>
<li><a href="#org329bd44">2 将数据传输到 OpenGL</a></li>
<li><a href="#org7c5f331">3 顶点着色</a></li>
<li><a href="#org599367c">4 细分着色</a></li>
<li><a href="#org3d41735">5 几何着色</a></li>
<li><a href="#orgebd51a2">6 图元装配</a></li>
<li><a href="#org3f9341b">7 剪切</a></li>
<li><a href="#org7027c51">8 光栅化</a></li>
<li><a href="#orgbe091f3">9 片元着色</a></li>
<li><a href="#orgf3b7c0d">10 逐片元的操作 (lesson 4)</a></li>
</ul>
</li>
<li><a href="#org361dbdd">参考资料</a></li>
</ul>
</li>
<li><a href="#orgcb07759">Shader Fundamentals</a>
<ul>
<li><a href="#org7cdb164">Shaders and OpenGL</a></li>
<li><a href="#org7e369e2">OpenGL's Programmable pipline</a>
<ul>
<li><a href="#org9d9ab66">4.3 版本的图形管线包含 4 个阶段：</a></li>
<li><a href="#org18577c2">数据传输</a></li>
</ul>
</li>
<li><a href="#org9f9198a">Shading Language</a>
<ul>
<li><a href="#orgbf8cffc">类型转换</a></li>
<li><a href="#org12bc37b">聚合类型</a></li>
<li><a href="#org0cffb9c">Structrues</a></li>
<li><a href="#org475b4a6">Array</a></li>
<li><a href="#org8546bf3">Storage Qualifiers</a></li>
<li><a href="#org8b3c37b">Function</a></li>
<li><a href="#org8af3f30">计算不变性</a></li>
<li><a href="#orgec76246">Shader Preprocessor</a></li>
</ul>
</li>
<li><a href="#org2f159b6">Interface Blocks</a>
<ul>
<li><a href="#org704b318">概述</a></li>
<li><a href="#org79c53b5">Uniform Block Layout Control</a></li>
<li><a href="#org7504a5e">在 app 中访问 Uniform blocks</a></li>
<li><a href="#org8d7c9fc">buffer blocks</a></li>
<li><a href="#org15844ef">In/Out Blocks</a></li>
</ul>
</li>
<li><a href="#org835d4ce">Compiling Shaders</a></li>
<li><a href="#org1fda427">Shader Subroutines</a>
<ul>
<li><a href="#org4d6d1b3">GLSL Subroutine Setup</a></li>
<li><a href="#orgc7c3963">Selecting Shader Subroutines</a></li>
</ul>
</li>
<li><a href="#org9b7dab4">Separate Shader Objects</a></li>
</ul>
</li>
<li><a href="#org96deb53">Drawing with OpenGL</a>
<ul>
<li><a href="#orga78f5a0">一、OpenGL Graphics Primitives</a>
<ul>
<li><a href="#orgbb1f0ac">Points</a></li>
<li><a href="#org7a69d9f">Point Sprites</a></li>
<li><a href="#org0673485">Lines, Strips, and Loops</a></li>
<li><a href="#orge196ee2">Triangles Strips Fans</a></li>
<li><a href="#org20d5387">Rendering Polygons As Points, Outlines, or Solids</a></li>
<li><a href="#org63c56d7">Reversing and Culling Polygon Faces</a></li>
</ul>
</li>
<li><a href="#org3455daf">二、Data in OpenGL Buffers</a>
<ul>
<li><a href="#org0ed2042">Creating and allocating buffers</a></li>
<li><a href="#orgf225470">Getting Data into and out of Buffers</a></li>
<li><a href="#orga9267ef">Reading the contents of a buffer</a></li>
<li><a href="#orgd664083">Accessing the Content of Buffers</a></li>
<li><a href="#orgdb8dab5">Asynchronous and explicit mapping</a></li>
<li><a href="#org2f4a251">Discarding Buffer Data</a></li>
<li><a href="#org101cf42">Delete Buffer</a></li>
</ul>
</li>
<li><a href="#org6e9582a">三、Vertex Specification</a>
<ul>
<li><a href="#org4dc14dd">VertexAttibPointer in Depth</a></li>
<li><a href="#orgf54c1fc">Integer Vertex Attributes</a></li>
<li><a href="#org595b6dd">Double-Precision Vertex Attributes</a></li>
<li><a href="#org276a4f1">Packed Data Formats for Vertex Attributes</a></li>
<li><a href="#orgcb5acdf">Static Vertex-Attribute Specification</a></li>
</ul>
</li>
<li><a href="#org5ae9605">四、OpenGL Drawing Commands</a>
<ul>
<li><a href="#orgec7fc99">绘图命令</a></li>
<li><a href="#org464e08b">Restarting Primitives</a></li>
</ul>
</li>
<li><a href="#orgd7a0e0e">五、Instanced Rendering</a></li>
<li><a href="#org34f90b8">六、参考资料</a></li>
</ul>
</li>
<li><a href="#orge421162">Color,Pixels,and Framebuffers</a>
<ul>
<li><a href="#org50c450d">一、Basic Color Theory</a></li>
<li><a href="#orgfdf6d30">二、Buffers and Their Uses</a>
<ul>
<li><a href="#org6c7bb5d">简述</a></li>
<li><a href="#org8715e85">Clearing Buffers</a></li>
<li><a href="#org0bb8217">Masking Buffers</a></li>
</ul>
</li>
<li><a href="#org35dca55">三、Color and OpenGL</a>
<ul>
<li><a href="#org3a58d41">简述</a></li>
<li><a href="#org2afc044">Color Representation and OpenGL</a></li>
<li><a href="#orgba8137d">Vertex Color</a></li>
<li><a href="#org5f8800b">Rasterization</a></li>
</ul>
</li>
<li><a href="#org3be86b6">四、Multisampling</a></li>
<li><a href="#org326e3f6">五、Testing and Operating on Fragments</a>
<ul>
<li><a href="#orga489e14">简述</a></li>
<li><a href="#org509d288">Scissor Test</a></li>
<li><a href="#org6e62227">Multisample Fragment Operations</a></li>
<li><a href="#org5d8e3f2">Stencil Test</a></li>
<li><a href="#org631f99f">Depth Test</a></li>
<li><a href="#org807c6cf">Blending</a></li>
<li><a href="#org8b2f307">Dithering</a></li>
<li><a href="#org85f617e">Logical Operations</a></li>
<li><a href="#orgacd37c3">Occlusion Query</a></li>
<li><a href="#org6172b38">Conditional Rendering</a></li>
</ul>
</li>
<li><a href="#org9e7f91a">六、Per-Primitive Antialiasing</a></li>
<li><a href="#orgec3d004">七、Framebuffer Objects</a>
<ul>
<li><a href="#org2b459b0">简述</a></li>
<li><a href="#orgf129e51">Renderbuffers</a></li>
</ul>
</li>
<li><a href="#org51b7709">八、Writing to Multiple Renderbuffers Simultaneously</a>
<ul>
<li><a href="#orgda2a116">指定输出变量和附加点的对应关系</a></li>
<li><a href="#orgcdb5339">Selecting Color Buffers for Writing and Reading</a></li>
<li><a href="#orga0253a5">Dual-Source Blending</a></li>
</ul>
</li>
<li><a href="#org05ef196">九、Reading and Copying Pixel Data</a></li>
<li><a href="#org4f4f20a">十、Copying Pixel Rectangles</a></li>
</ul>
</li>
<li><a href="#org3f19da4">Viewing Transformations,Clipping,and Feedback</a>
<ul>
<li><a href="#org5e39b78">一、Viewing</a></li>
<li><a href="#orgfa5bd1e">二、User Transformations</a>
<ul>
<li><a href="#orgcef6695">Matrix Multiply Refresher</a></li>
<li><a href="#org762d2ca">Homogeneous Coordinates</a></li>
<li><a href="#org896e077">线性变换和矩阵</a></li>
<li><a href="#orgc53b543">Perspective Projection / Orthographic Projection</a></li>
<li><a href="#org6c2cd07">法线变换</a></li>
<li><a href="#orgdae3550">OpenGL Matrices</a></li>
<li><a href="#org222ffaa">实现一个摄像机类</a></li>
</ul>
</li>
<li><a href="#org4b9e9d1">三、OpenGL Transformations</a></li>
<li><a href="#orge3568ee">四、Transform Feedback</a>
<ul>
<li><a href="#org5f5356d">简述</a></li>
<li><a href="#org35b751e">Transform feedback Objects</a></li>
<li><a href="#org78531b1">Transform Feedback Buffers</a></li>
<li><a href="#org8efd919">Configuring Transform Feedback Varyings</a></li>
<li><a href="#org2f50448">开始、停止 Transform Feedback</a></li>
<li><a href="#org3417386">离子系统</a></li>
</ul>
</li>
<li><a href="#orgae2d8c2">Q&amp;A</a>
<ul>
<li><a href="#org5f4ce25">关于坐标变换流程</a>
<ul>
<li><a href="#org9e1e4bb">坐标变换流程是怎样的？</a></li>
<li><a href="#orgfc9bc54">坐标裁剪是如何进行的？</a></li>
<li><a href="#org5d421f4">为什么坐标裁剪不直接在 NDC 坐标系下进行？</a></li>
<li><a href="#orgb23cdf7">裁剪坐标系是怎样的坐标系？它的原点-坐标轴是怎样的？</a></li>
<li><a href="#org85ed03d">OpenGL NDC 标准设备坐标系为什么是左手坐标系？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga85d42f">Textures</a>
<ul>
<li><a href="#orge6d6333">一、Texture Mapping</a></li>
<li><a href="#orgad3c962">二、Basic Texture Types</a></li>
<li><a href="#org2435fe9">三、Creating and Initializing Textures</a>
<ul>
<li><a href="#org5e68713">生成贴图对象名称</a></li>
<li><a href="#orge9f6348">创建/绑定贴图对象到激活的纹理单元</a></li>
<li><a href="#orgf941044">选择激活的纹理绑定点（纹理单元）</a></li>
<li><a href="#org3343fa7">删除纹理对象</a></li>
<li><a href="#org2f8c373">为纹理对象指定存储空间和数据</a>
<ul>
<li><a href="#orgc6d75d9">Texture Formats</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcc0a4a1">四、Proxy Textures</a></li>
<li><a href="#orge1ea97b">五、Specifying Texture Data</a>
<ul>
<li><a href="#org276865e">Explicitly Setting Texture Data</a></li>
<li><a href="#org6d44ebc">Using Pixel Unpack Buffers</a></li>
<li><a href="#orgcf0dd7d">Copying Data from the Frambuffer</a></li>
<li><a href="#orgc27a3e4">Loading Images from Files</a></li>
<li><a href="#orge4970e3">Retrieving Texture Data</a></li>
<li><a href="#org876d5c2">Texture Data Layout</a></li>
</ul>
</li>
<li><a href="#org8127754">六、Sampler Objects</a>
<ul>
<li><a href="#org373e1e3">简述</a></li>
<li><a href="#org91617c3">Sampler Parameters</a></li>
</ul>
</li>
<li><a href="#orgb6e4176">七、Using Textures</a>
<ul>
<li><a href="#orgdb90ce4">Texture Coordinates</a></li>
<li><a href="#org2c6df7e">Arranging Texture Data</a></li>
<li><a href="#orgd2f12c4">Using Multiple Textures</a></li>
</ul>
</li>
<li><a href="#org76cd63a">八、Complex Texture Types</a>
<ul>
<li><a href="#org2b90740">3D Textures</a></li>
<li><a href="#orge153c0d">Array Textures</a></li>
<li><a href="#orgb36613f">Cube-Map Textures</a></li>
<li><a href="#orgdeef909">Shadow Samplers</a></li>
<li><a href="#org065362f">Depth-Stencil Textures</a></li>
<li><a href="#orgda0eda4">Buffer Textures</a></li>
</ul>
</li>
<li><a href="#org12b18fd">九、Texture Views</a></li>
<li><a href="#org1be2608">十、Compressed Textures</a></li>
<li><a href="#org796da7a">十一、Filtering</a>
<ul>
<li><a href="#org613a146">简述</a></li>
<li><a href="#org73b2b8f">Linear Filtering</a></li>
<li><a href="#orgcfce72b">Using and Generating Mipmaps</a></li>
<li><a href="#org09dbf3d">Calculating the Mipmap Level</a></li>
<li><a href="#orgfdb74b7">Mipmap Level-of-Detail Control</a></li>
</ul>
</li>
<li><a href="#orged707cf">十二、Advanced Texture Lookup Functions</a></li>
<li><a href="#org8c4f7c8">十三、Point Sprites</a></li>
<li><a href="#org6b0d7e6">十四、Rendering to Texture Maps</a></li>
<li><a href="#orgf5a9bb0">十五、贴图最佳实践</a></li>
</ul>
</li>
<li><a href="#org0e45fd2">Light and Shadow</a>
<ul>
<li><a href="#org849890b">一、Classic Lighting Model</a>
<ul>
<li><a href="#org16f23d0">简述</a></li>
<li><a href="#orgcd0981b">Fragment Shaders for Different Light Styles</a></li>
<li><a href="#orga32680e">Moving Calculations to the Vertex Shader</a></li>
<li><a href="#org27755cd">Multiple Lights and Materials</a></li>
<li><a href="#org58e48a5">Lighting Coordinate Systems</a></li>
<li><a href="#orgc63b798">Limitations of the Classic Lighting Model</a></li>
</ul>
</li>
<li><a href="#orgae4c0ac">二、Advanced Lighting Models</a>
<ul>
<li><a href="#org6885bf6">Hemisphere Lighting</a></li>
<li><a href="#org0ac3994">Image-Based Lighting</a></li>
<li><a href="#orgf7c00f8">Lighting with Spherical Harmonics</a></li>
</ul>
</li>
<li><a href="#org595bf65">三、Shadow Mapping</a></li>
</ul>
</li>
<li><a href="#org68b3307">Procedural Texturing</a></li>
<li><a href="#org576987b">Tessellation Shaders</a></li>
<li><a href="#org7d9ab83">Geometry Shaders</a></li>
<li><a href="#orgaebcbfb">Memory</a></li>
<li><a href="#org121a4a0">Compute Shaders</a></li>
<li><a href="#org5a47173">Q&amp;A</a>
<ul>
<li><a href="#org374d260">Qt OpenGL 升级</a></li>
<li><a href="#org3151eb8">坐标系</a></li>
<li><a href="#org196e257">设置缩放变换矩阵时需要将 w 设置为 1，否则缩放无效</a></li>
<li><a href="#org692e085">shader 中不使用的 uniform 会被自动移除</a></li>
<li><a href="#orgbbd36f5">Qt 开启 c++11</a></li>
<li><a href="#org3a63988">glGetError glGetUniformLocation bug</a></li>
<li><a href="#orgc6874fa">绘制的物体没有显示出来</a></li>
<li><a href="#org26b1862">Qt 包含库头文件</a></li>
<li><a href="#orgf5261bf">不能将 build 目录放在项目目录下，否则复制目录会递归死循环</a></li>
<li><a href="#org8faf2e4">GTimerMgr 中 Schedule(target,task,&#x2026;)task 不能用 std::function</a></li>
<li><a href="#orgfca599b">注意： vector 遍历删除照成 iterator 失效的问题</a></li>
<li><a href="#org3428689">实现自定义的 LookUp 时，需要注意 OpenGL 中矩阵的存储是列主序的</a></li>
<li><a href="#org1d5301a">旋转摄像机画面没有变化：请检查一下 QOpenGLWidget 是否开启了每帧执行 update 的操作！</a></li>
<li><a href="#org4fb48bf">物体贴图为黑白颜色时，检查 glTexImage2D 的 format 参数是否正确。</a></li>
<li><a href="#org7cf024f">shader 中定义的变量需要进行初始化，否则其值是随机值。</a></li>
<li><a href="#org2f29c2e">光照通常不会影响物体的透明度，所以光照计算中，颜色的 alpha 值通常是不变的。</a></li>
<li><a href="#org11533b9">什么是摄像机空间（视觉空间、观察空间）？</a></li>
<li><a href="#orgb27efa8">光照计算在视觉坐标系下进行有什么好处？</a></li>
<li><a href="#orgd28d669">几种光照成分的名称</a></li>
<li><a href="#org0b7ee8d">VBO 和 VAO 的区别</a></li>
<li><a href="#org79a472a">参考链接：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org72dabff">OpenGL Version</a>
<ul>
<li><a href="#orgf110a5a">OpenGL ES</a>
<ul>
<li><a href="#org15e7006">New features in OpenGL ES 3.0 include:</a></li>
<li><a href="#org524f54e">New features in OpenGL ES 3.1 include:</a></li>
<li><a href="#orge2eee60">New features in OpenGL ES 3.2 include:</a></li>
<li><a href="#org03de91a">参考资料</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
《OpenGL Programming Guide,Eighth Edition》读书笔记<br />
OpenGL note.<br />
</p>
<div class="HTML" id="org0ff26c0">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgca3b8cc" class="outline-2">
<h2 id="orgca3b8cc">OpenGL Programming Guide ver8</h2>
<div class="outline-text-2" id="text-orgca3b8cc">
</div>
<div id="outline-container-orgee278ab" class="outline-3">
<h3 id="orgee278ab">Introduction to OpenGL</h3>
<div class="outline-text-3" id="text-orgee278ab">
</div>
<div id="outline-container-org8ff0e36" class="outline-4">
<h4 id="org8ff0e36">一 搭建开发环境</h4>
<div class="outline-text-4" id="text-org8ff0e36">
<p>
1 安装 PyQt5 PyOpenGL<br />
brew install pyqt5<br />
./easy_install-3.5 PyOpenGL<br />
</p>

<p>
2 安装 PyCharm 配置 PyCharm<br />
<a href="http://blog.csdn.net/a359680405/article/details/45074761">http://blog.csdn.net/a359680405/article/details/45074761</a><br />
</p>
</div>
</div>
<div id="outline-container-org99f0d52" class="outline-4">
<h4 id="org99f0d52">二 OpenGL 渲染管线</h4>
<div class="outline-text-4" id="text-org99f0d52">

<div id="org8172686" class="figure">
<p><img src="./OpenGL/opengl_pipeline.png" alt="opengl_pipeline.png" width="600px" /><br />
</p>
</div>
</div>
<div id="outline-container-orgb3ae996" class="outline-5">
<h5 id="orgb3ae996">1 准备向 OpenGL 传输数据</h5>
<div class="outline-text-5" id="text-orgb3ae996">
<p>
OpenGL 需要将所有的数据都保存到缓存对象(buffer object)中,它相当于由 OpenGL 服务端维护的<br />
一块内存区域。我们可以使用多种方式来创建这样的数据缓存,不过最常用 的方法就是使用例 1.1 中的<br />
glBufferData() 命令。我们可能还需要对缓存做一些额外的设置,相关的内容请参见第 3 章。<br />
</p>
</div>
</div>

<div id="outline-container-org329bd44" class="outline-5">
<h5 id="org329bd44">2 将数据传输到 OpenGL</h5>
<div class="outline-text-5" id="text-org329bd44">
<p>
当将缓存初始化完毕之后,我们可以通过调用 OpenGL 的一个绘制命令来请求渲染几何图元,例 1.1 中<br />
的 glDrawArrays() 就是一个常用的绘制命令。OpenGL 的绘制通常就是将顶点数据传输到 OpenGL<br />
服务端。我们可以将一个顶点视为一个需要统一处理的数据包。这个包中的数据可以是我们需要的任何数<br />
据(也就是说,我们自己负责定义构成顶点的所有数据),通常其中几乎始终会包含位置数据。其他的数据<br />
可能用来决定一个像素的最终颜色。第 3 章会更详细地介绍绘制命令的内容。<br />
</p>
</div>
</div>

<div id="outline-container-org7c5f331" class="outline-5">
<h5 id="org7c5f331">3 顶点着色</h5>
<div class="outline-text-5" id="text-org7c5f331">
<p>
对于绘制命令传输的每个顶点,OpenGL 都会调用一个顶点着色器来处理顶点相关的数据。根据其他光栅化<br />
之前的着色器的活跃与否,顶点着色器可能会非常简单,例如,只是 将数据复制并传递到下一个着色阶段,这<br />
叫做传递着色器(pass-through shader);它也可能 非常复杂,例如,执行大量的计算来得到顶点在屏幕<br />
上的位置(一般情况下,我们会用到变换矩阵(transformation matrix)的概念,参见第 5 章),或者通<br />
过光照的计算(参见第 7 章) 来判断顶点的颜色,或者其他一些技法的实现。通常来说,一个复杂的应用程<br />
序可能包含许多个顶点着色器,但是在同一时刻只能有一个顶点着色器起作用。<br />
</p>
</div>
</div>

<div id="outline-container-org599367c" class="outline-5">
<h5 id="org599367c">4 细分着色</h5>
<div class="outline-text-5" id="text-org599367c">
<p>
顶点着色器处理每个顶点的关联数据之后,如果同时激活了细分着色器(tessellation shader),那么它<br />
将进一步处理这些数据。正如在第 9 章将会看到的,细分着色器会使用 Patch 来描述一个物体的形状,<br />
并且使用相对简单的 Patch 几何体连接来完成细分的工作, 其结果是几何图元的数量增加,并且模型的外<br />
观会变得更为平顺。细分着色阶段会用到两个着色器来分别管理 Patch 数据并生成最终的形状。<br />
</p>
</div>
</div>

<div id="outline-container-org3d41735" class="outline-5">
<h5 id="org3d41735">5 几何着色</h5>
<div class="outline-text-5" id="text-org3d41735">
<p>
下一个着色阶段— 几何着色— 允许在光栅化之前对每个几何图元做更进一步的处理,例如创建新的图元。这<br />
个着色阶段也是可选的,但是我们在第 10 章里会体会到它的强大之处。<br />
</p>
</div>
</div>

<div id="outline-container-orgebd51a2" class="outline-5">
<h5 id="orgebd51a2">6 图元装配</h5>
<div class="outline-text-5" id="text-orgebd51a2">
<p>
前面介绍的着色阶段所处理的都是顶点数据,此外这些顶点之间如何构成几何图元的所有信息也会被传递到<br />
OpenGL 当中。图元装配阶段将这些顶点与相关的几何图元之间组织起来,准备下一步的剪切和光栅化工<br />
作。<br />
</p>
</div>
</div>

<div id="outline-container-org3f9341b" class="outline-5">
<h5 id="org3f9341b">7 剪切</h5>
<div class="outline-text-5" id="text-org3f9341b">
<p>
顶点可能会落在视口(viewport)之外— 也就是我们可以进行绘制的窗口区域— 此 时与顶点相关的图元<br />
会做出改动,以保证相关的像素不会在视口外绘制。这一过程叫做剪切(clipping),它是由 OpenGL<br />
自动完成的。<br />
</p>
</div>
</div>

<div id="outline-container-org7027c51" class="outline-5">
<h5 id="org7027c51">8 光栅化</h5>
<div class="outline-text-5" id="text-org7027c51">
<p>
剪切之后马上要执行的工作,就是将更新后的图元传递到光栅化单元,生成对应的片元。我们可以将一个片<br />
元视为一个“候选的像素”,也就是可以放置在帧缓存中的像素,但是它也可能被最终剔除,不再更新对应的<br />
像素位置。之后的两个阶段将会执行片元的处理, 即片元着色和逐片元的操作。<br />
</p>
</div>
</div>

<div id="outline-container-orgbe091f3" class="outline-5">
<h5 id="orgbe091f3">9 片元着色</h5>
<div class="outline-text-5" id="text-orgbe091f3">
<p>
最后一个可以通过编程控制屏幕上显示颜色的阶段,叫做片元着色阶段。在这个阶段中,我们使用着色器<br />
来计算片元的最终颜色(尽管在下一个阶段(逐片元的操作)时可能 还会改变颜色一次)和它的深度值。片<br />
元着色器非常强大,在这里我们会使用纹理映射的方式,对顶点处理阶段所计算的颜色值进行补充。如果<br />
我们觉得不应该继续绘制某个片元, 在片元着色器中还可以终止这个片元的处理,这一步叫做片元的<br />
丢弃(discard)。<br />
如果我们需要更好地理解处理顶点的着色器和片元着色器之间的区别,可以用这种方法来记忆:顶点着色<br />
(包括细分和几何着色)决定了一个图元应该位于屏幕的什么位置,而片元着色使用这些信息来决定某个片<br />
元的颜色应该是什么。<br />
</p>
</div>
</div>
<div id="outline-container-orgf3b7c0d" class="outline-5">
<h5 id="orgf3b7c0d">10 逐片元的操作 (lesson 4)</h5>
<div class="outline-text-5" id="text-orgf3b7c0d">
<p>
除了我们在片元着色器里做的工作之外,片元操作的下一步就是最后的独立片元处理过程。在这个阶段里会<br />
使用深度测试(depth test,或者通常也称作 z-buffering)和模板测试(stencil test)的方式来决<br />
定一个片元是否是可见的。<br />
如果一个片元成功地通过了所有激活的测试,那么它就可以被直接绘制到帧缓存中了,它对应的像素的颜色<br />
值(也可能包括深度值)会被更新,如果开启了融合(blending)模式, 那么片元的颜色会与该像素当前的<br />
颜色相叠加,形成一个新的颜色值并写入帧缓存中。<br />
（1）Scissor test<br />
（2）Multisample fragment operations<br />
（3）Stencil test<br />
（4）Depth test<br />
（5）Blending<br />
（6）Dithering // 抖动<br />
（7）Logical operations<br />
</p>

<p>
像素数据的传输也有一条路径。通常来说,像素数据来自图像 文件,尽管它也可能是 OpenGL 直接渲染的。<br />
像素数据通常保存在纹理贴图当中,通过纹理映射的方式调用。在纹理阶段中我们可以从一张或者多张纹理<br />
贴图中查找所需的数据值。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org361dbdd" class="outline-4">
<h4 id="org361dbdd">参考资料</h4>
<div class="outline-text-4" id="text-org361dbdd">
<ul class="org-ul">
<li><a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcb07759" class="outline-3">
<h3 id="orgcb07759">Shader Fundamentals</h3>
<div class="outline-text-3" id="text-orgcb07759">
</div>
<div id="outline-container-org7cdb164" class="outline-4">
<h4 id="org7cdb164">Shaders and OpenGL</h4>
<div class="outline-text-4" id="text-org7cdb164">
<p>
从 3.1 版本开始，固定函数管线从 CoreProfile 中移除了，shaders 成为强制要求的。<br />
</p>
</div>
</div>

<div id="outline-container-org7e369e2" class="outline-4">
<h4 id="org7e369e2">OpenGL's Programmable pipline</h4>
<div class="outline-text-4" id="text-org7e369e2">
</div>
<div id="outline-container-org9d9ab66" class="outline-5">
<h5 id="org9d9ab66">4.3 版本的图形管线包含 4 个阶段：</h5>
<div class="outline-text-5" id="text-org9d9ab66">
<p>
(1) vertex shading stage.       [mandatory]<br />
接收 vertex-buffer 对象指定的顶点数据，分别处理每个顶点。<br />
(2) tessellation shading stage  [optional]<br />
在 OpenGL 管线中生成额外的几何图元。激活该阶段时，它将从顶点着色阶段接收数据，并做进一步处理。<br />
(3) geometry shading stage      [optional]<br />
可以修改 OpenGL 管线中的几何图元，分别处理每个几何图元（修改、忽略几何图元）。<br />
(4) fragment shading stage      [mandatory]<br />
该阶段处理由光栅化程序产生的 fragments，在这个阶段片段的颜色和深度值被计算。<br />
(5) compute shading stage<br />
该阶段不是图形管线的一部分。<br />
</p>
</div>
</div>
<div id="outline-container-org18577c2" class="outline-5">
<h5 id="org18577c2">数据传输</h5>
<div class="outline-text-5" id="text-org18577c2">
<p>
shader 通过 in/out(输入/输出)变量来进行数据传递。<br />
uniform 为 OpenGL 应用程序定义变量，在 shader 中只能读不能修改。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org9f9198a" class="outline-4">
<h4 id="org9f9198a">Shading Language</h4>
<div class="outline-text-4" id="text-org9f9198a">
</div>
<div id="outline-container-orgbf8cffc" class="outline-5">
<h5 id="orgbf8cffc">类型转换</h5>
<div class="outline-text-5" id="text-orgbf8cffc">
<p>
隐式类型转换<br />
int -&gt; uint<br />
int,uint -&gt; float<br />
int,uint,float -&gt; double<br />
显式类型转换<br />
float f=10.0;<br />
int ten=int(f);<br />
</p>
</div>
</div>
<div id="outline-container-org12bc37b" class="outline-5">
<h5 id="org12bc37b">聚合类型</h5>
<div class="outline-text-5" id="text-org12bc37b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BaseType</th>
<th scope="col" class="org-left">2D vec</th>
<th scope="col" class="org-left">3D vec</th>
<th scope="col" class="org-left">4D vec</th>
<th scope="col" class="org-left">MatrixTypes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">float</td>
<td class="org-left">vec2</td>
<td class="org-left">vec3</td>
<td class="org-left">vec4</td>
<td class="org-left">mat2    mat3    mat4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">mat2x2  mat2x3  mat2x4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">mat3x2  mat3x3  mat3x4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">mat4x2  mat4x3  mat4x4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-left">dvec2</td>
<td class="org-left">dvec3</td>
<td class="org-left">dvec4</td>
<td class="org-left">dmat2   dmat3   dmat4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">dmat2x2 dmat2x3 dmat2x4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">dmat3x2 dmat3x3 dmat3x4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">dmat4x2 dmat4x3 dmat4x4</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-left">ivec2</td>
<td class="org-left">ivec3</td>
<td class="org-left">ivec4</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">uint</td>
<td class="org-left">uvec2</td>
<td class="org-left">uvec3</td>
<td class="org-left">uvec4</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">bool</td>
<td class="org-left">bvec2</td>
<td class="org-left">bvec3</td>
<td class="org-left">bvec4</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org0cffb9c" class="outline-5">
<h5 id="org0cffb9c">Structrues</h5>
<div class="outline-text-5" id="text-org0cffb9c">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> Particle {
    <span style="color: #ce537a; font-weight: bold;">float</span> lifetime;
    vec3  position;
    vec3  velocity;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org475b4a6" class="outline-5">
<h5 id="org475b4a6">Array</h5>
<div class="outline-text-5" id="text-org475b4a6">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">coeff</span>[3] = <span style="color: #ce537a; font-weight: bold;">float</span>[3](1.0,2.0,3.0);
<span style="color: #ce537a; font-weight: bold;">float</span>[3] coeff = <span style="color: #ce537a; font-weight: bold;">float</span>[3](1.0,2.0,3.0);
coeff.length();     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">=3</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">coeff</span>[3][5];
<span style="color: #ce537a; font-weight: bold;">coeff</span>[2].length();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">=5</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8546bf3" class="outline-5">
<h5 id="org8546bf3">Storage Qualifiers</h5>
<div class="outline-text-5" id="text-org8546bf3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">TypeModifier</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">const</td>
<td class="org-left">标记变量为只读</td>
</tr>

<tr>
<td class="org-left">=in</td>
<td class="org-left">输入变量</td>
</tr>

<tr>
<td class="org-left">=out</td>
<td class="org-left">输出变量</td>
</tr>

<tr>
<td class="org-left">=uniform</td>
<td class="org-left">从 App 传到 shader 的变量，shader 中只读</td>
</tr>

<tr>
<td class="org-left">buffer</td>
<td class="org-left">和 App 共享的读写内存</td>
</tr>

<tr>
<td class="org-left">shared</td>
<td class="org-left">computer shader 使用。</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21021;&#22987;&#21270; shader &#20013; uniform array &#25968;&#25454;&#30340;&#20004;&#31181;&#26041;&#27861;&#65306;</span>
uniform <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">offsets</span>[100];
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">--&#26041;&#27861; 1--</span>
<span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">i</span> = 0; i &lt; 100; i++)
{
    <span style="color: #ce537a; font-weight: bold;">stringstream</span> <span style="color: #7590db;">ss</span>;
    <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">index</span>;
    ss &lt;&lt; i;
    index = ss.str();
    <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">location</span> = glGetUniformLocation(shader.Program, (<span style="color: #2d9574;">"offsets["</span> + index + <span style="color: #2d9574;">"]"</span>).c_str())
    glUniform2f(location, translations[i].x, translations[i].y);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">--&#26041;&#27861; 2--</span>
<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">offset_uniform_local</span> = glGetUniformLocation(program, <span style="color: #2d9574;">"offsets"</span>);
<span style="color: #bc6ec5; font-weight: bold;">glUniform2fv</span>(offset_uniform_local,100,translations);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306;&#19979;&#38754;&#36825;&#31181;&#26041;&#27861;&#26159;&#19981;&#21487;&#29992;&#30340;</span>
<span style="color: #bc6ec5; font-weight: bold;">glUniform1fv</span>(offset_uniform_local,200,translations);
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b3c37b" class="outline-5">
<h5 id="org8b3c37b">Function</h5>
<div class="outline-text-5" id="text-org8b3c37b">
<div class="org-src-container">
<pre class="src src-shader">returnType <span style="color: #bc6ec5; font-weight: bold;">functionName</span>([accessModifier] type1 variable1,[accessModifier] type2 variable2)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// function body</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> returnValue;
}

<span style="color: #2aa1ae; background-color: #292e34;">// -AccessModifier-    -Description-</span>
<span style="color: #2aa1ae; background-color: #292e34;">// in                  &#20540;&#34987; copy &#21040;&#20989;&#25968;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// const in            &#21482;&#35835;&#30340; copy &#21040;&#20989;&#25968;&#30340;&#20540;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// out                 &#20540;&#34987; copy &#21040;&#20989;&#25968;&#22806;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// inout               &#20540;&#34987; copy &#21040;&#20989;&#25968;&#20869;&#12289;&#22806;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8af3f30" class="outline-5">
<h5 id="org8af3f30">计算不变性</h5>
<div class="outline-text-5" id="text-org8af3f30">
<p>
invariant 和 precise 可以保证 shader 中的计算不变性。<br />
invariant 用于任何 shader 的输出变量。如果两个 shader 使用同一个表达式计算该输出变量，那么结果是相同的<br />
</p>

<div class="org-src-container">
<pre class="src src-shader">invariant gl_Position;
invariant centroid <span style="color: #4f97d7; font-weight: bold;">out</span> vec3 <span style="color: #4f97d7; font-weight: bold;">Color</span>;
</pre>
</div>

<p>
centroid  在打开多点采样的时候，强迫一个片断输入变量的采样位于图元像素覆盖的区域，centroid 限定的任何顶点着色器输出，都必须有一个匹配的片断着色器输入也被 centroid 限定<br />
#pragma STDGL invariant(all)<br />
</p>

<p>
precise   用于任何函数返回值或任何计算变量。也可用于内置变量，用户变量。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">precise gl_Position;
precise <span style="color: #4f97d7; font-weight: bold;">out</span> vec3 Location;
precise vec3 subdivide(vec3 P1, vec3 P2)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// .....</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgec76246" class="outline-5">
<h5 id="orgec76246">Shader Preprocessor</h5>
<div class="outline-text-5" id="text-orgec76246">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#define</span>
<span style="color: #bc6ec5;">#define</span> LPos(n) gl_LightSource[n].position
<span style="color: #7590db;">__LINE__</span>
<span style="color: #7590db;">__FILE__</span>
<span style="color: #7590db;">__VERSION__</span>
<span style="color: #bc6ec5;">#undef</span>
<span style="color: #bc6ec5;">#if</span>
<span style="color: #bc6ec5;">#ifdef</span>
<span style="color: #bc6ec5;">#ifndef</span>
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">#elif</span>
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#error</span> text &#22312;&#32534;&#35793; shader &#26102;,&#21521;&#26085;&#24535;&#28040;&#24687;&#20013;&#25554;&#20837; text
<span style="color: #bc6ec5;">#pragma</span> options
<span style="color: #bc6ec5;">    #pragma</span> optimize(on)
<span style="color: #bc6ec5;">    #pragma</span> optimize(off)
<span style="color: #bc6ec5;">    #pragma</span> <span style="color: #4f97d7;">debug</span>(on)
<span style="color: #bc6ec5;">    #pragma</span> <span style="color: #4f97d7;">debug</span>(off)
#extension options
    #extension extension_name : &lt;directive&gt;
    #extension <span style="color: #4f97d7;">all</span> : &lt;directive&gt;
    <span style="color: #2aa1ae; background-color: #292e34;">// -Directive-         -Description-</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// require             &#22914;&#26524;&#25193;&#23637;&#19981;&#23384;&#22312;&#25110;&#25193;&#23637;&#20026; all,&#21017;&#26631;&#35760;&#19968;&#20010;&#38169;&#35823;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// enable              &#22914;&#26524;&#29305;&#23450;&#30340;&#25193;&#23637;&#19981;&#23384;&#22312;&#21017;&#32473;&#19968;&#20010;&#35686;&#21578;,&#22914;&#26524;&#20026; all,&#21017;&#26631;&#35760;&#19968;&#20010;&#38169;&#35823;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// warn                &#22914;&#26524;&#29305;&#23450;&#25193;&#23637;&#19981;&#23384;&#22312;,&#25110;&#32773;&#20351;&#29992;&#20102;&#20219;&#24847;&#25193;&#23637;,&#21017;&#32473;&#19968;&#20010;&#35686;&#21578;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// disable             &#22914;&#26524;&#25193;&#23637;&#19981;&#25903;&#25345;,&#21017;&#20135;&#29983;&#19968;&#20010;&#38169;&#35823;&#25110;&#32773;&#35686;&#21578;</span>
#version number
#line options
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2f159b6" class="outline-4">
<h4 id="org2f159b6">Interface Blocks</h4>
<div class="outline-text-4" id="text-org2f159b6">
</div>
<div id="outline-container-org704b318" class="outline-5">
<h5 id="org704b318">概述</h5>
<div class="outline-text-5" id="text-org704b318">
<p>
shader 和 app 或 shader 之间共享的变量可以组织为 blocks,Uniform 变量可以组织到 uniform blocks 中,<br />
input 和 output 变量可以组织到 in/out blocks 中,shader 存储缓存组织到 buffer blocks 中.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">uniform</span> b {     <span style="color: #2aa1ae; background-color: #292e34;">// uniform or in or out or buffer</span>
    vec4 v1;    <span style="color: #2aa1ae; background-color: #292e34;">// list of variables</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> v2;    <span style="color: #2aa1ae; background-color: #292e34;">// ...</span>
};              <span style="color: #2aa1ae; background-color: #292e34;">// access members as v1 and v2</span>
<span style="color: #4f97d7; font-weight: bold;">uniform</span> b {     <span style="color: #2aa1ae; background-color: #292e34;">// uniform or in or out or buffer</span>
    vec4 v1;    <span style="color: #2aa1ae; background-color: #292e34;">// list of variables</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> v2;    <span style="color: #2aa1ae; background-color: #292e34;">// ...</span>
} name;         <span style="color: #2aa1ae; background-color: #292e34;">// access members as name.v1 and name.v2</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org79c53b5" class="outline-5">
<h5 id="org79c53b5">Uniform Block Layout Control</h5>
<div class="outline-text-5" id="text-org79c53b5">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// -LayoutQualifier-           -Description-</span>
<span style="color: #2aa1ae; background-color: #292e34;">// shared                      &#25351;&#23450; uniform block &#34987;&#22810;&#20010;&#31243;&#24207;&#20849;&#20139;(&#36825;&#20010;&#26159;&#40664;&#35748;&#20462;&#39280;)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// packed                      &#25351;&#23450; uniform block &#20351;&#29992;&#26368;&#23567;&#20869;&#23384;&#24067;&#23616;.uniform block &#19981;&#33021;&#22840;&#31243;&#24207;&#20849;&#20139;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// std140                      &#20351;&#29992;&#26631;&#20934;&#24067;&#23616;.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// std430                      &#20351;&#29992;&#26631;&#20934;&#24067;&#23616;.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// row_major                   uniform block &#20013;&#30340;&#30697;&#38453;&#20026;&#34892;&#20027;&#24207;&#23384;&#20648;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// column_major                uniform block &#20013;&#30340;&#30697;&#38453;&#20026;&#21015;&#20027;&#24207;&#23384;&#20648;(&#36825;&#26159;&#40664;&#35748;&#26041;&#24335;)</span>
layout (<span style="color: #4f97d7; font-weight: bold;">shared</span>, <span style="color: #4f97d7; font-weight: bold;">row_major</span>) <span style="color: #4f97d7; font-weight: bold;">uniform</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//.....</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org7504a5e" class="outline-5">
<h5 id="org7504a5e">在 app 中访问 Uniform blocks</h5>
<div class="outline-text-5" id="text-org7504a5e">
<p>
(1) 返回 shader 中名称为 uniformBlockName 的 uniform block 索引<br />
GLuint glGetUniformBlockIndex(GLuint program, const char* uniformBlockName);<br />
e.g:<br />
uboIndex = glGetUniformBlockIndex(program, "Uniforms");<br />
(2) 获取 shader 中 index 为 uniformBlockIndex 的 uniform block 的名称为 pname 的参数的值<br />
glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);<br />
e.g:<br />
glGetActiveUniformBlockiv(program, uboIndex, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;uboSize);<br />
(3) 依据 names 获取 shader 中对应 uniform 变量的索引<br />
e.g:<br />
glGetUniformIndices(program,NumUniforms, names, indices);<br />
(4) 依据 uniform 变量的索引,获取其其他参数<br />
glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);<br />
e.g:<br />
glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_OFFSET, offset);<br />
glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_SIZE, size);<br />
glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_TYPE, type);<br />
(5) 将当前绑定的缓冲区对象和索引为 index 的 uniform block 关联<br />
void glBindBufferRange(GLenum target,GLuint index,GLuint buffer,GLintptr offset,GLsizeiptr size);<br />
void glBindBufferBase(GLenum target,GLuint index,GLuint buffer);<br />
e.g:<br />
glBindBufferBase(GL_UNIFORM_BUFFER, uboIndex, ubo);<br />
glBindBufferRange(GL_UNIFORM_BUFFER,ubo_index,ubo,ubo_offset[type],data_size);<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">program</span> = GLHelper::CreateShaderProgramWithFiles(<span style="color: #2d9574;">":/vertex_UniformBlock.vert"</span>,<span style="color: #2d9574;">":/fragment_UniformBlock.frag"</span>);
  <span style="color: #bc6ec5; font-weight: bold;">glUseProgram</span>(program);

  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">uboIndex</span>;
  <span style="color: #ce537a; font-weight: bold;">GLint</span>  <span style="color: #7590db;">uboSize</span>;
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">ubo</span>;
  <span style="color: #ce537a; font-weight: bold;">GLvoid</span> *<span style="color: #7590db;">buffer</span>;

  uboIndex = glGetUniformBlockIndex(program, <span style="color: #2d9574;">"Uniforms"</span>);
  <span style="color: #bc6ec5; font-weight: bold;">glGetActiveUniformBlockiv</span>(program, uboIndex, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;uboSize);

  buffer = malloc(uboSize);

  <span style="color: #4f97d7; font-weight: bold;">if</span>(buffer == <span style="color: #a45bad;">NULL</span>)
  {
      fprintf(stderr, <span style="color: #2d9574;">"Unable to allocate buffer\n"</span>);
      exit(EXIT_FAILURE);
  }
  <span style="color: #4f97d7; font-weight: bold;">else</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">enum</span> {<span style="color: #7590db;">Translation</span>, <span style="color: #7590db;">Scale</span>, <span style="color: #7590db;">Rotation</span>, <span style="color: #7590db;">Enabled</span>, <span style="color: #7590db;">NumUniforms</span>};
      <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">scale</span> = 0.5;
      <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">translation</span>[] = {0.1, 0.1, 0.0};
      <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">rotation</span>[] = {90, 0.0, 0.0, 1.0};
      <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #7590db;">enabled</span> = GL_TRUE;

      <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">names</span>[NumUniforms] = {
          <span style="color: #2d9574;">"translation"</span>,
          <span style="color: #2d9574;">"scale"</span>,
          <span style="color: #2d9574;">"rotation"</span>,
          <span style="color: #2d9574;">"enabled"</span>
      };

      <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">indices</span>[NumUniforms];
      <span style="color: #ce537a; font-weight: bold;">GLint</span>  <span style="color: #7590db;">size</span>[NumUniforms];
      <span style="color: #ce537a; font-weight: bold;">GLint</span>  <span style="color: #7590db;">offset</span>[NumUniforms];
      <span style="color: #ce537a; font-weight: bold;">GLint</span>  <span style="color: #7590db;">type</span>[NumUniforms];

      glGetUniformIndices(program,NumUniforms, names, indices);
      glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_OFFSET, offset);
      glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_SIZE, size);
      glGetActiveUniformsiv(program,NumUniforms,indices,GL_UNIFORM_TYPE, type);

      memcpy( (<span style="color: #ce537a; font-weight: bold;">GLchar</span>*)buffer + offset[Translation], &amp;translation, size[Translation] * GLHelper::TypeSize(type[Translation]) );
      memcpy( (<span style="color: #ce537a; font-weight: bold;">GLchar</span>*)buffer + offset[Scale],       &amp;scale,       size[Scale] * GLHelper::TypeSize(type[Scale]) );
      memcpy( (<span style="color: #ce537a; font-weight: bold;">GLchar</span>*)buffer + offset[Rotation],    &amp;rotation,    size[Rotation] * GLHelper::TypeSize(type[Rotation]) );
      memcpy( (<span style="color: #ce537a; font-weight: bold;">GLchar</span>*)buffer + offset[Enabled],     &amp;enabled,     size[Enabled] * GLHelper::TypeSize(type[Enabled]) );

      glGenBuffers(1, &amp;ubo);
      glBindBuffer(GL_UNIFORM_BUFFER, ubo);
      glBufferData(GL_UNIFORM_BUFFER, uboSize, buffer, GL_STATIC_DRAW);
      glBindBufferBase(GL_UNIFORM_BUFFER, uboIndex, ubo);

      glGenVertexArrays(NumVAOs, VAOs);
      glBindVertexArray(VAOs[Triangles]);
      <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">vertices</span>[NumVertices][2] = {
          {-0.90, -0.90},
          { 0.85, -0.90},
          {-0.90,  0.85},
          { 0.90, -0.85},
          { 0.90,  0.90},
          {-0.85,  0.90},
      };

      glGenBuffers(NumBuffers,VBuffers);
      glBindBuffer(GL_ARRAY_BUFFER, VBuffers[ArrayBuffer]);
      glBufferData(GL_ARRAY_BUFFER, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);

      glVertexAttribPointer(vPos,2,GL_FLOAT,GL_FALSE,0,BUFF_OFFSET(0));
      glEnableVertexAttribArray(vPos);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org8d7c9fc" class="outline-5">
<h5 id="org8d7c9fc">buffer blocks</h5>
<div class="outline-text-5" id="text-org8d7c9fc">
<p>
buffer blocks 和 uniform block 相比，有两个优点：<br />
(1) 着色器可以写入，修改 buffer blocks 的内容。<br />
(2) buffer blocks 的大小可以在渲染之前再确定，而不是编译连接的时候。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">buffer BufferObject {
    <span style="color: #ce537a; font-weight: bold;">int</span>     mode;
    vec4    points[];    <span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#25968;&#32452;&#30340;&#22823;&#23567;&#21487;&#20197;&#22312;&#28210;&#26579;&#20043;&#21069;&#30830;&#23450;</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org15844ef" class="outline-5">
<h5 id="org15844ef">In/Out Blocks</h5>
<div class="outline-text-5" id="text-org15844ef">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #4f97d7; font-weight: bold;">Lighting</span> {
    vec3 normal;
    vec2 bumpCoord;
}
<span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7; font-weight: bold;">Lighting</span> {
    vec3 normal;
    vec2 bumpCoord;
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org835d4ce" class="outline-4">
<h4 id="org835d4ce">Compiling Shaders</h4>
<div class="outline-text-4" id="text-org835d4ce">
<p>
使用 shader 的步骤：<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">==== &#23545;&#20110;&#27599;&#20010; shader object ====</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 1. create a shader object.</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; shader &#23545;&#35937;</span>
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #bc6ec5; font-weight: bold;">glCreateShader</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">--type--</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_VERTEX_SHADER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAGMENT_SHADER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TESS_CONTROL_SHADER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TESS_EVALUATION_SHADER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_GEOMETRY_SHADER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20851;&#32852; shader &#23545;&#35937;&#21644; shader &#28304;&#20195;&#30721;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span>   <span style="color: #bc6ec5; font-weight: bold;">glShaderSource</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLchar</span>** <span style="color: #7590db;">string</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span>* <span style="color: #7590db;">length</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 2. compile your shader source into the object.</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32534;&#35793; shader &#28304;&#20195;&#30721;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glCompileShader</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 3. verify that your shader compiled successfully</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGetShaderiv</span> (<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">pname</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> *<span style="color: #7590db;">params</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGetShaderInfoLog</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">bufSize</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span>* <span style="color: #7590db;">length</span>,<span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">infoLog</span>);

  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">==== &#23558;&#22810;&#20010; shader objects &#36830;&#25509;&#21040;&#19968;&#20010; shader &#31243;&#24207; ====</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 1. create a shader program</span>
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #bc6ec5; font-weight: bold;">glCreateProgram</span>(<span style="color: #ce537a; font-weight: bold;">void</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 2. attach the appropriate shader objects to the shader program.</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glAttachShader</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>,<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDetachShader</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>,<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 3. link the shader program</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glLinkProgram</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 4. verify that the shader link phase completed successfully</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGetProgramiv</span> (<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">pname</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> *<span style="color: #7590db;">params</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGetProgramInfoLog</span> (<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">bufSize</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> *<span style="color: #7590db;">length</span>, <span style="color: #ce537a; font-weight: bold;">GLchar</span> *<span style="color: #7590db;">infoLog</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">step 5. use the shader for vertex or fragment processing</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glUseProgram</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>);
  <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsShader</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>);
  <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsProgram</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org1fda427" class="outline-4">
<h4 id="org1fda427">Shader Subroutines</h4>
<div class="outline-text-4" id="text-org1fda427">
</div>
<div id="outline-container-org4d6d1b3" class="outline-5">
<h5 id="org4d6d1b3">GLSL Subroutine Setup</h5>
<div class="outline-text-5" id="text-org4d6d1b3">
<p>
(1) 定义 Subroutine 类型<br />
subroutine returnType subroutineType(type param, &#x2026;);<br />
e.g:<br />
subroutine vec4 LightFunc(vec3);<br />
(2) 使用前面定义好的 Subroutine 类型来定义一组 subroutine<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">subroutine (LightFunc) vec4 ambient(vec3 n)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> Materials.ambient;
}
subroutine (LightFunc) vec4 diffuse(vec3 n)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> Materials.diffuse*<span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(n),LightVec.xyz),0.0);
}
</pre>
</div>

<p>
(3) 指定一个 subroutine uniform 变量来保存你在程序中选择的 subroutine 函数指针<br />
e.g:<br />
subroutine uniform LightFunc materialShader;<br />
Tips:<br />
一个 subroutine 可以对应多个 subroutine 类型<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">subroutine <span style="color: #ce537a; font-weight: bold;">void</span> Type_1();
subroutine <span style="color: #ce537a; font-weight: bold;">void</span> Type_2();

subroutine (Type_1) Func_1();
subroutine (Type_2) Func_2();
subroutine (Type_1,Type_2) Func_12();

subroutine <span style="color: #4f97d7; font-weight: bold;">uniform</span> Type_1 func_1;  <span style="color: #2aa1ae; background-color: #292e34;">// &#21487;&#20197;&#20351;&#29992; Func_1 Func_12</span>
subroutine <span style="color: #4f97d7; font-weight: bold;">uniform</span> Type_2 func_2;  <span style="color: #2aa1ae; background-color: #292e34;">// &#21487;&#20197;&#20351;&#29992; Func_2 Func_12</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7c3963" class="outline-5">
<h5 id="orgc7c3963">Selecting Shader Subroutines</h5>
<div class="outline-text-5" id="text-orgc7c3963">
<p>
GLint glGetSubroutineUniformLocation(GLuint program,GLenum shadertype,const char* name);<br />
获得 subroutine uniform 的位置<br />
GLuint glGetSubroutineIndex(GLuint program,GLenum shadertype,const char* name);<br />
获得 subroutine 的 index<br />
GLuint glUniformSubroutinesuiv(GLenum shadertype,GLsizei count,const GLuint* indices);<br />
设置 count 个 subroutine uniforms 为 indices 中保存的值<br />
e.g:<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">materialShaderLoc</span>;
<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">ambientIndex</span>;
<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">diffuseIndex</span>;

<span style="color: #bc6ec5; font-weight: bold;">glUseProgram</span>(program);

materialShaderLoc = glGetSubroutineUniformLocation(program,GL_VERTEX_SHADER,<span style="color: #2d9574;">"materialShader"</span>);

<span style="color: #4f97d7; font-weight: bold;">if</span> (materialShaderLoc &lt; 0)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Error</span>
}
ambientIndex = glGetSubroutineIndex(program,GL_VERTEX_SHADER,<span style="color: #2d9574;">"ambient"</span>);
diffuseIndex = glGetSubroutineIndex(program,GL_VERTEX_SHADER,<span style="color: #2d9574;">"diffuse"</span>);
<span style="color: #4f97d7; font-weight: bold;">if</span>(ambientIndex==GL_INVALID_INDEX || diffuseIndex==GL_INVALID_INDEX)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span>
}
<span style="color: #4f97d7; font-weight: bold;">else</span>
{
    <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>;
    glGetIntegerv(GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS, &amp;n);

    <span style="color: #ce537a; font-weight: bold;">GLuint</span>* <span style="color: #7590db;">indices</span> = new GLuint[n];
    indices[materialShaderLoc] = ambientIndex;

    glUniformSubroutinesuiv(GL_VERTEX_SHADER, n, indices);

    delete [] indices;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9b7dab4" class="outline-4">
<h4 id="org9b7dab4">Separate Shader Objects</h4>
<div class="outline-text-4" id="text-org9b7dab4">
<p>
4.1 版本之前的 OpenGL，应用程序执行期间，同一时间只能绑定一个 shader program。一个 vertex shader 处理一组几何元素然后交由多个 fragment shader 进行后续处理，这种情况下，你需要多个 shader program 对应，这些 shader program 都有相同的 vertex shader.<br />
</p>

<p>
4.1 版本中 Separate shader objects 可以将不同 shader programs 的多个 shader 阶段组合到一个 program pipeline 中。其步骤如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">(1) &#21019;&#24314;&#21487;&#37325;&#29992;&#30340; shader program</span>
<span style="color: #bc6ec5; font-weight: bold;">glProgramParameter</span>(program, GL_PROGRAM_SEPARABLE, GL_TRUE);
<span style="color: #bc6ec5; font-weight: bold;">glCreateShaderProgramv</span>()
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">(2) &#20351;&#29992;&#26032;&#30340; shader pipeline &#23558;&#22810;&#20010;&#26469;&#33258;&#19981;&#21516; shader programs &#30340; shader &#38454;&#27573;&#32452;&#21512;&#20026;&#19968;&#20010;&#21487;&#22797;&#29992;&#30340; program pipeline.</span>
<span style="color: #bc6ec5; font-weight: bold;">glGenProgramPipelines</span>();
<span style="color: #bc6ec5; font-weight: bold;">glBindProgramPipeline</span>();
<span style="color: #bc6ec5; font-weight: bold;">glUseProgramStages</span> (<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">pipeline</span>, <span style="color: #ce537a; font-weight: bold;">GLbitfield</span> <span style="color: #7590db;">stages</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">~Tips1~ &#21024;&#38500; program pipelines</span>
<span style="color: #bc6ec5; font-weight: bold;">glDeleteProgramPipelines</span>();
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">~Tips2~ &#35774;&#32622; uniform &#21464;&#37327;&#20540;:</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">set the active program object for a program pipeline object</span>
<span style="color: #bc6ec5; font-weight: bold;">glActiveShaderProgram</span>();
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">set uniform</span>
<span style="color: #ce537a; font-weight: bold;">glUniform</span>*();
<span style="color: #ce537a; font-weight: bold;">glProgramUniform</span>*();
<span style="color: #ce537a; font-weight: bold;">glProgramUniformMatrix</span>*();
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #bc6ec5; font-weight: bold;">LoadPipeline</span>(
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">vsSource</span>,
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">gsSource</span>,
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">fsSource</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">vsProgram</span> = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, &amp;vsSource);
      <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">gsProgram</span> = glCreateShaderProgramv(GL_GEOMETRY_SHADER, 1, &amp;gsSource);
      <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">fsProgram</span> = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, &amp;fsSource);

      <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">pipeline</span>;
      glGenProgramPipelines(1, &amp;pipeline);
      glBindProgramPipeline(pipeline);

      glUseProgramStages(pipeline, GL_VERTEX_SHADER_BIT, vsProgram);
      glUseProgramStages(pipeline, GL_GEOMETRY_SHADER_BIT, gsProgram);
      glUseProgramStages(pipeline, GL_FRAGMENT_SHADER_BIT, fsProgram);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glUniform* now heed the "active" shader program rather than glUseProgram</span>
      glActiveShaderProgram(pipeline, vsProgram);
      glUniform1f(fooLocation, 1.0f);

      <span style="color: #4f97d7; font-weight: bold;">return</span> pipeline;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org96deb53" class="outline-3">
<h3 id="org96deb53">Drawing with OpenGL</h3>
<div class="outline-text-3" id="text-org96deb53">
</div>
<div id="outline-container-orga78f5a0" class="outline-4">
<h4 id="orga78f5a0">一、OpenGL Graphics Primitives</h4>
<div class="outline-text-4" id="text-orga78f5a0">
</div>
<div id="outline-container-orgbb1f0ac" class="outline-5">
<h5 id="orgbb1f0ac">Points</h5>
<div class="outline-text-5" id="text-orgbb1f0ac">
<ul class="org-ul">
<li>点的大小<br />
在程序中用 glPointSize(GLfloat size)来固定点的大小<br />
在 shader 中用 gl_PointSize 来设置点的大小（只有 GL_PROGRAM_POINT_SIZE 为 GL_TRUE 才可用）<br /></li>
<li>点的光栅化规则<br />
以点为中心以点的大小为边长的正方形包含的像素会被覆盖<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7a69d9f" class="outline-5">
<h5 id="org7a69d9f">Point Sprites</h5>
<div class="outline-text-5" id="text-org7a69d9f">
<p>
在渲染点的时候，点内的每个片段都会执行片段着色器。gl_PointCoord 变量可以在 fragment shader 中使用，用来表示片段在点内的坐标。<br />
将 gl_PointCoord 当作贴图坐标来使用，可以代替简单的正方形块。结合 alpha 混合或片段丢弃，甚至可以创建形状各异的点 sprite。<br />
</p>
</div>
</div>
<div id="outline-container-org0673485" class="outline-5">
<h5 id="org0673485">Lines, Strips, and Loops</h5>
<div class="outline-text-5" id="text-org0673485">
<ul class="org-ul">
<li>多条线按顺序连接不闭合被称作 line strip<br /></li>
<li>多条线按顺序连接闭合被称作 line loop<br /></li>
<li>线的宽度<br />
glLineWidth 用来设置线的宽度<br />
反锯齿开启后，线被当做长方体，其长度和线长度相同，宽度和线宽度相同。<br /></li>
<li>线的光栅化规则<br />
光栅化线的规则被称为钻石退出规则.当光栅化一条从 A 点到 B 点的线，如果一个点的正方形内所包含的钻石形状的边被经过，那么这个点就会被点亮，除非点 B 在这个钻石形状内。这样的话，如果还有一条线是从 B 点到 C 点，这样点 B 只被点亮一次。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge196ee2" class="outline-5">
<h5 id="orge196ee2">Triangles Strips Fans</h5>
<div class="outline-text-5" id="text-orge196ee2">
<ul class="org-ul">
<li>Triangles Strips 某个三角形会公用前一个三角形后面两个顶点<br /></li>
<li>Triangles Fans 所有三角形公用第一个顶点<br /></li>
<li>三角形渲染<br />
当分开的多个三角形被渲染时，每个三角形的渲染是独立于其他三角形的。<br />
一个三角形被渲染时，将三角形的每个顶点投影到屏幕空间形成三条边。如果一个采样落在三条边形成的半空间的正面，那么这个采样就会被点亮。<br />
如果两个三角形共享一条边，没有任何一个采样点被两个三角形都包含。这样可以保证 OpenGL 光栅化包含共享边网格的可靠性，多个三角形之间不会有间隙，也不会过度绘制。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org20d5387" class="outline-5">
<h5 id="org20d5387">Rendering Polygons As Points, Outlines, or Solids</h5>
<div class="outline-text-5" id="text-org20d5387">
<p>
一个多边形有两面，正面和背面，依据那一面正对着观察者，可以有不同的渲染。这样就可以绘制固体的剖面图了，在剖面图中，物体的里面和外面有明显的差别。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;&#24773;&#20917;&#19979; face=GL_FRONT_AND_BACK mode=GL_FILL</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35774;&#32622;&#22810;&#36793;&#24418;&#28210;&#26579;&#27169;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glPolygonMode</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">face</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">face = GL_FRONT_AND_BACK</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mode = GL_POINT GL_LINE GL_FILL</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips&#65306; &#35980;&#20284;&#19981;&#33021;&#20026; FRONT &#21644; BACK &#25351;&#23450;&#19981;&#21516;&#30340; mode&#65311;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#29305;&#24615;&#24050;&#32463;&#20174; opengl 3.2 &#29256;&#26412;&#24320;&#22987;&#65292;&#34987;&#26631;&#35760;&#20026; deprecated&#65292;&#25152;&#20197; face &#30340;&#26522;&#20030;&#20540;&#21482;&#33021;&#20026; GL_FRONT_AND_BACK</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://stackoverflow.com/questions/19672014/why-is-gl-front-and-gl-back-deprecated-in-opengl-3-2-onwards</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org63c56d7" class="outline-5">
<h5 id="org63c56d7">Reversing and Culling Polygon Faces</h5>
<div class="outline-text-5" id="text-org63c56d7">
<p>
按照惯例，多边形顶点按照逆时针方向出现在屏幕上时被称作正向。<br />
你可以使用方向一致（都是逆时针正向 或 都是顺时针反向）的多边形来构建任何“合理”的固体。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#27491;&#38754;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glFrontFace</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL_CCW counterclockwise</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL_CW  clockwise</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21076;&#38500;&#30340;&#38754;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glCullFace</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRONT GL_BACK GL_FRONT_AND_BACK</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glEnable</span>(GL_CULL_FACE);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3455daf" class="outline-4">
<h4 id="org3455daf">二、Data in OpenGL Buffers</h4>
<div class="outline-text-4" id="text-org3455daf">
</div>
<div id="outline-container-org0ed2042" class="outline-5">
<h5 id="org0ed2042">Creating and allocating buffers</h5>
<div class="outline-text-5" id="text-org0ed2042">
<pre class="example" id="orgf7b3fc2">
调用 glGenBuffers 生成 buffer object 的名称。
void glGenBuffers(GLsizei n, GLuint *buffers);

---Buffer Binding Targets(points)---
Target                          Uses
GL_ARRAY_BUFFER                 用于通过 glVertexAttribPointer 设置顶点数组数据指针
GL_COPY_READ/WRITE_BUFFER       用于 buffer 之间 copy 数据
GL_DRAW_INDIRECT_BUFFER         用于 indirect 绘制时保存绘制命令的参数
GL_ELEMENT_ARRAY_BUFFER         用于保存顶点的索引，执行索引绘制命令 glDrawElements  
                                1. OpenGL 只能使用一个顶点缓存区，即 vertexPos uv normal 的索引需要都一相同
                                2. OBJ格式的模型每个属性都可以有各自的索引缓冲区。
                                3. 因为不同属性的索引需要相同，因此不同属性的数量也要相同。例如：一个三角形需要3个顶点，1个normal，3个uv。但是，OpenGL要求一个三角形需要3个顶点，3个normal，3个uv。
                                - http://www.opengl-tutorial.org/cn/intermediate-tutorials/tutorial-9-vbo-indexing/
GL_PIXEL_PACK_BUFFER            用于保存从图片对象(textures/framebuffer)读取的数据 glGetTexImage glReadPixels
GL_PIXEL_UNPACK_BUFFER          用于指定 glTexImage2D 的来源数据
GL_TEXTURE_BUFFER               将 buffer 绑定到 texture 对象上，这样就可以在 shader 中获取其数据了
GL_TRANSFORM_FEEDBACK_BUFFER    用于保存变换后的顶点属性
GL_UNIFORM_BUFFER               用于保存 Uniform 数据

//指定当前绑定的 target 类的 buffer 对象 或者 创建 target 类的 buffer 对象
glBindBuffer(GLenum target, GLuint buffer);
</pre>
</div>
</div>
<div id="outline-container-orgf225470" class="outline-5">
<h5 id="orgf225470">Getting Data into and out of Buffers</h5>
<div class="outline-text-5" id="text-orgf225470">
<p>
glBufferData(GLenum target,GLsizeiptr size,const GLvoid* data,GLenum usage)<br />
glBufferSubData(GLenum target,GLintptr offset,GLsizeiptr size,const GLvoid* data);<br />
glClearBufferData(GLenum target,GLenum internalfamat,GLenum format,GLenum type,const void* data)<br />
glClearSubBufferData(GLenum target,GLenum internalfamat,GLintptr offset,GLintptr size,GLenum format,GLenum type,const void* data)<br />
glCopyBufferSubData(GLenum readtarget,GLenum writetarget,GLintptr readoffset,GLintptr writeoffset,GLsizeiptr size)<br />
</p>
</div>
</div>
<div id="outline-container-orga9267ef" class="outline-5">
<h5 id="orga9267ef">Reading the contents of a buffer</h5>
<div class="outline-text-5" id="text-orga9267ef">
<p>
void glGetBufferSubData(GLenum target,GLintptr offset,GLsizeiptr size,GLvoid* data);<br />
</p>
</div>
</div>
<div id="outline-container-orgd664083" class="outline-5">
<h5 id="orgd664083">Accessing the Content of Buffers</h5>
<div class="outline-text-5" id="text-orgd664083">
<p>
void* glMapBuffer(GLenum target,GLenum access)<br />
&#x2014;Access Modes&#x2014;<br />
GL_READ_ONLY<br />
GL_WRITE_ONLY<br />
GL_READ_WRITE<br />
void glUnmapBuffer(GLenum target)<br />
</p>
</div>
</div>
<div id="outline-container-orgdb8dab5" class="outline-5">
<h5 id="orgdb8dab5">Asynchronous and explicit mapping</h5>
<div class="outline-text-5" id="text-orgdb8dab5">
<p>
void* glMapBufferRange(GLenum target,GLintptr offset,GLsizeiptr length,GLbitfield access)<br />
&#x2014; Access &#x2014;<br />
GL_MAP_INVALIDATE_RANGE_BIT         指定范围的数据被忽略成为 invalid 数据，不能和 GL_MAP_READ_BIT 同时使用<br />
GL_MAP_INVALIDATE_BUFFER_BIT        整个范围的数据被忽略成为 invalid 数据，不能和 GL_MAP_READ_BIT 同时使用<br />
GL_MAP_FLUSH_EXPLICIT_BIT           指定更新数据的范围，和 GL_MAP_WRITE_BIT 同时使用<br />
GL_MAP_UNSYNCHRONIZED_BIT           未指定该参数时，在返回关联的范围之前，OpenGL 会等待所有访问该 buffer 的操作完成<br />
</p>

<p>
void glFlushMappedBufferRange(GLenum target,GLintptr offset,GLsizeiptr length);<br />
</p>
</div>
</div>
<div id="outline-container-org2f4a251" class="outline-5">
<h5 id="org2f4a251">Discarding Buffer Data</h5>
<div class="outline-text-5" id="text-org2f4a251">
<p>
glInvalidateBufferData(GLuint buffer)<br />
glInvalidateBufferSubData(GLuint buffer,GLintptr offset,GLsizeptr length)<br />
</p>
</div>
</div>
<div id="outline-container-org101cf42" class="outline-5">
<h5 id="org101cf42">Delete Buffer</h5>
<div class="outline-text-5" id="text-org101cf42">
<p>
删除指定的多个 buffers。buffer 对象被删除后，其名称变为不可用，但可被 glGenBuffers 重新复用。<br />
glDeleteBuffers(GLsizei n, const GLuint* buffers);<br />
</p>

<ul class="org-ul">
<li><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml</a><br /></li>
<li><a href="https://stackoverflow.com/questions/27937285/when-should-i-call-gldeletebuffers">https://stackoverflow.com/questions/27937285/when-should-i-call-gldeletebuffers</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6e9582a" class="outline-4">
<h4 id="org6e9582a">三、Vertex Specification</h4>
<div class="outline-text-4" id="text-org6e9582a">
</div>
<div id="outline-container-org4dc14dd" class="outline-5">
<h5 id="org4dc14dd">VertexAttibPointer in Depth</h5>
<div class="outline-text-5" id="text-org4dc14dd">
<p>
void glVertexAttribPointer(GLuint index,GLint size,GLenum type,GLboolean normalized,GLsizei stride,const GLvoid* pointer)<br />
e.g:<br />
glVertexAttribPointer(index,size,GL_INT,GL_TRUE,stride,pointer)<br />
数据被标准化的方法 result = source/(pow(32)-1)<br />
glVertexAttribPointer(index,size,GL_UNSIGNED_BYTE,GL_TRUE,stride,pointer)<br />
数据被标准化的方法 result = (2*source+1)/(pow(8)-1)<br />
</p>
</div>
</div>
<div id="outline-container-orgf54c1fc" class="outline-5">
<h5 id="orgf54c1fc">Integer Vertex Attributes</h5>
<div class="outline-text-5" id="text-orgf54c1fc">
<p>
void glVertexAttribIPointer(GLuint index,GLint size,GLenum type,GLsizei stride,const GLvoid* pointer)<br />
type &#x2013; GL_BYPTE,GL_UNSIGNED_BYTE,GL_SHORT,GL_UNSIGNED_SHORT,GL_INT,GL_UNSIGNED_INT<br />
</p>
</div>
</div>
<div id="outline-container-org595b6dd" class="outline-5">
<h5 id="org595b6dd">Double-Precision Vertex Attributes</h5>
<div class="outline-text-5" id="text-org595b6dd">
<p>
void glVertexAttribLPointer(GLuint index,GLint size,GLenum type,GLsizei stride,const GLvoid* pointer)<br />
type &#x2013; GL_DOUBLE<br />
</p>
</div>
</div>
<div id="outline-container-org276a4f1" class="outline-5">
<h5 id="org276a4f1">Packed Data Formats for Vertex Attributes</h5>
<div class="outline-text-5" id="text-org276a4f1">
<p>
type &#x2013;<br />
GL_INT_2_10_10_10_REV<br />
GL_UNSIGNED_INT_2_10_10_10_REV<br />
</p>
</div>
</div>
<div id="outline-container-orgcb5acdf" class="outline-5">
<h5 id="orgcb5acdf">Static Vertex-Attribute Specification</h5>
<div class="outline-text-5" id="text-orgcb5acdf">
<p>
静态顶点属性是顶点属性的默认值。<br />
void glVertexAttrib{1234}{fds}(GLuint index,TYPE values);<br />
void glVertexAttrib{1234}{fds}v(GLuint index,const TYPE* values);<br />
void glVertexAttrib4{bsifd ub us ui}v(GLuint index,const TYPE* values);<br />
</p>

<p>
void glVertexAttrib4Nub(GLuint index,GLubyte x,GLubyte y,GLubyte z,GLubyte w);<br />
void glVertexAttrib4N{bsi ub us ui}v(GLuint index,const TYPE* v);<br />
</p>

<p>
void glVertexAttribI{1234}{i ui}(GLuint index, TYPE values);<br />
void glVertexAttribI{123}{i ui}v(GLuint index,const TYPE *values);<br />
void glVertexAttribI4{bsi ub us ui}v(GLuint index,const TYPE *values);<br />
</p>

<p>
void glVertexAttribL{1234}(GLuint index, TYPE values);<br />
void glVertexAttribL{1234}v(GLuint index, const TYPE *values);<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org5ae9605" class="outline-4">
<h4 id="org5ae9605">四、OpenGL Drawing Commands</h4>
<div class="outline-text-4" id="text-org5ae9605">
</div>
<div id="outline-container-orgec7fc99" class="outline-5">
<h5 id="orgec7fc99">绘图命令</h5>
<div class="outline-text-5" id="text-orgec7fc99">
<p>
Open 的绘图命令可以粗略的分为两类：基于索引的和非索引的<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TRIANGLES, GL_LINE_LOOP, GL_LINES, and GL_POINTS.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174;&#31532; first &#20010;&#39030;&#28857;&#25968;&#25454;&#24320;&#22987;&#65292;&#21462; count &#20010;&#39030;&#28857;&#25968;&#25454;&#26469;&#32472;&#21046; mode &#31867;&#22411;&#30340;&#20960;&#20309;&#22270;&#20803;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawArrays</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">type</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174; GL_ELEMENT_ARRAY_BUFFER &#32531;&#20914;&#21306;&#23545;&#35937;&#20013;&#65292;&#20559;&#31227; indices &#23383;&#33410;&#24320;&#22987;&#65292;&#21462; count &#20010; type &#31867;&#22411;&#30340;&#32034;&#24341;&#20540;&#65292;&#20381;&#25454;&#32034;&#24341;&#20540;&#25351;&#23450;&#30340;&#39030;&#28857;&#25968;&#25454;&#26469;&#32472;&#21046; mode &#31867;&#22411;&#30340;&#20960;&#20309;&#22270;&#20803;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawElements</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span>* <span style="color: #7590db;">indices</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">basevertex &#25351;&#23450;&#20559;&#31227;&#22810;&#23569;&#20010;&#32034;&#24341;&#25968;&#25454; (indices &#25351;&#23450;&#20559;&#31227;&#23383;&#33410;&#25968;)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545; glDrawElements &#30340;&#19968;&#20010;&#25913;&#36827;&#12290;&#22686;&#21152;&#20102; GLint basevertex &#21442;&#25968;&#65292;&#31216;&#20026;&#32034;&#24341;&#22522;&#25968;&#65292;&#25152;&#26377;&#30340; index &#25968;&#20540;&#37117;&#35201;&#21152;&#19978;&#36825;&#20010;&#25968;&#20540;&#21518;&#20877;&#36827;&#34892;&#32472;&#21046;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20363;&#22914;&#65306;GLushort vetex_indices[] = {0,1,2,3,4}; &#19979;&#38754;&#30340;&#20989;&#25968;&#21462;&#30340;&#32034;&#24341;&#25968;&#25454;&#20026;{2,3,4}</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glDrawElementsBaseVertex(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, NULL, 2);</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawElementsBaseVertex</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> *<span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">basevertex</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">start &#25351;&#23450;&#26368;&#23567;&#30340;&#32034;&#24341;&#20540; end &#25351;&#23450;&#26368;&#22823;&#30340;&#32034;&#24341;&#20540;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524; &#33719;&#21462;&#21040;&#30340;&#32034;&#24341;&#20540;&#19981;&#22312;[start end]&#33539;&#22260;&#20869;&#65292;&#22312;&#25105;&#33258;&#24049;&#30340; PC &#30005;&#33041;&#19978;&#20063;&#27809;&#26377;&#20219;&#20309;&#24433;&#21709;&#65292;&#20960;&#20309;&#22270;&#20803;&#20381;&#28982;&#21487;&#20197;&#28210;&#26579;&#20986;&#26469;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://stackoverflow.com/questions/7549991/questions-about-gldrawrangeelements</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawRangeElements</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">start</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">end</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> *<span style="color: #7590db;">indices</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawRangeElementsBaseVertex</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>,<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">start</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">end</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> *<span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">basevertex</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">indirect &#25351;&#23450; GL_DRAW_INDIRECT_BUFFER &#32531;&#20914;&#21306;&#30340;&#20559;&#31227;&#65292;&#32472;&#21046;&#21629;&#20196;&#30340;&#21442;&#25968;&#20445;&#23384;&#22312; GL_DRAW_INDIRECT_BUFFER &#32531;&#20914;&#21306;&#23545;&#35937;&#20013;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawArraysIndirect</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> *<span style="color: #7590db;">indirect</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawElementsIndirect</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> * <span style="color: #7590db;">indirect</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">primcount &#25351;&#23450;&#20960;&#20309;&#22270;&#20803;&#30340;&#20010;&#25968; first &#21644; count &#37117;&#26159;&#21253;&#21547; primcount &#20010;&#20803;&#32032;&#30340;&#25968;&#32452;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19968;&#27425;&#20989;&#25968;&#35843;&#29992;&#32472;&#21046;&#22810;&#20010;&#20960;&#20309;&#22270;&#20803;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glMultiDrawArrays</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span> * <span style="color: #7590db;">first</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span> * <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primcount</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glMultiDrawElements</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span> * <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> * <span style="color: #4f97d7; font-weight: bold;">const</span> * <span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primcount</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glMultiDrawElementsBaseVertex</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span> * <span style="color: #7590db;">count</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLvoid</span> * <span style="color: #4f97d7; font-weight: bold;">const</span> * <span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primcount</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLint</span> * <span style="color: #7590db;">baseVertex</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glMultiDrawArraysIndirect</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span> * <span style="color: #7590db;">indirect</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">drawcount</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">stride</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glMultiDrawElementsIndirect</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span> * <span style="color: #7590db;">indirect</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">drawcount</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">stride</span>);

<span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">DrawArraysIndirectCommand_t</span>
{
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">count</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">primCount</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">first</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">baseInstance</span>;
} <span style="color: #ce537a; font-weight: bold;">DrawArraysIndirectCommand</span>;

<span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">DrawElementsIndirectCommand_t</span>
{
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">count</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">primCount</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">firstIndex</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">baseVertex</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">baseInstance</span>;
} <span style="color: #ce537a; font-weight: bold;">DrawElementsIndirectCommand</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org464e08b" class="outline-5">
<h5 id="org464e08b">Restarting Primitives</h5>
<div class="outline-text-5" id="text-org464e08b">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glPrimitiveRestartIndex</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#35774;&#32622; primitive_restart_index,&#20351;&#29992; glDrawElements &#31995;&#21015;&#30340;&#32472;&#22270;&#21629;&#20196;&#26102;&#65292;&#24403;&#33719;&#21462;&#39030;&#28857;&#30340;&#32034;&#24341;&#21644; primitive_restart_index &#30456;&#31561;&#26102;&#65292;&#20250;&#24573;&#30053;&#24403;&#21069;&#32034;&#24341;&#65292;&#24182;&#19988;&#20197;&#19979;&#19968;&#20010;&#32034;&#24341;&#20026;&#26032;&#22270;&#20803;&#30340;&#31532;&#19968;&#20010;&#39030;&#28857;&#12290;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd7a0e0e" class="outline-4">
<h4 id="orgd7a0e0e">五、Instanced Rendering</h4>
<div class="outline-text-4" id="text-orgd7a0e0e">
<p>
Instanced Rendering 是一连串执行相同绘制命令多次的一种方法。这是一种绘制大量几何体的高效方法，该方法只有很少的 API 调用。<br />
</p>
<ul class="org-ul">
<li><p>
instanced draw<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">primCount &#32472;&#21046;&#20960;&#20309;&#22270;&#20803;&#30340;&#20010;&#25968;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawArraysInstanced</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primCount</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawElementsInstanced</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primCount</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawElementsInstancedBaseVertex</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">indices</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">primCount</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">baseVertex</span>);
</pre>
</div>

<ul class="org-ul">
<li>Instanced Vertex Attributes<br /></li>
</ul>
<p>
下面的函数使得顶点属性变为 instanced（或 instancing)<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glVertexAttribDivisor</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">divisor</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">index   &#25351;&#23450;&#39030;&#28857;&#23646;&#24615;&#30340;&#32034;&#24341;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">divisor &#25351;&#23450;&#39030;&#28857;&#23646;&#24615;&#34987;&#26356;&#26032;&#30340;&#39057;&#29575; divisor &#20026; 0 &#26102;&#65292;&#23545;&#25351;&#23450;&#30340;&#23646;&#24615;&#20851;&#38381; instancing(&#25110; instanced)</span>
</pre>
</div>

<ul class="org-ul">
<li>关于 Instancing <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/10%20Instancing/">https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/10%20Instancing/</a><br /></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org34f90b8" class="outline-4">
<h4 id="org34f90b8">六、参考资料</h4>
<div class="outline-text-4" id="text-org34f90b8">
<ol class="org-ol">
<li>关于 OpenGL Draw 函数的详细信息<br /></li>
</ol>
<p>
(利用现代 OpenGL API 大幅度减少由于执行驱动导致 CPU 的开销)<a href="http://www.opengpu.org/home.php?mod=space&amp;uid=36152&amp;do=blog&amp;id=598">http://www.opengpu.org/home.php?mod=space&amp;uid=36152&amp;do=blog&amp;id=598</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge421162" class="outline-3">
<h3 id="orge421162">Color,Pixels,and Framebuffers</h3>
<div class="outline-text-3" id="text-orge421162">
</div>
<div id="outline-container-org50c450d" class="outline-4">
<h4 id="org50c450d">一、Basic Color Theory</h4>
<div class="outline-text-4" id="text-org50c450d">
<ol class="org-ol">
<li>物理世界的颜色<br /></li>
</ol>
<p>
在物理世界中，光是由光子组成的，用最简单的术语讲，光子是沿直线传播的粒子，它拥有自己的“颜色”（其表示了波长或频率）。<br />
可见光的波长范围为 390nm-720nm，其中包含了 7 种颜色：violet indigo blue green yellow orange red。<br />
人眼可以看到不止 7 种颜色，其实是不同波长光子混合而形成的唯一的颜色。<br />
</p>

<ol class="org-ol">
<li>计算机中的颜色<br /></li>
</ol>
<p>
大部分显示设备只能显示一小部分可见光谱。他们使用主要的三种颜色（红、绿、蓝）来生成可以显示光谱。<br />
</p>
</div>
</div>
<div id="outline-container-orgfdf6d30" class="outline-4">
<h4 id="orgfdf6d30">二、Buffers and Their Uses</h4>
<div class="outline-text-4" id="text-orgfdf6d30">
</div>
<div id="outline-container-org6c7bb5d" class="outline-5">
<h5 id="org6c7bb5d">简述</h5>
<div class="outline-text-5" id="text-org6c7bb5d">
<p>
在 OpenGL 中可以使用下面几种 buffer：Color buffers\ Depth buffer\ Stencil buffer，所有这些 buffer 组合起来形成<br />
framebuffer。<br />
当应用程序启动时，使用的是 default framebuffer.其总是包含一个 Color buffer.<br />
(1) Color Buffers<br />
通常绘画到颜色缓冲区中，其中包含了 RGB 或 sRGB 颜色数据，以及每个像素的 alpha 值。一个 framebuffer 中可能包含多个颜色缓冲区。<br />
default framebuffer 的主颜色缓冲区是特殊的颜色缓冲区，它和屏幕上的窗口相关联，将图片显示在屏幕上，其他颜色缓冲区都是离<br />
屏渲染的。<br />
颜色缓存区中的每个像素可以存储一个颜色，或者将该像素分为多个子像素，来执行多重采样反锯齿。<br />
(2) Depth Buffer<br />
深度缓冲区为每个像素保存了深度值，用来决定物体在 3 维空间中的可见性。<br />
深度值是通过测量到眼睛距离来得到的，拥有更小深度值的像素会覆盖更大生深度的像素。<br />
(3) Stencil Buffer<br />
模板缓冲区用来将绘制限定在特定的区域内。<br />
</p>
</div>
</div>
<div id="outline-container-org8715e85" class="outline-5">
<h5 id="org8715e85">Clearing Buffers</h5>
<div class="outline-text-5" id="text-org8715e85">
<p>
(1) 设置清除缓存的值<br />
void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);<br />
void glClearDepth(GLclampd depth);<br />
void glClearDepthf(GLclampf depth);<br />
void glClearStencil(GLint s);<br />
(2) 清除缓存<br />
void glClear(GLbitfield mask);<br />
GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT GL_STENCIL_BUFFER_BIT<br />
</p>
</div>
</div>
<div id="outline-container-org0bb8217" class="outline-5">
<h5 id="org0bb8217">Masking Buffers</h5>
<div class="outline-text-5" id="text-org0bb8217">
<p>
OpenGL 写数据到开启的颜色、深度、模板缓冲区之前，会在数据上执行掩码操作。<br />
void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);<br />
void glColorMaski(GLuint buffer, GLboolean red, GLboolean green, GLboolean blue,GLboolean alpha);<br />
指定某个颜色分量是否可以被写入颜色缓冲区<br />
void glDepthMask(GLboolean flag);<br />
如果 flag 为 GL_TRUE，则深度缓冲区可以写入，否则不可写入。<br />
void glStencilMask(GLuint mask);<br />
void glStencilMaskSeparate(GLenum face, GLuint mask)<br />
指定一个位掩码控制模板缓存区的各个位平面的写入。mask 的初始值为全 1。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org35dca55" class="outline-4">
<h4 id="org35dca55">三、Color and OpenGL</h4>
<div class="outline-text-4" id="text-org35dca55">
</div>
<div id="outline-container-org3a58d41" class="outline-5">
<h5 id="org3a58d41">简述</h5>
<div class="outline-text-5" id="text-org3a58d41">
<p>
为片段指定颜色的工作是由片段着色器来做的，有很多种方式来做这件事情：<br />
(1) 片段着色器不使用任何额外的数据来生成片段颜色。<br />
(2) 附加的颜色数据被提供给每个顶点，这些数据可能会被顶点着色器修改，然后传递给片段着色器。片段着色器依据此颜色数据来生成片段颜色<br />
(3) 附加的数据（但不是特定颜色数据）被提供给片段着色器，并且通过计算来生成颜色。<br />
(4) 额外的数据，例如数字图片，在片段着色器中被引用用来查询颜色数据。<br />
</p>
</div>
</div>
<div id="outline-container-org2afc044" class="outline-5">
<h5 id="org2afc044">Color Representation and OpenGL</h5>
<div class="outline-text-5" id="text-org2afc044">
<p>
默认情况下片段着色器接收到的值被当作浮点值，这些值的范围为[0.0,1.0](即标准化的值)，<br />
但这些值被写入到帧缓冲区时会被映射到帧缓存区支持的值的范围。<br />
可以通过 glVertexAttribPointer()来指定值是否被标准化。<br />
</p>
</div>
</div>
<div id="outline-container-orgba8137d" class="outline-5">
<h5 id="orgba8137d">Vertex Color</h5>
<div class="outline-text-5" id="text-orgba8137d">
<p>
顶点颜色数据的使用，可以查看该章实例项目中的以下文件：<br />
vertexcolor.h<br />
vertexcolor.cpp<br />
</p>
</div>
</div>
<div id="outline-container-org5f8800b" class="outline-5">
<h5 id="org5f8800b">Rasterization</h5>
<div class="outline-text-5" id="text-org5f8800b">
<p>
光栅化用来决定屏幕上的哪些区域被特定的几何图元覆盖，其结合输入的顶点数据线性插值产生各个片段的数据并提供给片段着色器中的对应变量。<br />
应用在颜色数据上的线性插值被称作 Gouraud shading<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3be86b6" class="outline-4">
<h4 id="org3be86b6">四、Multisampling</h4>
<div class="outline-text-4" id="text-org3be86b6">
<ol class="org-ol">
<li>简述<br /></li>
</ol>
<p>
多重采样是一种平滑化几何图元边缘的一种技术。通过对每个几何图元的每个像素进行多次采样，对每个像素保存多个样本， 对所有样本进行处理来确定像素的最终颜色。<br />
glGetIntegerv(GL_SAMPLE_BUFFERS)用来检查是否支持多重采样。<br />
glEnable(GL_MULTISAMPLE)开启多重采样<br />
glGetIntegerv(GL_SAMPLES)获取样本的数量<br />
void glGetMultisamplefv(GL_SAMPLE_POSITION, GLuint index, GLfloat *val);<br />
获取索引值为 index 的样本的地址，该地址的范围为[0,1],表示了样本相对于像素左下角的偏移。与 shader 中 gl_SamplePosition 值相同。<br />
在着色器中的使用 sample 关键字，可以使被修饰的变量依据每个样本的不同地址有对应的细微差别。<br />
</p>

<ol class="org-ol">
<li>Sample Shading<br /></li>
</ol>
<p>
glEnable(GL_SAMPLE_SHADING) 可以使片段着色器中的 in 变量自动依据样本地址插值。<br />
</p>

<p>
下面的函数可以控制片段着色器中接收到的样本数量：<br />
void glMinSampleShading(GLfloat value)<br />
value 的范围为[0,1]。1 表示每个样本都需要独立被渲染，0 表示忽略样本渲染。<br />
</p>

<p>
Tips:<br />
Qt 中让 QOpenGLWidget 支持多重采样需要如下操作:<br />
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">QSurfaceFormat</span> <span style="color: #7590db;">format</span>;
  format.setRenderableType(QSurfaceFormat::OpenGL);
  format.setProfile(QSurfaceFormat::CoreProfile);
  format.setOption(QSurfaceFormat::DebugContext);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35774;&#32622;&#37319;&#26679;&#25968;&#37327;&#65292;&#20174;&#32780;&#25903;&#25345;&#22810;&#37325;&#37319;&#26679;</span>
  format.setSamples(4);
</pre>
</div>
</div>
</div>
<div id="outline-container-org326e3f6" class="outline-4">
<h4 id="org326e3f6">五、Testing and Operating on Fragments</h4>
<div class="outline-text-4" id="text-org326e3f6">
</div>
<div id="outline-container-orga489e14" class="outline-5">
<h5 id="orga489e14">简述</h5>
<div class="outline-text-5" id="text-orga489e14">
<p>
片段着色器处理片段之后还会按顺序经过下面的处理：<br />
（1）Scissor test<br />
（2）Multisample fragment operations<br />
（3）Stencil test<br />
（4）Depth test<br />
（5）Blending<br />
（6）Dithering<br />
（7）Logical operations<br />
如果某个片段在某个阶段被淘汰，那么它就会被丢弃，后续的阶段就不需要在执行了。<br />
</p>
</div>
</div>
<div id="outline-container-org509d288" class="outline-5">
<h5 id="org509d288">Scissor Test</h5>
<div class="outline-text-5" id="text-org509d288">
<p>
指定一个正方形区域，区域外的片段都将被忽略<br />
void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);<br />
glEnable(GL_SCISSOR_TEST) glDisable(GL_SCISSOR_TEST) 裁剪测试开启控制<br />
</p>
</div>
</div>
<div id="outline-container-org6e62227" class="outline-5">
<h5 id="org6e62227">Multisample Fragment Operations</h5>
<div class="outline-text-5" id="text-org6e62227">
<p>
下面链接详细描述了多重采样的原理<br />
<a href="http://learnopengl.com/#!Advanced-OpenGL/Anti-Aliasing">http://learnopengl.com/#!Advanced-OpenGL/Anti-Aliasing</a><br />
<a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/11%20Anti%20Aliasing/">https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/11%20Anti%20Aliasing/</a><br />
</p>

<p>
默认情况下多重采样计算片段覆盖的值是不包含 alpha 的(即，不会计算 alpha)，通过 glEnable()可以更改该设置<br />
GL_SAMPLE_ALPHA_TO_CONVERAGE 指定计算包括 alpha<br />
GL_SAMPLE_ALPHA_TO_ONE       设置 alpha 值为 1，并使用它<br />
GL_SAMPLE_COVERAGE           使用通过 glSampleCoverage 设置的值<br />
GL_SAMPLE_MASK               指定一个额外的 bit 序列作为覆盖值的掩码，这个掩码和采样覆盖值位与<br />
</p>

<p>
当开启了 GL_SAMPLE_COVERAGE，就可以通过 glSampleConverage 函数来指定一个值和片段覆盖值进行位与（AND）<br />
glSampleMaski(GLuint index, GLbitfield mask)可用来指定掩码的 bit 序列<br />
</p>
</div>
</div>
<div id="outline-container-org5d8e3f2" class="outline-5">
<h5 id="org5d8e3f2">Stencil Test</h5>
<div class="outline-text-5" id="text-org5d8e3f2">
<p>
模板测试需要模板缓冲区，如果不存在模板缓冲区，模板测试则总是通过。<br />
// TODO 实现一个描边效果<br />
</p>
</div>
</div>
<div id="outline-container-org631f99f" class="outline-5">
<h5 id="org631f99f">Depth Test</h5>
<div class="outline-text-5" id="text-org631f99f">
<p>
深度缓存区保存了视点到物体的距离。<br />
（1）Polygon Offset<br />
多边形偏移可用于 渲染固体的高亮边缘、表面贴花、隐藏线移除<br />
glEnable(GL_POLYGON_OFFSET_FILL)<br />
void glPolygonOffset(GLfloat factor, GLfloat units);<br />
开启多边形偏移后，在执行深度测试之前，每个片段的深度值会被添加一个偏移值。偏移值按照下面方法计算：<br />
offset = m * factor + r * units<br />
</p>
</div>
</div>
<div id="outline-container-org807c6cf" class="outline-5">
<h5 id="org807c6cf">Blending</h5>
<div class="outline-text-5" id="text-org807c6cf">
<p>
混合操作把源片段的 RGB 和 alpha 值与已经存储在这个位置的像素的对应值进行组合.<br />
（1）Blending Factors<br />
  Sr,Sg,Sb,Sa 表示源混合因子<br />
  Dr,Dg,Db,Da 表示目标混合因子<br />
  Rs,Gs,Bs,As 表示源颜色<br />
  Rd,Gd,Bd,Ad 表示目标颜色<br />
  最终的颜色为 SrRs+DrRd, SgGs+DgGd, SbBs+DbBd, SaAs+DaAd<br />
</p>
</div>
</div>
<div id="outline-container-org8b2f307" class="outline-5">
<h5 id="org8b2f307">Dithering</h5>
<div class="outline-text-5" id="text-org8b2f307">
<p>
抖动可以让系统表示更多的颜色。<br />
</p>
</div>
</div>
<div id="outline-container-org85f617e" class="outline-5">
<h5 id="org85f617e">Logical Operations</h5>
<div class="outline-text-5" id="text-org85f617e">
<p>
将输入的片段值（source）和已经存储在颜色缓存区中的片段值（destination）进行逻辑运算。<br />
</p>
</div>
</div>
<div id="outline-container-orgacd37c3" class="outline-5">
<h5 id="orgacd37c3">Occlusion Query</h5>
<div class="outline-text-5" id="text-orgacd37c3">
<p>
深度缓冲区确定了每个像素的可见性。出于性能考虑，如果在一个几何体渲染之前可以确定它是否可见非常有意义。<br />
遮挡查询可以让你确定一个特定的几何在执行深度测试后是否可见。<br />
使用遮挡查询的步骤：<br />
（1）为你需要的每一个遮挡查询生成一个查询 id。<br />
void glGenQueries(GLsizei n,GLuint* ids);<br />
（2）调用 glBeginQuery()指定开始遮挡查询<br />
（3）渲染做遮挡测试的几何体<br />
（4）调用 glEndQuery()指定遮挡查询完成<br />
（5）获取通过深度测试的片段数据<br />
void glGetQueryObjectiv(GLenum id,GLenum pname,GLint* params)<br />
void glGetQueryObjectuiv(GLenum id, GLenum pname, GLuint *params);<br />
（6）清除遮挡查询对象<br />
void glDeleteQueries(GLsizei n, const GLuint *ids);<br />
</p>
</div>
</div>
<div id="outline-container-org6172b38" class="outline-5">
<h5 id="org6172b38">Conditional Rendering</h5>
<div class="outline-text-5" id="text-org6172b38">
<p>
遮挡查询的一个问题是它需要 OpenGL 暂停处理几何体和片段，记录深度缓冲区中受影响的片段的数目，<br />
并将该值返回给应用程序。以这种方式停止图形硬件，在性能敏感的应用程序中，会影响到性能。<br />
为了消除暂停 OpenGL 的操作，条件渲染允许图形硬件来决定是否等待遮挡查询结果。<br />
void glBeginConditionalRender(GLuint id, GLenum mode);<br />
id 为遮挡查询对象 id<br />
mode 为下列选项之一,用来指定 GPU 在继续渲染之前，是否等待遮挡查询结果<br />
GL_QUERY_WAIT<br />
GL_QUERY_NO_WAIT<br />
GL_QUERY_BY_REGION_WAIT<br />
GL_QUERY_BY_REGION_WAIT<br />
void glEndConditionalRender(void);<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9e7f91a" class="outline-4">
<h4 id="org9e7f91a">六、Per-Primitive Antialiasing</h4>
<div class="outline-text-4" id="text-org9e7f91a">
<ol class="org-ol">
<li>简述<br /></li>
</ol>
<p>
可以使用下面的方法来控制图片显示质量和速度的平衡。<br />
void glHint(GLenum target, GLenum hint);<br />
</p>
<ol class="org-ol">
<li>Antialiasing Lines<br /></li>
</ol>
<p>
glEnable(GL_LINE_SMOOTH);<br />
glEnable(GL_BLEND);<br />
glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);<br />
glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE);<br />
</p>
<ol class="org-ol">
<li>Antialiasing Polygon<br /></li>
</ol>
<p>
glEnable(GL_POLYGON_SMOOTH);<br />
glEnable(GL_BLEND);<br />
glBlendFunc(GL_SRC_ALPHA_STAURATE,GL_ONE);<br />
glHint(GL_POLYGON_SMOOTH_HINT, GL_DONT_CARE);<br />
</p>
</div>
</div>
<div id="outline-container-orgec3d004" class="outline-4">
<h4 id="orgec3d004">七、Framebuffer Objects</h4>
<div class="outline-text-4" id="text-orgec3d004">
</div>
<div id="outline-container-org2b459b0" class="outline-5">
<h5 id="org2b459b0">简述</h5>
<div class="outline-text-5" id="text-org2b459b0">
<p>
到目前为止我们所讨论的缓存区都是由窗口系统默认为我们所创建的。尽管你可以只通过这些默认的缓冲区来运用任何技术，但是，这样会<br />
需要缓冲区之间过多的数据移动。使用帧缓冲区对象创建自己的帧缓冲区，利用它所绑定的渲染缓冲区可以最小化数据 copy 并优化性能。<br />
帧缓冲区对象可用于离屏渲染、更新贴图映射、执行 buffer ping-ponging。<br />
窗口系统创建的默认帧缓冲区是唯一可以显示到显示器上的缓冲区。默认帧缓冲区关联的 color\depth\stencil 渲染缓冲区是自动创建<br />
的。应用程序创建的帧缓冲区对象，需要额外创建这些渲染缓存区和帧缓存区对象关联。默认帧缓冲区对象关联的缓存区不能和应用程序<br />
创建的帧缓冲区对象相关联，反之亦然。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGenFramebuffers</span>(<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>,<span style="color: #ce537a; font-weight: bold;">GLuint</span>* <span style="color: #7590db;">ids</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindFramebuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">framebuffer</span>);
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">target - GL_FRAMEBUFFER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDeleteFramebuffers</span>(<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLuint</span> *<span style="color: #7590db;">ids</span>);
<span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsFramebuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">framebuffer</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glFramebufferParameteri</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">pname</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">param</span>);
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">pname</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAMEBUFFER_DEFAULT_WIDTH</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAMEBUFFER_DEFAULT_HEIGHT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAMEBUFFER_DEFAULT_LAYERS</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAMEBUFFER_DEFAULT_SAMPLES</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf129e51" class="outline-5">
<h5 id="orgf129e51">Renderbuffers</h5>
<div class="outline-text-5" id="text-orgf129e51">
<p>
（1）创建 renderbuffer 对象<br />
渲染缓冲区是由 OpenGL 管理的高效内存，其中保存了格式化的图片数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGenRenderbuffers</span>(<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> *<span style="color: #7590db;">ids</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDeleteRenderbuffers</span>(<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLuint</span> *<span style="color: #7590db;">ids</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glIsRenderbuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">renderbuffer</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindRenderbuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">renderbuffer</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">target &#24517;&#39035;&#20026; GL_RENDERBUFFER</span>
</pre>
</div>
<p>
（2）为 renderbuffer 对象分配空间<br />
第一次以未使用过的 renderbuffer 名字调用 glBindRenderbuffer 时，OpenGL 会创建一个 renderbuffer 对象，其所有状态都是默认值。<br />
将 renderbuffer 关联到帧缓冲区对象之前，需要为其申请存储空间并制定图片格式。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glRenderbufferStorage</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalformat</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glRenderbufferStorageMultisample</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">samples</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalformat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>);
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">target &#24517;&#39035;&#20026; GL_RENDERBUFFER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">internalformat</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110; color-renderable buffer &#20026; GL_RED GL_R8 GL_R16 ...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110; depth-renderable buffer &#20026; GL_DEPTH_COMPONENT GL_DEPTH_COMPONENT16 ...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110; stencil buffer &#20026; GL_STENCIL_INDEX, GL_STENCIL_INDEX1 ...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110; packed depth-stencil &#20026; GL_DEPTH_STENCIL</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>

<p>
（3）将 renderbuffer 关联到 framebuffer 上<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glFramebufferRenderbuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">attachment</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">renderbuffertarget</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">renderbuffer</span>);
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">target GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_FRAMEBUFFER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">attachment GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT, or GL_DEPTH_STENCIL_ATTACHMENT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">renderbuffertarget GL_RENDERBUFFER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">renderbuffer &#20026; 0 &#26102;&#31227;&#38500;&#24403;&#21069;&#20851;&#32852;&#30340; attachment</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>

<p>
（4）检查帧缓冲区的状态<br />
贴图和缓冲区格式以及帧缓冲区附加点的各种组合会产生各种情况导致渲染无法完成。修改帧缓冲区附加之后，最好检查一下帧缓冲区的状态。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #bc6ec5; font-weight: bold;">glCheckFramebufferStatus</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>);
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">target GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_FRAMEBUFFER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#26377;&#20219;&#20309;&#38169;&#35823;&#26102;&#36820;&#22238; 0</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>

<p>
（5）清除缓冲区<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5; font-weight: bold;">glClear</span>(GL_COLOR_BUFFER_BIT);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #7590db;">glClearBuffer</span>{<span style="color: #ce537a; font-weight: bold;">fi</span> <span style="color: #7590db;">ui</span>}<span style="color: #bc6ec5; font-weight: bold;">v</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">drawbuffer</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">TYPE</span> *<span style="color: #7590db;">value</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glClearBufferfi</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">drawbuffer</span>, <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">depth</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">stencil</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">buffer GL_COLOR, GL_DEPTH, or GL_STENCIL</span>
</pre>
</div>

<p>
（6）释放缓冲区<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">OpenGL</span> <span style="color: #bc6ec5; font-weight: bold;">&#25552;&#20379;&#20102;&#19968;&#31181;&#26426;&#21046;&#26469;&#26631;&#35760;&#19968;&#20010;&#21306;&#22495;&#25110;&#25972;&#20010;&#24103;&#32531;&#20914;&#21306;&#19981;&#20877;&#20351;&#29992;&#20102;</span>&#65292;&#21363;&#21487;&#20197;&#37322;&#25918;&#20102;&#12290;
<span style="color: #ce537a; font-weight: bold;">void</span> glInvalidateFramebuffer(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">numAttachments</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLenum</span> *<span style="color: #7590db;">attachments</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glInvalidateSubFramebuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">numAttachmens</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLenum</span> *<span style="color: #7590db;">attachments</span>,
<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">y</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org51b7709" class="outline-4">
<h4 id="org51b7709">八、Writing to Multiple Renderbuffers Simultaneously</h4>
<div class="outline-text-4" id="text-org51b7709">
<p>
通过多个渲染缓冲区（或贴图）来和帧缓冲区对象配合使用时，可以从片段着色器同步写入数据到多个缓冲区。这避免了处理相同顶点数据多次，也避免<br />
了光栅化相同的图元多次。这种技术被称为 MRT（multiple-render target）<br />
</p>
</div>
<div id="outline-container-orgda2a116" class="outline-5">
<h5 id="orgda2a116">指定输出变量和附加点的对应关系</h5>
<div class="outline-text-5" id="text-orgda2a116">
<p>
通过在片段着色器中用 layout 来指定输出变量和帧缓冲区对象附加点的对应关系。<br />
layout (location = 0) out vec4 color;<br />
layout (location = 1) out vec4 normal;<br />
</p>

<p>
也可以在 shader 链接阶段，通过下面的函数来指导链接器来设置合适的关联关系。<br />
void glBindFragDataLocation(GLuint program, GLuint colorNumber,const GLchar *name);<br />
void glBindFragDataLocationIndexed(GLuint program,GLuint colorNumber, GLuint index,const GLchar *name);<br />
GLint glGetFragDataLocation(GLuint program, const GLchar *name);<br />
GLint glGetFragDataIndex(GLuint program, const GLchar *name);<br />
</p>

<p>
如果 shader 中已经指定了 location，则通过上面函数指定的关联就会被忽略。<br />
</p>
</div>
</div>
<div id="outline-container-orgcdb5339" class="outline-5">
<h5 id="orgcdb5339">Selecting Color Buffers for Writing and Reading</h5>
<div class="outline-text-5" id="text-orgcdb5339">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawBuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDrawBuffers</span>(<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">n</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLenum</span> *<span style="color: #7590db;">buffers</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">FRONT BACK &#23545;&#24212;&#20110;&#31383;&#21475;&#31243;&#24207;&#30003;&#35831;&#30340;render buffer</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LEFT RIGHT &#29992;&#20110;VR&#31561;&#31435;&#20307;&#30011;&#38754;&#32472;&#21046;&#26102;&#30003;&#35831;&#30340; render buffer</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_COLOR_ATTACHMENTi &#23545;&#24212;&#20110;&#33258;&#24049;&#30003;&#35831;&#30340;render buffer&#21487;&#29992;&#20110;&#31163;&#23631;&#28210;&#26579;</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">mode -</span><span style="color: #2aa1ae; background-color: #292e34;">  */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_NONE</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRONT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRONT_LEFT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_BACK</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRONT_RIGHT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_LEFT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_BACK_LEFT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RIGHT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_BACK_RIGHT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_FRONT_AND_BACK</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_COLOR_ATTACHMENTi</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glReadBuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">mode</span>);

<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">capability</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#26377;&#19979;&#38754;&#30340; capability &#25903;&#25345;&#25351;&#23450;index</span>
<span style="color: #2aa1ae; background-color: #292e34;">  GL_BLEND</span>
<span style="color: #2aa1ae; background-color: #292e34;">  GL_SCISSOR_TEST</span>
<span style="color: #2aa1ae; background-color: #292e34;">  index &lt; GL_MAX_DRAW_BUFFERS</span>
<span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glEnablei</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">capability</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glDisablei</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">capability</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>);
<span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsEnabledi</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">capability</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orga0253a5" class="outline-5">
<h5 id="orga0253a5">Dual-Source Blending</h5>
<div class="outline-text-5" id="text-orga0253a5">
<p>
Dual source blending 是指一种混合模式，片段着色器输出两个颜色值到相同的 buffer 中。为了实现这个目的，<br />
这两个输出必须指向相同的 buffer 索引，但是用另外的一个参数指定哪个是 color 0，哪个是 color 1。如下：<br />
layout (location = 0, index = 0) out vec4 first_output;<br />
layout (location = 0, index = 1) out vec4 second_output;<br />
上面的第二个输出被用作以下面枚举为参数的混合<br />
GL_SRC1_COLOR<br />
GL_SRC1_ALPHA<br />
GL_ONE_MINUS_SRC1_COLOR<br />
GL_ONE_MINUS_SRC1_ALPHA<br />
</p>

<p>
若 GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 值为 1，则 Dual source 混合和渲染到多个缓冲区无法同时使用。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org05ef196" class="outline-4">
<h4 id="org05ef196">九、Reading and Copying Pixel Data</h4>
<div class="outline-text-4" id="text-org05ef196">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glReadBuffer</span>(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20174;&#20160;&#20040;&#32531;&#20914;&#21306;&#35835;&#21462;&#25968;&#25454;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glReadPixels</span>(<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pixels</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">format -</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RED</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RED_INTEGER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RGB</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RGB_INTEGER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RGBA</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_RGBA_INTEGER</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_STENCIL_INDEX</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_DEPTH_COMPONENT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_DEPTH_STENCIL</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>

  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">type -</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_UNSIGNED_BYTE</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_BYTE</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_UNSIGNED_SHORT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_SHORT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_UNSIGNED_INT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_INT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">...</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL &#24456;&#22810;&#31867;&#22411;&#30340;&#32531;&#20914;&#21306;&#20250;&#20197;&#26631;&#20934;&#21270;[0,1]&#33539;&#22260;&#20197;&#22806;&#30340;&#20540;&#26469;&#23384;&#20648;&#39068;&#33394;&#20540;&#12290;&#36890;&#36807; glReadPixels &#26469;&#35835;&#21462;&#36825;&#20123;&#20540;&#26159;&#65292;&#21487;&#20197;&#20351;&#29992;&#19979;&#38754;&#30340;&#20989;&#25968;&#26469;&#65292;&#25351;&#23450;&#26159;&#21542;&#23558;&#20540;&#22266;&#23450;&#22312;&#26631;&#20934;&#21270;&#33539;&#22260;&#20869;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glClampColor</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">clamp</span>);
  target - GL_CLAMP_READ_COLOR
  clamp  - GL_TRUE GL_FALSE
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f4f20a" class="outline-4">
<h4 id="org4f4f20a">十、Copying Pixel Rectangles</h4>
<div class="outline-text-4" id="text-org4f4f20a">
<p>
下面函数可用于一个缓冲区的不同区域之间 或者 不同帧缓冲区之间 copy 像素.在 copy 过程中可以对像素执行改变尺寸、倒转、转换、过滤操作<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBlitFramebuffer</span>(<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">srcX0</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">srcY0</span>,
  <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">srcX1</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">srcY1</span>,
  <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">dstX0</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">dstY0</span>,
  <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">dstX1</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">dstY1</span>,
  <span style="color: #ce537a; font-weight: bold;">GLbitfield</span> <span style="color: #7590db;">buffers</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">filter</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">buffers - &#19979;&#38754;&#26522;&#20030;&#30340;&#20301;&#25110;,&#25351;&#23450; copy &#21738;&#20123; buffer &#20013;&#30340;&#20869;&#23481;</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_COLOR_BUFFER_BIT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_DEPTH_BUFFER_BIT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_STENCIL_BUFFER_BIT</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">filter - &#22914;&#26524;&#28304;&#21644;&#30446;&#26631;&#22823;&#23567;&#19981;&#21516;&#65292;&#21017;&#20351;&#29992;&#35813;&#21442;&#25968;&#25351;&#23450;&#36807;&#28388;&#27169;&#24335;</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_NEAREST</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">GL_LINEAR</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f19da4" class="outline-3">
<h3 id="org3f19da4">Viewing Transformations,Clipping,and Feedback</h3>
<div class="outline-text-3" id="text-org3f19da4">
</div>
<div id="outline-container-org5e39b78" class="outline-4">
<h4 id="org5e39b78">一、Viewing</h4>
<div class="outline-text-4" id="text-org5e39b78">
<p>
将三维变为二维用到的关键工具有：视图模型、标准设备坐标的使用、通过矩阵乘运用线性变换、设置视图映射。<br />
</p>
<ol class="org-ol">
<li>Camera Model<br /></li>
</ol>
<p>
制作需要的视图所进行的变换处理和用照相机拍照片类似。<br />
拍照片的步骤：<br />
（1）放置照相机<br />
（2）放置模型<br />
（3）选择镜头<br />
OpenGL 渲染图片的步骤：<br />
（1）将照相机移动到你想放置的地方，并且将它的方向放置正确。【视图变换】<br />
（2）将被拍摄的物体放到场景中。【模型变换】<br />
（3）选择照相机摄像头调解缩放。【投影变换】<br />
（4）拍照<br />
（5）放大或缩小结果图片到需要的尺寸。【视口变换】<br />
步骤 3 决定了场景中多少内容被拍摄到。<br />
步骤 5 决定了被拍摄到的内容放到多大的屏幕上。<br />
</p>
<ol class="org-ol">
<li>Viewing Frustum<br /></li>
</ol>
<p>
OpenGL 会排除太近或太远的几何体，也就是说在 near 平面前面的或在 far 平面后面的物体会被排除。<br />
靠近视景体顶角的物体会非常大，特别是在顶角上时，这会造成问题。物体太远时出于性能原因，以及<br />
深度精度问题，太远的物体会被排除。<br />
</p>
<ol class="org-ol">
<li>Frustum Clipping<br /></li>
</ol>
<p>
图元跨越裁剪平面时，OpenGL 会裁剪这样的图元。<br />
</p>
<ol class="org-ol">
<li>Orthographic Viewing Model<br /></li>
</ol>
<p>
物体正交投影投影后，维持物体实际尺寸以及他们之间的夹角不变。正交投影只是忽略一个维度的坐标。<br />
</p>
</div>
</div>

<div id="outline-container-orgfa5bd1e" class="outline-4">
<h4 id="orgfa5bd1e">二、User Transformations</h4>
<div class="outline-text-4" id="text-orgfa5bd1e">
</div>
<div id="outline-container-orgcef6695" class="outline-5">
<h5 id="orgcef6695">Matrix Multiply Refresher</h5>
<div class="outline-text-5" id="text-orgcef6695">
<p>
C(B(Av)) = (CBA)v<br />
可以利用上面的原理来优化性能<br />
</p>
</div>
</div>
<div id="outline-container-org762d2ca" class="outline-5">
<h5 id="org762d2ca">Homogeneous Coordinates</h5>
<div class="outline-text-5" id="text-org762d2ca">
<p>
将三维坐标转化为四维齐次坐标有两个好处：<br />
（1）可以进行透视投影<br />
（2）可以通过线性变换来表示平移<br />
</p>
</div>
</div>
<div id="outline-container-org896e077" class="outline-5">
<h5 id="org896e077">线性变换和矩阵</h5>
<div class="outline-text-5" id="text-org896e077">
<ul class="org-ul">
<li>变换物体和变换坐标系<br />
有些情况下需要进行物体变换，另外一些情况下则需要进行坐标系变换。但是，这两种变换实际上是等价的，将物体变换一个量等价于将坐标系变换一个相反的量。<br />
变换坐标系，其实就是将以该坐标系表示的所有物体都进行和该坐标系相同的变换。<br />
详情可以参考，ComputerGraphicMath 这篇博客的内容。<br /></li>
<li><p>
平移<br />
</p>
<pre class="example" id="orgfc64250">
  x,y,z 都平移 2.5
  
  1.0 0.0 0.0 2.5   x   x+2.5
  0.0 1.0 0.0 2.5 * y = y+2.5
  0.0 0.0 1.0 2.5   z   z+2.5
  0.0 0.0 0.0 1.0   1   1    
</pre></li>
<li><p>
缩放<br />
</p>
<pre class="example" id="org9957963">
  x,y,z 都缩放 3 倍
  3.0 0.0 0.0 0.0   x   3x
  0.0 3.0 0.0 0.0 * y = 3y
  0.0 0.0 3.0 0.0   z   3z
  0.0 0.0 0.0 1.0   1   1 
</pre></li>
<li><p>
Rotation<br />
</p>
<pre class="example" id="org9242ea7">
  沿 x 轴旋转 50 度
  1.0  0.0    0.0   0.0   x      x            
  0.0  cos50 -sin50 0.0   y    cos50*y-sin50*z
  0.0  sin50  cos50 0.0 * z =  sin50*y+cos50*z
  0.0  0.0    0.0   1.0   1      1            
  沿 y 轴旋转 50 度
  cos50  0.0   sin50 0.0   x    cos50*x+sin50*z
  0.0    1.0   0.0   0.0   y      y            
  -sin50  0.0   cos50 0.0 * z = -sin50*x+cos50*z
  0.0    0.0   0.0   1.0   1      1            
  沿 z 轴旋转 50 度
  cos50  -sin50 0.0 0.0   x   cos50*x-sin50*y
  sin50   cos50 0.0 0.0 * y = sin50*x+cos50*y
  0.0     0.0   1.0 0.0   z      z           
  0.0     0.0   0.0 1.0   1      1           
  沿任意轴(Rx,Ry,Rz)旋转 o 度
</pre></li>
<li><p>
Shearing 切变<br />
</p>
<pre class="example" id="orgc040385">
  1 s  *  x  =  x+sy 
  0 1     y      y   
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgc53b543" class="outline-5">
<h5 id="orgc53b543">Perspective Projection / Orthographic Projection</h5>
<div class="outline-text-5" id="text-orgc53b543">
<p>
构造透视投影矩阵和正交投影矩阵<br />
<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a><br />
</p>
</div>
</div>
<div id="outline-container-org6c2cd07" class="outline-5">
<h5 id="org6c2cd07">法线变换</h5>
<div class="outline-text-5" id="text-org6c2cd07">
<p>
法线向量只用了三维，没有用齐次坐标。因为：<br />
（1）平移物体不会修改它的法线，所以法线不需要考虑平移问题<br />
（2）法线向量用来进行光照计算，其在透视投影之前进行，所以法线向量不需要透视投影。<br />
需要注意的是法线向量的变换公用物体的变换。<br />
\(n_{eye} = (M^{−1})^Tn_{obj}\)<br />
</p>

<p>
<a href="http://www.songho.ca/opengl/gl_normaltransform.html">http://www.songho.ca/opengl/gl_normaltransform.html</a><br />
<a href="http://www.cnblogs.com/hefee/p/3817397.html">http://www.cnblogs.com/hefee/p/3817397.html</a><br />
</p>
</div>
</div>
<div id="outline-container-orgdae3550" class="outline-5">
<h5 id="orgdae3550">OpenGL Matrices</h5>
<div class="outline-text-5" id="text-orgdae3550">
<p>
为了优化性能，将对于每个顶点都相同的矩阵运算放在应用程序中进行，计算完毕后传递给顶点着色器。<br />
（1）OpenGL 中的矩阵行列<br />
opengl 中矩阵是列主序的。通过矩阵转置操作可以将列主序矩阵转化为行主序，反之亦然。<br />
列主序 行主序 影响了矩阵运算的顺序，行主序矩阵从左到右依次计算，列主序矩阵从右到左依次计算。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  mat3x4 m;
  vec4 v = m[1]; <span style="color: #2aa1ae; background-color: #292e34;">// v &#26159;&#30697;&#38453; m &#30340;&#31532;&#20108;&#21015;&#21521;&#37327;</span>
</pre>
</div>
<p>
<a href="http://blog.csdn.net/oracleot/article/details/5378746">http://blog.csdn.net/oracleot/article/details/5378746</a><br />
</p>
</div>
</div>
<div id="outline-container-org222ffaa" class="outline-5">
<h5 id="org222ffaa">实现一个摄像机类</h5>
<div class="outline-text-5" id="text-org222ffaa">
<p>
实现一个摄像机其实就是定义一个视觉坐标系。定义这个坐标系，需要坐标系源点在世界坐标系中的位置，以及三个互相垂直的方向向量。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lookAt &#20989;&#25968;&#36820;&#22238;&#19968;&#20010;&#30697;&#38453;&#65292;&#21487;&#20197;&#23454;&#29616;&#19990;&#30028;&#22352;&#26631;&#21040;&#35270;&#35273;&#22352;&#26631;&#30340;&#36716;&#25442;</span>
glm::mat4 CameraMatrix = glm::LookAt(
    cameraPosition, <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the position of your camera, in world space</span>
    cameraTarget,   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">where you want to look at, in world space</span>
    upVector        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">probably glm::vec3(0,1,0), but (0,-1,0) would make you looking upside-down, which can be great too</span>
);
</pre>
</div>

<ul class="org-ul">
<li><p>
实现在场景中移动<br />
只需要移动摄像机的坐标就可以实现。<br />
按下 a 时向左移动，按下 d 时向右移动，按下 w 向前移动，按下 s 向后移动。<br />
以向左移动为例，实现方法为，将摄像机坐标系下向左的单位向量 \(left_v=(-1,0,0)\) 转换到世界坐标系中 \(left_w\) ，然后将 \(摄像机坐标+left_w\)<br />
</p>
<div class="org-src-container">
<pre class="src src-c">    <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">left_view</span> = glm::vec3(-1,0,0,1);
    <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">left_world</span> = glm::normalize(glm::inverse(CameraMatrix) * left_view);
    cameraPosition = cameraPosition + left_world;
    CameraMatrix = glm::LookAt(
                               cameraPosition,
                               cameraTarget,
                               upVector
                               );
</pre>
</div></li>
<li><p>
实现在场景中转动视角<br />
只需要旋转摄像机的朝向就可以实现。<br />
鼠标往左移动往左转，鼠标往右移动往右转。<br />
以向左转为例，实现方法为，将世界坐标系下 cameraTarget 向量绕 upVector 向量逆时针旋转 angle 角度<br />
</p>
<div class="org-src-container">
<pre class="src src-c">    glm::quat rotate = glm::normalize(glm::angleAxis(glm::radians(angle), upVector));
    cameraTarget = rotate * cameraTarget;
    CameraMatrix = glm::LookAt(
                               cameraPosition,
                               cameraTarget,
                               upVector
                               );
</pre>
</div></li>
<li><p>
实现场景的缩放<br />
鼠标滚轮向上滚动场景放大，鼠标滚轮向下滚动场景缩小。<br />
以场景放大为例，实现方法为，增大视野<br />
</p>
<div class="org-src-container">
<pre class="src src-c">    fov = fov + delta;
    projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f); 
</pre>
</div></li>
</ul>
<p>
<a href="https://learnopengl.com/#!Getting-started/Camera">https://learnopengl.com/#!Getting-started/Camera</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4b9e9d1" class="outline-4">
<h4 id="org4b9e9d1">三、OpenGL Transformations</h4>
<div class="outline-text-4" id="text-org4b9e9d1">
<ol class="org-ol">
<li>在 OpenGL 中指定最近和最远的裁剪平面<br /></li>
</ol>
<p>
void glDepthRange(GLclampd near, GLclampd far);<br />
void glDepthRangef(GLclampf near, GLclampf far);<br />
</p>
<ol class="org-ol">
<li>在 OpenGL 中指定显示区域<br /></li>
</ol>
<p>
void glViewport(GLint x, GLint y, GLint width, GLint height);<br />
</p>
<ol class="org-ol">
<li>多个视口<br /></li>
<li>z 的精度<br /></li>
</ol>
<p>
使用浮点数来做计算会有精度限制。所以数值上不同的深度坐标最后会有相同的 z 浮点值。这会造成错误的隐藏物体。<br />
使用透视除法后，z 的精度会更加糟糕。随着变换后的深度坐标远离近裁剪平面，它的精度会变小。<br />
下面的链接中，通过图示直观地说明了这个问题。<br />
<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a><br />
</p>
<ol class="org-ol">
<li>User Clipping<br /></li>
</ol>
<p>
用户裁切是指添加额外的裁切平面。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #bc6ec5; font-weight: bold;">glEnable</span>(GL_CLIP_PLANE0);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#21551;&#31532; 0 &#20010;&#35009;&#21098;&#24179;&#38754;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glClipPlane</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">plane</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLdouble</span> *<span style="color: #7590db;">equation</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#19968;&#20010;&#35009;&#21098;&#24179;&#38754;&#12290;equation &#21442;&#25968;&#25351;&#21521;&#24179;&#38754;&#26041;&#31243; Ax + By + Cz + D = 0 &#30340; 4 &#20010;&#31995;&#25968;&#12290;</span>

  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">example:</span>
  <span style="color: #ce537a; font-weight: bold;">GLdouble</span> <span style="color: #7590db;">eqn</span> [4]={0.0,1.0,0.0,0.0};  
  <span style="color: #ce537a; font-weight: bold;">GLdouble</span> <span style="color: #7590db;">eqn2</span> [4] ={1.0,0.0,0.0,0.0};
  <span style="color: #bc6ec5; font-weight: bold;">glClipPlane</span>(GL_CLIP_PLANE0,eqn);  
  <span style="color: #bc6ec5; font-weight: bold;">glEnable</span>(GL_CLIP_PLANE0);  
  <span style="color: #bc6ec5; font-weight: bold;">glClipPlane</span>(GL_CLIP_PLANE1,eqn2);  
  <span style="color: #bc6ec5; font-weight: bold;">glEnable</span>(GL_CLIP_PLANE1);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">or clip with shader</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">gl_ClipDistance &#29992;&#26469;&#25351;&#23450;&#23450;&#28857;&#21644;&#24179;&#38754;&#30340;&#20851;&#31995;&#12290;&#36317;&#31163;=0 &#34920;&#31034;&#23450;&#28857;&#22312;&#35009;&#21098;&#24179;&#38754;&#19978;&#65292;&#36317;&#31163;&gt;0 &#34920;&#31034;&#39030;&#28857;&#22312;&#35009;&#21098;&#24179;&#38754;&#20869; (&#39030;&#28857;&#19981;&#20250;&#34987;&#35009;&#21098;)&#65292;&#36317;&#31163;&lt;0 &#34920;&#31034;&#39030;&#28857;&#22312;&#35009;&#21098;&#24179;&#38754;&#22806;(&#39030;&#28857;&#34987;&#35009;&#21098;)&#65307;</span>
<span style="color: #bc6ec5;">  #version</span> 330 core
  uniform <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Plane</span>; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">A,B,C,D for Ax+By+Cz+D=0</span>
  in <span style="color: #ce537a; font-weight: bold;">vect4</span> <span style="color: #7590db;">Vertex</span>;    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">w==1.0</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">gl_ClipDistance</span>[1];
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
  {
      gl_ClipDistance[0] = dot(Vertex, Plane);
  }
</pre>
</div>
<p>
<a href="http://blog.sina.com.cn/s/blog_5ff6097b0100xqvr.html">http://blog.sina.com.cn/s/blog_5ff6097b0100xqvr.html</a><br />
</p>
</div>
</div>
<div id="outline-container-orge3568ee" class="outline-4">
<h4 id="orge3568ee">四、Transform Feedback</h4>
<div class="outline-text-4" id="text-orge3568ee">
</div>
<div id="outline-container-org5f5356d" class="outline-5">
<h5 id="org5f5356d">简述</h5>
<div class="outline-text-5" id="text-org5f5356d">
<p>
Transform feedback 是在顶点处理结束以后，在图元装配和光栅化之前。当顶点数据组合为几何图元时，Transform feedback 捕获这些顶点数据并且可以将他们的属性记录到缓冲区对象中。<br />
</p>
</div>
</div>
<div id="outline-container-org35b751e" class="outline-5">
<h5 id="org35b751e">Transform feedback Objects</h5>
<div class="outline-text-5" id="text-org35b751e">
<p>
transform feedback object 封装了实现 transform feedback 的状态。这些状态包括：<br />
用于保存捕获到的顶点数据的缓冲区、计数索引每个缓冲区有多满、标示 transform feedback 是否是当前激活的。<br />
（1）创建 transform feedback 对象名称<br />
void glGenTransformFeedbacks(GLsizei n, GLuint * ids);<br />
（2）创建/绑定 transform feedback 对象<br />
void glBindTransformFeedback(GLenum target, GLuint id);<br />
GLboolean glIsTransformFeedback(GLenum id);<br />
（3）删除 transform feedback<br />
void glDeleteTransformFeedbacks(GLsizei n, const GLuint ids);<br />
</p>
</div>
</div>
<div id="outline-container-org78531b1" class="outline-5">
<h5 id="org78531b1">Transform Feedback Buffers</h5>
<div class="outline-text-5" id="text-org78531b1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#24403;&#21069;&#32465;&#23450;&#30340;&#32531;&#20914;&#21306;&#23545;&#35937;&#21644;&#32034;&#24341;&#20026; index &#30340; tfbo &#20851;&#32852;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindBufferBase</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">buffer</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindBufferRange</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">index</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">GLintptr</span> <span style="color: #7590db;">offset</span>,<span style="color: #ce537a; font-weight: bold;">GLsizeiptr</span> <span style="color: #7590db;">size</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-target- GL_TRANSFORM_FEEDBACK_BUFFER</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example initialization of a Transform Feedback Buffer</span>
<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">buffer</span>;
glGenBuffers(1, &amp;buffer);

<span style="color: #bc6ec5; font-weight: bold;">glBindBuffer</span>(GL_TRANSFORM_FEEDBACK, buffer);
<span style="color: #bc6ec5; font-weight: bold;">glBufferData</span>(GL_TRANSFORM_FEEDBACK_BUFFER, 1024*1024, <span style="color: #a45bad;">NULL</span>, GL_DYNAMIC_COPY);

<span style="color: #bc6ec5; font-weight: bold;">glBindBufferRange</span>(
                  GL_TRANSFORM_FEEDBACK_BUFFER,
                  0,
                  buffer,
                  0,
                  512*1024
                  );
<span style="color: #bc6ec5; font-weight: bold;">glBindBufferRange</span>(
                  GL_TRANSFORM_FEEDBACK_BUFFER,
                  0,
                  buffer,
                  512*1024,
                  512*1024
                  );
</pre>
</div>
</div>
</div>
<div id="outline-container-org8efd919" class="outline-5">
<h5 id="org8efd919">Configuring Transform Feedback Varyings</h5>
<div class="outline-text-5" id="text-org8efd919">
<p>
在 transform feedback 阶段,指定哪些变量会被记录,以及被记录到哪个 buffer 中<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTransformFeedbackVaryings</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">program</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">count</span>,<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">GLchar</span> ** <span style="color: #7590db;">varyings</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">bufferMode</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-bufferMode-</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_INTERLEAVED_ATTRIBS</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_SEPARATE_ATTRIBS</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#19978;&#38754;&#30340;&#20195;&#30721;&#38656;&#35201;&#22312; glLinkProgram()&#20043;&#21069;&#35843;&#29992;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, gl_SkipComponents4, and gl_NextBuffer.</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example &#25351;&#23450;&#38656;&#35201;&#21453;&#39304;&#21464;&#25442;&#30340;&#21464;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524; bufferMode = GL_INTERLEAVED_ATTRIBS,&#37027;&#20040; foo,bar,baz &#30340;&#20540;&#23558;&#20250;&#32039;&#25384;&#30528;&#35760;&#24405;&#21040; TF &#32531;&#20914;&#21306;&#23545;&#35937;&#20013;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524; bufferMode = GL_SEPARATE_ATTRIBS,&#37027;&#20040; foo,bar,baz &#30340;&#20540;&#23558;&#20250;&#20998;&#21035;&#34987;&#35760;&#24405;&#22312;&#21508;&#33258;&#30340; TF &#32531;&#20914;&#21306;&#23545;&#35937;&#20013;&#12290;</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">vars</span>[] = {<span style="color: #2d9574;">"foo"</span>, <span style="color: #2d9574;">"bar"</span>, <span style="color: #2d9574;">"baz"</span>};
<span style="color: #bc6ec5; font-weight: bold;">glTransformFeedbackVaryings</span>(
                            prog,
                            <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(vars)/<span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>[0]),
                            varyings,
                            GL_INTERLEAVED_ATTRIBS
                            );
<span style="color: #bc6ec5; font-weight: bold;">glTransformFeedbackVaryings</span>(
                            prog,
                            <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>)/<span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>[0]),
                            varyings,
                            GL_SEPARATE_ATTRIBS
                            );
<span style="color: #bc6ec5; font-weight: bold;">glLinkProgram</span>(prog);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example &#22312; TF &#32531;&#20914;&#21306;&#23545;&#35937;&#20013;&#30041;&#19979;&#38388;&#38553;</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">vars</span>[] = {
    <span style="color: #2d9574;">"foo"</span>,
    <span style="color: #2d9574;">"gl_SkipComponents2"</span>,
    <span style="color: #2d9574;">"bar"</span>,
    <span style="color: #2d9574;">"gl_SkipComponents3"</span>
    <span style="color: #2d9574;">"baz"</span>
};
<span style="color: #bc6ec5; font-weight: bold;">glTransformFeedbackVaryings</span>(
                            prog,
                            <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>)/<span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>[0]),
                            varyings,
                            GL_INTERLEAVED_ATTRIBS
                            );

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example Declare the transform feedback varying names</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span> * <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">vars</span>[] =
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Record foo, a gap of 1 float, bar, and then two floats</span>
    <span style="color: #2d9574;">"foo"</span>, <span style="color: #2d9574;">"gl_SkipComponents1"</span>, <span style="color: #2d9574;">"bar"</span>, <span style="color: #2d9574;">"gl_SkipComponents2"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Move to binding point 1</span>
    <span style="color: #2d9574;">"gl_NextBuffer"</span>,
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Leave a gap of 4 floats, then record baz, then leave</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">another gap of 2 floats</span>
    <span style="color: #2d9574;">"gl_SkipComponents4"</span> <span style="color: #2d9574;">"baz"</span>, <span style="color: #2d9574;">"gl_SkipComponents2"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Move to binding point 2</span>
    <span style="color: #2d9574;">"gl_NextBuffer"</span>,
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Move directly to binding point 3 without directing anything</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to binding point 2</span>
    <span style="color: #2d9574;">"gl_NextBuffer"</span>,
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Record iron and copper with a 3 component gap between them</span>
    <span style="color: #2d9574;">"iron"</span>, <span style="color: #2d9574;">"gl_SkipComponents3"</span>, <span style="color: #2d9574;">"copper"</span>
};
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Set the varyings</span>
<span style="color: #bc6ec5; font-weight: bold;">glTransformFeedbackVaryings</span>(prog,
                            <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>) / <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">vars</span>[0]),
                            varyings,
                            GL_INTERLEAVED_ATTRIBS);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Remember to link the program object</span>
<span style="color: #bc6ec5; font-weight: bold;">glLinkProgram</span>(prog);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f50448" class="outline-5">
<h5 id="org2f50448">开始、停止 Transform Feedback</h5>
<div class="outline-text-5" id="text-org2f50448">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBeginTransformFeedback</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">primitiveMode</span>);
-primitiveMode
GL_POINTS
GL_LINES
GL_TRIANGLES
<span style="color: #ce537a; font-weight: bold;">void</span> glPauseTransformFeedback(<span style="color: #ce537a; font-weight: bold;">void</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glResumeTransformFeedback</span>(<span style="color: #ce537a; font-weight: bold;">void</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glEndTransformFeedback</span>(<span style="color: #ce537a; font-weight: bold;">void</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org3417386" class="outline-5">
<h5 id="org3417386">离子系统</h5>
<div class="outline-text-5" id="text-org3417386">
<p>
实现离子系统<br />
<img src="./OpenGL/3_particle_system_simulator.png" alt="3_particle_system_simulator.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgae2d8c2" class="outline-4">
<h4 id="orgae2d8c2">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgae2d8c2">
</div>
<div id="outline-container-org5f4ce25" class="outline-5">
<h5 id="org5f4ce25">关于坐标变换流程</h5>
<div class="outline-text-5" id="text-org5f4ce25">
</div>
<div id="outline-container-org9e1e4bb" class="outline-6">
<h6 id="org9e1e4bb">坐标变换流程是怎样的？</h6>
<div class="outline-text-6" id="text-org9e1e4bb">
<p>
物体坐标系-&gt;世界坐标系-&gt;视觉坐标系-&gt;齐次裁剪坐标系（clipping 坐标系）-&gt;NDC 标准设备坐标系-&gt; 屏幕坐标系<br />
<img src="./OpenGL/1_coordinate_systems.png" alt="1_coordinate_systems.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgfc9bc54" class="outline-6">
<h6 id="orgfc9bc54">坐标裁剪是如何进行的？</h6>
<div class="outline-text-6" id="text-orgfc9bc54">
<p>
对与每个执行了投影变换后的点 (x_c, y_c, z_c, w_c),如果-w_c=&lt;x_c&lt;=w_c, -w_c=&lt;y_c&lt;=w_c, -w_c=&lt;z_c&lt;=w_c 三个条件都满足，就会保留该顶点，否则该顶点将被裁剪掉。<br />
</p>
</div>
</div>
<div id="outline-container-org5d421f4" class="outline-6">
<h6 id="org5d421f4">为什么坐标裁剪不直接在 NDC 坐标系下进行？</h6>
<div class="outline-text-6" id="text-org5d421f4">
<p>
因为在裁剪坐标系下执行裁剪后，后续需要执行透视除法的顶点就会减少，从而提高性能。<br />
</p>
<ul class="org-ul">
<li><a href="https://gamedev.stackexchange.com/questions/65789/why-is-clip-space-always-referred-to-as-homogeneous-clip-space">https://gamedev.stackexchange.com/questions/65789/why-is-clip-space-always-referred-to-as-homogeneous-clip-space</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb23cdf7" class="outline-6">
<h6 id="orgb23cdf7">裁剪坐标系是怎样的坐标系？它的原点-坐标轴是怎样的？</h6>
<div class="outline-text-6" id="text-orgb23cdf7">
<p>
裁剪坐标系是一个齐次坐标系。通过对裁剪坐标系执行透视除法，可以将裁剪坐标系转化<br />
为 NDC 坐标系。<br />
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/18875218/opengl-clip-coordinate">https://stackoverflow.com/questions/18875218/opengl-clip-coordinate</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org85ed03d" class="outline-6">
<h6 id="org85ed03d">OpenGL NDC 标准设备坐标系为什么是左手坐标系？</h6>
<div class="outline-text-6" id="text-org85ed03d">
<p>
因为在视觉坐标系中，摄像机是向着-z 方向看，而在 NDC 坐标系中，摄像机是向着+z 方向看的.<br />
NDC 使用左手坐标系的话，depth 缓冲区中的值越大，表示对应的顶点离近平面越远.<br />
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/9384827/why-is-the-normalized-device-coordinate-system-left-handed">https://stackoverflow.com/questions/9384827/why-is-the-normalized-device-coordinate-system-left-handed</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga85d42f" class="outline-3">
<h3 id="orga85d42f">Textures</h3>
<div class="outline-text-3" id="text-orga85d42f">
<p>
    通常来讲，计算机图形的目的是为了确定组成图像各个部分的颜色。尽管可以通过一个高级的渲染算法来计算像素的颜色，通常这个复杂的渲染器是不实用的。<br />
我们依赖于贴图（大块的图片数据）来绘制物体的表面，让物体更加真实。<br />
</p>
</div>

<div id="outline-container-orge6d6333" class="outline-4">
<h4 id="orge6d6333">一、Texture Mapping</h4>
<div class="outline-text-4" id="text-orge6d6333">
<p>
贴图是由贴图元素组成的。<br />
使用贴图映射的步骤<br />
（1）创建 texture object 并加载贴图数据到其中<br />
（2）在顶点中包含贴图坐标<br />
（3）在渲染器中，将每个你想要使用的贴图地图和一个 texture sampler 关联<br />
（4）在渲染器中，通过 texture sampler 来获取贴图值<br />
</p>
</div>
</div>

<div id="outline-container-orgad3c962" class="outline-4">
<h4 id="orgad3c962">二、Basic Texture Types</h4>
<div class="outline-text-4" id="text-orgad3c962">
<p>
（1）OpenGL 提供了很多类型的贴图对象，他们有各种各样的维度以及布局。<br />
每个贴图对象包含了一组图片来组成完整的贴图。每个图片可以是一维、二维、三维的图元数组，并且多个图片可以堆叠形成 mipmap 金字塔。<br />
贴图数组可以包含一维或二维切片。正方体映射是一种特殊的贴图数组，它包含六个切片。<br />
（2）贴图可用于实现表面多重采样。<br />
（3）贴图通过 texture units 绑定到 OpenGL 上下文。用 GL_TEXTURE0、GL_TEXTUREi 来表示绑定点。<br />
（4）绑定到 OpenGL 上下文的贴图可以通过 sampler variables 来访问。<br />
下表为贴图类型和采样变量类型的对应关系<br />
Target GL_TEXTURE*          Sampleler Type          Dimensionality<br />
1D                          sampler1D               1D<br />
1D_ARRAY                    sampler1DArray          1D array<br />
2D                          sampler2D               2D<br />
2D_ARRAY                    sampler2DArray          2D array<br />
2D_MULTISAMPLE              sampler2DMS             2D multisample<br />
2D_MULTISAMPLE_ARRAY        sampler2DMSArray        2D multisample array<br />
3D                          sampler3D               3D<br />
CUBE                        samplerCube             cube-map texture<br />
ARRAY                       samplerCubeArray        cube-map array<br />
RECTANGLE                   samplerRect             2D rectangle<br />
BUFFER                      samplerBuffer           1D buffer<br />
</p>
</div>
</div>

<div id="outline-container-org2435fe9" class="outline-4">
<h4 id="org2435fe9">三、Creating and Initializing Textures</h4>
<div class="outline-text-4" id="text-org2435fe9">
</div>
<div id="outline-container-org5e68713" class="outline-5">
<h5 id="org5e68713">生成贴图对象名称</h5>
<div class="outline-text-5" id="text-org5e68713">
<p>
void glGenTextures(GLsizei n, GLuint *textures);<br />
</p>
</div>
</div>
<div id="outline-container-orge9f6348" class="outline-5">
<h5 id="orge9f6348">创建/绑定贴图对象到激活的纹理单元</h5>
<div class="outline-text-5" id="text-orge9f6348">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">texture</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-target- </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#32441;&#29702;&#21517;&#31216;&#26159;&#21542;&#20026;&#32441;&#29702;&#23545;&#35937;</span>
<span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsTexture</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">texture</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf941044" class="outline-5">
<h5 id="orgf941044">选择激活的纹理绑定点（纹理单元）</h5>
<div class="outline-text-5" id="text-orgf941044">
<p>
默认激活的纹理绑定点为 GL_TEXTURE0<br />
void glActiveTexture(GLenum texture);<br />
texture GL_TEXTURE0-GL_TEXTUREi<br />
GL_MAX_COMBINED_ TEXTURE_IMAGE_UNITS 用来查询支持的最大纹理单元数目<br />
同一个纹理对象可以同步绑定到多个纹理绑定点。<br />
</p>
</div>
</div>
<div id="outline-container-org3343fa7" class="outline-5">
<h5 id="org3343fa7">删除纹理对象</h5>
<div class="outline-text-5" id="text-org3343fa7">
<p>
void glDeleteTextures(GLsizei n, const GLuint *textures);<br />
</p>
</div>
</div>
<div id="outline-container-org2f8c373" class="outline-5">
<h5 id="org2f8c373">为纹理对象指定存储空间和数据</h5>
<div class="outline-text-5" id="text-org2f8c373">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexStorage1D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">levels</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>);
    target &#24517;&#39035;&#20026; GL_TEXTURE_1D
    internalFormat &#20026; OpenGL &#29992;&#20110;&#23384;&#20648;&#20869;&#37096;&#36148;&#22270;&#25968;&#25454;&#30340;&#26684;&#24335;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexStorage2D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">levels</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexStorage3D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">levels</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">depth</span>)
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexStorage2DMultisample</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">samples</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #7590db;">fixedsamplelocations</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexStorage3DMultisample</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">samples</span>,<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">depth</span>, <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #7590db;">fixedsamplelocations</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23613;&#31649;&#26368;&#22909;&#30340;&#23454;&#36341;&#26159;&#22768;&#26126;&#19981;&#21464;&#30340;&#36148;&#22270;&#23384;&#20648;&#65292;&#20294;&#26159;&#20801;&#35768;&#36148;&#22270;&#23545;&#35937;&#25913;&#21464;&#23610;&#23544;&#20197;&#21450;&#26684;&#24335;&#26159;&#21487;&#20197;&#25903;&#25345;&#30340;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#26041;&#27861;&#25351;&#23450;&#20102;&#21487;&#21464;&#30340;&#32441;&#29702;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexImage1D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">level</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">border</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">data</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">format &#20026; &#24212;&#29992;&#31243;&#24207;&#25552;&#20379;&#30340;&#25968;&#25454;&#30340;&#26684;&#24335;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexImage2D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">level</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">border</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">data</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexImage3D</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">level</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">internalFormat</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">depth</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">border</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">data</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexImage2DMultisample</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">samples</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">internalFormat</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #7590db;">fixedsamplelocations</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTexImage3DMultisample</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">samples</span>,<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">internalFormat</span>,<span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">GLsizei</span> <span style="color: #7590db;">depth</span>, <span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #7590db;">fixedsamplelocations</span>);
</pre>
</div>
<p>
因为多重采样贴图的数据不能被初始化，glTexSubImage2D()也不能用来更新多重采样贴图的内容。将数据载入多重采样贴图的唯一方法是将多重采样贴图和一个 framebuffer 对象相关联，然后将数据渲染到其中。<br />
</p>
</div>
<div id="outline-container-orgc6d75d9" class="outline-6">
<h6 id="orgc6d75d9">Texture Formats</h6>
<div class="outline-text-6" id="text-orgc6d75d9">
<p>
internal format 为 OpenGL 用于存储内部贴图数据的格式。应用程序提供的数据会被转化为这种类型。<br />
Sized Internal Format       Base Internal Format        R Bits          G Bits          B Bits          A Bits<br />
GL_R8                       GL_RED                      8<br />
GL_R8_SNORM                 GL_RED                      s8<br />
GL_R16                      GL_RED                      16<br />
GL_R16_SNORM                GL_RG                       s16<br />
GL_RG8                      GL_RG                       8               8<br />
&#x2026;.<br />
external format 为 应用程序提供的数据的格式。<br />
Format                  Components Present<br />
GL_RED                  Red<br />
GL_GREEN                Green<br />
GL_BLUE                 Blue<br />
GL_RG                   Red, Green<br />
GL_RGB                  Red, Green, Blue<br />
GL_RGBA                 Red, Green, Blue, Alpha<br />
&#x2026;.<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcc0a4a1" class="outline-4">
<h4 id="orgcc0a4a1">四、Proxy Textures</h4>
<div class="outline-text-4" id="text-orgcc0a4a1">
<p>
每一类纹理类型都有与之对应的代理纹理。代理纹理用来测试 OpenGL 实现的能力。<br />
</p>
</div>
</div>

<div id="outline-container-orge1ea97b" class="outline-4">
<h4 id="orge1ea97b">五、Specifying Texture Data</h4>
<div class="outline-text-4" id="text-orge1ea97b">
</div>
<div id="outline-container-org276865e" class="outline-5">
<h5 id="org276865e">Explicitly Setting Texture Data</h5>
<div class="outline-text-5" id="text-org276865e">
<p>
void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format,GLenum type, const void *data);<br />
void glTexSubImage2D(GLenum target, GLint level, GLint xoffset,GLint yoffset, GLsizei width, GLsizei height, GLenum format,<br />
GLenum type, const void *data);<br />
void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,GLsizei width, GLsizei height,<br />
GLsizei depth, GLenum format, GLenum type, const void *data);<br />
</p>
</div>
</div>
<div id="outline-container-org6d44ebc" class="outline-5">
<h5 id="org6d44ebc">Using Pixel Unpack Buffers</h5>
<div class="outline-text-5" id="text-org6d44ebc">
<p>
当没有 buffer 对象绑定到 GL_PIXEL_UNPACK_BUFFER 时，glTexSubImage**()函数的 data 参数指定了数据的地址。<br />
当有 buffer 对象绑定到 GL_PIXEL_UNPACK_BUFFER 时，glTexSubImage**()函数的 data 参数指定了绑定到 GL_PIXEL_UNPACK_BUFFER 的 buffer 的偏移量。<br />
使用 buffer 对象来指定贴图数据的优势是，传递数据到贴图不需要立即执行，直到在渲染器中访问数据。这样数据的传输就可以和应用程序的运行同步进行了。<br />
</p>
</div>
</div>
<div id="outline-container-orgcf0dd7d" class="outline-5">
<h5 id="orgcf0dd7d">Copying Data from the Frambuffer</h5>
<div class="outline-text-5" id="text-orgcf0dd7d">
<p>
可以读取 frambuffer 的部分数据到贴图对象。<br />
void glCopyTexImage1D(GLenum target, GLint level,GLint internalFormat, GLint x, GLint y,GLsizei width, GLint border);<br />
void glCopyTexImage2D(GLenum target, GLint level,GLint internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);<br />
void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y,GLsizei width);<br />
void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,GLint x, GLint y, GLsizei width,GLsizei height);<br />
void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);<br />
虽然可以将 framebuffer 的数据读取到贴图对象，但是更高效的方式是直接将数据渲染到贴图对象中。<br />
void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);<br />
void glFramebufferTexture1D(GLenum target, GLenum attachment,GLenum texturetarget,GLuint texture, GLint level);<br />
void glFramebufferTexture2D(GLenum target,GLenum attachment, GLenum texturetarget, GLuint texture, GLint level);<br />
void glFramebufferTexture3D(GLenum target, GLenum attachment,GLenum texturetarget, GLuint texture, GLint level, GLint layer);<br />
</p>
</div>
</div>
<div id="outline-container-orgc27a3e4" class="outline-5">
<h5 id="orgc27a3e4">Loading Images from Files</h5>
<div class="outline-text-5" id="text-orgc27a3e4">
<p>
使用 QImage 可以加载图片。<br />
QImage temp(GLHelper::GetAbsPathRelativeGResPath("wall.jpg").c_str());<br />
QImage image = temp.convertToFormat(QImage::Format_RGB888);<br />
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image.width(), image.height(),0, GL_RGB, GL_UNSIGNED_BYTE, image.bits());<br />
</p>
</div>
</div>
<div id="outline-container-orge4970e3" class="outline-5">
<h5 id="orge4970e3">Retrieving Texture Data</h5>
<div class="outline-text-5" id="text-orge4970e3">
<p>
可以将贴图中的数据读到应用程序内存或一个 buffer 对象。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glGetTexImage</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">lod</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">type</span>, <span style="color: #ce537a; font-weight: bold;">GLvoid</span>* <span style="color: #7590db;">image</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">target - GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TEXTURE_RECTANGLE. GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35835;&#20837; image &#20013;&#30340;&#25968;&#25454;&#22823;&#23567;&#26159;&#30001; target&#12289;format &#21644; type &#20915;&#23450;&#30340;&#12290;</span>
</pre>
</div>

<p>
通常来讲将数据读入应用程序不是高效的操作，如果必须要读取贴图数据，应该将数据读到 buffer 对象中，然后将 buffer 映射到应用程序中。<br />
(1) 绑定 PBO pixel buffer object<br />
for (int i=0;i&lt;pbo_count;i++)<br />
{<br />
    glBindBuffer(GL_PIXEL_PACK_BUFFER, pbo[i]);<br />
    glReadPixels(0, 0, width, height, fmt, GL_UNSIGNED_BYTE, 0);<br />
}<br />
(2) 隔 2-3 帧后，读取缓冲区中存储的数据<br />
<i>* Read from the oldest bound pbo. *</i><br />
glBindBuffer(GL_PIXEL_PACK_BUFFER, pbos[dx]);<br />
</p>

<p>
ptr = (unsigned char*)glMapBuffer(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY);<br />
if (NULL != ptr) {<br />
    memcpy(pixels, ptr, nbytes);<br />
    glUnmapBuffer(GL_PIXEL_PACK_BUFFER);<br />
}<br />
else {<br />
    SX_ERROR("Failed to map the buffer");<br />
}<br />
</p>

<p>
<i>* Trigger the next read. *</i><br />
SX_DEBUG("glReadPixels() with pbo: %d", pbos[dx]);<br />
glReadPixels(0, 0, width, height, fmt, GL_UNSIGNED_BYTE, 0);<br />
</p>

<p>
<a href="http://www.roxlu.com/2014/048/fast-pixel-transfers-with-pixel-buffer-objects">http://www.roxlu.com/2014/048/fast-pixel-transfers-with-pixel-buffer-objects</a><br />
</p>
</div>
</div>
<div id="outline-container-org876d5c2" class="outline-5">
<h5 id="org876d5c2">Texture Data Layout</h5>
<div class="outline-text-5" id="text-org876d5c2">
<p>
大多数情况图片数据是从左到右，从上到下在内存贴图图元之间紧密排列。<br />
可以通过下面的函数来指定图片数据的排列方式：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glPixelStorei</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">pname</span>, <span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">param</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glPixelStoref</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">pname</span>, <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">param</span>);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">pname - GL_UNPACK_ROW_LENGTH, GL_UNPACK_SWAP_BYTES, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES,</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL_UNPACK_ALIGNMENT, GL_UNPACK_IMAGE_HEIGHT, or GL_UNPACK_LSB_FIRST</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL_PACK_ROW_LENGTH, GL_PACK_SWAP_BYTES, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES,</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL_PACK_ALIGNMENT, GL_PACK_IMAGE_HEIGHT, or GL_PACK_LSB_FIRST</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">unpack  &#21442;&#25968;&#29992;&#26469;&#25351;&#23450; OpenGL &#22914;&#20309;&#20174;&#24212;&#29992;&#31243;&#24207;&#20869;&#23384;&#25110;&#32465;&#23450;&#21040; GL_PIXEL_UNPACK_BUFFER &#30340;&#32531;&#20914;&#21306;&#35835;&#21462;&#25968;&#25454;&#65288;glTexSubImage2D&#65289;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">packing &#21442;&#25968;&#29992;&#26469;&#25351;&#23450; OpenGL &#22914;&#20309;&#23558;&#36148;&#22270;&#25968;&#25454;&#20889;&#20837;&#20869;&#23384;&#65288;glGetTexImage&#65289;.</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8127754" class="outline-4">
<h4 id="org8127754">六、Sampler Objects</h4>
<div class="outline-text-4" id="text-org8127754">
</div>
<div id="outline-container-org373e1e3" class="outline-5">
<h5 id="org373e1e3">简述</h5>
<div class="outline-text-5" id="text-org373e1e3">
<p>
贴图可以通过关联到贴图单元的一个 sampler 变量来读取，并运用 GLSL 内置的函数从贴图图片来获取贴图图元。<br />
sampler 对象中保存了获取图元方式的相关参数。sampler 对象被绑定到 sampler 单元。<br />
贴图对象包含一个内置的 sampler 对象，如果没有 sampler 对象绑定到对应的 sampler 单元，则该默认 sampler 对象用来贴图数据读取。<br />
（1）创建 sampler 对象名称<br />
void glGenSamplers(GLsizei count, GLuint *samplers);<br />
（2）创建/绑定 sampler 对象到 sampler 单元<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glBindSampler</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">unit</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">sampler</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unit &#20026; sampler &#21333;&#20803;&#30340;&#32034;&#24341;&#12290;&#22914;&#26524; sampler &#20026; 0&#65292;&#21017;&#28165;&#38500; sampler &#21333;&#20803;&#19978;&#32465;&#23450;&#30340;&#25152;&#26377; sampler &#23545;&#35937;</span>
<span style="color: #ce537a; font-weight: bold;">GLboolean</span> <span style="color: #bc6ec5; font-weight: bold;">glIsSampler</span>(<span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">id</span>);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glBindTexture &#21644; glBindSampler &#30340;&#19981;&#21516;&#20043;&#22788;&#65306; //void glBindTexture(GLenum target, GLuint texture);</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">--1-- glBindSampler &#27809;&#26377; target &#21442;&#25968;&#12290;&#22240;&#20026; sampler &#23545;&#35937;&#27809;&#26377;&#32500;&#24230;&#19968;&#35828;&#65292;&#25152;&#20197;&#27809;&#24517;&#35201;&#21306;&#21035;&#19981;&#21516;&#31867;&#22411;&#30340; sampler &#23545;&#35937;&#31867;&#22411;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">--2-- glBindSampler &#26377; unit &#21442;&#25968;&#65292;&#27809;&#26377;&#23545;&#24212;&#30340; glActiveSampler &#20989;&#25968;&#12290;glActiveTexture &#30340;&#21442;&#25968;&#20026; GL_TEXTURE0-GLTEXTURi &#30340;&#24120;&#25968;&#65292;i &#30340;&#26368;&#22823;&#20540;&#26159;&#30001;&#23454;&#29616;&#23450;&#20041;&#30340;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unit &#26159;&#19968;&#20010;&#26080;&#31526;&#21495;&#25972;&#25968;&#65292;&#20801;&#35768;&#20219;&#24847;&#25968;&#30446;&#30340; sampler &#21333;&#20803;&#12290;</span>
</pre>
</div>
<p>
（3）删除 sampler object<br />
void glDeleteSamplers(GLsizei count, const GLuint *samplers );<br />
</p>
</div>
</div>
<div id="outline-container-org91617c3" class="outline-5">
<h5 id="org91617c3">Sampler Parameters</h5>
<div class="outline-text-5" id="text-org91617c3">
<p>
void glSamplerParameter{fi}(GLuint sampler, GLenum pname, Type param );<br />
void glSamplerParameter{fi}v(GLuint sampler, GLenum pname, const Type* param );<br />
void glSamplerParameterI{i ui}v(GLuint sampler, GLenum pname,const Type* param );<br />
下面的函数用来设置贴图关联的默认的 sampler object 的参数<br />
void glTexParameter{fi}(GLenum target, GLenum pname, Type param );<br />
void glTexParameter{fi}v(GLenum target, GLenum pname, const Type *param );<br />
void glTexParameterI{i ui}v(GLenum target, GLenum pname, const Type *param );<br />
</p>

<p>
Tips:<br />
关于纹理对象和采样器对象 <a href="http://blog.csdn.net/cyrosly/article/details/5431963">http://blog.csdn.net/cyrosly/article/details/5431963</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb6e4176" class="outline-4">
<h4 id="orgb6e4176">七、Using Textures</h4>
<div class="outline-text-4" id="text-orgb6e4176">
<p>
在 shader 中通过有维度类型的 sampler 变量来表示的。每个 sampler 变量由贴图对象和 sampler 对象组成，贴图对象包含了一组图片数据，<br />
sampler 对象包含了一组采样参数。贴图对象被绑定到贴图单元，sampler 对象被绑定到对应的 sampler 单元。使用 GLSL 的内置函数 texture<br />
可以通过贴图对象和 sampler 对象来访问贴图数据。<br />
gvec4 texture(gsampler1D tex, float P[, float bias]);<br />
gvec4 texture(gsampler2D tex, vec2 P[, float bias]);<br />
gvec4 texture(gsampler3D tex, vec3 P[, float bias]);<br />
gvec4 texture(gsamplerCube tex, vec3 P[, float bias]);<br />
gvec4 texture(gsampler1DArray tex, vec2 P[, float bias]);<br />
gvec4 texture(gsampler2DArray tex, vec3 P[, float bias]);<br />
gvec4 texture(gsampler2DRect tex, vec2 P);<br />
gvec4 texture(gsamplerCubeArray tex, vec4 P[, float bias]);<br />
gvec4 为 vec4, ivec4, or uvec4<br />
gsampler2D 为 sampler2D, isampler2D<br />
</p>
</div>

<div id="outline-container-orgdb90ce4" class="outline-5">
<h5 id="orgdb90ce4">Texture Coordinates</h5>
<div class="outline-text-5" id="text-orgdb90ce4">
<p>
一个贴图被认为在每个维度上占据了从 0.0 到 1.0 的区域。如果贴图坐标在[0.0,1.0]范围外，贴图坐标需要被修改使他们回到[0.0,1.0]范围。<br />
OpenGL 通过下面的采样参数来控制修改贴图坐标的行为：<br />
GL_TEXTURE_WRAP_S 控制 s 轴数据的修改<br />
GL_TEXTURE_WRAP_T 控制 t 轴数据的修改<br />
GL_TEXTURE_WRAP_R 控制 r 轴数据的修改<br />
下面的参数指定了具体修改方式：<br />
GL_CLAMP_TO_EDGE<br />
GL_CLAMP_TO_BORDER<br />
GL_REPEAT<br />
GL_MIRRORED_REPEAT<br />
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br />
</p>
</div>
</div>

<div id="outline-container-org2c6df7e" class="outline-5">
<h5 id="org2c6df7e">Arranging Texture Data</h5>
<div class="outline-text-5" id="text-org2c6df7e">
<p>
static const GLenum abgr_swizzle[] =<br />
{<br />
     GL_ALPHA, GL_RED, GL_GREEN, GL_BLUE<br />
};<br />
// Bind the ABGR texture<br />
glBindTexture(GL_TEXTURE_2D, abgr_texture);<br />
// Set all four swizzle parameters in one call to glTexParameteriv<br />
glTexParameteriv( GL_TEXTURE_2D,<br />
                  GL_TEXTURE_SWIZZLE_RGBA,<br />
                  abgr_swizzle);<br />
// Now bind the RGBx texture<br />
glBindTexture(GL_TEXTURE_2D, rgbx_texture);<br />
<i>/ We’re only setting the GL_TEXTURE_SWIZZLE_A parameter here<br />
/</i> because the R, G, and B swizzles can be left as their default values.<br />
glTexParameteri( GL_TEXTURE_2D,<br />
                 GL_TEXTURE_SWIZZLE_A,<br />
                 GL_ONE);<br />
</p>
</div>
</div>

<div id="outline-container-orgd2f12c4" class="outline-5">
<h5 id="orgd2f12c4">Using Multiple Textures</h5>
<div class="outline-text-5" id="text-orgd2f12c4">
<p>
为了使用多个纹理，需要在 shader 中声明多个 uniform sampler 变量。每个变量会索引不同的纹理单元。<br />
通过 glGetUniformLocation()可以获得 uniform sampler 变量<br />
使用 glUniform1i()可以修改 uniform sampler 变量的值。<br />
使用多个纹理的步骤：<br />
（1）激活每个使用的纹理单元，并将纹理对象绑定到该纹理单元<br />
glActiveTexture()<br />
glBindTexture()<br />
（2）设置 sampler 变量的值为纹理单元的索引<br />
glUniform1i()<br />
e.g:<br />
 glUseProgram(prog);<br />
 <i>/ For the first texture, we will use texture unit 0&#x2026;<br />
 /</i> Get the uniform location<br />
 GLint tex1_uniform_loc = glGetUniformLocation(prog, "tex1");<br />
 // Set it to 0<br />
 glUniform1i(tex1_uniform_loc, 0);<br />
 // Select texture unit 0<br />
 glActiveTexture(GL_TEXTURE0);<br />
 // Bind a texture to it<br />
 glBindTexture(GL_TEXTURE_2D, tex1);<br />
 // Repeat the above process for texture unit 1<br />
 GLint tex2_uniform_loc = glGetUniformLocation(prog, "tex2");<br />
 glUniform1i(tex2_uniform_loc, 1);<br />
 glActiveTexture(GL_TEXTURE1);<br />
 glBindTexture(GL_TEXTURE_2D, tex2);<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org76cd63a" class="outline-4">
<h4 id="org76cd63a">八、Complex Texture Types</h4>
<div class="outline-text-4" id="text-org76cd63a">
<p>
贴图通常为一维或二维图片，但是还有一些其他类型的贴图。例如：3D 贴图、贴图数组、立方体映射、阴影、深度-模板以及缓冲区贴图。<br />
</p>
</div>
<div id="outline-container-org2b90740" class="outline-5">
<h5 id="org2b90740">3D Textures</h5>
<div class="outline-text-5" id="text-org2b90740">
<p>
3D 贴图可以认为是在 3D 网格中排列的体素。<br />
3D 贴图典型应用是在医学图片或流体模拟中的体渲染。<br />
</p>
</div>
</div>
<div id="outline-container-orge153c0d" class="outline-5">
<h5 id="orge153c0d">Array Textures</h5>
<div class="outline-text-5" id="text-orge153c0d">
<p>
有时候需要在一次渲染中访问多个贴图，例如你需要使用一个角色的漫反射贴图、法线贴图、镜面光贴图以及其他的一些属性。如果为每个<br />
贴图使用 glBindTexture()会造成性能影响。贴图数组允许你组合一组一维或二维的贴图，他们拥有相同的大小和格式。<br />
</p>
</div>
</div>
<div id="outline-container-orgb36613f" class="outline-5">
<h5 id="orgb36613f">Cube-Map Textures</h5>
<div class="outline-text-5" id="text-orgb36613f">
<p>
立方体映射贴图用于环境贴图。它包含一组图片，并且将他们当做立方体的每个面。正方体的六个面由六个子贴图表示，他们必须是大小相<br />
同的正方形。<br />
Cube-Map 贴图的贴图坐标为(x,y,z) 一个中心点在原点的单位立方体其表面的点的坐标和 Cube-Map 的贴图坐标一一对应。<br />
（1）Skybox<br />
（2）Environment Map<br />
（3）无缝 Cube-Map<br />
可以使用 glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS)来消除立方体各个面连接处明显的接缝<br />
</p>
</div>
</div>
<div id="outline-container-orgdeef909" class="outline-5">
<h5 id="orgdeef909">Shadow Samplers</h5>
<div class="outline-text-5" id="text-orgdeef909">
<p>
在 GLSL 中提供了一种特殊的采样器即 shadow sampler。shadow sampler 在贴图坐标中使用了额外的分量，用来和获取到<br />
的贴图值进行比较。<br />
使用 shadow sampler 时，从 texture()返回的值在[0.0,1.0]范围内，指示了通过比较操作的贴图值的部分。<br />
对于采样只有一个纹理值（使用了 GL_NEAREST 过滤模式，没有 mipmaps，每个贴图图元只有一个采样）的情况下，返回值为<br />
0.0 或 1.0。0.0 表示没有通过比较操作，1.0 表示通过了比较操作。<br />
如果多个图元用来构造返回给 shader 的值（使用了线性过滤模式，或者使用了多重采样贴图），返回值为[0.0,1.0]范围内的<br />
任何值，该值依赖于通过比较操作的贴图图元的数目。<br />
float texture(gsampler1DShadow tex, vec3 P[, float bias]);<br />
float texture(gsampler2DShadow tex, vec3 P[, float bias]);<br />
float texture(gsamplerCubeShadow tex, vec4 P[, float bias]);<br />
float texture(gsampler1DArrayShadow tex, vec3 P[, float bias]);<br />
float texture(gsampler2DArrayShadow tex, vec4 P[, float bias]);<br />
float texture(gsampler2DRectShadow tex, vec3 P);<br />
float texture(gsamplerCubeArrayShadow tex, vecP P, float compare);<br />
开启关闭比较函数<br />
glSamplerParameteri(sampler,GL_TEXTURE_COMPARE_MODE,GL_COMPARE_REF_TO_TEXTURE)<br />
glSamplerParameteri(sampler,GL_TEXTURE_COMPARE_MODE,GL_NONE)<br />
设置比较函数<br />
glSamplerParameteri(sampler,GL_TEXTURE_COMPARE_FUNC,func)<br />
func 为 GL_LEQUAL, GL_GEQUAL, GL_LESS, GL_GREATER, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS, or GL_NEVER<br />
</p>
</div>
</div>
<div id="outline-container-org065362f" class="outline-5">
<h5 id="org065362f">Depth-Stencil Textures</h5>
<div class="outline-text-5" id="text-org065362f">
<p>
贴图除了可以保存图片数据，通过使用 GL_DEPTH_STENCIL 贴图格式，还可以保存深度和模板值。<br />
默认情况下着色器会读取深度值(GL_DEPTH_COMPONENT)，通过下面函数可以设置着色器来读取模板值(GL_STENCIL_COMPONENTS)<br />
void glTexParameteri(GLenum target​, GL_DEPTH_STENCIL_TEXTURE_MODE, GL_STENCIL_COMPONENTS);<br />
</p>
</div>
</div>
<div id="outline-container-orgda0eda4" class="outline-5">
<h5 id="orgda0eda4">Buffer Textures</h5>
<div class="outline-text-5" id="text-orgda0eda4">
<p>
buffer textures 是一种特殊的贴图类型，它可以让着色器访问一个 buffer 对象，将这个 buffer 对象当做一个很大的一维贴图。<br />
buffer textures 通过 glTexParameteri()设置参数，它没有内置的才采样器并且采样对象对于它是无效的。<br />
buffer textures 和一维贴图的主要区别为：<br />
（1）一维贴图的尺寸限制为 GL_MAX_ TEXTURE_SIZE，而 buffer textures 的尺寸限制为 GL_MAX_TEXTURE_BUFFER_SIZE。<br />
（2）一维贴图支持过滤、mipmaps、纹理坐标包装以及其他的采样器参数。而 buffer textures 都不支持。<br />
（3）一维贴图的贴图坐标是标准化的浮点值，而 buffer textures 使用非标准化的整数贴图坐标。<br />
</p>

<p>
关联 buffer 对象和贴图对象<br />
void glTexBuffer(GLenum target, GLenum internalFormat, GLuint buffer);<br />
void glTexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset,<br />
GLsizeiptr size);<br />
</p>

<p>
在着色器中访问 buffer textures<br />
vec4 texelFetch(samplerBuffer s, int coord);<br />
ivec4 texelFetch(isamplerBuffer s, int coord);<br />
uvec4 texelFetch(usamplerBuffer s, int coord);<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">e.g:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Buffer to be used as the data store</span>
<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">buf</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Texture to be used as a buffer texture</span>
<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">tex</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Data is located somewhere else in this program extern const GLvoid* data;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Generate, bind, and initialize a buffer object</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">using the GL_TEXTURE_BUFFER binding. Assume we&#8217;re</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">going to use one megabyte of data here.</span>
glGenBuffers(1, &amp;buf);
<span style="color: #bc6ec5; font-weight: bold;">glBindBuffer</span>(GL_TEXTURE_BUFFER,  buf);
<span style="color: #bc6ec5; font-weight: bold;">glBufferData</span>(GL_TEXTURE_BUFFER,  1024 * 1024,
             data, GL_STATIC_DRAW);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Now create the buffer texture and associate it</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">with the buffer object.</span>
glGenTextures(1, &amp;tex);
<span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(GL_TEXTURE_BUFFER, tex);
<span style="color: #bc6ec5; font-weight: bold;">glTexBuffer</span>(GL_TEXTURE_BUFFER, GL_R32F, buf);

<span style="color: #bc6ec5;">#version</span> 330 core
uniform samplerBuffer buf
in <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">buf_tex_coord</span>;
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 0) out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)
{
    color = texelFetch(buf, tex_coord);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org12b18fd" class="outline-4">
<h4 id="org12b18fd">九、Texture Views</h4>
<div class="outline-text-4" id="text-org12b18fd">
<p>
OpenGL 允许多个贴图公用一个数据存储。<br />
首先 创建一个贴图将其初始化为大小不可变的。<br />
其次 创建一个贴图的贴图视图。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">glTextureView</span>(<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">texture</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">target</span>,<span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">origTexture</span>, <span style="color: #ce537a; font-weight: bold;">GLenum</span> <span style="color: #7590db;">internalFormat</span>,
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">minLevel</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">numLevels</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">minLayer</span>, <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">numLayers</span>);
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">target &#21644; origTexture &#24517;&#39035;&#21305;&#37197;</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">Original Target(GL_TEXTURE*)        Compatible Targets(GL_TEXTURE*)</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">1D                                  1D,1D_ARRAY</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">2D                                  2D,2D_ARRAY</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">internalFormat &#20063;&#24517;&#39035;&#21644; origTexture &#30340; internalFormat &#21305;&#37197;</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">OriginalTarget          CompatibleTargets</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">128-bit                 GL_RGBA32F,GL_RGBA32UI,GL_RGBA32I</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">......</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
</pre>
</div>
<p>
创建了贴图的视图以后，可以在任何可以使用贴图的地方使用贴图视图，包括图片加载和存储或者帧缓存附件，还可以创建<br />
贴图视图的贴图视图，每个视图都会保存一个到原始数据存储的引用。删除原始的贴图也是合法的。只要有一个数据的视图<br />
存在，真实的数据就不会被删除。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">e.g 1: Creating a Texture View with a New Format</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Create two texture names - one will be our parent,</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">one will be the view</span>
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">tex</span>[2];
  glGenTextures(2, &amp;tex);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Bind the first texture and initialize its data store</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Here, the store will be 1024 x 1024 2D texture with</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mipmaps and the format will be GL_RGB8 - 8-bits per</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">component RGB, unsigned normalized</span>
  <span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(GL_TEXTURE_2D, <span style="color: #ce537a; font-weight: bold;">tex</span>[0]);
  <span style="color: #bc6ec5; font-weight: bold;">glTexStorage2D</span>(GL_TEXTURE_2D, 10, GL_RGB8, 1024, 1024);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Now,.create a view of the texture, this time using // GL_RGB8UI so as to receive the raw data from the texture</span>
  <span style="color: #bc6ec5; font-weight: bold;">glTextureView</span>(<span style="color: #ce537a; font-weight: bold;">tex</span>[1],           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">New texture view</span>
                GL_TEXTURE_2D,    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Target for the new view</span>
                <span style="color: #ce537a; font-weight: bold;">tex</span>[0],           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Original texture</span>
                GL_RGB8UI,        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">New format</span>
                0, 10,            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">All mipmaps</span>
                0, 1);            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Only one layer</span>

  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">e.g 2: Creating a Texture View with a New Target</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Create two texture names - one will be our parent,</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">one will be the view</span>
  <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">tex</span>[2];
  glGenTextures(2, &amp;tex);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Bind the first texture and initialize its data store</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">We are going to create a 2D array texture with a layer</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">size of 256x256 texels and 100 layers.</span>
  <span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, <span style="color: #ce537a; font-weight: bold;">tex</span>[0]);
  <span style="color: #bc6ec5; font-weight: bold;">glTexStorage3D</span>(GL_TEXTURE_2D_ARRAY, 8, GL_RGAB32F, 256, 256, 100);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Now,.create a GL_TEXTURE_2D view of the texture,</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">extracting a single slice from the middle of the array</span>
  <span style="color: #bc6ec5; font-weight: bold;">glTextureView</span>(<span style="color: #ce537a; font-weight: bold;">tex</span>[1],           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">New texture view</span>
                GL_TEXTURE_2D,    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Target for the new view</span>
                <span style="color: #ce537a; font-weight: bold;">tex</span>[0],           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Original texture</span>
                GL_RGBA32F,       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Same format as original texture</span>
                0, 8,             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">All mipmaps</span>
                50, 1);           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Only one layer</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-org1be2608" class="outline-4">
<h4 id="org1be2608">十、Compressed Textures</h4>
<div class="outline-text-4" id="text-org1be2608">
<p>
有两种方法可以将压缩数据放入 OpenGL。<br />
第一种方法是让 OpenGL 为你压缩数据。<br />
这种情况下你提供非压缩数据，但是指定一种 压缩类型的内部格式。OpenGL 实现会获取原始未压缩数据然后对其进行压缩。因为这是实时的过程，所以 OpenGL 通常会实 现一个比较简单的算法从而可以快速压缩数据，导致压缩图片质量比较低。<br />
</p>

<p>
第二种方法是离线压缩数据，然后将压缩过的数据直接传递给 OpenGL。<br />
使用这种方法，你可以花足够的时间来达到想要的图 片质量而不牺牲运行时性能。 有很多种压缩算法和压缩格式，并且不同的硬件和 OpenGL 实现会支持不同的格式。为了确定你的 OpenGL 实现支持哪些格式， 你需要检查扩展的实现列表。<br />
</p>

<p>
OpenGL 会保证支持两种家族格式。RGTC(Red-Green 贴图压缩格式)和 BPTC(Block Partitioned 贴图压缩格式)。两种<br />
格式都是基于块的并且将图元以 4x4 的图元块为单位存储，每一个都独立压缩。这样的数据块很容易被硬件解压。<br />
</p>

<p>
使用离线压缩图片时，可使用下面的方法指定可变的存储<br />
void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalFormat,<br />
GLsizei width, GLint border, GLsizei imageSize, const void *data);<br />
&#x2026;&#x2026;<br />
</p>

<p>
使用离线压缩图片时，更新压缩贴图的部分数据<br />
void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width,<br />
GLenum format, GLsizei imageSize, const void *data);<br />
&#x2026;&#x2026;<br />
</p>
</div>
</div>

<div id="outline-container-org796da7a" class="outline-4">
<h4 id="org796da7a">十一、Filtering</h4>
<div class="outline-text-4" id="text-org796da7a">
</div>
<div id="outline-container-org613a146" class="outline-5">
<h5 id="org613a146">简述</h5>
<div class="outline-text-5" id="text-org613a146">
<p>
贴图映射可以是直线、正方形、矩形甚至是 3，贴图被映射到一个多边形或表面并且被转换为屏幕坐标后，贴图的每个独立的图元<br />
很少会直接对应屏幕图片的每个独立的像素。依赖于使用的变换以及应用的贴图映射，屏幕上的一个像素可能对应一个贴图图元的<br />
一小部分，或者一组图元的集合。<br />
</p>
</div>
</div>
<div id="outline-container-org73b2b8f" class="outline-5">
<h5 id="org73b2b8f">Linear Filtering</h5>
<div class="outline-text-5" id="text-org73b2b8f">
<p>
只要贴图的采样率相对于图片的尖峰数据足够高，线性重建的图片依然会有相当高的质量。<br />
OpenGL 获得你传递给它的贴图坐标，并且查找两个最靠近的样本。依据到这两个点的距离为这两个样本创建权值，然后使用它们的<br />
权值来创建一个平均权值。<br />
线性过滤不仅可用于 1D 2D 3D 贴图，它还可用于邻接的 mipmap。<br />
GL_TEXTURE_MAG_FILTER 和 GL_TEXTURE_MIN_FILTER 这两个参数控制 OpenGL 如何过滤贴图。<br />
贴图被放大时使用 GL_TEXTURE_MAG_FILTER 参数的配置。需求的贴图分辨率比最高分辨率的 mipmap(level0)高.<br />
贴图被缩小时使用 GL_TEXTURE_MIN_FILTER 参数的配置。<br />
</p>
</div>
</div>
<div id="outline-container-orgcfce72b" class="outline-5">
<h5 id="orgcfce72b">Using and Generating Mipmaps</h5>
<div class="outline-text-5" id="text-orgcfce72b">
<p>
GL_TEXTURE_MIN_FILTER 参数控制着，当 mipmap level 比 0 大时，贴图图元如何创建。<br />
GL_NEAREST 和 GL_LINEAR 设置会关闭 mipmapping，OpenGL 只会使用 level0 贴图。<br />
GL_NEAREST_MIPMAP_NEAREST、GL_NEAREST_MIPMAP_LINEAR、GL_LINEAR_MIPMAP_NEAREST、GL_LINEAR_MIPMAP_LINEAR 设<br />
置会启用 mipmapping。GL_A_MIPMAP_B,A 控制如何创建每个 level-mipmap 的图元。NEAREST 表示取最近的图元，LINEAR 表示线性插值<br />
获得图元；B 控制如何将这些样本混合。NEAREST 表示只使用最近 level 的 mipmap，LINEAR 表示取两个最近的 mipmap 进行线性插值。<br />
Tips:<br />
GL_TEXTURE_MAG_FILTER 的默认值为 GL_LINEAR，GL_TEXTURE_MIN_FILTER 的默认值为 GL_LINEAR_MIPMAP_LINEAR。所以默认情况<br />
下会启用 mipmapping。使用 mipmapping 要求完整的 mipmap 集合，即所有 level 的 mipmap 都必须存在，如果没有完整的 mipmap，shader<br />
中会返回无用的贴图数据。<br />
</p>

<p>
为了使用 mipmapping，你必须提供所有 2 的幂尺寸的贴图，这些 2 的幂尺寸的贴图尺寸范围为 1x1 到贴图最大尺寸。<br />
如果你不想使用 mipmapping 一直到 1x1 大小的贴图，你可以设置 GL_TEXTURE_MAX_LEVEL 来指定你提供的最大 level。<br />
如果最高分辨率 level 的贴图不是正方形，在生成 mipmap 时，尺寸小的那个维度将比另一个维度在尺寸上先变为 1.此时会继续生成 mipmap，<br />
直到另一维度的尺寸也变为 1.例如：最高分辨率的图片为 64x16,会生成 32x8,16x4,8x2,4x1,2x1,1x1 尺寸的 mipmap。<br />
</p>

<p>
OpenGL 支持自动生成 mipmap，但是该实现被设计为效率优先于质量，而且不同的实现之间有很大不同。所以当需要高质量，结果一致的时候<br />
最好自己生成 mipmap。<br />
void glGenerateMipmap(GLenum target);<br />
</p>
</div>
</div>
<div id="outline-container-org09dbf3d" class="outline-5">
<h5 id="org09dbf3d">Calculating the Mipmap Level</h5>
<div class="outline-text-5" id="text-org09dbf3d">
<p>
λbase (x, y) = log2 [ρ (x, y)]<br />
λ′ (x, y) = λbase + clamp(biastexobj + biasshader)<br />
</p>

<p>
λ = lodmax,     λ′ &gt; lodmax<br />
λ = λ′,         lodmin ≤ λ′ ≤ lodmax<br />
λ = lodmin,     λ′ &lt; lodmin<br />
λ = undefined,  lodmin &gt; lodmax<br />
</p>

<p>
lodmin 通过 GL_TEXTURE_MIN_LOD 来设置<br />
lodmax 通过 GL_TEXTURE_MAX_LOD 来设置<br />
</p>
</div>
</div>
<div id="outline-container-orgfdb74b7" class="outline-5">
<h5 id="orgfdb74b7">Mipmap Level-of-Detail Control</h5>
<div class="outline-text-5" id="text-orgfdb74b7">
<p>
GL_TEXTURE_BASE_LEVEL 指定 mipmap 的最低等级，即指定最高分辨率的 mipmap 等级<br />
GL_TEXTURE_MAX_LEVEL 指定 mipmap 的最高等级，即指定最低分辨率的 mipmap 等级<br />
</p>

<p>
贴图流的使用：<br />
使用贴图流时，存储完整贴图对象的空间是通过 glTexStorage2D()来申请的，但是初始化数据没有载入，当应用程序运行时，新的对象出现<br />
时，他的贴图数据以从最低分辨率 mipmap 到最高分辨率 mipmap 的顺序进行加载。GL_TEXTURE_BASE_LEVEL 的值被设置为到目前为止载入的<br />
最高分辨率的 mipmap 的 level。这样的话当越来越多的贴图数据载入，屏幕上的物体会越来越清晰。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orged707cf" class="outline-4">
<h4 id="orged707cf">十二、Advanced Texture Lookup Functions</h4>
<div class="outline-text-4" id="text-orged707cf">
<ol class="org-ol">
<li>Explicit Level of Detial<br /></li>
</ol>
<p>
下面函数可以对指定 level 的 texture 进行采样<br />
gvec4 textureLod(gsampler1D tex, float P, float lod);<br />
gvec4 textureLod(gsampler2D tex, vec2 P, float lod);<br />
gvec4 textureLod(gsampler3D tex, vec3 P, float lod);<br />
gvec4 textureLod(gsamplerCube tex, vec3 P, float lod);<br />
gvec4 textureLod(gsampler1DArray tex, vec2 P, float lod);<br />
gvec4 textureLod(gsampler2DArray tex, vec3 P, float lod);<br />
gvec4 textureLod(gsampler2DRect tex, vec2 P, float lod);<br />
gvec4 textureLod(gsamplerCubeArray tex, vec4 P, float lod);<br />
</p>

<ol class="org-ol">
<li>Explicit Gradient Specification<br /></li>
</ol>
<p>
可以通过下面的函数，覆盖 mipmapping 的 level-of-detail 计算。<br />
gvec4 textureGrad(gsampler1D tex, float P,float dPdx, float dPdy);<br />
gvec4 textureGrad(gsampler2D tex, vec2 P,vec2 dPdx, vec2 dPdy);<br />
gvec4 textureGrad(gsampler3D tex, vec3 P,vec3 dPdx, vec3 dPdy);<br />
gvec4 textureGrad(gsamplerCube tex, vec3 P,vec3 dPdx,vec3 dPdy);<br />
gvec4 textureGrad(gsampler1DArray tex, vec2 P,float dPdx,float dPdy);<br />
gvec4 textureGrad(gsampler2DArray tex, vec3 P,vec2 dPdx,vec2 dPdy);<br />
gvec4 textureGrad(gsamplerCubeArray tex, vec4 P,vec3 dPdx,vec3 dPdy);<br />
</p>

<ol class="org-ol">
<li>Texture Fetch with Offsets<br /></li>
</ol>
<p>
gvec4 textureOffset(gsampler1D tex, float P, int offset, [float bias]);<br />
gvec4 textureOffset(gsampler2D tex, vec2 P, ivec2 offset, [float bias]);<br />
gvec4 textureOffset(gsampler3D tex, vec3 P, ivec3 offset, [float bias]);<br />
gvec4 textureOffset(gsampler1DArray tex, vec2 P, int offset, [float bias]);<br />
gvec4 textureOffset(gsampler2DArray tex, vec3 P, ivec2 offset, [float bias]);<br />
gvec4 textureOffset(gsampler2DRect tex, vec2 P, ivec2 offset, [float bias]);<br />
在执行获取图元之前会偏移 offset 个图元。<br />
</p>

<ol class="org-ol">
<li>Projective Texturing<br /></li>
</ol>
<p>
gvec4 textureProj(gsampler1D tex, vec2 P[, float bias);<br />
gvec4 textureProj(gsampler1D tex, vec4 P[, float bias);<br />
gvec4 textureProj(gsampler2D tex, vec3 P[, float bias);<br />
gvec4 textureProj(gsampler2D tex, vec4 P[, float bias);<br />
gvec4 txtureProj(gsampler3D tex, vec4 P[, float bias);<br />
gvec4 textureProj(gsamplerRect tex, vec3 P);<br />
gvec4 textureProj(gsamplerRect tex, vec4 P);<br />
</p>

<ol class="org-ol">
<li>Texture Queries in Shaders<br /></li>
</ol>
<p>
下面的函数返回 mipmap 信息，返回值为 vec2 类型，x 中保存了被访问的 mipmap 数组。y 返回了 mipmap 的基础 level。<br />
vec2 textureQueryLod(gsampler1D sampler,float P);<br />
vec2 textureQueryLod(gsampler2D sampler,vec2 P);<br />
vec2 textureQueryLod(gsampler3D sampler,vec3 P);<br />
&#x2026;&#x2026;<br />
下面的函数返回样本包含的 mipmap 等级数量<br />
int textureQueryLevels(gsampler1D tex);<br />
int textureQueryLevels(gsampler2D tex);<br />
int textureQueryLevels(gsampler3D tex);<br />
&#x2026;&#x2026;<br />
下面的函数返回贴图的尺寸<br />
int textureSize(gsampler1D tex, int lod);<br />
ivec2 textureSize(gsampler2D tex, int lod);<br />
ivec3 textureSize(gsampler3D tex, int lod);<br />
&#x2026;&#x2026;<br />
</p>

<ol class="org-ol">
<li>Gathering Texels<br /></li>
</ol>
<p>
gvec4 textureGather(gsampler2D tex, vec2 P[, int comp]);<br />
从贴图获取四个贴图图元，comp 指定要获取的分量。0，1，2，3 分别对应 x,y,z,w<br />
textureGather 的返回值:<br />
vec4(Sample_i0_j1(P, base).comp,<br />
     Sample_i1_j1(P, base).comp,<br />
     Sample_i1_j0(P, base).comp,<br />
     Sample_i0_j1(P, base).comp);<br />
</p>

<ol class="org-ol">
<li>Combining Special Functions<br /></li>
</ol>
<p>
组合多个特性的贴图函数<br />
textureProjLod<br />
textureProjGrad<br />
&#x2026;&#x2026;<br />
</p>
</div>
</div>

<div id="outline-container-org8c4f7c8" class="outline-4">
<h4 id="org8c4f7c8">十三、Point Sprites</h4>
<div class="outline-text-4" id="text-org8c4f7c8">
<p>
点精灵本质上是使用片段着色器渲染 OpenGL 点，点中的片段坐标可以通过 gl_PointCoord 获取到。<br />
</p>
<ol class="org-ol">
<li>Texutred Point Sprites<br /></li>
</ol>
<p>
&#x2013; vertex shader &#x2013;<br />
uniform mat4 model_matrix;<br />
uniform mat4 projection_matrix;<br />
layout (location = 0) in vec4 position;<br />
void main(void)<br />
{<br />
     vec4 pos = projection_matrix * (model_matrix * position);<br />
     gl_PointSize = (1.0 - pos.z / pos.w) * 64.0;<br />
     gl_Position = pos;<br />
}<br />
&#x2013; fragment shader &#x2013;<br />
uniform sampler2D sprite_texture;<br />
out vec4 color;<br />
void main(void)<br />
{<br />
     color = texture(sprite_texture, gl_PointCoord);<br />
}<br />
</p>

<ol class="org-ol">
<li>Analytic Color and Shape<br /></li>
</ol>
<p>
out vec4 color;<br />
void main(void)<br />
{<br />
    const vec4 color1 = vec4(0.6, 0.0, 0.0, 1.0);<br />
    const vec4 color2 = vec4(0.9, 0.7, 1.0, 0.0);<br />
    vec2 temp = gl_PointCoord - vec2(0.5);<br />
    float f = dot(temp, temp);<br />
    if (f &gt; 0.25) discard;<br />
    color = mix(color1, color2, smoothstep(0.1, 0.25, f));<br />
}<br />
</p>
<ol class="org-ol">
<li>Controlling the Appearance of Points<br /></li>
</ol>
<p>
可以通过下面的函数控制点的外观<br />
void glPointParameter{if}(GLenum pname, TYPE param);<br />
void glPointParameter{if}v(GLenum pname, const TYPE *param);<br />
pname                           param                               description<br />
GL_POINT_SPRITE_COORD_ORIGIN    GL_LOWER_LEFT GL_UPPER_LEFT         指定点的原点坐标<br />
GL_POINT_FADE_THRESHOLD_SIZE                                        指定 fade 门槛<br />
当点的尺寸低于门槛值时，OpenGL 可以停止真正的反锯齿，而是使用混合将该点淡出为背景色。<br />
</p>
</div>
</div>

<div id="outline-container-org6b0d7e6" class="outline-4">
<h4 id="org6b0d7e6">十四、Rendering to Texture Maps</h4>
<div class="outline-text-4" id="text-org6b0d7e6">
<ol class="org-ol">
<li>简述<br /></li>
</ol>
<p>
通过下面的方法可以将数据渲染到贴图<br />
void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);<br />
&#x2026;&#x2026;<br />
对于三维或一维、二维贴图数组，可以通过下面函数将贴图的单层作为 framebuffer 附加点。<br />
void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);<br />
</p>

<ol class="org-ol">
<li>Discading Rendered Data<br /></li>
</ol>
<p>
首要的规则：在开始渲染一帧之前，你必须清除 framebuffer。<br />
忽略 framebuffer 要比清除它更加高效。<br />
如果你确定新的渲染将完全替换 framebuffer 的内容，你可以通过下面的函数忽略 framebuffer 中的数据：<br />
void glInvalidateFramebuffer(GLenum target,GLsizei numAttachments,const GLenum * attachments);<br />
void glInvalidateSubFramebuffer(GLenum target,GLsizei numAttachments, const GLenum * attachments,<br />
GLint x, GLint y, GLint width, GLint height);<br />
如果你只想忽略和 framebuffer 关联的 texture 的内容，可以使用下面的函数：<br />
void glInvalidateTexImage(GLuint texture, GLint level);<br />
void glInvalidateTexSubImage(GLuint texture, GLint level,GLint xoffset, GLint yoffset,<br />
GLint zoffset, GLint width, GLint height, GLint depth);<br />
</p>
</div>
</div>

<div id="outline-container-orgf5a9bb0" class="outline-4">
<h4 id="orgf5a9bb0">十五、贴图最佳实践</h4>
<div class="outline-text-4" id="text-orgf5a9bb0">
<ol class="org-ol">
<li>Immutable Texuture Storage<br /></li>
</ol>
<p>
尽量使用空间不变的贴图，对于空间不变的贴图，OpenGL 实现可以对其有效性做一定假设。例如，空间不变的贴图总是完整的。<br />
</p>

<ol class="org-ol">
<li>Mipmaps<br /></li>
</ol>
<p>
为贴图创建并初始化 mipmap 链。允许硬件使用低分辨率的 mipmap 不仅可以提高程序渲染图片的质量，而且会让图形处理器的<br />
caches 使用效率更高。贴图 cache 是一小片内存用来存储最近使用过的贴图数据。应用程序使用的贴图越小，放入贴图 cache<br />
的图片就会越多，应用程序运行速度就越快。<br />
</p>

<ol class="org-ol">
<li>Integer Format Textures<br /></li>
</ol>
<p>
当贴图数据使用没标准化的整数时，不要忘记使用整型的采样器(isampler2D,usampler3D,等等)。一个常见的错误是创建<br />
了浮点型的采样器，而使用了整型的内部数据格式。<br />
</p>

<p>
Tips:<br />
1 关于 纹理对象、纹理单元、采样器变量、采样器对象、采样器单元的关系可参考一下文档描述。<br />
<a href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html">http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0e45fd2" class="outline-3">
<h3 id="org0e45fd2">Light and Shadow</h3>
<div class="outline-text-3" id="text-org0e45fd2">
</div>
<div id="outline-container-org849890b" class="outline-4">
<h4 id="org849890b">一、Classic Lighting Model</h4>
<div class="outline-text-4" id="text-org849890b">
</div>
<div id="outline-container-org16f23d0" class="outline-5">
<h5 id="org16f23d0">简述</h5>
<div class="outline-text-5" id="text-org16f23d0">
<p>
经典的光照模型叠加一组独立光照成分来获得整个光照效果。这些光照成分分别为：ambient、diffuse 以及 specular。<br />
</p>

<p>
环境光不是来自于任何特定方向。经典光照模型将它当做一个贯穿整个场景的常量，对于分散在场景中的光形成一个合适的<br />
近似。计算环境光不需要涉及任何对光源方向和观察着方向的分析。它可以是每个光源贡献的值的累计，也可以是一个全局<br />
的常量。<br />
</p>

<p>
漫反射光是物体表面将特定光源的光向所有方向均等地反射的光。即使表面没有将光源直接反射到你的眼睛，因为漫反射的<br />
存在，你依然可以看到表面被点亮。眼睛的方向是无所谓的，但是光源的方向会影响到漫反射。表面越直接面对光源，表面<br />
会越明亮，正对光源的表面比测对光源的表面收集了更多的光。漫反射光的计算依赖于表面的法向量以及光源的方向，以及<br />
表面的颜色，但是不会用到观察者的方向。<br />
</p>

<p>
环境高光是由表面直接反射的光。高亮程度指的是表面材质表现的有多么像一面镜子。一个高度磨光的金属球反射了非常尖<br />
锐的、亮的镜面高光，然而一个磨的钝的会反射一个巨大的、衰减的镜面高光。一个布料球实质上几乎没有反射任何镜面高光。<br />
这个特定角度的效果强度被称为光滑度。计算镜面高光需要知道直接反射光源的光到眼睛，需要表面朝向多近，因此需要知道<br />
表面的法线，光源的方向以及眼睛的方向。<br />
</p>
</div>
</div>
<div id="outline-container-orgcd0981b" class="outline-5">
<h5 id="orgcd0981b">Fragment Shaders for Different Light Styles</h5>
<div class="outline-text-5" id="text-orgcd0981b">
<p>
(1) No Lighting<br />
</p>
<div class="org-src-container">
<pre class="src src-c">----------------------- Vertex Shader -------------------------
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader with no lighting</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform mat4 MVPMatrix; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">model-view-projection transform</span>
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexColor</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sent from the application, includes alpha</span>
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pre-transformed position</span>
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sent to the rasterizer for interpolation</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    Color = VertexColor;
    gl_Position = MVPMatrix * VertexPosition;
}
---------------------- Fragment Shader ------------------------
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader with no lighting</span>
<span style="color: #bc6ec5;">#version</span> 330 core
in vec4 Color;          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">interpolated between vertices</span>
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">color result for this fragment</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    FragColor = Color;
}
</pre>
</div>
<p>
(2) Ambient Light<br />
光自身也可以有颜色而不只是亮度。光的颜色会和被照亮的物体表面的颜色相互作用。这种交互作用可以通过乘法来模拟。<br />
多个光照亮一个物体时，多个光是叠加的关系，使用加法来模拟光的叠加。<br />
用 0.0 表示纯黑，用 1.0 表示满强度。<br />
光的颜色可以比 1.0 高，特别是我们将多个光源的光进行叠加。我们会使用 min()来使光饱和到白色。输出到 framebuffer 的颜色值需要应用 min(),计算过程中的中间值不需要。<br />
如果物体颜色中包含 alpha 成分，而且不希望光照修改它的 alpha。可以将片段着色器输出颜色的 alpha 成分设置为物体颜色 的 alpha。<br />
光照计算也可以放在顶点着色器中进行，片段着色器中会获得插值后的结果。因为顶点着色器通常处理的顶点要比片段着色器 处理的片段少很多，所以顶点着色器中计算光照会更加高效。但是，对于很多光照技术，插值的结果会不同，基于每个片段的 光照计算要比基于每个顶点的光照计算质量更高。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">--------------------------- Vertex Shader -----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for ambient light</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexColor</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
     Color = VertexColor;
     gl_Position = MVPMatrix * VertexPosition;
}
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------- Fragment Shader ----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader for global ambient lighting</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Ambient</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sets lighting level, same across many vertices</span>
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
<span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">vec4 scatteredLight = Ambient; // this is the only light</span>
<span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">// modulate surface color with light, but saturate at white</span>
<span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">FragColor = min(Color * scatteredLight, vec4(1.0));</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">scatteredLight</span> = vec3(Ambient);
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">rgb</span> = min(Color.rgb*scatteredLight,vec3(1.0));
    FragColor = vec4(rgb,Color.a);
}
</pre>
</div>
<p>
(3) Directional Light<br />
如果光非常的远，可以近似地认为物体表面上每点的光的方向都是相同的。将这种光称为方向光。类似的，当观察者非常远时， 可以近似地认为物体表面上每点的眼睛的方向都是相同的。这种简化让方向光的代码实现很简单并且运行速度比其他类型的光照 更快。这种类型的光对于模拟像太阳这样的光源很有用。<br />
就像环境光一样，方向光也有自己的颜色，我们将依据漫反射的分散，用光的颜色来调整物体表面的颜色。镜面成分的贡献会被分开计算，这样镜面高亮就是光源的颜色，而不是物体表面颜色的调整。<br />
镜面高光的反光度是通过一个指数来测量，用来加快直接反射方向的角度的减少。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Directional Light Source Lighting</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">--------------------------- Vertex Shader -----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for a directional light computed in the fragment shader</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat3</span> <span style="color: #7590db;">NormalMatrix</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to transform normals, pre-perspective</span>
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexColor</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">VertexNormal</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    Color = VertexColor;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we now need a surface normal</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">interpolate the normalized surface normal</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">transform the normal, without perspective, and normalize it</span>
    Normal = normalize(NormalMatrix * VertexNormal);
    gl_Position = MVPMatrix * VertexPosition;
}
-------------------------- Fragment Shader ----------------------------
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader computing lighting for a directional light</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform vec3 Ambient;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightColor</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightDirection</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">direction toward the light</span>
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">HalfVector</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Shininess</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Strength</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">surface orientation for shiniest spots</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exponent for sharping highlights</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">extra factor to adjust shininess</span>
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">surface normal, interpolated between vertices</span>
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compute cosine of the directions, using dot products,</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to see how much light would be reflected</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">diffuse</span> = max(0.0, dot(Normal, LightDirection));
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">specular</span> = max(0.0, dot(Normal, HalfVector));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">surfaces facing away from the light (negative dot products)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">won&#8217;t be lit by the directional light</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (diffuse == 0.0)
    {
        specular = 0.0;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        specular = pow(specular, Shininess); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sharpen the highlight</span>
    }
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">scatteredLight</span> = Ambient + LightColor * diffuse;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">reflectedLight</span> = LightColor * specular * Strength;
     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don&#8217;t modulate the underlying color with reflected light,</span>
     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">only with scattered light</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">rgb</span> = min(Color.rgb * scatteredLight + reflectedLight, vec3(1.0));
    FragColor = vec4(rgb, Color.a);
}
</pre>
</div>

<p>
(4) Point Lights<br />
点光模拟靠近场景或者是场景内的光，例如灯光或者天花板灯光或者街道上的灯光。点光源和方向光源之间主要有两个不同点：<br />
首先：对于物体表面上的每个点来说，点光源的方向是不同的。<br />
其次：物体表面接收到的光会随着和点光源的距离增加而减弱。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Point-Light Source Lighting</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">--------------------------- Vertex Shader -----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for a point-light (local) source, with computation</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">done in the fragment shader.</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat3</span> <span style="color: #7590db;">NormalMatrix</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexColor</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">VertexNormal</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now need the transform, minus perspective</span>
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Position</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">adding position, so we know where we are</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    Color = VertexColor;
    Normal = normalize(NormalMatrix * VertexNormal);
    Position = MVMatrix * VertexPosition;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pre-perspective space</span>
    gl_Position = MVPMatrix * VertexPosition; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">includes perspective</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------- Fragment Shader ----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader computing a point-light (local) source lighting.</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Ambient</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightColor</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightPosition</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Shininess</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Strength</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">location of the light, eye space</span>
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">EyeDirection</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ConstantAttenuation</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">attenuation coefficients</span>
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">LinearAttenuation</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">QuadraticAttenuation</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Position</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">find the direction and distance of the light,</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">which changes fragment to fragment for a local light</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">lightDirection</span> = LightPosition - vec3(Position);
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lightDistance</span> = length(lightDirection);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normalize the light direction vector, so</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">that a dot products give cosines</span>
    lightDirection = lightDirection / lightDistance;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">model how much light is available for this fragment</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">attenuation</span> = 1.0 / (ConstantAttenuation + LinearAttenuation * lightDistance +
    QuadraticAttenuation * lightDistance * lightDistance);
     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the direction of maximum highlight also changes per fragment</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">halfVector</span> = normalize(lightDirection + EyeDirection);
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">diffuse</span> = max(0.0, dot(Normal, lightDirection));
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">specular</span> = max(0.0, dot(Normal, halfVector));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (diffuse == 0.0)
    {
        specular = 0.0;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        specular = pow(specular, Shininess) * Strength;
    }
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">scatteredLight</span> = Ambient + LightColor * diffuse * attenuation;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">reflectedLight</span> = LightColor * specular * attenuation;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">rgb</span> = min(Color.rgb * scatteredLight + reflectedLight, vec3(1.0));
    FragColor = vec4(rgb, Color.a);
}
</pre>
</div>

<p>
(5) Spotlights<br />
在剧场或影院，聚光灯投射一个巨大的光，照亮一个指定的区域。OpenGL 限制产生一个在某个特定方向上的光锥来模拟聚光<br />
灯。聚光灯的方向和聚光灯光锥对准的方向是不同的，除非你从聚光灯的中心看。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Spotlight Lighting</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">--------------------------- Vertex Shader -----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for spotlight computed in the fragment shader</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat3</span> <span style="color: #7590db;">NormalMatrix</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexColor</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">VertexNormal</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Position</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    Color = VertexColor;
    Normal = normalize(NormalMatrix * VertexNormal);
    Position = MVMatrix * VertexPosition;
    gl_Position = MVPMatrix * VertexPosition;
}
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------- Fragment Shader ----------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader computing a spotlight&#8217;s effect</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Ambient</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightColor</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">LightPosition</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Shininess</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Strength</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">EyeDirection</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ConstantAttenuation</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">LinearAttenuation</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">QuadraticAttenuation</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ConeDirection</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">SpotCosCutoff</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">SpotExponent</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Color</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">Position</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">adding spotlight attributes</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">how wide the spot is, as a cosine</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">control light fall-off in the spot</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">lightDirection</span> = LightPosition - vec3(Position);
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">lightDistance</span> = length(lightDirection);
    lightDirection = lightDirection / lightDistance;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">attenuation</span> = 1.0 / (ConstantAttenuation + LinearAttenuation * lightDistance +
    QuadraticAttenuation * lightDistance * lightDistance);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">how close are we to being in the spot?</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">spotCos</span> = dot(lightDirection, -ConeDirection);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">attenuate more, based on spot-relative position</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (spotCos &lt; SpotCosCutoff)
    {
        attenuation = 0.0;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        attenuation *= pow(spotCos, SpotExponent);
    }

    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">halfVector</span> = normalize(lightDirection + EyeDirection);
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">diffuse</span> = max(0.0, dot(Normal, lightDirection));
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">specular</span> = max(0.0, dot(Normal, halfVector));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (diffuse == 0.0)
    {
        specular = 0.0;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        specular = pow(specular, Shininess) * Strength;
    }
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">scatteredLight</span> = Ambient + LightColor * diffuse * attenuation;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">reflectedLight</span> = LightColor * specular * attenuation;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">rgb</span> = min(Color.rgb * scatteredLight + reflectedLight, vec3(1.0));
    FragColor = vec4(rgb, Color.a);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga32680e" class="outline-5">
<h5 id="orga32680e">Moving Calculations to the Vertex Shader</h5>
<div class="outline-text-5" id="text-orga32680e">
<p>
没有关于在哪儿进行光照计算的规则。通过实验来发现对于你的物体表面的更好方式。极端情况下，颜色可以完全在顶点着色器中计算 然后在插值。这本质上就是 Gouraud 渲染。尽管从计算角度来看是很节省，但是它会造成光照锯齿。<br />
</p>
</div>
</div>
<div id="outline-container-org27755cd" class="outline-5">
<h5 id="org27755cd">Multiple Lights and Materials</h5>
<div class="outline-text-5" id="text-org27755cd">
<p>
通常一个场景中有很多个光源，以及很多种材质。通常一次只会渲染一个材质，但是会有很多个光源照亮这个材质。<br />
（1）光照属性<br />
将光的特性组成一个结构体，创建一个结构体的数组进行处理。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">LightProperties</span> {
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isEnabled</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">true to apply this light in this invocation</span>
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isLocal</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">true for a point light or a spotlight, false for a positional light</span>
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isSpot</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">true if the light is a spotlight</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ambient</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">light&#8217;s contribution to ambient light</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">color</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">color of light</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">position</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">location of light, if is Local is true, otherwise the direction toward the light</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">halfVector</span>;        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">direction of highlights for directional light vec3 coneDirection;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">spotCosCutoff</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">spotlight attributes</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">spotExponent</span>;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">constantAttenuation</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">local light attenuation coefficients</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">linearAttenuation</span>;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">quadraticAttenuation</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">other properties you may desire</span>
};
</pre>
</div>
<p>
（2）材质的属性<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">MaterialProperties</span> {
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">emission</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">light produced by the material</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ambient</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">what part of ambient light is reflected</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">diffuse</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">what part of diffuse light is scattered</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">specular</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">what part of specular light is scattered</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">shininess</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exponent for sharpening specular reflection</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">other properties you may desire</span>
};
</pre>
</div>
<p>
如果应用程序需要经常在不同的材质之间切换，可以使用同一个片段着色器来渲染不同的材质，这样就不需要切换 shader 或更新 uniforms<br />
了。为了达到这样的目的，需要创建一个 MaterialProperties 数组，其中每个元素表示不同的材质。将材质的索引传入着色器，着色器<br />
会到数组中索引材质，然后对进行合适的渲染。<br />
（3）Two-Sided Lighting<br />
shader 中的内置变量 gl_FrontFacing 用来标记当前正在从正面还是背面观察表面。该变量只能在片段着色器中使用。<br />
</p>
</div>
</div>
<div id="outline-container-org58e48a5" class="outline-5">
<h5 id="org58e48a5">Lighting Coordinate Systems</h5>
<div class="outline-text-5" id="text-org58e48a5">
<p>
所有光照计算用到的法线、方向、位置坐标必须来自同一个坐标系，这样光照计算才会有意义。通常会选择视觉坐标系为光照<br />
坐标系。也就是眼睛的坐标为(0,0,0)并且眼睛朝向 z 轴负方向。通常提供给光照方程的所有方向和位置都是视觉坐标系，而<br />
光栅化会使用齐次坐标系。<br />
Tips:<br />
使用视觉坐标系来计算光照，世界空间的光的方向需要经过法线矩阵变换。<br />
</p>
</div>
</div>
<div id="outline-container-orgc63b798" class="outline-5">
<h5 id="orgc63b798">Limitations of the Classic Lighting Model</h5>
<div class="outline-text-5" id="text-orgc63b798">
<p>
（1）经典光照模型没有考虑阴影<br />
（2）环境光的衰减不够真实。<br />
（3）一个发热或光亮的物体会有光晕环绕。<br />
（4）一个贴图的表面通常不是非常光滑的，光照必须考虑表面的凹凸，否则表面看起来会不自然的平整。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgae4c0ac" class="outline-4">
<h4 id="orgae4c0ac">二、Advanced Lighting Models</h4>
<div class="outline-text-4" id="text-orgae4c0ac">
</div>
<div id="outline-container-org6885bf6" class="outline-5">
<h5 id="org6885bf6">Hemisphere Lighting</h5>
<div class="outline-text-5" id="text-org6885bf6">
<p>
半球光照背后的理念是使用两个半球来模拟光照。上面的半球代表天空，下面的半球表示地面。物体法线直接指向上方的表面，其所有光<br />
照都来自上半球，物体法线直接指向下方的表面，其所有光照都来自下半球。为两个半球指定合适的颜色，可以让球体上法线指向上方的<br />
被照亮，法线指向下方的在阴影中。<br />
计算表面任何一点的光照：<br />
Color = a * SkyColor + (1 - a) GroundColor<br />
_<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">a = 1.0 - (0.5 * sin(x))    x&lt;=90degree</td>
</tr>

<tr>
<td class="org-left">a = 0.5 * sin(x)            x&gt;90degree</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li></li>
</ul>
<p>
or a = 0.5 + 0.5*cos(x)<br />
</p>
</div>
</div>
<div id="outline-container-org0ac3994" class="outline-5">
<h5 id="org0ac3994">Image-Based Lighting</h5>
<div class="outline-text-5" id="text-org0ac3994">
<p>
在基于图片的光照中涉及到以下步骤：<br />
（1）使用光照探针（例如，一个反射球）来抓取发生在现实场景中的照明。抓取到的全方向的，高动态范围的图片被 称作一个光照探针图片<br />
（2）使用光照探针图片来创建环境的表示（例如，环境贴图）<br />
（3）将需要渲染的物体放到环境中<br />
（4）使用步骤（2）生成环境表示来渲染物体<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Shaders for Image-based Lighting</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">--------------------- Vertex Shader ---------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for image-based lighting</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat3</span> <span style="color: #7590db;">NormalMatrix</span>;
in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">VertexNormal</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ReflectDir</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    Normal = normalize(NormalMatrix * VertexNormal);
    <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">pos</span> = MVMatrix * VertexPosition;
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">eyeDir</span> = pos.xyz;
    ReflectDir = reflect(eyeDir, Normal);
    gl_Position = MVPMatrix * VertexPosition;
}
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">-------------------- Fragment Shader --------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader for image-based lighting</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">BaseColor</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">SpecularPercent</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">DiffusePercent</span>;
uniform <span style="color: #ce537a; font-weight: bold;">samplerCube</span> <span style="color: #7590db;">SpecularEnvMap</span>;
uniform <span style="color: #ce537a; font-weight: bold;">samplerCube</span> <span style="color: #7590db;">DiffuseEnvMap</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ReflectDir</span>; in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">Normal</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Look up environment map values in cube maps</span>
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">diffuseColor</span> = vec3(texture(DiffuseEnvMap, normalize(Normal)));
    <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">specularColor</span> = vec3(texture(SpecularEnvMap, normalize(ReflectDir)));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Add lighting to base color and mix</span>
    vec3color=mix(BaseColor,diffuseColor*BaseColor,DiffusePercent);
    color = mix(color, specularColor + color, SpecularPercent);
    FragColor = vec4(color, 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf7c00f8" class="outline-5">
<h5 id="orgf7c00f8">Lighting with Spherical Harmonics</h5>
<div class="outline-text-5" id="text-orgf7c00f8">
<p>
Spherical Harmonics 是用来计算光照漫反射项的方法。这种方法利用光照探针图片可以精确再现漫反射，而不需要在运行时访问光照探针图片。探针图片被预处理来产生一些系数，在运行时，这些系数可以被用来在数学上表示这个探针图片。<br />
Spherical hamonics 表示了一张图片在一个球上的频率空间。这类似于在直线或者是圆上的傅里叶变换。这种图片的表示方法是连续的并且是旋转不变的。使用这种方式表示一个光照探针图片，你可以只使用 9 个球谐基函数精确地再现一个表面的漫反射。这 9 个球谐基函数可以通过<br />
归一化表面法线的常数、线性、二次多项式来获得。<br />
直观上来看，使用少量数目的频率空间上的基函数来模拟漫反射似乎是可以的，因为漫反射在表面的变化很慢。只使用 9 项参数，对于任何输入的物理光照分布，在所有朝向的表面上的平均错误要小于 3%。使用 Debevec 的光照探针图片，平均错误还要小于 1%，并且对于任意像素的最大<br />
错误要小于 5%。<br />
每个球谐基函数有一个基于使用的光照探针图片的系数。这个系数对于不同的颜色通道也不同，所以你可以将每个系数当做一个 RGB 值。预处理阶段用来计算光照探针图片的这九个 RGB 参数。<br />
使用 Spherical Harmonics 的漫反射公式为：<br />
</p>

<p>
diffuse = c1 L22 (x^2-y^2) + c3 L20 z^2 + c4 L00 - c5L20 +<br />
          2c1(L2 m2 xy + L21 xz + L2 m1 yz) +<br />
          2c2(L11 x + L1 m1 y + L10z)<br />
c1-c5 为 5 个常数，L 系数是九个基函数系数，他们是通过特定的光照探针图片在预处理阶段计算出来的。x,y,z 为被渲染的顶点的归一化的法<br />
线。<br />
</p>

<p>
因为漫反射变化比较慢，对于没有巨大多边形的场景，我们理当在顶点着色器中计算光照，然后在光栅化阶段进行插值。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Shaders for Spherical Harmonics Lighting</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">--------------------- Vertex Shader ---------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vertex shader for computing spherical harmonics</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat3</span> <span style="color: #7590db;">NormalMatrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ScaleFactor</span>;
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">C1</span> = 0.429043;
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">C2</span> = 0.511664;
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">C3</span> = 0.743125;
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">C4</span> = 0.886227;
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">C5</span> = 0.247708;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Constants for Old Town Square lighting</span>
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L00</span> = vec3( 0.871297, 0.875222, 0.864470);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L1m1</span> = vec3( 0.175058, 0.245335, 0.312891);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L10</span> = vec3( 0.034675, 0.036107, 0.037362);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L11</span> = vec3(-0.004629, -0.029448, -0.048028);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L2m2</span> = vec3(-0.120535, -0.121160, -0.117507);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L2m1</span> = vec3( 0.003242, 0.003624, 0.007511);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L20</span> = vec3(-0.028667, -0.024926, -0.020998);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L21</span> = vec3(-0.077539, -0.086325, -0.091591);
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L22</span> = vec3(-0.161784, -0.191783, -0.219152);

in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">VertexPosition</span>;
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">VertexNormal</span>;
out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">DiffuseColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">tnorm</span> = normalize(NormalMatrix * VertexNormal);
DiffuseColor =  C1 * L22 *(tnorm.x * tnorm.x - tnorm.y * tnorm.y) +
                C3 * L20 * tnorm.z * tnorm.z +
                C4 * L00 -
                C5 * L20 +
                2.0 * C1 * L2m2 * tnorm.x * tnorm.y +
                2.0 * C1 * L21 * tnorm.x * tnorm.z +
                2.0 * C1 * L2m1 * tnorm.y * tnorm.z +
                2.0 * C2 * L11 * tnorm.x +
                2.0 * C2 * L1m1 * tnorm.y +
                2.0 * C2 * L10 * tnorm.z;
DiffuseColor *= ScaleFactor;
gl_Position = MVPMatrix * VertexPosition;
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------- Fragment Shader --------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader for lighting with spherical harmonics</span>
<span style="color: #bc6ec5;">#version</span> 330 core
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">DiffuseColor</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">FragColor</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
FragColor = vec4(DiffuseColor, 1.0);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org595bf65" class="outline-4">
<h4 id="org595bf65">三、Shadow Mapping</h4>
<div class="outline-text-4" id="text-org595bf65">
<p>
阴影贴图是一种多阶段技术，它使用深度贴图来渲染阴影。其中一个关键的阶段是从触发阴影的光源,而不是从最终的视点来看场景。从光源来看场景，所有看到的都是会被该光源点亮的。<br />
阴影贴图技术的两个阶段如下：<br />
（1）以光源的位置为视点渲染场景，把深度贴图对象附加到帧缓冲区对象,将深度值渲染到贴图中。<br />
（2）以本来的视点渲染场景，<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- Step 1.1 -- Create a depth texture and attach to framebuffer</span>
glGenTextures(1, &amp;depth_texture);
<span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(GL_TEXTURE_2D, depth_texture);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Allocate storage for the texture data</span>
<span style="color: #bc6ec5; font-weight: bold;">glTexImage2D</span>(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT32,
             DEPTH_TEXTURE_SIZE, DEPTH_TEXTURE_SIZE,
             0, GL_DEPTH_COMPONENT, GL_FLOAT, <span style="color: #a45bad;">NULL</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Set the default filtering modes</span>
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Set up depth comparison mode</span>
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,GL_COMPARE_REF_TO_TEXTURE);
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Set up wrapping modes</span>
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
<span style="color: #bc6ec5; font-weight: bold;">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
<span style="color: #bc6ec5; font-weight: bold;">glBindTexture</span>(GL_TEXTURE_2D, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Create FBO to render depth into</span>
glGenFramebuffers(1, &amp;depth_fbo);
<span style="color: #bc6ec5; font-weight: bold;">glBindFramebuffer</span>(GL_FRAMEBUFFER, depth_fbo);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Attach the depth texture to it</span>
<span style="color: #bc6ec5; font-weight: bold;">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT,depth_texture, 0);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Disable color rendering as there are no color attachments</span>
<span style="color: #bc6ec5; font-weight: bold;">glDrawBuffer</span>(GL_NONE);


<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- Step 1.2 -- prepare render scene from light pos</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Time varying light position</span>
<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">light_position</span> = vec3(sinf(t * 6.0f * 3.141592f) * 300.0f,
                           200.0f,
                           cosf(t * 4.0f * 3.141592f) * 100.0f + 250.0f);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Matrices for rendering the scene</span>
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">scene_model_matrix</span> = rotate(t * 720.0f, Y);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Matrices used when rendering from the light&#8217;s position</span>
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">light_view_matrix</span> = lookat(light_position, vec3(0.0f), Y);
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #bc6ec5; font-weight: bold;">light_projection_matrix</span>(frustum(-1.0f, 1.0f, -1.0f, 1.0f,1.0f, FRUSTUM_DEPTH));

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Now we render from the light&#8217;s position into the depth buffer.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Select the appropriate program</span>
<span style="color: #bc6ec5; font-weight: bold;">glUseProgram</span>(render_light_prog);

<span style="color: #bc6ec5; font-weight: bold;">glUniformMatrix4fv</span>(render_light_uniforms.MVPMatrix,
                   1, GL_FALSE,
                   <span style="color: #ce537a; font-weight: bold;">light_projection_matrix</span> *
                   <span style="color: #7590db;">light_view_matrix</span> *
                   scene_model_matrix);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">---- vertex shader ----</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">MVPMatrix</span>;
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 0) in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">position</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)
{
        gl_Position = MVPMatrix * position;
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">---- fragment shader ----</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fragment shader for shadow map generation</span>
<span style="color: #bc6ec5;">#version</span> 330 core
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 0) out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)
{
        color = vec4(1.0);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- Step 1.3 -- render from light pos to generate Shadow texture</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Bind the "depth only" FBO and set the viewport to the size</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of the depth texture</span>
<span style="color: #bc6ec5; font-weight: bold;">glBindFramebuffer</span>(GL_FRAMEBUFFER, depth_fbo);
glViewport(0, 0, DEPTH_TEXTURE_SIZE, DEPTH_TEXTURE_SIZE);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Clear</span>
glClearDepth(1.0f);
<span style="color: #bc6ec5; font-weight: bold;">glClear</span>(GL_DEPTH_BUFFER_BIT);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Enable polygon offset to resolve depth-fighting isuses</span>
<span style="color: #bc6ec5; font-weight: bold;">glEnable</span>(GL_POLYGON_OFFSET_FILL);
glPolygonOffset(2.0f, 4.0f);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Draw from the light&#8217;s point of view</span>
DrawScene(<span style="color: #a45bad;">true</span>);
<span style="color: #bc6ec5; font-weight: bold;">glDisable</span>(GL_POLYGON_OFFSET_FILL);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- Step 2.1 -- render scene at real eye pos and use shadow map texture</span>
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">scene_model_matrix</span> = rotate(t * 720.0f, Y);
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">scene_view_matrix</span> = translate(0.0f, 0.0f, -300.0f);
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">scene_projection_matrix</span> = frustum(-1.0f, 1.0f, -aspect, aspect,1.0f, FRUSTUM_DEPTH);
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">scale_bias_matrix</span> = mat4(vec4(0.5f, 0.0f, 0.0f, 0.0f),
                              vec4(0.0f, 0.5f, 0.0f, 0.0f),
                              vec4(0.0f, 0.0f, 0.5f, 0.0f),
                              vec4(0.5f, 0.5f, 0.5f, 1.0f));
<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">shadow_matrix</span> = scale_bias_matrix * light_projection_matrix * light_view_matrix;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">---- vertex shader ----</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model_matrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view_matrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection_matrix</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">shadow_matrix</span>;
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 0) in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">position</span>;
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 1) in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">normal</span>;
<span style="color: #ce537a; font-weight: bold;">out</span> <span style="color: #7590db;">VS_FS_INTERFACE</span>
{
        <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">shadow_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">world_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">eye_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">normal</span>;
} vertex;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)
{
        <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">world_pos</span> = model_matrix * position;
        <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">eye_pos</span> = view_matrix * world_pos;
        <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">clip_pos</span> = projection_matrix * eye_pos;
        vertex.world_coord = world_pos.xyz;
        vertex.eye_coord = eye_pos.xyz;
        vertex.shadow_coord = shadow_matrix * world_pos;
        vertex.normal = mat3(view_matrix * model_matrix) * normal;
        gl_Position = clip_pos;
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">---- fragment shader ----</span>
<span style="color: #bc6ec5;">#version</span> 330 core
uniform <span style="color: #ce537a; font-weight: bold;">sampler2DShadow</span> <span style="color: #7590db;">depth_texture</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">light_position</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">material_ambient</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">material_diffuse</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">material_specular</span>;
uniform <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">material_specular_power</span>;
<span style="color: #bc6ec5; font-weight: bold;">layout</span> (location = 0) <span style="color: #ce537a; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;
<span style="color: #ce537a; font-weight: bold;">in</span> <span style="color: #7590db;">VS_FS_INTERFACE</span>
{
        <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">shadow_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">world_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">eye_coord</span>;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">normal</span>;
} fragment;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)
{
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">N</span> = fragment.normal;
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">L</span> = normalize(light_position - fragment.world_coord);
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">R</span> = reflect(-L, N);
        <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">E</span> = normalize(fragment.eye_coord);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">NdotL</span> = dot(N, L);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">EdotR</span> = dot(-E, R);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">diffuse</span> = max(NdotL, 0.0);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">specular</span> = max(pow(EdotR, material_specular_power),0.0);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span> = textureProj(depth_texture, fragment.shadow_coord);
        color = vec4(material_ambient + f * (material_diffuse * diffuse +
                     material_specular * specular), 1.0);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org68b3307" class="outline-3">
<h3 id="org68b3307">Procedural Texturing</h3>
</div>
<div id="outline-container-org576987b" class="outline-3">
<h3 id="org576987b">Tessellation Shaders</h3>
</div>
<div id="outline-container-org7d9ab83" class="outline-3">
<h3 id="org7d9ab83">Geometry Shaders</h3>
</div>
<div id="outline-container-orgaebcbfb" class="outline-3">
<h3 id="orgaebcbfb">Memory</h3>
</div>
<div id="outline-container-org121a4a0" class="outline-3">
<h3 id="org121a4a0">Compute Shaders</h3>
</div>
<div id="outline-container-org5a47173" class="outline-3">
<h3 id="org5a47173">Q&amp;A</h3>
<div class="outline-text-3" id="text-org5a47173">
</div>
<div id="outline-container-org374d260" class="outline-4">
<h4 id="org374d260">Qt OpenGL 升级</h4>
<div class="outline-text-4" id="text-org374d260">
<ul class="org-ul">
<li>QGLWidget QGLFormat 被淘汰掉了，需要使用 QOpenGLWidget QSurfaceFormat 代替<br /></li>
<li>所有 OpenGL 的 API 都被封装到 QOpenGLFunctions 和 QOpenGLExtraFunctions 中了,MyGLWidget 需要派生自这个两个函数，否则 OpenGL 方法无法使用<br /></li>
<li>glShadeModel 函数不再支持，需要注释掉。<br /></li>
<li>需要在 MGLWidget::initializeGL()一开始调用 initializeOpenGLFunctions();否则会 crash。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3151eb8" class="outline-4">
<h4 id="org3151eb8">坐标系</h4>
<div class="outline-text-4" id="text-org3151eb8">
<ul class="org-ul">
<li>OpenGL 为右手坐标系，Unity3D 为左手坐标系。OpenGL 旋转正方向遵循右手原则，Unity3D 旋转正方向遵循左手原则。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org196e257" class="outline-4">
<h4 id="org196e257">设置缩放变换矩阵时需要将 w 设置为 1，否则缩放无效</h4>
<div class="outline-text-4" id="text-org196e257">
<p>
e.g:<br />
mat4 scale = mat4x4(<br />
    vec4(0.1,   0,   0,   0),<br />
    vec4(  0, 0.1,   0,   0),<br />
    vec4(  0,   0, 0.1,   0),<br />
    vec4(  0,   0,   0,   1)<br />
    );<br />
如果上面的 w 也为 1，则缩放是无效的。<br />
</p>
</div>
</div>
<div id="outline-container-org692e085" class="outline-4">
<h4 id="org692e085">shader 中不使用的 uniform 会被自动移除</h4>
<div class="outline-text-4" id="text-org692e085">
<p>
下面的代码可以让 model_matrix uniform 不被移除，而且可以通过颜色确定 model_matrix 的值<br />
//vs_fs_color = model_matrix[2];<br />
vs_fs_color = color;<br />
</p>
</div>
</div>
<div id="outline-container-orgbbd36f5" class="outline-4">
<h4 id="orgbbd36f5">Qt 开启 c++11</h4>
<div class="outline-text-4" id="text-orgbbd36f5">
<p>
CONFIG += c++11<br />
</p>
</div>
</div>
<div id="outline-container-org3a63988" class="outline-4">
<h4 id="org3a63988">glGetError glGetUniformLocation bug</h4>
<div class="outline-text-4" id="text-org3a63988">
<p>
第一次调用 glGetUniformLocation 会报下面错误<br />
error GL_INVALID_OPERATION = 1282<br />
Error glGetUniformLocation local = 0<br />
</p>
</div>
</div>
<div id="outline-container-orgc6874fa" class="outline-4">
<h4 id="orgc6874fa">绘制的物体没有显示出来</h4>
<div class="outline-text-4" id="text-orgc6874fa">
<p>
（1）是否开启了深度测试，导致物体被剔除了<br />
（2）查看物体是否位于视野外，导致物体被剔除了<br />
（3）查看是否开启了 glEnable(GL_CULL_FACE); 物体表面被当做背面了！<br />
（4）检查 glBufferData 是否使用了正确的参数<br />
下面的参数是错误的<br />
glBufferData(_vabuffer, vertex_data_size, vertex_data, GL_STATIC_DRAW);<br />
下面的参数是正确<br />
glBufferData(GL_ARRAY_BUFFER, vertex_data_size, vertex_data, GL_STATIC_DRAW);<br />
（5）检查 glVertexAttribPointer 是否使用了正确的参数<br />
static GLfloat vertex_data[] = {<br />
    -1.0, -1.0,  0.0,  -1.0,<br />
     0.0,  1.0,  0.0,  -1.0,<br />
     1.0, -1.0,  0.0,  -1.0<br />
};<br />
下面的参数是正确<br />
glVertexAttribPointer(0,4,GL_FLOAT,GL_FALSE,4*sizeof(GLfloat),0);<br />
<a href="https://www.opengl.org/sdk/docs/man/html/glVertexAttribPointer.xhtml">https://www.opengl.org/sdk/docs/man/html/glVertexAttribPointer.xhtml</a><br />
void glVertexAttribPointer(<br />
    GLuint index,               <i>/ 属性的索引<br />
    GLint size,                 /</i> 属性数据包含多少个 type 的数据<br />
    GLenum type,                <i>/ 属性数据类型<br />
    GLboolean normalized,       /</i> 是否标准化<br />
    GLsizei stride,             <i>/ 两个属性之间的间隔<br />
    const GLvoid * pointer);    /</i> 第一个属性数据距离数据起始地址的偏移量<br />
下面的参数也是正确的<br />
glVertexAttribPointer(0,4,GL_FLOAT,GL_FALSE,0,vertex_data);<br />
stride 为 0 表示连续的属性之间是紧密排列的。<br />
下面的参数是错误的<br />
glVertexAttribPointer(0,sizeof(GLfloat)*4,GL_FLOAT,GL_FALSE,0,0);<br />
size 表示包含多少个 type 的数据，不是数据占用的内存字节数<br />
下面的参数是错误的<br />
glVertexAttribPointer(0,4,GL_FLOAT,GL_FALSE,0,vertex_data);<br />
pointer 表示的是第一个属性数据距离数据其实地址的 offset，而不是数据的真正地址。<br />
（6）检查 glBindBuffer 和 glBindVertexArray 的位置<br />
下面的位置是错误的：<br />
glBindBuffer(GL_ARRAY_BUFFER,0);<br />
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);<br />
glBindVertexArray(0);<br />
下面的位置是正确的：<br />
glBindVertexArray(0);<br />
glBindBuffer(GL_ARRAY_BUFFER,0);<br />
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);<br />
（7）检查顶点的坐标范围<br />
默认情况下 x,y,z 的范围只有在[-1,1]才可以显示。如果需要修改范围需要指定投影矩阵，<br />
用 glm::ortho 或者 glm::perspective<br />
（8）检查 glDepthFunc 是否正确<br />
默认值为 GL_LESS<br />
GL_LEQUAL 表示如果输入的深度值小于或等于参考值，则通过<br />
深度值为摄像机到物体的距离<br />
（9）检查顶点数据的定义是否使用了 static，该程序中顶点定义都作为函数的局部变量，若不是 static，<br />
函数执行完毕，数据就被释放了。<br />
</p>
</div>
</div>
<div id="outline-container-org26b1862" class="outline-4">
<h4 id="org26b1862">Qt 包含库头文件</h4>
<div class="outline-text-4" id="text-org26b1862">
<p>
在.pro 文件中添加如下代码<br />
INCLUDEPATH += \[PWD/../../../libs/glm
DEPENDPATH += \]PWD/../../../libs/glm<br />
</p>
</div>
</div>
<div id="outline-container-orgf5261bf" class="outline-4">
<h4 id="orgf5261bf">不能将 build 目录放在项目目录下，否则复制目录会递归死循环</h4>
</div>
<div id="outline-container-org8faf2e4" class="outline-4">
<h4 id="org8faf2e4">GTimerMgr 中 Schedule(target,task,&#x2026;)task 不能用 std::function</h4>
<div class="outline-text-4" id="text-org8faf2e4">
<p>
因为 std::function 无法比较，Unschedule 时需要支持指定 task 的 Unschedule。<br />
</p>
</div>
</div>
<div id="outline-container-orgfca599b" class="outline-4">
<h4 id="orgfca599b">注意： vector 遍历删除照成 iterator 失效的问题</h4>
<div class="outline-text-4" id="text-orgfca599b">
<p>
例如 GTimerMgr::Unschedule 中<br />
</p>
</div>
</div>
<div id="outline-container-org3428689" class="outline-4">
<h4 id="org3428689">实现自定义的 LookUp 时，需要注意 OpenGL 中矩阵的存储是列主序的</h4>
</div>
<div id="outline-container-org1d5301a" class="outline-4">
<h4 id="org1d5301a">旋转摄像机画面没有变化：请检查一下 QOpenGLWidget 是否开启了每帧执行 update 的操作！</h4>
</div>
<div id="outline-container-org4fb48bf" class="outline-4">
<h4 id="org4fb48bf">物体贴图为黑白颜色时，检查 glTexImage2D 的 format 参数是否正确。</h4>
</div>
<div id="outline-container-org7cf024f" class="outline-4">
<h4 id="org7cf024f">shader 中定义的变量需要进行初始化，否则其值是随机值。</h4>
<div class="outline-text-4" id="text-org7cf024f">
<p>
vec3 result_color;                      <i>/ 没有初始化是错误的。<br />
vec3 result_color = vec3(0.0,0.0,0.0)   /</i> 初始化过了，可以正常使用。<br />
</p>
</div>
</div>
<div id="outline-container-org2f29c2e" class="outline-4">
<h4 id="org2f29c2e">光照通常不会影响物体的透明度，所以光照计算中，颜色的 alpha 值通常是不变的。</h4>
</div>
<div id="outline-container-org11533b9" class="outline-4">
<h4 id="org11533b9">什么是摄像机空间（视觉空间、观察空间）？</h4>
<div class="outline-text-4" id="text-org11533b9">
<p>
所谓摄像机空间、视觉空间、观察空间就是摄像机节点的本地坐标系。<br />
</p>
</div>
</div>
<div id="outline-container-orgb27efa8" class="outline-4">
<h4 id="orgb27efa8">光照计算在视觉坐标系下进行有什么好处？</h4>
<div class="outline-text-4" id="text-orgb27efa8">
<p>
光照计算中通常需要视觉方向，当在视觉坐标系下进行光照计算时，视觉方向即为顶点在视觉坐标系下的坐标。<br />
</p>
</div>
</div>
<div id="outline-container-orgd28d669" class="outline-4">
<h4 id="orgd28d669">几种光照成分的名称</h4>
<div class="outline-text-4" id="text-orgd28d669">
<p>
ambient   环境光<br />
diffuse   漫反射光<br />
specular  镜面反射光<br />
</p>
</div>
</div>
<div id="outline-container-org0b7ee8d" class="outline-4">
<h4 id="org0b7ee8d">VBO 和 VAO 的区别</h4>
<div class="outline-text-4" id="text-org0b7ee8d">
<p>
(1) VBO 是一个 Buffer 对象，用来存储顶点的原始数据。<br />
&#x2013;Tips&#x2013;<br />
（1-1）GL_ARRAY_BUFFER 的绑定 VBO 操作（即调用 glBindBuffer(GL_ARRAY_BUFFER,_vbo)），不属于 VAO 所记录的状态。<br />
调用绑定 VBO 操作后，第一次调用 glVertexAttribPointer 时，才会将当前绑定的 vbo 记录到 VAO 中。<br />
VBO 的创建 、绑定、删除<br />
glGenBuffers(1,&amp;_vertex_buffer);<br />
glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer);<br />
glBufferData(GL_ARRAY_BUFFER, data_size,vertex_data,GL_STATIC_DRAW);<br />
glDeleteBuffers(1,&amp;_vertex_buffer)<br />
(2) VAO 是一个 OpenGL 对象，用来存储一系列状态来提供给顶点数据。它保存了顶点数据的格式，当前绑定的 vbo 这些状态。<br />
VAO 的创建、绑定、删除<br />
glGenVertexArrays(1,&amp;_vertex_arr_obj);<br />
glBindVertexArray(_vertex_arr_obj);<br />
glDeleteVertexArrays(1,&amp;_vertex_arr_obj);<br />
</p>

<p>
参考--<a href="https://www.khronos.org/opengl/wiki/Vertex_Specification">https://www.khronos.org/opengl/wiki/Vertex_Specification</a><br />
</p>
</div>
</div>

<div id="outline-container-org79a472a" class="outline-4">
<h4 id="org79a472a">参考链接：</h4>
<div class="outline-text-4" id="text-org79a472a">
<ul class="org-ul">
<li>Modern OpenGL Tutorials en <a href="http://ogldev.atspace.co.uk/index.html">http://ogldev.atspace.co.uk/index.html</a><br /></li>
<li>Modern OpenGL Tutorials cn <a href="https://www.zhihu.com/column/c_1375900139991678976">https://www.zhihu.com/column/c_1375900139991678976</a><br /></li>
<li>Modern OpenGL Tutorials src <a href="https://github.com/flcker/ogldev_source">https://github.com/flcker/ogldev_source</a><br /></li>
<li>learnopengl <a href="https://learnopengl-cn.readthedocs.io/zh/latest/">https://learnopengl-cn.readthedocs.io/zh/latest/</a><br /></li>
<li>opengl-tutorial <a href="http://www.opengl-tutorial.org/">http://www.opengl-tutorial.org/</a><br /></li>
<li>openglredbook <a href="https://github.com/openglredbook/examples">https://github.com/openglredbook/examples</a><br /></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org72dabff" class="outline-2">
<h2 id="org72dabff">OpenGL Version</h2>
<div class="outline-text-2" id="text-org72dabff">
</div>
<div id="outline-container-orgf110a5a" class="outline-3">
<h3 id="orgf110a5a">OpenGL ES</h3>
<div class="outline-text-3" id="text-orgf110a5a">
</div>
<div id="outline-container-org15e7006" class="outline-4">
<h4 id="org15e7006">New features in OpenGL ES 3.0 include:</h4>
<div class="outline-text-4" id="text-org15e7006">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">新特性</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">OpenGL Shading Language ES 3.00</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">transform feedback 1 and 2 (with restrictions)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">uniform buffer objects including block arrays</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vertex array objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sampler objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sync objects and fences</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pixel buffer objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">buffer subrange mapping</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">buffer object to buffer object copies 314</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boolean occlusion queries, including conservative mode</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">instanced rendering, via shader variable and/or vertex attribute divisor</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">multiple render targets</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2D array and 3D textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">simplified texture storage specification</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">R and RG textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">texture swizzles</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">seamless cube maps</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">non-power-of-two textures with full wrap mode support and mipmapping</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">texture LOD clamps and mipmap level base offset and max clamp</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">at least 32 textures, at least 16 each for fragment and vertex shaders</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">16-bit (with filtering) and 32-bit (without filtering) floating-point textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">32-bit, 16-bit, and 8-bit signed and unsigned integer renderbuffers, textures, and vertex attributes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">8-bit sRGB textures and framebuffers (without mixed RGB/sRGB rendering)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">11/11/10 floating-point RGB textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shared exponent RGB 9/9/9/5 textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">10/10/10/2 unsigned normalized and unnormalized integer textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">10/10/10/2 signed and unsigned normalized vertex attributes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">16-bit floating-point vertex attributes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">8-bit-per-component signed normalized textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ETC2/EAC texture compression formats</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sized internal texture formats with minimum precision guarantees</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">multisample renderbuffers</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">8-bit unsigned normalized renderbuffers</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">depth textures and shadow comparison</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">24-bit depth renderbuffers and textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">24/8 depth/stencil renderbuffers and textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">32-bit depth and 32F/8 depth/stencil renderbuffers and textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">stretch blits (with restrictions)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">framebuffer invalidation hints</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">primitive restart with fixed index</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unsigned integer element indices with at least 24 usable bits</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">draw command allowing specification of range of accessed elements</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ability to attach any mipmap level to a framebuffer object</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">minimum/maximum blend equations</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">program binaries, including querying binaries from linked GLSL programs</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mandatory online compiler</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">non-square and transposable uniform matrices</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">additional pixel store state</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">indexed extension string queries</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org524f54e" class="outline-4">
<h4 id="org524f54e">New features in OpenGL ES 3.1 include:</h4>
<div class="outline-text-4" id="text-org524f54e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Arrays of arrays (shading language only)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Compute shaders</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Indirect draw commands (with draw parameters in buffer storage)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Explicit uniform location</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Support for framebuffers with no attachments</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Program interface queries</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Atomic counters</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shader bitfield operations (shading language only)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shader helper invocation (shading language only)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shader image load/store operations</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shader layout binding (shading language only)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shader storage buffer objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Separate shader objects</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Stencil texturing</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Texture gather operations</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Multisample formats for immutable textures</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Vertex attribute binding</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
tessellation_shader : OpenGL ES 3.1 and OpenGL ES Shading Language 3.10 are required.<br />
geometry_shader : OpenGL ES 3.1 and OpenGL ES Shading Language 3.10 are required.<br />
</p>

<ul class="org-ul">
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_tessellation_shader.txt">https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_tessellation_shader.txt</a><br /></li>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/OES/OES_geometry_shader.txt">https://www.khronos.org/registry/OpenGL/extensions/OES/OES_geometry_shader.txt</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge2eee60" class="outline-4">
<h4 id="orge2eee60">New features in OpenGL ES 3.2 include:</h4>
<div class="outline-text-4" id="text-orge2eee60">
<p>
• Almost all features of the Android extension pack, incorporating by reference all of the following features - with the exception of the sRGB decode features of EXT_texture_sRGB_decode<br />
• Advanced blend equations.<br />
• Copying subregions between image objects<br />
• Supporting blending on a per-draw-buffer basis<br />
• Debug messages<br />
• Geometry shaders<br />
• Miscellaneous new shader functionality<br />
• ASTC texture compression (LDR profile only)<br />
• Primitive bounding boxes<br />
• Shader image atomic operations<br />
• Shader interface blocks<br />
• Shader multisample interpolation control<br />
• Sample shading control<br />
• Sample variables<br />
• Texture buffer objects<br />
• Texture border color<br />
• Texture cube map arrays<br />
• Tessellation shaders<br />
• STENCIL8 texture formats<br />
• Texture multisample 2D arrays and also include the following features, which are not part of the Android extension pack.<br />
• Draw calls specifying a base vertex parameter<br />
• Floating-point framebuffers<br />
• Enabling robust buffer access as described in GL_KHR_robustness (preventing crashes), but without the additional behavior defined by GL_KHR_robust_buffer_access<br />
• Support for querying CONTEXT_FLAGS, as needed by debug and robust buffer access functionality.<br />
• Support for querying MULTISAMPLE_LINE_WIDTH_RANGE and MULTISAMPLE_LINE_WIDTH_GRANULARITY (see section 13.6.4). Note that these are different query and enum values than desktop GL’s SMOOTH_LINE_WIDTH_*, which remain unsupported (Bug 13828).<br />
</p>

<p>
NV_mesh_shader <br />
</p>
<ul class="org-ul">
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_mesh_shader.txt">https://www.khronos.org/registry/OpenGL/extensions/NV/NV_mesh_shader.txt</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org03de91a" class="outline-4">
<h4 id="org03de91a">参考资料</h4>
<div class="outline-text-4" id="text-org03de91a">
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/17543364/what-are-the-differences-between-opengl-es-2-0-and-opengl-es-3-0">https://stackoverflow.com/questions/17543364/what-are-the-differences-between-opengl-es-2-0-and-opengl-es-3-0</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'OpenGL',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
