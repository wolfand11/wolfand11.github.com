<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-09-07 Wed 11:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Physically Based Rendering</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">Physically Based Rendering</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgea327cc">Physically Based Rendering</a>
<ul>
<li><a href="#org68c6712">Prepare</a></li>
<li><a href="#org54c9e80">1 Introduction</a>
<ul>
<li><a href="#org01c990a">Literate Programming</a></li>
<li><a href="#orgf36541a">Photorealistic rendering and the ray-tracing algorithm</a>
<ul>
<li><a href="#orge9ea1dd">Cameras</a></li>
<li><a href="#orgbb40349">Ray-object intersections</a></li>
<li><a href="#org6a77c0f">Light sources</a></li>
<li><a href="#orgc946561">Visibility</a></li>
<li><a href="#org4fc2c8e">Surface scattering</a></li>
<li><a href="#org5909344">Indirect light transport</a></li>
<li><a href="#orgb87276d">Ray propagation</a></li>
</ul>
</li>
<li><a href="#orgf02a783">pbrt: System Overview</a>
<ul>
<li><a href="#org5d63657">phases of execution</a></li>
<li><a href="#org88aec90">scene representation</a></li>
<li><a href="#org4a604b9">integrator interface and SamplerIntegrator</a></li>
<li><a href="#orgc902b1c">the main rendering loop</a>
<ul>
<li><a href="#org5208cc6">Ray differentials</a></li>
<li><a href="#org6bdb9f2">Li 函数</a></li>
<li><a href="#org988c468">渲染主循环流程</a></li>
</ul>
</li>
<li><a href="#orgbababc1">an integrator for whited ray tracing</a></li>
</ul>
</li>
<li><a href="#org4a9892f">parallelization of pbrt</a></li>
<li><a href="#org280f7ab">EXERCISE</a></li>
</ul>
</li>
<li><a href="#org04463c6">Part 1 Main Geometric Functionality</a>
<ul>
<li><a href="#orgd4b3194">2 Geometry and Transformations</a>
<ul>
<li><a href="#orgc72f7b0">本书坐标系</a></li>
<li><a href="#orga11254a">从一个向量创建一个坐标系</a></li>
<li><a href="#org322ee0a">AABB Bounding Box</a></li>
<li><a href="#org1616c5b">Point 和 Vector 的不同</a></li>
<li><a href="#org42bcd9f">Normal 和 Vector 的不同</a></li>
<li><a href="#org43c20a5">Matrix</a></li>
<li><a href="#orgbed3f10">矩阵和行列式</a></li>
<li><a href="#orgedc96d2">逆矩阵求解</a></li>
<li><a href="#orgad540d4">LookAt</a></li>
<li><a href="#org01f0af9">判断矩阵是否为透视矩阵</a></li>
<li><a href="#org355307f">判断矩阵是否包含缩放</a></li>
<li><a href="#orgbdce59e">判断矩阵是否会将左手坐标系变为右手坐标系</a></li>
<li><a href="#org44ec135">从矩阵中分离 TRS</a></li>
</ul>
</li>
<li><a href="#orgb6d1da9">3 Shapes</a>
<ul>
<li><a href="#org68458f6">AABB 和射线求交点</a></li>
<li><a href="#org073cd08">Sphere Shape</a></li>
<li><a href="#org014185f">曲面面积求解</a></li>
<li><a href="#org48b0114">Cylinder Shape</a></li>
<li><a href="#org90e2392">Disk</a></li>
<li><a href="#orgae50775">Cone</a></li>
<li><a href="#orga77214d">Paraboloid</a></li>
<li><a href="#org7b9a25f">Hyperboloid</a></li>
<li><a href="#org4bc851e">Triangle Meshes</a></li>
<li><a href="#orgd94dd33">Triangle</a></li>
<li><a href="#org4f1ee20">Curve</a>
<ul>
<li><a href="#org0750dce">Curve 的表示</a></li>
<li><a href="#orga04f8e3">Curve Intersect</a></li>
</ul>
</li>
<li><a href="#orge84ad56">Subdivision Surfaces</a>
<ul>
<li><a href="#org6d2ab27">Subdivision 的优点</a></li>
<li><a href="#org4518397">Mesh 的表示</a></li>
<li><a href="#org3a2c450">计算顶点的 valence 值</a></li>
<li><a href="#org4d7fe44">计算顶点周围一圈的顶点</a></li>
<li><a href="#org309585b">计算顶点新的坐标</a></li>
<li><a href="#orgd9f431b">计算顶点的 Normal</a></li>
</ul>
</li>
<li><a href="#orgf1d93a5">Managing Rounding Error</a>
<ul>
<li><a href="#org40970a3">浮点数的算术</a></li>
<li><a href="#org6e6d957">保守的 Ray-Bounds 相交计算</a></li>
<li><a href="#org0b638a7">Robust Triangle Intesections</a></li>
<li><a href="#org568e34a">Bounding Intersection Point Error</a></li>
<li><a href="#org8814d32">Robust Spawned Ray Origins</a></li>
<li><a href="#org39211c7">Avoiding Intersections Behind Ray Origins</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd5e670f">4 Primitives and intersection acceleration</a>
<ul>
<li><a href="#orgcc22e55">Primitive Interface And Geometric Primitives</a></li>
<li><a href="#orgcd73ffa">Aggregates</a></li>
<li><a href="#orgc11f2b5">Bounding Volume Hierachies</a>
<ul>
<li><a href="#org31eaa44">构建 BVH</a></li>
<li><a href="#org07b0e42">Surface Area Heuristic 消耗模型</a></li>
<li><a href="#org8febe4b">SAH 划分</a></li>
<li><a href="#org8fc6b69">Linear Bounding Volume Hierachies</a></li>
<li><a href="#orgdbdbe03">参考资料</a></li>
</ul>
</li>
<li><a href="#orgfa601c7">KD-TREE Accelerator</a>
<ul>
<li><a href="#orgef6fc72">Tree Representation</a></li>
<li><a href="#org5ed1340">Tree Construction</a></li>
<li><a href="#orga6e274e">Tree Traversal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6b3a932">Part 2 Image Formation Process</a>
<ul>
<li><a href="#org3b358f5">5 Color and radiometry</a>
<ul>
<li><a href="#orge31a0e7">基础知识</a>
<ul>
<li><a href="#org879e058">物理的光和颜色</a></li>
<li><a href="#orgea06aae">颜色</a></li>
<li><a href="#orgfb254ed">参考资料</a></li>
</ul>
</li>
<li><a href="#org1b92190">Spectral Representation</a></li>
<li><a href="#org9f6e5b2">SampledSpectrum</a>
<ul>
<li><a href="#org1a9185c">XYZ Color</a></li>
<li><a href="#org80b811d">RGB Color</a></li>
<li><a href="#orgdd070be">参考资料</a></li>
</ul>
</li>
<li><a href="#org9b2951c">RGBSpectrum</a></li>
<li><a href="#org46694ea">Radiometry</a></li>
<li><a href="#orge4be04a">Working With Radiometric intergals</a>
<ul>
<li><a href="#org7aa7fc5">Integrals over projected solid angle</a></li>
<li><a href="#org02669e4">Integrals over spherical coordinates</a></li>
<li><a href="#orgf5315e1">Integrals over area</a></li>
</ul>
</li>
<li><a href="#org317f523">Surface Reflection</a>
<ul>
<li><a href="#orgb46ec18">BRDF BTDF</a></li>
<li><a href="#org7d98c2e">BSSRDF</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org312c0ac">6 Camera models</a>
<ul>
<li><a href="#org17157ef">Camera Model</a></li>
<li><a href="#org7f8ec7e">Projective Camera Models</a>
<ul>
<li><a href="#orga3dbd9e">Orthographic Camera</a></li>
<li><a href="#orge28fd54">Perspective Camera</a></li>
<li><a href="#org5b2f26c">Lens Model and Depth Of Field</a></li>
</ul>
</li>
<li><a href="#orgcd822f3">Environment Camera</a></li>
<li><a href="#orgdb18607"><span class="todo TODO">TODO</span> Realistic Cameras</a></li>
</ul>
</li>
<li><a href="#org53626c1">7 Sampling and reconstruction</a>
<ul>
<li><a href="#org1044cc2">Sampling Theory</a>
<ul>
<li><a href="#org26675e1">The Frequency Domain And The Fourier Transform</a></li>
<li><a href="#org2175890">Ideal Sampling and Reconstruction</a></li>
<li><a href="#org4888013">Aliasing</a></li>
<li><a href="#org0452786">Antialiasing Techniques</a></li>
<li><a href="#org030dc98">Application To Image Synthesis</a></li>
<li><a href="#org830642e">Sources of Aliasing in Rendering</a></li>
<li><a href="#orgf350eea">Understanding Pixels</a></li>
</ul>
</li>
<li><a href="#orgf4f503a">Sampling Interface</a>
<ul>
<li><a href="#orgcc01523">Evaluating Sample Patterns:Discrepancy</a></li>
<li><a href="#orgd43b381">Basic Sampler Interface and Implement</a></li>
</ul>
</li>
<li><a href="#org37f7630">Stratified Sampling</a></li>
<li><a href="#org2135d1d">The Halton Sampler</a>
<ul>
<li><a href="#org2947767">Hammersley and Halton Sequences</a></li>
<li><a href="#org72467c7"><span class="todo TODO">TODO</span> HaltonSampler Implement</a></li>
</ul>
</li>
<li><a href="#org03373c1"><span class="todo TODO">TODO</span> (0,2)-Sequence Sampler</a></li>
<li><a href="#orgf8e7852"><span class="todo TODO">TODO</span> Maximized Minimal Distance Sampler</a></li>
<li><a href="#org1cc2a48"><span class="todo TODO">TODO</span> Sobol Sampler</a></li>
<li><a href="#orgee191a8">Image Reconstruction</a></li>
<li><a href="#org7621eaf">Film and The imaging pipeline</a>
<ul>
<li><a href="#orgd0b05cc">Film Class</a></li>
<li><a href="#org6193138">Supplying Pixel Values To The Film</a></li>
<li><a href="#org883bbaa">Image output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd6f533f">Part 3 Light And Scatter</a>
<ul>
<li><a href="#orgef8afce">8 Reflection models</a>
<ul>
<li><a href="#orgbbea66c">Basic Interface</a>
<ul>
<li><a href="#org6e8ca51">reflectance</a></li>
</ul>
</li>
<li><a href="#org5919fa4">Specular Reflection And Transmission</a>
<ul>
<li><a href="#org2f26053">Fresnel Reflectance</a></li>
<li><a href="#org68d5847">Specular Reflection</a></li>
<li><a href="#orgb4fe418">Specular Transmission</a></li>
<li><a href="#orgf805b91">Fresnel-Modulated Specular Reflection and Transmission</a></li>
</ul>
</li>
<li><a href="#org565ac73">Lambertian Reflection</a></li>
<li><a href="#org4430cad">Microfacet Models</a>
<ul>
<li><a href="#orgd46a1ea">Oren-Nayar Diffuse Reflection</a></li>
<li><a href="#org4b733d3">Microfacet Distribution Function</a></li>
<li><a href="#org8ff55d0">Masking And Shadowing</a></li>
<li><a href="#org4616fb2">Torrance-Sparrow Model (MicrofacetReflection MicrofacetTransmission)</a></li>
</ul>
</li>
<li><a href="#org1fb3f1d">Fresnel Incidence Effects</a></li>
<li><a href="#org7f0c54e">Fourier Basis BSDFs</a>
<ul>
<li><a href="#orgfe7075c">Spline Interpolation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8bc612a">9 Materials</a>
<ul>
<li><a href="#orgf93fa38">BSDFs</a>
<ul>
<li><a href="#org87eb653">BSDF memory management</a></li>
</ul>
</li>
<li><a href="#orgf5237ef">Material Interface And Implementations</a>
<ul>
<li><a href="#orgef6d258">Matte Material</a></li>
<li><a href="#orgae76a28">Plastic Material</a></li>
<li><a href="#orgd8f8a84">Mix Material</a></li>
<li><a href="#org053e588">Fourier Material</a></li>
<li><a href="#org4c35340">Additional Material</a></li>
</ul>
</li>
<li><a href="#org509dd4a">Bump Mapping</a></li>
</ul>
</li>
<li><a href="#org02b0ce9">10 Texture</a>
<ul>
<li><a href="#orgb3b0bba">Sampling And Antialiasing</a>
<ul>
<li><a href="#org6de1586">Finding The Texture Sampling Rate</a></li>
<li><a href="#orgb7ffc9c">Filtering Texture Functions</a></li>
<li><a href="#org75939b4">Ray Differentials For Specular Reflection And Transmission</a></li>
</ul>
</li>
<li><a href="#org7393016">Texture Coordinate Generation</a>
<ul>
<li><a href="#org072015c">2D(u,v) Mapping</a></li>
<li><a href="#orgc9e3b47">Spherical Mapping</a></li>
<li><a href="#orgdf2959b">Cylindrical Mapping</a></li>
<li><a href="#org2ece670">Planar Mapping</a></li>
<li><a href="#org1933397">3DMapping</a></li>
</ul>
</li>
<li><a href="#org500ca16">Texture Interface and Basic Textures</a>
<ul>
<li><a href="#org95c201f">ConstantTexture</a></li>
<li><a href="#org54e1ba4">Scale Texture</a></li>
<li><a href="#orgd3c6c0e">Mix Textures</a></li>
<li><a href="#orgd395cec">BilinearInterpolation</a></li>
</ul>
</li>
<li><a href="#orgdc3f1de">Image Texture</a>
<ul>
<li><a href="#org8426a26">Texture Memory Management</a></li>
<li><a href="#org034cce7">MipMaps</a></li>
<li><a href="#orge63fa51">Isotropic Triangle Filter</a></li>
<li><a href="#org0614358">Elliptically Weighted Average</a></li>
</ul>
</li>
<li><a href="#org7a8d958">Solid And Procedural Texture</a>
<ul>
<li><a href="#orgac46bba">UV Texture</a></li>
<li><a href="#orga5ec4fc">Checker Board</a></li>
<li><a href="#org83538d5">Solid Checker Board</a></li>
</ul>
</li>
<li><a href="#org644c2ae">Noise</a>
<ul>
<li><a href="#orgbd8fe12">Perlin Noise</a></li>
<li><a href="#org14e84e9">Random Polka Dots</a></li>
<li><a href="#org26aa88b">Noise Idioms and Spectral Synthesis</a></li>
<li><a href="#org6144c51">Bumpy and wrinkled textures</a></li>
<li><a href="#org549927c">Windy Waves</a></li>
<li><a href="#org9b3c961">Marble</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org490f0fb">11 Volume Scattering</a>
<ul>
<li><a href="#org39ce91f">Volume Scattering Processes</a>
<ul>
<li><a href="#org6dc1330">Absorption</a></li>
<li><a href="#org0b53c2f">Emission</a></li>
<li><a href="#orgd705b96">Out-Scattering And Attenuation</a></li>
<li><a href="#org7fe2c19">In-Scattering</a></li>
<li><a href="#org01b9d59">参考资料</a></li>
</ul>
</li>
<li><a href="#org31ead02">Phase Functions</a></li>
<li><a href="#org71df033">Media</a>
<ul>
<li><a href="#org7b66ca4">Medium Interactions</a></li>
<li><a href="#orgcd973e7">Homogeneous Medium</a></li>
<li><a href="#org55b3716">3D Grids</a></li>
</ul>
</li>
<li><a href="#org4b8fda9">The BSSRDF</a>
<ul>
<li><a href="#org90b1614">Separable BSSRDFS</a></li>
<li><a href="#org9371f9f">Tabulated BSSRDF</a></li>
<li><a href="#orgebc9582">Subsurface Scattering Materials</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga2ba111">12 Light Source</a>
<ul>
<li><a href="#orgc0cdc00">Light Emission</a>
<ul>
<li><a href="#org355c3fc">Blackbody Emitters</a></li>
<li><a href="#org348268f">Standard Illuminants</a></li>
</ul>
</li>
<li><a href="#orgeeac899">Light Interface</a>
<ul>
<li><a href="#org3da685e"><span class="todo TODO">TODO</span> Visiblity Testing</a></li>
</ul>
</li>
<li><a href="#org25e248b">Point Lights</a>
<ul>
<li><a href="#org91a5537">Point Lights</a></li>
<li><a href="#orge34f662">Spot Lights</a></li>
<li><a href="#orgff155c1"><span class="todo TODO">TODO</span> Texture Projection Lights</a></li>
<li><a href="#org6691c31"><span class="todo TODO">TODO</span> Goniophotometric Diagram Lights</a></li>
</ul>
</li>
<li><a href="#orgc715e30">Distant Lights</a></li>
<li><a href="#org78f83bd">Area Lights</a></li>
<li><a href="#org2335026">Infinite Area Lights</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8d0d7b8">Part 4 Implement Light Transport algorithms</a>
<ul>
<li><a href="#org4a77e25">13 Monte Carlo Integration</a>
<ul>
<li><a href="#org161f0d3">Background And Probability Review</a>
<ul>
<li><a href="#org502ea8d">Continuous Random Variables</a></li>
<li><a href="#orgaa5d208">Expected Values And Variance</a></li>
</ul>
</li>
<li><a href="#orgc4e8152">The Monte Carlo Estimator</a></li>
<li><a href="#orge183bf9">Sampling Random Variables</a>
<ul>
<li><a href="#org16932ba">The Inversion Method</a></li>
<li><a href="#org88e6477">The Rejection Method</a></li>
</ul>
</li>
<li><a href="#org7ae60df">Metropolis Sampling</a>
<ul>
<li><a href="#org7a74ab1">Basic Algorithm</a></li>
<li><a href="#org286c189">Choosing Mutation Strategies</a></li>
<li><a href="#orgaae7658">Start-up Bias</a></li>
<li><a href="#org0f4baf2"><span class="todo TODO">TODO</span> 1D Setting</a></li>
<li><a href="#org5615db8"><span class="todo TODO">TODO</span> Estimating Intergrals With Metropolis Sampling</a></li>
</ul>
</li>
<li><a href="#orgc9d6e7d">Transforming Between Distributions</a>
<ul>
<li><a href="#org98f33fd">Transformation in Multiple Dimensions</a></li>
<li><a href="#org3084ca4">Polar Coordinates</a></li>
<li><a href="#orgd7000bc">Spherical Coordinates</a></li>
</ul>
</li>
<li><a href="#org0c5da72">2D Sampling With Multidimensional Transformations</a>
<ul>
<li><a href="#orgcfaac50">Uniformaly Sampling a Hemisphere</a></li>
<li><a href="#org710f623">Uniformaly Sampling a Sphere</a></li>
<li><a href="#org3360dd4">Sampling a unit disk</a></li>
<li><a href="#org861c4e1">Cosine-Weighted Hemisphere Sampling</a></li>
<li><a href="#org007dead">Sampling a Cone</a></li>
<li><a href="#orgaec6fd0">Sampling a Triangle</a></li>
<li><a href="#orge0e2e0e">Sampling Cameras</a></li>
<li><a href="#org224cf0c">Piecewise-Constant 2D Distributions</a></li>
</ul>
</li>
<li><a href="#orgeb67802">Russian Roulette And Splitting</a>
<ul>
<li><a href="#orgb5a121e">Splitting</a></li>
</ul>
</li>
<li><a href="#org9f893a5">Careful Sample Placement</a>
<ul>
<li><a href="#orgb39a6ed">Stratified Sampling</a></li>
<li><a href="#orgc4a00ac">Quasi Monte Carlo</a></li>
<li><a href="#orgd924b9e">Warping Samples And Distortion</a></li>
</ul>
</li>
<li><a href="#org833490a">Bias</a></li>
<li><a href="#orgfb3c1f9">Importance Sampling</a>
<ul>
<li><a href="#org0842357">Multiple Importance Sampling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org27fe840">14 Light Transport I:Surface Reflection</a>
<ul>
<li><a href="#orgdde12da">Sampling Reflection Functions</a>
<ul>
<li><a href="#orgf362b5c">概述</a></li>
<li><a href="#org054871f">Microfacet BxDFS</a></li>
<li><a href="#org11da200">FresnelBlend</a></li>
<li><a href="#org5f610dc">Specular Reflection And Transmission(FresnelSpecular)</a></li>
<li><a href="#orgd240bd0"><span class="todo TODO">TODO</span> Fourier BSDF</a></li>
<li><a href="#org62d7aa5">Application: Estimating Reflectance</a></li>
<li><a href="#org707718a">Sampling BSDFs</a></li>
</ul>
</li>
<li><a href="#orgb4026a2">Sampling Light Sources</a>
<ul>
<li><a href="#org0598b57">Lights With Singularities</a></li>
<li><a href="#orgb6dccb8">Sampling Shapes</a></li>
<li><a href="#orgf158ed1">Area Lights</a></li>
<li><a href="#orgcfb111b">Infinite Area Lights</a></li>
</ul>
</li>
<li><a href="#orgd129c1c">Direct Lighting</a>
<ul>
<li><a href="#org673d88f">Estimating The Direct Lighting Integral</a></li>
</ul>
</li>
<li><a href="#orgafd2b1f">The Light Transport Equation</a>
<ul>
<li><a href="#org4faad2e">Basic Derivation</a></li>
<li><a href="#org3988273">Analytic Solutions to the LTE</a></li>
<li><a href="#org7ed14bf">The Surface form of the LTE</a></li>
<li><a href="#orgb25bb26">Integral Over Paths</a></li>
<li><a href="#orgc9c5d9a">Delta Distributions in the Integrand</a></li>
<li><a href="#org677aa5c">Partitioning The Integrand</a></li>
</ul>
</li>
<li><a href="#org1f03b1c">Path Tracing</a>
<ul>
<li><a href="#org4d31319">Overview</a></li>
<li><a href="#org4de65ad">Path Sampling</a></li>
<li><a href="#org600f703">Incremental Path Construction</a></li>
<li><a href="#orgc989bc0">Implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org33ba73b">15 Light Transport II:Volume Rendering</a>
<ul>
<li><a href="#org8f971c2">The Equation of Transfer</a>
<ul>
<li><a href="#org11c8fe0"><span class="todo TODO">TODO</span> Generalized Path Space</a></li>
</ul>
</li>
<li><a href="#orgdf3cbf4">Sampling Volume Scattering</a>
<ul>
<li><a href="#org8f2d1a6">Homogeneous Medium</a></li>
<li><a href="#orgb96ae40">Heterogeneous Medium</a></li>
<li><a href="#org4b3e633">Sampling Phase Functions</a></li>
</ul>
</li>
<li><a href="#org5ee795a">Volumetric Light Transport</a>
<ul>
<li><a href="#org9733912">Path Tracing</a></li>
</ul>
</li>
<li><a href="#orgec3b9e7">Sampling Subsurface Reflection Function</a>
<ul>
<li><a href="#org001c14c"><span class="todo TODO">TODO</span> Sampling The SeparableBSSRDF</a></li>
<li><a href="#org9ec0060"><span class="todo TODO">TODO</span> Sampling The TabulatedBSSRDF</a></li>
<li><a href="#org244d594"><span class="todo TODO">TODO</span> Subsurface Scattering In The Path Tracer</a></li>
</ul>
</li>
<li><a href="#org39ccd31">Subsurface Scattering Using The Diffusion Equation</a>
<ul>
<li><a href="#org34bd58e">Principle Of Similarity</a></li>
<li><a href="#org2bf7000"><span class="todo TODO">TODO</span> Diffusion Theory</a></li>
<li><a href="#orge470f0e"><span class="todo TODO">TODO</span> Monopole Solution</a></li>
<li><a href="#org5921f01"><span class="todo TODO">TODO</span> Non-Classical Diffusion</a></li>
<li><a href="#org08e4e31"><span class="todo TODO">TODO</span> Dipole Solution</a></li>
<li><a href="#org87c57db"><span class="todo TODO">TODO</span> Beam Solution</a></li>
<li><a href="#orgf012b4f"><span class="todo TODO">TODO</span> Single Scattering Term</a></li>
<li><a href="#org18d5663"><span class="todo TODO">TODO</span> Filling The BSSRDFTable</a></li>
<li><a href="#org5c60d23"><span class="todo TODO">TODO</span> Setting Scattering Properties</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9afc5c4">16 Light Transport III:Bidirectional Methods</a>
<ul>
<li><a href="#orgce1929d">The Path-Space Measurement Equation</a></li>
<li><a href="#org8d257fa">Stochastic Progressive Photon Mapping</a></li>
<li><a href="#orgfa1ac91">Bidirectional Path Tracing</a></li>
<li><a href="#orgcf2ec69">Metropolis Light Transport</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0c1bc56">17 Retrospective and the future</a>
<ul>
<li>
<ul>
<li><a href="#org870bed9">Design Retrospective</a></li>
<li><a href="#org3b954db">Alternative Hardware</a></li>
<li><a href="#org408f169">Conclusion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org848cf46">参考资料</a></li>
</ul>
</li>
<li><a href="#org476daa3">Lighting Model</a>
<ul>
<li><a href="#orgf4bfd13">Lambert</a></li>
<li><a href="#orgbfc4cd2">Phong</a>
<ul>
<li><a href="#org749c733">缺点</a></li>
</ul>
</li>
<li><a href="#orgc89892b">BlinnPhong</a></li>
<li><a href="#orgedc1889">PBR</a>
<ul>
<li><a href="#org3244890">Cook-Torrance 模型</a></li>
<li><a href="#orgd61831b">OpenGL Implement BRDF</a></li>
<li><a href="#org4763f86">DisneyBRDF</a>
<ul>
<li><a href="#org01388d1">BRDF 图像切片</a></li>
<li><a href="#org94da2c4">DisneyDiffuse</a></li>
<li><a href="#org75b0bd4">DisneySpecular</a>
<ul>
<li><a href="#org5a6eba9">法线分布项 D</a></li>
<li><a href="#orgdecd7ac">Fresnel 项 F</a></li>
<li><a href="#org2595d34">几何项 G</a></li>
</ul>
</li>
<li><a href="#org269332c">Q&amp;A</a>
<ul>
<li><a href="#org00540a5">文章中 &phi;(d) 如何理解？</a></li>
</ul>
</li>
<li><a href="#org35140fd">参考文档</a></li>
</ul>
</li>
<li><a href="#orgf99d1f1">UnityBRDF</a>
<ul>
<li><a href="#orgbee4f6a">BRDF1</a>
<ul>
<li><a href="#org76c43ec">DiffuseTerm</a></li>
<li><a href="#org2c79d5f">Specular G|V(Visibility) D</a></li>
<li><a href="#org99fe7be">Specular G|V(Visibility) D Legacy</a></li>
<li><a href="#orgedd75ca">Specular F</a></li>
<li><a href="#org40fe3d2">BRDF1</a></li>
</ul>
</li>
<li><a href="#orgb428a38">BRDF2</a>
<ul>
<li><a href="#orgf9c28dc">BRDF2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc219969">UE4BRDF</a></li>
<li><a href="#orgdf81b03">Image Based Lighting</a></li>
<li><a href="#org3b0f065">球谐函数</a></li>
<li><a href="#org2bcf539">PBR Detail</a>
<ul>
<li><a href="#org7f7c669">参考文档</a>
<ul>
<li><a href="#org5e8f96d">How Is The NDF Really Defined?</a></li>
<li><a href="#orgb52aeaa">Sampling microfacet BRDF</a></li>
<li><a href="#org899e240">Misc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd52bc24">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgee58882">Misc</a>
<ul>
<li><a href="#orgecfd936">Aniso</a>
<ul>
<li><a href="#org0ae1c86">简单计算方式</a></li>
<li><a href="#orge904356">Gregory Ward</a></li>
<li><a href="#orgc3ba778">参考资料</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Physically Based Rendering 第 3 版 翻译.<br />
</p>
<div class="HTML" id="org5ebcedb">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgea327cc" class="outline-2">
<h2 id="orgea327cc">Physically Based Rendering</h2>
<div class="outline-text-2" id="text-orgea327cc">
</div>
<div id="outline-container-org68c6712" class="outline-3">
<h3 id="org68c6712">Prepare</h3>
<div class="outline-text-3" id="text-org68c6712">
<div class="org-src-container">
<pre class="src src-shell">git clone -b book git@github.com:mmp/pbrt-v3.git
git submodule update --init --recursive

<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; CMake SourceCode &#36335;&#24452;      D:/Documents/MyProject/Public/pbrt3_book</span>
<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; CMake Build Binaries &#36335;&#24452;  D:/Documents/MyProject/Public/pbrt3_book/BuildApp</span>
<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">Windows CMake Configure</span>
<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">Windows CMake Generate</span>

<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">D:/Documents/MyProject/Public/pbrt3_book/BuildApp &#30446;&#24405;&#19979;&#25171;&#24320;VS&#24037;&#31243;</span>

<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">run test</span>
pbrt.exe --nthreads 1 D:\Documents\MyProject\Public\pbrt3\scenes\killeroo-simple.pbrt

<span style="color: #2aa1ae; background-color: #292e34;">## </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#36733;&#26356;&#22810;&#22330;&#26223;</span>
git clone git://git.pbrt.org/pbrt-v3-scenes ./pbrt3_scenes
</pre>
</div>
</div>
</div>

<div id="outline-container-org54c9e80" class="outline-3">
<h3 id="org54c9e80">1 Introduction</h3>
<div class="outline-text-3" id="text-org54c9e80">
</div>
<div id="outline-container-org01c990a" class="outline-4">
<h4 id="org01c990a">Literate Programming</h4>
<div class="outline-text-4" id="text-org01c990a">
<p>
Literate Programming 是 Tex 的作者发明的一种编程方法，它基于很简单却非常有革命性的观念，这个观念就是应该以人的思维，而不应该以电脑的思维来写程序。<br />
</p>
</div>
</div>
<div id="outline-container-orgf36541a" class="outline-4">
<h4 id="orgf36541a">Photorealistic rendering and the ray-tracing algorithm</h4>
<div class="outline-text-4" id="text-orgf36541a">
<p>
尽管有很多种方式实现光线追踪，但是所有的这些实现中都需要模拟下面物体和现象:<br />
</p>
</div>
<div id="outline-container-orge9ea1dd" class="outline-5">
<h5 id="orge9ea1dd">Cameras</h5>
<div class="outline-text-5" id="text-orge9ea1dd">
<ul class="org-ul">
<li>对于场景图片的每个点，摄像机记录的颜色值应该为多少呢？<br />
从简易的针孔照相机来看，只有通过针孔和胶片像素点连线的光线才会被记录到胶片上。所以，可以依据像素点和摄像机位置生成射线。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbb40349" class="outline-5">
<h5 id="orgbb40349">Ray-object intersections</h5>
<div class="outline-text-5" id="text-orgbb40349">
<p>
每次摄像机生成一条射线时，渲染器的第一项任务就是确定射线第一次和哪个物体相交，并且交点在哪儿。交点就是沿着射线可见的点。然后，我们将模拟光线和交点的交互。<br />
射线的参数表示形式， \(o\) 表示射线的原点， \(t\) 为参数，其合法范围为 \((0, \infty )\)<br />
</p>
\begin{align}
r(t) = o + td;
\end{align}

<p>
只是一个单独的交点对于射线追踪器是不够的，它还需要知道表面上该点的一些特定的属性。首先，该点的材质必须是确定的，并且会被传递给射线追踪算法的后续阶段。其次，交点的额外的几何信息也是需要的。例如交点的法线。<br />
</p>
</div>
</div>
<div id="outline-container-org6a77c0f" class="outline-5">
<h5 id="org6a77c0f">Light sources</h5>
<div class="outline-text-5" id="text-org6a77c0f">
<p>
射线和物体的交互阶段确定了需要被渲染的点，以及该点的一些局部几何信息。回顾我们最终的目标是要找出在摄像机方向上离开该点的光的总量。为此我们需要知道有多少光照可以到达该交点。<br />
假设光源为点光源，单位表面接收到的辐照度如下， \(\Phi\) 表示光源的辐射通量，\(\theta\) 表示光线和表面的夹角<br />
</p>
\begin{align}
dE = \frac{\Phi cos\theta}{4\pi r^2}
\end{align}
</div>
</div>
<div id="outline-container-orgc946561" class="outline-5">
<h5 id="orgc946561">Visibility</h5>
<div class="outline-text-5" id="text-orgc946561">
<p>
构造一个新的射线，其起点为前面阶段得到的交点，其方向指向光源。这些特殊的射线被称为阴影射线。如果我们追踪这些射线，就可以判断是否有阻挡物在交点和光源之间，没有阻挡物时，光线的贡献才会被计算。<br />
</p>
</div>
</div>
<div id="outline-container-org4fc2c8e" class="outline-5">
<h5 id="org4fc2c8e">Surface scattering</h5>
<div class="outline-text-5" id="text-org4fc2c8e">
<p>
场景中的每个物体都提供了一个材质，这是物体表面上每个点的显示属性的描述。这个描述是通过双向反射分布函数给出的。这个函数可以告诉我们从入射方向 \(w_i\) 到 出射方向 \(w_o\) 有多少能量被反射。我们将在 p 点的 BRDF 记作 \(f_r(p, w_o, w_i)\)<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">light</span> <span style="color: #4f97d7; font-weight: bold;">in</span> lights)
   {
       <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span><span style="color: #bc6ec5; font-weight: bold;">IsLightBlocked</span>(light))
       {
           incident_light = light.<span style="color: #bc6ec5; font-weight: bold;">L</span>(point);
           amount_reflected = surface.<span style="color: #bc6ec5; font-weight: bold;">BRDF</span>(hit_point, camera_vector, light_vector);
           L += amount_reflected * incident_light;
       }
   }
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#30340; L &#34920;&#31034;&#36752;&#23556;&#29575;</span>
</pre>
</div>
<p>
BTDF 双向透射分布函数<br />
BSDF 双向散射分布函数<br />
BSSRDF 双向次表面散射反射分布函数<br />
</p>
</div>
</div>
<div id="outline-container-org5909344" class="outline-5">
<h5 id="org5909344">Indirect light transport</h5>
<div class="outline-text-5" id="text-org5909344">
<p>
如果从摄像机发出的射线碰到了有光泽的物体例如一面镜子，我们可以依据交点处表面的法线反射射线，并递归地调用射线追踪程序来找到到达交点的光照，然后将其贡献加到原始的摄像机射线中。同样的技术可以用于追踪和透明物体相交时，生成的透射射线。<br />
</p>

<p>
通常来讲，从某个点到达摄像机的光由两部分组成，一部分是该点发出的光的总量，另一部分是该点反射的光的总量。这种观念的正式表述就是光照传播方程（也叫渲染方程）：<br />
</p>
\begin{align}
L_o(p, w_o) = L_e(p, w_o) + \int_{S^2}f(p,w_o,w_i)L_i(p,w_i)|cos \theta_i|dw_i
\end{align}

<p>
Whitted 简化了上述渲染方程中，积分的求解，他只计算朝向光源的 L_i(p,w_i)。但是，他的方法可以进一步扩展，例如，我们可以计算多个靠近 Whitted 选取方向的射线进行计算，然后按照权重计算他们的贡献，这样就可以获得更好的效果。<br />
</p>

<p>
当射线碰到物体时，我们可以一直生成新的射线，然后，递归计算该射线。这样就可以捕捉到物体之间所有的反射，从而创造出非常真实的图片。<br />
</p>
</div>
</div>
<div id="outline-container-orgb87276d" class="outline-5">
<h5 id="orgb87276d">Ray propagation</h5>
<div class="outline-text-5" id="text-orgb87276d">
<p>
介质对光传播的影响有两种方式。<br />
第一种，介质可以减弱光线，无论是吸收或者是将光散射到其他方向。我们可以通过计算射线原点和当前交点之间的透射率来计算这种影响效果。<br />
第二种，介质也可以对射线携带的光有增强作用。当介质本身发光时，或者是介质从其他方向反射光照到当前射线方向。从数值上计算体积光传播方程可以找到很多这样的例子。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf02a783" class="outline-4">
<h4 id="orgf02a783">pbrt: System Overview</h4>
<div class="outline-text-4" id="text-orgf02a783">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Base Class</th>
<th scope="col" class="org-left">Directory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Shape</td>
<td class="org-left">shapes/</td>
</tr>

<tr>
<td class="org-left">Aggregate</td>
<td class="org-left">accelerators/</td>
</tr>

<tr>
<td class="org-left">Camera</td>
<td class="org-left">cameras/</td>
</tr>

<tr>
<td class="org-left">Sampler</td>
<td class="org-left">samplers</td>
</tr>

<tr>
<td class="org-left">Filter</td>
<td class="org-left">filters/</td>
</tr>

<tr>
<td class="org-left">Material</td>
<td class="org-left">materials/</td>
</tr>

<tr>
<td class="org-left">Texture</td>
<td class="org-left">textures/</td>
</tr>

<tr>
<td class="org-left">Medium</td>
<td class="org-left">media/</td>
</tr>

<tr>
<td class="org-left">Light</td>
<td class="org-left">lights/</td>
</tr>

<tr>
<td class="org-left">Integrator</td>
<td class="org-left">integrators/</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org5d63657" class="outline-5">
<h5 id="org5d63657">phases of execution</h5>
<div class="outline-text-5" id="text-org5d63657">
<pre class="example" id="orgcb4aea8">
- 解析完命令行参数后，会调用 api.cpp - pbrtWorldEnd() 函数
- pbrtWorldEnd 中会先创建 Integrator, 调用 api.cpp - RenderOptions::MakeIntegrator()
- 创建 Integrator 时会先创建 Sampler, 调用 api.cpp - MakeSampler()
- 创建 Integrator
- 创建完 Integator 后会创建 Scene，调用 api.cpp - RenderOptions::MakeScene()
- 创建 Scene时会先创建场景管理数据结构 Accelerator, 调用 api.cpp - MakeAccelerator()
- 创建 Scene
- 创建完Scene之后会执行 integrator-&gt;Render(*scene) 开启渲染主循环
</pre>
</div>
</div>
<div id="outline-container-org88aec90" class="outline-5">
<h5 id="org88aec90">scene representation</h5>
</div>
<div id="outline-container-org4a604b9" class="outline-5">
<h5 id="org4a604b9">integrator interface and SamplerIntegrator</h5>
</div>
<div id="outline-container-orgc902b1c" class="outline-5">
<h5 id="orgc902b1c">the main rendering loop</h5>
<div class="outline-text-5" id="text-orgc902b1c">
</div>
<div id="outline-container-org5208cc6" class="outline-6">
<h6 id="org5208cc6">Ray differentials</h6>
<div class="outline-text-6" id="text-org5208cc6">
<p>
Ray differentials 包含了射线的相关的信息，其实就是在当前像素点上分别在 x 和 y 方向上偏移一像素生成的射线.<br />
</p>
</div>
</div>
<div id="outline-container-org6bdb9f2" class="outline-6">
<h6 id="org6bdb9f2">Li 函数</h6>
<div class="outline-text-6" id="text-org6bdb9f2">
<p>
Li 函数用于计算给定射线的入射辐射率<br />
</p>
<ul class="org-ul">
<li>ray 指定被计算的射线<br /></li>
<li>scene 指定被渲染的场景<br /></li>
<li>sampler 样本生成器，使用 MonteCarlo 积分来计算光照传输方程<br /></li>
<li>arena MemoryArena 对象，用于积分器高效地分配临时内存空间<br /></li>
<li>depth 射线从摄像机发出，直到当前调用 Li()，弹射的次数<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org988c468" class="outline-6">
<h6 id="org988c468">渲染主循环流程</h6>
<div class="outline-text-6" id="text-org988c468">
<pre class="example" id="orgdaf0d4c">
- 依据胶片大小划分tile, 每个tile并行进行渲染
  - 为tile分配内存
  - 为 tile 克隆sampler实例
  - 计算tile的采样边界
  - 依据tile的采样边界获取对应的FileTile
  - 遍历tile内的每个像素，对每个像素进行渲染
  	- 对每个像素的每个样本进行处理
      - 根据像素坐标获取对应的CameraSample
      - 为当前的CameraSample 生成摄像机射线
			- 计算沿着摄像机射线的辐射率 L
      - 记录当前样本贡献的辐射率，以及对应的权重
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbababc1" class="outline-5">
<h5 id="orgbababc1">an integrator for whited ray tracing</h5>
<div class="outline-text-5" id="text-orgbababc1">
<p>
Whitted 积分器的工作方式是，沿着射线的反射和折射方向递归地计算辐射率。当达到预先决定的最大深度后停止递归。如果不设置最大深度的话，可能递归永远都不会结束。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4a9892f" class="outline-4">
<h4 id="org4a9892f">parallelization of pbrt</h4>
</div>
<div id="outline-container-org280f7ab" class="outline-4">
<h4 id="org280f7ab">EXERCISE</h4>
<div class="outline-text-4" id="text-org280f7ab">
<div class="org-src-container">
<pre class="src src-shell">pbrt.exe --nthreads 1 D:\Documents\MyProject\Public\pbrt3\scenes\killeroo-simple.pbrt
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org04463c6" class="outline-3">
<h3 id="org04463c6">Part 1 Main Geometric Functionality</h3>
<div class="outline-text-3" id="text-org04463c6">
</div>
<div id="outline-container-orgd4b3194" class="outline-4">
<h4 id="orgd4b3194">2 Geometry and Transformations</h4>
<div class="outline-text-4" id="text-orgd4b3194">
</div>
<div id="outline-container-orgc72f7b0" class="outline-5">
<h5 id="orgc72f7b0">本书坐标系</h5>
<div class="outline-text-5" id="text-orgc72f7b0">
<p>
PhysicalBasedRendering  坐标系为左手坐标系，向量为列向量<br />
</p>

<ul class="org-ul">
<li>各种坐标系惯例 <a href="../theory/ComputerGraphicMath.html#orgc7e557b">../theory/ComputerGraphicMath.html#orgc7e557b</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga11254a" class="outline-5">
<h5 id="orga11254a">从一个向量创建一个坐标系</h5>
<div class="outline-text-5" id="text-orga11254a">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992; &#20114;&#30456;&#22402;&#30452;&#30340;&#21521;&#37327;&#22841;&#35282;&#20026;90&#24230;&#65292;&#21017;cos(\theta)=0</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21462; v1 x&#12289;y&#20998;&#37327;&#20013;&#27604;&#36739;&#22823;&#30340;&#21521;&#37327;&#21644;z&#20998;&#37327;&#20132;&#25442;&#65292;&#24182;&#23558;z&#65288;&#21407;&#26469;z&#20998;&#37327;&#20540;&#25152;&#22788;&#30340;&#26032;&#20998;&#37327;&#65289;&#21462;&#21453;&#65292;&#20877;&#23558;&#20998;&#37327;&#27604;&#36739;&#23567;&#30340;&#39033;&#65288;&#27809;&#26377;&#21442;&#19982;&#20132;&#25442;&#30340;&#20998;&#37327;&#65289;&#32622;0&#65292;&#26032;&#30340;&#21521;&#37327;&#23601;&#21487;&#20197;&#28385;&#36275;&#19978;&#38754;&#30340;&#26465;&#20214;</span>
  template &lt;typename T&gt; <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">void</span>
  CoordinateSystem(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3</span>&lt;T&gt; &amp;v1, Vector3&lt;T&gt; *v2, Vector3&lt;T&gt; *v3)
  {
      <span style="color: #4f97d7; font-weight: bold;">if</span> (std::abs(v1.x) &gt; std::abs(v1.y))
      {
          *v2 = Vector3&lt;T&gt;(-v1.z, 0, v1.x) / std::sqrt(v1.x * v1.x + v1.z * v1.z);
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          *v2 = Vector3&lt;T&gt;(0, v1.z, -v1.y) / std::sqrt(v1.y * v1.y + v1.z * v1.z);
      }
      *v3 = Cross(v1, *v2);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org322ee0a" class="outline-5">
<h5 id="org322ee0a">AABB Bounding Box</h5>
<div class="outline-text-5" id="text-org322ee0a">
<div class="org-src-container">
<pre class="src src-c">  template &lt;typename T&gt; Bounds3&lt;T&gt;
  Union(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b1, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b2) {
      <span style="color: #4f97d7; font-weight: bold;">return</span> Bounds3&lt;T&gt;(Point3&lt;T&gt;(std::min(b1.pMin.x, b2.pMin.x),
                                  std::min(b1.pMin.y, b2.pMin.y),
                                  std::min(b1.pMin.z, b2.pMin.z)),
                        Point3&lt;T&gt;(std::max(b1.pMax.x, b2.pMax.x),
                                  std::max(b1.pMax.y, b2.pMax.y),
                                  std::max(b1.pMax.z, b2.pMax.z)));
  }

  template &lt;typename T&gt; Bounds3&lt;T&gt;
  Intersect(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b1, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b2) {
      <span style="color: #4f97d7; font-weight: bold;">return</span> Bounds3&lt;T&gt;(Point3&lt;T&gt;(std::max(b1.pMin.x, b2.pMin.x),
                                  std::max(b1.pMin.y, b2.pMin.y),
                                  std::max(b1.pMin.z, b2.pMin.z)),
                        Point3&lt;T&gt;(std::min(b1.pMax.x, b2.pMax.x),
                                  std::min(b1.pMax.y, b2.pMax.y),
                                  std::min(b1.pMax.z, b2.pMax.z)));
  }

  template &lt;typename T&gt;
  bool Overlaps(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b1, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3</span>&lt;T&gt; &amp;b2) {
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">x</span> = (b1.pMax.x &gt;= b2.pMin.x) &amp;&amp; (b1.pMin.x &lt;= b2.pMax.x);
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">y</span> = (b1.pMax.y &gt;= b2.pMin.y) &amp;&amp; (b1.pMin.y &lt;= b2.pMax.y);
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">z</span> = (b1.pMax.z &gt;= b2.pMin.z) &amp;&amp; (b1.pMin.z &lt;= b2.pMax.z);
      <span style="color: #4f97d7; font-weight: bold;">return</span> (x &amp;&amp; y &amp;&amp; z);
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org1616c5b" class="outline-5">
<h5 id="org1616c5b">Point 和 Vector 的不同</h5>
<div class="outline-text-5" id="text-org1616c5b">
<p>
点可以被表示为 [s1,s2,s3,1][v1,v2,v3,p0]^T 或 [v1,v2,v3,p0][s1,s2,s3,1]^T<br />
向量可以被表示为 [s1,s2,s3,0][v1,v2,v3,p0]^T 或 [v1,v2,v3,p0][s1,s2,s3,0]^T<br />
</p>

<p>
向量和矩阵运算即向量在空间中变换时，平移变换不会改变向量。将向量的第四个分量赋值为 0，可以保证向量和矩阵的运算中向量不受坐标系原点变化的影响(平移变换)。<br />
</p>
</div>
</div>
<div id="outline-container-org42bcd9f" class="outline-5">
<h5 id="org42bcd9f">Normal 和 Vector 的不同</h5>
<div class="outline-text-5" id="text-org42bcd9f">
<p>
Normal 是垂直与表面的向量，对一个表面做矩阵变换后，为了保证 Normal 于表面依然垂直，需要对 Normal 使用不同的矩阵变换。<br />
</p>

<p>
n 为原始平面 A 点处的法线，t为原始平面 A 点处法线 n 对应的切线，n'为变换后平面 A 点处的法线，t'为变换后平面 A 点处法线 n'对应的切线。<br />
变换前满足条件 dot(n,t) = n^Tt = 0<br />
变换后满足条件 dot(n',t') = n'^Tt' = 0<br />
假设 S 为变换 Normal 的矩阵则有：<br />
(Sn)^Tt'=0<br />
(Sn)^TMt=0<br />
n^TS^TMt=0  ==&gt; S^TM = I ==&gt; S^T=M^(-1) ==&gt; S=(M^(-1))^T<br />
</p>


<div id="org330f56b" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_08_NormalTrans.jpg" alt="20_05_08_NormalTrans.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org43c20a5" class="outline-5">
<h5 id="org43c20a5">Matrix</h5>
<div class="outline-text-5" id="text-org43c20a5">
<p>
本书中使用了列向量，Matrix 和向量相乘时，向量在右边矩阵在左边。Matrix 每一列表示新坐标系的坐标轴的基向量。<br />
代码中 Matrix 按照行主序(row-major)存储，和向量相乘时，Matrix 每行分别和向量相乘：<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">m[0][0] m[0][1] m[0][2] m[0][3]  </span>
<span style="color: #2aa1ae; background-color: #292e34;">m[1][0] m[1][1] m[1][2] m[1][3]  </span>
<span style="color: #2aa1ae; background-color: #292e34;">m[2][0] m[2][1] m[2][2] m[2][3]  </span>
<span style="color: #2aa1ae; background-color: #292e34;">m[3][0] m[3][1] m[3][2] m[3][3]  </span>
<span style="color: #2aa1ae; background-color: #292e34;">*/</span>

template &lt;typename T&gt;
<span style="color: #4f97d7; font-weight: bold;">inline</span> Point3&lt;T&gt; Transform::operator()(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3</span>&lt;T&gt; &amp;p) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">x</span> = p.x, <span style="color: #7590db;">y</span> = p.y, <span style="color: #7590db;">z</span> = p.z;
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">xp</span> = m.m[0][0] * x + m.m[0][1] * y + m.m[0][2] * z + m.m[0][3];
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">yp</span> = m.m[1][0] * x + m.m[1][1] * y + m.m[1][2] * z + m.m[1][3];
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">zp</span> = m.m[2][0] * x + m.m[2][1] * y + m.m[2][2] * z + m.m[2][3];
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">wp</span> = m.m[3][0] * x + m.m[3][1] * y + m.m[3][2] * z + m.m[3][3];
    CHECK_NE(wp, 0);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (wp == 1)
        <span style="color: #4f97d7; font-weight: bold;">return</span> Point3&lt;T&gt;(xp, yp, zp);
    <span style="color: #4f97d7; font-weight: bold;">else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> Point3&lt;T&gt;(xp, yp, zp) / wp;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbed3f10" class="outline-5">
<h5 id="orgbed3f10">矩阵和行列式</h5>
<div class="outline-text-5" id="text-orgbed3f10">
<ul class="org-ul">
<li>数学家最初发明行列式和矩阵是为了解决什么问题？ <a href="https://www.zhihu.com/question/19919917/answer/270694029">https://www.zhihu.com/question/19919917/answer/270694029</a><br /></li>
<li>行列式与矩阵之间的深刻联系是什么？ <a href="https://www.zhihu.com/question/31698184">https://www.zhihu.com/question/31698184</a><br /></li>
<li>行列式的本质是什么？ <a href="https://www.zhihu.com/question/36966326/answer/70687817">https://www.zhihu.com/question/36966326/answer/70687817</a><br /></li>
<li>行列式的计算方法 <a href="https://www.jianshu.com/p/99b9ac1c6162">https://www.jianshu.com/p/99b9ac1c6162</a><br /></li>
<li>n 阶行列式 <a href="https://baike.baidu.com/item/n%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F">https://baike.baidu.com/item/n%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F</a><br /></li>
<li>特征值和特征向量的意义？ <a href="https://www.zhihu.com/question/29589753">https://www.zhihu.com/question/29589753</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgedc96d2" class="outline-5">
<h5 id="orgedc96d2">逆矩阵求解</h5>
<div class="outline-text-5" id="text-orgedc96d2">
<ul class="org-ul">
<li>伴随矩阵 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5">https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5</a><br /></li>
<li>逆矩阵 <a href="https://baike.baidu.com/item/%E9%80%86%E7%9F%A9%E9%98%B5">https://baike.baidu.com/item/%E9%80%86%E7%9F%A9%E9%98%B5</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24179;&#31227;&#30697;&#38453;&#30340;&#36870;&#30697;&#38453;</span>
<span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #bc6ec5; font-weight: bold;">Translate</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;delta) {
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #bc6ec5; font-weight: bold;">m</span>(1, 0, 0, delta.x,
0, 1, 0, delta.y,
0, 0, 1, delta.z,
0, 0, 0, 1);
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #bc6ec5; font-weight: bold;">minv</span>(1, 0, 0, -delta.x,
0, 1, 0, -delta.y,
0, 0, 1, -delta.z,
0, 0, 0, 1);
<span style="color: #4f97d7; font-weight: bold;">return</span> Transform(m, minv);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32553;&#25918;&#30697;&#38453;&#30340;&#36870;&#30697;&#38453;</span>
<span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #bc6ec5; font-weight: bold;">Scale</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">z</span>) {
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #bc6ec5; font-weight: bold;">m</span>(x, 0, 0, 0,
0, y, 0, 0,
0, 0, z, 0,
0, 0, 0, 1);
<span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #bc6ec5; font-weight: bold;">minv</span>(1/x, 0, 0, 0,
0, 1/y, 0, 0,
0, 0, 1/z, 0,
0, 0, 0, 1);
<span style="color: #4f97d7; font-weight: bold;">return</span> Transform(m, minv);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26059;&#36716;&#30697;&#38453;&#30340;&#36870;&#30697;&#38453;&#20026;&#26059;&#36716;&#30697;&#38453;&#30340;&#36716;&#32622;&#30697;&#38453;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgad540d4" class="outline-5">
<h5 id="orgad540d4">LookAt</h5>
<div class="outline-text-5" id="text-orgad540d4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #bc6ec5; font-weight: bold;">LookAt</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;pos, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;look, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;up) {
    <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">cameraToWorld</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize fourth column of viewing matrix</span>
    cameraToWorld.m[0][3] = pos.x;
    cameraToWorld.m[1][3] = pos.y;
    cameraToWorld.m[2][3] = pos.z;
    cameraToWorld.m[3][3] = 1;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize first three columns of viewing matrix</span>
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">dir</span> = Normalize(look - pos);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (Cross(Normalize(up), dir).Length() == 0) {
        Error(
            <span style="color: #2d9574;">"\"up\" vector (%f, %f, %f) and viewing direction (%f, %f, %f) "</span>
            <span style="color: #2d9574;">"passed to LookAt are pointing in the same direction.  Using "</span>
            <span style="color: #2d9574;">"the identity transformation."</span>,
            up.x, up.y, up.z, dir.x, dir.y, dir.z);
        <span style="color: #4f97d7; font-weight: bold;">return</span> Transform();
    }
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">right</span> = Normalize(Cross(Normalize(up), dir));
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">newUp</span> = Cross(dir, right);
    cameraToWorld.m[0][0] = right.x;
    cameraToWorld.m[1][0] = right.y;
    cameraToWorld.m[2][0] = right.z;
    cameraToWorld.m[3][0] = 0.;
    cameraToWorld.m[0][1] = newUp.x;
    cameraToWorld.m[1][1] = newUp.y;
    cameraToWorld.m[2][1] = newUp.z;
    cameraToWorld.m[3][1] = 0.;
    cameraToWorld.m[0][2] = dir.x;
    cameraToWorld.m[1][2] = dir.y;
    cameraToWorld.m[2][2] = dir.z;
    cameraToWorld.m[3][2] = 0.;
    <span style="color: #4f97d7; font-weight: bold;">return</span> Transform(Inverse(cameraToWorld), cameraToWorld);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org01f0af9" class="outline-5">
<h5 id="org01f0af9">判断矩阵是否为透视矩阵</h5>
<div class="outline-text-5" id="text-org01f0af9">
<p>
<a href="../graphics/UnityCatLikeCoding.html#org0940ed3">../graphics/UnityCatLikeCoding.html#org0940ed3</a><br />
</p>
</div>
</div>
<div id="outline-container-org355307f" class="outline-5">
<h5 id="org355307f">判断矩阵是否包含缩放</h5>
<div class="outline-text-5" id="text-org355307f">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">HasScale</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Float</span> la2 = (*<span style="color: #4f97d7; font-weight: bold;">this</span>)(Vector3f(1, 0, 0)).LengthSquared();
      <span style="color: #4f97d7; font-weight: bold;">Float</span> lb2 = (*<span style="color: #4f97d7; font-weight: bold;">this</span>)(Vector3f(0, 1, 0)).LengthSquared();
      <span style="color: #4f97d7; font-weight: bold;">Float</span> lc2 = (*<span style="color: #4f97d7; font-weight: bold;">this</span>)(Vector3f(0, 0, 1)).LengthSquared();
<span style="color: #bc6ec5;">      #define</span> NOT_ONE(x) ((x) &lt; .999f || (x) &gt; 1.001f)
      <span style="color: #4f97d7; font-weight: bold;">return</span> (NOT_ONE(la2) || NOT_ONE(lb2) || NOT_ONE(lc2));
<span style="color: #bc6ec5;">      #undef</span> NOT_ONE
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbdce59e" class="outline-5">
<h5 id="orgbdce59e">判断矩阵是否会将左手坐标系变为右手坐标系</h5>
<div class="outline-text-5" id="text-orgbdce59e">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">Transform</span>::SwapsHandedness() <span style="color: #4f97d7; font-weight: bold;">const</span> {
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">det</span> =
          m.m[0][0] * (m.m[1][1] * m.m[2][2] - m.m[1][2] * m.m[2][1]) -
          m.m[0][1] * (m.m[1][0] * m.m[2][2] - m.m[1][2] * m.m[2][0]) +
          m.m[0][2] * (m.m[1][0] * m.m[2][1] - m.m[1][1] * m.m[2][0]);
      <span style="color: #4f97d7; font-weight: bold;">return</span> det &lt; 0;
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org44ec135" class="outline-5">
<h5 id="org44ec135">从矩阵中分离 TRS</h5>
<div class="outline-text-5" id="text-org44ec135">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AnimatedTransform</span>::Decompose(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> &amp;m, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">T</span>, <span style="color: #ce537a; font-weight: bold;">Quaternion</span> *<span style="color: #7590db;">Rquat</span>, <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> *<span style="color: #7590db;">S</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Extract translation _T_ from transformation matrix</span>
    T-&gt;x = m.m[0][3];
    T-&gt;y = m.m[1][3];
    T-&gt;z = m.m[2][3];

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute new transformation matrix _M_ without translation</span>
    <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">M</span> = m;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; 3; ++i) M.m[i][3] = M.m[3][i] = 0.f;
    M.m[3][3] = 1.f;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Extract rotation _R_ from transformation matrix</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">norm</span>;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">count</span> = 0;
    <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">R</span> = M;
    <span style="color: #4f97d7; font-weight: bold;">do</span> {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute next matrix _Rnext_ in series</span>
        <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">Rnext</span>;
        <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">Rit</span> = Inverse(Transpose(R));
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; 4; ++i)
            <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">j</span> = 0; j &lt; 4; ++j)
                Rnext.m[i][j] = 0.5f * (R.m[i][j] + Rit.m[i][j]);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute norm of difference between _R_ and _Rnext_</span>
        norm = 0;
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; 3; ++i) {
            <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">n</span> = std::abs(R.m[i][0] - Rnext.m[i][0]) +
                std::abs(R.m[i][1] - Rnext.m[i][1]) +
                std::abs(R.m[i][2] - Rnext.m[i][2]);
            norm = std::max(norm, n);
        }
        R = Rnext;
    } <span style="color: #4f97d7; font-weight: bold;">while</span> (++count &lt; 100 &amp;&amp; norm &gt; .0001);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">XXX TODO FIXME deal with flip...</span>
    *Rquat = Quaternion(R);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute scale _S_ using rotation and original matrix</span>
    *S = Matrix4x4::Mul(Inverse(R), M);
}
</pre>
</div>


<div id="orgc827fd1" class="figure">
<p><img src="./PhysicallyBasedRendering/decompose_matrix.jpg" alt="decompose_matrix.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb6d1da9" class="outline-4">
<h4 id="orgb6d1da9">3 Shapes</h4>
<div class="outline-text-4" id="text-orgb6d1da9">
</div>
<div id="outline-container-org68458f6" class="outline-5">
<h5 id="org68458f6">AABB 和射线求交点</h5>
<div class="outline-text-5" id="text-org68458f6">
<p>
参考项目 unitycatlikecoding\RenderingAndAdvancedR\Assets\MyTest\08BoundingBoxAlgorithm 中计算。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">template &lt;typename T&gt;
<span style="color: #4f97d7; font-weight: bold;">inline</span> bool Bounds3&lt;T&gt;::IntersectP(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;ray, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">hitt0</span>,
                                   <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">hitt1</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">t0</span> = 0, <span style="color: #7590db;">t1</span> = ray.tMax;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; 3; ++i) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update interval for _i_th bounding box slab</span>
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">invRayDir</span> = 1 / ray.d[i];
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tNear</span> = (pMin[i] - ray.o[i]) * invRayDir;
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tFar</span> = (pMax[i] - ray.o[i]) * invRayDir;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update parametric interval from slab intersection $t$ values</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (tNear &gt; tFar) std::swap(tNear, tFar);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update _tFar_ to ensure robust ray--bounds intersection</span>
        tFar *= 1 + 2 * gamma(3);
        t0 = tNear &gt; t0 ? tNear : t0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tFar&#20026;&#26080;&#31351;&#22823;&#26102;&#65292;t1=t1=ray.tMax</span>
        t1 = tFar &lt; t1 ? tFar : t1;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (t0 &gt; t1) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (hitt0) *hitt0 = t0;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (hitt1) *hitt1 = t1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
}

template &lt;typename T&gt;
<span style="color: #4f97d7; font-weight: bold;">inline</span> bool Bounds3&lt;T&gt;::IntersectP(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;ray, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;invDir, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">dirIsNeg</span>[3]) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3f</span> &amp;bounds = *this;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Check for ray intersection against $x$ and $y$ slabs</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;xAxis yAxis&#26041;&#21521;ray&#21644;BoundBox&#30340;&#30456;&#20132;&#21306;&#22495;</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tMin</span> = (bounds[dirIsNeg[0]].x - ray.o.x) * invDir.x;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tMax</span> = (bounds[1 - dirIsNeg[0]].x - ray.o.x) * invDir.x;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tyMin</span> = (bounds[dirIsNeg[1]].y - ray.o.y) * invDir.y;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tyMax</span> = (bounds[1 - dirIsNeg[1]].y - ray.o.y) * invDir.y;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update _tMax_ and _tyMax_ to ensure robust bounds intersection</span>
    tMax *= 1 + 2 * gamma(3);
    tyMax *= 1 + 2 * gamma(3);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">xAxis&#26041;&#21521;&#19978;&#30340;&#30456;&#20132;&#21306;&#22495;&#21521;yAxis&#26041;&#21521;&#24310;&#20280; yAxis&#26041;&#21521;&#19978;&#30340;&#30456;&#20132;&#21306;&#22495;&#21521;xAxis&#26041;&#21521;&#24310;&#20280; &#22914;&#26524;&#20004;&#20010;&#24310;&#20280;&#21518;&#30340;&#21306;&#22495;&#19981;&#30456;&#20132; &#35828;&#26126;ray&#21644;BoundingBox&#19981;&#30456;&#20132;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tMin &gt; tyMax || tyMin &gt; tMax) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tyMin &gt; tMin) tMin = tyMin;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tyMax &lt; tMax) tMax = tyMax;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Check for ray intersection against $z$ slab</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tzMin</span> = (bounds[dirIsNeg[2]].z - ray.o.z) * invDir.z;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tzMax</span> = (bounds[1 - dirIsNeg[2]].z - ray.o.z) * invDir.z;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update _tzMax_ to ensure robust bounds intersection</span>
    tzMax *= 1 + 2 * gamma(3);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tMin &gt; tzMax || tzMin &gt; tMax) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tzMin &gt; tMin) tMin = tzMin;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tzMax &lt; tMax) tMax = tzMax;
    <span style="color: #4f97d7; font-weight: bold;">return</span> (tMin &lt; ray.tMax) &amp;&amp; (tMax &gt; 0);
}

</pre>
</div>


<div id="orga43a4ea" class="figure">
<p><img src="./PhysicallyBasedRendering/aabb_interaction.jpg" alt="aabb_interaction.jpg" /><br />
</p>
</div>

<p>
下面文章对算法解释的很清楚：<br />
</p>
<ul class="org-ul">
<li>射线与包围盒的相交测试 <a href="https://zhuanlan.zhihu.com/p/138259656">https://zhuanlan.zhihu.com/p/138259656</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org073cd08" class="outline-5">
<h5 id="org073cd08">Sphere Shape</h5>
<div class="outline-text-5" id="text-org073cd08">
<p>
x^2+y^2+z^2 = 1   单位球<br />
x^2+y^2+z^2 = r^2 半径为 r 的球<br />
</p>

<p>
f(&Theta;,&Phi;) 形式<br />
x = rsin(&Theta;)cos(&Phi;)<br />
y = rsin(&Theta;)sin(&Theta;)<br />
z = rcos(&Theta;)<br />
</p>

<p>
f(u, v)形式<br />
&Phi; = u&Phi;<sub>max</sub><br />
&Theta; = &Theta;<sub>min</sub> + v(&Theta;<sub>max</sub>-&Theta;<sub>min</sub>)<br />
</p>


<div id="org98df7b6" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_18_SphereEqua.jpg" alt="20_05_18_SphereEqua.jpg" /><br />
</p>
</div>

<p>
下面链接可以求解偏导数：<br />
</p>
<ul class="org-ul">
<li><a href="https://zs.symbolab.com/solver/partial-derivative-calculator/%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%20u%7D%5Cleft(rsin%5Cleft(%5Ctheta%20%5Cright)cos%5Cleft(u%5Cphi%20%5Cright)%5Cright)">https://zs.symbolab.com/solver/partial-derivative-calculator/%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%20u%7D%5Cleft(rsin%5Cleft(%5Ctheta%20%5Cright)cos%5Cleft(u%5Cphi%20%5Cright)%5Cright)</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org014185f" class="outline-5">
<h5 id="org014185f">曲面面积求解</h5>
<div class="outline-text-5" id="text-org014185f">
<p>
曲线长度求解<br />
<img src="./PhysicallyBasedRendering/20_05_18_CurveLen.jpg" alt="20_05_18_CurveLen.jpg" /><br />
</p>

<ul class="org-ul">
<li>曲线长度求解 <a href="https://www.jianshu.com/p/f4b0b7a74c7e">https://www.jianshu.com/p/f4b0b7a74c7e</a><br /></li>
</ul>

<p>
任意光滑曲线绕 x 轴旋转一周得到的旋转曲面的面积<br />
</p>

<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/50518832">https://www.zhihu.com/question/50518832</a><br /></li>
</ul>

<p>
一般曲面面积求解，下图为曲面面积公式<br />
<img src="./PhysicallyBasedRendering/20_05_15_CurveArea.jpg" alt="20_05_15_CurveArea.jpg" /><br />
</p>
<ul class="org-ul">
<li>如何理解导数的概念 ? <a href="https://www.zhihu.com/question/28684811/answer/159589897">https://www.zhihu.com/question/28684811/answer/159589897</a><br /></li>
<li>曲面面积公式推导 <a href="https://www.zhihu.com/question/48421749/answer/165585609">https://www.zhihu.com/question/48421749/answer/165585609</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org48b0114" class="outline-5">
<h5 id="org48b0114">Cylinder Shape</h5>
<div class="outline-text-5" id="text-org48b0114">
<p>
x^2+y^2-r^2 = 0<br />
</p>

<p>
&Phi; = u&Phi;<sub>max</sub><br />
x = rcos(&Phi;)<br />
y = rsin(&Phi;)<br />
z = z<sub>min</sub> + v(z<sub>max</sub>-z<sub>min</sub>)<br />
</p>


<div id="orgf4df89b" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_18_CylinderEqua.jpg" alt="20_05_18_CylinderEqua.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org90e2392" class="outline-5">
<h5 id="org90e2392">Disk</h5>
<div class="outline-text-5" id="text-org90e2392">
<p>
&Phi; = u&Phi;<sub>max</sub><br />
x = ((1-v)r<sub>i</sub> + vr)cos(&Phi;)<br />
y = ((1-v)r<sub>i</sub> + vr)sin(&Phi;)<br />
z = h<br />
</p>


<div id="orgf5353cd" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_18_DiskEqua.jpg" alt="20_05_18_DiskEqua.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgae50775" class="outline-5">
<h5 id="orgae50775">Cone</h5>
<div class="outline-text-5" id="text-orgae50775">
<p>
<img src="./PhysicallyBasedRendering/20_05_18_ConeEqua.jpg" alt="20_05_18_ConeEqua.jpg" /><br />
<img src="./PhysicallyBasedRendering/00_03_cone_equation.jpg" alt="00_03_cone_equation.jpg" /><br />
</p>
<ul class="org-ul">
<li>圆锥体方程推导 <a href="https://zhidao.baidu.com/question/1432238340617922939.html">https://zhidao.baidu.com/question/1432238340617922939.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga77214d" class="outline-5">
<h5 id="orga77214d">Paraboloid</h5>
<div class="outline-text-5" id="text-orga77214d">
<p>
<img src="./PhysicallyBasedRendering/20_05_18_ParaboloidEqua.jpg" alt="20_05_18_ParaboloidEqua.jpg" /><br />
<img src="./PhysicallyBasedRendering/00_03_paraboloids_equation.jpg" alt="00_03_paraboloids_equation.jpg" /><br />
</p>
<ul class="org-ul">
<li>旋转抛物面方程怎么写？ <a href="https://www.zhihu.com/question/387696812">https://www.zhihu.com/question/387696812</a><br /></li>
<li>椭圆抛物面和双曲抛物面的方程怎么推导出来的？ <a href="https://www.zhihu.com/question/312954498/answer/1091698001">https://www.zhihu.com/question/312954498/answer/1091698001</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7b9a25f" class="outline-5">
<h5 id="org7b9a25f">Hyperboloid</h5>
<div class="outline-text-5" id="text-org7b9a25f">

<div id="org0f93726" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_18_HyperBoloidEqua.jpg" alt="20_05_18_HyperBoloidEqua.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4bc851e" class="outline-5">
<h5 id="org4bc851e">Triangle Meshes</h5>
<div class="outline-text-5" id="text-org4bc851e">
<p>
对于简单多面体 V-E+F=2<br />
对于任意多面体 f(p)=V-E+F<br />
V=vertex, E=edge, F=face<br />
</p>

<p>
由三角形构成的物体 E=F*3/2 （由三角形构成的物体，其每个边都属于两个面，而其一共有 F 个面，所以这样的边一共有 3F 个，又每个边属于两个面，所以每个面多计算一次，所以最终的边数量为 F*3/2）<br />
</p>

<ul class="org-ul">
<li>多面体欧拉定理 <a href="https://baike.baidu.com/item/%E5%A4%9A%E9%9D%A2%E4%BD%93%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">https://baike.baidu.com/item/%E5%A4%9A%E9%9D%A2%E4%BD%93%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86</a><br /></li>
<li>简单多面体 <a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%A4%9A%E9%9D%A2%E4%BD%93">https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%A4%9A%E9%9D%A2%E4%BD%93</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd94dd33" class="outline-5">
<h5 id="orgd94dd33">Triangle</h5>
<div class="outline-text-5" id="text-orgd94dd33">
<p>
<img src="./PhysicallyBasedRendering/20_05_21_EdgeFunction.jpg" alt="20_05_21_EdgeFunction.jpg" /><br />
e(p) 边函数给出了 p0,p1 和给定点 p 围成的三角形的面积，其利用了向量的叉乘。上面图中边函数 e(p)为 2 维向量的叉乘的结果。<br />
<img src="./PhysicallyBasedRendering/00_03_06_2dimension_vector_cross.jpg" alt="00_03_06_2dimension_vector_cross.jpg" /><br />
下面文件展示了 e(p)和 面积的关系：<br />
<a href="./PhysicallyBasedRendering/20_05_19_edge_equ.ggb">./PhysicallyBasedRendering/20_05_19_edge_equ.ggb</a><br />
</p>

<ul class="org-ul">
<li>点积和叉乘的出现背景是什么？ <a href="https://www.zhihu.com/question/349692615">https://www.zhihu.com/question/349692615</a><br /></li>
<li>二维向量叉乘公式 <a href="https://zhidao.baidu.com/question/679880157161377532.html">https://zhidao.baidu.com/question/679880157161377532.html</a><br /></li>
</ul>


<div id="org383ee13" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_19_TriangleEqua.jpg" alt="20_05_19_TriangleEqua.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>矩阵求逆 <a href="https://www.mathsisfun.com/algebra/matrix-inverse.html">https://www.mathsisfun.com/algebra/matrix-inverse.html</a><br /></li>
<li>判断点是否在三角形内 <a href="https://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html">https://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html</a><br /></li>
<li>重心坐标系 <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates">https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates</a><br /></li>
</ul>

<p>
<a id="org82d8bec"></a><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">Triangle</span>::Area() <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Get triangle vertices in p0, p1, and p2</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5 * Cross(p1 - p0, p2 - p0).Length();
}
</pre>
</div>

<ul class="org-ul">
<li>已知三顶点坐标求面积 <a href="../theory/ComputerGraphicMath.html#orge148fa3">../theory/ComputerGraphicMath.html#orge148fa3</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4f1ee20" class="outline-5">
<h5 id="org4f1ee20">Curve</h5>
<div class="outline-text-5" id="text-org4f1ee20">
</div>
<div id="outline-container-org0750dce" class="outline-6">
<h6 id="org0750dce">Curve 的表示</h6>
<div class="outline-text-6" id="text-org0750dce">
<p>
n 阶的贝塞尔曲线，是两个 n-1 阶贝塞尔曲线之间的插值<br />
</p>

<p>
下图演示了从一阶 Bezier 曲线导出二阶 Bezier 曲线:<br />
<img src="./PhysicallyBasedRendering/20_05_19_BezierEqua.jpg" alt="20_05_19_BezierEqua.jpg" /><br />
<a href="./PhysicallyBasedRendering/00_03_bezier_curve.ggb">./PhysicallyBasedRendering/00_03_bezier_curve.ggb</a><br />
</p>

<p>
将一条 BezierCurve 分为多段，可以通过 Blossoming 来确定每一段 BezierCurve 的控制点<br />
<img src="./PhysicallyBasedRendering/00_03_bezier_blossoms.jpg" alt="00_03_bezier_blossoms.jpg" /><br />
<img src="./PhysicallyBasedRendering/20_05_21_BezierBlossom.jpg" alt="20_05_21_BezierBlossom.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">p[4] &#20026;BezierCurve&#30340;4&#20010;&#25511;&#21046;&#28857;</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #bc6ec5; font-weight: bold;">BlossomBezier</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">p</span>[4], <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">u0</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">u1</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">u2</span>) 
{
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">a</span>[3] = {Lerp(u0, p[0], p[1]), Lerp(u0, p[1], p[2]),
                    Lerp(u0, p[2], p[3])};
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">b</span>[2] = {Lerp(u1, a[0], a[1]), Lerp(u1, a[1], a[2])};
    <span style="color: #4f97d7; font-weight: bold;">return</span> Lerp(u2, b[0], b[1]);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#27714;&#20986;&#20102;&#24403;&#21069;&#23376;&#27573;Curve&#23545;&#24212;&#30340;&#25511;&#21046;&#28857; TODO Why?</span>
<span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">cpObj</span>[4];
<span style="color: #ce537a; font-weight: bold;">cpObj</span>[0] = BlossomBezier(common-&gt;cpObj, uMin, uMin, uMin);
<span style="color: #ce537a; font-weight: bold;">cpObj</span>[1] = BlossomBezier(common-&gt;cpObj, uMin, uMin, uMax);
<span style="color: #ce537a; font-weight: bold;">cpObj</span>[2] = BlossomBezier(common-&gt;cpObj, uMin, uMax, uMax);
<span style="color: #ce537a; font-weight: bold;">cpObj</span>[3] = BlossomBezier(common-&gt;cpObj, uMax, uMax, uMax);
</pre>
</div>

<ul class="org-ul">
<li>贝塞尔曲线 <a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A">https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A</a><br /></li>
<li>Bezier Blossoms <a href="https://courses.engr.illinois.edu/cs418/fa2018/slides/10-5%20Bezier%20Blossoms.pdf">https://courses.engr.illinois.edu/cs418/fa2018/slides/10-5%20Bezier%20Blossoms.pdf</a><br /></li>
<li>Blossom <a href="https://en.wikipedia.org/wiki/Blossom_(functional)">https://en.wikipedia.org/wiki/Blossom_(functional)</a><br /></li>
<li>A Primer on Bézier Curves <a href="https://pomax.github.io/bezierinfo/">https://pomax.github.io/bezierinfo/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga04f8e3" class="outline-6">
<h6 id="orga04f8e3">Curve Intersect</h6>
<div class="outline-text-6" id="text-orga04f8e3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Curve &#26102;&#20250;&#30452;&#25509;&#23558; Curve &#20998;&#25104;&#22810;&#27573;&#65292;&#21508;&#27573; Curve &#20844;&#20849;&#30340;&#20449;&#24687;&#20250;&#23384;&#20648;&#22312; CurveCommon &#31867;&#20013;&#65292;&#27599;&#20010;&#20998;&#27573;&#30340;&#20449;&#24687;&#23384;&#20648;&#22312; Curve &#31867;&#20013;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#24320;&#22987;&#25551;&#36848; &#27599;&#20010;&#20998;&#27573; Curve &#30340; Intersect</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807; BlossomBezier &#26041;&#27861;&#21487;&#20197;&#27714;&#20986;&#24403;&#21069; Curve &#31867;&#23545;&#24212;&#30340;&#25511;&#21046;&#28857;&#25968;&#25454;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#25511;&#21046;&#28857;&#25968;&#25454;&#36716;&#25442;&#21040;&#27714;&#20132;&#22352;&#26631;&#31995;&#19979; (Ray.dir &#20026;&#22352;&#26631;&#31995; zAxis&#65292;&#25511;&#21046;&#28857; p3-p0 &#20026;&#22352;&#26631;&#31995; yAxis&#65292;Ray &#21644; Curve &#30340;&#20132;&#28857;&#22352;&#26631;&#20026;(0,0))</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#21518;&#32493;&#36882;&#24402;&#27714;&#20132;&#28857;&#30340;&#28145;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Ray &#21644;&#24403;&#21069; Curve &#27573;&#30340; BoundingBox&#65292;&#22914;&#26524; BoundingBox &#19981;&#37325;&#21472;&#65292;&#21017;&#35828;&#26126; Ray &#21644;&#24403;&#21069; Curve &#27573;&#27809;&#20132;&#28857;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#24403;&#21069; Curve &#27573;&#32487;&#32493;&#20174;&#20013;&#38388;&#20998;&#20026;&#20004;&#27573;&#23376; Curve&#65292;&#20998;&#21035;&#23545;&#23376; Curve &#27573;&#27714;&#19982; Ray &#30340;&#20132;&#28857;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#24320;&#22987;&#25551;&#36848; &#23376; Curve &#27573;&#30340; Intersect</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#23376; Curve &#27573;&#36827;&#34892;&#27714;&#23548;&#21487;&#20197;&#24471;&#20986;&#23376; Curve &#27573;&#30340;&#23548;&#25968;&#20989;&#25968;&#65292;&#21033;&#29992;&#23548;&#25968;&#20989;&#25968;&#27714;&#20986; p0 &#21644; p3 &#28857;&#30340;&#20999;&#32447;&#65292;&#20877;&#21033;&#29992;&#20999;&#32447;&#27714;&#20986; p0 &#21644; p3 &#28857;&#22402;&#30452;&#19982;&#20999;&#32447;&#30340;&#21521;&#37327;&#65292;&#21017;&#24471;&#21040;&#23376; Curve &#27573;&#20004;&#31471;&#28857;&#22788;&#30340;&#22402;&#30452;&#21521;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20197;&#22402;&#30452;&#21521;&#37327;&#20026;&#36793;&#65292;&#21028;&#26029;&#20132;&#28857;(0,0)&#26159;&#21542;&#22312;&#22402;&#30452;&#21521;&#37327;&#27491;&#30830;&#30340;&#19968;&#20391;&#65292;&#22914;&#26524;&#19981;&#22312;&#65292;&#35828;&#26126;&#27809;&#26377;&#20132;&#28857;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#20132;&#28857;(0,0)&#25237;&#24433;&#21040; p0p3 &#30452;&#32447;&#19978;&#65292;&#36817;&#20284;&#27714;&#20986;&#20132;&#28857;&#22312;&#23376; Curve &#27573;&#19978;&#30340; u &#20540;&#65292;&#20195;&#30721;&#20013;&#35760;&#20316; w</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807; w &#21487;&#20197;&#35745;&#31639;&#20986;&#20132;&#28857;(0,0)&#22312;&#25972;&#27573; Curve &#19978;&#30340; u &#20540;&#65292;&#20195;&#30721;&#20013;&#35760;&#20316; u&#65292;&#20351;&#29992; u &#21487;&#20197;&#35745;&#31639;&#20986;&#20132;&#28857;&#22788; Curve &#30340;&#23485;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524; CurveType &#20026; Ribbon&#65292;&#38656;&#35201;&#23558; Curve &#30340;&#23485;&#24230;&#36827;&#34892; Slerp&#65292;&#26368;&#32456;&#23558;&#20132;&#28857;&#22788; Curve &#30340;&#23485;&#24230;&#35760;&#20316; hitWidth</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">// &#27979;&#35797;&#20132;&#28857;&#21644; Curve &#30340;&#23485;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#20986;&#23376; Curve &#27573;&#19978; w &#22788;&#30340;&#22352;&#26631;&#20540;&#65292;&#35813;&#28857;&#36817;&#20284;&#20026;&#20132;&#28857;&#22312;&#23376; Curve &#27573;&#19978;&#30340;&#25237;&#24433;&#28857;&#65292;&#20195;&#30721;&#20013;&#35760;&#20316; pc&#65292;&#21516;&#26102;&#27714;&#24471; pc &#28857;&#22788;&#30340;&#20999;&#32447;&#65292;&#20195;&#30721;&#20013;&#35760;&#20316; dpcdw</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#25237;&#24433;&#28857;&#21040;&#20132;&#28857;(0,0)&#30340;&#36317;&#31163;&#65292;&#22914;&#26524;&#36317;&#31163;&#22823;&#20110; hitWidth/2&#65292;&#35828;&#26126;&#20132;&#28857;&#19981;&#22312;&#23376; Curve &#27573;&#30340;&#26354;&#38754;&#19978;&#65292;&#22914;&#26524;&#25237;&#24433;&#28857; pc.z&lt;0 || pc.z&gt;zMax &#20063;&#35828;&#26126;&#20132;&#28857;&#19981;&#22312;&#23376; Curve &#27573;&#30340;&#26354;&#38754;&#19978;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">// &#35745;&#31639;&#20132;&#28857;&#30340; v &#20540;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20197; pc &#21644; dpcdw &#20026;&#36793;&#65292;&#21028;&#26029;&#20132;&#28857;(0,0)&#22312;&#36793;&#30340;&#21738;&#19968;&#20391;&#65292;&#20174;&#32780;&#27714;&#20986;&#23545;&#24212;&#30340; v &#20540;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">// &#35745;&#31639; t &#20197;&#21450;&#20132;&#28857;&#22788;&#30340;&#23548;&#25968;</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgc6c76ab"></a>Q&amp;A 为什么 Triangle 的 Intersect 中没有使用 LookAt 来做变换，而 Curve 的 Intersect 要这样做？<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge84ad56" class="outline-5">
<h5 id="orge84ad56">Subdivision Surfaces</h5>
<div class="outline-text-5" id="text-orge84ad56">
</div>
<div id="outline-container-org6d2ab27" class="outline-6">
<h6 id="org6d2ab27">Subdivision 的优点</h6>
<div class="outline-text-6" id="text-org6d2ab27">
<ul class="org-ul">
<li>Subdivision Surface 比多边形 Mesh 要平滑<br /></li>
<li>大多数现存的基础设施建模系统可以被重定向为 Subdivision，经典的多边形建模工具可用于构建 Subdivision 控制模型<br /></li>
<li>Subdivision 方法通常是基于样条的表面表示的一般化。<br /></li>
<li>通过在局部增加控制表面就可以很容易地为局部区域增加细节，这对于样条表现形式则比较困难<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4518397" class="outline-6">
<h6 id="org4518397">Mesh 的表示</h6>
<div class="outline-text-6" id="text-org4518397">
<p>
SDFace 表示 subdivision mesh 的三角面<br />
SDVertex 表示 subdivision mesh 的顶点<br />
</p>

<p>
subdivision mesh 可以是封闭的 mesh 也可以是开放的 mesh<br />
</p>
<ul class="org-ul">
<li>封闭的 mesh 没有边界，所有的面在每个边上都有邻接面，即每个面都有 3 个邻接面<br /></li>
<li>开放的 mesh 有边界<br /></li>
</ul>

<p>
在 mesh 内部的，大部分顶点有 6 个邻接面，有 6 个邻接顶点<br />
在开放 mesh 的边界上，大多数顶点有 3 个邻接面，有 4 个邻接顶点<br />
</p>

<p>
顶点的邻接顶点数量被称为该顶点的 valence<br />
valence 值大于 6 的内部顶点，和 valence 值大于 4 的边界顶点被称为 Extraordinary Vertices；否则为 Regular Vertices.<br />
</p>

<p>
Loop Subdivision 表面在所有地方都是平滑的，除了在 Extraordinary Vertices 处。<br />
</p>

<p>
原来在 Mesh 中已经存在的点被称为 Even Vertices（SDVertex.child 指向的 vertex），分割边的新的顶点被称为 Odd Vertices(SDFace.children[].v[]数组中的某个 vertex);<br />
</p>

<p>
下图表示了 SDFace 中顶点和邻接面数据的拓扑结构<br />
<img src="./PhysicallyBasedRendering/20_05_21_SDFace_Struct.jpg" alt="20_05_21_SDFace_Struct.jpg" /><br />
</p>

<p>
下图表示了判断顶点是否在边界上<br />
<img src="./PhysicallyBasedRendering/20_05_21_CheckBoundaryVertex.jpg" alt="20_05_21_CheckBoundaryVertex.jpg" /><br />
</p>

<p>
对控制 Mesh 进行 Subdivision 后，每个 SDVertex 有一个 children SDVertex，每个 SDFace 有 4 个 children SDFace<br />
<img src="./PhysicallyBasedRendering/20_05_22_SubdivisionSingleTriangle.jpg" alt="20_05_22_SubdivisionSingleTriangle.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org3a2c450" class="outline-6">
<h6 id="org3a2c450">计算顶点的 valence 值</h6>
<div class="outline-text-6" id="text-org3a2c450">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#39030;&#28857;&#30340;valence&#20540;</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">SDVertex</span>::valence() {
    <span style="color: #ce537a; font-weight: bold;">SDFace</span> *<span style="color: #7590db;">f</span> = startFace;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>boundary) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute valence of interior vertex</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nf</span> = 1;
        <span style="color: #4f97d7; font-weight: bold;">while</span> ((f = f-&gt;nextFace(this)) != startFace) ++nf;
        <span style="color: #4f97d7; font-weight: bold;">return</span> nf;
    } <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute valence of boundary vertex</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nf</span> = 1;
        <span style="color: #4f97d7; font-weight: bold;">while</span> ((f = f-&gt;nextFace(this)) != nullptr) ++nf;
        f = startFace;
        <span style="color: #4f97d7; font-weight: bold;">while</span> ((f = f-&gt;prevFace(this)) != nullptr) ++nf;
        <span style="color: #4f97d7; font-weight: bold;">return</span> nf + 1;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d7fe44" class="outline-6">
<h6 id="org4d7fe44">计算顶点周围一圈的顶点</h6>
<div class="outline-text-6" id="text-org4d7fe44">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">SDVertex</span>::oneRing(<span style="color: #ce537a; font-weight: bold;">Point3f</span> *<span style="color: #7590db;">p</span>) {
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>boundary) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Get one-ring vertices for interior vertex</span>
        <span style="color: #ce537a; font-weight: bold;">SDFace</span> *<span style="color: #7590db;">face</span> = startFace;
        <span style="color: #4f97d7; font-weight: bold;">do</span> {
            *p++ = face-&gt;nextVert(this)-&gt;p;
            face = face-&gt;nextFace(this);
        } <span style="color: #4f97d7; font-weight: bold;">while</span> (face != startFace);
    } <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Get one-ring vertices for boundary vertex</span>
        <span style="color: #ce537a; font-weight: bold;">SDFace</span> *<span style="color: #7590db;">face</span> = startFace, *<span style="color: #7590db;">f2</span>;
        <span style="color: #4f97d7; font-weight: bold;">while</span> ((f2 = face-&gt;nextFace(this)) != nullptr) face = f2;
        *p++ = face-&gt;nextVert(this)-&gt;p;
        <span style="color: #4f97d7; font-weight: bold;">do</span> {
            *p++ = face-&gt;prevVert(this)-&gt;p;
            face = face-&gt;prevFace(this);
        } <span style="color: #4f97d7; font-weight: bold;">while</span> (face != nullptr);
    }
}
</pre>
</div>

<p>
下图展示了计算非边界顶点周围一圈顶点的过程：<br />
<img src="./PhysicallyBasedRendering/20_05_21_OneRingVertexArr.jpg" alt="20_05_21_OneRingVertexArr.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org309585b" class="outline-6">
<h6 id="org309585b">计算顶点新的坐标</h6>
<div class="outline-text-6" id="text-org309585b">
<p>
<img src="./PhysicallyBasedRendering/00_03_08_02_calc_new_pos.jpg" alt="00_03_08_02_calc_new_pos.jpg" /><br />
<img src="./PhysicallyBasedRendering/20_05_22_EvenVerticesNewPos.jpg" alt="20_05_22_EvenVerticesNewPos.jpg" /><br />
<img src="./PhysicallyBasedRendering/20_05_22_OddVerticesNewPos.jpg" alt="20_05_22_OddVerticesNewPos.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd9f431b" class="outline-6">
<h6 id="orgd9f431b">计算顶点的 Normal</h6>
<div class="outline-text-6" id="text-orgd9f431b">

<div id="org26c1c1b" class="figure">
<p><img src="./PhysicallyBasedRendering/20_05_22_CalcNewVertexNormal.jpg" alt="20_05_22_CalcNewVertexNormal.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf1d93a5" class="outline-5">
<h5 id="orgf1d93a5">Managing Rounding Error</h5>
<div class="outline-text-5" id="text-orgf1d93a5">
</div>
<div id="outline-container-org40970a3" class="outline-6">
<h6 id="org40970a3">浮点数的算术</h6>
<div class="outline-text-6" id="text-org40970a3">
<p>
无法在有限的内存中表示无限的实数。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9368409"></a>定点数<br />
<div class="outline-text-7" id="text-org9368409">
<p>
一种有限表示实数的方法是使用定点数。以 16 位整型表示实数 [0, 65535/256] = [0, 255+255/256]，这种表示的精度为 1/256<br />
定点数可以使用整数算术运算高效实现，但是，其可以表示的最大数是有限的，而且不能精确地表示接近零的很小的数<br />
</p>
</div>
</li>

<li><a id="org90e1e7a"></a>浮点数<br />
<div class="outline-text-7" id="text-org90e1e7a">
<p>
浮点数表示法，使用一个符号（sign），一个尾数（significand），以及一个指数（exponent）。这种表示法和科学计数相似，但是有效位数和指数是固定的数字。<br />
IEEE 标准规定，32 位浮点数通过一位符号位，8位指数，23 位尾数<br />
</p>

<p>
具体可以参考 <a href="../theory/ComputerSystem.html#orgec35070">../theory/ComputerSystem.html#orgec35070</a><br />
</p>
</div>

<ul class="org-ul">
<li><a id="org8efeaf2"></a>将 Float 转化为 UInt32<br />
<div class="outline-text-8" id="text-org8efeaf2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#27861;1 &#29616;&#20195;&#29256;&#26412;&#30340;c++&#24050;&#32463;&#31105;&#27490;&#20102;&#36825;&#31181;&#26041;&#24335;&#65292;&#20026;&#20102;&#35753;&#32534;&#35793;&#22120;&#21487;&#20197;&#26356;&#31215;&#26497;&#22320;&#23545;&#20195;&#30721;&#36827;&#34892;&#20248;&#21270;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span> = ...;
<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">bits</span> = *((<span style="color: #ce537a; font-weight: bold;">uint32_t</span> *)&amp;f);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#27861;2 &#29616;&#20195;&#29256;&#26412;&#30340;c++&#35268;&#23450;&#65292;&#20174;union&#35835;&#21462;&#30340;&#20803;&#32032;&#21644;&#19978;&#19968;&#27425;&#36171;&#20540;&#30340;&#20803;&#32032;&#19981;&#21516;&#20026;&#26410;&#23450;&#20041;&#34892;&#20026;</span>
<span style="color: #4f97d7; font-weight: bold;">union</span> <span style="color: #ce537a; font-weight: bold;">FloatBits</span>
{
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span>;
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">ui</span>;
}

<span style="color: #ce537a; font-weight: bold;">FloatBits</span> <span style="color: #7590db;">fb</span>;
fb.f = ...;
<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">bits</span> = fb.ui;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#27861;3</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #bc6ec5; font-weight: bold;">FloatToBits</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span>) 
{
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">ui</span>;
    memcpy(&amp;ui, &amp;f, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(<span style="color: #ce537a; font-weight: bold;">float</span>));
    <span style="color: #4f97d7; font-weight: bold;">return</span> ui;
}
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">BitsToFloat</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">ui</span>) {
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span>;
    memcpy(&amp;f, &amp;ui, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(uint32_t));
    <span style="color: #4f97d7; font-weight: bold;">return</span> f;
}
</pre>
</div>
</div>
</li>
<li><a id="org6366e5e"></a>Bump Float Value<br />
<div class="outline-text-8" id="text-org6366e5e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28014;&#28857;&#25968;&#20108;&#36827;&#21046;&#34920;&#31034;&#30340;&#36830;&#32493;&#24615;&#25903;&#25345;&#20102;&#19979;&#38754;&#30340;&#36825;&#20123;&#26041;&#27861;</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#19979;&#19968;&#20010;&#27604;&#24403;&#21069;float&#20540;&#22823;&#30340;&#20540;</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">NextFloatUp</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">v</span>) 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Handle infinity and negative zero for _NextFloatUp()_</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (std::isinf(v) &amp;&amp; v &gt; 0.) <span style="color: #4f97d7; font-weight: bold;">return</span> v;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (v == -0.f) v = 0.f;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Advance _v_ to next higher float</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">ui</span> = FloatToBits(v);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (v &gt;= 0)
        ++ui;
    <span style="color: #4f97d7; font-weight: bold;">else</span>
        --ui;
    <span style="color: #4f97d7; font-weight: bold;">return</span> BitsToFloat(ui);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#19979;&#19968;&#20010;&#27604;&#24403;&#21069;float&#23567;&#30340;&#20540;</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">NextFloatDown</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">v</span>) 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Handle infinity and positive zero for _NextFloatDown()_</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (std::isinf(v) &amp;&amp; v &lt; 0.) <span style="color: #4f97d7; font-weight: bold;">return</span> v;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (v == 0.f) v = -0.f;
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">ui</span> = FloatToBits(v);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (v &gt; 0)
        --ui;
    <span style="color: #4f97d7; font-weight: bold;">else</span>
        ++ui;
    <span style="color: #4f97d7; font-weight: bold;">return</span> BitsToFloat(ui);
}
</pre>
</div>
</div>
</li>

<li><a id="orgb8b86b1"></a>Running Error Analysis<br />
<div class="outline-text-8" id="text-orgb8b86b1">
<p>
<a id="orgdc9cc0d"></a><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org6e6d957" class="outline-6">
<h6 id="org6e6d957">保守的 Ray-Bounds 相交计算</h6>
<div class="outline-text-6" id="text-org6e6d957">
<p>
在 Ray-BoundingBox 相交计算中，我们沿着 Ray 方向找到进入 BoundingBox 的交点处的 t<sub>min</sub>，然后找到离开 BoundingBox 的交点处的 t<sub>max</sub>，如果 t<sub>min</sub>&lt;t<sub>max</sub>说明有交点，否则说明无交点。<br />
使用浮点数计算，可能会导致错误，使得相交测试失败。<br />
</p>


<div id="org64b55a8" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_05_25_conservative_intersection.jpg" alt="2020_05_25_conservative_intersection.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org0b638a7" class="outline-6">
<h6 id="org0b638a7">Robust Triangle Intesections</h6>
<div class="outline-text-6" id="text-org0b638a7">
<p>
三角形和射线相交计算中，将三角形转化到求交坐标系下，使用重心坐标判断射线和三角形是否相交，避免了上面计算方式导致的误差。尽管错误可以从三角形转化到求交坐标系时产生，但是该错误不会影响相交测试，因为相同的变换被应用于所有的三角形(这个误差非常小，不会明显影响交点计算的精确性)。<br />
</p>

<p>
该算法的关键在于使用浮点算术运算，edge 函数可以保证有正确的符号。<br />
<img src="./PhysicallyBasedRendering/2020_05_25_robust_triangle_intesections.jpg" alt="2020_05_25_robust_triangle_intesections.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org568e34a" class="outline-6">
<h6 id="org568e34a">Bounding Intersection Point Error</h6>
<div class="outline-text-6" id="text-org568e34a">
<p>
下图分析了按照普通方法求 Ray 和 Shape 交点的误差：<br />
<img src="./PhysicallyBasedRendering/2020_05_25_ray_shape_intersection_001.jpg" alt="2020_05_25_ray_shape_intersection_001.jpg" /><br />
</p>

<p>
下图展示了使用投影法求交点：<br />
<img src="./PhysicallyBasedRendering/2020_05_25_projection_intesections.jpg" alt="2020_05_25_projection_intesections.jpg" /><br />
</p>

<p>
下图展示了三角形和射线交点的求解：<br />
<img src="./PhysicallyBasedRendering/2020_05_25_ray_shape_intersection_002.jpg" alt="2020_05_25_ray_shape_intersection_002.jpg" /><br />
</p>

<p>
下图展示了其他 Shape 交点求解：<br />
<img src="./PhysicallyBasedRendering/2020_05_25_ray_shape_intersection_003.jpg" alt="2020_05_25_ray_shape_intersection_003.jpg" /><br />
</p>

<p>
下图展示了矩阵变换引入的误差：<br />
<img src="./PhysicallyBasedRendering/2020_05_25_ray_shape_intersection_004.jpg" alt="2020_05_25_ray_shape_intersection_004.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org8814d32" class="outline-6">
<h6 id="org8814d32">Robust Spawned Ray Origins</h6>
<div class="outline-text-6" id="text-org8814d32">
<p>
下图展示了 SpawnRay 时，Ray Origin 的计算<br />
<img src="./PhysicallyBasedRendering/2020_05_26_robust_spawned_ray_origins.jpg" alt="2020_05_26_robust_spawned_ray_origins.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> <span style="color: #bc6ec5; font-weight: bold;">Transform</span>::operator()(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;r, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">oError</span>, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">dError</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
      <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">o</span> = (*this)(r.o, oError);
      <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">d</span> = (*this)(r.d, dError);
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tMax</span> = r.tMax;
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">lengthSquared</span> = d.LengthSquared();
      <span style="color: #4f97d7; font-weight: bold;">if</span> (lengthSquared &gt; 0) {
          <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">dt</span> = Dot(Abs(d), *oError) / lengthSquared;
          o += d * dt;
          <span style="color: #2aa1ae; background-color: #292e34;">//        </span><span style="color: #2aa1ae; background-color: #292e34;">tMax -= dt;</span>
      }
      <span style="color: #4f97d7; font-weight: bold;">return</span> Ray(o, d, tMax, r.time, r.medium);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org39211c7" class="outline-6">
<h6 id="org39211c7">Avoiding Intersections Behind Ray Origins</h6>
<div class="outline-text-6" id="text-org39211c7">
<p>
下图展示了 RayBoundingBox 交点计算中，舍入操作没有影响到交点计算精确性：<br />
<img src="./PhysicallyBasedRendering/2020_05_27_avoid_error_intersection_001.jpg" alt="2020_05_27_avoid_error_intersection_001.jpg" /><br />
</p>

<p>
下图展示了 Ray Triangle 计算中，如何避免在 Ray 原点后产生交点：<br />
<img src="./PhysicallyBasedRendering/2020_05_27_avoid_error_intersection_002.jpg" alt="2020_05_27_avoid_error_intersection_002.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd5e670f" class="outline-4">
<h4 id="orgd5e670f">4 Primitives and intersection acceleration</h4>
<div class="outline-text-4" id="text-orgd5e670f">
</div>
<div id="outline-container-orgcc22e55" class="outline-5">
<h5 id="orgcc22e55">Primitive Interface And Geometric Primitives</h5>
<div class="outline-text-5" id="text-orgcc22e55">
<p>
抽象类 Primitive 是几何处理和渲染子系统的桥梁。<br />
Instanceing 的支持是在 TransformedPrimitive 中实现的，其包含 AnimatedTransforms 属性，将 Shape 变换到不同的世界坐标从而实现 Instancing。刚体动画也是这样实现的。<br />
</p>
</div>
</div>
<div id="outline-container-orgcd73ffa" class="outline-5">
<h5 id="orgcd73ffa">Aggregates</h5>
<div class="outline-text-5" id="text-orgcd73ffa">
<p>
概括来说，主要有两种加速射线追踪的方案：空间分割和物体分割。<br />
空间分割将三维空间划分为多个区域(在场景上对轴对齐的 Box 进行迭代)，并且记录在每个区域中有哪些物体与该区域重叠。有些算法中，可以根据区域中几何单元的数量自适应地调整区域大小。当执行射线相交计算时，射线经过的区域会被依次计算，并且只有和这些区域重叠的几何单元会被测试。<br />
物体分割则是渐进地将场景中的物体分割为更小的组成物件。例如：一个房子可以被分为四面墙、一个房顶、一个椅子。当射线和房屋没有交点时，所有的房屋子物体都可以被 culling。当有交点时，才需要进一步测试和子物体的相交。<br />
这两种方案对于解决 Ray 交点计算都很成功，没有理论表明那种方案更好。<br />
KdTreeAccel 基于空间分割方式<br />
BVHAccel 基于物体分割方式<br />
</p>
</div>
</div>
<div id="outline-container-orgc11f2b5" class="outline-5">
<h5 id="orgc11f2b5">Bounding Volume Hierachies</h5>
<div class="outline-text-5" id="text-orgc11f2b5">
<p>
基于物体分割方式有一个属性是，每个物体在树形结构中只出现一次，而基于空间分割的方式，物体可能跨越多个空间区域，所以在树形结构中会出现多次。这个属性决定了，使用 BVH 方式所消耗的内存是有限的。假设一共有 n 个几何单元，则 BVH 树就一共有 n 个叶子节点用来存储所有几何单元，还有 n-1 个内部节点，一共就有 2n-1 个节点。<br />
BVH 树的构建要比 kd-tress 更高效一些。而 kd-trees 则提供了更快一些的交点计算。<br />
BVH 通常要比 kd-trees 更精确一些。<br />
</p>
</div>
<div id="outline-container-org31eaa44" class="outline-6">
<h6 id="org31eaa44">构建 BVH</h6>
<div class="outline-text-6" id="text-org31eaa44">
<p>
下图展示了划分 primitive 时，如何选择划分的方向：<br />
<img src="./PhysicallyBasedRendering/2020_05_27_choosing_partition_primitive_dir.jpg" alt="2020_05_27_choosing_partition_primitive_dir.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org07b0e42" class="outline-6">
<h6 id="org07b0e42">Surface Area Heuristic 消耗模型</h6>
<div class="outline-text-6" id="text-org07b0e42">
<p>
Surface Area Heuristic 提供了有充分依据的消耗模型，可以回答以下这类问题：<br />
</p>
<ol class="org-ol">
<li>将几何单元划分为多少可以得到一个更好的 BVH 用于射线交点测试？<br /></li>
<li>将空间划分为多少子空间可以得到一个更好的加速结构？<br /></li>
</ol>

<p>
射线通过一个区域，执行相交测试需要的消耗为下面公式 1；<br />
另一种情况是一个区域被划分为了两个区域，则相交测试需要的消耗为下面公式 2；<br />
<img src="./PhysicallyBasedRendering/2020_05_27_sah_cost_model.jpg" alt="2020_05_27_sah_cost_model.jpg" /><br />
t<sub>trav</sub> 表示遍历 interior 节点，确定射线经过了哪个子区域所消耗的时间。<br />
pA 和 pB 分别为射线通过 A 区域和 B 区域的概率<br />
Na 和 Nb 分别为 A 区域和 B 区域中的几何单元数量<br />
</p>

<p>
下图为计算射线通过区域的概率的原理：<br />
<img src="./PhysicallyBasedRendering/2020_05_27_calc_probabilities.jpg" alt="2020_05_27_calc_probabilities.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org8febe4b" class="outline-6">
<h6 id="org8febe4b">SAH 划分</h6>
<div class="outline-text-6" id="text-org8febe4b">
<p>
不是考虑所有可能的划分方法，然后计算每种划分的消耗，最后选择消耗最少的划分。这样的方式消耗太大了。<br />
沿划分的轴，将整个区域划分为多个等距的桶，只需要考虑在桶边界上的划分。这种方式更加高效，而且依然可以获得有效的划分。下图展示了这种方式：<br />
<img src="./PhysicallyBasedRendering/2020_05_27_sah_splitting.jpg" alt="2020_05_27_sah_splitting.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8fc6b69" class="outline-6">
<h6 id="org8fc6b69">Linear Bounding Volume Hierachies</h6>
<div class="outline-text-6" id="text-org8fc6b69">
<p>
在构建 Bounding Volume Hierachies 时使用 Surface Area Heuristic 方法可以给出很好的结果，但是，这种方式有两个缺点：<br />
</p>
<ol class="org-ol">
<li>在树的每一层都需要对 SAH 消耗进行计算。<br /></li>
<li>从上至下的构建 BVH 对于并行非常不友好。最明显的并行方案(并行构建子树)受制于只有上一级树构建完成后才能构建下一级。<br /></li>
</ol>

<p>
LBVH 就是用来解决以上问题的。<br />
LBVH 背后关键的理念是将 BVH 构建转化为排序问题。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0025921"></a>Morton Codes<br />
<div class="outline-text-7" id="text-org0025921">
<p>
Morton Codes 基于一个简单的变换：给定一个 n 维的整数坐标值，它的 Morton-coded 表示坐标的二进制位交叉.<br />
例如：<br />
一个 2D 的坐标(x,y) x、y 的各个位用 xi 和 yi 来表示，则其 Morton-coded 值为 &#x2026;y3x3 y2x2 y1x1 y0x0<br />
对于一个 3D 的坐标(x,y,z)，其 Morton-Coded 值为 &#x2026;z3y3x3 z2y2x2 z1y1x1 z0y0x0<br />
</p>

<p>
将一个 3D 坐标转化为 Morton Codes:<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #bc6ec5; font-weight: bold;">EncodeMorton3</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;v) 
{
    Assert(v.x &gt;= 0 &amp;&amp; v.x &lt;= (1 &lt;&lt; 10));
    Assert(v.y &gt;= 0 &amp;&amp; v.y &lt;= (1 &lt;&lt; 10));
    Assert(v.z &gt;= 0 &amp;&amp; v.z &lt;= (1 &lt;&lt; 10));
    <span style="color: #4f97d7; font-weight: bold;">return</span> (LeftShift3(v.z) &lt;&lt; 2) | (LeftShift3(v.y) &lt;&lt; 1) | LeftShift3(v.x);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#26041;&#27861;&#23558;&#27599;&#20010;&#20301;&#30340;&#31227;&#20301;&#20559;&#31227;&#37327;&#20998;&#35299;&#20026;2&#30340;&#24130;&#27425;&#21644;&#65292;&#23558;&#31227;&#20301;&#25805;&#20316;&#20174;9&#20943;&#23569;&#21040;&#20102;4</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #bc6ec5; font-weight: bold;">LeftShift3</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">x</span>) 
{
    Assert(x &lt;= (1 &lt;&lt; 10));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (x == (1 &lt;&lt; 10)) --x;
    x = (x | (x &lt;&lt; 16)) &amp; 0b00000011000000000000000011111111;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = ---- --98 ---- ---- ---- ---- 7654 3210</span>
    x = (x | (x &lt;&lt; 8)) &amp; 0b00000011000000001111000000001111;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = ---- --98 ---- ---- 7654 ---- ---- 3210</span>
    x = (x | (x &lt;&lt; 4)) &amp; 0b00000011000011000011000011000011;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = ---- --98 ---- 76-- --54 ---- 32-- --10</span>
    x = (x | (x &lt;&lt; 2)) &amp; 0b00001001001001001001001001001001;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> x;
}
</pre>
</div>
<p>
下图展示了 LeftShift3 的原理：<br />
<img src="./PhysicallyBasedRendering/2020_05_28_encode_morton.jpg" alt="2020_05_28_encode_morton.jpg" /><br />
</p>

<p>
RadixSort 可以参考 ../algorithm/AlgorithmIntroduce.org 文档中描述。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Z-order_curve">https://en.wikipedia.org/wiki/Z-order_curve</a><br /></li>
<li><a href="https://onlinemathtools.com/generate-z-order-curve">https://onlinemathtools.com/generate-z-order-curve</a><br /></li>
<li><a href="https://cg2010studio.com/2011/12/06/%E6%91%A9%E9%A0%93%E7%A2%BC-morton-code/">https://cg2010studio.com/2011/12/06/%E6%91%A9%E9%A0%93%E7%A2%BC-morton-code/</a><br /></li>
</ul>
</div>
</li>
<li><a id="org517dce7"></a>Compact BVH For Traversal<br />
<div class="outline-text-7" id="text-org517dce7">
<p>
将 tree 转化为紧密的表示形式（如数组）可以优化 cache、memory 可以整体提高性能。<br />
最终的 BVH 会由树形结构转化为数组，数组中元素按照深度优先排列。<br />
<img src="./PhysicallyBasedRendering/2020_05_29_bvh_tree_to_arr.jpg" alt="2020_05_29_bvh_tree_to_arr.jpg" /><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdbdbe03" class="outline-6">
<h6 id="orgdbdbe03">参考资料</h6>
<div class="outline-text-6" id="text-orgdbdbe03">
<ul class="org-ul">
<li>Introduction to Acceleration Structure <a href="https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/introduction">https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/introduction</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfa601c7" class="outline-5">
<h5 id="orgfa601c7">KD-TREE Accelerator</h5>
<div class="outline-text-5" id="text-orgfa601c7">
<p>
Binary space partitioning(BSP) trees 可以自适应地使用平面将空间分割开。BSP tree 首先使用一个包围盒包含整个场景，如果包围盒中的几何体数量大于某个阙值，使用一个平面将这个包围盒分成两半形成两个新的包围盒。处于分界线上的几何体同时属于两个包围盒。这个分割操作会递归进行直到最终的树的每个叶子区域都包含足够小数量的的几何体，或者是达到了分割的最大深度。<br />
因为分割平面可以放在包围盒内部的任何地方，而且三维空间的不同部位可以被细化到不同的程度，所以 BSP 可以很容易处理场景中不均匀分布的几何体。<br />
</p>

<p>
kd-tree 简单地限制分割平面必须垂直于其中一个坐标轴，这使得遍历和构建 tree 很高效。<br />
octree 使用垂直与坐标轴的三个平面同时分割包围盒，每一步将包围盒分成 8 个区域。<br />
</p>
</div>
<div id="outline-container-orgef6fc72" class="outline-6">
<h6 id="orgef6fc72">Tree Representation</h6>
<div class="outline-text-6" id="text-orgef6fc72">
<p>
将树的节点所占用内存大小压缩到 8 字节，可以保证 8 个节点刚好可以放到 64 字节的 cache（8 字节的 Node 比 16 字节的 Node 速度提高了 20%）。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">KdAccelNode</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">union</span> {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34920;&#31034;&#20998;&#21106;&#20301;&#32622;</span>
          <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">split</span>;                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interior</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#21482;&#26377;&#19968;&#20010;&#22270;&#20803;&#65292;&#34920;&#31034;&#20960;&#20309;&#20307;&#30340;&#20559;&#31227;</span>
          <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">onePrimitive</span>;            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Leaf</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#30001;&#22810;&#20010;&#22270;&#20803;&#65292;&#34920;&#31034;&#31532;&#19968;&#20010;&#20960;&#20309;&#20307;&#30340;&#20559;&#31227;</span>
          <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">primitiveIndicesOffset</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Leaf</span>
      };

  <span style="color: #a45bad;">private</span>:
      <span style="color: #4f97d7; font-weight: bold;">union</span> {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Leaf     &#31532;&#20004;&#20301;&#20026;11&#34920;&#31034;&#20026;Leaf   &#20854;&#20182;&#20301;&#34920;&#31034;&#20960;&#20309;&#20307;&#25968;&#37327;</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interior &#31532;&#20004;&#20301;&#34920;&#31034;&#20998;&#21106;&#38754;&#25152;&#27839;&#30340;&#36724;  &#20854;&#20182;&#20301;&#34920;&#31034;&#20998;&#21106;&#21518;&#19978;&#38754;&#23376;&#33410;&#28857;&#30340;&#20559;&#31227;</span>
          <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">flags</span>;       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Both</span>
          <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nPrims</span>;      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Leaf</span>
          <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">aboveChild</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interior</span>
      };
  };
</pre>
</div>
</div>
</div>
<div id="outline-container-org5ed1340" class="outline-6">
<h6 id="org5ed1340">Tree Construction</h6>
<div class="outline-text-6" id="text-org5ed1340">
<p>
kd-trees 构建使用的 SAH 和 BVH trees 不同之处在于，前者在选择分割面时，如果该分割面生成的两个区域中，有一个区域是空区域则这种分割更优，因为空区域和射线求交消耗最小。<br />
kd-trees 使用的 SAH 消耗模型如下：<br />
<img src="./PhysicallyBasedRendering/2020_06_04_kd_tree_sah_cost.jpg" alt="2020_06_04_kd_tree_sah_cost.jpg" /><br />
</p>

<p>
kd-trees 将所有几何单元的 BoundingBox 的各个面做为分割面，选出消耗最小的分割面。通过将 BoundingBox 投影到各个轴上，可以方便地进行处理。<br />
对 BoudingBox 在轴上的投影进行大小排序，小于分割面的图元为 below，大于分割面的图元为 above<br />
<img src="./PhysicallyBasedRendering/2020_06_04_kd_tree_split_axis.jpg" alt="2020_06_04_kd_tree_split_axis.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orga6e274e" class="outline-6">
<h6 id="orga6e274e">Tree Traversal</h6>
<div class="outline-text-6" id="text-orga6e274e">
<p>
下图展示了遍历树的操作：<br />
<img src="./PhysicallyBasedRendering/2020_06_04_kd_tree_traversal.jpg" alt="2020_06_04_kd_tree_traversal.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_06_04_kd_tree_traversal_explain_01.jpg" alt="2020_06_04_kd_tree_traversal_explain_01.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_06_04_kd_tree_traversal_explain_02.jpg" alt="2020_06_04_kd_tree_traversal_explain_02.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6b3a932" class="outline-3">
<h3 id="org6b3a932">Part 2 Image Formation Process</h3>
<div class="outline-text-3" id="text-org6b3a932">
</div>
<div id="outline-container-org3b358f5" class="outline-4">
<h4 id="org3b358f5">5 Color and radiometry</h4>
<div class="outline-text-4" id="text-org3b358f5">
</div>
<div id="outline-container-orge31a0e7" class="outline-5">
<h5 id="orge31a0e7">基础知识</h5>
<div class="outline-text-5" id="text-orge31a0e7">
</div>
<div id="outline-container-org879e058" class="outline-6">
<h6 id="org879e058">物理的光和颜色</h6>
<div class="outline-text-6" id="text-org879e058">
<p>
光是电磁辐射<br />
</p>
<ul class="org-ul">
<li>不同颜色的光对应不同的波长<br /></li>
<li>经典电磁学里，光波的能量由振幅确定，与频率或波长无关。在量子力学的情形，单光子的能量由频率或波长确定，而光波是大量光子的集合，所以光波的能量或振幅对应的是光子的数量。<br /></li>
</ul>

<p>
光子能量: E=hc/λ=hf=hv<br />
</p>

<p>
可见光的波长范围为 380nm - 780nm<br />
下图展示了电磁波的波长分布<br />
<img src="./PhysicallyBasedRendering/2020_06_05_light_wavelength.jpg" alt="2020_06_05_light_wavelength.jpg" /><br />
</p>

<p>
energy, flux(power), intensity, irradiance, radiance 这些物理量可以用于描述电磁辐射。<br />
</p>

<p>
SPD(spectral power distribution) 是一个波长函数，用于描述每种波长的光的总量。<br />
Relative SPD 是每种波长的光的总量的相对值。<br />
</p>

<p>
下图展示了常见光源的 SPD：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_normal_light_spd.jpg" alt="2020_06_07_normal_light_spd.jpg" /><br />
</p>

<p>
不同物体反射光的 SPD 不同，如下图展示了黄油、番茄、生菜反射光的 SPD：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_different_obj_spd.jpg" alt="2020_06_07_different_obj_spd.jpg" /><br />
</p>



<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E5%85%89%E8%B0%B1%E5%88%86%E5%B8%83">https://baike.baidu.com/item/%E5%85%89%E8%B0%B1%E5%88%86%E5%B8%83</a><br /></li>
<li>光谱功率分布（spectral power distribution） <a href="http://mycolordoc.com/archives/741">http://mycolordoc.com/archives/741</a><br /></li>
<li>spectral power distribution <a href="https://en.wikipedia.org/wiki/Spectral_power_distribution">https://en.wikipedia.org/wiki/Spectral_power_distribution</a><br /></li>
<li>光的波长和振幅对应光子的什么属性？ <a href="https://www.zhihu.com/question/309647712">https://www.zhihu.com/question/309647712</a><br /></li>
<li>光子能量 <a href="https://baike.baidu.com/item/%E5%85%89%E5%AD%90%E8%83%BD%E9%87%8F">https://baike.baidu.com/item/%E5%85%89%E5%AD%90%E8%83%BD%E9%87%8F</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgea06aae" class="outline-6">
<h6 id="orgea06aae">颜色</h6>
<div class="outline-text-6" id="text-orgea06aae">
</div>
<ul class="org-ul">
<li><a id="orgac3ce05"></a>人眼对波长的响应<br />
<div class="outline-text-7" id="text-orgac3ce05">
<p>
物体没有颜色，颜色是我们所看到的感觉。<br />
人眼有两类光感细胞: 视杆细胞和视锥细胞。在低亮度水平时，只有视杆细胞发挥作用，而在高亮度水平时则是视锥细胞发挥作用，在中间亮度水平时，两者都会同时工作。 视杆细胞只有 1 种，对感知颜色没有贡献。<br />
人眼的视锥细胞可分为三种：L/M/S，这三种细胞对不同波长的光响应不同，才使人类产生各种颜色的感觉。下图展示了三种细胞对不同波长光的相对响应值：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_lms_cell.jpg" alt="2020_06_07_lms_cell.jpg" /><br />
</p>

<p>
人的视觉系统在感知颜色时是有层次的，下图展示了这种层次结构。<br />
<img src="./PhysicallyBasedRendering/2020_06_07_color_sence_layer.jpg" alt="2020_06_07_color_sence_layer.jpg" /><br />
人们对视觉系统的深层次机理还有很多未知的地方，但是对视网膜颜色已经有了深入的理解，视网膜本质上是一个传感器，而光传感器对不同波长的光的敏感度用光谱敏感度函数 f()来描述，这样一个光源造成的响应 R 可以描述为下图，它实际上是光源中各个单色光的响应的加权和。光谱功率分布 SPD 是无限维度的(波长是连续的，400nm 到 401nm 之间就有无限多个)，人类有三种视锥细胞可以对光谱有响应，对应了 SML 三条响应曲线。将 SPD 分别和 SML 响应曲线卷积(将 SPD 投影到 SML 空间)得到 3 个值，这三个值组成一个向量，就是视网膜颜色。<br />
</p>

<p>
<img src="./PhysicallyBasedRendering/2020_06_07_sensor_response_func.jpg" alt="2020_06_07_sensor_response_func.jpg" /><br />
人眼的三种视锥细胞对光的响应为：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_eye_response_func.jpg" alt="2020_06_07_eye_response_func.jpg" /><br />
而这些响应可以用一个具有 3 个元素的向量 c 来描述，它就是我们所说的 视网膜颜色:<br />
<img src="./PhysicallyBasedRendering/2020_06_07_retinal_color.jpg" alt="2020_06_07_retinal_color.jpg" /><br />
不同 SPD 的光，可以得到同样的视网膜颜色。这使得我们测量颜色时有了更多的挑战和困难。比如下面展示了两个不同的光谱功率分布，一个来自生菜，一个来自绿茶，但是在观察者看来都是同样的绿色。<br />
<img src="./PhysicallyBasedRendering/2020_06_07_diff_spd_same_color.jpg" alt="2020_06_07_diff_spd_same_color.jpg" /><br />
我们可以认为视网膜颜色空间是一个 3 维的颜色空间，我们称之为 LMS 颜色空间。任何一种纯色光在这个 3 维空间中都有对应的坐标，我们可以画出这些坐标，并从不同的角度去观察画出的曲线：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_color_space_01.jpg" alt="2020_06_07_color_space_01.jpg" /><br />
可以观察到这条曲线呈套索状，并位于 3 维空间的第一象限，它的起始点和终点都是原点，并且除了原点之外都与 M 轴无交点。<br />
上面的曲线假设输入的纯色光是单位强度的，那么如果强度有变化呢？此时的曲线的样子是下面这样的，可以看到我们得到的颜色坐标位于一个凸面上。<br />
<img src="./PhysicallyBasedRendering/2020_06_07_color_space_02.jpg" alt="2020_06_07_color_space_02.jpg" /><br />
如果是由多种不同强度不同波长纯色光混合而成的光呢？此时它的颜色坐标则会位于这个凸面包裹的范围之中：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_color_space_03.jpg" alt="2020_06_07_color_space_03.jpg" /><br />
</p>

<ul class="org-ul">
<li>颜色的科学 <a href="https://zhuanlan.zhihu.com/p/80321112">https://zhuanlan.zhihu.com/p/80321112</a><br /></li>
<li>既然紫光的波长最短，为什么用红色和蓝色混合会产生紫色（紫光）？ <a href="https://www.zhihu.com/question/385007670">https://www.zhihu.com/question/385007670</a><br /></li>
<li>颜色知识 1-人类的视觉系统与颜色 <a href="https://zhuanlan.zhihu.com/p/84891237">https://zhuanlan.zhihu.com/p/84891237</a>  Tips: 该节内容大部分来自于该引用<br /></li>
</ul>
</div>
</li>
<li><a id="orgc6efd41"></a>人眼特性<br />
<ul class="org-ul">
<li><a id="org5ae0975"></a>人眼分辨率 人眼像素<br />
<div class="outline-text-8" id="text-org5ae0975">
<p>
人眼一般具有一亿左右的视杆细胞，但是视锥细胞说满了也只有 700 万不到。<br />
人眼成像过程非常复杂，大脑的参与同样至关重要。由于视锥细胞集中在黄斑，也就是视线焦点处。因此，人眼对于视线焦点处的色彩信息掌握最为充分，而对于非焦点区域，就只能靠大脑来“处理”了。而人眼对焦极快，可以快速对焦到你想要看到的地方，因此仿佛可以将看见的景色尽收眼底。<br />
</p>
</div>
</li>

<li><a id="org58a8e97"></a>人眼动态范围<br />
<div class="outline-text-8" id="text-org58a8e97">
<p>
场景的最大亮度与最小亮度的跨度称作动态范围. 通常使用尼特(nits)来度量，1尼特=1 坎特拉/平方米(1nits=1cd/m^2)。<br />
场景里的最大亮度和最小亮度的比就叫做（静态）对比度<br />
</p>

<p>
在白天环境亮度 10，000 特时，人眼大约能分辨的亮度范围为 200～20，000 尼特，低于 200 尼特的亮度同感觉为黑色。而夜间环境为 30 尼特时，可分辨的亮度范围为 1～200 尼特，这时 100 尼特的亮度就引起相当亮的感觉。只有低于 1 尼特的亮度才引起黑色感觉。<br />
人眼感知的亮度与光强成指数关系，而物理学定义的亮度与光强成正比。<br />
</p>


<div id="org339836f" class="figure">
<p><img src="./PhysicallyBasedRendering/22_03_01_dynamic_range-eye.jpg" alt="22_03_01_dynamic_range-eye.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>亮度 <a href="https://baike.baidu.com/item/%E4%BA%AE%E5%BA%A6/645802?fr=aladdin">https://baike.baidu.com/item/%E4%BA%AE%E5%BA%A6/645802?fr=aladdin</a><br /></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range">https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgc4fa625"></a>为什么人眼动态范围很大？<br />
<div class="outline-text-9" id="text-orgc4fa625">
<p>
正是因为人脑视觉系统各级（从最底层的视网膜开始！）对外界光线的加工，才使得我们实际看到的视觉经验中的场景，每个区域最终在视觉上都表现出合适的对比度，尽管场景中最亮和最暗的部分绝对光强的差异远超神经元活动本身的响应范围。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org7757cb2"></a>参考资料<br />
<div class="outline-text-8" id="text-org7757cb2">
<ul class="org-ul">
<li>人的眼睛相当于什么参数的镜头？ <a href="https://www.zhihu.com/question/26507130">https://www.zhihu.com/question/26507130</a><br /></li>
<li>Human eye <a href="https://en.wikipedia.org/wiki/Human_eye">https://en.wikipedia.org/wiki/Human_eye</a><br /></li>
<li>人眼的像素有多高？ <a href="https://www.zhihu.com/question/25111095">https://www.zhihu.com/question/25111095</a><br /></li>
<li>人的眼相当于多少像素的数码相机呢？ <a href="https://www.zhihu.com/question/19968393">https://www.zhihu.com/question/19968393</a><br /></li>
<li>为什么人眼的动态范围 (Dynamic Range) 比相机大得多？ <a href="https://www.zhihu.com/question/21492596/answer/117666373">https://www.zhihu.com/question/21492596/answer/117666373</a><br /></li>
<li>What is the maximum light intensity that a human eye can withstand without being damaged? <a href="https://www.quora.com/What-is-the-maximum-light-intensity-that-a-human-eye-can-withstand-without-being-damaged">https://www.quora.com/What-is-the-maximum-light-intensity-that-a-human-eye-can-withstand-without-being-damaged</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2af9a14"></a>颜色的标准化<br />
<ul class="org-ul">
<li><a id="org8fff160"></a>三原色理论 颜色匹配实验<br />
<div class="outline-text-8" id="text-org8fff160">
<p>
三原色，所谓三原色，就是指这三种色中的任意一色都不能由另外两种原色混合产生，而其它色可由这三色按照一定的比例混合出来，色彩学上将这三个独立的色称为三原色。<br />
</p>

<p>
在颜色匹配实验中，当这三原色光的相对亮度(luminance)比例为 1.0000： 4.5907 ： 0.0601 时就能匹配等能白光，所以 CIE 选取这一比例作为红、绿、蓝三原色的单位量。CIE 通过颜色匹配实验，确定了 CIE-RGB 颜色匹配函数（类比人眼三种视锥细胞对光的响应函数）。<br />
</p>

<ul class="org-ul">
<li>三原色原理 <a href="https://baike.baidu.com/item/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%8E%9F%E7%90%86/6969780">https://baike.baidu.com/item/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%8E%9F%E7%90%86/6969780</a><br /></li>
<li>颜色知识 2-三原色理论与颜色匹配实验 <a href="https://zhuanlan.zhihu.com/p/84897327">https://zhuanlan.zhihu.com/p/84897327</a><br /></li>
<li>1931 CIE 颜色系统 <a href="https://zhuanlan.zhihu.com/p/31374619">https://zhuanlan.zhihu.com/p/31374619</a><br /></li>
<li>CIE 光谱三刺激值 <a href="https://baike.baidu.com/item/CIE%E5%85%89%E8%B0%B1%E4%B8%89%E5%88%BA%E6%BF%80%E5%80%BC/22127070?fr=aladdin">https://baike.baidu.com/item/CIE%E5%85%89%E8%B0%B1%E4%B8%89%E5%88%BA%E6%BF%80%E5%80%BC/22127070?fr=aladdin</a><br /></li>
</ul>
</div>
</li>
<li><a id="org89f9835"></a>颜色模型 颜色空间<br />
<ul class="org-ul">
<li><a id="org6b04871"></a>颜色模型<br />
<div class="outline-text-9" id="text-org6b04871">
<p>
颜色模型: 颜色模型是一种抽象的数学模型，描述了颜色被表示为数字元组的方式，通常颜色可以表示为三个或四个分量。 当此模型与如何解释各个分量的精确意义相关联时，生成的颜色集称为“颜色空间”。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Color_model">https://en.wikipedia.org/wiki/Color_model</a><br /></li>
</ul>

<p>
RGB color model:<br />
RGB 颜色模型是一种基于人类对颜色感知的加色模型。通过对 R、G、B 三种颜色的光束进行叠加可以得到其他颜色，格拉斯曼定律揭示了颜色混合的线性规律。<br />
RGB 颜色模型本身并没有定义红、绿和蓝的含义，因此混合它们的结果不是绝对的，而是相对于原色的。 当定义了红、绿、蓝三原色的准确色度后，颜色模型就变成了一个绝对的颜色空间，例如 sRGB 或 Adobe RGB。<br />
</p>

<p>
格拉斯曼定律揭示了光谱分布转化为 RGB 颜色值的本质，给定任意一个 SPD I(λ), 其对应的 RGB 坐标为:<br />
<img src="./PhysicallyBasedRendering/22_03_04_color-matching-theory.jpg" alt="22_03_04_color-matching-theory.jpg" /><br />
I(λ) 是线性的，r(λ) g(λ) b(λ)是所选三原色对应的颜色匹配函数。<br />
</p>

<p>
CIE 颜色匹配实验就是利用格拉斯曼定律构造 CIE-RGB 颜色空间。<br />
</p>

<ul class="org-ul">
<li>格拉斯曼定律 <a href="https://en.wikipedia.org/wiki/Grassmann%27s_laws_(color_science)">https://en.wikipedia.org/wiki/Grassmann%27s_laws_(color_science)</a><br /></li>
</ul>

<p>
CMYK color model:<br />
CMYK 颜色模型是一种减色颜色模型。<br />
</p>

<p>
Cylindrical-coordinate color model:<br />
存在许多颜色模型，其中颜色适合圆锥形、圆柱形或球形，中性色沿中心轴从黑色到白色，色调对应于周边的角度。如 HSL，HSV 等等<br />
</p>
</div>
</li>

<li><a id="orgabb5ae5"></a>颜色空间<br />
<div class="outline-text-9" id="text-orgabb5ae5">
<p>
颜色空间: 为一个颜色模型定义三原色、白点、传递函数后，就可以确定其所能表示的颜色集合，该集合就是颜色空间。<br />
</p>

<p>
颜色空间通常还会包含 Image State、Viewing Environment、Data Type 等信息：<br />
</p>
<ul class="org-ul">
<li>Image State：它把颜色空间分类成了几种不同的图像状态，最常见的就是 Scene Referred Image 和 Display/Output Referred Image<br /></li>
<li>Viewing Environment：由于人眼的视觉是自适应的，大脑对颜色的理解是依赖当前所处的观察环境的。例如，同样一张白纸在明亮的天光环境和钨丝灯光照下我们都认为它是白色的，但实际上在两种光照环境下它真正反射的光线是不同的。因此，我们需要给颜色空间定义一个它的观察环境，这个观察环境会影响颜色空间的白点值、传递函数等数值。例如 DCI-P3 的白点和伽马一定程度上就是为了适应影院这样较为昏暗的放映条件<br /></li>
<li>Data Type：它指定了这个空间下颜色数据的范围和精度，例如数据是 8-bit、10-bit 还是 16-bit，格式是 integer 还是 floating point<br /></li>

<li><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-color-management/">https://chrisbrejon.com/cg-cinematography/chapter-1-color-management/</a><br /></li>
</ul>

<p>
RGB color space:<br />
RGB color space 是基于 RGB color model 的很多种颜色空间的总称。如：sRGB，Adobe RGB, CIE RGB<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/RGB_color_spaces">https://en.wikipedia.org/wiki/RGB_color_spaces</a><br /></li>
</ul>
</div>
</li>

<li><a id="org092cc5f"></a>CIE-RGB<br />
<div class="outline-text-9" id="text-org092cc5f">
<p>
CIE1931 色匹配实验使用 700 nm 红光，546.1 nm 绿光，435.8 nm 的蓝光，对 380nm 到 780nm 的单色光进行匹配，得到 r(λ) g(λ) b(λ) 三个颜色匹配函数。匹配实验并没有指定三原色光的亮度，三原始光亮度比例是由下面的等式推导出来的：<br />
<img src="./PhysicallyBasedRendering/22_03_04_cie-rgb_integral_condition.jpg" alt="22_03_04_cie-rgb_integral_condition.jpg" /><br />
最终，r:g:b 三原色的 luminance 比例为 1.0000:4.5907:0.0601，radiance 比例为 72.0962:1.3791:1<br />
</p>

<p>
CIE-RGB 线性空间的正交基: 1 单位亮度的 700nm 红光为(1,0,0), 4.5907 单位亮度的 546.1nm 绿光为(0,1,0), 0.0601 单位亮度的 435.8nm 蓝光为(0,0,1)。需要注意的是，CIE-RGB 空间中，部分颜色的坐标为负数。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a><br /></li>
</ul>
</div>
</li>
<li><a id="orga4993e8"></a>CIE-XYZ<br />
<div class="outline-text-9" id="text-orga4993e8">
<p>
为了消除 CIE-RGB 颜色空间中，r分量的负值，开发了 CIE-XYZ 颜色空间。另外还满足如下一些约束：<br />
</p>
<ul class="org-ul">
<li>所有坐标都是正的保持等能点（equal energy point）作为白色<br /></li>
<li>使得新的 Y 坐标能够代表明度，也就是使得新的 Y 坐标等于视觉的明度响应<br /></li>
<li>使得新的 Z 坐标在红光端保持为 0<br /></li>
<li>使得所有色彩尽可能充满新的空间<br /></li>
</ul>

<p>
明度响应曲线是人眼对不同波长光引起明亮感觉的描述。使用等能光谱不同波长的光与标准白光相匹配的实测，可以获得对各个波长的光的相对视亮度函数。根据观察范围和观察者亮度适应水平分为两种：明视觉光亮度函数和暗视觉光亮度函数。<br />
<img src="./PhysicallyBasedRendering/cie-rgb-cie-XYZ.jpg" alt="cie-rgb-cie-XYZ.jpg" /><br />
</p>

<p>
CIE-RGB 到 CIE-XYZ 转化矩阵的构造(从 CIE-RGB 空间构造 CIE-XYZ 空间), 可以参考 wiki 中内容。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/Luminous_efficiency_function">https://en.wikipedia.org/wiki/Luminous_efficiency_function</a><br /></li>
</ul>
</div>
</li>
<li><a id="org5a11646"></a>CIE-xyY<br /></li>
<li><a id="org8e04273"></a>linear RGB 颜色空间<br />
<div class="outline-text-9" id="text-org8e04273">
<p>
linear RGB 这种说法是不准确的，因为 linear RGB 并没有给出三原色和白点，传递函数等信息。<br />
</p>

<p>
一种观点认为，rgb 颜色可以理解为 SPD 的简化，其只包含了三个单色光的量。<br />
另一种观点认为，rgb 颜色是 SPD 投影到 rgb 空间的表示形式。<br />
</p>
</div>
</li>
<li><a id="org92fbbb9"></a>sRGB<br />
<div class="outline-text-9" id="text-org92fbbb9">
<p>
sRGB 颜色空间是惠普和微软制定的被用于网络、Windows、印刷等领域的 RGB 颜色空间标准。其各个属性如下：<br />
三原色和白点:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CIE xy chromaticity</th>
<th scope="col" class="org-right">red</th>
<th scope="col" class="org-right">green</th>
<th scope="col" class="org-right">blue</th>
<th scope="col" class="org-right">whitepoint</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x</td>
<td class="org-right">0.6400</td>
<td class="org-right">0.3000</td>
<td class="org-right">0.1500</td>
<td class="org-right">0.3127</td>
</tr>

<tr>
<td class="org-left">y</td>
<td class="org-right">0.3300</td>
<td class="org-right">0.6000</td>
<td class="org-right">0.0600</td>
<td class="org-right">0.3290</td>
</tr>

<tr>
<td class="org-left">z</td>
<td class="org-right">0.0300</td>
<td class="org-right">0.1000</td>
<td class="org-right">0.7900</td>
<td class="org-right">0.3583</td>
</tr>
</tbody>
</table>

<p>
从 CIE 色度图选择某个颜色空间的三原色和白点，求出该颜色空间和 CIE-XYZ 颜色空间的变换矩阵的方法如下图所示：<br />
<img src="./PhysicallyBasedRendering/2022_02_25_calcXYZColor.jpg" alt="2022_02_25_calcXYZColor.jpg" /><br />
Tips: CIE 色度图选择的三原色、白点的值也是 CIE-XYZ 空间的颜色值，这些值在 X+Y+Z=1 平面上。<br />
</p>

<p>
下面推导了 sRGB 到 CIE-XYZ 的变换矩阵:<br />
</p>
<pre class="example" id="orgdb68815">
0.3290 * sw = 1,
0.6400 * sr + 0.3*sg + 0.15*sb = 0.3127*sw,
0.3300 * sr + 0.6*sg + 0.06*sb = 0.3290*sw,
0.0300 * sr + 0.1*sg + 0.79*sb = 0.3583*sw,

// WolframAlpha 中不支持上面写法，支持下面这种写法
0.3290 * w = 1, 0.6400 * r + 0.3*g + 0.15*b = 0.3127*w, 0.3300 * r + 0.6*g + 0.06*b = 0.3290*w, 0.0300 * r + 0.1*g + 0.79*b = 0.3583*w,

// 解的
sr≈0.644361, sg≈1.19195, sb≈1.20321, sw≈3.03951

// 从而得到Rxyz Gxyz Bxyz
Rxyz = rxyz*sr = (0.6400,0.3300,0.0300) * 0.644361 = {0.412391, 0.212639, 0.0193308}
Gxyz = gxyz*sg = (0.3000,0.6000,0.1000) * 1.19195  = {0.357585, 0.71517, 0.119195}
Bxyz = bxyz*sb = (0.1500,0.0600,0.7900) * 1.20321  = {0.180482, 0.0721926, 0.950536}
Wxyz = wxyz*sw = (0.3127,0.3290,0.3583) * 3.03951  = {0.950455, 0.999999, 1.08906}

// 因此 sRGB 到 CIE-XYZ 的变换矩阵为
0.412391, 0.212639, 0.0193308
0.357585, 0.71517,  0.119195
0.180482, 0.0721926, 0.950536


          0.412391, 0.212639,  0.0193308
(1,0,1)   0.357585, 0.71517,   0.119195   =  (0.412391, 0.212639, 0.0193308)
          0.180482, 0.0721926, 0.950536
</pre>

<p>
传递函数:<br />
Image State:<br />
Viewing Environment: 常规家庭、办公照明环境<br />
Data Type:<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/SRGB">https://en.wikipedia.org/wiki/SRGB</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/RGB_color_spaces">https://en.wikipedia.org/wiki/RGB_color_spaces</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space</a><br /></li>
</ul>
</div>
</li>

<li><a id="orga6e2025"></a>Rec. 2020<br />
<div class="outline-text-9" id="text-orga6e2025">
<p>
三原色和白点:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CIE xy chromaticity</th>
<th scope="col" class="org-right">red</th>
<th scope="col" class="org-right">green</th>
<th scope="col" class="org-right">blue</th>
<th scope="col" class="org-right">whitepoint</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x</td>
<td class="org-right">0.708</td>
<td class="org-right">0.170</td>
<td class="org-right">0.131</td>
<td class="org-right">0.3127</td>
</tr>

<tr>
<td class="org-left">y</td>
<td class="org-right">0.292</td>
<td class="org-right">0.797</td>
<td class="org-right">0.046</td>
<td class="org-right">0.3290</td>
</tr>

<tr>
<td class="org-left">z</td>
<td class="org-right">0.</td>
<td class="org-right">0.033</td>
<td class="org-right">0.823</td>
<td class="org-right">0.3583</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Rec._2020">https://en.wikipedia.org/wiki/Rec._2020</a><br /></li>
</ul>
</div>
</li>

<li><a id="org62187f6"></a>渲染 颜色值 颜色空间<br />
<ul class="org-ul">
<li><a id="org731b163"></a>Radiometry or Photometry<br />
<div class="outline-text-10" id="text-org731b163">
<p>
渲染中选择的单位是 Radiometry 还是 Photometry，这个问题的答案并不统一。<br />
</p>
<ul class="org-ul">
<li>Photometry<br /></li>
</ul>
<p>
Moving Frostbite to PBR 文章描述：Frostbite 引擎中，整个渲染管线使用了 photometry。使用 radiometry，就需要同时提供 luminous efficacy(发光效率)，这增加了艺术家工作的复杂性，因此，最好假设光的波长都为 555nm，此时 1(watt)=683(lumen)。这样可以简单转化 Radiometry 和 Photometry 的单位。现实世界中光源都是按照 Photometry 度量的，所以最终引擎采用了 Photometry 作为单位。<br />
</p>

<ul class="org-ul">
<li>Radiometry<br /></li>
</ul>
<p>
Radiometry Versus Photometry 文章描述：提出如果是渲染单色图片，使用 Radiometry 和 Photometry 都一样，只需要对渲染结果进行简单转化。如果是渲染 RGB 彩色图片， 渲染中应该使用 Radiometry 单位。使用 Radiometry 单位，颜色值(1,1,1)是白色，且对应的 SPD 大致是平坦的。使用 Photometry 单位，颜色值(1,1,1)不是白色，而是一种紫色，绿色范围内的能量较少，而红色和蓝色范围内的能量较多。<br />
</p>

<ul class="org-ul">
<li>Radiometry Versus Photometry <a href="https://www.reedbeta.com/blog/radiometry-versus-photometry/">https://www.reedbeta.com/blog/radiometry-versus-photometry/</a><br /></li>
<li><a href="https://computergraphics.stackexchange.com/questions/8295/luminance-and-radiance-in-computer-screen">https://computergraphics.stackexchange.com/questions/8295/luminance-and-radiance-in-computer-screen</a><br /></li>
<li><a href="https://computergraphics.stackexchange.com/questions/1992/rendering-in-radiometric-units-or-photometric">https://computergraphics.stackexchange.com/questions/1992/rendering-in-radiometric-units-or-photometric</a><br /></li>
</ul>
</div>
</li>
<li><a id="org3c58007"></a>linear and non-linear color space<br />
<div class="outline-text-10" id="text-org3c58007">
<p>
几何光学中，光能量是线性的，光物体交互可以用相加和相乘来模拟。如，两个光源叠加相当于两个光源的 SPD 相加；光源 L(光源的光谱分布为 L)照射物体 O(物体的反射光谱分布为 O)，则物体反射的光为 L*O。<br />
</p>

<p>
使用 RGB 模型表示光谱分布时也是线性的，证明如下图：<br />
<img src="./PhysicallyBasedRendering/22_03_02_xyz_linear_space.jpg" alt="22_03_02_xyz_linear_space.jpg" /><br />
</p>

<p>
在渲染计算中，若所选的颜色空间不是线性的，则无法正确模拟光和物体的交互。例如：若我们选用的颜色空间是二次的(LightEnergy = LightPos^2 光对应的坐标值和能量是二次关系)，考虑指定波长的光其坐标值为 1，对应的能量是 1，坐标值为 2，对应的能量是 4。<br />
</p>
<pre class="example" id="org4f3fc39">
二次空间颜色值 1 + 2 = 3
对应的能量计算 1 + 4 = 5

二次颜色值3 转化为能量后为 9, 这和使用能量计算的结果5不相同。
</pre>
<p>
因此，渲染计算中需要使用线性的颜色空间。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/38857180/what-is-the-difference-between-linear-and-non-linear-color-space-system">https://stackoverflow.com/questions/38857180/what-is-the-difference-between-linear-and-non-linear-color-space-system</a><br /></li>
</ul>
</div>
</li>
<li><a id="org1313122"></a>sRGB BT.2020 ACES2065-1<br />
<div class="outline-text-10" id="text-org1313122">
<p>
本质上来说，sRGB CIE-RGB 或 CIE-XYZ 颜色值都是光谱功率分布和响应函数积分得到的。<br />
sRGB    的三个基向量为 R(1,0,0) G(0,1,0) B(0,0,1) sRGB    是标准正交线性空间<br />
CIE-RGB 的三个基向量为 R(1,0,0) G(0,1,0) B(0,0,1) CIE-RGB 是标准正交线性空间<br />
CIE-XYZ 的三个基向量为 X(1,0,0) Y(0,1,0) Z(0,0,1) CIE-XYZ 是标准正交线性空间<br />
</p>

<p>
虽然， 以上三个颜色空间都是线性空间。但是，由于三原色、白点不同，使用不同的颜色空间渲染得到的结果会有差异。颜色相加不会导致结果不同，但是颜色相乘的结果受到三原色选取影响。<br />
</p>

<p>
前人的研究表明，那些三原色越接近光谱轨迹的色域空间渲染出来的结果往往更接近光谱渲染的正确结果，ACEScg 就是这样一个颜色空间，它的三原色 AP1 在光谱轨迹附近，且包含了 Rec. 2020 等常见的广色域空间，因此它非常适合作为 CG 和 VFX 等计算机渲染的工作空间。<br />
</p>

<ul class="org-ul">
<li><a href="https://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb">https://computergraphics.stackexchange.com/questions/8152/for-shader-math-why-should-linear-rgb-keep-the-gamut-of-srgb</a><br /></li>
<li><a href="https://computergraphics.stackexchange.com/questions/203/are-there-common-materials-that-arent-represented-well-by-rgb">https://computergraphics.stackexchange.com/questions/203/are-there-common-materials-that-arent-represented-well-by-rgb</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>

<li><a id="orgdfbc2ea"></a>参考资料<br />
<div class="outline-text-9" id="text-orgdfbc2ea">
<ul class="org-ul">
<li>Color Model <a href="https://en.wikipedia.org/wiki/Color_model">https://en.wikipedia.org/wiki/Color_model</a><br /></li>
<li>RGB color space <a href="https://en.wikipedia.org/wiki/RGB_color_space">https://en.wikipedia.org/wiki/RGB_color_space</a><br /></li>
<li>线性和非线性的区别是什么？ <a href="https://www.zhihu.com/question/293327883">https://www.zhihu.com/question/293327883</a><br /></li>
<li>格拉斯曼定律 (色彩) <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E6%96%AF%E6%9B%BC%E5%AE%9A%E5%BE%8B_(%E8%89%B2%E5%BD%A9)">https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E6%96%AF%E6%9B%BC%E5%AE%9A%E5%BE%8B_(%E8%89%B2%E5%BD%A9)</a><br /></li>
<li>色彩空间基础 <a href="https://zhuanlan.zhihu.com/p/24214731">https://zhuanlan.zhihu.com/p/24214731</a><br /></li>
<li>色彩空间表示与转换 <a href="https://zhuanlan.zhihu.com/p/24281841">https://zhuanlan.zhihu.com/p/24281841</a><br /></li>
<li>HDR 和色彩管理 1 光、颜色和色度图 <a href="https://zhuanlan.zhihu.com/p/129095380">https://zhuanlan.zhihu.com/p/129095380</a><br /></li>
<li>HDR 和色彩管理 2 颜色空间 <a href="https://zhuanlan.zhihu.com/p/133434457">https://zhuanlan.zhihu.com/p/133434457</a><br /></li>
<li>displaycal <a href="https://displaycal.net/">https://displaycal.net/</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0685081"></a>色域、色温和白平衡<br />
<ul class="org-ul">
<li><a id="org5249630"></a>实时渲染中如果模拟色调适应？<br />
<div class="outline-text-9" id="text-org5249630">
<p>
色调适应是指光照变化后，物体实际反射到人眼的 SPD(光谱能量分布) 也会发生变化，但是，人类的视角系统有一种神奇能力，可以让视网膜得到的颜色和大脑中感知的颜色不同，从而使得不同光照下，同一个物体的感知颜色是相同的。<br />
</p>


<div id="orgf37833a" class="figure">
<p><img src="./PhysicallyBasedRendering/22_02_25_color_constancy.jpg" alt="22_02_25_color_constancy.jpg" /><br />
</p>
</div>

<p>
实时渲染中在后处理中通过白平衡来实现颜色的恒常。白平衡实现中通过调节两个参数:色温和色调，来设置白点的位置，从而得到正确的色彩转换；色温调节蓝-黄偏色，色调调节绿-品红偏色。<br />
</p>
<ol class="org-ol">
<li>将 temperature 和 tint 表示的白点 转化为 CIE xy chromaticity 中的白点 wXYZ(x,y)<br /></li>
<li>将 wXYZ(x,y)转化为 LMS 空间的白点 wLSM<br /></li>
<li>计算 LSM 空间的 D65 白点 wD65LSM<br /></li>
<li>计算 LMS 空间中白平衡变换矩阵如下面注释所示<br /></li>
</ol>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">Converts white balancing parameter to LMS coefficients.</span>
<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">&lt;param name="temperature"&gt;A temperature offset, in range [-100;100].&lt;/param&gt;</span>
<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">&lt;param name="tint"&gt;A tint offset, in range [-100;100].&lt;/param&gt;</span>
<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">&lt;returns&gt;LMS coefficients.&lt;/returns&gt;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> Vector3 ColorBalanceToLMSCoeffs(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">temperature</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">tint</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Range ~[-1.5;1.5] works best</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">t1</span> = temperature / 65f;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">t2</span> = tint / 65f;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Get the CIE xy chromaticity of the reference white point.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Note: 0.31271 = x value on the D65 white point</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">x</span> = 0.31271f - t1 * (t1 &lt; 0f ? 0.1f : 0.05f);
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">y</span> = StandardIlluminantY(x) + t2 * 0.05f;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Calculate the coefficients in the LMS space.</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">w1</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Vector3</span>(0.949237f, 1.03542f, 1.08728f); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LMS space D65 white point</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">w2</span> = CIExyToLMS(x, y);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Vector3</span>(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wD65 wD65LSM   &#20998;&#21035;&#20026; CIE-XYZ &#31354;&#38388;&#21644;LSM &#31354;&#38388;&#20013;, D65 &#20809;&#29031;&#29615;&#22659;&#19979;&#30340;&#30333;&#28857;&#65292;&#20063;&#26159;&#20154;&#31867;&#24863;&#30693;&#30340;&#30333;&#28857;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wXYZ wLSM      &#20998;&#21035;&#20026; CIE-XYZ &#31354;&#38388;&#21644;LSM &#31354;&#38388;&#20013;, &#24403;&#21069;&#30333;&#24179;&#34913;&#21442;&#25968;&#23450;&#20041;&#30340;&#30333;&#28857;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">csRGB cLSM     &#20998;&#21035;&#20026; sRGB-Linear &#31354;&#38388;&#21644;LSM &#31354;&#38388;&#20013;, &#24403;&#21069;&#25805;&#20316;&#30340;&#20687;&#32032;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">csRGBWB cLSMWB &#20998;&#21035;&#20026; sRGB-Linear &#31354;&#38388;&#21644;LSM &#31354;&#38388;&#20013;, &#24403;&#21069;&#25805;&#20316;&#30340;&#20687;&#32032;&#39068;&#33394;&#34987;&#30333;&#24179;&#34913;&#21518;&#30340;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cLSM   = XYZ2LSM * sRGB2XYZ * csRGB </span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">//          </span><span style="color: #2aa1ae; background-color: #292e34;">| wD65LSM.r/wLSM.r  0                   0                |</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cLSMWB = | 0                 wD65LSM.g/wLSM.g    0                | * cLSM</span>
<span style="color: #2aa1ae; background-color: #292e34;">//          </span><span style="color: #2aa1ae; background-color: #292e34;">| 0                 0                   wD65LSM.b/wLSM.b |</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">csRGB  = XYZ2sRGB * LSM2XYZ * cLSMWB</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: Unity&#20351;&#29992;&#30340;XYZ2LSM&#21464;&#25442;&#30697;&#38453;&#26469;&#33258; CIECAM02, &#21442;&#32771;&#19979;&#38754; LMS_color_space &#38142;&#25509;&#20869;&#23481;</span>
</pre>
</div>

<p>
Color appearance model(CAM) 是一种数学模型，旨在描述人类颜色视觉的感知方面，例如，在何种观察调节下，颜色外观与刺激源的相应物理测量不相符。（相比之下，颜色模型定义了一个坐标空间来描述颜色，例如 RGB 和 CMYK 颜色模型。）<br />
因此，Unity 中在进行白平衡时，将颜色转化到 CAM02 颜色模型下。<br />
</p>

<ul class="org-ul">
<li>Color balance <a href="https://en.wikipedia.org/wiki/Color_balance">https://en.wikipedia.org/wiki/Color_balance</a><br /></li>
<li>LMS_color_space <a href="https://en.wikipedia.org/wiki/LMS_color_space#CAT02">https://en.wikipedia.org/wiki/LMS_color_space#CAT02</a><br /></li>
<li>Color appearance model <a href="https://en.wikipedia.org/wiki/Color_appearance_model">https://en.wikipedia.org/wiki/Color_appearance_model</a><br /></li>
<li>CAM02 <a href="https://en.wikipedia.org/wiki/CIECAM02">https://en.wikipedia.org/wiki/CIECAM02</a><br /></li>
<li>白平衡算法 <a href="http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html">http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html</a> 有道云笔记有备份<br /></li>
</ul>
</div>
</li>
<li><a id="org546a465"></a>参考资料<br />
<div class="outline-text-9" id="text-org546a465">
<ul class="org-ul">
<li>颜色知识 3-色域、色温和白平衡 <a href="https://zhuanlan.zhihu.com/p/84954611">https://zhuanlan.zhihu.com/p/84954611</a><br /></li>
<li>色温、白平衡与色彩恒常性 <a href="https://zhuanlan.zhihu.com/p/27165715">https://zhuanlan.zhihu.com/p/27165715</a><br /></li>
<li>色彩恒常性 <a href="https://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E6%81%92%E5%B8%B8%E6%80%A7">https://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E6%81%92%E5%B8%B8%E6%80%A7</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgfc5e133"></a>HDR 和色彩管理<br />
<div class="outline-text-8" id="text-orgfc5e133">
<ul class="org-ul">
<li>human eye <a href="https://en.wikipedia.org/wiki/Human_eye">https://en.wikipedia.org/wiki/Human_eye</a><br /></li>
<li>HDR 和色彩管理 3 SDR 和 HDR <a href="https://zhuanlan.zhihu.com/p/138295496">https://zhuanlan.zhihu.com/p/138295496</a><br /></li>
<li>HDR 和色彩管理 4 HDR 标准和 ACES <a href="https://zhuanlan.zhihu.com/p/144775352">https://zhuanlan.zhihu.com/p/144775352</a><br /></li>
<li>HDR 和色彩管理 5 游戏中的 HDR <a href="https://zhuanlan.zhihu.com/p/150894189">https://zhuanlan.zhihu.com/p/150894189</a><br /></li>
<li>ACES <a href="https://en.wikipedia.org/wiki/Academy_Color_Encoding_System">https://en.wikipedia.org/wiki/Academy_Color_Encoding_System</a><br /></li>
</ul>
</div>
</li>
<li><a id="org8d90289"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org002d001"></a>如何理解 颜色知识 2-三原色理论与颜色匹配实验 文章中的颜色匹配函数？<br />
<div class="outline-text-9" id="text-org002d001">
<p>
横轴为光的波长，纵轴为匹配该波长的光的颜色所使用的红、绿、蓝三种波长光的量。<br />
红色曲线有一部分落在了 x 轴之下，这是因为混合红、绿、蓝三种波长光无法得到这个区域对应的光的颜色，需要将红色光叠在被匹配的光上，才能使得两边颜色一直（默认情况下，左边为被匹配的光，右边为红绿蓝三种波长的光叠加在一起的混合光）。<br />
</p>

<p>
请参考下面文中描述<br />
</p>
<ul class="org-ul">
<li>色觉地图的建立（一）：光感受器、色匹配实验与 CIE RGB 坐标系 <a href="https://zhuanlan.zhihu.com/p/72803768">https://zhuanlan.zhihu.com/p/72803768</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge6fc4a9"></a>参考链接<br />
<div class="outline-text-8" id="text-orge6fc4a9">
<p>
具体内容参考下面链接。<br />
</p>
<ul class="org-ul">
<li>CIE 1931 XYZ 色彩空间 <a href="https://zh.wikipedia.org/wiki/CIE1931%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">https://zh.wikipedia.org/wiki/CIE1931%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4</a><br /></li>
<li>color-spaces <a href="https://ciechanow.ski/color-spaces/">https://ciechanow.ski/color-spaces/</a>  该链接中有颜色空间的 3D 图，可交互旋转这些图形<br /></li>
<li>3D CIE-RGB CIE-XYZ 空间演示 <a href="https://graphics.stanford.edu/courses/cs178/applets/threedgamut.html">https://graphics.stanford.edu/courses/cs178/applets/threedgamut.html</a><br /></li>
<li>Color: From Hexcodes to Eyeballs <a href="http://jamie-wong.com/post/color/">http://jamie-wong.com/post/color/</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgfb254ed" class="outline-6">
<h6 id="orgfb254ed">参考资料</h6>
<div class="outline-text-6" id="text-orgfb254ed">
<ul class="org-ul">
<li>Color and Light <a href="http://www.cse.psu.edu/~rtc12/CSE486/lecture26.pdf">http://www.cse.psu.edu/~rtc12/CSE486/lecture26.pdf</a><br /></li>
<li>色觉地图的建立（一）：光感受器、色匹配实验与 CIE RGB 坐标系 <a href="https://zhuanlan.zhihu.com/p/72803768">https://zhuanlan.zhihu.com/p/72803768</a><br /></li>
<li>HumanSensitivity to color <a href="http://graphics.stanford.edu/courses/cs178/applets/locus.html">http://graphics.stanford.edu/courses/cs178/applets/locus.html</a><br /></li>
<li>ColorMatching <a href="http://graphics.stanford.edu/courses/cs178/applets/colormatching.html">http://graphics.stanford.edu/courses/cs178/applets/colormatching.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1b92190" class="outline-5">
<h5 id="org1b92190">Spectral Representation</h5>
<div class="outline-text-5" id="text-org1b92190">
<p>
pbr 中不支持动态修改 Spectrum 类型，修改 Spectrum 类型需要重新编译，这样做有两个好处：<br />
</p>
<ol class="org-ol">
<li>很多 Spectrum 的方法都可以实现为 inlined，而不需要通过虚函数机制来支持不同 Spectrum 类型<br /></li>
<li>不需要动态创建 Spectrum 的实例。<br /></li>
</ol>

<p>
CoefficientSpectrum 下面的样本访问函数的实现中隐含了光谱表示是一系列的系数线性地缩放一组固定的基函数。尽管这种抽象不够理想，但是其简化了当前系统其他部分的实现，并且当这个假设不正确时，也不难清除。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">Float &amp; CoefficientSpectrum::operator[](<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>) { <span style="color: #4f97d7; font-weight: bold;">return</span> c[i]; }
<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">CoefficientSpectrum</span>::operator[](<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> { <span style="color: #4f97d7; font-weight: bold;">return</span> c[i]; }
</pre>
</div>
</div>
</div>
<div id="outline-container-org9f6e5b2" class="outline-5">
<h5 id="org9f6e5b2">SampledSpectrum</h5>
<div class="outline-text-5" id="text-org9f6e5b2">
<p>
下图展示了利用线性插值来求平均的光谱采样：<br />
<img src="./PhysicallyBasedRendering/2020_06_05_average_spec_samples.jpg" alt="2020_06_05_average_spec_samples.jpg" /><br />
</p>
</div>

<div id="outline-container-org1a9185c" class="outline-6">
<h6 id="org1a9185c">XYZ Color</h6>
<div class="outline-text-6" id="text-org1a9185c">
<p>
人类视觉系统的特性决定了可以只使用 3 个浮点值就可以表示人类看到的颜色。色彩感知的三原色理论表示，可以使用三个值 xλ,yλ,zλ为人类观察者精确表示所有可见光谱。<br />
给定一个 SPD S(λ)，这三个值可通过下面公式计算得到，X(λ) Y(λ) Z(λ) 分别为光谱匹配曲线，这些曲线由 CIE 标准通过一系列主观试验测试绘制出来。这些匹配曲线和人眼视网膜上的三种颜色感知视锥细胞的响应曲线相似。<br />
下图为光谱匹配曲线：<br />
<img src="./PhysicallyBasedRendering/2020_06_05_xyz_match_curve.jpg" alt="2020_06_05_xyz_match_curve.jpg" /><br />
下图为由 SPD 和 X(λ) Y(λ) Z(λ)计算 xλ,yλ,zλ的方法：<br />
<img src="./PhysicallyBasedRendering/2020_06_05_spd_to_xyz.jpg" alt="2020_06_05_spd_to_xyz.jpg" /><br />
</p>

<p>
需要注意的是，不同的光谱分布可能会得到相似的 xλ,yλ,zλ值。对于人类视觉来说，这些不同的 SPDs 确有相同的可视效果。这些光谱被称为条件等色。<br />
</p>

<p>
尽管 XYZ 可以很好的将一个给定的 SPD 表示为人类观察者看到的颜色。但是其也有不足的地方，例如，计算两个颜色各自 XYZ 值的乘积所得的 XYZ 值和将两个 SPD 相乘然后计算结果的 XYZ 值有明显的差别。<br />
XYZ 空间的 y 系数和 luminance 有紧密联系，其用于度量颜色的亮度感觉。<br />
</p>
</div>
</div>

<div id="outline-container-org80b811d" class="outline-6">
<h6 id="org80b811d">RGB Color</h6>
<div class="outline-text-6" id="text-org80b811d">
<p>
当我们将 RGB 颜色显示到显示器上时，实际上显示的光谱基本由 r、g、b 三个光谱响应曲线的权重和决定。下图显示了 LED 显示器和 LCD 显示器发出的 r、g、b 的分布：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_lcd_led.jpg" alt="2020_06_07_lcd_led.jpg" /><br />
下图显示了 RGB 颜色(0.6,0.3,0.2)在 LED、LCD 上的显示时的 SPD，可以看出，不同显示器显示相同颜色，所得的 SPD 却非常不同，因此用户提供的用于表示特定颜色的 RGB 值，只有知道显示器特性才有意义。<br />
<img src="./PhysicallyBasedRendering/2020_06_07_lcd_led_color_instance.jpg" alt="2020_06_07_lcd_led_color_instance.jpg" /><br />
给定 SPD 的（xλ，yλ，zλ）表示形式，并选择一组特定的 SPD 来定义显示器的红色，绿色和蓝色，我们可以将（xλ，yλ，zλ）转换为对应显示器的 RGB 系数。给定显示器的光谱响应曲线 R(λ), G(λ), B(λ)，对于特定的显示器 RGB 系数可以通过下面方法来计算：<br />
<img src="./PhysicallyBasedRendering/2020_06_07_calc_rgb.jpg" alt="2020_06_07_calc_rgb.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">XYZToRGB</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">xyz</span>[3], <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">rgb</span>[3]) 
  {
      rgb[0] = 3.240479f * xyz[0] - 1.537150f * xyz[1] - 0.498535f * xyz[2];
      rgb[1] = -0.969256f * xyz[0] + 1.875991f * xyz[1] + 0.041556f * xyz[2];
      rgb[2] = 0.055648f * xyz[0] - 0.204043f * xyz[1] + 1.057311f * xyz[2];
  }
</pre>
</div>

<p>
将 RGB 或 XYZ 值转化为 SPD 比较难，无数多个 SPD 有相同的 xλ，yλ，zλ系数。我们希望转化函数可以满足如下条件：<br />
</p>
<ol class="org-ol">
<li>当 RGB 系数相同时，得到的 SPD 应该是一个常数<br /></li>
<li>通常，希望计算得到的 SPD 是平滑的。大多数真实世界的物体都具有平滑的 SPD。不平滑的光谱主要来源于光源，特别是荧光灯。<br /></li>
</ol>

<p>
通过将显示器的 R(λ), G(λ), and B(λ) SPDs 加权求和来构造 SPD 不是一个很好的解决方案，因为显示器的 R(λ), G(λ), and B(λ) SPDs 通常是不规律、不平滑的，加权求和得到的 SPD 也不会平滑。<br />
Smits(1999)发现了一种将 RGBs 转化为 SPDs 的方法。分别为 red、green、blue 计算各自的 SPDs，并保证这些 SPDs 光滑，然后用给定的 RGB 系数对这些 SPDs 进行加权求和，从而得到平滑的 SPD，再将 SPD 转化为 RGB 可以得到一个和原始 RGB 系数接近的系数.可以对这种基本方式做下面两个额外的改进：<br />
</p>
<ol class="org-ol">
<li>不要使用 red\green\blue 的 SPDs 的和来表示常量光谱，直接通过常量光谱表示常量 SPDs。<br /></li>
<li>混合颜色是由两种元颜色混合而来，混合颜色最好通过预计算的光滑的 SPD 来表示，而不是通过元颜色的和表示<br /></li>
</ol>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">SampledSpectrum</span> <span style="color: #bc6ec5; font-weight: bold;">SampledSpectrum</span>::FromRGB(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">rgb</span>[3], <span style="color: #ce537a; font-weight: bold;">SpectrumType</span> <span style="color: #7590db;">type</span>) 
  {
      <span style="color: #ce537a; font-weight: bold;">SampledSpectrum</span> <span style="color: #7590db;">r</span>;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (type == SpectrumType::Reflectance) {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Convert reflectance spectrum to RGB</span>
          <span style="color: #4f97d7; font-weight: bold;">if</span> (rgb[0] &lt;= rgb[1] &amp;&amp; rgb[0] &lt;= rgb[2]) {
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute reflectance _SampledSpectrum_ with _rgb[0]_ as minimum</span>
              r += rgb[0] * rgbRefl2SpectWhite;
              <span style="color: #4f97d7; font-weight: bold;">if</span> (rgb[1] &lt;= rgb[2]) {
                  r += (rgb[1] - rgb[0]) * rgbRefl2SpectCyan;
                  r += (rgb[2] - rgb[1]) * rgbRefl2SpectBlue;
              } <span style="color: #4f97d7; font-weight: bold;">else</span> {
                  r += (rgb[2] - rgb[0]) * rgbRefl2SpectCyan;
                  r += (rgb[1] - rgb[2]) * rgbRefl2SpectGreen;
              }
          }
      }
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
  }
</pre>
</div>

<ul class="org-ul">
<li>LCD 显示器工作原理到底是怎样的？ <a href="https://www.zhihu.com/question/39452323">https://www.zhihu.com/question/39452323</a><br /></li>
<li>显示器如何显示准确的颜色？ <a href="https://zhuanlan.zhihu.com/p/43467096">https://zhuanlan.zhihu.com/p/43467096</a><br /></li>
<li>An RGB to Spectrum Conversion for Reflectances <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.9608&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.9608&amp;rep=rep1&amp;type=pdf</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdd070be" class="outline-6">
<h6 id="orgdd070be">参考资料</h6>
</div>
</div>
<div id="outline-container-org9b2951c" class="outline-5">
<h5 id="org9b2951c">RGBSpectrum</h5>
</div>
<div id="outline-container-org46694ea" class="outline-5">
<h5 id="org46694ea">Radiometry</h5>
<div class="outline-text-5" id="text-org46694ea">
<p>
辐射度学并不是使用物理的第一原理推导而来，而是基于光的粒子抽象建立的。因此，该框架无法描述光的偏振，但是已经将辐射度学和麦克斯韦方程建立了联系，这为辐射度学提供了坚实的物理基础。<br />
辐射传播是辐射能量的传播。其基于辐射度原理，属于几何光学层面，光的宏观属性足够描述光和物体(物体的尺寸远大于光的波长)的交互。其很少包含光的波动光学模型，但是波动光学的结果需要使用辐射度学的语言来描述。这样就可以描述光和尺寸较小的物体(物体尺寸和波长近似)的交互，可以模拟色散和干涉现象。更精细的细节就需要利用量子机制来描述光和原子的交互。渲染问题不需要直接模拟量子机制。<br />
</p>

<p>
pbrt 中，我们假设几何光学足够描述光和光的散射。这样可以得到如下一些光的行为规则：<br />
</p>
<ol class="org-ol">
<li>线性关系：组合两个输入等价于两个输入分别作用的结果的和<br /></li>
<li>能量守恒：散射后能量不会比原来更多<br /></li>
<li>没有偏振：忽略电磁场的偏振<br /></li>
<li>没有荧光和磷光：这些是光在一个波长尺度上的行为，和光在多个波长尺度上的行为完全独立。<br /></li>
<li>稳定的状态：光在环境中达到均衡，其辐射分布不会随时间变化。注意：磷光现象违反了稳定状态的假设。<br /></li>
</ol>

<p>
几何光学模型的最大缺点是无法简单地模拟色散和干涉现象。因为两个区域总的通量不必和各自接收的能量的和相等。<br />
</p>

<p>
下图展示了辐射度学中的物理量：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_radiomery_quantity.jpg" alt="2020_06_08_radiomery_quantity.jpg" /><br />
</p>

<p>
所有的辐射度测量物理量都有对应的光度测量物理量。光度学是研究人类视觉系统对可见的电子辐射的感觉。<br />
每个光谱辐射度物理量都可以被转化为对应的光度物理量，只需要对辐射度物理量和对应光度响应曲线的积做积分就可以了。下图展示了辐射度测量物理量和光度学测量物理量之间的对应关系：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_radiomery_photometric.jpg" alt="2020_06_08_radiomery_photometric.jpg" /><br />
Luminance 测量了人眼观察到的光谱功率分布的亮度。和 Luminance 对应的辐射度测量物理量为 Radiance（记作 L），下图表示了计算 Luminance(记作 Y)的公式：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_radiance_to_luminance.jpg" alt="2020_06_08_radiance_to_luminance.jpg" /><br />
Lunimance 和光谱响应曲线 V (λ)与 XYZ 颜色表示有紧密关系。CIE 的 Y (λ) 三刺激曲线是和人类亮度响应曲线 V(λ)成比例的。<br />
<img src="./PhysicallyBasedRendering/2020_06_08_CIEY_luminance.jpg" alt="2020_06_08_CIEY_luminance.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://computergraphics.stackexchange.com/questions/8295/luminance-and-radiance-in-computer-screen">https://computergraphics.stackexchange.com/questions/8295/luminance-and-radiance-in-computer-screen</a><br /></li>
<li><a href="https://computergraphics.stackexchange.com/questions/1992/rendering-in-radiometric-units-or-photometric">https://computergraphics.stackexchange.com/questions/1992/rendering-in-radiometric-units-or-photometric</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge4be04a" class="outline-5">
<h5 id="orge4be04a">Working With Radiometric intergals</h5>
<div class="outline-text-5" id="text-orge4be04a">
<p>
渲染中最寻常的任务是求辐射量的积分。本节介绍一些技巧可以简化求辐射量积分的任务。<br />
</p>
</div>
<div id="outline-container-org7aa7fc5" class="outline-6">
<h6 id="org7aa7fc5">Integrals over projected solid angle</h6>
<div class="outline-text-6" id="text-org7aa7fc5">
<p>
下图为计算点 p 处的 irradiance(辐照度) n 为点 p 处表面的 normal，Li(p,w)为 radiance(入射辐射度)函数，cos(&theta;)为 dA⊥项。&theta; 为 w 和 n 的夹角。辐照度通常只计算 normal 指向的半球范围。<br />
<img src="./PhysicallyBasedRendering/2020_06_08_calc_irradiance.jpg" alt="2020_06_08_calc_irradiance.jpg" /><br />
</p>

<p>
辐射量积分中的各种 cosine 项经常会分散其要表示的内容。使用投影立体角而不是立体角来度量积分对象覆盖的区域可以避免此问题。<br />
物体的投影立体角是通过先将物体投影到单位球上，然后再将物体投影到垂直与 normal 的 disc 上得到的。如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_proj_solid_angle.jpg" alt="2020_06_08_proj_solid_angle.jpg" /><br />
</p>

<p>
在半球范围内，从某个物体发出的总的通量可以通过下面公式计算，其中 A 为该物体的表面积：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_calc_flux.jpg" alt="2020_06_08_calc_flux.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org02669e4" class="outline-6">
<h6 id="org02669e4">Integrals over spherical coordinates</h6>
<div class="outline-text-6" id="text-org02669e4">
<p>
将立体角积分转化为球面坐标系积分经常很方便。<br />
下图将一个向量转化为球坐标系形式：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_spherical_coord.jpg" alt="2020_06_08_spherical_coord.jpg" /><br />
下图将立体角转化为球面坐标系形式：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_spherical_coord_solid_angle.jpg" alt="2020_06_08_spherical_coord_solid_angle.jpg" /><br />
</p>

<p>
则点 p 处的 irradiance(辐照度)可以通过如下方式计算：<br />
<img src="./PhysicallyBasedRendering/2020_06_08_calc_irradiance_spherical_coord.jpg" alt="2020_06_08_calc_irradiance_spherical_coord.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgf5315e1" class="outline-6">
<h6 id="orgf5315e1">Integrals over area</h6>
<div class="outline-text-6" id="text-orgf5315e1">
<p>
将在方向上的积分转化为在区域(面积)上的积分可以简化计算。有一个正方形发出恒定的 radiance(辐射率)，计算点 p 处的 irradiance(辐照度)。在各个方向上积分来求该值是不太直接的，因为给定一个方向需要判断该方向上正方形是否可见。在四边形的区域上积分来计算辐照度则更容易。<br />
微分区域和微分立体角有如下关系，其中 &theta; 为正方形微分表面 dA 的法线和指向 p 点的向量的夹角，r为 p 和正方形微分表面 dA 之间的距离。<br />
<img src="./PhysicallyBasedRendering/2020_06_08_integral_over_area.jpg" alt="2020_06_08_integral_over_area.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org317f523" class="outline-5">
<h5 id="org317f523">Surface Reflection</h5>
<div class="outline-text-5" id="text-org317f523">
<p>
当光入射到表面，表面会散射光，并反射一部分光回到环境中。模拟反射主要有两个效果需要表示出来：反射光的光谱分布和反射光的方向分布。<br />
</p>
</div>
<div id="outline-container-orgb46ec18" class="outline-6">
<h6 id="orgb46ec18">BRDF BTDF</h6>
<div class="outline-text-6" id="text-orgb46ec18">
<p>
BRDF(bidirectional reflectance distribution function) 形式化描述了表面的反射。其忽略了光在次表面传播的效果。<br />
BTDF(bidirectional transmittance distribution function) 描述了穿过表面的光的分布。BTDF 不满足互换性(reciprocity).<br />
BSDF(bidirectional scattering distribution function) 描述了表面反射和透射，其同时考虑了 BRDF 和 BTDF.<br />
</p>

<p>
下图为 BRDF  BTDF  BSDF 的定义:<br />
<img src="./PhysicallyBasedRendering/2020_06_09_brdf_define.jpg" alt="2020_06_09_brdf_define.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="./AdvancedGlobalIllumination.html#orgd97ae63">Solid Angle</a><br /></li>
</ul>

<p>
Tips: brdf 的范围为 0 到无穷大<br />
</p>
<ul class="org-ul">
<li><a href="https://www.gamedev.net/forums/topic/257668-brdf-range----greater-than-01-/">https://www.gamedev.net/forums/topic/257668-brdf-range----greater-than-01-/</a><br /></li>
<li><a href="http://resources.mpi-inf.mpg.de/departments/d4/teaching/ws200708/cg/slides/CG07-Brdf+Texture.pdf">http://resources.mpi-inf.mpg.de/departments/d4/teaching/ws200708/cg/slides/CG07-Brdf+Texture.pdf</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7d98c2e" class="outline-6">
<h6 id="org7d98c2e">BSSRDF</h6>
<div class="outline-text-6" id="text-org7d98c2e">
<p>
BSSRDF(bidirectional scattering surface reflectance distribution function) 描述了材质的散射中展现了明显的次表面光传播。<br />
</p>

<p>
下图为 BSSRDF 的定义(<a id="orgcd8f87e"></a>)：<br />
<img src="./PhysicallyBasedRendering/2020_06_09_bssrdf_define.jpg" alt="2020_06_09_bssrdf_define.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org312c0ac" class="outline-4">
<h4 id="org312c0ac">6 Camera models</h4>
<div class="outline-text-4" id="text-org312c0ac">
</div>
<div id="outline-container-org17157ef" class="outline-5">
<h5 id="org17157ef">Camera Model</h5>
<div class="outline-text-5" id="text-org17157ef">
<p>
真实世界的摄像机都有一个快门，其开启一个短暂的时间将胶片暴露在光下。曝光时间大于 0 时，会造成运动模糊：曝光时间内，物体相对于摄像机运动时，物体会变模糊。摄像机都会存储快门打开的时间和快门关闭的时间，并且摄像机采样场景时生成的射线也会携带对应的时间。在快门开启关闭时间间隔内，给定恰当的射线时间分布，就可以在最终计算的图片中展现运动模糊效果。<br />
</p>

<p>
摄像机中还包含一个 Film 实例的指针，以及一个 Medium 实例的指针（用于表示摄像机所处的介质）。<br />
</p>

<p>
摄像机空间可以方便地监测物体对于摄像机是否可见。例如，如果物体在摄像机空间中的 BoundingBox 在 Z=0 平面后面，则物体对于摄像机不可见。<br />
</p>
</div>
</div>
<div id="outline-container-org7f8ec7e" class="outline-5">
<h5 id="org7f8ec7e">Projective Camera Models</h5>
<div class="outline-text-5" id="text-org7f8ec7e">
<p>
屏幕空间：屏幕空间定义在胶片平面上。摄像机将物体从摄像机空间投影到胶片平面上。生成的图片只有在屏幕窗口内的部分是可见的。屏幕空间中深度值 Z 的范围为[0,1]，分别对应近裁剪面和远裁剪面。注意：尽管被称为屏幕空间，其仍然是三维坐标系，因为 z 值是有意义的<br />
标准设备坐标空间（NDC）：该坐标系是实际被渲染图片的坐标系。x,y 方向的范围为[0，1].深度值和屏幕空间的相同。<br />
光栅化空间：几乎和 NDC 空间相同，除了 x，y 坐标范围为[0, resolution.x] [0, resolution.y]<br />
<img src="./PhysicallyBasedRendering/2020_06_09_camera_relative_space.jpg" alt="2020_06_09_camera_relative_space.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ScreenToRaster</span>
ScreenToRaster =
            Scale(film-&gt;fullResolution.x, film-&gt;fullResolution.y, 1) *
            Scale(1 / (screenWindow.pMax.x - screenWindow.pMin.x),
                  1 / (screenWindow.pMin.y - screenWindow.pMax.y), 1) *
            Translate(Vector3f(-screenWindow.pMin.x, -screenWindow.pMax.y, 0));

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">RasterToScreen</span>
RasterToScreen = Inverse(ScreenToRaster);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">RasterToCamera</span>
RasterToCamera = Inverse(CameraToScreen) * RasterToScreen;
</pre>
</div>
</div>

<div id="outline-container-orga3dbd9e" class="outline-6">
<h6 id="orga3dbd9e">Orthographic Camera</h6>
<div class="outline-text-6" id="text-orga3dbd9e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#27491;&#20132;&#25237;&#24433;&#30697;&#38453;</span>
<span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #bc6ec5; font-weight: bold;">Orthographic</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">zNear</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">zFar</span>) 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> Scale(1, 1, 1 / (zFar - zNear)) * Translate(Vector3f(0, 0, -zNear));
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#20132;&#25668;&#20687;&#26426;&#30340;CameraToScreen &#21464;&#25442;&#30697;&#38453;&#20026; Orthographic(0, 1);</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge28fd54" class="outline-6">
<h6 id="orge28fd54">Perspective Camera</h6>
<div class="outline-text-6" id="text-orge28fd54">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#36879;&#35270;&#25237;&#24433;&#30697;&#38453;</span>
<span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #bc6ec5; font-weight: bold;">Perspective</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">fov</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">n</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">f</span>) 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform projective divide for perspective projection</span>
    <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #bc6ec5; font-weight: bold;">persp</span>(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, f / (f - n), -f * n / (f - n),
                    0, 0, 1, 0);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Scale canonical perspective view to specified field of view</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">invTanAng</span> = 1 / std::tan(Radians(fov) / 2);
    <span style="color: #4f97d7; font-weight: bold;">return</span> Scale(invTanAng, invTanAng, 1) * Transform(persp);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36879;&#35270;&#25668;&#20687;&#26426;&#30340; CameraToScreen&#21464;&#25442;&#30697;&#38453;&#20026; Perspective(fov, 1e-2f, 1000.f)</span>
</pre>
</div>

<p>
上面透视投影变换的求解分为两步：<br />
</p>
<ol class="org-ol">
<li>将点 p 投影到近平面得到点 p'。如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_09_perspective_projection_matrix_01.jpg" alt="2020_06_09_perspective_projection_matrix_01.jpg" /><br /></li>
<li>利用用户指定的 FOV，将投影后的视景体内的坐标转化到[-1,1]范围内的坐标。<br />
    对于正方形图片来说，x和 y 都在[-1,1]范围内。<br />
对于矩形图片来说，比较窄的方向会被映射到[-1, 1]范围，比较宽的方向会同比例映射到更大的范围。<br /></li>
</ol>
</div>
</div>

<div id="outline-container-org5b2f26c" class="outline-6">
<h6 id="org5b2f26c">Lens Model and Depth Of Field</h6>
<div class="outline-text-6" id="text-org5b2f26c">
<p>
真实的相机有镜头系统，其将通过有限尺寸光圈的光聚焦到胶片平面上。相机设计者面临一个取舍：光圈越大，就会有越多的光进入胶片，需要曝光的时间也就越短。然而，镜头只会聚焦在单个平面上（焦点平面），离焦点平面越远的物体会越模糊。光圈越大，产生的模糊越明显。<br />
</p>

<p>
下面是成像系统相关的几个概念：<br />
焦点（像方交点）：在物理学上指平行光线经透镜折射或曲面镜反射后的会聚点。<br />
物方交点：<br />
焦距：平行光从透镜的光心到光聚集之焦点的距离，即透镜中心到焦点的距离。<br />
焦平面：与成像系统的光轴垂直、且包含成像系统焦点的平面。<br />
镜屏距：透镜中心到屏幕（底片）的距离。<br />
物距：物体到透镜中心的距离。<br />
像距：给定物距和焦距情况下，像到透镜中心的距离。<br />
合焦距离：屏幕上的像最清晰时，屏幕据透镜中心的距离。物距给定，合焦距离即是像距。<br />
</p>

<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/20086562/answer/15877139">https://www.zhihu.com/question/20086562/answer/15877139</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/21672067">https://zhuanlan.zhihu.com/p/21672067</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E5%87%B8%E9%80%8F%E9%95%9C">https://baike.baidu.com/item/%E5%87%B8%E9%80%8F%E9%95%9C</a><br /></li>
<li>工程光学（六）——几何光学（进阶）<a href="https://zhuanlan.zhihu.com/p/48980327">https://zhuanlan.zhihu.com/p/48980327</a><br /></li>
</ul>
<p>
下图为凸透镜原理：<br />
<img src="./PhysicallyBasedRendering/2020_06_16_convex_lens.gif" alt="2020_06_16_convex_lens.gif" /><br />
</p>

<p>
对于目前我们使用的简单摄像机模型，我们可以应用光学上经典的近似（薄镜头近似），使用计算机图形学投影模型来模拟有限光圈。薄镜头近似模拟拥有单个球面镜头的光学系统，镜头的厚薄和曲面镜头的直径有很小关系。<br />
在薄镜头近似中，平行的入射光线经过镜头后会聚焦在一点，这点被称为焦点。焦点到镜头的距离被称为焦距 f。如果胶片被放置在镜头后焦点的位置上，则无线远的物体会被聚焦到胶片上的一个点。如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_12_thin_len_approximation_01.jpg" alt="2020_06_12_thin_len_approximation_01.jpg" /><br />
下面链接中可以进行动态演示：<br />
<a href="https://ophysics.com/l12.html">https://ophysics.com/l12.html</a><br />
<a href="./PhysicallyBasedRendering/2020_06_12_ConcaveAndConvexLenses.ggb">./PhysicallyBasedRendering/2020_06_12_ConcaveAndConvexLenses.ggb</a><br />
</p>

<p>
对于场景中距离镜头为 z 的一点 p，镜头的焦距为 f，p 点被镜头聚焦的点为 p'，其到镜头的距离为 z'(像距)，由成像公式可的如下关系：<br />
<img src="./PhysicallyBasedRendering/2020_06_12_thin_len_approximation_02.jpg" alt="2020_06_12_thin_len_approximation_02.jpg" /><br />
</p>
<ul class="org-ul">
<li>成像公式证明 <a href="https://baike.baidu.com/item/%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F">https://baike.baidu.com/item/%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F</a><br /></li>
</ul>

<p>
上图中的 z'就是 z 对应的像距，z和 z'是一一对应的，如果点没有放置在 z 聚焦位置上，点在胶片上的投影为一个圆盘(disk)而不是一个点。这个圆盘的边界被称为 circle of confusion。圆盘的尺寸由光圈的直径，焦距以及物体到镜头的距离决定。<br />
在实践中，物体不需要正好在焦点平面上才投影出清晰的像，只要 circle of confusion 大致小于胶片上每个像素的大小，物像就是清晰的。物体聚焦的距离范围被称为镜头的 depth of field(景深).<br />
成像公式可用于计算 circle of confusion 的直径。如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_12_thin_len_approximation_03.jpg" alt="2020_06_12_thin_len_approximation_03.jpg" /><br />
焦距 f 为 50mm 的镜头，25mm 光圈，清晰像的物距 Zf 为 1m，随着物距 z 的变化，circle of confusion 直径的变化如下图：<br />
<img src="./PhysicallyBasedRendering/2020_06_12_circle_of_confusion_diameter.jpg" alt="2020_06_12_circle_of_confusion_diameter.jpg" /><br />
从上图可以看出，Z小于 Zf 时，Dc 变化比较快，而 Z 大于 Zf 时，Dc 变化比较慢。<br />
</p>

<p>
在射线追踪中模拟一个薄镜头非常简单直接。设点 O 为胶片上一点，在镜头上选一个点 A，然后计算经过镜头中心点 Ao 的射线和焦距平面的交点 Z，则 AZ 就是胶片上 O 对应的射线。如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_12_thin_len_approximation_04.jpg" alt="2020_06_12_thin_len_approximation_04.jpg" /><br />
通常为了模拟平滑的景深需要为每个像素点追踪很多个射线。<br />
下面代码为镜头半径大于 0 时，镜头发出射线的重新计算代码。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">if</span> (lensRadius &gt; 0) {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sample point on lens</span>
      <span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #7590db;">pLens</span> = lensRadius * ConcentricSampleDisk(sample.pLens);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute point on plane of focus</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">focalDistance &#20026;&#33014;&#29255;&#21040;&#32858;&#28966;&#24179;&#38754;&#30340;&#36317;&#31163;</span>
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">ft</span> = focalDistance / ray-&gt;d.z;
      <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">pFocus</span> = (*ray)(ft);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update ray for effect of lens</span>
      ray-&gt;o = Point3f(pLens.x, pLens.y, 0);
      ray-&gt;d = Normalize(pFocus - ray-&gt;o);
   }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcd822f3" class="outline-5">
<h5 id="orgcd822f3">Environment Camera</h5>
<div class="outline-text-5" id="text-orgcd822f3">
<p>
射线追踪比基于光栅化的渲染方法的一大优势是，其可以简单利用非寻常的图片投影。关于图片采样位置如何对应到射线的方向，我们有极大的自由度，因为射线追踪渲染算法并不依赖于场景中的直线必须要投影为图片中的直线这类属性。<br />
环境摄像机模型就是在场景中一点(环境摄像机的位置)，向所有方向追踪射线，得到一个 2D 的视图。<br />
EnvironmentCamera 直接从 Camera 类派生，而不是从 ProjectiveCamera 类派生。因为环境投影不是线性的，其无法通过一个 4x4 的矩阵来表示。<br />
EnvironmentCamera 使用了球坐标系来实现，如下面代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">EnvironmentCamera</span>::GenerateRay(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">CameraSample</span> &amp;sample, <span style="color: #ce537a; font-weight: bold;">Ray</span> *<span style="color: #7590db;">ray</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">ProfilePhase</span> <span style="color: #bc6ec5; font-weight: bold;">prof</span>(Prof::GenerateCameraRay);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute environment camera ray direction</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">theta</span> = Pi * sample.pFilm.y / film-&gt;fullResolution.y;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">phi</span> = 2 * Pi * sample.pFilm.x / film-&gt;fullResolution.x;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29992;&#29699;&#22352;&#26631;&#31995;&#27714;&#23556;&#32447;&#26041;&#21521;</span>
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #bc6ec5; font-weight: bold;">dir</span>(std::sin(theta) * std::cos(phi), std::cos(theta),
                 std::sin(theta) * std::sin(phi));
    *ray = Ray(Point3f(0, 0, 0), dir, Infinity,
               Lerp(sample.time, shutterOpen, shutterClose));
    ray-&gt;medium = medium;
    *ray = CameraToWorld(*ray);
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
}
</pre>
</div>
<p>
下面为光栅化渲染方法中用到的环境映射：<br />
</p>
<ul class="org-ul">
<li>详解球面环境映射 - Spherical Environment Mapping <a href="https://zhuanlan.zhihu.com/p/84494845">https://zhuanlan.zhihu.com/p/84494845</a><br /></li>
<li>详解双抛物面环境映射 <a href="https://zhuanlan.zhihu.com/p/40784734">https://zhuanlan.zhihu.com/p/40784734</a><br /></li>
</ul>
<p>
下面文件展示了其中原理：<br />
<a href="./PhysicallyBasedRendering/paraboloid_env_mapping.ggb">./PhysicallyBasedRendering/paraboloid_env_mapping.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-orgdb18607" class="outline-5">
<h5 id="orgdb18607"><span class="todo TODO">TODO</span> Realistic Cameras</h5>
</div>
</div>
<div id="outline-container-org53626c1" class="outline-4">
<h4 id="org53626c1">7 Sampling and reconstruction</h4>
<div class="outline-text-4" id="text-org53626c1">
</div>
<div id="outline-container-org1044cc2" class="outline-5">
<h5 id="org1044cc2">Sampling Theory</h5>
<div class="outline-text-5" id="text-org1044cc2">
<p>
一个数字图片被表示为一组像素值，这些像素值通常排列成一个矩形格子。当数字图片被显示到物理设备上时，这些值通常用于确定显示器上像素所发出的光谱功率。区分图片像素和显示像素非常重要。图片像素表示函数在特定采样点的值。而显示像素是物理对象发出的带有某种分布的光，(在 LCD 显示器上，斜着看和正着看颜色和亮度会有很大不同）。显示器使用图片像素值来构建一个新的图片函数。这个函数定义在显示器的所有点上，而不只是数字图片的很小的像素点。取一组采样值，然后将其转化为连续函数的过程被称为重建(reconstruction)。<br />
为了计算数字图片上离散的像素值，必须对原始的连续的图片函数做采样。在 pbrt 中，获取图片函数信息的唯一方式是通过射线追踪来对图片函数进行采样，这和其他射线追踪渲染器是一样的。<br />
因为采样和重建过程涉及到了近似，所以会引入被称为走样(aliasing)的错误。走样有多种表现形式，其中包括锯齿边缘或者动画中的闪烁。这是因为采样过程中无法从连续定义的图片函数捕捉到所有信息。<br />
</p>

<p>
下图展示了采样和重建的过程：<br />
<img src="./PhysicallyBasedRendering/2020_06_18_sampling_reconstruction_process_01.jpg" alt="2020_06_18_sampling_reconstruction_process_01.jpg" /><br />
</p>
</div>

<div id="outline-container-org26675e1" class="outline-6">
<h6 id="org26675e1">The Frequency Domain And The Fourier Transform</h6>
<div class="outline-text-6" id="text-org26675e1">
<p>
傅里叶变换是傅里叶分析的基础之一，傅里叶变换是函数在频率域上的表示(通常函数是在空间域上表示)。下图表示了两个函数在空间域和频率域上的图像。<br />
<img src="./PhysicallyBasedRendering/2020_06_16_frequency_spatial_domain_func.jpg" alt="2020_06_16_frequency_spatial_domain_func.jpg" /><br />
</p>

<p>
下图为傅里叶级数和傅里叶变换的公式：<br />
<img src="./PhysicallyBasedRendering/2020_06_17_fourier_transform_func.jpg" alt="2020_06_17_fourier_transform_func.jpg" /><br />
</p>

<p>
大多数函数可以被分解为多个带相位的正弦函数的权重和。在频率空间表示一个函数，便于深入了解该函数的特性(正弦函数的频率分布对应了原始函数的频率分布)。使用这种形式，可以使用傅里叶分析透彻理解，采样引入的错误，以及重建(reconstruction)的过程，以及如何减少感知到的错误效果。<br />
</p>

<p>
频率域表示和空间域表示互逆，下图为一些重要的函数，以及其在频率域的表示。<br />
<img src="./PhysicallyBasedRendering/2020_06_17_important_func_s_f_space.jpg" alt="2020_06_17_important_func_s_f_space.jpg" /><br />
</p>

<ul class="org-ul">
<li>正弦型函数 <a href="https://baike.baidu.com/item/%E6%AD%A3%E5%BC%A6%E5%9E%8B%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E6%AD%A3%E5%BC%A6%E5%9E%8B%E5%87%BD%E6%95%B0</a><br /></li>
<li>傅里叶分析之掐死教程 <a href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a><br /></li>
<li>如何通俗地理解傅立叶变换？ <a href="https://www.matongxue.com/madocs/473.html">https://www.matongxue.com/madocs/473.html</a><br /></li>
<li>如何理解傅立叶级数公式？ <a href="https://www.matongxue.com/madocs/619.html">https://www.matongxue.com/madocs/619.html</a><br /></li>
<li>从傅立叶级数到傅立叶变换 <a href="https://www.matongxue.com/madocs/712.html">https://www.matongxue.com/madocs/712.html</a><br /></li>
<li>如何理解傅里叶变换公式？<a href="https://www.zhihu.com/question/19714540/answer/1119070975">https://www.zhihu.com/question/19714540/answer/1119070975</a><br /></li>
<li>傅里叶系列（一）傅里叶级数的推导 <a href="https://zhuanlan.zhihu.com/p/41455378">https://zhuanlan.zhihu.com/p/41455378</a><br /></li>
<li>傅里叶系列（二）傅里叶变换的推导 <a href="https://zhuanlan.zhihu.com/p/41875010">https://zhuanlan.zhihu.com/p/41875010</a><br /></li>
<li>Explanation Fourier <a href="http://www.jezzamon.com/fourier/">http://www.jezzamon.com/fourier/</a><br /></li>
<li>Fourier 变换的性质 <a href="https://zhuanlan.zhihu.com/p/148484210">https://zhuanlan.zhihu.com/p/148484210</a><br /></li>
<li>如何理解离散傅里叶变换及 Z 变换 <a href="https://zhuanlan.zhihu.com/p/45114376">https://zhuanlan.zhihu.com/p/45114376</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org2175890" class="outline-6">
<h6 id="org2175890">Ideal Sampling and Reconstruction</h6>
<div class="outline-text-6" id="text-org2175890">
<p>
使用频率空间分析，我们可以形式化地研究采样的性质。采样过程需要我们选择一组等间距的采样位置，并且计算在这些位置上函数的值。将采样过程形式化表示就是和 shah(狄拉克梳状函数)相乘，下图为该函数定义以及对应的采样过程图示：<br />
<img src="./PhysicallyBasedRendering/2020_06_18_sampling_process.jpg" alt="2020_06_18_sampling_process.jpg" /><br />
这些采样值可以用于定义一个重建函数~f(x)，只需要选择一个重建过滤函数 r(x)，然后和采样值进行卷积运算就可以了。为了重建，卷积对重建滤波在采样点中心的实例进行了加权求和缩放。<br />
下图展示了重建函数的数学描述，以及三角滤波重建的一个例子：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_reconstruction_01.jpg" alt="2020_06_19_reconstruction_01.jpg" /><br />
上面讲述的获得重建函数的过程显得不必要的复杂，直观地讲，可以通过在样本之间以某种方式插值来得到重建函数。上面形式化的表述，可以方便地在重建过程中应用 Fourier analysis。<br />
</p>

<p>
通过在频域中分析样本函数，我们可以更深入地认识采样过程。特别是，我们可以确定在怎样的条件下，可以使用样本数据精确重建原始函数。对于此处的讨论，我们假定原始函数 f(x)的带宽为有限的，也就是说存在一个频率 w0，f(x)的频率都小于 w0。带宽有限的函数，其频域表示函数为紧支撑的，也就是说，|w|&gt;w0 时，F(w) = 0。<br />
</p>

<p>
Fourier Transform 的一个重要性质是两个函数乘积的傅里叶变换为，这两个函数各自傅里叶变换后再卷积；而两个函数卷积的傅里叶变换为，这两个函数各自傅里叶变换后再相乘。通过该性质可得出，对原函数的采样，在时域空间是原函数(时域表示)和 Shah 函数的乘积，在频域空间是原函数（频域表示）和另一个 Shah 函数的卷积。周期为 T 的 Shah 函数，其频域表示(傅里叶变换)为周期为 1/T 的 Shah 函数。这说明时域空间上样本间隔越远，频域空间上样本间隔越近。<br />
<img src="./PhysicallyBasedRendering/2020_06_19_FourierTransform_Property_01.jpg" alt="2020_06_19_FourierTransform_Property_01.jpg" /><br />
</p>

<p>
频域空间的样本表示是通过 F(w)和一个新的 shah 函数的卷积得到的，将一个函数和 delta 函数卷积得到的是该函数的一个复制，所以，将函数和 shah 函数卷积的结果为无数个原函数的复制，这些复制之间的间隔为新的 shah 函数的周期(1/T)。<br />
得到无穷多个原始函数分布的复制后，我们只要保留中心在原点的副本，忽略掉其他副本就可以得到原始函数了。为了达到这个目标，我们需要使用一个 box 函数。下图为该过程(重建过程)的图示：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_reconstruction_02.jpg" alt="2020_06_19_reconstruction_02.jpg" /><br />
</p>

<p>
由此可得，我们只需要对原函数进行一系列固定间隔的采样，就可以精确得到原函数在频域空间的表示，除了需要假定原函数为带宽有限的外，不需要知道其他任何信息。<br />
在时域空间应用相同的过程将会精确重建原函数。因为 Box 函数的傅里叶逆变换为 sinc 函数，所以时域空间中理想的重建函数为：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_reconstruction_03.jpg" alt="2020_06_19_reconstruction_03.jpg" /><br />
</p>

<p>
不幸的是，sinc 函数定义域是[-Infinity, Infinity]，必须使用所有的样本值 f(i)才能计算出时域空间特定的~f(x)值。实践中，通常选择有限边界的滤波函数，尽管这会导致无法精确重建原始函数。<br />
在图形学中，通常使用 Box 函数作为滤波函数，其可以有效地在 x 附近的区域对所有样本值进行平均。从 Box 滤波函数在频率域的行为就可以看出，这是一个非常差的选择，这种技术试图通过乘一个 sinc 函数来隔离函数分布的中心副本，这不仅对于选择中心副本来说效果很差，而且还包含了其他无限多个副本的高频部分。<br />
</p>

<ul class="org-ul">
<li>如何通俗易懂地解释卷积？ <a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a><br /></li>
<li>图示卷积 <a href="https://www.desmos.com/calculator/ea96vohtuq">https://www.desmos.com/calculator/ea96vohtuq</a><br /></li>
<li>图示卷积 <a href="./PhysicallyBasedRendering/2020_06_21_convolution.ggb">./PhysicallyBasedRendering/2020_06_21_convolution.ggb</a><br /></li>
<li>图示卷积 <a href="https://www.geogebra.org/m/KMrAFBxN">https://www.geogebra.org/m/KMrAFBxN</a><br /></li>
<li>卷积神经网络的卷积核 和 数学中的卷积 <a href="https://www.zhihu.com/question/52237725">https://www.zhihu.com/question/52237725</a><br /></li>
<li>《傅里叶光学（九）》 信号采样与重建 <a href="https://zhuanlan.zhihu.com/p/72079283">https://zhuanlan.zhihu.com/p/72079283</a><br /></li>
<li>麻省理工学院公开课：信号与系统：模拟与数字信号处理 <a href="https://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fsignals.html">https://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fsignals.html</a><br /></li>
<li>实变函数中的支撑（support）是什么意思？ <a href="https://www.zhihu.com/question/329984717">https://www.zhihu.com/question/329984717</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4888013" class="outline-6">
<h6 id="org4888013">Aliasing</h6>
<div class="outline-text-6" id="text-org4888013">
<p>
除了 sinc 函数无限边界的问题外，理想采样和重建方式的另一个严重的问题是假定信号的带宽是有限的。对于那些带宽无限的信号，或者相对信号自身的频率来说采样率不足够高的信号，前面描述的重建过程会得到一个和原函数不同的函数。<br />
成功重建的关键是，将采样分布乘一个适当宽度的 Box 函数。信号的副本分布是由空格分割的，所以完美的重建是有可能的。如果对原函数的采样使用比较低的频率。这意味这时域空间中样本之间的间隔增大，频域空间中样本之间的间隔缩小，也就是 F(w)的副本之间靠的更近。如果这些副本靠的太近，他们就会重叠。下图展示了采样率太低的情况：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_aliased_01.jpg" alt="2020_06_19_aliased_01.jpg" /><br />
</p>

<p>
因为这些副本会叠加在一起，最终的分布将看起来就不像是原始函数的多个副本了。当新的分布被乘一个 box 函数，得到的分布看起来像，但不再等于原始 F(w):原始信号的高频细节漏到了重建信号分布的低频区域了。这些新的低频 artifacts 被称为 aliases（走样）(因为高频伪装成了低频)，并且结果信号被称为 aliased（走样了）。下图展示了这种走样现象：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_aliased_02.jpg" alt="2020_06_19_aliased_02.jpg" /><br />
</p>

<p>
解决频谱重叠问题的一个可行方案是简单增加采样率，直到频谱的副本分开足够远而没有重叠，这样就消除了走样。采样理论可以精确告诉我们需要多大的采样率。理论表示，当采样率大于两倍的信号最大频率，就可以完美重建原始信号。这个最小的采样率被称为 Nyquist freqqency.<br />
</p>

<p>
对于带宽无限的信号，无法通过足够高的采样率来重建。没有带宽限制的信号其频谱是无限的，所以无论如何分离这些副本，他们都始终叠在一起。不幸的是，图形学中只有少数几个有趣的函数带宽是有限的。特别是，任何不连续的函数都不是带宽有限的，因此，我们无法完美地采样和重建它们。这是有道理的，因为不连续的函数不连续的地方总是落在两个样本之间，而样本无法提供不连续的信息。因此，需要应用不同的方法来抵消这种错误。<br />
</p>
</div>
</div>

<div id="outline-container-org0452786" class="outline-6">
<h6 id="org0452786">Antialiasing Techniques</h6>
<div class="outline-text-6" id="text-org0452786">
<p>
如果不小心地采样和重建，大量的 artifacts 将在最终的图片上出现。有时候区分采样和重建导致的 artifacts 很有用，当我们希望精确区分的时候，我们称采样导致的 artifacts 为 prealiasing，而重建导致的 artifacts 为 postaliasing。任何尝试纠正这些错误的方法被统称为 antialiasing.<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orge1cce1b"></a>Nonuniform Sampling<br />
<div class="outline-text-7" id="text-orge1cce1b">
<p>
尽管我们采样的图片函数有无限多频率分量，无法从样本完美地重建，但是可以通过以非统一的方式改变样本间距来减少可视的 aliasing 影响。其形式化表示如下：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_nouniform_sampling.jpg" alt="2020_06_19_nouniform_sampling.jpg" /><br />
对于固定的采样率来说，无论是统一还是非统一采样都会得到错误的重建信号。但是，非统一采样会将规律的 aliasing artifacts 变为噪声，其会减低人类视觉系统的分散。在频域空间，样本信号的副本会随机地平移，因此重建的结果表现为随机错误而不是增强的 aliasing。<br />
</p>
</div>
</li>

<li><a id="orgdcb84e6"></a>Adaptive Sampling<br />
<div class="outline-text-7" id="text-orgdcb84e6">
<p>
另一种被推荐的减少 aliasing 的方式是 adaptive supersampling(自适应超采样)：如果我们可以识别频率高于 Nyquist 限制的区域，我们可以在这些区域增加采样而不需要在所有地方都增加采样频率。在实践中，很难采用这种方式，因为找到所有需要超采样的区域很难。大多数这样做的技术都是基于检验邻接的采样值，然后找到有明显变化的地方，假设信号在这个区域有很高的频率。<br />
一般来说，邻接样本值无法告诉我们样本之间确切是什么：即使邻接的样本值相同，函数可能在它们之间有巨大变化。另外，邻接样本值可能有明显的不同，却没有任何 aliasing 存在。<br />
</p>
</div>
</li>

<li><a id="org168f26d"></a>Prefiltering<br />
<div class="outline-text-7" id="text-org168f26d">
<p>
另一种采样理论提供的消除 aliasing 的方法为 Filter 原始函数，这样就没有高频存在了，这些高频是以当前采样率采样时无法被精确捕捉的。在第 10 章的贴图函数使用了这种方式。尽管这种技术改变了被采样函数的特点，其从原函数中移除了一部分信息，但是 blurring 通常要比 aliasing 好一些。<br />
我们可以将原始函数的频谱乘一个 Box 滤波函数，该 Box 滤波函数的宽度大于 Nyquist 限制。在时域中，对应着将原始函数和 sinc 滤波函数求卷积，f(x)。<br />
在实践中，我们可以使用一个有限范围的滤波函数。该滤波函数的频率域表示有助于阐明其是如何近似理想的 sinc 滤波函数的。<br />
下图就是一个实例：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_prefiltering.jpg" alt="2020_06_19_prefiltering.jpg" /><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org030dc98" class="outline-6">
<h6 id="org030dc98">Application To Image Synthesis</h6>
<div class="outline-text-6" id="text-org030dc98">
<p>
运用这些理论于 2D 情况下采样和重建渲染场景的图片是非常直接的。我们可以把图片当作 2D 图片位置到辐射率值 L 的函数。<br />
好消息是，使用我们的射线追踪，我们可以计算该函数在任意一点的值。坏消息是，无法在采样之前预过滤 f 函数来移除高频部分。因此，本章的采样器会使用 Nonuniform Sampling 和 Adaptive Sampling 策略。<br />
将场景函数的定义一般化为更高维度的函数是非常有用的，让其也依赖时间 t 以及其采样的镜头的位置(u,v)。因为所有的从摄像机发射的射线都基于 5 个量，改变其中任意一个都会得到不同的射线，也就可能得到不同的值。对于特定的图片位置，该点的辐射率值通常会随时间而变换(场景中有运动的物体)，也会随镜头位置而变化（如果摄像机包含一个带有限光圈的镜头）。<br />
更一般地，因为 14 到 16 章的很多积分器使用了统计技术来估算沿着给定射线的辐射量，当重复给定同一个射线时，他们可能返回一个不同的辐射率值。如果我们将来扩展了场景辐射率函数来包含积分器使用的样本值(例如，在区域光源上选择点来计算照明)我们将需要一个更高维的函数。<br />
高效采样所有这些维度是生成高质量图片重要的一部分。<br />
</p>
</div>
</div>
<div id="outline-container-org830642e" class="outline-6">
<h6 id="org830642e">Sources of Aliasing in Rendering</h6>
<div class="outline-text-6" id="text-org830642e">
<p>
几何体是渲染图片中最常见的导致 aliasing 的原因。当投影到图片平面时，对象的边缘引入了一个阶跃函数（图片函数突然从一个值跳跃为另一个值）。阶跃函数不仅有无限频率内容，而且完美重建滤波函数应用于走样的样本时会导致 artifacts：ringing artifacts 在重建函数中出现，这种效果被称为 Gibbs phenomenon（吉布斯现象）。面对 aliasing 时，选择一个有效的重建滤波函数需要结合科学、艺术以及个人品味。下图展示了吉布斯现象：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_gibbs_phenomenon.jpg" alt="2020_06_19_gibbs_phenomenon.jpg" /><br />
</p>

<p>
场景中非常小的物体也会导致几何 aliasing。如果几何体足够小其落在了样本之间，其会出乎意料的消失，在过一个动画过几帧后又会出来。<br />
</p>

<p>
另一个 aliasing 的来源为物体的贴图和材质。没有被正确过滤的贴图映射或者闪耀表面上小的亮点都可能导致渲染的 aliasing。如果采样率没有足够高，无法足够采样这些特性，结果就会 aliasing。物体投射的尖锐的阴影会引入另一种阶跃函数。尽管可以通过几何边缘在图片平面上确定阶跃函数的位置，从阴影边界来检测阶跃函数是非常难的。<br />
</p>

<p>
我们无法去掉所有导致 aliasing 的源由，所以我们必须发展技术缓和其在最终图片上的影响。<br />
</p>
</div>
</div>
<div id="outline-container-orgf350eea" class="outline-6">
<h6 id="orgf350eea">Understanding Pixels</h6>
<div class="outline-text-6" id="text-orgf350eea">
<p>
在本章剩余部分，需要铭记两个关于像素的观念。<br />
第一个：组成图片的像素是图片函数的很多点的样本，这些点样本在图片平面上为离散的点。注意一个像素关联的不是区域，将像素当作小的正方形区域是错误的模型，会导致一系列错误。<br />
第二个：最终图片上的像素被定义在像素网格上的离散整数坐标(x,y)上，但是本章的 Sampler 生成的图片样本在连续的浮点坐标(x,y)上。一种自然的在这两种不同的域上映射的方式是将连续的浮点坐标舍入为最近的离散坐标。这种方式很有吸引力，因为其会将刚好等于离散坐标值的连续的坐标映射为离散坐标。然而，结果是给定一组间隔为[x0,x1]的离散坐标，一组覆盖这个范围的连续的坐标的范围为[x0-1/2,x1+1/2).这样，为一个给定离散像素范围生成的连续样本坐标有 1/2 的偏移。<br />
按照下面方式转化离散坐标和连续坐标，离散的范围[x0,x1]会被转化为连续的范围[x0,x1+1)，这样更自然，并且使得代码更简单：<br />
<img src="./PhysicallyBasedRendering/2020_06_19_image_coord_convert.jpg" alt="2020_06_19_image_coord_convert.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4f503a" class="outline-5">
<h5 id="orgf4f503a">Sampling Interface</h5>
<div class="outline-text-5" id="text-orgf4f503a">
<p>
Sampler 类的任务是生成一个 n 维样本的序列，每个样本向量属于一个图片样本，每个样本向量的维度随光照传播算法不同而会有变化。下图展示了 Sampler 为图片样本生成的采样向量：<br />
<img src="./PhysicallyBasedRendering/2020_06_21_sampler_vector.jpg" alt="2020_06_21_sampler_vector.jpg" /><br />
</p>
</div>

<div id="outline-container-orgcc01523" class="outline-6">
<h6 id="orgcc01523">Evaluating Sample Patterns:Discrepancy</h6>
<div class="outline-text-6" id="text-orgcc01523">
<p>
傅里叶分析给我们提供了评价采样模式质量的方法，但是其只能让我们可以量化在带宽有限的情况下均匀增加更多采样所带来的改进。给定带宽无限(图片中物体边缘的地方)以及大于 2 维采样向量(Monte Carlo 光照传播算法)的情况，只使用傅里叶分析是不够的。<br />
</p>

<p>
给定一个渲染器和一个候选的放置样本的算法，一种验证该算法有效性的方法是使用其采样模式渲染一张图片，然后比较该图片和另一张使用了更多数量样本渲染得到的图片。我们将使用这种方式来比较采样算法。<br />
</p>

<p>
傅里叶分析之外，数学家发明了一种被称为 Discrepancy（差异）的概念，其可用于评估一个 n 维采样模式的质量。分布比较好的模式其具备低差异值。<br />
</p>

<p>
差异的基础理念为，可以通过下面方法来评估一组在 n 维空间[0,1)^n 上的样本点的质量，计算每个区域中样本点的数量，比较每个区域的体积和其中的样本点数量。下图在二维空间展示了这种理念：<br />
<img src="./PhysicallyBasedRendering/2020_06_21_discrepancy.jpg" alt="2020_06_21_discrepancy.jpg" /><br />
</p>

<p>
Discrepancy 的数学定义如下。关于 Discrepancy，Star Discrepancy，以及均匀分布的一维样本模式的 Star Discrepancy 请参考 知乎-PBRT-E7.2-采样接口 <a href="https://zhuanlan.zhihu.com/p/73943687">https://zhuanlan.zhihu.com/p/73943687</a> 文章的描述。<br />
<img src="./PhysicallyBasedRendering/2020_06_21_discrepancy_define.jpg" alt="2020_06_21_discrepancy_define.jpg" /><br />
</p>

<p>
只使用差异来衡量采样模式，并不是一个很好的标准。一些低差异的采样模式展现出样本的聚集。7.7 节中的 Sobol 采样就有该问题。直观地看，靠的太近的样本就是没有充分利用样本资源：一个样本越靠近另一个，那么该样本就越可能没有提供新的信息。因此计算任意两个样本的最小距离也是一个有用的衡量标准，距离越大采样模式的质量越好。<br />
</p>

<p>
有很多算法可以生成 Poisson Disk 采样模式，按照样本点距离的标准，这种模式评分很高。人眼的视杆细胞和视锥细胞就是按这种模式分布的，这进一步说明这种方法对于成像来说是一个好的模式。实践中发现 Poisson disk 模式对于 2D 图片来说非常好，但是对于高维采样来说，low discrepancy 模式要更有效。<br />
</p>

<ul class="org-ul">
<li>低差异序列（一）- 常见序列的定义及性质 <a href="https://zhuanlan.zhihu.com/p/20197323">https://zhuanlan.zhihu.com/p/20197323</a><br /></li>
<li>Star Discrepancy <a href="https://mathworld.wolfram.com/StarDiscrepancy.html">https://mathworld.wolfram.com/StarDiscrepancy.html</a><br /></li>
<li>PBRT-E7.2-采样接口 <a href="https://zhuanlan.zhihu.com/p/73943687">https://zhuanlan.zhihu.com/p/73943687</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd43b381" class="outline-6">
<h6 id="orgd43b381">Basic Sampler Interface and Implement</h6>
<div class="outline-text-6" id="text-orgd43b381">
<p>
Sampler 的实现存储了一系列当前样本的状态，例如：哪个像素被采样，样本向量的维度，等等。因此单个 Sampler 对象被多个线程并行使用时，自然会不安全。Sampler 类实现了 Clone 函数，每个线程都会克隆初始化的 Sampler 对象，每个 Sampler 对象都携带一个随机种子，这样不同的线程就会得到不同的随机数序列。在多个 image tiles 之间重用相同的随机数序列会导致 image artifacts。<br />
</p>

<p>
Sampler 实现同时处理了获取样本向量各个分量的请求，其为这些值的存储申请空间。<br />
std::vector&lt;int&gt; samples1DArraySizes;      存储请求的样本数组的大小。<br />
std::vector&lt;int&gt; samples2DArraySizes;<br />
std::vector&lt;vector&lt;Float&gt;&gt;   sampleArray1D;  存储整个像素的样本数组。<br />
std::vector&lt;vector&lt;Point2f&gt;&gt; sampleArray2D;<br />
size_t array1DOffset;   记录下一个样本对应的样本向量数组的偏移。<br />
size_t array2DOffset;<br />
</p>

<p>
Request1DArray(int n);  n 为请求访问的样本数量<br />
Request2DArray(int n);<br />
</p>

<p>
Get1DArray(int n);      获取当前样本对应的各个维度数据(样本向量)。<br />
Get2DArray(int n);<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org9e40f4f"></a>Pixel Sampler<br />
<div class="outline-text-7" id="text-org9e40f4f">
<p>
尽管一些采样算法可以很容易地递增生成每个样本向量的各个维度的值，大多数都是一次性生成一个像素的所有样本的所有维度值。PixelSampler 实现了一些基础的方法用于实现这类采样器。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">PixelSampler&#20013;&#26679;&#26412;&#25968;&#25454;&#30340;&#23384;&#20648;&#20026; sampler1D[dimension][pixelSampleIndex]&#65292;&#36825;&#26679;&#23384;&#20648;&#21487;&#20197;&#35753;&#25152;&#26377;&#26679;&#26412;&#30340;&#25351;&#23450;&#20998;&#37327;&#22312;&#20869;&#23384;&#20013;&#25490;&#21015;&#22312;&#19968;&#36215;&#65292;&#36825;&#23545;&#20110;&#29983;&#25104;&#26679;&#26412;&#25968;&#25454;&#30340;&#20195;&#30721;&#26356;&#26041;&#20415;&#12290;</span>
PixelSampler::PixelSampler(<span style="color: #ce537a; font-weight: bold;">int64_t</span> <span style="color: #7590db;">samplesPerPixel</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSampledDimensions</span>) : Sampler(samplesPerPixel) 
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; nSampledDimensions; ++i) 
    {
        samples1D.push_back(std::vector&lt;Float&gt;(samplesPerPixel));
        samples2D.push_back(std::vector&lt;Point2f&gt;(samplesPerPixel));
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306;sampler1D&#21644;sampler2D&#20844;&#29992;curPixelSampleIndex</span>
<span style="color: #bc6ec5; font-weight: bold;">Get1D</span>(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36820;&#22238; sampler1D[cur1DDimension++][curPixelSampleIndex++]</span>
<span style="color: #bc6ec5; font-weight: bold;">Get2D</span>(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36820;&#22238; sampler2D[cur2DDimension++][curPixelSampleIndex++]</span>
</pre>
</div>
</div>
</li>

<li><a id="orga43e00c"></a>Global Sampler<br />
<div class="outline-text-7" id="text-orga43e00c">
<p>
一些生成样本的算法完全不是基于像素的，而是很自然地生成分布在整个图片上的连续的样本，其会连续访问完全不同的像素（这类采样器可以高效地放置每个额外的样本，以填充 n 维样本空间中的漏洞，这自然会导致连续生成的样本分布在不同的像素中）。这些采样算法对于当前的 Sampler 接口来说是种麻烦。例如，一个采样器生成了一系列如下表所示的样本值，这些值为样本向量的前两个维度。这些样本值的每个维度都被乘以图片分辨率从而得到图片平面的样本位置（为了简化此处假设图片的分辨率为 2x3）。注意此处的采样器（HaltonSampler），一个像素的所有样本之间间隔 6 个样本。如果我们渲染图片时，每个像素使用三个样本，为了生成像素(0,0)的所有的样本，我们需要生成索引为 0,6 以及 12 的样本。<br />
</p>


<div id="orgd5c1fa2" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_22_global_sampler_01.jpg" alt="2020_06_22_global_sampler_01.jpg" /><br />
</p>
</div>

<p>
我们之前定义的 Sampler 接口，其指定了渲染像素所对应的样本，而不是反过来由样本得到被渲染的像素。但是适配当前的设计是有理由的：这种方式易于将胶片分解为多个小的 image tile，从而用于多线程渲染，这样每个线程在局部区域计算的像素可以被有效地合并到最终的图片中。因此，我们需要这些采样器生成的样本是无序的，这样对于单个像素的所有样本又是连续的。<br />
</p>

<p>
GetIndexForSample(sampleNum) 执行从当前像素和给定样本索引到全局索引的映射。例如，上图中如果 currentPixel 为(0,2)，则 GetIndexForSample(0)将返回 2，因为索引为 2 的样本为(0,2)像素区域内的第一个样本。<br />
</p>

<p>
SampleDimmension(index, dimension) 返回指定索引指定维度的样本值。注意前两个维度为偏移量，他们会被特殊处理。例如，上图中 SampleDimension(4,1) 将返回 0.333333,因为索引为 4 的样本对应的像素区域为(0,1)，所以第二维的采样值为 1.333333-1 = 0.333333<br />
</p>

<p>
非常有必要确定采样向量的哪些维度用于数组采样。前面的维度要比后面的维度有更好的质量，因此将开始的一些维度为 CameraSample 留出来很重要，因为这些样本值对最终的图片质量有重要影响。因此，从开始的维度到 arrayStartDim 用于常规的 1D 和 2D 样本值，后续的维度先被用于 1D 数组样本值，紧接着的维度用于 2D 数组样本值。最后，更高维度从 arrayEndDim 开始。<br />
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org37f7630" class="outline-5">
<h5 id="org37f7630">Stratified Sampling</h5>
<div class="outline-text-5" id="text-org37f7630">
<p>
StratifiedSampler 的关键理念是将采样区域划分为不重叠的区域，并且为每个区域取一个样本，这样我们就尽可能避免了遗漏图片的整个特征，因为保证了样本之间距离不会太近。分层越小，层数越多，采样率越高。<br />
</p>

<p>
StratifiedSampler 在每个 stratum 内选随机的位置来放置样本，该位置围绕 stratum 中心点，以 stratum 的宽高的一半为最大值进行随机。这种非一致性可以将 aliasing 转化为噪声。采样器也提供了非随机模式，其提供了一致的采样。<br />
直接将分层应用于高维采样会很快导致巨量的样本数量。例如，如果将 5D 图片(x,y,t,u,v)，lens，以及样本时间间隔在每个维度划分为 4 层，最终每个像素需要的样本数量为 4^5=1024。我们可以减少某些维度样本数量来减低这种影响，但是这会让我们丢掉分层带来的好处。我们可以获取到分层的大部分好处，而不需要大量的样本。我们只需要为域维度的子集计算低维的分层模式，然后随机地将子集的样本关联在一起。下图展示了这种方法的基础理念:我们可能只想为每个像素取 4 个样本，但是依然使得这些样本在整个维度上都是被分层的。我们独立地生成 4 个 2 维的分层图片样本，4个 1 维的分层时间样本，以及 4 个 2 维的镜头样本。然后，我们随机地选一个图片样本一个时间样本一个镜头样本，将他们关联起来得到像素的一个样本向量，这样得到的样本向量整体上对样本空间有好的覆盖。<br />
</p>


<div id="org388a7cc" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_22_stratified_sampler_01.jpg" alt="2020_06_22_stratified_sampler_01.jpg" /><br />
</p>
</div>

<p>
调用者可能会请求请求任意数量的图片样本，此时分层可能无法很容易被使用(例如，我们如何生成拥有 7 个样本的 2D 分层模式)。我们可以只是生成 nx1 或 1xn 的分层模式，但是这样只会在一个维度上得到分层的好处，其他维度无法保证也是好的模式。StratifiedSampler::RandSize()可以将请求的样本值数量舍入为一个整数的平方。<br />
另外一种可以生成任意数量样本，任意数量维度的方法为 Latinhypercube sampling(LHS).LHS 统一地将每个维度的轴分为 n 个区域，并且在每个区域沿着对角线生成一个 jitterred sample，然后，这些样本值在每个维度进行随机洗牌，这样就可以创建一个好的分布。LHS 的一个优点是将样本投影到任意维度的轴上时，减少了样本的聚集。下图展示了 LHS 的原理。除了解决样本聚集的问题，LHS 并不是对 StratifiedSampling 的优化。在实践中，随着 n 的增加，LHS 的采样模式要比 StratifiedSampling 的采样模式更差。<br />
</p>


<div id="orgfb524fd" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_22_lhs_sampler_01.jpg" alt="2020_06_22_lhs_sampler_01.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org2135d1d" class="outline-5">
<h5 id="org2135d1d">The Halton Sampler</h5>
<div class="outline-text-5" id="text-org2135d1d">
<p>
HaltonSampler 生成的点不仅可以保证不会聚集的太近，而且在采样向量的整个维度上都分布很好。<br />
</p>
</div>

<div id="outline-container-org2947767" class="outline-6">
<h6 id="org2947767">Hammersley and Halton Sequences</h6>
<div class="outline-text-6" id="text-org2947767">
<p>
Halton 和 Hammersley 序列是两种紧密相关的低差异点集。它们都基于一种被称为 radical inverse 的构造方法。这种方法的基础是任何一个正整数都可以被表示为 b 进制的数字序列。<br />
Halton 和 Hammersley 的定义可以参考原书。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #bc6ec5; font-weight: bold;">ReverseBits32</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">n</span>) 
{
    n = (n &lt;&lt; 16) | (n &gt;&gt; 16);
    n = ((n &amp; 0x00ff00ff) &lt;&lt; 8) | ((n &amp; 0xff00ff00) &gt;&gt; 8);
    n = ((n &amp; 0x0f0f0f0f) &lt;&lt; 4) | ((n &amp; 0xf0f0f0f0) &gt;&gt; 4);
    n = ((n &amp; 0x33333333) &lt;&lt; 2) | ((n &amp; 0xcccccccc) &gt;&gt; 2);
    n = ((n &amp; 0x55555555) &lt;&lt; 1) | ((n &amp; 0xaaaaaaaa) &gt;&gt; 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> n;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #bc6ec5; font-weight: bold;">ReverseBits64</span>(<span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">n</span>) 
{
    <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">n0</span> = ReverseBits32((<span style="color: #ce537a; font-weight: bold;">uint32_t</span>)n);
    <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">n1</span> = ReverseBits32((<span style="color: #ce537a; font-weight: bold;">uint32_t</span>)(n &gt;&gt; 32));
    <span style="color: #4f97d7; font-weight: bold;">return</span> (n0 &lt;&lt; 32) | n1;
}
</pre>
</div>


<p>
Hammersley 和 Halton 序列有一个缺点，就是随着基数 b 的增加，样本值会展现出极其规律的模式。这个问题可以通过扰乱（scrambled）Halton 和 Hammersley 序列来解决，在计算基数取反时对数字进行一次排列。<br />
</p>

<ul class="org-ul">
<li>低差异序列（一）- 常见序列的定义及性质 <a href="https://zhuanlan.zhihu.com/p/20197323">https://zhuanlan.zhihu.com/p/20197323</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org72467c7" class="outline-6">
<h6 id="org72467c7"><span class="todo TODO">TODO</span> HaltonSampler Implement</h6>
</div>
</div>

<div id="outline-container-org03373c1" class="outline-5">
<h5 id="org03373c1"><span class="todo TODO">TODO</span> (0,2)-Sequence Sampler</h5>
<div class="outline-text-5" id="text-org03373c1">
<p>
(0, 2)-sequences 以一种非常一般的方式进行分层。例如，开始的 16 个样本满足 StratifiedSampling 约束，这意味着在每一个（1/4, 1/4）方格内只有一个样本。而且，也符合 Latin hypercube 约束，因为只有（1/16，1）和（1，1/16）在边界上。下图展示了将空间分割为区域的所有可能情况，每种情况的(0,2)-sequence 都满足分层的属性。16 个样本的每个连续的序列也满足这些分布属性。<br />
<img src="./PhysicallyBasedRendering/2020_06_22_0-2-sequences.jpg" alt="2020_06_22_0-2-sequences.jpg" /><br />
</p>

<p>
(0,2)-Sequence 的定义<br />
</p>
</div>
</div>

<div id="outline-container-orgf8e7852" class="outline-5">
<h5 id="orgf8e7852"><span class="todo TODO">TODO</span> Maximized Minimal Distance Sampler</h5>
</div>
<div id="outline-container-org1cc2a48" class="outline-5">
<h5 id="org1cc2a48"><span class="todo TODO">TODO</span> Sobol Sampler</h5>
</div>
<div id="outline-container-orgee191a8" class="outline-5">
<h5 id="orgee191a8">Image Reconstruction</h5>
<div class="outline-text-5" id="text-orgee191a8">
<p>
给定仔细选取的图片样本，我们需要将样本和基于样本计算的辐射率值转化为像素值用于显示或者存储。依据信号处理理论，我们需要做三件事情来计算输出图片上每个像素对应的最终的值：<br />
</p>
<ol class="org-ol">
<li>依据一组图片样本重建一个连续的图片函数 ~L<br /></li>
<li>预过滤 ~L 函数，将超过 Nyquist 限制的频率移除<br /></li>
<li>在像素位置对 ~L 函数进行采样，计算该位置像素最终的像素值。<br /></li>
</ol>

<p>
采样理论的最近研究显示完美重建在实践上基本上是无法达到的。重建理论的研究目标已经从完美重建转为开发可以最小化错误的重建技术。<br />
pbrt 中使用的重建技术没有直接使用最新的方式。为了重建像素值，我们需要考虑插值特定像素附近样本的问题。可以通过如下公式计算像素 I(x,y)最终的值：<br />
<img src="./PhysicallyBasedRendering/2020_06_22_reconstruct_equition.jpg" alt="2020_06_22_reconstruct_equition.jpg" /><br />
</p>

<p>
下图展示了一个位于(x,y)处的像素，其对应的像素过滤器在 x 方向上的范围为 radius.x，在 y 方向上的范围为 radius.y.在这个过滤器 Box 内的所有样本都可能对像素值有贡献，这依赖于过滤器函数 f(x-xi,y-yi)的值。<br />
<img src="./PhysicallyBasedRendering/2020_06_22_reconstruct_example.jpg" alt="2020_06_22_reconstruct_example.jpg" /><br />
</p>

<p>
sinc 过滤函数不是合适的选择，因为当有频率超过 Nyquist limit，其会导致 Gibbs phenomenon。而且 sinc 函数最终不会在有限的距离内下降为 0。实践上，并没有一个最好的过滤函数。对于特定的场景，选择最好的滤波函数需要综合定性评估和定性判断。<br />
</p>

<p>
下图展示了本节讨论的 Filter 函数的图形：<br />
<img src="./PhysicallyBasedRendering/2020_06_22_filter_functions.jpg" alt="2020_06_22_filter_functions.jpg" /><br />
</p>

<p>
BoxFilter 为图形学中最常见的过滤函数之一。BoxFilter 对图片的方形区域内的所有样品取相等的权重。尽管计算高效，但是其可能为最糟糕的过滤器。BoxFilter 会让高频样本数据泄露到重建的值中。这导致了 postaliasing(即使原始样本值有足够高的频率来避免 aliasing，错误依然由糟糕的过滤器引入了)<br />
下图展示了 BoxFilter 用于重建两个 1D 函数的结果：<br />
<img src="./PhysicallyBasedRendering/2020_06_22_box_filter.jpg" alt="2020_06_22_box_filter.jpg" /><br />
</p>

<p>
TriangleFilter 比 BoxFilter 要稍微好一些。在过滤器中心的样本点的权重为 1，权重从过滤器从中心到边界线性变小。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">TriangleFilter</span>::Evaluate(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;p) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> std::max((<span style="color: #ce537a; font-weight: bold;">Float</span>)0, radius.x - std::abs(p.x)) *
           std::max((<span style="color: #ce537a; font-weight: bold;">Float</span>)0, radius.y - std::abs(p.y));
}
</pre>
</div>

<p>
GaussianFilter 比 BoxFilter 和 TriangleFilter 都要好。下图为 1D 高斯过滤器函数:<br />
<img src="./PhysicallyBasedRendering/2020_06_22_gaussian_filter.jpg" alt="2020_06_22_gaussian_filter.jpg" /><br />
<a href="./PhysicallyBasedRendering/gaussian_filter.ggb">./PhysicallyBasedRendering/gaussian_filter.ggb</a><br />
</p>

<p>
MitchellFilter<br />
Mitchell 和 Netravali 开发了一系列参数化的滤波函数用于系统的研究 Filter 的设计。通过分析测试对象对图形过滤后的主观反应，他们开发了一个滤波器，其试图在 ringing 和 blurring 之间找到平衡。<br />
该函数定义如下，其有两个系数 B 和 C，这两个系数可以任意选取，Mitchell 建议这两个系数在直线 B+2C=1 上。<br />
<img src="./PhysicallyBasedRendering/2020_06_22_mitchell_filter.jpg" alt="2020_06_22_mitchell_filter.jpg" /><br />
</p>

<p>
Windowed Sinc Filter<br />
</p>

<p>
非归一化 sinc 函数： sinc(x) = sin(x)/x<br />
归一化 sinc 函数  ： sinc(x) = sin(x&pi;)/(x&pi;)<br />
</p>

<p>
Lanczos window 只是 sinc 函数中心的波瓣，Lanczos window 和 sinc 函数相乘得到 LanczosSincFilter 函数。下图为 Lanczos window 函数：<br />
</p>

<p>
<img src="./PhysicallyBasedRendering/2020_06_21_lanczos_sinc.jpg" alt="2020_06_21_lanczos_sinc.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_06_21_lanczos_sinc_01.jpg" alt="2020_06_21_lanczos_sinc_01.jpg" /><br />
<a href="./PhysicallyBasedRendering/2020_06_21_lanczos_sinc_01.ggb">./PhysicallyBasedRendering/2020_06_21_lanczos_sinc_01.ggb</a><br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">LanczosSincFilter</span>::<span style="color: #bc6ec5; font-weight: bold;">Sinc</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">x</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
      x = <span style="color: #a45bad;">std</span>::abs(x);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (x &lt; 1e-5) <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::sin(Pi * x) / (Pi * x);
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">radius &#25511;&#21046;Filter&#30340;&#21322;&#24452;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tau &#25511;&#21046;Filter&#30340;&#21608;&#26399;</span>
  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">LanczosSincFilter</span>::<span style="color: #bc6ec5; font-weight: bold;">WindowedSinc</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">radius</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
      x = <span style="color: #a45bad;">std</span>::abs(x);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (x &gt; radius) <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">lanczos</span> = Sinc(x / tau);
      <span style="color: #4f97d7; font-weight: bold;">return</span> Sinc(x) * lanczos;
  }
</pre>
</div>

<ul class="org-ul">
<li>sinc 函数 <a href="https://baike.baidu.com/item/sinc%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/sinc%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7621eaf" class="outline-5">
<h5 id="org7621eaf">Film and The imaging pipeline</h5>
<div class="outline-text-5" id="text-org7621eaf">
<p>
摄像机的传感器或胶片有一个神奇的效果，其可以将入射光转化为带颜色的图片。pbrt 中，Film 类就是对传感器的建模。每个摄像机射线对应的辐射率被计算出来后，Film 的实现确定了胶片上每个像素周围的样本对该像素的贡献，然后更新其所表示的图片。当渲染主循环结束后，Film 类会将最终的图片写入到一个文件中。<br />
</p>
</div>
<div id="outline-container-orgd0b05cc" class="outline-6">
<h6 id="orgd0b05cc">Film Class</h6>
<div class="outline-text-6" id="text-orgd0b05cc">
<p>
crop window 指定了实际被存储和写出的像素的边界。Crop window 有利于调试，并且将大图片划分为多个小图使其可以在多个电脑上被渲染。Crop window 为 NDC 空间的坐标值。<br />
<img src="./PhysicallyBasedRendering/2020_06_22_crop_window.jpg" alt="2020_06_22_crop_window.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Pixel</span>
  {
    <span style="color: #bc6ec5; font-weight: bold;">Pixel</span>() { xyz[0] = xyz[1] = xyz[2] = filterWeightSum = 0; }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36816;&#34892;&#26102;&#23545;&#20687;&#32032;&#26377;&#36129;&#29486;&#30340;&#20809;&#35889;&#26435;&#37325;&#21644;&#34987;&#34920;&#31034;&#20026;XYZ&#39068;&#33394;&#24182;&#19988;&#34987;&#23384;&#20648;&#22312;Pixel&#23545;&#35937;&#30340;xyz&#25104;&#21592;&#21464;&#37327;&#20013;</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">xyz</span>[3];
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">filterWeightSum&#23384;&#20648;&#20102;&#26679;&#26412;&#23545;&#20687;&#32032;&#36129;&#29486;&#30340;&#36807;&#28388;&#22120;&#26435;&#37325;&#21644;</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">filterWeightSum</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">splatXYZ&#23384;&#20648;&#20102;&#26080;&#26435;&#37325;&#30340;&#26679;&#26412;&#21644;</span>
    <span style="color: #ce537a; font-weight: bold;">AtomicFloat</span> <span style="color: #7590db;">splatXYZ</span>[3];
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#25104;&#21592;&#27809;&#26377;&#23454;&#38469;&#29992;&#36884;&#65292;&#21482;&#26159;&#30830;&#20445;Pixel&#23545;&#35937;&#20026;32&#23383;&#33410;&#32780;&#19981;&#26159;28&#23383;&#33410;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#21487;&#20197;&#35753;Pixel&#23545;&#35937;&#22312;cache&#20013;&#23545;&#40784;&#65292;&#36991;&#20813;&#32531;&#23384;&#22833;&#36133;</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">pad</span>;
  };

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23384;&#20648;Film&#23545;&#24212;&#30340;&#20687;&#32032;&#25968;&#25454;</span>
  std::unique_ptr&lt;Pixel[]&gt; Film::pixels;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">filter &#39044;&#35745;&#31639;&#20540;&#34920;</span>
  <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">filterTableWidth</span> = 16;
  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">filterTable</span>[filterTableWidth*filterTableWidth];
</pre>
</div>
<p>
选择 XYZ 颜色而不是 RGB 是为了强调 XYZ 是独立于显示器的颜色表示方式，而 RGB 需要假定一组特定的显示器响应曲线。<br />
</p>

<p>
Film 预计算了一个过滤器值表，从而可以避免耗时的虚函数 Filter::Evaluate()调用。没有用每个样本的精确位置来计算过滤器值会引入一些错误，但是实践上这种错误并不明显。<br />
Film 的责任是确定整数像素值的范围，Sampler 的责任是为这些像素值生成样本。Film::GetSampleBounds 返回被采样的区域，因为像素重建过滤器通常跨越多个像素，因此 Sampler 生成的图片样本必须稍为超出被输出的像素的范围。这样即使是边界处的像素也会有相同的样本密度。这对于通过 crop windows 一片一片渲染图片来说也很重要，其避免了子图片边界处的 artifacts。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Bounds2i</span> <span style="color: #bc6ec5; font-weight: bold;">Film</span>::GetSampleBounds() <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Bounds2f</span> <span style="color: #bc6ec5; font-weight: bold;">floatBounds</span>(Floor(Point2f(croppedPixelBounds.pMin) +
                               Vector2f(0.5f, 0.5f) - filter-&gt;radius),
                         Ceil(Point2f(croppedPixelBounds.pMax) -
                              Vector2f(0.5f, 0.5f) + filter-&gt;radius));
    <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #ce537a; font-weight: bold;">Bounds2i</span>)floatBounds;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6193138" class="outline-6">
<h6 id="org6193138">Supplying Pixel Values To The Film</h6>
<div class="outline-text-6" id="text-org6193138">
<p>
有三种方式将样本的贡献提供给胶片。第一种方式是由 Sampler 在图片的 tiles 上生成的样本驱动的。尽管这种最简单直接的方法允许渲染器提供一个胶片像素位置以及一个直接指向胶片像素的射线携带的光谱，但是在多线程下无法为这种方式提供一个高效的实现，因为这种情况下多个线程可能会同时更新图片的同一部分。<br />
</p>

<p>
Film 定义了一个接口，多个线程可以指定其生成的样本在某个像素范围。给定样本范围，GetFileTile()返回指向 FileTile 对象的指针，FileTile 中存储了在对应区域中，样本对该区域像素的贡献。FileTile 和其存储的数据对于调用者来说是独自占有的，因此线程可以提供样本值给 FilmTile 而不需要担心其他线程争夺。当线程在 tile 上的工作完成后，其会将完成的 tile 传回给 Film，Film 会将 tile 合并到最终的图片中。<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pFilm&#20026;&#33014;&#29255;&#19978;&#26679;&#26412;&#30340;&#20301;&#32622;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">L&#20026;&#35813;&#26679;&#26412;&#23545;&#24212;&#30340;&#36752;&#23556;&#29575;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sampleWeight &#20026;&#35813;&#26679;&#26412;&#30340;&#26435;&#37325;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FilmTile</span>::<span style="color: #bc6ec5; font-weight: bold;">AddSample</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;pFilm, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;L, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">sampleWeight</span> = 1.)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#24403;&#21069;&#26679;&#26412;&#24433;&#21709;&#30340;&#20687;&#32032;&#21306;&#22495;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute sample's raster bounds</span>
      <span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #7590db;">pFilmDiscrete</span> = pFilm - <span style="color: #bc6ec5; font-weight: bold;">Vector2f</span>(0.5f, 0.5f);
      <span style="color: #ce537a; font-weight: bold;">Point2i</span> <span style="color: #7590db;">p0</span> = (<span style="color: #ce537a; font-weight: bold;">Point2i</span>)<span style="color: #bc6ec5; font-weight: bold;">Ceil</span>(pFilmDiscrete - filterRadius);
      <span style="color: #ce537a; font-weight: bold;">Point2i</span> <span style="color: #7590db;">p1</span> = (<span style="color: #ce537a; font-weight: bold;">Point2i</span>)<span style="color: #bc6ec5; font-weight: bold;">Floor</span>(pFilmDiscrete + filterRadius) + <span style="color: #bc6ec5; font-weight: bold;">Point2i</span>(1, 1);
      p0 = <span style="color: #bc6ec5; font-weight: bold;">Max</span>(p0, pixelBounds.pMin);
      p1 = <span style="color: #bc6ec5; font-weight: bold;">Min</span>(p1, pixelBounds.pMax);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Loop over filter support and add sample to pixel arrays</span>
    
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#39044;&#35745;&#31639;&#23545;&#20110;&#27599;&#20010;&#20687;&#32032;&#35813;&#26679;&#26412;&#23545;&#24212;&#30340;&#36807;&#28388;&#22120;&#26435;&#37325;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Precompute $x$ and $y$ filter table offsets</span>
      <span style="color: #ce537a; font-weight: bold;">int</span> *ifx = <span style="color: #bc6ec5; font-weight: bold;">ALLOCA</span>(<span style="color: #ce537a; font-weight: bold;">int</span>, p1.x - p0.x);
      <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">x</span> = p0.x; x &lt; p1.x; ++x)
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#25214;&#34920;&#32034;&#24341;&#35745;&#31639;&#26041;&#27861; distance / Radius * filterTableWidth</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">filterTableWidth = filterTableHeight = filterTableSize</span>
          <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">fx</span> = std::<span style="color: #bc6ec5; font-weight: bold;">abs</span>((x - pFilmDiscrete.x) * invFilterRadius.x * filterTableSize);
          ifx[x - p0.x] = std::<span style="color: #bc6ec5; font-weight: bold;">min</span>((<span style="color: #ce537a; font-weight: bold;">int</span>)std::<span style="color: #bc6ec5; font-weight: bold;">floor</span>(fx), filterTableSize - 1);
      }
      <span style="color: #ce537a; font-weight: bold;">int</span> *ify = <span style="color: #bc6ec5; font-weight: bold;">ALLOCA</span>(<span style="color: #ce537a; font-weight: bold;">int</span>, p1.y - p0.y);
      <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">y</span> = p0.y; y &lt; p1.y; ++y)
      {
          <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">fy</span> = std::<span style="color: #bc6ec5; font-weight: bold;">abs</span>((y - pFilmDiscrete.y) * invFilterRadius.y * filterTableSize);
          ify[y - p0.y] = std::<span style="color: #bc6ec5; font-weight: bold;">min</span>((<span style="color: #ce537a; font-weight: bold;">int</span>)std::<span style="color: #bc6ec5; font-weight: bold;">floor</span>(fy), filterTableSize - 1);
      }

      <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">y</span> = p0.y; y &lt; p1.y; ++y)
      {
          <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">x</span> = p0.x; x &lt; p1.x; ++x)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Evaluate filter value at $(x,y)$ pixel</span>
              <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">offset</span> = ify[y - p0.y] * filterTableSize + ifx[x - p0.x];
              <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">filterWeight</span> = filterTable[offset];

              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#36807;&#28388;&#21518;&#30340;&#26679;&#26412;&#23545;&#20110;&#20687;&#32032;&#30340;&#36129;&#29486;</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update pixel values with filtered sample contribution</span>
              FilmTilePixel &amp;pixel = <span style="color: #bc6ec5; font-weight: bold;">GetPixel</span>(<span style="color: #bc6ec5; font-weight: bold;">Point2i</span>(x, y));
              pixel.contribSum += L * sampleWeight * filterWeight;
              pixel.filterWeightSum += filterWeight;
          }
      }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org883bbaa" class="outline-6">
<h6 id="org883bbaa">Image output</h6>
<div class="outline-text-6" id="text-org883bbaa">
<p>
给定显示设备的响应特性，可以将像素值从设备独立的 XYZ 值转化为依赖于设备的 RGB 值。这种转化对应于另一种光谱基的改变，新的基是由显示设备的光谱响应曲线决定的。此处，从 XYZ 到设备 RGB 的转化使用的权重是基于 sRGB 的。sRGB 是标准的颜色空间，其被所有显示设备和打印设备所支持。<br />
</p>

<p>
随着输出的 RGB 值被初始化，最终的值由，计算像素过滤方程得到即 contribSum/filterWeightSum。这个转变可能会导致 RGB 值的某些分量为负值；这些是色域外的颜色，其无法被选择的显示基色表示。有多种方案可以解决该问题，例如，将值截断到 0，或者偏移所有分量使其落在色域内，或者基于所有的像素执行一个全局的优化。重建的像素也可能会为负值，这是由于重建过滤函数中存在负波瓣。此处，将颜色值截断为 0 来解决同时这两种情况导致的负值。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd6f533f" class="outline-3">
<h3 id="orgd6f533f">Part 3 Light And Scatter</h3>
<div class="outline-text-3" id="text-orgd6f533f">
</div>
<div id="outline-container-orgef8afce" class="outline-4">
<h4 id="orgef8afce">8 Reflection models</h4>
<div class="outline-text-4" id="text-orgef8afce">
<p>
表面反射模型的来源：<br />
</p>
<ol class="org-ol">
<li>测量数据：很多真实世界中的反射数据都已经被测量。这些数据可以直接被以表格的形式被使用，或者可用于计算一系列基础函数的系数。<br /></li>
<li>现象模型：尝试描述真实世界表面属性的方程对于模拟表面反射显然很有效。这种类型的 BSDFs 特别易于使用，因为他们使用的都是直观的参数(例如，roughness)。<br /></li>
<li>模拟：有时候，组成表面的底层信息是知道的。例如，我们知道图画是由颜色颗粒浮在媒介上组成的，表面的反射属性都是知道的。这种情况下，可以通过生成反射数据来模拟光线的散射。这种模拟可以在渲染期间执行，也可以通过预处理来执行。随后，其使用于一组基础函数，可在渲染期间使用。<br /></li>
<li>物理光学：使用详细的光学模型可以推导出反射模型，将光当作一种波并使用 Maxwell 方程进行求解，从而得到光在表面如何反射。这种模型计算非常昂贵，但是对于渲染应用来说没有明显地比基于几何光学的模型更精确。<br /></li>
<li>几何光学：类似模拟方式。如果已知表面的底层散射属性和几何属性，可以导出封闭式的反射模型。几何光学更易于追踪模拟光和表面的交互，因为极化等复杂的波效应被忽略了。<br /></li>
</ol>

<p>
表面的反射可以被分为四种类型：diffuse，glossy specular, perfect specular, retro-reflective. 如下图所示。大多数真实表面的反射展现出的是这四种类型的混合。<br />
<img src="./PhysicallyBasedRendering/2020_06_23_reflection_categorized.jpg" alt="2020_06_23_reflection_categorized.jpg" /><br />
</p>

<p>
给定反射的类型，反射的分布函数可能是 isotropic 也可能是 anisotropic。大多数对象是各项同性的：选择表面上一点，绕法线轴旋转该点，反射光线的分布是不变的。与此相反，各向异性材质反射不同总量的光到不同的方向。<br />
</p>

<p>
需要注意 pbrt 中如下一些惯例和细节：<br />
</p>
<ol class="org-ol">
<li>入射光方向 wi 以及出射的视角方向 wo 被变换到表面的本地坐标系后都会被单位化，并且都指向外面。<br /></li>
<li>表面法线总是指向物体的外面，这样可以很容易确定光是进入还是离开物体：如果光方向和法线在同一个半球内，则光线进入物体。否则光线离开物体。pbrt 没有像很多其他渲染器那样，对法线进行反向使得法线和 wo 在同一边。<br /></li>
<li>用于渲染的本地坐标系和 Shape::Intersect 函数使用的坐标系不完全一样。其可被修改来达到 bump mapping 的效果。<br /></li>
<li>BRDF 和 BTDF 的实现不应该关心 wi 和 wo 是否在同一个半球内。<br /></li>
</ol>
</div>
<div id="outline-container-orgbbea66c" class="outline-5">
<h5 id="orgbbea66c">Basic Interface</h5>
<div class="outline-text-5" id="text-orgbbea66c">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">BxDF</span>::<span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>
<p>
给定一对入射光方向和反射光方向，计算此时 bxdf 的值（但考虑了反射光谱分布）。例如：MicrofacetReflection::f() 返回的值为 R * DGF/(4*cosThetaI*cosThetaO)<br />
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">BxDF</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample_f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;<span style="color: #7590db;">sample</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>, <span style="color: #ce537a; font-weight: bold;">BxDFType</span> *<span style="color: #7590db;">sampledType</span> = <span style="color: #a45bad;">nullptr</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>;
<span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">MicrofacetTransmission</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample_f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;<span style="color: #7590db;">u</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>, <span style="color: #ce537a; font-weight: bold;">BxDFType</span> *<span style="color: #7590db;">sampledType</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (wo.z == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> 0.;
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wh</span> = distribution-&gt;Sample_wh(wo, u);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">eta</span> = CosTheta(wo) &gt; 0 ? (etaA / etaB) : (etaB / etaA);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>Refract(wo, (<span style="color: #ce537a; font-weight: bold;">Normal3f</span>)wh, eta, wi)) <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
    *pdf = Pdf(wo, *wi);
    <span style="color: #4f97d7; font-weight: bold;">return</span> f(wo, *wi);
}

<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">BxDF</span>::<span style="color: #bc6ec5; font-weight: bold;">Pdf</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> SameHemisphere(wo, wi) ? AbsCosTheta(wi) * InvPi : 0;
}
</pre>
</div>
<p>
给定反射光方向时，计算对应的入射光方向以及此时的 BxDF 值。例如：MicrofacetReflection::Sample_f() 返回的值为 MicrofacetReflection::f()<br />
对于完美镜面物体(如：镜子，玻璃，水)，这些物体只会将一个入射方向的光散射到一个出射方向。这类 BxDFs 最好使用 delta 分布(在特定值处不为零，其他都为另)来描述。BxDF::Sample_f()用于处理 delta 分布描述的散射，也用于处理散射光沿多个方向时，需要随机采样方向的情况（MonteCarlo BSDF 采样）。<br />
</p>
</div>

<div id="outline-container-org6e8ca51" class="outline-6">
<h6 id="org6e8ca51">reflectance</h6>
<div class="outline-text-6" id="text-org6e8ca51">
<p>
考虑 4 维 BRDF 或 BTDF 聚合行为是很有用的。定义一个在多对方向上的函数，然后将其降低为只在一个方向上的 2D 函数来描述整体的散射行为。<br />
<a id="orgb61ffaf"></a><br />
Hemispherical-directional reflectance (半球-方向 反射)为一个 2D 函数，对于半球空间上为常量照明的情况下，其可以给出在给定方向上的总的反射。等价地，其可以给出由于从给定方向上的入射光导致的在半球空间上的整体反射。其定义如下：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_hemispherical-directional-reflectance.jpg" alt="2020_06_24_hemispherical-directional-reflectance.jpg" /><br />
推导：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_hemispherical-directional-reflectance_01.jpg" alt="2020_06_24_hemispherical-directional-reflectance_01.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">rho &#23601;&#26159;&#24076;&#33098;&#23383;&#27597;&#30340; \rho &#35835;&#8220;&#32905;&#8221; &#34920;&#31034; reflectance ^_^</span>
BxDF::rho(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSamples</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples</span>)
</pre>
</div>

<p>
<a id="orgd2743c0"></a><br />
Hemispherical-hemispherical reflectance（半球-半球 反射）当入射光在各个方向上都相同时，其可以给出被表面反射的入射光部分。其定义如下：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_hemispherical-hemispherical-reflectance.jpg" alt="2020_06_24_hemispherical-hemispherical-reflectance.jpg" /><br />
推导：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_hemispherical-hemispherical-reflectance_01.jpg" alt="2020_06_24_hemispherical-hemispherical-reflectance_01.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c">BxDF::rho(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSamples</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples1</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples2</span>) 
</pre>
</div>


<div id="org1c2be9c" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_24_hd_hh_reflectance.jpg" alt="2020_06_24_hd_hh_reflectance.jpg" /><br />
</p>
</div>

<p>
Tips: 此处的 \(\rho\) 描述的是某种光照情况下整体的散射行为。<br />
</p>
<ul class="org-ul">
<li>\(\rho_{hd}\) 表示入射光为特定方向，反射光在半球空间均匀分布的情况下，此时的反射率。或者入射光在半球空间均匀分布，出射光为特定方向<br /></li>

<li>Reflectance <a href="https://en.wikipedia.org/wiki/Reflectance">https://en.wikipedia.org/wiki/Reflectance</a><br /></li>

<li>pbr 中什么时候调用 rho？<br />
pbr 中由 BSDF::rho 依次调用其包含的 BxDF::rho，但是源代码中并没有调用 BSDF::rho 的地方。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5919fa4" class="outline-5">
<h5 id="org5919fa4">Specular Reflection And Transmission</h5>
<div class="outline-text-5" id="text-org5919fa4">
<p>
光在光滑的完美表面上的行为，使用物理和几何光学模型非常容易分析和描述。这些表面展现了入射光完美的镜面反射和透射。给定入射方向 wi 方向，所有的光都被散射到单个出射方向 wo。<br />
对于镜面反射来说:<br />
 \(\theta_i = \theta_o\)<br />
 \(\phi_o = \phi_i + \pi\)<br />
对于透射来说:<br />
 \(\phi_o = \phi_i + \pi\)<br />
 \(\eta_i*sin(\theta_i)=\eta_t*sin(\theta_t)\)<br />
</p>

<p>
通常折射率会随光的波长而变化。因此入射光在两种介质的边界处会被散射到多个方向，这种现象被称为色散(dispersion)。实践中通常会忽略这种波长依赖性，因为这种效果通常来说对于视觉精确性并不重要，而且这极大简化了光的传播计算。<br />
</p>
</div>

<div id="outline-container-org2f26053" class="outline-6">
<h6 id="org2f26053">Fresnel Reflectance</h6>
<div class="outline-text-6" id="text-org2f26053">
<p>
除了反射和透射方向，计算入射光的反射和透射量也很重要。菲涅尔方程描述了表面反射的光的量。菲涅尔方程为 Maxwell 方程在光滑表面下求解出来的。<br />
</p>

<p>
不同材质分类：<br />
</p>
<ol class="org-ol">
<li>dielectrics 电介质。这种材质不会导电。<br />
  他们的折射率为实数，通常其折射率范围为 1 到 3。<br />
这种材质会透射一部分照明。典型的电介质有玻璃，石油，水以及空气。<br /></li>
<li>导体。这种材质中，价电子可以在其原子晶格内自由移动，从而使电流从一个地方流到另一个地方。当导体受到电磁辐射(如可见光)时，其行为会非常不同于电介质：<br />
材质会表现为不透明。会反射回明显的一部分光。另一部分光会进入导体内部，并被很快吸收（通常在材质表面 0.1 微米内就被完全吸收了，因此只有从非常薄的金属透过的光才能被可感知到）。因此在 pbrt 中忽略导体的透射。<br />
和电介质不同，导体的折射率为复数。n' = n + ik<br /></li>
<li>半导体。硅、锗等属于半导体。pbrt 中不考虑这种材质。<br /></li>
</ol>

<p>
导体和电介质都遵循相同的菲涅尔方程。尽管如此，我们更倾向于为电介质创建一个特殊的方程，从而从这种特定的简单形式中获得便利。<br />
下图为电介质对应的菲涅尔方程：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_dielectric_fresnel_equation.jpg" alt="2020_06_24_dielectric_fresnel_equation.jpg" /><br />
</p>

<p>
下图为部分电介质的折射率：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_index_of_refraction.jpg" alt="2020_06_24_index_of_refraction.jpg" /><br />
</p>

<p>
当光从一种介质 A 到达另一种折射率比较低的介质 B，在入射角接近 90 度时，将没有光进入介质 B。发生这种全反射的最小入射角被称为临界角。当入射角大于临界角时，发生全反射，此时不需要计算菲涅尔方程。<br />
</p>

<p>
电介质和导体边界处的菲涅尔方程为：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_conduct_fresnel_equation.jpg" alt="2020_06_24_conduct_fresnel_equation.jpg" /><br />
</p>

<p>
<a id="org5cc72ab"></a> FrDielectric(Float cosThetaI, Float etaI, float etaT) 函数用来为电介质材质计算 Fresnel 反射公式。<br />
<a id="org36d109a"></a> FrConductor(Float cosThetaI, cost Spectrum &amp;etai, const Spectrum &amp;etat, const Spectrum &amp;k) 函数用来为导体材质计算 Fresnel 反射公式。<br />
方便起见，实现了 Fresnel FresnelConductors FresnelDielectrics 三个类来用于计算菲涅尔反射的系数：<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Fresnel</span> {
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fresnel Interface</span>
    <span style="color: #4f97d7; font-weight: bold;">virtual</span> ~<span style="color: #bc6ec5; font-weight: bold;">Fresnel</span>();
    <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosI</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
    <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">ToString</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
  };

  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">FresnelConductor</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Fresnel</span> {
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosThetaI</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
      <span style="color: #4f97d7; font-weight: bold;">return</span> FrConductor(<span style="color: #a45bad;">std</span>::abs(cosThetaI), etaI, etaT, k);
    }
    <span style="color: #bc6ec5; font-weight: bold;">FresnelConductor</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">etaI</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">etaT</span>,
                     <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">k</span>)
      : etaI(etaI), etaT(etaT), k(k) {}
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">ToString</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
  <span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">etaI</span>, <span style="color: #7590db;">etaT</span>, <span style="color: #7590db;">k</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">FresnelDielectric</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Fresnel</span> {
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosThetaI</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
      <span style="color: #4f97d7; font-weight: bold;">return</span> FrDielectric(cosThetaI, etaI, etaT);
    }
    <span style="color: #bc6ec5; font-weight: bold;">FresnelDielectric</span>(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaI</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaT</span>) : etaI(etaI), etaT(etaT) {}
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">ToString</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;

  <span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaI</span>, <span style="color: #7590db;">etaT</span>;
  };
</pre>
</div>

<p>
下图展示了 Gold 的折射率实数部分和虚数部分，这两个值都和波长相关：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_gold_index_of_refraction.jpg" alt="2020_06_24_gold_index_of_refraction.jpg" /><br />
</p>

<ul class="org-ul">
<li>菲涅耳方程 <a href="https://zhuanlan.zhihu.com/p/31534769">https://zhuanlan.zhihu.com/p/31534769</a><br /></li>
<li>什么是偏振光？<a href="http://www.coozhi.com/shenghuojiaju/shenghuochangshi/110199.html">http://www.coozhi.com/shenghuojiaju/shenghuochangshi/110199.html</a><br /></li>
</ul>


<p>
可以通过 Schlick's approximation 来近似计算菲涅尔方程：<br />
 \(F = F0 + (1-F0)(1-cos(I))^5\)<br />
 \(F0 = ((n1-n2)/(n1+n2))^2\)<br />
</p>

<p>
I  为入射角<br />
F0 为入射角为 0 时，菲涅尔方程的值<br />
入射角很大时，Fresnel 现象会很明显，此时 Fresnel 值几乎为 1。上面的 Schlick 近似可以看作是对 I=0 （F=F0）和 I=90 (F=1)时的插值，只不过插值方式不是线性的。<br />
</p>


<div id="org804307c" class="figure">
<p><img src="./PhysicallyBasedRendering/schlick_fresnel_is_lerp.jpg" alt="schlick_fresnel_is_lerp.jpg" /><br />
</p>
</div>

<p>
<img src="./PhysicallyBasedRendering/conductor_f0.jpg" alt="conductor_f0.jpg" /><br />
<img src="./PhysicallyBasedRendering/dielectric_f0.jpg" alt="dielectric_f0.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org68d5847" class="outline-6">
<h6 id="org68d5847">Specular Reflection</h6>
<div class="outline-text-6" id="text-org68d5847">

<div id="org7b79cad" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_24_specular_reflectance.jpg" alt="2020_06_24_specular_reflectance.jpg" /><br />
</p>
</div>

<p>
Tips:<br />
完美镜面反射下，fr(双向反射分布函数)和 Fr(菲涅尔方程)并不相等！双向反射分布函数是 dLo 和 dEi 的比值，其需要考虑所有入射光方向综合的情况。菲涅尔方程是 dLo 和 dLi 的比值，其不需要考虑各个方向综合的情况。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SpecularReflection BxDF &#20026; &#21453;&#23556;+&#23436;&#32654;&#38236;&#38754;</span>
<span style="color: #bc6ec5; font-weight: bold;">SpecularReflection</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;R, <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span>) 
: BxDF(BxDFType(BSDF_REFLECTION | BSDF_SPECULAR)),
  R(R),
  fresnel(fresnel) {}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110;&#20219;&#24847;&#32473;&#23450;&#30340;&#20837;&#23556;&#26041;&#21521;&#21644;&#20986;&#23556;&#26041;&#21521;&#65292;&#27809;&#26377;&#21453;&#23556;</span>
<span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularReflection</span>::f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0.f);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20110;&#32473;&#23450;&#20986;&#23556;&#26041;&#21521;&#65292;&#36820;&#22238;&#26399;&#26395;&#30340;&#20837;&#23556;&#20809;&#26041;&#21521;&#65292;&#20197;&#21450;&#21453;&#23556;&#30340;&#20809;&#35889;</span>
<span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularReflection</span>::Sample_f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>,
                                      <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;sample, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>,
                                      <span style="color: #ce537a; font-weight: bold;">BxDFType</span> *<span style="color: #7590db;">sampledType</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute perfect specular reflection direction</span>
    *wi = Vector3f(-wo.x, -wo.y, wo.z);
    *pdf = 1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> fresnel-&gt;Evaluate(CosTheta(*wi)) * R / AbsCosTheta(*wi);
}

</pre>
</div>
</div>
</div>
<div id="outline-container-orgb4fe418" class="outline-6">
<h6 id="orgb4fe418">Specular Transmission</h6>
<div class="outline-text-6" id="text-orgb4fe418">

<div id="org7798742" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_24_specular_transmit.jpg" alt="2020_06_24_specular_transmit.jpg" /><br />
</p>
</div>

<p>
镜面透射向量通过折射定律来获得：<br />
</p>
<ul class="org-ul">
<li>折射定律 <a href="https://baike.baidu.com/item/%E6%8A%98%E5%B0%84%E5%AE%9A%E5%BE%8B">https://baike.baidu.com/item/%E6%8A%98%E5%B0%84%E5%AE%9A%E5%BE%8B</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SpecularTransmission &#30340;BxDF&#31867;&#22411;&#20026; &#36879;&#23556;+&#23436;&#32654;&#38236;&#38754;</span>
<span style="color: #bc6ec5; font-weight: bold;">SpecularTransmission</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;T, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaA</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaB</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>)
: BxDF(BxDFType(BSDF_TRANSMISSION | BSDF_SPECULAR)),
  T(T),
  etaA(etaA),
  etaB(etaB),
  fresnel(etaA, etaB),
  mode(mode) {}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf805b91" class="outline-6">
<h6 id="orgf805b91">Fresnel-Modulated Specular Reflection and Transmission</h6>
<div class="outline-text-6" id="text-orgf805b91">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">FresnelSpecular &#30340;BxDF&#31867;&#22411;&#20026; &#21453;&#23556;+&#36879;&#23556;+&#23436;&#32654;&#38236;&#38754;</span>
  <span style="color: #bc6ec5; font-weight: bold;">FresnelSpecular</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;R, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;T, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaA</span>,
                      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaB</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>)
  : BxDF(BxDFType(BSDF_REFLECTION | BSDF_TRANSMISSION | BSDF_SPECULAR)),
    R(R),
    T(T),
    etaA(etaA),
    etaB(etaB),
    fresnel(etaA, etaB),
    mode(mode) {}

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">FresnelSpecular f &#36820;&#22238;0&#65292;&#22240;&#20026;&#26159;&#23436;&#32654;&#38236;&#38754;&#65292;&#25152;&#20197;&#25351;&#23450;&#20837;&#23556;&#26041;&#21521;&#21644;&#20986;&#23556;&#26041;&#21521;&#23545;&#24212;&#30340;&#36752;&#23556;&#29575;&#20026;0</span>
  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">FresnelSpecular</span>::f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span> {
      <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0.f);
  }
</pre>
</div>

<p>
FresnelSpecular 详细实现请参考下面部分：<br />
<a href="#org5f610dc">FresnelSpecular Sample_f 以及 Pdf</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org565ac73" class="outline-5">
<h5 id="org565ac73">Lambertian Reflection</h5>
<div class="outline-text-5" id="text-org565ac73">
<p>
Lambertain 模型是最简单的 BRDF 模型之一。其模拟了完美的漫反射表面，其将入射照明等可能地散射到所有方向。<br />
<img src="./PhysicallyBasedRendering/2020_06_24_lambertain_fr.jpg" alt="2020_06_24_lambertain_fr.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_06_24_lambertain_fr_01.jpg" alt="2020_06_24_lambertain_fr_01.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">R &#20026;&#21453;&#23556;&#20809;&#35889;&#65292;&#20854;&#32473;&#20986;&#20837;&#23556;&#20809;&#21487;&#20197;&#34987;&#21453;&#23556;&#30340;&#37096;&#20998;</span>
  <span style="color: #bc6ec5; font-weight: bold;">LambertianReflection</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;R)
  : BxDF(BxDFType(BSDF_REFLECTION | BSDF_DIFFUSE)), R(R) {}

  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">LambertianReflection</span>::f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span> {
      <span style="color: #4f97d7; font-weight: bold;">return</span> R * InvPi;
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27809;&#24517;&#35201;&#36890;&#36807;&#32479;&#35745;&#30340;&#26041;&#27861;&#26469;&#35745;&#31639; </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23436;&#32654;&#28459;&#21453;&#23556;&#65292;&#23558;&#25152;&#26377;&#20837;&#23556;&#20809;&#37117;&#22343;&#21248;&#21453;&#23556;&#21040;&#21322;&#29699;&#31354;&#38388;&#20013;&#65292;&#25152;&#20197;&#20854;&#21453;&#23556;&#29575;&#20026;R</span>
  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">rho</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSamples</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> { <span style="color: #4f97d7; font-weight: bold;">return</span> R; }
  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">rho</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSamples</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples1</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> *<span style="color: #7590db;">samples2</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> { <span style="color: #4f97d7; font-weight: bold;">return</span> R; }
</pre>
</div>

<ul class="org-ul">
<li>PBR Step by Step（一）立体角 <a href="https://www.cnblogs.com/jerrycg/p/4924761.html">https://www.cnblogs.com/jerrycg/p/4924761.html</a><br /></li>
<li>PBR Step by Step（四）Lambertian 反射模型 <a href="https://www.cnblogs.com/jerrycg/p/4941359.html">https://www.cnblogs.com/jerrycg/p/4941359.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4430cad" class="outline-5">
<h5 id="org4430cad">Microfacet Models</h5>
<div class="outline-text-5" id="text-org4430cad">
<p>
很多基于几何光学的模型，在模拟表面反射和透射时，都采用了下面这种理念：将粗糙的表面模拟为一系列小的微表面(microfacets)。由微表面组成的表面通常建模为高度场，微表面朝向的分布通过统计方法来表示。下图展示了一个比较粗糙的表面和一个比较光滑的表面：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_microfact_surface.jpg" alt="2020_06_24_microfact_surface.jpg" /><br />
使用微表面模型计算反射时，需要考虑下图所示的微表面层次的局部光照效果：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_microfact_model.jpg" alt="2020_06_24_microfact_model.jpg" /><br />
</p>
</div>

<div id="outline-container-orgd46a1ea" class="outline-6">
<h6 id="orgd46a1ea">Oren-Nayar Diffuse Reflection</h6>
<div class="outline-text-6" id="text-orgd46a1ea">
<p>
下图展示了 Oren-Nayar 模型<br />
<img src="./PhysicallyBasedRendering/2020_06_24_oren_nayar_model.jpg" alt="2020_06_24_oren_nayar_model.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org4b733d3" class="outline-6">
<h6 id="org4b733d3">Microfacet Distribution Function</h6>
<div class="outline-text-6" id="text-org4b733d3">
<p>
微表面分布函数定义在和 BSDF 一样的坐标系下。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24494;&#34920;&#38754;&#20998;&#24067;</span>
    <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> 
    {
    <span style="color: #4f97d7; font-weight: bold;">public</span>:
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MicrofacetDistribution Public Methods</span>
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> ~<span style="color: #bc6ec5; font-weight: bold;">MicrofacetDistribution</span>();
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27861;&#32447;&#20998;&#24067;</span>
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">D</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wh</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">Lambda</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">w</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">G1</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">w</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
          <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / (1 + Lambda(w));
        }
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20960;&#20309;&#20998;&#24067;</span>
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">G</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
          <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / (1 + Lambda(wo) + Lambda(wi));
        }
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #bc6ec5; font-weight: bold;">Sample_wh</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;<span style="color: #7590db;">u</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wo&#20986;&#23556;&#26041;&#21521;&#65292;wh&#27861;&#32447;&#26041;&#21521;&#23545;&#24212;&#30340;&#27010;&#29575;&#23494;&#24230;</span>
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">Pdf</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wh</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>;
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">ToString</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;

    <span style="color: #4f97d7; font-weight: bold;">protected</span>:
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MicrofacetDistribution Protected Methods</span>
        <span style="color: #bc6ec5; font-weight: bold;">MicrofacetDistribution</span>(<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">sampleVisibleArea</span>)
          : sampleVisibleArea(sampleVisibleArea) {}

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MicrofacetDistribution Protected Data</span>
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">sampleVisibleArea</span>;
    };

  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">MicrofacetDistribution</span>::<span style="color: #bc6ec5; font-weight: bold;">Pdf</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wh</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
  {
      <span style="color: #4f97d7; font-weight: bold;">if</span> (sampleVisibleArea)
          <span style="color: #4f97d7; font-weight: bold;">return</span> D(wh) * G1(wo) * AbsDot(wo, wh) / AbsCosTheta(wo);
      <span style="color: #4f97d7; font-weight: bold;">else</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> D(wh) * AbsCosTheta(wh);
  }
</pre>
</div>

<p>
为了保证物理上的合理性，微表面函数必须要归一化的（即遵守一定的约束条件）。直观地讲，如果我们考虑在法线方向上，微表面上的入射射线，每个射线和微表面只相交一次。形式化的表示就是，给定一个微表面微分区域 dA,微表面在该区域的投影必须等于 dA.如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_microfacet_discrition_001.jpg" alt="2020_06_24_microfacet_discrition_001.jpg" /><br />
</p>

<p>
下面链接中详细描述了法线分布需要遵守的约束条件：<br />
</p>
<ul class="org-ul">
<li><a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf</a><br /></li>
<li><a href="./EGSR07BTDF.html#org244d1b1">Microfacet Distribution Function 微表面分布函数 D</a><br /></li>
</ul>

<p>
下图展示了两种法线分布函数：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_normal_distribution_func.jpg" alt="2020_06_24_normal_distribution_func.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8ff55d0" class="outline-6">
<h6 id="org8ff55d0">Masking And Shadowing</h6>
<div class="outline-text-6" id="text-org8ff55d0">
<p>
只用微表面的法线分布来描述微表面的性质是不够的。从给定的方向观察或照射时，因为一些微表面背对着指定方向，所以这些微表面是不可见的，另一些微表面由于其他微表面的遮挡也可能是不可见的，这种效果可以通过 Smith 的 masking-shadowing 函数 G1(w, wh)来描述，其给出对于指定的法线 wh，从 w 方向观察或照射，可见的微表面。(0&lt;=G1(w, wh)&lt;=1)。通常来说，微表面可见的概率独立于他们的朝向 wh。<br />
</p>

<p>
下图展示了 G1 的归一化约束：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_g_distribution_func.jpg" alt="2020_06_24_g_distribution_func.jpg" /><br />
</p>

<p>
注意：正对 w 方向区域并不都是可见的。<br />
</p>

<p>
给定 D(wh),假设微表面上相邻点的高度无关联，可得如下公式：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_g_distribution_func_001.jpg" alt="2020_06_24_g_distribution_func_001.jpg" /><br />
</p>

<p>
G(ωo, ωi) 给出在ωo 和ωi 方向上都可见的微表面。定义 G 需要额外的假设。我们假设两个方向上可见的可能性互相独立，则得到 G 的方程：G(ωo, ωi) = G1(ωo) G1(ωi)<br />
实践中，两个方向上微表面可见性并不是独立的。考虑特殊情况 ωo = ωi ;此时 G(ωo, ωi) = G1(ωo) = G1(ωi); ωo 和ωi 夹角越小相关性越大。假定给定的点越高微表面可见性越大，在此假设下可推出如下 G 的方程：<br />
<img src="./PhysicallyBasedRendering/2020_06_24_g_distribution_func_002.jpg" alt="2020_06_24_g_distribution_func_002.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="./EGSR07BTDF.html#orge827d05">Shadowing-Masking Function 几何项 G</a><br /></li>
<li>法线分布函数相关总结 <a href="https://zhuanlan.zhihu.com/p/69380665">https://zhuanlan.zhihu.com/p/69380665</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4616fb2" class="outline-6">
<h6 id="org4616fb2">Torrance-Sparrow Model (MicrofacetReflection MicrofacetTransmission)</h6>
<div class="outline-text-6" id="text-org4616fb2">
<p>
Torrance-Sparrow Model 描述的是粗糙表面的反射。<br />
Torrance-Sparrow Model 推导参考 <a href="#orgc86e256">No description for this link</a><br />
</p>


<div id="orged8d531" class="figure">
<p><img src="./PhysicallyBasedRendering/brdf_derive.jpg" alt="brdf_derive.jpg" /><br />
</p>
</div>

<p>
\(dw_h dw_o\) 关系的另一种推导方式：<br />
<img src="./PhysicallyBasedRendering/dwh_dwo_relation.jpg" alt="dwh_dwo_relation.jpg" /><br />
</p>

<p>
粗糙表面的透射可以参考下面论文，其中也包含了 brdf 的推导。<br />
<img src="./PhysicallyBasedRendering/00_03_08_04_btdf.jpg" alt="00_03_08_04_btdf.jpg" /><br />
</p>

<ul class="org-ul">
<li>Microfacet Models for Refraction through Rough Surfaces <a href="http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf</a><br /></li>
<li>Microfacet models for reflection and refraction <a href="https://www.cs.cornell.edu/courses/cs6630/2012sp/slides/05ufacet.pdf">https://www.cs.cornell.edu/courses/cs6630/2012sp/slides/05ufacet.pdf</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #bc6ec5; font-weight: bold;">MicrofacetReflection</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">R</span>, <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distribution</span>, <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span>)
          : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)),
            R(R),
            distribution(distribution),
            fresnel(fresnel) {}
  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">MicrofacetReflection</span>::<span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
  {
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosThetaO</span> = AbsCosTheta(wo), <span style="color: #7590db;">cosThetaI</span> = AbsCosTheta(wi);
      <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wh</span> = wi + wo;
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Handle degenerate cases for microfacet reflection</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (cosThetaI == 0 || cosThetaO == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0.);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (wh.x == 0 &amp;&amp; wh.y == 0 &amp;&amp; wh.z == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0.);
      wh = Normalize(wh);
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">F</span> = fresnel-&gt;Evaluate(Dot(wi, wh));
      <span style="color: #4f97d7; font-weight: bold;">return</span> R * distribution-&gt;D(wh) * distribution-&gt;G(wo, wi) * F / (4 * cosThetaI * cosThetaO);
  }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #bc6ec5; font-weight: bold;">MicrofacetTransmission</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">T</span>, <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distribution</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaA</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaB</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>)
          : BxDF(BxDFType(BSDF_TRANSMISSION | BSDF_GLOSSY)),
            T(T),
            distribution(distribution),
            etaA(etaA),
            etaB(etaB),
            fresnel(etaA, etaB),
            mode(mode) {}

<span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">MicrofacetTransmission</span>::<span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>,
                                   <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #4f97d7; font-weight: bold;">if</span> (SameHemisphere(wo, wi)) <span style="color: #4f97d7; font-weight: bold;">return</span> 0;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">transmission only</span>

    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosThetaO</span> = CosTheta(wo);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">cosThetaI</span> = CosTheta(wi);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (cosThetaI == 0 || cosThetaO == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute $\wh$ from $\wo$ and $\wi$ for microfacet transmission</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">eta</span> = CosTheta(wo) &gt; 0 ? (etaB / etaA) : (etaA / etaB);
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wh</span> = Normalize(wo + wi * eta);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (wh.z &lt; 0) wh = -wh;

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">F</span> = fresnel.Evaluate(Dot(wo, wh));

    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">sqrtDenom</span> = Dot(wo, wh) + eta * Dot(wi, wh);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">factor</span> = (mode == <span style="color: #a45bad;">TransportMode</span>::Radiance) ? (1 / eta) : 1;

    <span style="color: #4f97d7; font-weight: bold;">return</span> (Spectrum(1.f) - F) * T * <span style="color: #a45bad;">std</span>::abs(distribution-&gt;D(wh) * distribution-&gt;G(wo, wi) * eta * eta * AbsDot(wi, wh) * AbsDot(wo, wh) * factor * factor / (cosThetaI * cosThetaO * sqrtDenom * sqrtDenom));
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1fb3f1d" class="outline-5">
<h5 id="org1fb3f1d">Fresnel Incidence Effects</h5>
<div class="outline-text-5" id="text-org1fb3f1d">
<p>
对于分层物体，图形学中很多 BRDF 模型没有考虑，菲涅尔反射减少了到达底层的光。考虑一张光滑的木桌子或一面涂有光泽涂料的墙：如果你正对着这些表面看，你主要看到的是木头或涂料的颜色。当你移动视角到掠射角，你看到很少的底层颜色，由于菲涅尔效果，其被增加的反射光泽所淹没。<br />
</p>

<p>
<img src="./PhysicallyBasedRendering/00_02_08_05_FresnelBlend.jpg" alt="00_02_08_05_FresnelBlend.jpg" /><br />
上面公式证明请参考论文 《An Anisotropic Phong Light Reflection Model》(我没看 ^_^)<br />
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a45bad;">FresnelBlend</span>::<span style="color: #bc6ec5; font-weight: bold;">FresnelBlend</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">Rd</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;<span style="color: #7590db;">Rs</span>,
                             <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distribution</span>)
      : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)),
        Rd(Rd),
        Rs(Rs),
        distribution(distribution) {}

  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">FresnelBlend</span>::<span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
      <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">pow5</span> = [](<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">v</span>) { <span style="color: #4f97d7; font-weight: bold;">return</span> (v * v) * (v * v) * v; };
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#19979;&#38754; Rd * (Spectrum(1.f) - Rs)&#37096;&#20998;&#65292;&#21644;Unity&#20013;reflectivity&#30340;&#35745;&#31639;&#19968;&#26679;&#12290;Unity&#20013;&#23601;&#26159;&#36890;&#36807;&#36825;&#31181;&#26041;&#24335;&#31895;&#30053;&#22320;&#36981;&#23432;&#33021;&#37327;&#23432;&#24658;&#12290;</span>
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">diffuse</span> = (28.f / (23.f * Pi)) * Rd * (Spectrum(1.f) - Rs) * (1 - pow5(1 - .5f * AbsCosTheta(wi))) * (1 - pow5(1 - .5f * AbsCosTheta(wo)));
      <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wh</span> = wi + wo;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (wh.x == 0 &amp;&amp; wh.y == 0 &amp;&amp; wh.z == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(0);
      wh = Normalize(wh);
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">specular</span> = distribution-&gt;D(wh) / (4 * AbsDot(wi, wh) * <span style="color: #a45bad;">std</span>::max(AbsCosTheta(wi), AbsCosTheta(wo))) * SchlickFresnel(Dot(wi, wh));
      <span style="color: #4f97d7; font-weight: bold;">return</span> diffuse + specular;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org7f0c54e" class="outline-5">
<h5 id="org7f0c54e">Fourier Basis BSDFs</h5>
<div class="outline-text-5" id="text-org7f0c54e">
<p>
尽管上面的反射模型可以表示很多材质，但是对于某些材质，上面的模型表现并不好（例如，带有光滑或粗糙清漆的金属，或者纤维。这些材质通常包含逆反射 retro-reflective）。对于这种材质，有一种方法是将他们的 BSDF 值存储在一个巨大的 3D 或 4D 查找表中，然而这种方式需要太大的存储空间（如果 wi 和 wo 按照球面角为 1 度的间隔进行采样，需要 10 亿个样本点来表示对应的各向异性 BSDF）<br />
</p>

<p>
FourierBSDF 表示各项同性的 BSDF 时，会使用球坐标系的形式。<br />
<img src="./PhysicallyBasedRendering/2020_06_24_fourier_bsdf_001.jpg" alt="2020_06_24_fourier_bsdf_001.jpg" /><br />
上面公式中的 ak 在其输入参数上是离散分布的。我们选择一组天顶角的 cos 值 μ= {μ0, . . . , μn−1}，为每一对μi,μj 存储对应的  ak(μi,μj)。可以将每个 ak 当作一个 nxn 的矩阵，整个 BRDF 表示就由 m 个这样的矩阵组成。每一个矩阵描述了对于入射照明在材质中的不同方位角的震荡频率。<br />
最大阶 m 的值需要通过计算上面傅里叶展开公式来满足精度变化需求，其依赖于特定的天顶角，因此对于给定的一对方向，调节系数 ak 的数量来适应 BSDF 的复杂度是很值得的。这样做对于数据的紧密性很重要。<br />
考虑完美镜面反射的情况，可看出系数数目的可变性:<br />
当μi 和μo 接近时(μi ≈ μo)，此时为了精确表示 specular lobe 需要很多系数(此时对应的频率比较高)，对于大部分方位角差(φ = φi− φo)来说，其值为 0，而对于靠近φ = π的一组方向来说，其值很大。<br />
当μi 和μo 不同时，只需要一项来表示 BSDF 为 0。<br />
为了让 BSDF 对于所有的(μi,μo)对更加平滑，需要多个 ak 系数来精确表示φ的分布，但是光滑性意味着通常不需要太多的系数。FourierBSDF 开发了这种属性并且只存储一组离散的系数就可以达到想要的精度。<br />
</p>

<p>
为了使构建的 BSDF 非常平滑，对于 ak 系数的计算采用了张量积样条(tensor-product spline)。对于每个 ak 系数，其计算方法如下：<br />
<img src="./PhysicallyBasedRendering/2020_06_25_calc_ak.jpg" alt="2020_06_25_calc_ak.jpg" /><br />
</p>

<p>
当 ak 系数多时，可以通过下面三角函数关系，优化 FourierBSDF 公式的求解（利用之前计算的 cos 值计算当前的 cos 值）：<br />
<img src="./PhysicallyBasedRendering/2020_06_25_fourier_bsdf_001.jpg" alt="2020_06_25_fourier_bsdf_001.jpg" /><br />
</p>

<ul class="org-ul">
<li>张量的概念 <a href="https://www.cnblogs.com/arxive/p/4967486.html">https://www.cnblogs.com/arxive/p/4967486.html</a><br /></li>
<li>马同学 张量专题 1 <a href="https://www.matongxue.com/madocs/683/">https://www.matongxue.com/madocs/683/</a><br /></li>
<li>马同学 张量专题 2 <a href="https://www.matongxue.com/madocs/692/">https://www.matongxue.com/madocs/692/</a><br /></li>
<li>马同学 张量专题 3 <a href="https://www.matongxue.com/madocs/708/">https://www.matongxue.com/madocs/708/</a><br /></li>
</ul>
</div>

<div id="outline-container-orgfe7075c" class="outline-6">
<h6 id="orgfe7075c">Spline Interpolation</h6>
<div class="outline-text-6" id="text-orgfe7075c">
<p>
已知函数 f 在 x0,x1,&#x2026;,xk 处的一组函数值，和导函数值。对于每一段[x(i),x(i+1)]，我们可以使用一个三次曲线进行近似 pi(x) = 3x^3 + bx^2 + cx + d;<br />
选择 pi(x)函数时，其需要满足以下条件：<br />
pi(xi) = f(xi)<br />
pi(xi+1)=f(xi+1)<br />
pi'(xi) = f'(xi)<br />
pi'(xi+1) = f'(xi+1)<br />
为了简化讨论，我们只考虑[x0,x1]，并且假设[x0,x1]=[0,1]<br />
求解 a,b,c,d 系数可得：<br />
a = f'(x0) + f'(x1) + 2f(x0) - 2f(x1)<br />
b = 3f(x1) - 3f(x0) - 2f'(x0) - f'(x1)<br />
c = f'(x0)<br />
d = f(x0)<br />
带入后可得:<br />
p(x) = (2x^3 - 3x^2 + 1)f(x0) + (-2x^3+3x^2)f(x1) + (x^3-2x^2+x)f'(x0) + (x^3-x^2)f'(x1)<br />
这种插值方式很方便，但是限制依然太强，因为通常我们无法知道导函数的信息。因此我们通过相邻的函数值 f(xi-1)和 f(xi+1)来计算近似的 f'(xi),这样可以计算处最终的 p(x)如下：<br />
</p>


<div id="org9d34c5e" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_25_fourier_bsdf_002.jpg" alt="2020_06_25_fourier_bsdf_002.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>catmull-rom 样条(spline)公式推导 <a href="https://zhuanlan.zhihu.com/p/111708587">https://zhuanlan.zhihu.com/p/111708587</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org8bc612a" class="outline-4">
<h4 id="org8bc612a">9 Materials</h4>
<div class="outline-text-4" id="text-org8bc612a">
</div>
<div id="outline-container-orgf93fa38" class="outline-5">
<h5 id="orgf93fa38">BSDFs</h5>
<div class="outline-text-5" id="text-orgf93fa38">
<p>
BSDF 表示一个 BRDFs 和 BTDFs 的集合。<br />
渲染法线会导致各种不同的 artifacts。<br />
下图 a 展示了 light leak：几何 normal 表示ωi 和ωo 在表面的两侧，因此，如果表面不透射，光照是没有贡献的。然而，如果我们直接以 ns 为中心的半球内计算渲染方程，我们会将来自ωi 方向的光包括进来，这是不正确的。这种情况说明，此处不能使用 ns 来代替 ng 作为渲染计算。<br />
下图 b 展示了一个类似的情况：渲染 normal 表示没有光线被反射到观察者，因为照明不在渲染 normal 表示的半球空间内，然而几何 normal 表示的半球空间中包含照明。<br />
解决以上问题的方法为：使用几何 normal 来确定是是否计算，照明和几何法线在同一个半球空间则计算 BRDF，否则计算 BTDF。而在计算渲染方程时，依然使用渲染 normal 和入射方向的夹角，而不使用几何 normal。<br />
<img src="./PhysicallyBasedRendering/2020_06_26_normal_error.jpg" alt="2020_06_26_normal_error.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">BSDF</span>::<span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">woW</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wiW</span>, <span style="color: #ce537a; font-weight: bold;">BxDFType</span> <span style="color: #7590db;">flags</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wi</span> = WorldToLocal(wiW), <span style="color: #7590db;">wo</span> = WorldToLocal(woW);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (wo.z == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> 0.;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20837;&#23556;&#20809;&#32447;&#12289;&#20986;&#23556;&#20809;&#32447;&#21644;&#20960;&#20309;&#27861;&#32447;&#22312;&#21516;&#19968;&#20010;&#21322;&#29699;&#31354;&#38388;&#21017;&#35745;&#31639; BRDF&#65292;&#21542;&#21017;&#35745;&#31639; BTDF</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">reflect</span> = Dot(wiW, ng) * Dot(woW, ng) &gt; 0;
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">f</span>(0.f);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bsdf &#20250;&#24490;&#29615;&#21472;&#21152;&#20854;&#21253;&#21547;&#30340;&#25152;&#26377;BxDF</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; nBxDFs; ++i)
        <span style="color: #4f97d7; font-weight: bold;">if</span> (bxdfs[i]-&gt;MatchesFlags(flags) &amp;&amp;
            ((reflect &amp;&amp; (bxdfs[i]-&gt;type &amp; BSDF_REFLECTION)) ||
             (<span style="color: #a45bad;">!</span>reflect &amp;&amp; (bxdfs[i]-&gt;type &amp; BSDF_TRANSMISSION))))
            f += bxdfs[i]-&gt;f(wo, wi);
    <span style="color: #4f97d7; font-weight: bold;">return</span> f;
}
</pre>
</div>
</div>
<div id="outline-container-org87eb653" class="outline-6">
<h6 id="org87eb653">BSDF memory management</h6>
<div class="outline-text-6" id="text-org87eb653">
<p>
对于每个和几何体相交的射线，Integrator 在计算射线携带的辐射率时都会创建一个或多个 BSDF 对象，每个 BSDF 对象中又包含多个由 Materials 在交点处创建的 BxDFs。如果使用 new delete 为这些 BSDF 和 BxDFs 对象分配内存，效率会很差。使用 MemoryArena 来解决该问题。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">BSDF</span> *<span style="color: #7590db;">b</span> = new BSDF;
<span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">lam</span> = new LambertianReflection(Spectrum(0.5f));

<span style="color: #ce537a; font-weight: bold;">BSDF</span> *<span style="color: #7590db;">b</span> = ARENA_ALLOC(arena, BSDF);
<span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">lam</span> = ARENA_ALLOC(arena, LambertianReflection)(Spectrum(0.5f));

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;arena&#30003;&#35831;&#30340;&#20869;&#23384;&#65292;&#20351;&#29992;new&#25191;&#34892;&#31867;&#23545;&#35937;&#30340;&#21021;&#22987;&#21270;</span>
<span style="color: #bc6ec5;">#define</span> <span style="color: #bc6ec5; font-weight: bold;">ARENA_ALLOC</span>(<span style="color: #7590db;">arena</span>, <span style="color: #7590db;">Type</span>) new (arena.Alloc(<span style="color: #4f97d7; font-weight: bold;">sizeof</span>(Type))) Type
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf5237ef" class="outline-5">
<h5 id="orgf5237ef">Material Interface And Implementations</h5>
<div class="outline-text-5" id="text-orgf5237ef">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">Material</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#20989;&#25968;&#30340;&#32844;&#36131;&#20026;&#65306;&#30830;&#23450;&#20132;&#28857;&#22788;&#30340;&#21453;&#23556;&#23646;&#24615;&#24182;&#20351;&#29992;&#23545;&#24212;&#30340;BSDF&#23545;&#35937;&#21021;&#22987;&#21270;SurfaceInteraction::bsdf&#25104;&#21592;&#21464;&#37327;&#12290;&#22914;&#26524;&#26448;&#36136;&#21253;&#21547;&#27425;&#34920;&#38754;&#25955;&#23556;&#65292;SurfaceInteraction::bssrdf&#25104;&#21592;&#21464;&#37327;&#20063;&#38656;&#35201;&#34987;&#21021;&#22987;&#21270;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SurfaceInteraction *si, &#23556;&#32447;&#21644;&#20960;&#20309;&#34920;&#38754;&#30340;&#20132;&#28857;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MemoryArena &amp;arena,     &#29992;&#20110;&#20026;BSDFs &#21644; BSSRDFs&#30003;&#35831;&#20869;&#23384;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">TransportMode mode,     &#29992;&#20110;&#25351;&#23450;&#20132;&#28857;&#26159;&#20174;&#25668;&#20687;&#26426;&#20986;&#21457;&#30340;&#23556;&#32447; &#36824;&#26159;&#20174;&#20809;&#28304;&#20986;&#21457;&#30340;&#23556;&#32447; &#21644;&#34920;&#38754;&#30456;&#20132;&#24471;&#21040;&#30340;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bool allowMultipleLobes &#29992;&#20110;&#25351;&#23450;&#26448;&#36136;&#20351;&#29992;&#30340;BxDF&#26159;&#21542;&#26159;&#32858;&#21512;&#20102;&#24456;&#22810;&#25955;&#23556;&#31867;&#22411;&#21040;&#21333;&#20010;BxDF&#12290;&#65288;&#20363;&#22914;&#65306;FresnelSpecular &#23601;&#26159;&#32858;&#21512;&#20102;&#21453;&#23556;&#21644;&#36879;&#23556;&#30340;BxDF&#65289;</span>
    virtual <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, MemoryArena &amp;arena, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) = 0;
}
</pre>
</div>

<pre class="example" id="orgc93bd6c">
Material 会创建对应的 BxDFs，将他们添加到 SurfaceInteraction 的 bsdf 中。
首先：SurfaceInteraction 的bsdf会对其中的BxDFs逐一计算f()和Pdf()值，求出对出射Radiance的贡献，将其叠加到总的Radiance中。
然后：如果光照不是DeltaLight，SurfaceInteraction 的bsdf会对其中的BxDFs逐一计算Sample_f()，求出对出射Radiance的贡献，将其叠加到总的Radiance中。

具体处理逻辑参考 integrator.cpp 中 EstimateDirect函数的实现。
Spectrum EstimateDirect(const Interaction &amp;it, const Point2f &amp;uScattering, const Light &amp;light, const Point2f &amp;uLight,
                        const Scene &amp;scene, Sampler &amp;sampler,
                        MemoryArena &amp;arena, bool handleMedia, bool specular)
</pre>
</div>
<div id="outline-container-orgef6d258" class="outline-6">
<h6 id="orgef6d258">Matte Material</h6>
<div class="outline-text-6" id="text-orgef6d258">
<p>
Matte Material 用于描述完全的漫反射材质<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Kd &#20026;&#28459;&#21453;&#23556;&#20809;&#35889;&#20540;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sigma &#20026;&#31895;&#31961;&#24230;&#20540;(roughness)</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bumpMap &#20026;&#27861;&#32447;&#36148;&#22270;</span>
  <span style="color: #bc6ec5; font-weight: bold;">MatteMaterial</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">std</span>::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt; &amp;Kd,
                <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">std</span>::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;sigma,
                <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">std</span>::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;bumpMap)
    : Kd(Kd), sigma(sigma), bumpMap(bumpMap) {}

  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">MatteMaterial</span>::ComputeScatteringFunctions(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>,
                                                 MemoryArena &amp;arena,
                                                 <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
                                                 <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Evaluate textures for _MatteMaterial_ material and allocate BRDF</span>
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si);
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">r</span> = Kd-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">sig</span> = Clamp(sigma-&gt;Evaluate(*si), 0, 90);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>r.IsBlack())
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31895;&#31961;&#24230;&#20026;0 &#21017;bsdf&#20026;LambertianReflection, &#21542;&#21017;&#20026;OrenNayar</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (sig == 0)
          si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, LambertianReflection)(r));
        <span style="color: #4f97d7; font-weight: bold;">else</span>
          si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, OrenNayar)(r, sig));
    }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgae76a28" class="outline-6">
<h6 id="orgae76a28">Plastic Material</h6>
<div class="outline-text-6" id="text-orgae76a28">
<p>
Plastic 可用于模拟反射效果中混合了漫反射和有光泽散射的材质。其实就是典型的电介质材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">PlasticMaterial Method Definitions</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">PlasticMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
      si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize diffuse component of plastic material</span>
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">kd</span> = Kd-&gt;Evaluate(*si).Clamp();
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>kd.IsBlack())
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#19968;&#20010;Lambertian&#21453;&#23556;&#65292;kd&#20026; diffuse color</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LambertianReflection &#30340;Pdf&#20026;&#40664;&#35748;&#30340;BxDF::Pdf &#27492;&#22788;&#27809;&#26377;&#20351;&#29992;kd*(1-ks)&#26469;&#23454;&#29616;&#31895;&#30053;&#33021;&#37327;&#23432;&#24658;</span>
          si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, LambertianReflection)(kd));
      }

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize specular component of plastic material</span>
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">ks</span> = Ks-&gt;Evaluate(*si).Clamp();
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>ks.IsBlack()) {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;FresnelDielectric&#26469;&#35745;&#31639;&#33778;&#28037;&#23572;&#39033;</span>
          <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.5f, 1.f);
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Create microfacet distribution _distrib_ for plastic material</span>
          <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">rough</span> = roughness-&gt;Evaluate(*si);
          <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness)
              rough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(rough);
          <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(rough, rough);
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#19968;&#20010;&#24494;&#34920;&#38754;&#38236;&#38754;&#21453;&#23556;&#65292;ks&#20026; specular color</span>
          <span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">spec</span> = ARENA_ALLOC(arena, MicrofacetReflection)(ks, distrib, fresnel);
          si-&gt;bsdf-&gt;Add(spec);
      }
  }

  <span style="color: #ce537a; font-weight: bold;">PlasticMaterial</span> *<span style="color: #bc6ec5; font-weight: bold;">CreatePlasticMaterial</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">TextureParams</span> &amp;<span style="color: #7590db;">mp</span>) 
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;diffuse color &#20026;0.25,0.25,0.25</span>
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture</span>&lt;<span style="color: #ce537a; font-weight: bold;">Spectrum</span>&gt;&gt; <span style="color: #7590db;">Kd</span> = mp.GetSpectrumTexture(<span style="color: #2d9574;">"Kd"</span>, Spectrum(0.25f));
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;specular color &#20026;0.25,0.25,0.25</span>
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture</span>&lt;<span style="color: #ce537a; font-weight: bold;">Spectrum</span>&gt;&gt; <span style="color: #7590db;">Ks</span> = mp.GetSpectrumTexture(<span style="color: #2d9574;">"Ks"</span>, Spectrum(0.25f));
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture</span>&lt;<span style="color: #ce537a; font-weight: bold;">Float</span>&gt;&gt; <span style="color: #7590db;">roughness</span> = mp.GetFloatTexture(<span style="color: #2d9574;">"roughness"</span>, .1f);
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture</span>&lt;<span style="color: #ce537a; font-weight: bold;">Float</span>&gt;&gt; <span style="color: #7590db;">bumpMap</span> = mp.GetFloatTextureOrNull(<span style="color: #2d9574;">"bumpmap"</span>);
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">remapRoughness</span> = mp.FindBool(<span style="color: #2d9574;">"remaproughness"</span>, <span style="color: #a45bad;">true</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">PlasticMaterial</span>(Kd, Ks, roughness, bumpMap, remapRoughness);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd8f8a84" class="outline-6">
<h6 id="orgd8f8a84">Mix Material</h6>
<div class="outline-text-6" id="text-orgd8f8a84">
<p>
Mix Material 实现按照权重值将两个 Material 合在一起。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">MixMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>,
                                             <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>,
                                             <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
                                             <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scale &#23384;&#20648;&#20102;&#28151;&#21512;&#26435;&#37325;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute weights and original _BxDF_s for mix material</span>
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">s1</span> = scale-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">s2</span> = (Spectrum(1.f) - s1).Clamp();
    <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> <span style="color: #7590db;">si2</span> = *si;
    m1-&gt;ComputeScatteringFunctions(si, arena, mode, allowMultipleLobes);
    m2-&gt;ComputeScatteringFunctions(&amp;si2, arena, mode, allowMultipleLobes);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize _si-&gt;bsdf_ with weighted mixture of _BxDF_s</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">n1</span> = si-&gt;bsdf-&gt;NumComponents(), <span style="color: #7590db;">n2</span> = si2.bsdf-&gt;NumComponents();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bxdfs</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; n1; ++i)
        si-&gt;bsdf-&gt;bxdfs[i] = ARENA_ALLOC(arena, ScaledBxDF)(si-&gt;bsdf-&gt;bxdfs[i], s1);
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; n2; ++i)
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, ScaledBxDF)(si2.bsdf-&gt;bxdfs[i], s2));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org053e588" class="outline-6">
<h6 id="org053e588">Fourier Material</h6>
<div class="outline-text-6" id="text-org053e588">
<p>
FourierMaterial 支持将测量或人工生成的 BSDF 表格数据转化为基于方向的 BSDF。<br />
</p>
</div>
</div>
<div id="outline-container-org4c35340" class="outline-6">
<h6 id="org4c35340">Additional Material</h6>
<div class="outline-text-6" id="text-org4c35340">
</div>
<ul class="org-ul">
<li><a id="org166371d"></a>GlassMaterial<br />
<div class="outline-text-7" id="text-org166371d">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">GlassMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>,
                                               <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>,
                                               <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
                                               <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">eta</span> = index-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">urough</span> = uRoughness-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">vrough</span> = vRoughness-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">R</span> = Kr-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">T</span> = Kt-&gt;Evaluate(*si).Clamp();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize _bsdf_ for smooth or rough dielectric</span>
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si, eta);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (R.IsBlack() &amp;&amp; T.IsBlack()) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isSpecular</span> = urough == 0 &amp;&amp; vrough == 0;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular &amp;&amp; allowMultipleLobes) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">FresnelSpecular &#26159;&#20351;&#29992;FrDielectric&#26469;&#35745;&#31639;&#33778;&#28037;&#23572;&#39033;</span>
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, FresnelSpecular)(R, T, 1.f, eta, mode));
    } <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness) {
            urough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(urough);
            vrough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(vrough);
        }
        <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = isSpecular ? <span style="color: #a45bad;">nullptr</span> : ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(urough, vrough);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>R.IsBlack()) {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306; Glass &#26448;&#36136;&#27809;&#26377;diffuse&#21453;&#23556;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;FresnelDielectric&#35745;&#31639;&#33778;&#28037;&#23572;&#39033;</span>
            <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.f, eta);
            <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular)
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularReflection)(R, fresnel));
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetReflection)(R, distrib, fresnel));
        }
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>T.IsBlack()) {
            <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular)
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularTransmission)(T, 1.f, eta, mode));
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetTransmission)(T, distrib, 1.f, eta, mode));
        }
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org7ccedd5"></a>MetalMateiral<br />
<div class="outline-text-7" id="text-org7ccedd5">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">MetalMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>,
                                               <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>,
                                               <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
                                               <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si);

    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">uRough</span> = uRoughness ? uRoughness-&gt;Evaluate(*si) : roughness-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">vRough</span> = vRoughness ? vRoughness-&gt;Evaluate(*si) : roughness-&gt;Evaluate(*si);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness) {
        uRough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(uRough);
        vRough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(vRough);
    }
    <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">frMf</span> = ARENA_ALLOC(arena, FresnelConductor)(1., eta-&gt;Evaluate(*si), k-&gt;Evaluate(*si));
    <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(uRough, vRough);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37329;&#23646;&#21482;&#21253;&#21547; MicrofacetReflection&#65292;&#20854;&#19981;&#21253;&#21547;diffuse</span>
    si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetReflection)(1., distrib, frMf));
}
</pre>
</div>
</div>
</li>
<li><a id="orga325056"></a>MirrorMaterial<br />
<div class="outline-text-7" id="text-orga325056">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">MirrorMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>,
                                                <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>,
                                                <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
                                                <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si);
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">R</span> = Kr-&gt;Evaluate(*si).Clamp();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#21253;&#21547;SpecularReflection</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>R.IsBlack())
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularReflection)(R, ARENA_ALLOC(arena, FresnelNoOp)()));
}
</pre>
</div>
</div>
</li>
<li><a id="org706323b"></a>SubstrateMaterial<br />
<div class="outline-text-7" id="text-org706323b">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">SubstrateMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si);
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">d</span> = Kd-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">s</span> = Ks-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">roughu</span> = nu-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">roughv</span> = nv-&gt;Evaluate(*si);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>d.IsBlack() || <span style="color: #a45bad;">!</span>s.IsBlack()) {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness) {
            roughu = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(roughu);
            roughv = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(roughv);
        }
        <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(roughu, roughv);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20351;&#29992;&#20102;FresnelBlend&#65292;FresnelBlend&#26159;&#32771;&#34385;&#20102;&#33021;&#37327;&#23432;&#24658;&#30340;Diffuse&#21644;Specular</span>
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, FresnelBlend)(d, s, distrib));
    }
}
</pre>
</div>

<ul class="org-ul">
<li><a href="#org1fb3f1d">FresnelBlend实现细节</a><br /></li>
</ul>
</div>
</li>
<li><a id="org71828e7"></a>SubsurfaceMaterial<br />
<div class="outline-text-7" id="text-org71828e7">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">SubsurfaceMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize BSDF for _SubsurfaceMaterial_</span>
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">R</span> = Kr-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">T</span> = Kt-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">urough</span> = uRoughness-&gt;Evaluate(*si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">vrough</span> = vRoughness-&gt;Evaluate(*si);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Initialize _bsdf_ for smooth or rough dielectric</span>
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si, eta);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (R.IsBlack() &amp;&amp; T.IsBlack()) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isSpecular</span> = urough == 0 &amp;&amp; vrough == 0;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular &amp;&amp; allowMultipleLobes) {
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, FresnelSpecular)(R, T, 1.f, eta, mode));
    } 
    <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness) {
            urough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(urough);
            vrough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(vrough);
        }
        <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = isSpecular ? <span style="color: #a45bad;">nullptr</span> : ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(urough, vrough);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>R.IsBlack()) {
            <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.f, eta);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27809;&#26377;&#21253;&#21547;diffuse</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular)
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularReflection)(R, fresnel));
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetReflection)(R, distrib, fresnel));
        }
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>T.IsBlack()) {
            <span style="color: #4f97d7; font-weight: bold;">if</span> (isSpecular)
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularTransmission)(T, 1.f, eta, mode));
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetTransmission)(T, distrib, 1.f, eta, mode));
        }
    }
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">sig_a</span> = scale * sigma_a-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">sig_s</span> = scale * sigma_s-&gt;Evaluate(*si).Clamp();
    si-&gt;bssrdf = ARENA_ALLOC(arena, TabulatedBSSRDF)(*si, <span style="color: #4f97d7; font-weight: bold;">this</span>, mode, eta, sig_a, sig_s, table);
}
</pre>
</div>
</div>
</li>
<li><a id="org150afc2"></a>TranslucentMaterial<br />
<div class="outline-text-7" id="text-org150afc2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">TranslucentMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(
    <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>,
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">eta</span> = 1.5f;
    si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si, eta);

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">r</span> = reflect-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">t</span> = transmit-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (r.IsBlack() &amp;&amp; t.IsBlack()) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">kd</span> = Kd-&gt;Evaluate(*si).Clamp();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21253;&#21547; Lambertian diffuse &amp; Lambertian transmission</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>kd.IsBlack()) {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>r.IsBlack())
            si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, LambertianReflection)(r * kd));
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>t.IsBlack())
            si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, LambertianTransmission)(t * kd));
    }
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">ks</span> = Ks-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>ks.IsBlack() &amp;&amp; (<span style="color: #a45bad;">!</span>r.IsBlack() || <span style="color: #a45bad;">!</span>t.IsBlack())) {
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">rough</span> = roughness-&gt;Evaluate(*si);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness)
            rough = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(rough);
        <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(rough, rough);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>r.IsBlack()) {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: &#21322;&#36879;&#26126;&#26448;&#36136;&#37117;&#26159;&#30005;&#20171;&#36136;</span>
            <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.f, eta);
            si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetReflection)(r * ks, distrib, fresnel));
        }
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>t.IsBlack())
            si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, MicrofacetTransmission)(t * ks, distrib, 1.f, eta, mode));
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org2eee1a6"></a>UberMaterial<br />
<div class="outline-text-7" id="text-org2eee1a6">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">UberMaterial</span>::<span style="color: #bc6ec5; font-weight: bold;">ComputeScatteringFunctions</span>(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Perform bump mapping with _bumpMap_, if present</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (bumpMap) Bump(bumpMap, si);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">e</span> = eta-&gt;Evaluate(*si);

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">op</span> = opacity-&gt;Evaluate(*si).Clamp();
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">t</span> = (-op + Spectrum(1.f)).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>t.IsBlack()) {
        si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si, 1.f);
        <span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">tr</span> = ARENA_ALLOC(arena, SpecularTransmission)(t, 1.f, 1.f, mode);
        si-&gt;bsdf-&gt;Add(tr);
    } <span style="color: #4f97d7; font-weight: bold;">else</span>
        si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si, e);

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">kd</span> = op * Kd-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>kd.IsBlack()) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21253;&#21547;diffuse &#37096;&#20998; Lambertian Reflection</span>
        <span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">diff</span> = ARENA_ALLOC(arena, LambertianReflection)(kd);
        si-&gt;bsdf-&gt;Add(diff);
    }

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">ks</span> = op * Ks-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>ks.IsBlack()) {
        <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.f, e);
        <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">roughu</span>, <span style="color: #7590db;">roughv</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (roughnessu)
            roughu = roughnessu-&gt;Evaluate(*si);
        <span style="color: #4f97d7; font-weight: bold;">else</span>
            roughu = roughness-&gt;Evaluate(*si);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (roughnessv)
            roughv = roughnessv-&gt;Evaluate(*si);
        <span style="color: #4f97d7; font-weight: bold;">else</span>
            roughv = roughu;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (remapRoughness) {
            roughu = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(roughu);
            roughv = <span style="color: #a45bad;">TrowbridgeReitzDistribution</span>::RoughnessToAlpha(roughv);
        }
        <span style="color: #ce537a; font-weight: bold;">MicrofacetDistribution</span> *<span style="color: #7590db;">distrib</span> = ARENA_ALLOC(arena, TrowbridgeReitzDistribution)(roughu, roughv);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21253;&#21547; glossy reflection : MicrofacetReflection</span>
        <span style="color: #ce537a; font-weight: bold;">BxDF</span> *<span style="color: #7590db;">spec</span> = ARENA_ALLOC(arena, MicrofacetReflection)(ks, distrib, fresnel); 
        si-&gt;bsdf-&gt;Add(spec);
    }

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">kr</span> = op * Kr-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>kr.IsBlack()) {
        <span style="color: #ce537a; font-weight: bold;">Fresnel</span> *<span style="color: #7590db;">fresnel</span> = ARENA_ALLOC(arena, FresnelDielectric)(1.f, e);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21253;&#21547; specular reflection : SpecularReflection</span>
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularReflection)(kr, fresnel));
    }

    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">kt</span> = op * Kt-&gt;Evaluate(*si).Clamp();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>kt.IsBlack())
        si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, SpecularTransmission)(kt, 1.f, e, mode));
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org509dd4a" class="outline-5">
<h5 id="org509dd4a">Bump Mapping</h5>
<div class="outline-text-5" id="text-org509dd4a">
<p>
前面几节定义的材质都包含了一个浮点贴图，其用来定义表面上每一点的位移，其原理如下图所示：<br />
<img src="./PhysicallyBasedRendering/2020_06_26_bump_mapping_001.jpg" alt="2020_06_26_bump_mapping_001.jpg" /><br />
</p>

<p>
BumpMapping 原理<br />
使用 displacement texture 将表面偏移后，我们需要找到偏移后表面在 p'点处的偏导数∂p'/∂u 和∂p'/∂v，然后使用他们计算 shading normal(计算 shading normal 的方法：n = ∂p/∂u×∂p/∂v)。<br />
有两种方式可以用于计算∂d(u, v)/∂u 和∂d(u, v)/∂v:<br />
</p>
<ol class="org-ol">
<li>获取 u 和 v 方向上邻接的图元，进行求解。<br /></li>
<li>利用导数定义进行近似计算。<br /></li>
</ol>

<div id="org3f73239" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_26_bump_mapping_002.jpg" alt="2020_06_26_bump_mapping_002.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>求导数 <a href="https://zhuanlan.zhihu.com/p/70443521">https://zhuanlan.zhihu.com/p/70443521</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org02b0ce9" class="outline-4">
<h4 id="org02b0ce9">10 Texture</h4>
<div class="outline-text-4" id="text-org02b0ce9">
<p>
Textures 可能导致最终渲染图片中有高频率变化。尽管这种 aliasing 的视觉影响可以通过第七章种介绍的非一致性采样技术进行缓解，但是更好的解决方案是根据贴图采样率动态调整贴图内容的频率。<br />
</p>
</div>
<div id="outline-container-orgb3b0bba" class="outline-5">
<h5 id="orgb3b0bba">Sampling And Antialiasing</h5>
<div class="outline-text-5" id="text-orgb3b0bba">
<p>
采样是一个令人沮丧的任务。因为 aliasing 问题是无法解决的。无论采样率多大，无穷频率的内容(几何体的边界)以及硬阴影总会导致最终渲染图片中存在 aliasing。<br />
幸运的是，对于贴图来说，贴图函数通常存在一个解析形式，这使得移除贴图中非常高频率的部分是可行的。<br />
为了从贴图函数中移除 aliasing，需要解决两个问题：<br />
</p>
<ol class="org-ol">
<li>贴图空间的采样率必须是可计算的。从最终渲染图片的分辨率和像素采样率可得到屏幕空间的采样率，但是为了得到贴图函数的采样率需要确定场景中物体表面的采样率。<br /></li>
<li>给定贴图采样率，需要利用采样理论来指导贴图值的计算，以保证其值的频率小于当前采样率支持的最大频率。<br /></li>
</ol>
</div>
<div id="outline-container-org6de1586" class="outline-6">
<h6 id="org6de1586">Finding The Texture Sampling Rate</h6>
<div class="outline-text-6" id="text-org6de1586">
<p>
考虑任意的贴图函数，其为位置的函数，定义在场景中物体表面上。用 f(x,y)表示渲染图片的点(x,y)到物体表面的点的映射，则贴图函数可以表示为 T(f(x,y))。<br />
考虑贴图函数 T(s,t)被应用于垂直于 z 轴的正方形，该正方形 4 个顶点世界坐标分别为(0,0,0) (1,0,0) (1,1,0) (0,1,0).如果摄像机为正交投影，并放在恰当位置，使得该正方形铺满渲染图片，此时正方形上的点 p 对应的贴图坐标为 s = px t = py;则贴图坐标(s,t)与屏幕像素坐标(x,y)的关系为：s=x/x_r t=y/y_r (渲染图片的分辨率为 x_r,y_r)。给定一个像素的一个样本间隔，贴图参数空间上的样本间隔为(1/x_r,1/y_r),贴图函数必须移除高于当前可表示采样率的细节。<br />
<img src="./PhysicallyBasedRendering/2020_06_26_tex_func_001.jpg" alt="2020_06_26_tex_func_001.jpg" /><br />
像素坐标和贴图坐标的关系，以及像素采样率和贴图采样率之间的关系是确定贴图允许的最大频率内容的关键。给定一个三角形上的一点，其对应的贴图坐标为(s,t),摄像机为透视投影，可以通过解析的方法得到该点对应的渲染图片上样本点的差值。这是图形处理器进行贴图映射时实现抗锯齿的基础。<br />
对于复杂场景、透视投影的情况，精确地找到渲染图片位置和贴图坐标值的关系是非常困难的。幸运的是，对于贴图抗锯齿，我们不需要对于任意的渲染图片上的点(x,y)求解对应物体表面上的点 f(x,y).我们只需要知道改变像素采样点位置导致的贴图样本位置的变化。像素图片上(x,y)变为(x',y')对应物体上的点从 f(x,y)变为 f(x',y')，通过下面公式计算得到 f(x',y')：<br />
<img src="./PhysicallyBasedRendering/2020_06_26_tex_func_002.jpg" alt="2020_06_26_tex_func_002.jpg" /><br />
如果这些偏导数对于对应的 x'-x 和 y'-y 变化不大，上面的近似就是合理的。更重要的是，这些偏导数的值给出了，当像素在 x,y 方向上偏移 1 个单位时，贴图样本位置的变化，也就是贴图的采样率。<br />
我们可以使用 offset 射线来估算，<br />
下图展示了计算 dudx dvdx dudy dvdy (这些值就是贴图采样率)的原理：<br />
<img src="./PhysicallyBasedRendering/2020_06_26_tex_func_003.jpg" alt="2020_06_26_tex_func_003.jpg" /><br />
上面有 3 个方程 2 个未知数(∂u 和∂v)，其中有一个方程是退化的。计算∂p/∂u 和 ∂p/∂v 的叉乘，判断所得向量的最大分量，选另外两个分量(这两个分量上的 uv 变化最大)对应的方程进行求解。<br />
</p>
</div>
</div>

<div id="outline-container-orgb7ffc9c" class="outline-6">
<h6 id="orgb7ffc9c">Filtering Texture Functions</h6>
<div class="outline-text-6" id="text-orgb7ffc9c">
<p>
为了计算不带 aliasing 的 T(f(x,y)) ，我们需要先将该函数和 sinc 过滤器卷积，将超过 Nyquist 限制的频率移除掉，这样就得到基带有限的函数。再将基带有限的函数和屏幕上的像素过滤器函数进行卷积，从而得到贴图函数：<br />
<img src="./PhysicallyBasedRendering/2020_06_28_tex_func_004.jpg" alt="2020_06_28_tex_func_004.jpg" /><br />
在实践中，对于上面的过程可以做很多简化，例如，使用一个 BoxFilter 代替 sinc 用于移除高频率内容，并且将第二步完全忽略，这相当于将 BoxFilter 当作像素过滤器。这样整个 antialiasing 工作就完全可以在贴图空间进行了，极大简化了贴图函数的实现。<br />
理想的 sinc 过滤器可以让低于 Nyquist 限制的频率分量通过，但是移除高于 Nyquist 限制的频率分量。因此，如果我们知道贴图函数的内容频率，我们可以将高频项用其平均值代替，这样就高效地完成了 sinc 预过滤器的工作。<br />
supersampling 技术：贴图函数在主点旁边的多个位置上被求解和过滤，这样就对应增加了贴图空间的采样率。如果 Box 过滤器被应用于这些样本值，这等价于对函数值进行平均。如果贴图函数的求解很复杂，则该方法会很昂贵。但是，其比增加渲染图片采样率要高效很多，因为其不会导致追踪多个穿越场景的射线。<br />
</p>
</div>
</div>
<div id="outline-container-org75939b4" class="outline-6">
<h6 id="org75939b4">Ray Differentials For Specular Reflection And Transmission</h6>
<div class="outline-text-6" id="text-org75939b4">
<p>
为了计算在表面交点处，反射或透射的微分射线，我们需要对射线 r 进行近似得到 r'，r'和表面有新的交点，则对 r'进行射线追踪。如下图：<br />
<img src="./PhysicallyBasedRendering/2020_06_28_reflect_ray_differential_01.jpg" alt="2020_06_28_reflect_ray_differential_01.jpg" /><br />
r'和表面的交点可以通过对 r 和表面的交点进行偏移得到，偏移量为∂p/∂x 和 ∂p/∂y。<br />
r'的方向可以通过下面公式计算得到：<br />
<img src="./PhysicallyBasedRendering/2020_06_28_reflect_ray_differential.jpg" alt="2020_06_28_reflect_ray_differential.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_06_28_reflect_ray_differential_001.jpg" alt="2020_06_28_reflect_ray_differential_001.jpg" /><br />
对应的代码实现在 SamplerIntegrator::SpecularReflect 函数中。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7393016" class="outline-5">
<h5 id="org7393016">Texture Coordinate Generation</h5>
<div class="outline-text-5" id="text-org7393016">
<p>
TODO SurfaceInteraction 中的 dudx 为表面上点对渲染图片上 x 方向的导数。如何理解下面求得的 uv 坐标呢？<br />
<img src="./PhysicallyBasedRendering/2020_06_29_tex_mapping_001.jpg" alt="2020_06_29_tex_mapping_001.jpg" /><br />
</p>
</div>
<div id="outline-container-org072015c" class="outline-6">
<h6 id="org072015c">2D(u,v) Mapping</h6>
<div class="outline-text-6" id="text-org072015c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">su sv &#20026;&#32553;&#25918;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">du dv &#20026;&#20559;&#31227;</span>
UVMapping2D::UVMapping2D(<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">su</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">sv</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">du</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">dv</span>)
: su(su), sv(sv), du(du), dv(dv) {}

<span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #bc6ec5; font-weight: bold;">UVMapping2D</span>::Map(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> &amp;si, <span style="color: #ce537a; font-weight: bold;">Vector2f</span> *<span style="color: #7590db;">dstdx</span>, <span style="color: #ce537a; font-weight: bold;">Vector2f</span> *<span style="color: #7590db;">dstdy</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#32553;&#25918;&#20559;&#31227;&#36816;&#31639;&#21487;&#20197;&#36890;&#36807;&#27714;&#23548;&#25512;&#23548;&#20986;&#26469;&#65292;&#35814;&#24773;&#21442;&#32771;&#21407;&#20070;&#20869;&#23481;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute texture differentials for 2D identity mapping</span>
    *dstdx = Vector2f(su * si.dudx, sv * si.dvdx);
    *dstdy = Vector2f(su * si.dudy, sv * si.dvdy);
    <span style="color: #4f97d7; font-weight: bold;">return</span> Point2f(su * si.uv[0] + du, sv * si.uv[1] + dv);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc9e3b47" class="outline-6">
<h6 id="orgc9e3b47">Spherical Mapping</h6>
<div class="outline-text-6" id="text-orgc9e3b47">
<p>
SphereMapping 的原理是将一个球放在物体中心，物体上每个点都沿着该点到球心的方向投影到球表面，使用球上投影点的 uv 作为物体上对应点的 uv。<br />
</p>
</div>
</div>
<div id="outline-container-orgdf2959b" class="outline-6">
<h6 id="orgdf2959b">Cylindrical Mapping</h6>
<div class="outline-text-6" id="text-orgdf2959b">
<p>
将物体投影到圆柱体上。<br />
</p>
</div>
</div>
<div id="outline-container-org2ece670" class="outline-6">
<h6 id="org2ece670">Planar Mapping</h6>
<div class="outline-text-6" id="text-org2ece670">
<p>
我们可以使用两个不平行的向量 Vs 和 Vt 以及两个偏移量 Ds 和 Dt 定义一个参数化平面。物体上每一点到原点的向量和 Vs、Vt 分别点积再分别进行 Ds、Dt 偏移，从而得到对应的贴图坐标。<br />
假如选择 Vs=(1,0,0) Vt=(0,1,0) Ds=Dt=0，这相当于将 z=0 的平面作为投影平面，此时 s=Px t=Py.<br />
</p>
</div>
</div>
<div id="outline-container-org1933397" class="outline-6">
<h6 id="org1933397">3DMapping</h6>
<div class="outline-text-6" id="text-org1933397">
<p>
对世界坐标的点进行线性变换(通常取世界空间到物体空间的变换)，直接拿变换后的世界坐标作为 3D 贴图坐标。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org500ca16" class="outline-5">
<h5 id="org500ca16">Texture Interface and Basic Textures</h5>
<div class="outline-text-5" id="text-org500ca16">
<div class="org-src-container">
<pre class="src src-c">template &lt;typename T&gt;
class Texture {
  <span style="color: #a45bad;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Texture Interface</span>
    virtual <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> &amp;) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
    virtual ~Texture() {}
};
</pre>
</div>
</div>
<div id="outline-container-org95c201f" class="outline-6">
<h6 id="org95c201f">ConstantTexture</h6>
</div>

<div id="outline-container-org54e1ba4" class="outline-6">
<h6 id="org54e1ba4">Scale Texture</h6>
<div class="outline-text-6" id="text-org54e1ba4">
<p>
ScaleTexture 取两个贴图，返回这两个贴图值的乘积。<br />
ScaleTexture 忽略抗锯齿，将抗锯齿工作留给它的两个子贴图。尽管两个带宽有限的函数的积也是带宽有限的，但是乘积的最高频率可能比其中任何一个子贴图的频率都高。因此，即使两个贴图都进行了抗锯齿操作，它们的乘积依然可能会有锯齿。<br />
幸好该类通常用于拿一个常数去缩放另一张贴图，此时被缩放贴图做抗锯齿就够了。<br />
</p>
</div>
</div>
<div id="outline-container-orgd3c6c0e" class="outline-6">
<h6 id="orgd3c6c0e">Mix Textures</h6>
<div class="outline-text-6" id="text-orgd3c6c0e">
<p>
MixTexture 为更一般化的 ScaleTexture。其取三个贴图作为输入，其中两个可以为任意类型第三个的返回值必须为浮点值。浮点贴图为前两张贴图线性插值的权重。<br />
</p>
</div>
</div>

<div id="outline-container-orgd395cec" class="outline-6">
<h6 id="orgd395cec">BilinearInterpolation</h6>
<div class="outline-text-6" id="text-orgd395cec">
<p>
BilerpTexture 提供在 4 个常数之间进行线性插值。这 4 个常数定义在(s,t)参数空间的(0,0) (1,0) (0,1) (1,1)四个位置处。<br />
<img src="./PhysicallyBasedRendering/2020_06_29_bilerp_tex.jpg" alt="2020_06_29_bilerp_tex.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgdc3f1de" class="outline-5">
<h5 id="orgdc3f1de">Image Texture</h5>
<div class="outline-text-5" id="text-orgdc3f1de">
<p>
ImageTexture 类存储了一个 2D 数组，该数组的每个元素为贴图函数的点样本值。该类使用这些样本重建一个连续的图片函数，用于计算任意一点(s,t)的值。这些样本值通常被称为贴图图元(texels)。<br />
ImageTexture 模板类，对返回类型和贴图图元类型都进行了参数化。<br />
</p>
</div>
<div id="outline-container-org8426a26" class="outline-6">
<h6 id="org8426a26">Texture Memory Management</h6>
<div class="outline-text-6" id="text-org8426a26">
<p>
在一个场景中，每个图片贴图可能被重复使用多次，因此 pbrt 维护了一张图片表，用于记录已经被加载的图片，这样即使图片被多个 ImageTexture 使用，其也只需要加载一次。ImageTexture 构造函数通过调用 static ImageTexture::GetTexture() 函数得到所需贴图的一个 MipMap 表示。<br />
下图为 sRGB gamma 曲线函数，其为一个分段函数:<br />
<img src="./PhysicallyBasedRendering/2020_06_29_gamma_correct_equ.jpg" alt="2020_06_29_gamma_correct_equ.jpg" /><br />
</p>

<p>
将图片数据从文件中读出来后，先转化为 Tmemory 类型的数据，然后再执行缩放和 gamma 矫正，最后将得到的数据存到 mipmap 中。<br />
Tips: scale 参数并不是改变图片分辨率，而是直接对贴图图元值进行缩放。<br />
</p>
</div>
</div>

<div id="outline-container-org034cce7" class="outline-6">
<h6 id="org034cce7">MipMaps</h6>
<div class="outline-text-6" id="text-org034cce7">
<p>
贴图函数包含的频率过高，贴图采样率不足以表示，会导致 aliasing。对贴图函数进行求值之前，需要通过预过滤操作，移除任何高于 Nyquist 限制的频率。<br />
ImageTexture 的贴图图元是对贴图函数进行固定频率采样得到的一组样本。对贴图进行采样时，需要过滤的区域由中心点的贴图坐标(s, t)以及估算到的邻接图片样本对应的贴图坐标的偏移共同决定。这些偏移值就是估算的贴图采样率，我们必须移除频率高于两倍邻接图片样本的内容，来满足 Nyquist 标准。<br />
<img src="./PhysicallyBasedRendering/image_mipmap_theory.jpg" alt="image_mipmap_theory.jpg" /><br />
</p>

<p>
贴图采样和重建过程与第七章的图片采样过程有关键的不同。对贴图采样来说，获取样本值是不昂贵的(只需要对数组进行查询就可以了，图片采样则需要追踪额外数量的射线并计算辐射率)。贴图函数完全由一组样本定义，并且贴图函数在样本之间的行为是确定的。这些差异，使得我们可以在采样之前移除贴图的细节，从而消除 aliasing。<br />
</p>

<p>
MIPMap 实现了两种方法用于过滤宽度可变的高效贴图过滤。trilinear interpolation 和 elliptically weighted averaging(比第一个方法更慢更复杂，但是效果非常好)。<br />
为了限制需要访问的图元数量，这两种过滤方法都使用了 image pyramid 增加原图片的低分辨率预过滤版本来加速运算。原始图片的图元在金字塔底层，一直到最上层，只有一个图元，其为原始图片的所有图元的平均值。这个图片集合需要多于原始图片 1/3 的内存来存储。<br />
</p>

<p>
pbrt 中实现 image pyramid 时，会判断原始图片的分辨率是否为 2 的幂次，如果不是，会将图片放大到最近的 2 的幂次。放大图片涉及到了第 7 章中讲的采样和重建的理论。我们有一个图片函数，其由按照某个采样率进行采样得到的一组样本表示。我们使用原始样本重建一个连续图片函数，然后对新的图片函数按照一组新的样本位置(新的采样率)进行采样。因为新的采样增加了采样频率，因此不需要担心采样过疏导致高频分量出现。下图展示了，这种放大图片的 1D 图示：<br />
<img src="./PhysicallyBasedRendering/2020_06_29_enlarge_image_1d.jpg" alt="2020_06_29_enlarge_image_1d.jpg" /><br />
</p>

<p>
MIPMap 使用了可分离的重建过滤器，可分离的过滤器可以写为两个 1D 过滤器的积：f(x,y) = f(x)f(y). 使用可分离过滤器的一个优点是，当我们对图片进行重新采样使其分辨率从(s,t)变为(s',t')时，可以使用两个 1D 步骤来实现对图片的重新采样，这样我们需要访问的图元数量为过滤器宽度的线性函数，而不是二次函数。<br />
重新构建原始图片函数，然后对其在新的贴图图元位置进行采样。这等价于将重建过滤器核放在新的图元位置，然后加权附近的贴图图元。这样，每个新的图元就是原始图片中一小部分贴图图元的加权平均。<br />
</p>

<p>
考虑原始分辨率为 3，那么新的分辨率为 4。MIPMap::resampleWeights 生成重新采样权重的原理如下图：<br />
<img src="./PhysicallyBasedRendering/2020_06_30_mipmap_enlarge_tex.jpg" alt="2020_06_30_mipmap_enlarge_tex.jpg" /><br />
</p>

<p>
为了计算过滤后的值，每一次贴图查询通常需要使用 8-20 个贴图图元，因此精心选择贴图图元的内存分布来减少访问时的 cache miss 可以极大提高性能。<br />
MIPMap 使用了一个简单的 BoxFilter 对上一层级的 4 个图元进行平均得到当前层级的图元的值。使用 Lanczos Filter 可以得到一个更好的结果。<br />
</p>
</div>
</div>
<div id="outline-container-orge63fa51" class="outline-6">
<h6 id="orge63fa51">Isotropic Triangle Filter</h6>
<div class="outline-text-6" id="text-orge63fa51">
<p>
各项同性的过滤算法的主要缺点是，当以倾斜的角度看贴图时会显得有些模糊。因为倾斜角度看贴图时，沿不同的轴采样率需要不同，而各项同性的过滤算法，各个方向采样率相同。<br />
以很宽的过滤器对很多图元进行过滤会非常低效。因此 MIPMap 会选择某个层级的贴图使得过滤区域只包含 4 个图元。其原理如下图：<br />
</p>


<div id="orgd5b85d8" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_30_mipmap_select.jpg" alt="2020_06_30_mipmap_select.jpg" /><br />
</p>
</div>

<p>
双线性过滤的原理：<br />
<img src="./PhysicallyBasedRendering/2020_06_30_bilinear_filter.jpg" alt="2020_06_30_bilinear_filter.jpg" /><br />
</p>

<p>
计算出的 MipMap 层级 level 为 float 值，对 floor(level) 和 floor(level)+1 层贴图执行三角滤波，然后对滤波后的结果进行线性插值就得到最终的贴图值。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">if</span> (level &lt; 0)
    <span style="color: #4f97d7; font-weight: bold;">return</span> triangle(0, st);
<span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> (level &gt;= Levels() - 1)
    <span style="color: #4f97d7; font-weight: bold;">return</span> Texel(Levels() - 1, 0, 0);
<span style="color: #4f97d7; font-weight: bold;">else</span> {
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iLevel</span> = std::floor(level);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">delta</span> = level - iLevel;
    <span style="color: #4f97d7; font-weight: bold;">return</span> Lerp(delta, triangle(iLevel, st), triangle(iLevel + 1, st));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0614358" class="outline-6">
<h6 id="org0614358">Elliptically Weighted Average</h6>
<div class="outline-text-6" id="text-org0614358">
<p>
椭圆加权平均（EWA）算法将椭圆拟合到纹理空间中的两个轴, 这两个轴由纹理坐标差指定，然后使用高斯滤波函数对纹理进行滤波。不像上一节的三角滤波器，该滤波器支持任意朝向的贴图区域，其在不同方向上由不同的过滤边界。这种类型的滤波器被称为各项异性的。<br />
</p>


<div id="orgec5de57" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_30_ewa_filter_illustrate.jpg" alt="2020_06_30_ewa_filter_illustrate.jpg" /><br />
</p>
</div>

<p>
椭圆的离心率表示了椭圆的圆扁程度。离心率越小越接近于圆，越大则椭圆就越扁。EWA 是按照 minor axis 选择 MIPMap 层级的，当离心率大时，意味着需要过滤的图元数量会比较多。将 minor axis 的长度放大来限制椭圆的离心率。<br />
下图为所有在该椭圆内的点的方程：<br />
<img src="./PhysicallyBasedRendering/2020_06_30_ewa_ellipse_equ.jpg" alt="2020_06_30_ewa_ellipse_equ.jpg" /><br />
</p>

<p>
上面的隐式方程的一个比较好的特性是在特定图元处的值为 从椭圆中心到图元距离 和 从椭圆中心到椭圆边界距离 的平方比。这个值可用于对预计算的高斯过滤器函数值表进行索引。其原理如下图：<br />
<img src="./PhysicallyBasedRendering/2020_06_30_ewa_lookup_tbl.jpg" alt="2020_06_30_ewa_lookup_tbl.jpg" /><br />
</p>

<p>
关于该节的详细内容可以参考下面 知乎文章 EWA 的讲解。<br />
</p>
<ul class="org-ul">
<li>椭圆 <a href="https://baike.baidu.com/item/%E6%A4%AD%E5%9C%86">https://baike.baidu.com/item/%E6%A4%AD%E5%9C%86</a><br /></li>
<li>EWA <a href="https://zhuanlan.zhihu.com/p/105167411">https://zhuanlan.zhihu.com/p/105167411</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7a8d958" class="outline-5">
<h5 id="org7a8d958">Solid And Procedural Texture</h5>
<div class="outline-text-5" id="text-org7a8d958">
</div>
<div id="outline-container-orgac46bba" class="outline-6">
<h6 id="orgac46bba">UV Texture</h6>
<div class="outline-text-6" id="text-orgac46bba">

<div id="org7f35555" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_30_uv_texture.jpg" alt="2020_06_30_uv_texture.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga5ec4fc" class="outline-6">
<h6 id="orga5ec4fc">Checker Board</h6>
<div class="outline-text-6" id="text-orga5ec4fc">

<div id="org4d825af" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_30_checker_board_texture.jpg" alt="2020_06_30_checker_board_texture.jpg" /><br />
</p>
</div>

<p>
Checkerboard2DTexture 抗锯齿实现：<br />
当整个过滤区域都在同一个 check 中时，不需要执行抗锯齿。通过计算过滤区域的 BoundingBox，如果 BoundingBox 的边界在同一个 check 内，则说明过滤区域在同一个 check 内。此处使用了轴对齐的 BoundingBox，这简化了实现，但增加了过滤值的模糊度。<br />
<img src="./PhysicallyBasedRendering/2020_06_30_filter_area_bbox.jpg" alt="2020_06_30_filter_area_bbox.jpg" /><br />
当整个过滤区域不在同一个 check 中时。首先计算过滤区域覆盖的两种 check 的部分为多少。这等价于计算一个 2D 分段函数在过滤区域上的均值。得到均值后，我们就可以在这两种 check 之间进行混合了。<br />
<img src="./PhysicallyBasedRendering/2020_06_30_checker_board_func.jpg" alt="2020_06_30_checker_board_func.jpg" /><br />
</p>


<div id="orgff1a1a5" class="figure">
<p><img src="./PhysicallyBasedRendering/2d_checkerboard_pixel_value.jpg" alt="2d_checkerboard_pixel_value.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org83538d5" class="outline-6">
<h6 id="org83538d5">Solid Checker Board</h6>
<div class="outline-text-6" id="text-org83538d5">
<p>
我们可以基于 3D 贴图坐标定义一个立体的 CheckerBoard。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org644c2ae" class="outline-5">
<h5 id="org644c2ae">Noise</h5>
<div class="outline-text-5" id="text-org644c2ae">
<p>
程序化生成贴图时，无法在每次求解贴图值时，直接使用随机函数生成该点的贴图值，因为完全随机使得相邻的图元之间失去了连续性。<br />
图形学中使用 noise function 来实现程序化生成贴图中可控的随机性。通常 noise function 在 R^n-&gt;[-1,1]空间平滑变化（n=1,2,3），并且没有明显的重复。noise function 是基带有限的，其最大频率为已知的某个值。将 noise function 应用于贴图时，结果的频率是可控的，这样就不会导致高于 Nyquist 限制的频率内容被引入。<br />
很多 noise function 是基于 R^3 空间的整数格子的。首先，空间中每个整型的位置(x,y,z)都和一个值相关联。其次，给定空间中任何一个位置 P，确定其周围的 8 个格子，对这些格子的值进行插值得到 P 点最终的值。该方法可以被推广到任意维度的空间，对于 d 维空间，格子的数量为 2^d.<br />
</p>
</div>
<div id="outline-container-orgbd8fe12" class="outline-6">
<h6 id="orgbd8fe12">Perlin Noise</h6>
<div class="outline-text-6" id="text-orgbd8fe12">
<p>
Perlin noise 在所有的整型位置(x,y,z)处的值都为 0，其变化性来源于每个格子的梯度向量。<br />
梯度向量对所求点的影响通过下图方法来计算：<br />
<img src="./PhysicallyBasedRendering/2020_07_08_perlin_noise_01.jpg" alt="2020_07_08_perlin_noise_01.jpg" /><br />
指定整型格子的梯度向量是通过索引一个预计算的表(NoisePerm)得到的。NoisePerm 表中的值的低 4 位用于确定使用 16 个梯度向量中的哪个。<br />
NoisePerm 的生成方法为，先使用 0 到 NoisePermSize-1 对 NoisePerm 前 NoisePermSize 项进行填充，然后对这些数据进行随机排列，最后用这些数据填充后 NoisePermSize 项。<br />
</p>

<p>
下面文件为 3 维空间的梯度向量：<br />
<a href="./PhysicallyBasedRendering/perlin-3d-grad-vector.ggb">./PhysicallyBasedRendering/perlin-3d-grad-vector.ggb</a><br />
</p>

<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/Perlin%E5%99%AA%E5%A3%B0">https://zh.wikipedia.org/wiki/Perlin%E5%99%AA%E5%A3%B0</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/22337544">https://zhuanlan.zhihu.com/p/22337544</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org14e84e9" class="outline-6">
<h6 id="org14e84e9">Random Polka Dots</h6>
<div class="outline-text-6" id="text-org14e84e9">
<p>
polka dot texture 将贴图空间分为矩形 cells。每个 cell 有 50%几率包含一个点，这样点就会随机放置在不同的 cell 中。<br />
</p>
</div>
</div>
<div id="outline-container-org26aa88b" class="outline-6">
<h6 id="org26aa88b">Noise Idioms and Spectral Synthesis</h6>
<div class="outline-text-6" id="text-org26aa88b">
<p>
noise function 是基带有限的函数，这意味着可以通过缩放定义域来改变其频率内容。例如，Noise(2*p)的频率为 Noise(p)频率的二倍。<br />
可以通过下面的公式，使用频谱合成来计算模式从而丰富 noise 的细节：<br />
<img src="./PhysicallyBasedRendering/2020_07_08_spectral_synthesis_eq.jpg" alt="2020_07_08_spectral_synthesis_eq.jpg" /><br />
</p>

<p>
典型地，对于上面的公式，缩放因子 si、权重因子 wi 选择几何级数(等比数列)，si=2s(i-1)，权重因子 wi = w(i-1)/2。这使得高频率项对整体的影响相对要小。这里附加的项被称为一个八度 octave noise，因为其频率为前一个的两倍。当这个模式应用于 Perlin noise 时，结果被称为分形布朗运动 fractional Brownian motion.<br />
<img src="./PhysicallyBasedRendering/2020_07_08_fBm_graph.jpg" alt="2020_07_08_fBm_graph.jpg" /><br />
Fractional Brownian motion 对于程序化生成贴图是非常有用的构建要素，其比简单的 noise 有更复杂的变化，同时易于计算并且依然有很好的频率。<br />
fBm 的实现中使用了 clamping to antialias 的技术。其原理为，当我们计算一个基于很多项和的值时，已知每一项的频率，对于频率高于 Nyquist 限制的项，应该将该项的平均值用于求和。Noise()的平均值为 0。<br />
Noise()内容的最大频率粗略为 1。每个子项表示 2 倍频率的内容。假设 noise 空间的采样频率为 s，由下面公式可以计算出最多可以有多少项：<br />
第 1   项的频率为   \(s/2^{n-1} = 1\)<br />
第 2   项的频率为   \(s/2^{n-2}\)<br />
&#x2026;<br />
第 n-1 项的频率为   \(s/2\)<br />
第 n   项的频率为   \(s\)<br />
<img src="./PhysicallyBasedRendering/2020_07_08_fBm_n.jpg" alt="2020_07_08_fBm_n.jpg" /><br />
</p>

<p>
和 fBm() 类似的一个函数为 Turbulence()。绝对值会导致一阶不连续性。其图像如下：<br />
<img src="./PhysicallyBasedRendering/2020_07_08_turbulence_graph.jpg" alt="2020_07_08_turbulence_graph.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org6144c51" class="outline-6">
<h6 id="org6144c51">Bumpy and wrinkled textures</h6>
<div class="outline-text-6" id="text-org6144c51">
<p>
fBm 和 Turbulence 函数可用于实现 Bump 贴图和 Wrinkeled 贴图。<br />
</p>
</div>
</div>
<div id="outline-container-org549927c" class="outline-6">
<h6 id="org549927c">Windy Waves</h6>
<div class="outline-text-6" id="text-org549927c">
<p>
fBm 可用于实现波纹。<br />
</p>
</div>
</div>
<div id="outline-container-org9b3c961" class="outline-6">
<h6 id="org9b3c961">Marble</h6>
<div class="outline-text-6" id="text-org9b3c961">
<p>
noise function 的另一种用途为扰乱贴图坐标。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org490f0fb" class="outline-4">
<h4 id="org490f0fb">11 Volume Scattering</h4>
<div class="outline-text-4" id="text-org490f0fb">
<p>
可见光的波长约在 400～700 nm 之间，当光线射入分散体系时，一部分自由地通过，一部分被吸收、反射或散射，可能发生以下三种情况：<br />
（1）当光束通过粗分散体系，由于分散质的粒子大于入射光的波长，主要发生反射或折射现象，使体系呈现混浊。<br />
（2）当光线通过胶体溶液，由于分散质粒子的直径一般在 1～100 nm 之间，小于入射光的波长，主要发生散射，可以看见乳白色的光柱，出现丁达尔现象。<br />
（3）当光束通过分子溶液，由于溶液十分均匀，散射光因相互干涉而完全抵消，看不见散射光。<br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E4%B8%81%E8%BE%BE%E5%B0%94%E6%95%88%E5%BA%94">https://baike.baidu.com/item/%E4%B8%81%E8%BE%BE%E5%B0%94%E6%95%88%E5%BA%94</a><br /></li>
</ul>
</div>
<div id="outline-container-org39ce91f" class="outline-5">
<h5 id="org39ce91f">Volume Scattering Processes</h5>
<div class="outline-text-5" id="text-org39ce91f">
<p>
在有介质的环境中，主要有三个过程会影响辐射的分布：<br />
</p>
<ol class="org-ol">
<li>Absorption：辐射的减少主要是因为光的能量转化为其他形式的能量，例如热能<br /></li>
<li>Emission：发光的粒子会增加辐射在环境中的分布<br /></li>
<li>Scattering：朝向某个方向的辐射因为碰到了粒子而被散射到了其他方向<br /></li>
</ol>
</div>
<div id="outline-container-org6dc1330" class="outline-6">
<h6 id="org6dc1330">Absorption</h6>
<div class="outline-text-6" id="text-org6dc1330">
<p>
吸收是通过介质的吸收横截面来描述的，其为光在介质中传播单位距离被吸收的概率。尽管吸收截面通常为 p(位置)的函数，但通常会随 p(位置)和 w(光方向)变化。其也会随光的频率而变化。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_absorption_eq.jpg" alt="2020_07_09_absorption_eq.jpg" /><br />
</p>

<p>
上图中有一个自然底数 e 的积分，其指数部分的积分表示吸收率的积分。其意义的详细解释可以参考《An Intuitive Guide To Exponential Functions &amp; e》。<br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E5%90%B8%E6%94%B6%E6%88%AA%E9%9D%A2">https://baike.baidu.com/item/%E5%90%B8%E6%94%B6%E6%88%AA%E9%9D%A2</a><br /></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%90%B8%E6%94%B6%E6%88%AA%E9%9D%A2">https://zh.wikipedia.org/wiki/%E5%90%B8%E6%94%B6%E6%88%AA%E9%9D%A2</a><br /></li>
<li>An Intuitive Guide To Exponential Functions &amp; e <a href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/">https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/</a><br /></li>
</ul>

<p>
上面微分方程求解参考如下链接：<br />
</p>
<ul class="org-ul">
<li>体渲染数学原理 <a href="https://zhuanlan.zhihu.com/p/56710440">https://zhuanlan.zhihu.com/p/56710440</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0b53c2f" class="outline-6">
<h6 id="org0b53c2f">Emission</h6>
<div class="outline-text-6" id="text-org0b53c2f">
<p>
光线经过介质时，由于化学、热或原子能等过程，将能量转化为可见光，这会增强光线。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_emission_eq.jpg" alt="2020_07_09_emission_eq.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd705b96" class="outline-6">
<h6 id="orgd705b96">Out-Scattering And Attenuation</h6>
<div class="outline-text-6" id="text-orgd705b96">
<p>
光碰到粒子后被散射到不同方向，从而减少该方向上光的辐射量，这种现象被称为 out-scattering。<br />
由于吸收和外散射导致辐射的减少被统称为衰减或消光.<br />
散射系数和消光系数的比值被称为 albedo 反照率，其描述了散射相对于吸收的概率。<br />
1/消光系数被称为平均自由程，其描述了光线在介质中传播时，碰到介质粒子之前所经过的平均距离。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_attenuation_eq.jpg" alt="2020_07_09_attenuation_eq.jpg" /><br />
</p>

<p>
<a id="orgb3dace6"></a><br />
</p>


<div id="orgeef3300" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_09_triansmition_eq.jpg" alt="2020_07_09_triansmition_eq.jpg" /><br />
</p>
</div>

<p>
在均匀介质中(homogeneous medium)，衰减系数为常数。<br />
</p>

<ul class="org-ul">
<li>An Intuitive Guide To Exponential Functions &amp; e <a href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/">https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/</a><br /></li>
<li>用 C 语言画光（七）：比尔-朗伯定律 <a href="https://zhuanlan.zhihu.com/p/31901449">https://zhuanlan.zhihu.com/p/31901449</a><br /></li>
</ul>

<p>
上面微分方程求解参考如下链接：<br />
</p>
<ul class="org-ul">
<li>体渲染数学原理 <a href="https://zhuanlan.zhihu.com/p/56710440">https://zhuanlan.zhihu.com/p/56710440</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7fe2c19" class="outline-6">
<h6 id="org7fe2c19">In-Scattering</h6>
<div class="outline-text-6" id="text-org7fe2c19">
<p>
由于将其他方向的光散射到当前方向上，因此内散射会增加光的辐射量。<br />
假定粒子之间的间隔至少为他们半径的几倍，此时描述特定点的散射时，就可以忽略掉粒子之间的交互。在这种假设下，phase function 可以描述散射辐射在某点的角度分布，其为 BSDF 的体积模拟。<br />
</p>


<div id="org6bc9d85" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_09_inscattering_eq.jpg" alt="2020_07_09_inscattering_eq.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E7%9B%B8%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E7%9B%B8%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org01b9d59" class="outline-6">
<h6 id="org01b9d59">参考资料</h6>
<div class="outline-text-6" id="text-org01b9d59">
<p>
上面微分方程求解参考如下链接：<br />
</p>
<ul class="org-ul">
<li>体渲染数学原理 <a href="https://zhuanlan.zhihu.com/p/56710440">https://zhuanlan.zhihu.com/p/56710440</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org31ead02" class="outline-5">
<h5 id="org31ead02">Phase Functions</h5>
<div class="outline-text-5" id="text-org31ead02">
<p>
相函数 p(ωi-&gt;ω)表示ωi 方向射入的光散射到ω方向的概率密度。<br />
</p>

<p>
对于大多数自然存在的介质，相函数为角度的 1D 函数，该角度为入射方向和出射方向的夹角。因为入射光的照明不会随角度旋转而变化，这种 1D 相函数对应的介质被称为各项同性的。<br />
各项异性的介质由按照连续结构排列的粒子组成，其相函数为 4D 函数。Further Reading 中讨论这类介质。<br />
Phase function 本身也可以是各项同性或各项异性的。各项同性的介质可以有一个各项异性的相函数。<br />
各项同性的相函数描述了所有方向上都相同的散射，相函数是归一化的，因此各项同性的相函数只有一个：p(wo,wi) = 1/(4pi)<br />
</p>

<p>
henyey-greenstein 相函数为常用的相函数，下图展示了 g=-0.35 和 g=0.67 时 Henyey-Greenstein 相函数的图像。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_henyey-greenstein_PF.jpg" alt="2020_07_09_henyey-greenstein_PF.jpg" /><br />
<a href="./PhysicallyBasedRendering/2020_07_09_phase-func-henyey-greenstein.ggb">./PhysicallyBasedRendering/2020_07_09_phase-func-henyey-greenstein.ggb</a><br />
</p>

<p>
henyey-greenstein 模型中的 g 有精确的意义。其为被近似的相函数和夹角（入射方向和散射方向夹角）余弦值乘积的平均值。给定任意相函数 p，通过下面公式计算 g：<br />
对于各项同性的相函数 p(wo,wi)=1/(4pi)，带入下面方程可以求得 g=0。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_PF_g_param.jpg" alt="2020_07_09_PF_g_param.jpg" /><br />
</p>

<p>
有很多 phase function 都可以满足求解 g 的方程，单个 g 值不足以唯一表示一个散射分布。但是，将复杂的散射分布转化为简单参数模型要比精确性上的损失更重要。<br />
无法使用单个不对称参数 g 描述的相函数，经常可以通过相函数的权重和来描述，每个相函数有不同的不对称参数：<br />
<img src="./PhysicallyBasedRendering/2020_07_09_multi_PF.jpg" alt="2020_07_09_multi_PF.jpg" /><br />
</p>


<ul class="org-ul">
<li>相函数 <a href="https://baike.baidu.com/item/%E7%9B%B8%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E7%9B%B8%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org71df033" class="outline-5">
<h5 id="org71df033">Media</h5>
<div class="outline-text-5" id="text-org71df033">
<p>
Medium 基类提供了空间区域中的各种体积散射属性。在复杂的场景，可能有多个 Medium 实例，每个实例表示一种不同的散射效果。例如：户外河流场景可能有 1 个 Medim 用于模拟大气散射，另一个模拟从河流升起的薄雾，一个模拟河面悬浮的粒子。<br />
</p>

<p>
在 pbrt 中，两种散射介质之间的边界总是由 GeometricPrimitive 的表面表示的。其并非保持一个 Medium 指针，而是保持一个 MediumInterface 指针，MediumInterface 保存了两个 Medim 指针，一个表示内部的介质，一个表示外部的介质。<br />
</p>

<p>
和 Primitives 关联的形状表示了介质的边界，其通常也和一个材质相关联。例如，河水的表面可能会使用一个 GlassMaterial 来描述河水表面的散射，其也为从河水升起的薄雾介质和河水介质的边界。然而，有时候我们需要形状的边界表面来限制介质的边界，并不想看到边界表面本身。例如，可能使用一个 Box 来表示云的介质的边界，其应该只限制云的范围，而不影响光通过该 Box。<br />
pbrt 中，若 surface 的 Material 为 nullptr，则表示其不影响光线，对应的 SurfaceInteraction::bsdf 也是 nullptr.<br />
</p>
</div>
<div id="outline-container-org7b66ca4" class="outline-6">
<h6 id="org7b66ca4">Medium Interactions</h6>
<div class="outline-text-6" id="text-org7b66ca4">
<p>
MediumInteraction 表示在散射介质中，某点的相互作用。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">MediumInteraction</span> : public Interaction
  {
    <span style="color: #a45bad;">public</span>:
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MediumInteraction Public Methods</span>
      <span style="color: #a45bad;">MediumInteraction</span>() : phase(nullptr) {}
      MediumInteraction(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;p, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">time</span>,
                        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Medium</span> *<span style="color: #7590db;">medium</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">PhaseFunction</span> *<span style="color: #a45bad;">phase</span>)
          : Interaction(p, wo, time, medium), phase(phase) {}
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">IsValid</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> { <span style="color: #4f97d7; font-weight: bold;">return</span> phase != nullptr; }

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MediumInteraction Public Data</span>
      <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">PhaseFunction</span> *<span style="color: #7590db;">phase</span>;
  };
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcd973e7" class="outline-6">
<h6 id="orgcd973e7">Homogeneous Medium</h6>
<div class="outline-text-6" id="text-orgcd973e7">
<p>
齐次介质是最简单的介质。在这种介质区域内，光传播单位距离被吸收的概率&sigma;<sub>a</sub>为常量值，光传播单位距离被散射的概率&sigma;<sub>s</sub>也为常量值。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">HomogeneousMedium Declarations</span>
<span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">HomogeneousMedium</span> : public Medium {
  <span style="color: #a45bad;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">HomogeneousMedium Public Methods</span>
    HomogeneousMedium(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;sigma_a, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;sigma_s, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">g</span>)
        : sigma_a(sigma_a), <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21560;&#25910;&#27010;&#29575;</span>
          sigma_s(sigma_s), <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25955;&#23556;&#27010;&#29575;</span>
          sigma_t(sigma_s + sigma_a), <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28040;&#20809;&#31995;&#25968;</span>
          g(g) {}
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Tr</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;ray, Sampler &amp;sampler) <span style="color: #4f97d7; font-weight: bold;">const</span>;
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Sample</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;ray, Sampler &amp;sampler, MemoryArena &amp;arena,
                    <span style="color: #ce537a; font-weight: bold;">MediumInteraction</span> *<span style="color: #7590db;">mi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>;

  <span style="color: #a45bad;">private</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">HomogeneousMedium Private Data</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">sigma_a</span>, <span style="color: #7590db;">sigma_s</span>, <span style="color: #7590db;">sigma_t</span>;
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">g</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org55b3716" class="outline-6">
<h6 id="org55b3716">3D Grids</h6>
<div class="outline-text-6" id="text-org55b3716">
<p>
GridDensityMedium 类将介质的密度存储为一个 3D 格子。通过对样本进行插值来得到特定点的介质密度。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4b8fda9" class="outline-5">
<h5 id="org4b8fda9">The BSSRDF</h5>
<div class="outline-text-5" id="text-org4b8fda9">
<p>
下图为 BSSRDF 双向散射表面分布函数：<br />
<img src="./PhysicallyBasedRendering/2020_07_09_bssrdf_eq.jpg" alt="2020_07_09_bssrdf_eq.jpg" /><br />
</p>

<p>
Tips: 上面 S 的方程中，分母为通量。<br />
</p>
</div>
<div id="outline-container-org90b1614" class="outline-6">
<h6 id="org90b1614">Separable BSSRDFS</h6>
<div class="outline-text-6" id="text-org90b1614">
<p>
对于高反照率介质(high-albedo media),散射辐射分布通常是各项同性的，并且 Fresnel 透射比是定义最终方向分布的最重要的因素。<br />
对于低反照率介质(low-albedo media), 方向变化是有意义的，下面这种近似会少一些精确性。<br />
<img src="./PhysicallyBasedRendering/2020_07_09_separable_bssrdf_eq.jpg" alt="2020_07_09_separable_bssrdf_eq.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_07_09_separable_bssrdf_eq_02.jpg" alt="2020_07_09_separable_bssrdf_eq_02.jpg" /><br />
Tips: Sp 项即 profile 项，其概念和皮肤渲染中的 diffuse profile 应该一样。<br />
</p>

<p>
解耦 S 的空间和方向参数明显减低了 S 的维度，但是没有从根本上解决难题，对于任意形状的表面 Sp 项很难求解，此处引入近似的方法，用 Sr 来近似 Sp，Sr 的具体计算请参考下一节 <a href="#org9371f9f">Tabulated BSSRDF</a>。<br />
</p>
<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E5%8F%8D%E7%85%A7%E7%8E%87">https://baike.baidu.com/item/%E5%8F%8D%E7%85%A7%E7%8E%87</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E7%9F%A9">https://baike.baidu.com/item/%E7%9F%A9</a><br /></li>
<li>一阶矩 二阶矩 三阶矩 <a href="https://www.cnblogs.com/mld-code-life/p/11172796.html">https://www.cnblogs.com/mld-code-life/p/11172796.html</a> <br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9371f9f" class="outline-6">
<h6 id="org9371f9f">Tabulated BSSRDF</h6>
<div class="outline-text-6" id="text-org9371f9f">
<p>
TabulatedBSSRDF 类提供了访问表格表示的 BSSRDF，其可以处理很多散射 profile，包括从真实世界测量得到的 BSSRDF。<br />
需要特别注意的是，当所有的 BSSRDF 的材质属性固定时，radial profile Sr 只是一个 1D 函数。更一般地，其依赖于四个额外的参数：折射率η，散射各向异性 g，反照率ρ，以及消光系数σt。完整的 Sr 函数为 Sr(η, g, ρ, σt , r)，对于离散化来说，这个函数维度过高了。我们需要移除或者固定一些参数。<br />
考虑唯一的有物理单位的参数σt, 该参数用于度量单位距离上散射和吸收交互的概率。其效果只是控制 BSRDF profile 的空间缩放。为了减少维度，我们将σt 固定为 1.<br />
运行时，当查询给定σt 和半径 r 的 Sr 时，我们使用如下方程进行计算：<br />
<img src="./PhysicallyBasedRendering/2020_07_10_sr_eq.jpg" alt="2020_07_10_sr_eq.jpg" /><br />
实践中，我们也会将η, g 固定下来，这意味着这些参数对于物体来说不能贴图化。这些简化，使我们得到一个非常易于管理的 2D 函数，其只需要在ρ(Tips:反照率 ρ=σs/σt), optical radius 两个参数上进行离散化。<br />
</p>

<p>
注意 TabulatedBSSRDF::rho 成员变量给出了单次散射后能量的减少。这和材质整体的反照率(albedo)不同，材质整体的反照率将所有阶的散射都计算在内。将单次散射反照率记为ρ,将材质整体的反照率记为ρeff。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_peff_eq.jpg" alt="2020_07_10_peff_eq.jpg" /><br />
ρeff 为ρ的非线性单调递增函数。<br />
</p>
</div>
</div>
<div id="outline-container-orgebc9582" class="outline-6">
<h6 id="orgebc9582">Subsurface Scattering Materials</h6>
<div class="outline-text-6" id="text-orgebc9582">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29992;&#20110;&#35745;&#31639;&#20132;&#28857;&#22788;&#30340;&#25955;&#23556;&#23646;&#24615;</span>
SubsurfaceMaterial::ComputeScatteringFunctions(<span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, MemoryArena &amp;arena, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">allowMultipleLobes</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
</pre>
</div>
<p>
直接设置吸收和散射系数来达到希望的表现效果是很难的。这些参数都不是线性的，而且也不直观。KdSubsurfaceMaterial 允许用户按照表面漫反射的术语来设置次表面散射属性，以及平均自由程(mean free path)1/σt。需要注意的是，表面属性的变化并不对应于介质中属性的变化。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga2ba111" class="outline-4">
<h4 id="orga2ba111">12 Light Source</h4>
<div class="outline-text-4" id="text-orga2ba111">
</div>
<div id="outline-container-orgc0cdc00" class="outline-5">
<h5 id="orgc0cdc00">Light Emission</h5>
<div class="outline-text-5" id="text-orgc0cdc00">
<p>
所有温度高于绝对 0 度的物体都有原子在运动。正如麦克斯韦方程描述的，运动的带电原子粒子会发出某个波长范围内的电磁辐射。室温下的物体发出的大多数为红外线频率，我们很少能看到。物体需要很高的温度才能发出可见频率的光。<br />
</p>
<ul class="org-ul">
<li>钨丝白炽灯(Incandescent-tungsten lamps)：电子经过钨丝会让钨丝发热，这导致其发出电磁辐射，该电磁辐射的波长分布依赖于钨丝的温度。其发出的电磁辐射大部分为红外线波段，这意味着白炽灯消耗的大部分能量被转化为热能。<br /></li>
<li>卤素灯(Halogen lamps)：其也有钨丝，但是卤素灯内的气体为卤素气体。在高温下，升华的钨丝与卤素进行化学作用，冷却后的钨会重新凝固在钨丝上，形成平衡的循环，避免钨丝过早断裂。因此卤素灯泡比白炽灯更长寿。气化后的钨丝不会附着在灯泡表面，也不会减低灯泡亮度。<br />
  卤族元素指周期系ⅦA 族元素。包括氟（F）、氯（Cl）、溴（Br）、碘（I）、砹（At），简称卤素。<br />
<a href="https://baike.baidu.com/item/%E5%8D%A4%E7%B4%A0%E7%81%AF%E6%B3%A1">https://baike.baidu.com/item/%E5%8D%A4%E7%B4%A0%E7%81%AF%E6%B3%A1</a><br /></li>
<li>气体放电灯(Gas-discharge lamps)：<br />
<a href="https://baike.baidu.com/item/%E6%B0%94%E4%BD%93%E6%94%BE%E7%94%B5%E7%81%AF">https://baike.baidu.com/item/%E6%B0%94%E4%BD%93%E6%94%BE%E7%94%B5%E7%81%AF</a><br /></li>
<li>LED 灯<br />
<a href="https://baike.baidu.com/item/LED%E7%81%AF">https://baike.baidu.com/item/LED%E7%81%AF</a><br /></li>
</ul>

<p>
对于所有的这些光源，其底层物理过程都是电子和原子撞击，将原子外层的电子推到更高能量级。当电子返回低能量级时，就会有光子发射出来。<br />
</p>

<p>
照明效率测量了光源转化为可见照明的效率，其将人类观察的因素也计算在内。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_luminous_efficacy.jpg" alt="2020_07_10_luminous_efficacy.jpg" /><br />
</p>
</div>
<div id="outline-container-org355c3fc" class="outline-6">
<h6 id="org355c3fc">Blackbody Emitters</h6>
<div class="outline-text-6" id="text-org355c3fc">
<p>
黑体是一个完美的发射者：其完美地将能量转化为电磁辐射。黑体发射有封闭形式的表达式，其为温度和波长的函数。<br />
黑体吸收所有入射的能量，不会反射出任何能量。<br />
</p>

<p>
普朗克黑体辐射定律描述，在任意温度 T 下，从一个黑体中发射出的电磁辐射的辐射率与频率彼此之间的关系。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_blackbody_radiation.jpg" alt="2020_07_10_blackbody_radiation.jpg" /><br />
</p>

<p>
斯特藩-玻尔兹曼定律（Stefan–Boltzmann law）给出了空间中 p 点黑体的出射辐射。<br />
维恩位移定律（Wien’s displacement law）给出了给定温度下黑体辐射的波长。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_blackbody_law0203.jpg" alt="2020_07_10_blackbody_law0203.jpg" /><br />
</p>

<p>
基尔霍夫定律(Kirchoff ’s law) 描述了非黑体的发射行为，其描述了物体的发射率与吸收比之间的关系。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_kirchoff_law.jpg" alt="2020_07_10_kirchoff_law.jpg" /><br />
</p>

<p>
黑体发射分布提供了有用的度量标准用于描述非黑体发射特征，这种度量标准概念称为色温。如果一个发射体的 SPD 和同温度的黑体的分布相同，我们就称该发射体有对应的色温。<br />
</p>

<ul class="org-ul">
<li>黑体 <a href="https://baike.baidu.com/item/%E9%BB%91%E4%BD%93">https://baike.baidu.com/item/%E9%BB%91%E4%BD%93</a><br /></li>
<li>黑体辐射 <a href="https://baike.baidu.com/item/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84">https://baike.baidu.com/item/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84</a><br /></li>
<li>普朗克黑体辐射定律 <a href="https://zh.wikipedia.org/zh-hans/%E6%99%AE%E6%9C%97%E5%85%8B%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%AE%9A%E5%BE%8B">https://zh.wikipedia.org/zh-hans/%E6%99%AE%E6%9C%97%E5%85%8B%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%AE%9A%E5%BE%8B</a><br /></li>
<li>斯特藩-玻尔兹曼定律 <a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E8%97%A9-%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E5%AE%9A%E5%BE%8B">https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E8%97%A9-%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E5%AE%9A%E5%BE%8B</a><br /></li>
<li>维恩位移定律 <a href="https://baike.baidu.com/item/%E7%BB%B4%E6%81%A9%E4%BD%8D%E7%A7%BB%E5%AE%9A%E5%BE%8B">https://baike.baidu.com/item/%E7%BB%B4%E6%81%A9%E4%BD%8D%E7%A7%BB%E5%AE%9A%E5%BE%8B</a><br /></li>
<li>基尔霍夫定律 <a href="https://baike.baidu.com/item/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B/15860277">https://baike.baidu.com/item/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B/15860277</a><br /></li>
<li>色温 <a href="https://baike.baidu.com/item/%E8%89%B2%E6%B8%A9">https://baike.baidu.com/item/%E8%89%B2%E6%B8%A9</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org348268f" class="outline-6">
<h6 id="org348268f">Standard Illuminants</h6>
<div class="outline-text-6" id="text-org348268f">
<p>
<a href="https://baike.baidu.com/item/CIF%E6%A0%87%E5%87%86%E7%85%A7%E6%98%8E%E4%BD%93">https://baike.baidu.com/item/CIF%E6%A0%87%E5%87%86%E7%85%A7%E6%98%8E%E4%BD%93</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgeeac899" class="outline-5">
<h5 id="orgeeac899">Light Interface</h5>
<div class="outline-text-5" id="text-orgeeac899">
<p>
Light 类公用的 4 个成员变量：<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">flags</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26631;&#35760;&#20809;&#28304;&#22522;&#26412;&#30340;&#31867;&#22411;</span>
  <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #7590db;">LightToWorld</span>, <span style="color: #7590db;">WorldToLight</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20809;&#28304;&#22352;&#26631;&#31995;&#21644;&#19990;&#30028;&#22352;&#26631;&#31995;&#20043;&#38388;&#30340;&#36716;&#25442;</span>
  <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">nSamples</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21306;&#22495;&#20809;&#20351;&#29992;&#12290;</span>
  <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">MediumInterface</span> <span style="color: #7590db;">mediumInterface</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20809;&#28304;&#20869;&#37096;&#21644;&#22806;&#37096;&#30340;&#20171;&#36136;</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20809;&#28304;&#26631;&#35760;&#65292;&#35813;&#26631;&#35760;&#21487;&#20197;&#36890;&#36807;&#20301;&#25110;&#36827;&#34892;&#32452;&#21512;</span>
  <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">LightFlags</span> : <span style="color: #ce537a; font-weight: bold;">int</span>
  {
      DeltaPosition = 1,   <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#30340;delta&#34920;&#31034;delta &#20989;&#25968;&#65292;&#21363;&#29380;&#25289;&#20811;&#20989;&#25968;</span>
      DeltaDirection = 2,
      Area = 4,
      Infinite = 8
  };

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interaction&amp; ref  &#25552;&#20379;&#20102;&#19990;&#30028;&#31354;&#38388;&#20013;&#22330;&#26223;&#30340;&#19968;&#28857;p</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Point2f&amp; u        &#23545;&#20110;&#26377;&#20123;&#31867;&#22411;&#30340;&#20809;&#28304;&#65292;&#21040;&#36798;&#28857;p&#30340;&#20809;&#20026;&#22810;&#20010;&#26041;&#21521;&#30340;&#12290;u&#34920;&#31034;&#20809;&#28304;&#34920;&#38754;&#30340;&#20301;&#32622;&#12290;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vector3f* wi      p&#28857;&#20809;&#28304;&#20837;&#23556;&#26041;&#21521;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Float* pdf        &#20809;&#28304;&#26679;&#26412;&#30340;&#27010;&#29575;&#23494;&#24230;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VisibilityTester* vis&#29992;&#20110;&#30475;&#35265;&#24615;&#27979;&#35797;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return Spectrum   &#20026;&#21040;&#36798;p&#28857;&#30340;&#36752;&#23556;&#29575;</span>
  virtual <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Sample_Li</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>, <span style="color: #ce537a; font-weight: bold;">VisibilityTester</span> *<span style="color: #7590db;">vis</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>
</div>
<div id="outline-container-org3da685e" class="outline-6">
<h6 id="org3da685e"><span class="todo TODO">TODO</span> Visiblity Testing</h6>
</div>
</div>

<div id="outline-container-org25e248b" class="outline-5">
<h5 id="org25e248b">Point Lights</h5>
<div class="outline-text-5" id="text-org25e248b">
</div>
<div id="outline-container-org91a5537" class="outline-6">
<h6 id="org91a5537">Point Lights</h6>
<div class="outline-text-6" id="text-org91a5537">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #bc6ec5; font-weight: bold;">PointLight</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Transform</span> &amp;LightToWorld,
             <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">MediumInterface</span> &amp;mediumInterface, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;I)
    : Light((<span style="color: #ce537a; font-weight: bold;">int</span>)LightFlags::DeltaPosition, LightToWorld, mediumInterface),
    pLight(LightToWorld(Point3f(0, 0, 0))),
    I(I) {}
</pre>
</div>

<p>
严格来说使用辐射率来描述从点光源到达某个点的光是不正确的。辐射强度才是合适的单位。然而，我们滥用了术语，使用 Sample_Li 来计算从各种不同类型的光源到达某点的照明，将辐射强度除以距离的平方来转换单位。<br />
</p>

<ul class="org-ul">
<li>辐射率 <a href="https://zh.wikipedia.org/wiki/%E8%BE%90%E5%B0%84%E7%8E%87">https://zh.wikipedia.org/wiki/%E8%BE%90%E5%B0%84%E7%8E%87</a><br /></li>
<li>辐射强度 <a href="https://baike.baidu.com/item/%E8%BE%90%E5%B0%84%E5%BC%BA%E5%BA%A6">https://baike.baidu.com/item/%E8%BE%90%E5%B0%84%E5%BC%BA%E5%BA%A6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge34f662" class="outline-6">
<h6 id="orge34f662">Spot Lights</h6>
<div class="outline-text-6" id="text-orge34f662">
<div class="org-src-container">
<pre class="src src-c">SpotLight::SpotLight(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Transform</span> &amp;LightToWorld,
                     <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">MediumInterface</span> &amp;mediumInterface, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;I,
                     <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">totalWidth</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">falloffStart</span>)
    : Light((<span style="color: #ce537a; font-weight: bold;">int</span>)LightFlags::DeltaPosition, LightToWorld, mediumInterface),
      pLight(LightToWorld(Point3f(0, 0, 0))),
      I(I),
      cosTotalWidth(std::cos(Radians(totalWidth))),
      cosFalloffStart(std::cos(Radians(falloffStart))) {}
<span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">SpotLight</span>::Sample_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u,
                              <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>,
                              <span style="color: #ce537a; font-weight: bold;">VisibilityTester</span> *<span style="color: #7590db;">vis</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    *wi = Normalize(pLight - ref.p);
    *pdf = 1.f;
    *vis = VisibilityTester(ref, Interaction(pLight, ref.time, mediumInterface));
    <span style="color: #4f97d7; font-weight: bold;">return</span> I * Falloff(-*wi) / DistanceSquared(pLight, ref.p);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff155c1" class="outline-6">
<h6 id="orgff155c1"><span class="todo TODO">TODO</span> Texture Projection Lights</h6>
</div>
<div id="outline-container-org6691c31" class="outline-6">
<h6 id="org6691c31"><span class="todo TODO">TODO</span> Goniophotometric Diagram Lights</h6>
</div>
</div>
<div id="outline-container-orgc715e30" class="outline-5">
<h5 id="orgc715e30">Distant Lights</h5>
<div class="outline-text-5" id="text-orgc715e30">
<p>
令一类有用的光源为 distant light，也被称为 directional light.<br />
</p>
<div class="org-src-container">
<pre class="src src-c">DistantLight::DistantLight(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Transform</span> &amp;LightToWorld, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;L,
                           <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wLight)
    : Light((<span style="color: #ce537a; font-weight: bold;">int</span>)LightFlags::DeltaDirection, LightToWorld, MediumInterface()),
      L(L),
      wLight(Normalize(LightToWorld(wLight))) {}
</pre>
</div>
</div>
</div>
<div id="outline-container-org78f83bd" class="outline-5">
<h5 id="org78f83bd">Area Lights</h5>
<div class="outline-text-5" id="text-org78f83bd">
<p>
区域光由一个或多个 Shapes 定义，这些 Shapes 的表面会发出光，表面上每个点在不同方向上都有辐射率分布。通常计算区域光源的辐射量通常需要对光源区域进行积分，其通常无法通过封闭形式求解。该问题可通过 MonteCarlo 积分技术来解决。这种复杂计算可以得到软阴影，以及更真实的光照效果。<br />
</p>

<p>
AreaLight 为区域光的抽象基类。<br />
DiffuseAreaLight 实现了基础的区域光源，其有统一的空间和方向辐射分布。<br />
对于场景中的每个点，来自区域光源的辐射率可以从不同方向入射。<br />
<img src="./PhysicallyBasedRendering/2020_07_10_area_light.jpg" alt="2020_07_10_area_light.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org2335026" class="outline-5">
<h5 id="org2335026">Infinite Area Lights</h5>
<div class="outline-text-5" id="text-org2335026">
<p>
另一个有用的光源为无限区域光-一个无限远的区域光源，其围绕了整个场景。一种可视化这种光源的方法是将其当作一个巨大的球体，从这个球体向场景发射光。无限区域光源的一个重要用途是环境光。<br />
InfiniteAreaLight 也有变换矩阵，该矩阵用于确定朝向，即哪儿是朝上的方向。其使用球面坐标系将球体上的方向映射为(θ, φ)方向，然后再将(θ, φ)方向映射为贴图坐标(u,v).<br />
和 DistantLights 一样，光被定义为无限远处，MediumInterface 中的两个 Medium 成员都为 nullptr，这对应于真空。<br />
和 DistantLights 一样，也需要场景边界。<br />
InfiniteAreaLight 从所有方向发射光，因此也需要使用 MonteCarlo 积分来采样其照明。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8d0d7b8" class="outline-3">
<h3 id="org8d0d7b8">Part 4 Implement Light Transport algorithms</h3>
<div class="outline-text-3" id="text-org8d0d7b8">
</div>
<div id="outline-container-org4a77e25" class="outline-4">
<h4 id="org4a77e25">13 Monte Carlo Integration</h4>
<div class="outline-text-4" id="text-org4a77e25">
<p>
MonteCarlo 积分是使用随机采样来估算积分值的方法。MonteCarlo 一个很有用的属性是只要可以计算被积函数 f(x)在任意点的值，就可以计算该函数的积分。这使得蒙特卡洛积分易于实现，而且适用性很广，即使函数为不连续函数依然可以使用。<br />
MonteCarlo 积分的主要缺点是，如果使用 n 个样本来估算积分，该算法收敛于正确结果的速率为 \(O(n^{-1/2})\) 。这意味着为了让错误减半，需要对 4 倍的样本进行求解。在渲染中，每个样本通常需要追踪 1 个或多个射线，使用蒙特卡洛积分需要承受昂贵的计算开销。在最终计算出的图片上，蒙特卡洛采样带来的 artifacts 主要表现为噪声（像素随机的很亮或很暗）。目前图形学中关于蒙特卡洛的研究主要是关于如何尽可能减少错误，同时最小化额外的采样次数。<br />
</p>

<ul class="org-ul">
<li>MonteCarlo 模拟 <a href="https://jingyan.baidu.com/article/fea4511a07ed55f7ba912565.html">https://jingyan.baidu.com/article/fea4511a07ed55f7ba912565.html</a><br /></li>
<li>高斯积分 <a href="https://zhuanlan.zhihu.com/p/35847463">https://zhuanlan.zhihu.com/p/35847463</a><br /></li>
<li>蒙特卡洛积分 <a href="https://www.cnblogs.com/coshaho/p/9741298.html">https://www.cnblogs.com/coshaho/p/9741298.html</a><br /></li>
<li>蒙特卡洛积分 <a href="https://zhuanlan.zhihu.com/p/146144853">https://zhuanlan.zhihu.com/p/146144853</a><br /></li>
<li>蒙特卡洛求定积分 <a href="https://zhuanlan.zhihu.com/p/45746296">https://zhuanlan.zhihu.com/p/45746296</a><br /></li>
</ul>
</div>
<div id="outline-container-org161f0d3" class="outline-5">
<h5 id="org161f0d3">Background And Probability Review</h5>
<div class="outline-text-5" id="text-org161f0d3">
<p>
随机变量 X（random variable）是定义在样本空间上随机试验结果的实值函数。随机事件不论与数量是否直接有关，都可以数量化，即都能用数量化的方式表达。<br />
例如，掷骰子的结果为离散型随机变量，其取自一组事件组 Xi = {1, 2, 3, 4, 5, 6}. 其中每个事件的概率为 pi=1/6，所有概率的和为 1。取均匀分布随机变量ξ∈[0, 1)并将其映射为一个离散随机变量 X，离散型随机变量 X 和连续性随机变量ξ的对应关系如下：<br />
<img src="./PhysicallyBasedRendering/2020_07_13_continuse_to_discrete_var.jpg" alt="2020_07_13_continuse_to_discrete_var.jpg" /><br />
对于渲染中的应用，我们可能希望定义从场景中每个灯光采样照明的概率，该概率值为从任意一个光源采样的辐射通量和从所有光源采样到的辐射通量的比值：<br />
<img src="./PhysicallyBasedRendering/2020_07_13_light_sample_probability.jpg" alt="2020_07_13_light_sample_probability.jpg" /><br />
随机变量的累计分布函数(cumulative distribution function)是随机变量小于等于某个值的概率。P(x) = Pr{X ≤ x}.<br />
</p>

<ul class="org-ul">
<li>连续型随机变量 <a href="https://baike.baidu.com/item/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F">https://baike.baidu.com/item/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F</a><br /></li>
<li>累积分布函数 <a href="https://baike.baidu.com/item/%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0</a><br /></li>
<li>概率密度函数 <a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0</a><br /></li>
<li>均匀分布 <a href="https://baike.baidu.com/item/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83/954451">https://baike.baidu.com/item/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83/954451</a><br /></li>
<li>数学期望 <a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B">https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B</a><br /></li>
<li>方差 <a href="https://baike.baidu.com/item/%E6%96%B9%E5%B7%AE">https://baike.baidu.com/item/%E6%96%B9%E5%B7%AE</a><br /></li>
<li>估计量 <a href="https://wiki.mbalib.com/wiki/%E4%BC%B0%E8%AE%A1%E9%87%8F">https://wiki.mbalib.com/wiki/%E4%BC%B0%E8%AE%A1%E9%87%8F</a><br /></li>
<li>马尔科夫不等式 切比雪夫不等式 <a href="https://www.zhihu.com/question/27821324">https://www.zhihu.com/question/27821324</a><br /></li>
<li>大数定律 <a href="https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B</a><br /></li>
<li>大数定律 <a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B</a><br /></li>
<li>中心极限定理 <a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86">https://baike.baidu.com/item/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86</a><br /></li>
<li>中心极限定理 <a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86">https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86</a><br /></li>
</ul>
</div>
<div id="outline-container-org502ea8d" class="outline-6">
<h6 id="org502ea8d">Continuous Random Variables</h6>
<div class="outline-text-6" id="text-org502ea8d">
<p>
在渲染中，连续型随机变量比离散型随机变量更常用，其取值范围为连续区域。例如，实数、单位球上的方向，场景中物体的表面。<br />
</p>

<p>
经典均匀分布随机变量为一个特别重要的随机变量，我们将其记为ξ，其等概率地在[0,1)区域上取值。<br />
之所以重要有以下两个原因：<br />
</p>
<ol class="org-ol">
<li>在软件中易于生成符合该分布的随机变量<br /></li>
<li>可以通过先生成经典均匀分布的样本，然后再执行合适的变换来得到任意其他分布的样本。<br /></li>
</ol>

<p>
概率密度函数(probability density function)描述了随机变量取特定值的概率。其为随机变量累计分布函数的导数。p(x) = dP(x)/dx.<br />
<img src="./PhysicallyBasedRendering/2020_07_13_canonical_uniform_random_variable_cdf_pdf_.jpg" alt="2020_07_13_canonical_uniform_random_variable_cdf_pdf_.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_07_13_ab_uniform_random_variable_cdf_pdf_.jpg" alt="2020_07_13_ab_uniform_random_variable_cdf_pdf_.jpg" /><br />
</p>

<p>
<a href="./PhysicallyBasedRendering/00_13_uniform_pdf_cdf.ggb">./PhysicallyBasedRendering/00_13_uniform_pdf_cdf.ggb</a><br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83/954451">https://baike.baidu.com/item/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83/954451</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgaa5d208" class="outline-6">
<h6 id="orgaa5d208">Expected Values And Variance</h6>
<div class="outline-text-6" id="text-orgaa5d208">
<p>
函数 f 的期望值 Ep[f(x)]定义为该函数在某个分布上的平均值。蒙特卡洛积分需要计算任意积分函数的期望值。<br />
<img src="./PhysicallyBasedRendering/2020_07_13_expected_values_define.jpg" alt="2020_07_13_expected_values_define.jpg" /><br />
cos(x)在 0-π定义域内的期望值如下，其中 p 为均匀分布：<br />
<img src="./PhysicallyBasedRendering/2020_07_13_cos_expected_values.jpg" alt="2020_07_13_cos_expected_values.jpg" /><br />
</p>

<p>
函数的方差为函数和该函数期望偏差平方的期望，其形式化定义如下：<br />
<img src="./PhysicallyBasedRendering/2020_07_13_expected_values_variance_define.jpg" alt="2020_07_13_expected_values_variance_define.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc4e8152" class="outline-5">
<h5 id="orgc4e8152">The Monte Carlo Estimator</h5>
<div class="outline-text-5" id="text-orgc4e8152">
<p>
Monte Carlo method|estimator(蒙特卡洛估计量)可近似任意积分的值，其是依赖于随机采样来近似结果的数值技术。<br />
<img src="./PhysicallyBasedRendering/2020_07_14_monte_carlo_estimator.jpg" alt="2020_07_14_monte_carlo_estimator.jpg" /><br />
</p>

<p>
通过一般化，可以将上面均匀分布的限制去掉。这是非常重要的一步，小心选择样本的概率密度函数 PDF 可以减少 MonteCarlo 的方差。如果随机变量 Xi 的概率密度函数为 p(x)，则对应的估计量如下：<br />
<img src="./PhysicallyBasedRendering/2020_07_14_monte_carlo_estimator_01.jpg" alt="2020_07_14_monte_carlo_estimator_01.jpg" /><br />
</p>

<p>
MonteCarlo 方法很容易扩展到多维。下图展示了扩展到三维的情况：<br />
<img src="./PhysicallyBasedRendering/2020_07_14_monte_carlo_estimator_3d.jpg" alt="2020_07_14_monte_carlo_estimator_3d.jpg" /><br />
</p>

<p>
注意：采样数量 N 可以为任意值，不需要考虑积分的维度。这是 MonteCarlo 方法和传统求面积法的重要不同之处。MonteCarlo 方法中，样本数量的选取完全独立于积分的维度，而传统求面积的方法中，样本数量和维度为指数关系。<br />
</p>

<p>
MonteCarlo 估计量的收敛速率为 O(N<sup>0.5</sup>). 一维的情况下，标准的求面积技术收敛速度比 O(N<sup>0.5</sup>)要快。但随着维度增加，其效率指数减低。<br />
</p>

<p>
上面蒙特卡洛积分的推导没有下面 《蒙特卡洛法》更直观，建议参考下面链接中的推导。<br />
</p>

<ul class="org-ul">
<li>蒙特卡洛法 <a href="https://www.cnblogs.com/coshaho/p/9741298.html">https://www.cnblogs.com/coshaho/p/9741298.html</a> 有道笔记有备份<br /></li>
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/quick-introduction-to-monte-carlo-methods">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/quick-introduction-to-monte-carlo-methods</a><br /></li>
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/estimators">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/estimators</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge183bf9" class="outline-5">
<h5 id="orge183bf9">Sampling Random Variables</h5>
<div class="outline-text-5" id="text-orge183bf9">
</div>
<div id="outline-container-org16932ba" class="outline-6">
<h6 id="org16932ba">The Inversion Method</h6>
<div class="outline-text-6" id="text-org16932ba">
<p>
inversion method 使用一个或多个均匀随机变量，并将其映射为目标分布的随机变量。下面使用离散的例子来解释其过程：<br />
<img src="./PhysicallyBasedRendering/2020_07_14_the_inverse_method.jpg" alt="2020_07_14_the_inverse_method.jpg" /><br />
</p>


<div id="org14c9049" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_14_the_inverse_method_power_distribution.jpg" alt="2020_07_14_the_inverse_method_power_distribution.jpg" /><br />
</p>
</div>


<div id="orgba8fe35" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_14_the_inverse_method_exponential_distribution.jpg" alt="2020_07_14_the_inverse_method_exponential_distribution.jpg" /><br />
</p>
</div>


<div id="orgf288814" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_14_the_inverse_method_piecewise_constant_distribution.jpg" alt="2020_07_14_the_inverse_method_piecewise_constant_distribution.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org88e6477" class="outline-6">
<h6 id="org88e6477">The Rejection Method</h6>
<div class="outline-text-6" id="text-org88e6477">
<p>
对于一些函数，可能无法对其积分获得 CDF，或者无法求得其 CDF 的反函数。此时可以使用 Rejection Method 来按照某分布函数来生成样本。Rejection Method 的本质是投飞镖方式。假设我们需要从 f(x)分布抽取样本，我们有 PDF p(x)满足 f(x)&lt;cp(x)，而我们知道如何从 p(x)分布抽取样本。那么 Rejection Method 操作如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">loop forever</span>
  <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174; p &#20998;&#24067;&#29983;&#25104;&#26679;&#26412; X</span>
    X = gen_sample(p);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;(X, &#958; c p(X)) &#22312; f(X)&#19979;&#38754;&#65292;&#21017;&#25509;&#21463;&#29983;&#25104;&#30340;X&#26679;&#26412;&#65292;&#21542;&#21017;&#25298;&#32477;X&#26679;&#26412;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (&#958; &lt; f(X)/(<span style="color: #ce537a; font-weight: bold;">c</span> <span style="color: #bc6ec5; font-weight: bold;">p</span>(X))) then
      <span style="color: #4f97d7; font-weight: bold;">return</span> X
</pre>
</div>
<p>
该方法的效率依赖于 cp(x)和 f(x)靠近的程度。<br />
<img src="./PhysicallyBasedRendering/2020_07_15_rejection_method_001.jpg" alt="2020_07_15_rejection_method_001.jpg" /><br />
</p>


<div id="org7292f67" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_15_rejection_method_002.jpg" alt="2020_07_15_rejection_method_002.jpg" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #bc6ec5; font-weight: bold;">RejectionSampleDisk</span>(RNG &amp;rng) {
    <span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #7590db;">p</span>;
    <span style="color: #4f97d7; font-weight: bold;">do</span> {
        p.x = 1 - 2 * rng.UniformFloat();
        p.y = 1 - 2 * rng.UniformFloat();
    } <span style="color: #4f97d7; font-weight: bold;">while</span> (p.x * p.x + p.y * p.y &gt; 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> p;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7ae60df" class="outline-5">
<h5 id="org7ae60df">Metropolis Sampling</h5>
<div class="outline-text-5" id="text-org7ae60df">
<p>
Metropolis sampling 不需要对 f 函数进行积分，也不需要对积分进行归一化，不需要求 CDF 的反函数。而且，其每一次迭代生成的样本都是可用的，其没有 Rejection Sampling 的缺点。<br />
Metropolis sampling 按顺序生成的连续的样本统计上是相关联的，因此对于少量的样本无法确定其在整个域上是分布良好的。只有在大量样本的情况下，其才会覆盖整个区域。<br />
</p>

<p>
Tips: Metropolis 是一个物理学家。 - <a href="https://en.wikipedia.org/wiki/Nicholas_Metropolis">https://en.wikipedia.org/wiki/Nicholas_Metropolis</a><br />
</p>

<ul class="org-ul">
<li>马尔可夫性质 <a href="https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8">https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8</a><br /></li>
<li>随机过程 <a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/368895">https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/368895</a><br /></li>
<li>马尔可夫链 <a href="https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE">https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE</a><br /></li>
<li>什么是马尔可夫链蒙特卡洛（MCMC）？ <a href="https://zhuanlan.zhihu.com/p/116725922">https://zhuanlan.zhihu.com/p/116725922</a><br /></li>
<li>你对贝叶斯统计都有怎样的理解？ <a href="https://www.zhihu.com/question/21134457">https://www.zhihu.com/question/21134457</a><br /></li>
<li>贝塔分布 <a href="https://baike.baidu.com/item/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/8994021?fr=aladdin">https://baike.baidu.com/item/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/8994021?fr=aladdin</a><br /></li>
</ul>
</div>
<div id="outline-container-org7a74ab1" class="outline-6">
<h6 id="org7a74ab1">Basic Algorithm</h6>
<div class="outline-text-6" id="text-org7a74ab1">
<p>
Metropolis 算法从函数 f 生成一组样本 Xi，函数 f 定义在任意维度状态空间 \(\Omega\) 上，并且返回实数值。选中第一个样本 X0 ∈ \(\Omega\) 后，在生成后续样本 Xi 时，对 X(i-1)进行随机突变得到一个建议样本 X'。若该突变被接受，则 Xi = X'，否则 Xi = X(i-1)。当选择从一个状态转换为另一个状态时需要满足一些条件，最终 Xi 的分布会达到一个均衡分布；这个分布为静态分布。在极限情况下，这组样本 Xi ∈ \(\Omega\) 的分布恰好符合 f(x) 的概率密度函数:<br />
<img src="./PhysicallyBasedRendering/2020_07_16_f_pdf.jpg" alt="2020_07_16_f_pdf.jpg" /><br />
为了生成分布正确的样本，必须生成合适的突变，并且按照一些约束接受或拒绝突变。假设我们有一个突变方法，其可以将一个给定状态 X 转化为一个新的状态 X'。我们必须可以计算一个转换函数 T(X→X')，其可以给出从 X 突变为 X'的概率密度。<br />
给定一个转变函数，可以定义一个 acceptance probability a(X→X') 其给出接受从 X 到 X' 突变的概率。如果分布已经均衡，则满足如下条件，这个属性被称为 detailed balance.<br />
<img src="./PhysicallyBasedRendering/2020_07_16_detailed_balance.jpg" alt="2020_07_16_detailed_balance.jpg" /><br />
</p>

<p>
f 和 T 是设定好的，从上面公式可以得出 a 的定义。特别地，为了最大化达到均衡的速率，a的定义应该为：<br />
<img src="./PhysicallyBasedRendering/2020_07_16_a_define.jpg" alt="2020_07_16_a_define.jpg" /><br />
</p>

<p>
接受概率的推导可以参考下面文章描述<br />
</p>
<ul class="org-ul">
<li>随机采样方法整理与讲解（MCMC、Gibbs Sampling 等）<a href="https://www.cnblogs.com/xbinworld/p/4266146.html">https://www.cnblogs.com/xbinworld/p/4266146.html</a><br /></li>
</ul>

<p>
Metropolis sampling 算法的伪代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36873;&#23450;&#31532;&#19968;&#20010;&#26679;&#26412;</span>
  X = X0;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;&#21518;&#32493;&#26679;&#26412;</span>
  <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>=1; i&lt;n; i++)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#24403;&#21069;&#26679;&#26412;&#36827;&#34892;&#31361;&#21464;</span>
      X<span style="color: #dc752f; background-color: #292b2e;">'</span> = mutate(X);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#25509;&#21463;&#24403;&#21069;&#26679;&#26412;&#30340;&#27010;&#29575;</span>
      a = accept(X, X<span style="color: #dc752f; background-color: #292b2e;">'</span>);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27604;&#36739;&#36716;&#25442;&#27010;&#29575;&#21644;&#25509;&#21463;&#27010;&#29575;</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (random() &lt; a)
      {
          X = X<span style="color: #dc752f; background-color: #292b2e;">'</span>
      }
      record(X);
  }
</pre>
</div>
<p>
因为 Metropolis 算法自然地避免了 \(\Omega\) 空间上部分区域，这些区域上 f(x)的值相对比较小，只有很少样本在该区域被累加。为了获取 f(x)在这些区域的更多信息，可以使用数学期望技术来增强 Metropolis 算法。增强后的 Metropolis 算法伪代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36873;&#23450;&#31532;&#19968;&#20010;&#26679;&#26412;</span>
  X = X0;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;&#21518;&#32493;&#26679;&#26412;</span>
  <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>=1; i&lt;n; i++)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#24403;&#21069;&#26679;&#26412;&#36827;&#34892;&#31361;&#21464;</span>
      X<span style="color: #dc752f; background-color: #292b2e;">'</span> = mutate(X);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#25509;&#21463;&#24403;&#21069;&#26679;&#26412;&#30340;&#27010;&#29575;</span>
      a = accept(X, X<span style="color: #dc752f; background-color: #292b2e;">'</span>);
      record(X, 1-a);
      record(X<span style="color: #dc752f; background-color: #292b2e;">'</span>, a);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27604;&#36739;&#36716;&#25442;&#27010;&#29575;&#21644;&#25509;&#21463;&#27010;&#29575;</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (random() &lt; a)
      {
        X = X<span style="color: #dc752f; background-color: #292b2e;">'</span>
      }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org286c189" class="outline-6">
<h6 id="org286c189">Choosing Mutation Strategies</h6>
<div class="outline-text-6" id="text-org286c189">
<p>
通常希望突变有合适的大的变化而不是比较小的变化。这样可以快速的探索整个状态空间，小的突变会导致局限在状态空间的一个小的区域内。然而，当 f(X)的值在当前样本 X 处相对大时，很多建议的突变会被拒绝(从上节的接受概率的公式可以看出，此时的接受概率会变低)。我们希望避免很多样本是相同的，这样同样是为了更好地探索状态空间。在 f 的值相对大的地方，小的突变可能是建议的样本 X'，其可以得到更高的接受度。<br />
因此，一个有效的突变方式是对当前样本 X 进行随机扰动。如果样本 X 表示一个实数向量(x0,x1,&#x2026;)，则可以对该向量的某些维度或所有维度进行扰动。可以利用如下算法进行扰动：<br />
xi' = (xi ± sξ) mod 1; 该方法是均匀对称的，因此不需要计算转换密度。<br />
另一个相关的突变方式是，直接忽略当前的样本，使用均匀随机值生成一个新的样本：xi = ξ.完全随机地生成一个新的样本可以保证我们不会卡在状态空间的某个部分。一般地，能够到达状态空间的所有状态是必要的，这个属性被称为可遍历性。特殊地，为了保证遍历性，需要满足 T(X-&gt;X') &gt; 0。<br />
另一种方式是，使用利用概率密度函数进行突变，该 PDF 和被采样函数的部分是匹配的。如果我们有一个 PDF p(x),其和 f 的某个分量相同。此时的转换函数为：T (X→X') = p(X')。也就是说，当前的状态 X 对于转换密度的计算是无关的，转换到 X'的密度值依赖于 X'，和当前的状态无关。<br />
</p>
</div>
</div>
<div id="outline-container-orgaae7658" class="outline-6">
<h6 id="orgaae7658">Start-up Bias</h6>
<div class="outline-text-6" id="text-orgaae7658">
<p>
如何计算初始的 X0 样本？如果使用一个不符合 f 分布的样本会导致 start-up bias.<br />
一个通用的解决方案是，以一个任意的状态，执行 Meropolis 采样算法多次，忽略其生成的样本，假设前面的计算已经得到了一个合适的 X，然后继续执行该算法。该方式有两个缺点：1 消耗比较高，其需要忽略一些样本。2. 需要忽略多少样本只能靠猜测。<br />
另一种方式是，如果另一种采样方法可用，我们可以使用任意密度函数 X0~p(x)来得到 X0.我们从状态 X0 开始 Markov chain，但是我们对所有生成的样本分配如下权重：w=f(X0)/p(X0).该方法可以以可预见的方式完全消除 start-up bias。<br />
如果对于我们选取的 X0, f(X0)=0.此时，所有的样本的权重都为 0.为了避免该错误，我们可以采样 N 个样本，Y1, &#x2026;,Yn,定义每个样本的权重为 wi=f(Yi)/p(Yi). 然后，从 Yi 中选择 X0，计算 Yi 的平均权重 w，将其作为 Metropolis 算法生成样本的权重。<br />
</p>
</div>
</div>
<div id="outline-container-org0f4baf2" class="outline-6">
<h6 id="org0f4baf2"><span class="todo TODO">TODO</span> 1D Setting</h6>
</div>
<div id="outline-container-org5615db8" class="outline-6">
<h6 id="org5615db8"><span class="todo TODO">TODO</span> Estimating Intergrals With Metropolis Sampling</h6>
</div>
</div>
<div id="outline-container-orgc9d6e7d" class="outline-5">
<h5 id="orgc9d6e7d">Transforming Between Distributions</h5>
<div class="outline-text-5" id="text-orgc9d6e7d">
<p>
假设给定随机变量 Xi，其概率密度函数为 px(x)。随机变量 Yi=y(Xi)。 y(x)函数必须为一对一的变换，如果多个 x 值对应一个 y 值，则无法描述 y 值的概率密度。由此可得如下关系：<br />
<img src="./PhysicallyBasedRendering/2020_07_16_distribution_transform_001.jpg" alt="2020_07_16_distribution_transform_001.jpg" /><br />
上面给出的方法为一般性的 inversion 方法，如果 X 为[0,1]的均匀分布，则 Px(x) = x,此时就是前面介绍的 inversion mothed.<br />
</p>
</div>
<div id="outline-container-org98f33fd" class="outline-6">
<h6 id="org98f33fd">Transformation in Multiple Dimensions</h6>
<div class="outline-text-6" id="text-org98f33fd">
<p>
多维的情况如下：<br />
<img src="./PhysicallyBasedRendering/2020_07_16_distribution_transform_002.jpg" alt="2020_07_16_distribution_transform_002.jpg" /><br />
</p>

<p>
行列式是线性变换的伸缩因子。行列式=1，图形面积不变；行列式&gt;1，图形被放大；0&lt;行列式&lt;1，图形被缩小；行列式&lt;0，图形镜像（改变了基的左右手法则）。<br />
因此，使用雅可比行列式缩放概率密度，可以表示坐标变换引起的概率密度变换。<br />
</p>

<ul class="org-ul">
<li>行列式的本质是什么？ <a href="https://www.zhihu.com/question/36966326">https://www.zhihu.com/question/36966326</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3084ca4" class="outline-6">
<h6 id="org3084ca4">Polar Coordinates</h6>
<div class="outline-text-6" id="text-org3084ca4">
<p>
以两维极坐标为例，假如我们从某个密度函数 p(r, &theta;)抽取样本,其对应的 p(x,y) 密度函数是什么？<br />
<img src="./PhysicallyBasedRendering/2020_07_16_polar_coord_example.jpg" alt="2020_07_16_polar_coord_example.jpg" /><br />
</p>

<p>
雅可比矩阵表示的是从(x,y)坐标系到(r, &theta;)坐标系的变换。<br />
雅可比行列式表示从(x,y)坐标系变换为(r, &theta;)坐标系后，空间的缩放系数。<br />
(x, y) -&gt; (r, &theta;) scaleFactor = r<br />
p(x,y)r = p(r, &theta;)<br />
</p>

<p>
Tips:<br />
雅可比行列式为负数并不表示空间缩小了，而是说空间镜像了。0&lt;行列式绝对值&lt;1 才表示空间缩小了。<br />
</p>
</div>
</div>
<div id="outline-container-orgd7000bc" class="outline-6">
<h6 id="orgd7000bc">Spherical Coordinates</h6>
<div class="outline-text-6" id="text-orgd7000bc">
<p>
下面为三维球坐标系的情况：<br />
<img src="./PhysicallyBasedRendering/2020_07_16_spherical_coord_example.jpg" alt="2020_07_16_spherical_coord_example.jpg" /><br />
由上面公式可以得出<a id="org74eddcd"></a>：<br />
<img src="./PhysicallyBasedRendering/2020_07_16_spherical_coord_dw.jpg" alt="2020_07_16_spherical_coord_dw.jpg" /><br />
</p>

<ul class="org-ul">
<li>球面立体角 <a href="https://baike.baidu.com/item/%E7%AB%8B%E4%BD%93%E8%A7%92">https://baike.baidu.com/item/%E7%AB%8B%E4%BD%93%E8%A7%92</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0c5da72" class="outline-5">
<h5 id="org0c5da72">2D Sampling With Multidimensional Transformations</h5>
<div class="outline-text-5" id="text-org0c5da72">
<p>
假设我们需要抽取样本(X, Y)，这些样本的 2D 联合密度函数为 p(x,y)。<br />
有一些多维密度函数是可分离的，例如 p(x,y) = px(x)py(y)。此时，随机变量(X, Y)可以分开进行采样，X按照 px 密度函数采样，Y按照 py 密度函数采样，将得到的样本组合成一对就是(X, Y)样本。<br />
有很多密度函数是无法分离的，此时我们按照下面方法进行采样：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_2d_joint_distribution.jpg" alt="2020_07_18_sample_2d_joint_distribution.jpg" /><br />
从联合分布进行 2D 采样的理念为，先计算相对于一个特定变量的边缘密度函数，然后利用 1D 技术从该密度函数抽取一个样本。得到该样本后即可计算给定该值的条件密度函数，再从该条件密度函数抽取一个样本，将两次抽取的样本组合为一组就是需要的样本。<br />
</p>

<ul class="org-ul">
<li>联合分布函数 <a href="../theory/MathTheory_Probability.html#orgc2729aa">../theory/MathTheory_Probability.html#orgc2729aa</a><br /></li>
<li>边缘分布函数 <a href="../theory/MathTheory_Probability.html#orgc2729aa">../theory/MathTheory_Probability.html#orgc2729aa</a><br /></li>
</ul>
</div>
<div id="outline-container-orgcfaac50" class="outline-6">
<h6 id="orgcfaac50">Uniformaly Sampling a Hemisphere</h6>
<div class="outline-text-6" id="text-orgcfaac50">

<div id="org4f7c663" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_18_sample_hemisphere_example.jpg" alt="2020_07_18_sample_hemisphere_example.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org710f623" class="outline-6">
<h6 id="org710f623">Uniformaly Sampling a Sphere</h6>
<div class="outline-text-6" id="text-org710f623">

<div id="orge656a9a" class="figure">
<p><img src="./PhysicallyBasedRendering/04_13_06_sample_sphere_example.jpg" alt="04_13_06_sample_sphere_example.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3360dd4" class="outline-6">
<h6 id="org3360dd4">Sampling a unit disk</h6>
<div class="outline-text-6" id="text-org3360dd4">
<p>
<img src="./PhysicallyBasedRendering/2020_07_18_uniform_sample_disk.jpg" alt="2020_07_18_uniform_sample_disk.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_disk_example.jpg" alt="2020_07_18_sample_disk_example.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org861c4e1" class="outline-6">
<h6 id="org861c4e1">Cosine-Weighted Hemisphere Sampling</h6>
<div class="outline-text-6" id="text-org861c4e1">
<p>
散射方程中 BSDF 和入射辐射率的乘积会再乘一个 cosine 项，因此生成的方向靠近半球顶端的可能性更大一些会很有用。<br />
球面立体角 w 的密度函数 请参考链接 <a href="#org74eddcd">No description for this link</a> , 下面为包含 cosine 项的球面立体角密度函数的推导：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_hemisphere_01.jpg" alt="2020_07_18_sample_hemisphere_01.jpg" /><br />
下面使用了 Malley 方法生成 cosine 权重的立体角分布：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_hemisphere_02.jpg" alt="2020_07_18_sample_hemisphere_02.jpg" /><br />
下面是我自己的推导：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_hemisphere_03.jpg" alt="2020_07_18_sample_hemisphere_03.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org007dead" class="outline-6">
<h6 id="org007dead">Sampling a Cone</h6>
<div class="outline-text-6" id="text-org007dead">
<p>
对于 SpotLight 和基于 Sphere 的区域灯光来说，在一个 cone 内进行均匀采样是很有用的。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_cone_example.jpg" alt="2020_07_18_sample_cone_example.jpg" /><br />
球面立体角 w 的密度函数 请参考链接 <a href="#org74eddcd">No description for this link</a>。<br />
</p>

<ul class="org-ul">
<li><a href="https://mathworld.wolfram.com/Cone.html">https://mathworld.wolfram.com/Cone.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgaec6fd0" class="outline-6">
<h6 id="orgaec6fd0">Sampling a Triangle</h6>
<div class="outline-text-6" id="text-orgaec6fd0">
<p>
下面使用面积为 1/2 的等腰直角三角形推导对三角形采样的方法，其使用了重心坐标，通用于一般的三角形。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_triangle_example.jpg" alt="2020_07_18_sample_triangle_example.jpg" /><br />
<img src="./PhysicallyBasedRendering/00_04_13_sample_triangle.jpg" alt="00_04_13_sample_triangle.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orge0e2e0e" class="outline-6">
<h6 id="orge0e2e0e">Sampling Cameras</h6>
<div class="outline-text-6" id="text-orge0e2e0e">

<div id="org704f673" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_07_18_sample_camera_example.jpg" alt="2020_07_18_sample_camera_example.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org224cf0c" class="outline-6">
<h6 id="org224cf0c">Piecewise-Constant 2D Distributions</h6>
<div class="outline-text-6" id="text-org224cf0c">
<p>
从离散的 2D 分布采样适用于生成贴图或环境贴图的样本。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_discrete_2d.jpg" alt="2020_07_18_sample_discrete_2d.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgeb67802" class="outline-5">
<h5 id="orgeb67802">Russian Roulette And Splitting</h5>
<div class="outline-text-5" id="text-orgeb67802">
<p>
下面为估计量 F 的 efficency 的定义：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_efficency.jpg" alt="2020_07_18_efficency.jpg" /><br />
</p>

<p>
Russian roulette 和 splitting 这两种技术可用于改进 Monte Carlo 估算的有效性。这两种方法可以明显增加样本对最终结果的贡献可能性。<br />
Russian roulette 用于解决计算耗费比较高，但是对最近结果贡献小的问题。Splitting 计算可以用于将更多的样本放置到重要的维度。<br />
</p>

<p>
考虑直接光照的积分，其给出在 p 点处的反射辐射率，其只考虑场景中所有光源的直接照明。假定我们从 p(wi)分布取两个样本进行计算。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_sample_dir_light.jpg" alt="2020_07_18_sample_dir_light.jpg" /><br />
计算中需要对从 p 点发出的阴影射线进行追踪，从而判断从 p 点看时，光源是否被遮挡。对于所有的 wi，如果 fr(p,wo,wi)为零，则 wi 对应的反射率也为 0，我们应该避免在这时对阴影射线进行追踪，因为其不会改变最终的结果。Russian roulette 可以使得在积分值很低时，也可以忽略对阴影射线的追踪，并且使得计算的结果平均是正确的。例如，当 fr(p,wo,wi)很小或 wi 靠近水平时，都可以忽略对阴影射线进行追踪。<br />
</p>

<p>
为了应用 Russian roulette,我们选择 q 为结束概率。可以基于预估的积分值来选择结束概率 q，随着积分值变大 q 变小。概率为 q 的情况下，对于特定的样本积分值不进行计算，而直接使用常数 c；概率为 1-q 的情况下，依然对积分值进行计算，并赋予 1/(1-q)的权值。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_russian_roulette_method.jpg" alt="2020_07_18_russian_roulette_method.jpg" /><br />
F'取到 c 的概率是 q，所以期望的这一部分就是 qc，也就是第二项。至于第一项也是一样的，取值概率是 1-q。<br />
</p>

<p>
Russian roulette 永远不会减少方差，选择不好的 Russian roulette 权重会极大增加方差。但是，如果所选的概率让对最终结果贡献很小的样本被忽略的话，其可以改进有效性。<br />
</p>
</div>
<div id="outline-container-orgb5a121e" class="outline-6">
<h6 id="orgb5a121e">Splitting</h6>
<div class="outline-text-6" id="text-orgb5a121e">
<p>
再次考虑只有直接光照的反射问题，忽略像素过滤后，该问题可以写成如下形式：<br />
<img src="./PhysicallyBasedRendering/2020_07_18_splitting_method.jpg" alt="2020_07_18_splitting_method.jpg" /><br />
通常会生成 N 个样本来计算积分，每个样本由一个像素位置(x,y)一个朝向光源的方向 w 组成。如果场景中由很多个光源，或者有一个区域光源用于产生软阴影，此时可能需要很多样本才能达到可接受的效果。不幸的是每个样本需要追踪两个射线，一个射线为像素(x,y)到看见的点，另一个阴影射线从看见的点到光源。<br />
假设 N=100,则有 200 个射线要追踪：100 个摄像机射线，100 个阴影射线。100 个摄像机射线太多了，其对结果影响不大。使用 Splitting 方法，我们只需要取 5 个像素样本但对于每个像素样本取 20 个光照样本。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9f893a5" class="outline-5">
<h5 id="org9f893a5">Careful Sample Placement</h5>
<div class="outline-text-5" id="text-org9f893a5">
<p>
减少方差的经典有效方法为，精心放置样本，使其能更好捕捉积分的特征。<br />
</p>
</div>
<div id="outline-container-orgb39a6ed" class="outline-6">
<h6 id="orgb39a6ed">Stratified Sampling</h6>
<div class="outline-text-6" id="text-orgb39a6ed">
<p>
分层采样将整个积分区域 A 划分为 n 个不重叠的区域 A1,A2,&#x2026;,An.每个区域被称为一个层。 从 A 中抽取样本时，我们按照每个层中的密度函数 pi，从每个 Ai 中抽取对应的 ni 个样本。<br />
超级采样一个像素，就是分层采样的一个简单例子。将一个像素周围区域划分为 kxk 个格子，从每个格子中抽取一个样本。这比随机抽取 k*k 个样本要好，因为完全随机抽取的样本可能会聚集在一起。<br />
选择一个不分层的样本等价于按照离散概率分布随机选择一个层 I，该离散概率分布由 vi 定义，然后在 Ai 层随机选择一个样本 X。这种情况下，X在 I 条件下进行选择，由条件概率可得其方差。<br />
<img src="./PhysicallyBasedRendering/2020_07_18_stratified_sampling.jpg" alt="2020_07_18_stratified_sampling.jpg" /><br />
</p>

<p>
分层采样的主要缺点为随着维度提高，需要的样本数量变多。<br />
一种方案是只对一些维度进行独立的分层，然后随机地将不同维度的样本关联起来，如：<a href="#org37f7630">Stratified Sampling</a> 部分描述。<br />
另一种方案是使用 Latin Hypercube sampling，不论维度多少，其可生成任意数量样本。不幸的是，其无法像分层采样那样可以有效减小方差。但是其比均匀随机采样效果要好。<br />
</p>
</div>
</div>
<div id="outline-container-orgc4a00ac" class="outline-6">
<h6 id="orgc4a00ac">Quasi Monte Carlo</h6>
<div class="outline-text-6" id="text-orgc4a00ac">
<p>
低差异采样技术被称为 Quasi Monte Carlo.拟蒙特卡洛技术的关键是其用精心设计的确定性算法生成低差异点集，用这些点集代替标准蒙特卡洛方法中的伪随机数。<br />
拟蒙特卡洛比标准蒙特卡洛有渐进更快的收敛速度。使用标准蒙特卡洛的大多数技术都可以用拟蒙特卡洛来代替，有一些则不行(例如：rejection sampling)。图形学中，对于不连续的积分渐进收敛速度通常是无法接受的，这种情况下，拟蒙特卡洛要比标准蒙特卡洛表现要好。<br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E6%8B%9F%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95">https://baike.baidu.com/item/%E6%8B%9F%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd924b9e" class="outline-6">
<h6 id="orgd924b9e">Warping Samples And Distortion</h6>
<div class="outline-text-6" id="text-orgd924b9e">
<p>
pbrt 中应用分层采样或 low-discrepancy 采样时，会在[0,1)^2 空间上生成一系列样本，然后再利用 13.5 和 13.6 节中的转换方法将这些样本转换到需要的空间。转换过程中需要保持样本的分层属性，也就是说靠近的样本应该映射为物体表面上靠近的位置，分离开的样本应该映射为分离开的位置。如果无法保持该性质，则分层的好处就丢失了。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org833490a" class="outline-5">
<h5 id="org833490a">Bias</h5>
<div class="outline-text-5" id="text-org833490a">
<p>
另一种减小方差的方法为在计算过程中引入 bias。有时候知道计算估计值的期望值不等于所求量，此时引入 bias 可以减小方差。如果估计量的期望值等于正确的值，则估计量为无偏的; 否则偏差即为期望和正确值的差。<br />
<img src="./PhysicallyBasedRendering/2020_07_19_bias.jpg" alt="2020_07_19_bias.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_07_19_bias_01.jpg" alt="2020_07_19_bias_01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgfb3c1f9" class="outline-5">
<h5 id="orgfb3c1f9">Importance Sampling</h5>
<div class="outline-text-5" id="text-orgfb3c1f9">
<p>
重要性采样是减小方差的强大技术。其利用了如下事实，即如果样本分布 p(x)和 f(x)近似，则取样时蒙特卡洛估计量的收敛速度会很快。其基础的理念为，将工作集中在积分值相对高的地方，这样精确估算的计算更高效。此时，生成样本时，在函数值高的地方，对应生成的样本数量比均匀采样会变多。<br />
</p>

<p>
如果选择了不好的分布，重要性采样会增加方差。<br />
</p>


<div id="org4a2fa4d" class="figure">
<p><img src="./PhysicallyBasedRendering/00_04_13_10_importance_sampling_base.jpg" alt="00_04_13_10_importance_sampling_base.jpg" /><br />
</p>
</div>


<div id="org891fb2b" class="figure">
<p><img src="./PhysicallyBasedRendering/00_04_13_10_importance_sampling_00.jpg" alt="00_04_13_10_importance_sampling_00.jpg" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">import</span> random
<span style="color: #4f97d7; font-weight: bold;">import</span> math

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x1</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">return</span> uniform_01_value;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x2</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">if</span> uniform_01_value&lt;0.9901:
        <span style="color: #4f97d7; font-weight: bold;">return</span> uniform_01_value/99.01;
    <span style="color: #4f97d7; font-weight: bold;">else</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> (uniform_01_value-0.99)/0.01;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x3</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">if</span> uniform_01_value&lt;0.009:
        <span style="color: #4f97d7; font-weight: bold;">return</span> uniform_01_value/0.01;
    <span style="color: #4f97d7; font-weight: bold;">else</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> (uniform_01_value+8.91)/9.91;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf1</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf2</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">if</span> x&lt;0.01:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 99.01
    <span style="color: #4f97d7; font-weight: bold;">else</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0.01
    
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf3</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">if</span> x&lt;0.9:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0.01
    <span style="color: #4f97d7; font-weight: bold;">else</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 9.91
    
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">if</span> x&lt;0.01:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 700
    <span style="color: #4f97d7; font-weight: bold;">else</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0.1

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>():
    <span style="color: #7590db;">total_times</span> = 16;
    <span style="color: #7590db;">counter</span> = 1;
    <span style="color: #7590db;">real</span> = 7.099
    random.seed(10);
    <span style="color: #4f97d7; font-weight: bold;">print</span>(<span style="color: #2d9574;">"No     Uniform     Importance1     Importance2    Err.Uniform     Err.Importance1            Err.Importance2"</span>)
    <span style="color: #4f97d7; font-weight: bold;">while</span> counter&lt;=total_times:
        <span style="color: #7590db;">samples_count</span> = 10000
        <span style="color: #7590db;">sum1</span> = 0.0
        <span style="color: #7590db;">sum2</span> = 0.0
        <span style="color: #7590db;">sum3</span> = 0.0
        <span style="color: #4f97d7; font-weight: bold;">for</span> index <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span>(samples_count):
            <span style="color: #7590db;">x</span> = random.random()
            <span style="color: #7590db;">sample1</span> = gen_x1(x)
            <span style="color: #7590db;">sample2</span> = gen_x2(x)
            <span style="color: #7590db;">sample3</span> = gen_x3(x)
            <span style="color: #7590db;">s_pdf1</span> = pdf1(sample1)
            <span style="color: #7590db;">s_pdf2</span> = pdf2(sample2)
            <span style="color: #7590db;">s_pdf3</span> = pdf3(sample3)
            <span style="color: #7590db;">sum1</span> += f(sample1)/s_pdf1;
            <span style="color: #7590db;">sum2</span> += f(sample2)/s_pdf2;
            <span style="color: #7590db;">sum3</span> += f(sample3)/s_pdf3;
        <span style="color: #7590db;">sum1</span> /= samples_count;
        <span style="color: #7590db;">sum2</span> /= samples_count;
        <span style="color: #7590db;">sum3</span> /= samples_count;
        <span style="color: #7590db;">err1</span> = 100.0*(sum1-real)/real;
        <span style="color: #7590db;">err2</span> = 100.0*(sum2-real)/real;
        <span style="color: #7590db;">err3</span> = 100.0*(sum3-real)/real;
        <span style="color: #4f97d7; font-weight: bold;">print</span>(<span style="color: #2d9574;">"%-6d %-14.4f %-14.4f %-14.4f %-14.2f %-14.2f %-14.2f"</span> %(counter, sum1, sum2, sum3, err1, err2, err3))
        <span style="color: #7590db;">counter</span>+=1
        
<span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #4f97d7;">__name__</span> == <span style="color: #2d9574;">'__main__'</span>:
    main()

<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">No     Uniform     Importance1     Importance2    Err.Uniform     Err.Importance1     Err.Importance2</span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">1      6.4691         7.0996         7.0870         -8.87          0.01               -0.17         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">2      7.4489         7.1013         7.1020         4.93           0.03               0.04          </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">3      7.2390         7.0969         0.1020         1.97           -0.03              -98.56        </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">4      6.5391         7.1002         0.0930         -7.89          0.02               -98.69        </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">5      7.3790         7.1013         7.1050         3.94           0.03               0.08          </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">6      7.4489         7.0972         14.1050        4.93           -0.02              98.69         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">7      6.9590         7.0993         0.1010         -1.97          0.00               -98.58        </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">8      7.7289         7.0937         14.1090        8.87           -0.07              98.75         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">9      7.6589         7.1031         14.1070        7.89           0.06               98.72         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">10     8.3588         7.0978         7.1180         17.75          -0.02              0.27          </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">11     6.5391         7.0958         0.0990         -7.89          -0.05              -98.61        </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">12     7.3790         7.0981         14.1020        3.94           -0.01              98.65         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">13     6.8190         7.0958         0.0920         -3.94          -0.05              -98.70        </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">14     7.0290         7.1013         7.0960         -0.99          0.03               -0.04         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">15     6.7490         7.1005         7.0950         -4.93          0.02               -0.06         </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">16     6.4691         7.0993         7.0940         -8.87          0.00               -0.07     </span>
</pre>
</div>

<p>
<img src="./PhysicallyBasedRendering/00_04_13_10_importance_sampling_01.jpg" alt="00_04_13_10_importance_sampling_01.jpg" /><br />
<a href="./PhysicallyBasedRendering/00_04_13_10_importance_sampling_01.ggb">./PhysicallyBasedRendering/00_04_13_10_importance_sampling_01.ggb</a><br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">import</span> random
<span style="color: #4f97d7; font-weight: bold;">import</span> math

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x1</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">return</span> math.pi*uniform_01_value*0.5;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x2</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">return</span> math.pi*0.5*math.<span style="color: #4f97d7;">pow</span>(uniform_01_value, 0.5);

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gen_x3</span>(uniform_01_value):
    <span style="color: #4f97d7; font-weight: bold;">return</span> math.acos(1.0-uniform_01_value);

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf1</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">return</span> 2/math.pi;

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf2</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">return</span> 8*x/(math.pi*math.pi);
    
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">pdf3</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">return</span> math.sin(x);
    
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>(x):
    <span style="color: #4f97d7; font-weight: bold;">return</span> math.sin(x);
    
<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>():
    <span style="color: #7590db;">total_times</span> = 16;
    <span style="color: #7590db;">counter</span> = 1;
    <span style="color: #7590db;">real</span> = 1.0
    random.seed(10);
    <span style="color: #4f97d7; font-weight: bold;">print</span>(<span style="color: #2d9574;">"No     Uniform     Importance1     Importance2    Err.Uniform     Err.Importance1    Err.Importance2"</span>)
    <span style="color: #4f97d7; font-weight: bold;">while</span> counter&lt;=total_times:
        <span style="color: #7590db;">samples_count</span> = 16
        <span style="color: #7590db;">sum1</span> = 0.0
        <span style="color: #7590db;">sum2</span> = 0.0
        <span style="color: #7590db;">sum3</span> = 0.0
        <span style="color: #4f97d7; font-weight: bold;">for</span> index <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span>(samples_count):
            <span style="color: #7590db;">x</span> = random.random()
            <span style="color: #7590db;">sample1</span> = gen_x1(x)
            <span style="color: #7590db;">sample2</span> = gen_x2(x)
            <span style="color: #7590db;">sample3</span> = gen_x3(x)
            <span style="color: #7590db;">s_pdf1</span> = pdf1(sample1)
            <span style="color: #7590db;">s_pdf2</span> = pdf2(sample2)
            <span style="color: #7590db;">s_pdf3</span> = pdf3(sample3)
            <span style="color: #7590db;">sum1</span> += f(sample1)/s_pdf1;
            <span style="color: #7590db;">sum2</span> += f(sample2)/s_pdf2;
            <span style="color: #7590db;">sum3</span> += f(sample3)/s_pdf3;
        <span style="color: #7590db;">sum1</span> /= samples_count;
        <span style="color: #7590db;">sum2</span> /= samples_count;
        <span style="color: #7590db;">sum3</span> /= samples_count;
        <span style="color: #7590db;">err1</span> = 100.0*(sum1-real)/real;
        <span style="color: #7590db;">err2</span> = 100.0*(sum2-real)/real;
        <span style="color: #7590db;">err3</span> = 100.0*(sum3-real)/real;
        <span style="color: #4f97d7; font-weight: bold;">print</span>(<span style="color: #2d9574;">"%-6d %-14.4f %-14.4f %-14.4f %-14.1f %-14.1f %-14.1f"</span> %(counter, sum1, sum2, sum3, err1, err2, err3))
        <span style="color: #7590db;">counter</span>+=1
        
<span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #4f97d7;">__name__</span> == <span style="color: #2d9574;">'__main__'</span>:
    main()

<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">No     Uniform     Importance1     Importance2    Err.Uniform     Err.Importance1    Err.Importance2</span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">1      1.0795         0.9779         1.0000         7.9            -2.2              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">2      0.9786         1.0001         1.0000         -2.1           0.0               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">3      0.9601         1.0161         1.0000         -4.0           1.6               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">4      0.9502         1.0153         1.0000         -5.0           1.5               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">5      0.8464         1.0461         1.0000         -15.4          4.6               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">6      1.0855         0.9899         1.0000         8.6            -1.0              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">7      0.7889         1.0531         1.0000         -21.1          5.3               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">8      1.1980         0.9565         1.0000         19.8           -4.4              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">9      1.2529         0.9194         1.0000         25.3           -8.1              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">10     0.9384         1.0180         1.0000         -6.2           1.8               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">11     0.9748         1.0113         1.0000         -2.5           1.1               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">12     1.1036         0.9892         1.0000         10.4           -1.1              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">13     0.9582         1.0025         1.0000         -4.2           0.3               0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">14     1.1459         0.9545         1.0000         14.6           -4.5              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">15     0.9775         0.9990         1.0000         -2.2           -0.1              0.0           </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">16     1.1445         0.9629         1.0000         14.5           -3.7              0.0           </span>
</pre>
</div>

<p>
下面文章中包含了重要性采样相关的知识：<br />
</p>
<ul class="org-ul">
<li>蒙特卡洛积分 <a href="https://zhuanlan.zhihu.com/p/146144853">https://zhuanlan.zhihu.com/p/146144853</a><br /></li>
</ul>
</div>
<div id="outline-container-org0842357" class="outline-6">
<h6 id="org0842357">Multiple Importance Sampling</h6>
<div class="outline-text-6" id="text-org0842357">
<p>
Multiple Importance Sampling 的基本理念为，估算积分时，我们可以从多个样本分布抽取样本，多个样本中至少有一个会和积分的的形状相匹配，即使我们不知道匹配的样本是哪个。MIS 提供了一种方法给样本分配权重，其可以减少方差峰值。只考虑不常见的特殊情况的特化采样程序是被鼓励的，因为当这些情况发生时，其可以减少方差，而且只是用先对少的开销。<br />
权重函数考虑生成一个样本 Xi 或 Yj 所有不同的方式，而不只是特定的实际用到的一个。平衡启发式是权重函数的一个好的选择。其可以为样本分配权重减少方差。<br />
<img src="./PhysicallyBasedRendering/2020_07_19_MIS_001.jpg" alt="2020_07_19_MIS_001.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org27fe840" class="outline-4">
<h4 id="org27fe840">14 Light Transport I:Surface Reflection</h4>
<div class="outline-text-4" id="text-org27fe840">
</div>
<div id="outline-container-orgdde12da" class="outline-5">
<h5 id="orgdde12da">Sampling Reflection Functions</h5>
<div class="outline-text-5" id="text-orgdde12da">
</div>
<div id="outline-container-orgf362b5c" class="outline-6">
<h6 id="orgf362b5c">概述</h6>
<div class="outline-text-6" id="text-orgf362b5c">
<div class="org-src-container">
<pre class="src src-c">  virtual <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">BxDF</span>::Sample_f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;sample, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>, <span style="color: #ce537a; font-weight: bold;">BxDFType</span> *<span style="color: #7590db;">sampledType</span> = nullptr) <span style="color: #4f97d7; font-weight: bold;">const</span>;
  virtual <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">BxDF</span>::Pdf(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span>;
</pre>
</div>
<p>
考虑间接光照时，在 BxDF::Sample_f 方法中，首先生成入射方向样本 wi，然后调用 BxDF::f 方法返回 wi 入射方向，wo 出射方向下对应的辐射率。例如：整个过程为 WhittedIntegrator::Li -&gt; SamplerIntegrator::SpecularReflect -&gt; BSDF::Sample_f -&gt; BxDF::Sample_f -&gt; BSDF::f。 Tips: 考虑光在表面的一次反射，其实就是包含了一次间接光照。<br />
</p>

<p>
BxDF::Sample_f 方法按照分布选择一个方向，该分布和对应的散射方程相似。该方法用于在完美镜面表面处查找反射和透射射线。<br />
BxDF::Sample_f 会取[0,1)^2 范围内的两个样本值，这两个样本值可以通过分层采样或低差异采样技术来生成。这两个样本值可用于基于 inversion method 的采样算法。<br />
BxDF::Sample_f 方法返回给定方向的 BSDF 值，以及采样的方向 wi 和 wi 方向对应的概率密度函数 p(wi)的值 pdf。pdf 值为立体角，wi 和 wo 在标准反射坐标系下。<br />
</p>

<p>
BxDF::Pdf() 方法返回给定入射方向和出射方向对应的概率密度 pdf。该方法对于 multiple importance sampling 非常有用。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7e3b241"></a>BSDF::Pdf<br />
<div class="outline-text-7" id="text-org7e3b241">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">BSDF</span>::<span style="color: #bc6ec5; font-weight: bold;">Pdf</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">woWorld</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wiWorld</span>, <span style="color: #ce537a; font-weight: bold;">BxDFType</span> <span style="color: #7590db;">flags</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (nBxDFs == 0.f) <span style="color: #4f97d7; font-weight: bold;">return</span> 0.f;
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wo</span> = WorldToLocal(woWorld), <span style="color: #7590db;">wi</span> = WorldToLocal(wiWorld);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (wo.z == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> 0.;
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">pdf</span> = 0.f;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">matchingComps</span> = 0;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; nBxDFs; ++i)
        <span style="color: #4f97d7; font-weight: bold;">if</span> (bxdfs[i]-&gt;MatchesFlags(flags)) {
            ++matchingComps;
            pdf += bxdfs[i]-&gt;Pdf(wo, wi);
        }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306; &#27492;&#22788;&#36890;&#36807;&#38500;matchingComps&#23545;BSDF&#30340;Pdf&#36827;&#34892;&#20102;&#24402;&#19968;&#21270;</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">v</span> = matchingComps &gt; 0 ? pdf / matchingComps : 0.f;
    <span style="color: #4f97d7; font-weight: bold;">return</span> v;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org054871f" class="outline-6">
<h6 id="org054871f">Microfacet BxDFS</h6>
<div class="outline-text-6" id="text-org054871f">
<p>
基于微表面的反射模型会基于一个微表面分布 D(wh)，每一个微表面都展现出完美的镜面反射或透射。D(wh)函数对 Torrance-Sparrow BSDF 函数的形状起决定性作用，因此按照 D(wh)函数的分布进行采样会非常高效。使用这种方式，首先从微表面分布 D(wh)生成一个微表面的朝向样本，然后入射方向通过镜面反射或透射公式来获得。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23454;&#36341;&#20013;&#65292;&#37319;&#26679;&#21487;&#35265;&#24494;&#34920;&#38754;&#21306;&#22495;&#27604;&#37319;&#26679;&#25972;&#20010;&#20998;&#24067;&#35201;&#26356;&#39640;&#25928;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#21464;&#37327;&#29992;&#20110;&#25351;&#23450;&#26159;&#21542;&#21482;&#37319;&#26679;&#21487;&#35265;&#24494;&#34920;&#38754;&#21306;&#22495;</span>
  <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">MicrofacetDistribution</span>::sampleVisibleArea;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #bc6ec5; font-weight: bold;">Sample_wh</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span>;
</pre>
</div>

<p>
下面为 BeckmannDistribution::Sample_wh 对于各项同性情况下，在整个分布上进行采样的原理：<br />
<img src="./PhysicallyBasedRendering/2020_08_07_BeckmannDist_wh.jpg" alt="2020_08_07_BeckmannDist_wh.jpg" /><br />
</p>

<p>
下图为从倾斜方向看可见微表面分布和整体微表面分布的区别：<br />
<img src="./PhysicallyBasedRendering/2020_08_07_visible_dist_full_dist.jpg" alt="2020_08_07_visible_dist_full_dist.jpg" /><br />
</p>

<p>
下面为 从 wh 的分布概率密度函数推导 wi 的分布概率密度函数：<br />
<img src="./PhysicallyBasedRendering/2020_08_07_pdf-wh-to-wi_01.jpg" alt="2020_08_07_pdf-wh-to-wi_01.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_08_07_pdf-wh-to-wi.jpg" alt="2020_08_07_pdf-wh-to-wi.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org11da200" class="outline-6">
<h6 id="org11da200">FresnelBlend</h6>
<div class="outline-text-6" id="text-org11da200">
<p>
FresnelBlend 类为 diffuse 和 glossy 的混合。采样该 BRDF 的一种直接的方式为同时对 cosine-weighted 分布和 microfacet 分布进行采样。<br />
</p>
</div>
</div>
<div id="outline-container-org5f610dc" class="outline-6">
<h6 id="org5f610dc">Specular Reflection And Transmission(FresnelSpecular)</h6>
<div class="outline-text-6" id="text-org5f610dc">
<p>
前面章节使用 Dirac delta 分布来定义 specular 反射的 BRDF 和 specular 透射的 BTDF。对于当前的采样框架其非常适用，Dirac delta 分布在 x!=0 时，其值为 0，其只有一个样本，因此为该分布生成样本非常简单。但是，确定其 PDF 则不是很简单。严格来说，delta 分布不是一个真正的函数，其必须定义为另一个函数的极限(如 面积为 1 的 box 函数，其宽度无限接近于 0 对应函数，此时δ(0)趋近于无穷大)，当然，计算 PDF 时，返回一个无穷大或很大的值，在渲染时，不会得到正确的结果。<br />
<img src="./PhysicallyBasedRendering/2020_08_10_specular_r_t_pdf.jpg" alt="2020_08_10_specular_r_t_pdf.jpg" /><br />
</p>

<p>
基于上面的分析，Sample_f()中分子分母中<a id="orge6b766d"></a>，因此返回的 pdf 为 1，而 Pdf()返回的 pdf 为 0，表示其他方向的概率密度为 0.<br />
</p>

<p>
FresnelSpecular 类同时封装了镜面反射和镜面透射，其通过电介质 Fresnel 项来调节镜面反射和镜面透射的量。例如，在掠射角度上，反射比较高，此时使用 MonteCarlo 采样时应该更大可能返回反射方向而不是透射方向，这种方式改进了 MonteCarlo 的效果。<br />
</p>

<p>
FresnelSpecular::Sample_f() 当样本为 Specular Reflection 时，pdf=F，当样本为 Specular Transmission 时，pdf=1-F。F 为 Fresnel 反射量，计算 F 值的函数为 <a href="#org5cc72ab">FrDielectric函数</a> <a href="#org36d109a">FrConductor函数</a>。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #bc6ec5; font-weight: bold;">FresnelSpecular</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;R, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> &amp;T, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaA</span>,
                  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaB</span>, <span style="color: #ce537a; font-weight: bold;">TransportMode</span> <span style="color: #7590db;">mode</span>)
    : BxDF(BxDFType(BSDF_REFLECTION | BSDF_TRANSMISSION | BSDF_SPECULAR)),
    R(R),
    T(T),
    etaA(etaA),
    etaB(etaB),
    fresnel(etaA, etaB),
    mode(mode) {}


  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">FresnelSpecular</span>::Sample_f(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wo, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>,
                                     <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>,
                                     <span style="color: #ce537a; font-weight: bold;">BxDFType</span> *<span style="color: #7590db;">sampledType</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">F</span> = FrDielectric(CosTheta(wo), etaA, etaB);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#21453;&#23556;&#36827;&#34892;&#37319;&#26679;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (u[0] &lt; F) {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute specular reflection for _FresnelSpecular_</span>

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute perfect specular reflection direction</span>
      *wi = Vector3f(-wo.x, -wo.y, wo.z);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (sampledType)
        *sampledType = BxDFType(BSDF_SPECULAR | BSDF_REFLECTION);
      *pdf = F;
      <span style="color: #4f97d7; font-weight: bold;">return</span> F * R / AbsCosTheta(*wi);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#36879;&#23556;&#36827;&#34892;&#37319;&#26679;</span>
    {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute specular transmission for _FresnelSpecular_</span>

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Figure out which $\eta$ is incident and which is transmitted</span>
      <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">entering</span> = CosTheta(wo) &gt; 0;
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaI</span> = entering ? etaA : etaB;
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">etaT</span> = entering ? etaB : etaA;

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute ray direction for specular transmission</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>Refract(wo, Faceforward(Normal3f(0, 0, 1), wo), etaI / etaT, wi))
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
      <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">ft</span> = T * (1 - F);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Account for non-symmetry with transmission to different medium</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (mode == TransportMode::Radiance)
        ft *= (etaI * etaI) / (etaT * etaT);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (sampledType)
        *sampledType = BxDFType(BSDF_SPECULAR | BSDF_TRANSMISSION);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306;&#36879;&#23556;&#30340;pdf = 1-F&#65292;&#36825;&#20445;&#35777;&#20102;&#33021;&#37327;&#23432;&#24658;</span>
      *pdf = 1 - F;
      <span style="color: #4f97d7; font-weight: bold;">return</span> ft / AbsCosTheta(*wi);
    }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd240bd0" class="outline-6">
<h6 id="orgd240bd0"><span class="todo TODO">TODO</span> Fourier BSDF</h6>
</div>
<div id="outline-container-org62d7aa5" class="outline-6">
<h6 id="org62d7aa5">Application: Estimating Reflectance</h6>
<div class="outline-text-6" id="text-org62d7aa5">
<p>
<a href="#orgb61ffaf">hemispherical-directional reflectance半球方向反射</a><br />
<a href="#orgd2743c0">hemispherical-hemispherical reflectance 半球半球反射</a><br />
</p>


<div id="org3acd860" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_08_11_bxdf_rho.jpg" alt="2020_08_11_bxdf_rho.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org707718a" class="outline-6">
<h6 id="org707718a">Sampling BSDFs</h6>
<div class="outline-text-6" id="text-org707718a">
<p>
BSDF 包含了所有的 BxDF。BxDF* BSDF::bxdfs[MaxBxDFs] 成员变量存储所有 bxdf 的引用。<br />
</p>


<div id="org5dd8f38" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_08_11_bsdf_pdf.jpg" alt="2020_08_11_bsdf_pdf.jpg" /><br />
</p>
</div>

<p>
<a href="#org7e3b241">BSDF::Pdf</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb4026a2" class="outline-5">
<h5 id="orgb4026a2">Sampling Light Sources</h5>
<div class="outline-text-5" id="text-orgb4026a2">
<p>
Lights 需要实现两个采样方法。第一个为 Sample_Li()，其对场景中某点的入射方向进行采样，光照沿该方向可以照亮该点。第二个为 Sample_Le()，其返回携带光照的射线，该射线从光源出发。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in  ref --&gt; ref&#20026;&#20809;&#32447;&#21644;&#22330;&#26223;&#20013;&#34920;&#38754;&#30340;&#20132;&#28857;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in  u   --&gt; u  &#25552;&#20379;&#20102;&#19968;&#20010;2D&#26679;&#26412;&#20540;&#65292;&#29992;&#20110;&#23545;&#20809;&#28304;&#36827;&#34892;&#37319;&#26679;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">out wi  --&gt; wi &#20026;&#26679;&#26412;&#30340;&#26041;&#21521;&#65292;&#20837;&#23556;&#35282;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">out pdf --&gt; wi&#23545;&#24212;&#30340;&#27010;&#29575;&#23494;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return  --&gt; </span>
virtual <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">Light</span>::Sample_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u,
                                  <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>,
                                  <span style="color: #ce537a; font-weight: bold;">VisibilityTester</span> *<span style="color: #7590db;">vis</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>
</div>

<div id="outline-container-org0598b57" class="outline-6">
<h6 id="org0598b57">Lights With Singularities</h6>
<div class="outline-text-6" id="text-org0598b57">
<p>
和完美的镜面反射和镜面透射一样，被定义为 delta 分布的光源也适用于当前采样框架，但是需要注意返回的辐射率和 PDF 中所隐含的 delta 分布，大多数情况下，这些 delta 分布会被约掉，但是 Multiple Importance Sampling 必须注意这种情况。<br />
PointLight 是由 delta 分布来描述的，其只会从单个方向照明一个点。由于是 delta 分布，因此 PointLight::Pdf_Li()返回 0.<br />
</p>
</div>
</div>

<div id="outline-container-orgb6dccb8" class="outline-6">
<h6 id="orgb6dccb8">Sampling Shapes</h6>
<div class="outline-text-6" id="text-orgb6dccb8">
<p>
pbrt 中，area lights 都有一个 Shape 对象来指定区域光的形状，为了从这样的区域光采样入射照明，需要在区域光形状上生成样本。因此，pbrt 为 Shape 类增加了采样方法。<br />
有两个采样方法，第一个方法如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#26041;&#27861;&#38500;&#20102;&#21021;&#22987;&#21270;&#37319;&#26679;&#28857;&#30340;&#20301;&#32622;p&#65292;&#27861;&#32447;n&#20197;&#22806;&#65292;&#20854;&#36824;&#38656;&#35201;&#22788;&#29702;&#28014;&#28857;&#20540;&#30340;&#33293;&#20837;&#38169;&#35823;</span>
<span style="color: #ce537a; font-weight: bold;">virtual</span> <span style="color: #bc6ec5; font-weight: bold;">Shape</span>::Interaction Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24418;&#29366;&#19978;&#30340;&#37319;&#26679;&#20960;&#20046;&#37117;&#26159;&#22343;&#21248;&#30340;&#65292;&#22240;&#27492;&#20854;pdf&#20026;&#38754;&#31215;&#30340;&#20498;&#25968;</span>
<span style="color: #ce537a; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">Shape</span>::Pdf(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;) <span style="color: #4f97d7; font-weight: bold;">const</span> { <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / Area(); }
</pre>
</div>

<p>
第二个采样方法如下，该方法对于光照来说特别有用，因为调用者可以传入被照亮的点，其允许区域光的形状实现保证只采样对于被照亮点可见的部分。<br />
</p>
<div class="org-src-container">
<pre class="src src-c">virtual <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #bc6ec5; font-weight: bold;">Shape</span>::Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span> {<span style="color: #4f97d7; font-weight: bold;">return</span> Sample(u);}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;&#23454;&#29616;&#20013;&#65292;&#23558;&#23450;&#20041;&#22312;&#21306;&#22495;&#19978;&#30340;&#23494;&#24230;&#36716;&#21270;&#20026;&#23450;&#20041;&#22312;&#31435;&#20307;&#35282;&#19978;&#30340;&#23494;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32473;&#23450;&#19968;&#20010;&#20132;&#28857;&#21644;wi&#65292;&#33509;&#20174;&#20132;&#28857;&#21457;&#20986;wi&#26041;&#21521;&#30340;&#23556;&#32447;&#21644;&#21306;&#22495;&#20809;&#24418;&#29366;&#19981;&#30456;&#20132;&#65292;&#21017;pdf&#20026;0&#65292;&#33509;&#30456;&#20132;&#20854;&#35745;&#31639;&#20844;&#24335;&#22914;&#19979;&#22270;&#65306;</span>
virtual <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">Shape</span>::Pdf(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span>;
</pre>
</div>
<p>
<img src="./PhysicallyBasedRendering/2020_08_11_area_light_pdf.jpg" alt="2020_08_11_area_light_pdf.jpg" /><br />
上面公式推导请参考： <a href="#orgf5315e1">Integrals over area</a><br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5e7d8dc"></a>Sampling Disks<br />
<div class="outline-text-7" id="text-org5e7d8dc">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #bc6ec5; font-weight: bold;">Disk</span>::Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37325;&#24515;&#22352;&#26631;&#37319;&#26679;disk</span>
    <span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #7590db;">pd</span> = ConcentricSampleDisk(u);
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #bc6ec5; font-weight: bold;">pObj</span>(pd.x * radius, pd.y * radius, height);
    <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #7590db;">it</span>;
    it.n = Normalize((*ObjectToWorld)(Normal3f(0, 0, 1)));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (reverseOrientation) it.n *= -1;
    it.p = (*ObjectToWorld)(pObj, Vector3f(0, 0, 0), &amp;it.pError);
    <span style="color: #4f97d7; font-weight: bold;">return</span> it;
  }
</pre>
</div>
</div>
</li>
<li><a id="org02d1060"></a>Sampling Cylinders<br />
<div class="outline-text-7" id="text-org02d1060">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #bc6ec5; font-weight: bold;">Cylinder</span>::Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">z</span> = Lerp(u[0], zMin, zMax);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">phi</span> = u[1] * phiMax;
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">pObj</span> = Point3f(radius * std::cos(phi), radius * std::sin(phi), z);
    <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #7590db;">it</span>;
    it.n = Normalize((*ObjectToWorld)(Normal3f(pObj.x, pObj.y, 0)));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (reverseOrientation) it.n *= -1;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Reproject _pObj_ to cylinder surface and compute _pObjError_</span>
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">hitRad</span> = std::sqrt(pObj.x * pObj.x + pObj.y * pObj.y);
    pObj.x *= radius / hitRad;
    pObj.y *= radius / hitRad;
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">pObjError</span> = gamma(3) * Abs(Vector3f(pObj.x, pObj.y, 0));
    it.p = (*ObjectToWorld)(pObj, pObjError, &amp;it.pError);
    <span style="color: #4f97d7; font-weight: bold;">return</span> it;
}
</pre>
</div>
</div>
</li>
<li><a id="org5091872"></a>Sampling Triangles<br />
<div class="outline-text-7" id="text-org5091872">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #bc6ec5; font-weight: bold;">Triangle</span>::Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Point2f</span> <span style="color: #7590db;">b</span> = UniformSampleTriangle(u);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Get triangle vertices in _p0_, _p1_, and _p2_</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;p0 = mesh-&gt;p[v[0]];
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;p1 = mesh-&gt;p[v[1]];
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3f</span> &amp;p2 = mesh-&gt;p[v[2]];
    <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #7590db;">it</span>;
    it.p = b[0] * p0 + b[1] * p1 + (1 - b[0] - b[1]) * p2;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute surface normal for sampled point on triangle</span>
    it.n = Normalize(Normal3f(Cross(p1 - p0, p2 - p0)));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Ensure correct orientation of the geometric normal; follow the same</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">approach as was used in Triangle::Intersect().</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mesh-&gt;n) {
        <span style="color: #ce537a; font-weight: bold;">Normal3f</span> <span style="color: #bc6ec5; font-weight: bold;">ns</span>(<span style="color: #ce537a; font-weight: bold;">b</span>[0] * mesh-&gt;n[v[0]] + b[1] * mesh-&gt;n[v[1]] +
                    (1 - b[0] - b[1]) * mesh-&gt;n[v[2]]);
        it.n = Faceforward(it.n, ns);
    } <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> (reverseOrientation ^ transformSwapsHandedness)
        it.n *= -1;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute error bounds for sampled point on triangle</span>
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">pAbsSum</span> =
        Abs(b[0] * p0) + Abs(b[1] * p1) + Abs((1 - b[0] - b[1]) * p2);
    it.pError = gamma(6) * Vector3f(pAbsSum.x, pAbsSum.y, pAbsSum.z);
    <span style="color: #4f97d7; font-weight: bold;">return</span> it;
}
</pre>
</div>
</div>
</li>
<li><a id="org327a3a9"></a>Sampling Sphere<br />
<div class="outline-text-7" id="text-org327a3a9">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #bc6ec5; font-weight: bold;">Sphere</span>::Sample(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Point3f</span> <span style="color: #7590db;">pObj</span> = Point3f(0, 0, 0) + radius * UniformSampleSphere(u);
    <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #7590db;">it</span>;
    it.n = Normalize((*ObjectToWorld)(Normal3f(pObj.x, pObj.y, pObj.z)));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (reverseOrientation) it.n *= -1;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Reproject _pObj_ to sphere surface and compute _pObjError_</span>
    pObj *= radius / Distance(pObj, Point3f(0, 0, 0));
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">pObjError</span> = gamma(5) * Abs((<span style="color: #ce537a; font-weight: bold;">Vector3f</span>)pObj);
    it.p = (*ObjectToWorld)(pObj, pObjError, &amp;it.pError);
    <span style="color: #4f97d7; font-weight: bold;">return</span> it;
}
</pre>
</div>
<p>
<img src="./PhysicallyBasedRendering/2020_08_11_sample_sphere_01.jpg" alt="2020_08_11_sample_sphere_01.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_08_11_sample_sphere_02.jpg" alt="2020_08_11_sample_sphere_02.jpg" /><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf158ed1" class="outline-6">
<h6 id="orgf158ed1">Area Lights</h6>
<div class="outline-text-6" id="text-orgf158ed1">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">DiffuseAreaLight</span>::Sample_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u,
                                       <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>,
                                       <span style="color: #ce537a; font-weight: bold;">VisibilityTester</span> *<span style="color: #7590db;">vis</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679;&#30340;&#20855;&#20307;&#24037;&#20316;&#37117;&#30001;&#21069;&#19968;&#33410;&#20171;&#32461;&#30340;Shape::Sample&#20989;&#25968;&#23436;&#25104;</span>
    <span style="color: #ce537a; font-weight: bold;">Interaction</span> <span style="color: #7590db;">pShape</span> = shape-&gt;Sample(ref, u);
    pShape.mediumInterface = mediumInterface;
    <span style="color: #4f97d7; font-weight: bold;">if</span> ((pShape.p - ref.p).LengthSquared() == 0) {
      *pdf = 0;
      <span style="color: #4f97d7; font-weight: bold;">return</span> 0.f;
    }
    *wi = Normalize(pShape.p - ref.p);
    *pdf = shape-&gt;Pdf(ref, *wi);
    *vis = VisibilityTester(ref, pShape);
    <span style="color: #4f97d7; font-weight: bold;">return</span> L(pShape, -*wi);
  }

  <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">DiffuseAreaLight</span>::Pdf_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;wi) <span style="color: #4f97d7; font-weight: bold;">const</span> 
  {
    <span style="color: #4f97d7; font-weight: bold;">return</span> shape-&gt;Pdf(ref, wi);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcfb111b" class="outline-6">
<h6 id="orgcfb111b">Infinite Area Lights</h6>
<div class="outline-text-6" id="text-orgcfb111b">
<p>
Infinite Area Lights 可以被当作一个无限大的球，其包围了整个场景，从所有方向对场景进行照明。InfiniteAreaLights 使用的环境贴图通常会随着方向不同而有明显的变化，例如，白天的天空环境贴图，对着太阳的少数方向的亮度要比其他方向亮数千倍。给定明显的变化，对 InfiniteAreaLights 采样如果匹配其照明分布，将会明显减小生成图片的方差。<br />
这种采样方式的实现主要需要如下三个步骤：<br />
</p>
<ol class="org-ol">
<li>定义一个 2D 分段概率分布函数 p(u,v)，(u,v)为图片的坐标。p(u,v)对应了环境贴图表示的辐射率的分布。<br /></li>
<li>应用 13.6.7 节的采样方法<a href="#org224cf0c">Piecewise-Constant 2D Distributions</a>，将 2D 样本转化为从分段的 p(u,v)分布进行采样<br /></li>
<li>基于(u,v)上的概率密度，定义在单位球所有方向上的概率密度函数<br /></li>
</ol>

<p>
第一步通过 Spectrum::y() 函数计算一组样本点的 luminance（亮度），从而将环境贴图定义的连续的光谱辐射率函数转化为常量分段函数。该步骤需要注意以下三点：<br />
</p>
<ol class="org-ol">
<li>计算辐射率函数的值时，所取的点的数量和原始贴图图元的数量相同。使用更多或更少的点，会导致对应地增加或减少内存的占用，但依然可以生成可用的样本分布。更少的点可能会导致采样分布和函数不匹配，而更多的样本会导致内存浪费却只增加了很少的好处。<br /></li>
<li>常量分段函数的值被存储在 img 变量中，MIPMap::Lookup()方法返回的值赋给了 img 变量。MIPMap::Lookup()方法会轻微 blurring 辐射率函数。因为连续的辐射率函数是通过线性插值图元来重建的，而有些图元是完全黑的，但离该图元很短距离的点可能是不为零的(不完全黑的)。因为我们使用常量分段函数来采样，而不是分段线性函数，因此必须考虑这种情况来保证在辐射率函数不为 0 的地方任何点的概率都大于 0。<br /></li>
<li>img 变量中的值都被乘了一个 sin(&theta;)，将经纬图映射到球时，对应的每行都有不同的 &theta; 值。注意这样做对于采样方法的正确性没有影响，因为 sin(&theta;) 的值在[0, π]范围上总是大于 0，我们只是改变了 pdf 的形状。这样做是为了调节 pdf 以消除从 2D 图片到单位球映射的扭曲。<br /></li>
</ol>


<div id="org70fef96" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_08_11_infinite_area_light_pdf.jpg" alt="2020_08_11_infinite_area_light_pdf.jpg" /><br />
</p>
</div>

<p>
利用上面的公式，我们可以从图片定义的阶段常量分布进行采样，然后将样本极其概率密度转化为单位圆上方向的形式。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">InfiniteAreaLight</span>::Sample_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;ref, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;u, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>, <span style="color: #ce537a; font-weight: bold;">VisibilityTester</span> *<span style="color: #7590db;">vis</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Find (u, v) sample coordinates in infinite light texture </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Convert infinite light sample point to direction </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute PDF for sampled infinite light direction </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Return radiance value for infinite light direction </span>
}
<span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #bc6ec5; font-weight: bold;">InfiniteAreaLight</span>::Pdf_Li(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Interaction</span> &amp;, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;w) <span style="color: #4f97d7; font-weight: bold;">const</span> 
{
    <span style="color: #ce537a; font-weight: bold;">Vector3f</span> <span style="color: #7590db;">wi</span> = WorldToLight(w);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">theta</span> = SphericalTheta(wi), <span style="color: #7590db;">phi</span> = SphericalPhi(wi);
    <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">sinTheta</span> = std::sin(theta);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (sinTheta == 0) <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> distribution-&gt;Pdf(Point2f(phi * Inv2Pi, theta * InvPi)) / (2 * Pi * Pi * sinTheta);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd129c1c" class="outline-5">
<h5 id="orgd129c1c">Direct Lighting</h5>
<div class="outline-text-5" id="text-orgd129c1c">
<p>
DirectLightingIntegrator 只考虑直接光照(从光源直接到达被渲染点的光)忽略间接光照(来自不发光物体的光)。<br />
</p>

<p>
DirectLightingIntegrator 的实现提供了两种策略用于计算方向光照。<br />
LightStrategy.UniformSampleAll 会循环遍历所有光源，对于每个光源按照取 Light::nSamples 个样本，累加结果。<br />
LightStrategy.UniformSampleOne 只会随机选择一个光源的一个样本。<br />
</p>

<p>
依赖于被渲染的场景，这两种方式都可能更适合。例如，如果为每个像素选择的样本很多，则单个光源样本更合适：合计一个像素的所有样本对方向光的采样就足够好了，可以得到高质量的图片。如果每个像素的样本比较少，采样所有光照可能更适合，这样才能保证无噪声的结果。<br />
</p>


<div id="org0fd298a" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_08_11_direct_light_integrator.jpg" alt="2020_08_11_direct_light_integrator.jpg" /><br />
</p>
</div>

<p>
在场景中有很多光源时，可能并不希望总是为被渲染的点计算来自所有光源的光。MonteCarlo 给了一种方式，其可以不计算所有光源平均来说依然能得到正确结果。考虑计算两个函数和的期望 E[f(x)+g(x)]，如果我们随机只计算 f(x)或 g(x)，然后将结果乘 2，则结果的期望将为 f(x)+g(x)。这就是 LightStrategy.UniformSampleOne 策略的原理。<br />
</p>
</div>
<div id="outline-container-org673d88f" class="outline-6">
<h6 id="org673d88f">Estimating The Direct Lighting Integral</h6>
<div class="outline-text-6" id="text-org673d88f">

<div id="org8852011" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_08_11_direct_lighting_integral.jpg" alt="2020_08_11_direct_lighting_integral.jpg" /><br />
</p>
</div>

<p>
为了减少方差，我们会使用重要性采样来选择 wj 方向。因为 BSDF 和方向辐射率项是独立的，很难找到这两项乘积的样本分布。这里我们会对一部分样本使用 BSDF 的样本分布，剩下的使用光照的分布。依赖于两者各自的特性，可能其中一种采样方法比另一种更有效。对于这种一个可能比另一个更有效的情况，我们将使用 Multiple Importance Sampling 来减少方差。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgafd2b1f" class="outline-5">
<h5 id="orgafd2b1f">The Light Transport Equation</h5>
<div class="outline-text-5" id="text-orgafd2b1f">
<ul class="org-ul">
<li>Transport Equation 传输方程<br /></li>
<li>Transfer Equation  传播方程<br /></li>
</ul>

<p>
场景中某点的入射辐射率受到场景中所有物体的几何属性、散射属性影响，这使得求解 Light Transport Equation 很困难。例如，一个亮的光照射一个红色物体，可能导致场景中旁边物体上有红点，或者桌子上的玻璃可能将光聚焦为焦散形状。考虑这种复杂性的渲染算法被称为全局照明算法，而局部照明算法则在渲染计算中只使用局部表面的信息。<br />
</p>
</div>
<div id="outline-container-org4faad2e" class="outline-6">
<h6 id="org4faad2e">Basic Derivation</h6>
<div class="outline-text-6" id="text-org4faad2e">
<p>
为了达到能量守恒，出射辐射率 Lo 必须等于物体发射的辐射率加上入射辐射率被散射的部分。<br />
<img src="./PhysicallyBasedRendering/2020_08_12_lte.jpg" alt="2020_08_12_lte.jpg" /><br />
</p>


<div id="org284bb59" class="figure">
<p><img src="./PhysicallyBasedRendering/00_04_14_04_lte_explain.jpg" alt="00_04_14_04_lte_explain.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3988273" class="outline-6">
<h6 id="org3988273">Analytic Solutions to the LTE</h6>
<div class="outline-text-6" id="text-org3988273">
<p>
简洁的 LTE 隐藏了无法对其进行一般化的解析求解的事实。基于物理的 BSDF 模型，场景中几何体的任意性，物体之间任意的可见性关系都使得只能通过数值求解技术来对 LTE 进行求解。<br />
但对于极其简单的设定，依然可以通过解析的方法来求解 LTE，例如，考虑一个球体的内部，其表面所有点都有相同的 LambertianBRDF，即，f(p,wo,wi)=c，并且向所有方向发出相同的辐射率：<br />
<img src="./PhysicallyBasedRendering/2020_08_12_analytic_lte.jpg" alt="2020_08_12_analytic_lte.jpg" /><br />
</p>

<p>
参考 <a href="#org565ac73">LambertainBRDF 推导</a> 就可以明白上面推导了。<br />
</p>
</div>
</div>
<div id="outline-container-org7ed14bf" class="outline-6">
<h6 id="org7ed14bf">The Surface form of the LTE</h6>
<div class="outline-text-6" id="text-org7ed14bf">
<p>
<img src="./PhysicallyBasedRendering/2020_08_12_surface_form_lte.jpg" alt="2020_08_12_surface_form_lte.jpg" /><br />
尽管方向形式和表面形式的光照传输方程是等价的，但其代表了两种不同的光照传输方式。使用 MonteCarlo 对方向形式的 LTE 进行求解，我们需要从方向分布中采样多个方向样本，然后发射射线来求解积分；对于表面形式的 LTE，我们需要按照点在表面面积上的分布在表面上选择多个点，然后计算这些点之间的连接来求解积分，追踪射线来求解可见性项 V(p&lt;-&gt;p')。G(p"&lt;-&gt;p')为耦合的几何项，其包含了方向形式 LTE 中的|cosθ|项，双向可见性项 V。<br />
</p>

<p>
立体角积分到面积积分的转化请参考： <a href="#orgf5315e1">Integrals over area</a><br />
</p>
</div>
</div>
<div id="outline-container-orgb25bb26" class="outline-6">
<h6 id="orgb25bb26">Integral Over Paths</h6>
<div class="outline-text-6" id="text-orgb25bb26">
<p>
从表面形式的 LTE 方程可以推导出更灵活的 LTE 形式，该形式被称为光照传输的路径积分公式(path integral formulation of light transport)。<br />
<img src="./PhysicallyBasedRendering/2020_08_12_path_integral_lte.jpg" alt="2020_08_12_path_integral_lte.jpg" /><br />
<img src="./PhysicallyBasedRendering/2020_08_12_path_integral_lte002.jpg" alt="2020_08_12_path_integral_lte002.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgc9c5d9a" class="outline-6">
<h6 id="orgc9c5d9a">Delta Distributions in the Integrand</h6>
<div class="outline-text-6" id="text-orgc9c5d9a">
<p>
假设在 Plight 点处，场景中只有一个点光源，考虑直接照明项，使用 delta 分布描述的 P(p2)如下：<br />
<img src="./PhysicallyBasedRendering/2020_08_12_direct_light_p2.jpg" alt="2020_08_12_direct_light_p2.jpg" /><br />
</p>

<p>
也就是说，在场景中 p2 必须和点光源的位置一样；分子中的δ项可以和分母中 p(Plight)中隐含的δ项约去，剩余的项可以直接求解而不需要使用 MonteCarlo(由于δ项的存在，只有 p2 为 plight 才有值，其他情况都为 0，所以不需要积分了)。类似的情况适用于路径吞吐量 T 中包含δ分布的 BSDF 项。<br />
δ项的抵消，具体请参考： <a href="#orge6b766d">δ项抵消</a><br />
</p>
</div>
</div>

<div id="outline-container-org677aa5c" class="outline-6">
<h6 id="org677aa5c">Partitioning The Integrand</h6>
<div class="outline-text-6" id="text-org677aa5c">
<p>
很多渲染算法被开发出来用于求解某些条件下的光照传输方程，而对于其他条件则无法使用。例如，Whitted integrator 只处理 delta BSDF 的镜面反射而忽略 diffuse 和 glossyBSDF 的多次散射光。<br />
我们希望导出正确的光照传输算法，其考虑所有可能的散射模型，而不忽略任何贡献，并且也不多次计算。处理该问题的一种比较好的方式是以多种方式将 LTE 进行划分。例如，我们将 LTE 求和在路径上展开：<br />
<img src="./PhysicallyBasedRendering/2020_08_12_partitioning_lte_001.jpg" alt="2020_08_12_partitioning_lte_001.jpg" /><br />
第一项通过计算 p1 点的发射辐射率来进行求解，第二项使用精确的直接光照求解技术进行求解，而剩余的项使用快速但不精确的方式进行求解。如果剩余的项对于整体反射的辐射率贡献相对比较小，这种方式就是合理的。需要注意的细节是，在计算剩余项时，需要忽略 P(p1) P(P2).<br />
</p>

<p>
将每个 P(pn)项分离为独立的多项也是很有用的。例如，我们可以将 Emission 项分为小光源 Les 和大光源 Lel:<br />
<img src="./PhysicallyBasedRendering/2020_08_12_partitioning_lte_002.jpg" alt="2020_08_12_partitioning_lte_002.jpg" /><br />
这两个积分可以独立求解，可能使用完全不同的算法或不同的样本数量。<br />
</p>

<p>
BSDF 项也是可以被分离的。如下：<br />
<img src="./PhysicallyBasedRendering/2020_08_12_partitioning_lte_003.jpg" alt="2020_08_12_partitioning_lte_003.jpg" /><br />
</p>

<p>
下面展示了连乘的意义：<br />
<img src="./PhysicallyBasedRendering/2020_08_12_product.jpg" alt="2020_08_12_product.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1f03b1c" class="outline-5">
<h5 id="org1f03b1c">Path Tracing</h5>
<div class="outline-text-5" id="text-org1f03b1c">
</div>
<div id="outline-container-org4d31319" class="outline-6">
<h6 id="org4d31319">Overview</h6>
<div class="outline-text-6" id="text-org4d31319">
<p>
给定路径积分形式的光照传输方程，我们希望估算出 p1 点的出射辐射度，p1 点为摄像机射线和场景中物体的交点。为了估算该值，有两个问题需要解决：<br />
</p>
<ol class="org-ol">
<li>如何使用有限数量的计算来估算无限个 P(pi)项<br /></li>
<li>给定特定的 P(pi)项，如何生成一个或多个路径来利用 MonteCarlo 估算多维积分<br /></li>
</ol>

<p>
对于路径追踪，我们可以利用如下事实，基于物理的场景中，包含多个顶点的路径散射的光比包含更少顶点的路径散射的光要少。这是 BSDF 能量守恒很自然的结论。因此，我们总是估算开始的几项，然后开始应用 Russian roulette 来停止采样。例如，我们总是计算 P(p1) P(p2) P(p3)，但是按照概率 q，停止计算更多的项，则求和的无偏估计为：<br />
<img src="./PhysicallyBasedRendering/2020_08_13_russian_roulette_lte001.jpg" alt="2020_08_13_russian_roulette_lte001.jpg" /><br />
以这种方式使用 Russian roulette，没有解决需要求无穷和的问题。如果我们将这种思想再往前推进一步，即对于每一项都按照概率 qi 来确定是否结束计算：<br />
<img src="./PhysicallyBasedRendering/2020_08_13_russian_roulette_lte002.jpg" alt="2020_08_13_russian_roulette_lte002.jpg" /><br />
最终我们将停止继续计算求和。因为对于任何特定的 i，计算 P(pi)的概率大于 0，如果我们求解了 P(pi)，其将会被赋予合适的权重，最终的结果就是一个无偏估计。<br />
</p>
</div>
</div>
<div id="outline-container-org4de65ad" class="outline-6">
<h6 id="org4de65ad">Path Sampling</h6>
<div class="outline-text-6" id="text-org4de65ad">
<p>
给定计算有限项来计算无限项的方法，我们还需要计算特定项 P(pi)的方法。我们需要 i+1 个顶点来指定该路径，其中最后一个顶点 pi 在光源上，第一个顶点 p0 在摄像机胶片上。<br />
<img src="./PhysicallyBasedRendering/2020_08_13_lte_pj_term.jpg" alt="2020_08_13_lte_pj_term.jpg" /><br />
P(pi)为在场景物体表面区域上的多重积分，最自然的方法是按照场景中物体表面对顶点 pi 进行采样，这样对场景中某个物体上的特定点 pi 和其他点都是等可能的。<br />
我们可以在场景中的 n 个物体上定义一个离散概率。如果每个物体的表面面积为 Ai,则在第 i 个物体的表面上采样一个路径顶点的概率为：<br />
<img src="./PhysicallyBasedRendering/2020_08_13_pj_probability.jpg" alt="2020_08_13_pj_probability.jpg" /><br />
给定一组按照这种方式采样得到的顶点 p0,p1,&#x2026;,pi-1，对于最后一个顶点 pi，我们可以在光源上进行采样。尽管我们可以使用相同的技术来采样路径点和光源上的点，但这会导致比较大的方差，因为对于所有的路径当 pi 不在发射光的对象上时，该路径对应的值为 0。期望值依然是正确的积分值，但是收敛速度非常慢。更好的方法是仅对发光对象的区域进行采样，并相应更新概率。 给定完整的路径，我们拥有估算 P(pi)所需的所有信息。<br />
对于通用的方式，关于如何设置采样概率，我们可以更具创造性。例如，如果我们知道间接照明来源于很少几个物体的贡献，我们可以对这些物体上的路径点赋予更高的概率，并更新样本的权重。<br />
然而，以这种方式进行路径采样时，有两个互相关联的问题。第一个会导致很高的方差，第二个会导致不正确的结果。<br />
第一个问题为很多路径将为无贡献的，如果其有邻接的点之间互相不可见。例如，在一个很复杂的建筑模型，邻接的路径点之间几乎总是有一堵或两堵墙。<br />
第二个问题为如果积分包含 delta 函数(例如，点光源或完美镜面 BSDF)，该采样技术将无法选择路径点从而让 delta 分布不为零。即使没有 delta 分布，BSDFs 变得越 glossy，则几乎所有路径将只有很小的贡献，因为 f(pi+1-&gt;pi-&gt;pi-1)中的点将导致 BSDF 为很小值或零值，这使得我们依然遭受高方差问题。同样地，如果不显示地进行采样，小区域光源也会导致高方差问题。<br />
</p>
</div>
</div>
<div id="outline-container-org600f703" class="outline-6">
<h6 id="org600f703">Incremental Path Construction</h6>
<div class="outline-text-6" id="text-org600f703">
<p>
解决以上问题的一个方案为从摄像机顶点 p0 开始渐进地构造路径。在每个顶点上，对 BSDF 进行采样来生成新的方向；通过追踪从 pi 出发指向采样方向的射线，然后求最近的交点来发现下一个顶点 pi+1。通过一系列选择，查找对局部贡献重要的方向，我们可以有效查找对整体贡献很大的方向。尽管有些情况该方案不是有效的，但是一般来说其是一个好的策略。<br />
</p>

<p>
因为该方案通过对 BSDF 按照立体角采样来构造路径，而路径积分 LTE 是在表面区域上的，因此我们需要将按照立体角的概率密度 pw 转化为按照面积的密度 pA 来执行修正.<br />
<img src="./PhysicallyBasedRendering/2020_08_13_pw_pA.jpg" alt="2020_08_13_pw_pA.jpg" /><br />
</p>

<p>
上图中公式的推导请参考 <a href="#orgf5315e1">将在方向上的积分转化为在面积上的积分</a> 。<br />
Tips: pA = 1/A<br />
</p>

<p>
该修正导致所有的几何项都从 P(pi)中被消去。我们已经知道 pi 和 pi+1 互相可见，因为我们通过射线追踪找到 pi+1,因此可见项都等于 1.换一种方法来理解就是，射线追踪提供了一种重要性采样可见分量 G 的操作。因此，如果我们使用该采样技术，我们依然从所有光源表面上按照 pA(pi)采样最后一个点 pi，可得一个路径的 MonteCarlo estimate 为：<br />
<img src="./PhysicallyBasedRendering/2020_08_13_mce_path.jpg" alt="2020_08_13_mce_path.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgc989bc0" class="outline-6">
<h6 id="orgc989bc0">Implementations</h6>
<div class="outline-text-6" id="text-orgc989bc0">
<p>
从摄像机射线和场景的第一个交点 p1 开始，在当前顶点从 BSDF 的采样分布进行采样，然后追踪射线到下一个顶点，从而递增地得到采样路径顶点。为了查找特定路径的最后一个顶点 pi，其必须在场景的某个光源上，使用了 multiple importance sampling，该 MIS 是基于直接光照的代码，开发出来用于直接光照积分器使用。通过使用 MIS 采样权重代替 pA(pi)来计算前面描述的估计量，当对 BSDF 进行采样是得到一个光源上点的更好方法时，我们可以得到方差更小的结果。<br />
</p>

<p>
另一个微小的差异是，估算 P(pi)项时，前面 i-1 长度路径的顶点会被复用。这意味着只需要追踪一条射线来构建新的路径，而不是 i 条射线。以这种方式复用路径会在所有的 P(pi)项之间引入关联性，其会轻微减低质量，但是实践上其远远弥补了整体效率的改进。<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp">Spectrum <span style="color: #ce537a; font-weight: bold;">PathIntegrator</span>::<span style="color: #bc6ec5; font-weight: bold;">Li</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">RayDifferential</span> &amp;r, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Scene</span> &amp;scene,
                            Sampler &amp;sampler, MemoryArena &amp;arena,
                            <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">depth</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> {
    <span style="color: #ce537a; font-weight: bold;">ProfilePhase</span> <span style="color: #bc6ec5; font-weight: bold;">p</span>(Prof::SamplerIntegratorLi);
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #bc6ec5; font-weight: bold;">L</span>(0.f), <span style="color: #bc6ec5; font-weight: bold;">beta</span>(1.f);
    <span style="color: #ce537a; font-weight: bold;">RayDifferential</span> <span style="color: #bc6ec5; font-weight: bold;">ray</span>(<span style="color: #ce537a; font-weight: bold;">r</span>);
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">specularBounce</span> = <span style="color: #a45bad;">false</span>;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">bounces</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (bounces = 0;; ++bounces)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Find next path vertex and accumulate contribution</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Intersect ray with scene and store intersection in isect</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Possibly add emitted light at intersection</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Terminate path if ray escaped or maxDepth was reached</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#27809;&#26377;&#20132;&#28857;&#25110;&#32773;&#36798;&#21040;&#26368;&#22823;&#28145;&#24230;&#21017;break</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute scattering functions and skip over medium boundaries</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24573;&#30053;&#23556;&#32447;&#21644;&#20171;&#36136;&#36793;&#30028;&#30340;&#30456;&#20132;</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sample illumination from lights to find path contribution</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sample BSDF to get new path direction</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;bsdf&#36827;&#34892;&#37319;&#26679;&#24471;&#21040;&#19979;&#19968;&#20010;&#36335;&#24452;&#28857;&#30340;&#30340;&#26041;&#21521;</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Account for subsurface scattering, if applicable</span>
        
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Possibly terminate the path with Russian roulette</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992; Russian Roulette &#32467;&#26463;&#36335;&#24452;&#36861;&#36394;</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> L;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org33ba73b" class="outline-4">
<h4 id="org33ba73b">15 Light Transport II:Volume Rendering</h4>
<div class="outline-text-4" id="text-org33ba73b">
<p>
就像 BSDF 刻画了从表面的反射，Medium 类实现了表面之间发生的散射。例如大气散射效果的薄雾，牛奶瓶中的脂肪颗粒的散射。技术上来说，这些现象都是由于大量微小粒子之间的表面交互而产生的。<br />
</p>
</div>
<div id="outline-container-org8f971c2" class="outline-5">
<h5 id="org8f971c2">The Equation of Transfer</h5>
<div class="outline-text-5" id="text-org8f971c2">
<ul class="org-ul">
<li>Transport Equation 传输方程<br /></li>
<li>Transfer Equation  传播方程<br /></li>
</ul>

<p>
Equation of Transfer 是控制光在中间介质中行为的基础方程，介质会吸收、发射和散射辐射。light transport equation 是 Equation of Transfer 的特例情况，其略去了中间介质，只包含了从物体表面的散射。<br />
</p>

<p>
Equation of Transfer 的最基础形式是一个积分-微分方程，其描述了空间中一点上，沿着一条光线辐射的变化。可以将其转化为一个纯积分方程，该积分方程描述了中间介质的效果，该中间介质为空间中沿着一条射线的无穷多个点。<br />
</p>


<div id="org09216af" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_11_09_integral_differential_et.jpg" alt="2020_11_09_integral_differential_et.jpg" /><br />
</p>
</div>

<p>
<a href="#orgb3dace6">Tr 透射比公式推导</a><br />
</p>

<p>
<img src="./PhysicallyBasedRendering/2020_11_09_integral_et_02.jpg" alt="2020_11_09_integral_et_02.jpg" /><br />
上面方程的意义为：从 p 点沿着 w 射线的所有点增加的辐射对从 w 方向上到达 p 的辐射都有贡献，每个点增加的辐射到达 p 点后被衰减的量由该点到 p 点的光线透射率(Tr(p'-&gt;p))确定。<br />
</p>

<p>
场景中包含反射或发射表面的情况更通用一些，此时射线不必是无限长度的，而且射线碰到的第一个表面会影响其辐射，我们需要将从表面离开的辐射添加进来，并且将沿着射线超过交点后贡献的辐射去掉。<br />
<img src="./PhysicallyBasedRendering/2020_11_09_integral_et_03.jpg" alt="2020_11_09_integral_et_03.jpg" /><br />
</p>

<p>
上面微分方程求解请参考如下链接：<br />
</p>
<ul class="org-ul">
<li>体渲染数学原理 <a href="https://zhuanlan.zhihu.com/p/56710440">https://zhuanlan.zhihu.com/p/56710440</a><br /></li>
</ul>
</div>
<div id="outline-container-org11c8fe0" class="outline-6">
<h6 id="org11c8fe0"><span class="todo TODO">TODO</span> Generalized Path Space</h6>
</div>
</div>
<div id="outline-container-orgdf3cbf4" class="outline-5">
<h5 id="orgdf3cbf4">Sampling Volume Scattering</h5>
<div class="outline-text-5" id="text-orgdf3cbf4">
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#20989;&#25968;&#30340;&#30446;&#26631;&#26159;&#65292;&#23545;&#31215;&#20998;&#24418;&#24335;&#30340; equation of transfer&#36827;&#34892;&#37319;&#26679;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ray &#19990;&#30028;&#31354;&#38388;&#30340;&#23556;&#32447;</span>
  <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">Medium</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;<span style="color: #7590db;">ray</span>, <span style="color: #ce537a; font-weight: bold;">Sampler</span> &amp;<span style="color: #7590db;">sampler</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">MediumInteraction</span> *<span style="color: #7590db;">mi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>
<p>
Medium::Sample 和前面遇到的 BSDF::Sample_f()有不同的语义。Medium::Sample 不会给调用者提供关于函数值额外的信息，也不会提供采样处的概率密度 PDF。通常这些信息是不需要的，当可以计算这些量的比值时，有些介质模型(特别是非均匀介质)允许更高效的采样机制。<br />
</p>

<p>
下图为使用蒙特卡洛估计量求解 Equation of Transfer 中部分系数的公式：<br />
<img src="./PhysicallyBasedRendering/2020_11_09_integral_et_sample.jpg" alt="2020_11_09_integral_et_sample.jpg" /><br />
</p>
</div>

<div id="outline-container-org8f2d1a6" class="outline-6">
<h6 id="org8f2d1a6">Homogeneous Medium</h6>
<div class="outline-text-6" id="text-org8f2d1a6">
<p>
HomogeneousMedium::Sample 方法的实现非常直接，唯一复杂的地方是衰减系数对于不同波长来说是变化的。<br />
</p>


<div id="org00cfb23" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_11_09_p_surf_sample.jpg" alt="2020_11_09_p_surf_sample.jpg" /><br />
</p>
</div>

<p>
上面最后一个公式推导如下：<br />
<img src="./PhysicallyBasedRendering/2020_11_10_p_surf_sample_01.jpg" alt="2020_11_10_p_surf_sample_01.jpg" /><br />
</p>

<p>
生成介质交互来代替表面交互的概率刚好等于 1 减去选中波长光波的光线透射率。因此，给定光学上比较薄的介质(或者比较短的射线边界)，更可能使用表面交互，而对于光学上比较厚的介质(或者比较长的射线边界)，则更可能对介质交互进行采样。<br />
</p>

<ul class="org-ul">
<li>指数随机变量 <a href="../Theory/MathTheory_Probability.html#orgccc8cad">指数随机变量</a><br /></li>
<li>An Intuitive Guide To Exponential Functions &amp; e <a href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/">https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb96ae40" class="outline-6">
<h6 id="orgb96ae40">Heterogeneous Medium</h6>
<div class="outline-text-6" id="text-orgb96ae40">
<p>
当中间介质空间上的变化可以被分解为多个均匀的区域（例如：一块一块的常量体素），一种称为 regular tracking 的技术可以将均匀介质相关的技术应用于各个独立的体素。该方式的缺点是，当有很多体素时消耗比较大。<br />
其他的技术则建立在直接泛化均匀介质采样概率密度函数公式上，这些技术通过空间可变的衰减系数执行来泛化。如下面公式：<br />
<img src="./PhysicallyBasedRendering/2020_11_10_p_surf_sample_02.jpg" alt="2020_11_10_p_surf_sample_02.jpg" /><br />
最常用的对上面方程执行重要性采样的方法为 ray marching。其将整个介质范围分成多个子范围，通过数值近似每个子范围内的积分，然后将离散的结果合并。这种方式会引入系统性统计偏差，即使每个像素使用了无数个样本点，该方式也无法得到正确结果，而且该方法会产生引人注意的可见的 artifacts。<br />
</p>

<p>
delta tracking 是一种无偏差方式。该方法原本是开发出来用于模拟原子反应中的中子体积散射的。当σt 为单色(monochromatic)时，该方式非常容易实现。需要注意的是，散射σs 和吸收σa 系数依然允许随光波长变化，只需要σt=σs+σa 是均匀的。<br />
delta tracking 可以被解释为，使用额外的虚拟粒子填充介质，直到介质中所有地方的衰减系数都相同。此时就可以利用均匀介质的采样技术了，当和介质粒子的交互发生时，需要判断涉及的粒子是真实的还是虚拟的，如果是虚拟的，则该交互会被忽略。而可以通过概率来随机确定是否为虚拟粒子，其概率为虚拟粒子占总粒子数的比例。<br />
下图为 Regular Tracking、 Ray Marching 和 Delta tracking 原理的对比:<br />
<img src="./PhysicallyBasedRendering/2020_11_10_p_surf_sample_03.jpg" alt="2020_11_10_p_surf_sample_03.jpg" /><br />
</p>

<p>
下图为 delta tracking 实现原理：<br />
<img src="./PhysicallyBasedRendering/2020_11_10_p_surf_sample_04.jpg" alt="2020_11_10_p_surf_sample_04.jpg" /><br />
上图中迭代终止的条件有两个：<br />
</p>
<ol class="org-ol">
<li>ti &gt; tmax，表示我们已经离开介质，而且没有产生任何和介质的交互，因此，Sample()方法不会对中间介质进行采样。<br /></li>
<li>在每次迭代中，会以σt(ti)/σt,max 的概率结束，σt(ti)/σt,max 值为此次迭代时，局部的真实粒子所占比例。<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">GridDensityMedium</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Ray</span> &amp;<span style="color: #7590db;">rWorld</span>, <span style="color: #ce537a; font-weight: bold;">Sampler</span> &amp;<span style="color: #7590db;">sampler</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">MediumInteraction</span> *<span style="color: #7590db;">mi</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
      <span style="color: #ce537a; font-weight: bold;">Ray</span> <span style="color: #7590db;">ray</span> = WorldToMedium(Ray(rWorld.o, Normalize(rWorld.d), rWorld.tMax * rWorld.d.Length()));
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute $[\tmin, \tmax]$ interval of _ray_'s overlap with medium bounds</span>
      <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Bounds3f</span> <span style="color: #7590db;">b</span>(Point3f(0, 0, 0), Point3f(1, 1, 1));
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">tMin</span>, <span style="color: #7590db;">tMax</span>;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>b.IntersectP(ray, &amp;tMin, &amp;tMax)) <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(1.f);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Run delta-tracking iterations to sample a medium interaction</span>
      <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">t</span> = tMin;
      <span style="color: #4f97d7; font-weight: bold;">while</span> (<span style="color: #a45bad;">true</span>) {
          t -= <span style="color: #a45bad;">std</span>::log(1 - sampler.Get1D()) * invMaxDensity / sigma_t;
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32456;&#27490;&#24490;&#29615;&#30340;&#31532;&#19968;&#31181;&#24773;&#20917;</span>
          <span style="color: #4f97d7; font-weight: bold;">if</span> (t &gt;= tMax) <span style="color: #4f97d7; font-weight: bold;">break</span>;
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32456;&#27490;&#24490;&#29615;&#30340;&#31532;&#20108;&#31181;&#24773;&#20917;</span>
          <span style="color: #4f97d7; font-weight: bold;">if</span> (Density(ray(t)) * invMaxDensity &gt; sampler.Get1D())
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Populate _mi_ with medium interaction information and return</span>
              <span style="color: #ce537a; font-weight: bold;">PhaseFunction</span> *<span style="color: #7590db;">phase</span> = ARENA_ALLOC(arena, HenyeyGreenstein)(g);
              *mi = MediumInteraction(rWorld(t), -rWorld.d, rWorld.time, <span style="color: #4f97d7; font-weight: bold;">this</span>,
                                      phase);
              <span style="color: #4f97d7; font-weight: bold;">return</span> sigma_s / sigma_t;
          }
      }
      <span style="color: #4f97d7; font-weight: bold;">return</span> Spectrum(1.f);
  }

</pre>
</div>
</div>
</div>
<div id="outline-container-org4b3e633" class="outline-6">
<h6 id="org4b3e633">Sampling Phase Functions</h6>
<div class="outline-text-6" id="text-org4b3e633">
<p>
对 Phase Function 进行采样主要有以下两种应用：<br />
</p>
<ol class="org-ol">
<li>应用 Multi Importance Sampling 来计算中间介质中的直接光照<br /></li>
<li>为中间介质中间接光照样本采样被散射方向<br /></li>
</ol>


<div id="org60c6fb3" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_11_10_phase_func_sample.jpg" alt="2020_11_10_phase_func_sample.jpg" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#28385;&#36275;&#19978;&#36848;&#24212;&#29992;&#65292;Sample_p&#23454;&#29616;&#20102;&#32473;&#23450;&#29305;&#23450;&#20986;&#23556;&#26041;&#21521;wo&#21644;[0,1]^2&#31354;&#38388;&#20013;&#30340;&#26679;&#26412;&#20540;u&#65292;&#37319;&#26679;&#24471;&#21040;&#19968;&#20010;&#20837;&#23556;&#26041;&#21521;wi</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306;&#21644;BxDF&#30340;&#37319;&#26679;&#26041;&#27861;&#19981;&#21516;&#65292;Sample_p&#19981;&#20250;&#36820;&#22238;&#30456;&#20989;&#25968;&#20540;&#21644;&#20854;&#23545;&#24212;&#30340;PDF&#12290;</span>
  <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #a45bad;">PhaseFunction</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample_p</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wo</span>, <span style="color: #ce537a; font-weight: bold;">Vector3f</span> *<span style="color: #7590db;">wi</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;<span style="color: #7590db;">u</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>

<ul class="org-ul">
<li>紫外波段多分散系气溶胶散射相函数随机抽样方法研究 <a href="http://wulixb.iphy.ac.cn/article/doi/10.7498/aps.59.1749">http://wulixb.iphy.ac.cn/article/doi/10.7498/aps.59.1749</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5ee795a" class="outline-5">
<h5 id="org5ee795a">Volumetric Light Transport</h5>
<div class="outline-text-5" id="text-org5ee795a">
<p>
基于前面的采样构建模块，我们可以实现各种在中间介质中的光照传输算法。我们可以实现 EstimateDirect 函数中和中间介质相关的处理逻辑了。<br />
从光照采样之后，如果产生了中间介质的散射交互，就需要为出射方向和入射方向计算相函数的值，以及该值对应的 PDF（用于对该方向进行 Multiple Importance Sampling）。因为我们假设相函数是完美采样，其值和 PDF 相同。<br />
</p>
</div>
<div id="outline-container-org9733912" class="outline-6">
<h6 id="org9733912">Path Tracing</h6>
<div class="outline-text-6" id="text-org9733912">
<p>
VolPathIntegrator 是 SamplerIntegrator 的子类，其会考虑中间介质中的散射和衰减，以及表面的散射。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">VolPathIntegrator</span>::<span style="color: #bc6ec5; font-weight: bold;">Li</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">RayDifferential</span> &amp;<span style="color: #7590db;">r</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Scene</span> &amp;<span style="color: #7590db;">scene</span>, <span style="color: #ce537a; font-weight: bold;">Sampler</span> &amp;<span style="color: #7590db;">sampler</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">depth</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
  {
    <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #7590db;">L</span>(0.f), <span style="color: #7590db;">beta</span>(1.f);
    <span style="color: #ce537a; font-weight: bold;">RayDifferential</span> <span style="color: #7590db;">ray</span>(r);
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">specularBounce</span> = <span style="color: #a45bad;">false</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">bounces</span> = 0; ; ++bounces) 
    {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Intersect ray with scene and store intersection in isect</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Sample the participating medium, if present</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Handle an interaction with a medium or a surface</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Possibly terminate the path with Russian roulette</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> L;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgec3b9e7" class="outline-5">
<h5 id="orgec3b9e7">Sampling Subsurface Reflection Function</h5>
<div class="outline-text-5" id="text-orgec3b9e7">
<p>
VolPathIntegrator 可用于求解 BSSRDF：给定表面上的一对点和一对方向，该积分器可用于计算从 wi 方向到达 pi 点的入射光在 po 点的 wo 方向上出射的部分。除了标准的路径追踪或双向路径追踪技术，还有很多其他光照传输算法技术适用于求解 BSSRDF。<br />
很多透明物体具有很高反射率(albedo)的特点，使用经典的方式无法有效处理。例如：脱脂的牛奶的 albedo 为 0.9987。在介质中的每次交互中，几乎所有的光都被散射，而基本没有光被吸收，光在该介质中可以行进很远。数百甚至数千次的散射交互需要被考虑，用于计算出精确的结果。例如：在高 albedo 的牛奶中，经过 100 次散射交互后，路径中依然有 87.5%的入射光，而经过 500 次散射交互后，还有 51%，经过 1000 次散射交互，还有 26%。<br />
BSSRDF 类的实现表达了这类材质中聚集的散射行为，其可以高效地渲染这种效果。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">BSSRDF</span>::<span style="color: #bc6ec5; font-weight: bold;">S</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> &amp;<span style="color: #7590db;">pi</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Vector3f</span> &amp;<span style="color: #7590db;">wi</span>) = 0;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sample_S &#30830;&#23450;&#20102;&#22312;&#20869;&#37096;&#25955;&#23556;&#21518;&#20809;&#32447;&#37325;&#26032;&#20986;&#29616;&#30340;&#34920;&#38754;&#20301;&#32622;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">u1 &#20026;1D&#26679;&#26412;&#65292;&#20854;&#29992;&#20110;&#31163;&#25955;&#30340;&#37319;&#26679;&#20915;&#31574;(&#20363;&#22914;&#65306;&#36873;&#25321;&#29305;&#23450;&#30340;&#20809;&#35889;&#36890;&#36947;)</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">u2 &#20026; 2D&#26679;&#26412;&#65292;&#20854;&#29992;&#20110;&#26144;&#23556;&#21040;&#34920;&#38754;&#30340;&#20132;&#28857;</span>
  <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Spectrum</span> <span style="color: #a45bad;">BSSRDF</span>::<span style="color: #bc6ec5; font-weight: bold;">Sample_S</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Scene</span> &amp;<span style="color: #7590db;">scene</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> <span style="color: #7590db;">u1</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point2f</span> &amp;<span style="color: #7590db;">u2</span>, <span style="color: #ce537a; font-weight: bold;">MemoryArena</span> &amp;<span style="color: #7590db;">arena</span>, <span style="color: #ce537a; font-weight: bold;">SurfaceInteraction</span> *<span style="color: #7590db;">si</span>, <span style="color: #ce537a; font-weight: bold;">Float</span> *<span style="color: #7590db;">pdf</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> = 0;
</pre>
</div>

<p>
<a href="#org4b8fda9">The BSSRDF</a><br />
</p>
</div>

<div id="outline-container-org001c14c" class="outline-6">
<h6 id="org001c14c"><span class="todo TODO">TODO</span> Sampling The SeparableBSSRDF</h6>
<div class="outline-text-6" id="text-org001c14c">
<p>
参考前面章节内容了解 S(po, ωo, pi , ωi)被分离开的细节。 <a href="#org90b1614">Separable BSSRDFS公式描述</a> <br />
</p>

<p>
如果我们假设 BSSRDF 只采样透射穿过表面边界的射线，射线按照(1− Fr(cos θo))概率传播，这样就不需要对 1− Fr(cos θo))部分做任何事情了。<br />
为了采样 Sp，我们需要一种方法，可以在出射位置的附近利用表面的参数化将 2D 分布函数映射到该表面上。概念上来讲，可以通过测地线来获得这种参数化，但是发现和求解会很不容易，并且需要为每种支持的形状做很多工作。我们使用更简单的一种方式，这种方式使用射线追踪将 radial profile Sr 映射到场景的几何体上。下图展示了其基本的理念：<br />
<img src="./PhysicallyBasedRendering/2020_11_11_sample_sp.jpg" alt="2020_11_11_sample_sp.jpg" /><br />
</p>

<p>
po 和其对应的法线 no 定义了一个平面，用于近似几何体表面。使用 2D 极坐标，我们首先采样一个方位角φ和一个半径值 r，然后将其映射到几何体表面得到点 pi。SeparableBSSRDF 只支持径向对称的 profile 函数，强制φ从均匀分布[0, 2π)中取样，并且 r 是按照径向 profile function Sr 分布。<br />
对于上面这种基础的方式，此处依然有一些困难：<br />
</p>
<ol class="org-ol">
<li>radial profile Sr 对于不同的波长可能是不同的，对于不同的光谱通道，平均自由程可以有数量级的不同。<br /></li>
<li>当使用平面近似的表面几何体非常不精确并且 no·ni≈ 0 时，探针射线将会在掠射角处碰到表面，这使得 pi 对应的 S(po, ωo, pi , ·)拥有相对较高的值却可能被以很低的概率采样。这会导致很高的方差。<br /></li>
<li>探针射线可能会和表面多个地方相交。而所有这些交点可能都对反射辐射有贡献。<br /></li>
</ol>

<p>
我们为每种波长的光使用不同的采样技术来处理光谱波长的变化，并且每种技术使用不同的投影轴重复 3 次，投影轴由基础的向量给出，这样就得到了一个总数为 3*Spectrum::nSamples 的采样技术。这保证了 S 取不可忽略值的每个点都是拥有可靠概率的交互点。这个组合起来的技术是在 SeparableBSSRDF::Sample_Sp()中实现的。<br />
</p>

<p>
我们开始选择一个投影轴。注意：如果表面接近平面，沿着法线 SeparableBSSRDF::ns 很明显是最好的采样策略，沿着其他方向的探针射线很可能会和表面没有交点。因此我们分配了一大部分(50%)采样预算给垂直的射线。另外的一半平分给 SeparableBSSRDF::ss 和 SeparableBSSRDF::ts。<br />
</p>

<p>
因为 profile 减弱的很快，因此我们不需要考虑离 po 很远的点 pi。为了减低射线追踪的计算消耗，我们将探针射线截取到 \(r_{max}\) 。SeparableBSSRDF::Sample_Sr() 函数可用于确定 rmax，SeparableBSSRDF::Sample_Sr()方法将一个样本值 x 映射为一个球的半径，该球包含了 x 的散射能量(例如：SeparableBSSRDF::Sample_Sr(ch, 0.999f)表示计算包含了 0.999 光谱 ch 通道散射能量的球的半径)。<br />
</p>

<p>
给定 r 和 \(r_{max}\) ，探针射线和半径为 \(r_{max}\) 的球相交的长度 l 可以通过下面公式计算：<br />
<img src="./PhysicallyBasedRendering/2020_11_17_sample_sp_01.jpg" alt="2020_11_17_sample_sp_01.jpg" /><br />
</p>

<p>
实践上，探针射线和表面可能由多个交点。使用 IntersectionChain 链表来依次存储所有交点。<br />
<img src="./PhysicallyBasedRendering/2020_11_17_sample_sp_02.jpg" alt="2020_11_17_sample_sp_02.jpg" /><br />
</p>

<p>
Sample_Sp()只会返回单个位置 pi。因此需要使用均匀采样，从列表中选择一个交点返回。<br />
最后，SeparableBSSRDF::Pdf_Sp()用于计算组合的 PDF，其需要考虑用到的所有采样策略。<br />
</p>
</div>
</div>
<div id="outline-container-org9ec0060" class="outline-6">
<h6 id="org9ec0060"><span class="todo TODO">TODO</span> Sampling The TabulatedBSSRDF</h6>
</div>
<div id="outline-container-org244d594" class="outline-6">
<h6 id="org244d594"><span class="todo TODO">TODO</span> Subsurface Scattering In The Path Tracer</h6>
<div class="outline-text-6" id="text-org244d594">
<p>
散射渲染方程可以参考前面章节内容： <a href="#orgcd8f87e">BSSRDF 积分形式 散射渲染方程</a><br />
</p>

<p>
下图为散射渲染方程的蒙特卡洛积分公式：<br />
<img src="./PhysicallyBasedRendering/2020_11_11_sample_bssrdf_monte_carlo_estimator.jpg" alt="2020_11_11_sample_bssrdf_monte_carlo_estimator.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org39ccd31" class="outline-5">
<h5 id="org39ccd31">Subsurface Scattering Using The Diffusion Equation</h5>
<div class="outline-text-5" id="text-org39ccd31">
<p>
Photon beam diffusion 做了很多重要的假设和近似：<br />
</p>
<ol class="org-ol">
<li>光在透明介质中的分布是使用 diffusion approximation 来建模的，diffusion approximation 描述了照明在高散射中间介质中的均衡分布。<br /></li>
<li>介质是均匀的，并且隐含假设介质是半无限的（介质在一个无限延伸的平面下，介质是半无限延伸的）<br /></li>
<li>photo beam diffusion 建立在 separable BSSRDF 近似公式（<a href="#org90b1614">Separable BSSRDFS 近似公式</a>）基础上。<br /></li>
</ol>
<p>
当这些假设成立时，使用 Photon beam diffusion 计算的结果和使用 the equation of transfer(<a href="#org8f971c2">The Equation of Transfer</a>) 实地模拟得到的结果相似。<br />
当然，当 profile 被应用于任意的几何形状或材质属性随空间变化的几何体时，很多上面的假设都是不成立的。在图形学中，diffusion-type 方法的魅力在于，其会以优雅的方式退化，即使一些或所有的基础假设都被违反，其依然可以得到视觉上合理的结果。<br />
</p>
<ul class="org-ul">
<li>光扩散方程 <a href="https://baike.baidu.com/item/%E5%85%89%E6%89%A9%E6%95%A3%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E5%85%89%E6%89%A9%E6%95%A3%E6%96%B9%E7%A8%8B</a><br /></li>
<li>基于物理着色（四）- 次表面散射 <a href="https://zhuanlan.zhihu.com/p/21247702">https://zhuanlan.zhihu.com/p/21247702</a><br /></li>
</ul>
</div>
<div id="outline-container-org34bd58e" class="outline-6">
<h6 id="org34bd58e">Principle Of Similarity</h6>
<div class="outline-text-6" id="text-org34bd58e">
<p>
相似性原理是指对于高反照率的各项异性的散射介质，可以使用各项同性的相函数，以及适当的可修改的散射、衰减系数来模拟。基于可修改的系数计算出的光照传输结果和基于原始系数和相位函数计算的结果相差不多，同时基于各项同性的散射假设可以简化计算。<br />
相似性原理基于下面的观察，即经过多次散射事件后，高反照率介质中光的分布在各个方向上变得越来越均匀，而与原始照明分布和相函数的各项异性无关。<br />
<img src="./PhysicallyBasedRendering/00_15_05_01_phase_func.jpg" alt="00_15_05_01_phase_func.jpg" /><br />
上面图片中的公式中，随着 n 的增大，相函数收敛于各项同性相函数 1/(4π)。<br />
运用相似性原理把相函数当作各项同性后，各个散射属性也需要对应做修改。reduced scattering coefficient 被定义为σs'=(1−g)σs，reduced attenuation coefficient 定义为 σt'=σa+σs'，reduced albedo 定义为ρ'=σs'/σt'。<br />
为了理解这些系数所运用的理念，可以考虑一个强烈向前散射的相函数，其 g-&gt;1。对于原始的相函数，在散射后光大部分依然沿着同一方向前进。在该实例中，reduced scattering coefficient σs'=(1−g)σs 比σs 要小很多，这意味着光在散射之前经过了很长的距离；介质当作比起原本要薄，用于近似光传播的远。考虑相反的情况，g-&gt;-1，在依次散射事件中，光会趋向于散射到入射方向相反的方向。但是，紧接着的下一次散射，又会调转方向；光线弹射回来又弹射出去，几乎没有前进。这种情况下，reduced scattering coefficient 比原始的散射系数大，表示有更大概率发生散射交互。也就是说，介质被当作比其原本要厚，用于近似光无法向前传播。下图展示了这两种情况：<br />
<img src="./PhysicallyBasedRendering/00_15_05_01_two_case_example.jpg" alt="00_15_05_01_two_case_example.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org2bf7000" class="outline-6">
<h6 id="org2bf7000"><span class="todo TODO">TODO</span> Diffusion Theory</h6>
<div class="outline-text-6" id="text-org2bf7000">
<p>
扩散理论的一个关键假设是，每次散射事件会有效模糊入射照明，当光传播进入介质比较远的地方，有角度的辐射分布的高频部分会消失；在致密并各项同性的散射介质中，甚至所有的方向性都会消失。<br />
<img src="./PhysicallyBasedRendering/00_15_05_02_diffusion_theory_01.jpg" alt="00_15_05_02_diffusion_theory_01.jpg" /><br />
</p>

<ul class="org-ul">
<li>什么是扩散？ <a href="https://zhuanlan.zhihu.com/p/215865933">https://zhuanlan.zhihu.com/p/215865933</a><br /></li>
<li>扩散系数 <a href="http://cn.comsol.com/multiphysics/diffusion-coefficient">http://cn.comsol.com/multiphysics/diffusion-coefficient</a><br /></li>
<li>扩散方程 <a href="http://cn.comsol.com/multiphysics/diffusion-equation">http://cn.comsol.com/multiphysics/diffusion-equation</a><br /></li>
<li>A Practical Model for Subsurface Light Transport <a href="http://graphics.ucsd.edu/~henrik/papers/bssrdf/bssrdf.pdf">http://graphics.ucsd.edu/~henrik/papers/bssrdf/bssrdf.pdf</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge470f0e" class="outline-6">
<h6 id="orge470f0e"><span class="todo TODO">TODO</span> Monopole Solution</h6>
</div>
<div id="outline-container-org5921f01" class="outline-6">
<h6 id="org5921f01"><span class="todo TODO">TODO</span> Non-Classical Diffusion</h6>
</div>
<div id="outline-container-org08e4e31" class="outline-6">
<h6 id="org08e4e31"><span class="todo TODO">TODO</span> Dipole Solution</h6>
</div>
<div id="outline-container-org87c57db" class="outline-6">
<h6 id="org87c57db"><span class="todo TODO">TODO</span> Beam Solution</h6>
</div>
<div id="outline-container-orgf012b4f" class="outline-6">
<h6 id="orgf012b4f"><span class="todo TODO">TODO</span> Single Scattering Term</h6>
</div>
<div id="outline-container-org18d5663" class="outline-6">
<h6 id="org18d5663"><span class="todo TODO">TODO</span> Filling The BSSRDFTable</h6>
</div>
<div id="outline-container-org5c60d23" class="outline-6">
<h6 id="org5c60d23"><span class="todo TODO">TODO</span> Setting Scattering Properties</h6>
</div>
</div>
</div>
<div id="outline-container-org9afc5c4" class="outline-4">
<h4 id="org9afc5c4">16 Light Transport III:Bidirectional Methods</h4>
<div class="outline-text-4" id="text-org9afc5c4">
</div>
<div id="outline-container-orgce1929d" class="outline-5">
<h5 id="orgce1929d">The Path-Space Measurement Equation</h5>
</div>
<div id="outline-container-org8d257fa" class="outline-5">
<h5 id="org8d257fa">Stochastic Progressive Photon Mapping</h5>
</div>
<div id="outline-container-orgfa1ac91" class="outline-5">
<h5 id="orgfa1ac91">Bidirectional Path Tracing</h5>
</div>
<div id="outline-container-orgcf2ec69" class="outline-5">
<h5 id="orgcf2ec69">Metropolis Light Transport</h5>
</div>
</div>
</div>
<div id="outline-container-org0c1bc56" class="outline-3">
<h3 id="org0c1bc56">17 Retrospective and the future</h3>
<div class="outline-text-3" id="text-org0c1bc56">
</div>
<div id="outline-container-org870bed9" class="outline-5">
<h5 id="org870bed9">Design Retrospective</h5>
</div>
<div id="outline-container-org3b954db" class="outline-5">
<h5 id="org3b954db">Alternative Hardware</h5>
</div>
<div id="outline-container-org408f169" class="outline-5">
<h5 id="org408f169">Conclusion</h5>
</div>
</div>
<div id="outline-container-org848cf46" class="outline-3">
<h3 id="org848cf46">参考资料</h3>
<div class="outline-text-3" id="text-org848cf46">
<ul class="org-ul">
<li>PBR Book Online <a href="http://www.pbr-book.org/3ed-2018/contents.html">http://www.pbr-book.org/3ed-2018/contents.html</a><br /></li>
<li>PBR 源代码 <a href="https://github.com/mmp/pbrt-v3">https://github.com/mmp/pbrt-v3</a><br /></li>
<li>Scenes for pbrt-v3 <a href="https://pbrt.org/scenes-v3.html">https://pbrt.org/scenes-v3.html</a><br /></li>
<li>导数计算 <a href="https://zs.symbolab.com">https://zs.symbolab.com</a><br /></li>
<li>WayOnPBRT <a href="https://zhuanlan.zhihu.com/wayonpbrt">https://zhuanlan.zhihu.com/wayonpbrt</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org476daa3" class="outline-2">
<h2 id="org476daa3">Lighting Model</h2>
<div class="outline-text-2" id="text-org476daa3">
</div>
<div id="outline-container-orgf4bfd13" class="outline-3">
<h3 id="orgf4bfd13">Lambert</h3>
<div class="outline-text-3" id="text-orgf4bfd13">
<p>
只考虑环境光和漫反射的光照模型。<br />
</p>
\begin{align}  
&diffuseFactor = objNormal \cdot lightDir \\
&color = objColor * (ambientColor + diffuseFactor \cdot lightColor)
\end{align}  
</div>
</div>
<div id="outline-container-orgbfc4cd2" class="outline-3">
<h3 id="orgbfc4cd2">Phong</h3>
<div class="outline-text-3" id="text-orgbfc4cd2">
<p>
考虑环境光，漫反射光，镜面反射光的光照模型。其中镜面反射按照视角和反射光夹角来计算。<br />
shininess 为反光度<br />
镜面高光不和物体颜色交互，它被直接反射，所以在最终计算颜色时，镜面高光颜色是和散色出来的颜色相加的。<br />
</p>
\begin{align}
&diffuseFactor = objNormal \cdot lightDir \\
&specularFactor = saturate(reflect(lightDir) \cdot viewDir, 0, 1) \\
&specularFactor = specularFactor^{shininess} \\
&color = objColor \cdot (ambientFactor + diffuseFactor) \cdot lightColor) + specularFactor \cdot lightColor 
\end{align}
</div>
<div id="outline-container-org749c733" class="outline-4">
<h4 id="org749c733">缺点</h4>
<div class="outline-text-4" id="text-org749c733">
<ol class="org-ol">
<li>当放射光方向和视角夹角大于 90 度时，specular 被设置为 0，当反光度比较小时，镜面半径会比较大，而 specular 被设置为 0 导致，镜面光照突然就消失了。<br />
当然该缺点可以通过将 specular+1 从而将 specular 的值限定在[0,2]的范围呢<br /></li>
<li>反射光方向计算复杂<br /></li>
</ol>
\begin{equation}
refectLightDir = 2 (lightDir \cdot objNormal) \cdot objNormal - lightDir
\end{equation}
<ol class="org-ol">
<li>没有考虑菲涅耳效应。反射量随视角和法线的夹角增大而增大。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc89892b" class="outline-3">
<h3 id="orgc89892b">BlinnPhong</h3>
<div class="outline-text-3" id="text-orgc89892b">
<p>
考虑环境光，漫反射光，镜面反射光的光照模型。反射光方向取视线和光照方向的中心线，镜面反射按照中心线和法线的夹角来计算。<br />
</p>
\begin{align}
&diffuseFactor = objNormal \cdot lightDir \\
&specularFactor = normalize(lightDir + viewDir) \cdot objNormal \\
&specularFactor = specularFactor^{shininess} \\
&color = (objColor \cdot (ambientFactor + diffuseFactor) \cdot lightColor) + specularFactor \cdot lightColor
\end{align}

<p>
<a href="http://gamedev.stackexchange.com/questions/82494/why-is-h-blinn-used-instead-of-r-phong-in-specular-shading">http://gamedev.stackexchange.com/questions/82494/why-is-h-blinn-used-instead-of-r-phong-in-specular-shading</a><br />
</p>
</div>
</div>
<div id="outline-container-orgedc1889" class="outline-3">
<h3 id="orgedc1889">PBR</h3>
<div class="outline-text-3" id="text-orgedc1889">
</div>
<div id="outline-container-org3244890" class="outline-4">
<h4 id="org3244890">Cook-Torrance 模型</h4>
<div class="outline-text-4" id="text-org3244890">
<p>
<a id="orgc86e256"></a><br />
</p>

<p>
下面是计算机图形学引入的 BRDF 模型，又叫做 Cook-Torrance 模型.<br />
</p>
\begin{equation}
f(l,v) = \frac{F(l,h)G(l,v)D(h)}{4cos\theta_i cos\theta_o} = \frac{F(l,h)G(l,v)D(h)}{4(n \cdot l)(n \cdot v)}
\end{equation}
<p>
F(l,h)为菲涅耳反射方程，用于计算 l 方向的入射光和在 h 法线处的反射量；<br />
G(l,v)为几何衰减因子，用于计算入射光线被遮挡(Shadowing)和反射光线被遮挡(Masking)的量；<br />
D(h)为法线分布函数，用于计算在 h 方向上法线的分布率；<br />
h 表示微观法线 l 和 v 之间的半矢量 half-vector,对 v 方向反射光有贡献的法线<br />
n 表示宏观法线<br />
l 表示入射光方向<br />
v 表示视觉方向<br />
\(\theta_i\) 表示入射光和法线的夹角<br />
\(\theta_o\) 表示视线和法线的夹角<br />
</p>

<p>
<img src="./PhysicallyBasedRendering/03reflectance_equation.jpg" alt="03reflectance_equation.jpg" /><br />
<img src="./PhysicallyBasedRendering/03brdf_derivation.jpg" alt="03brdf_derivation.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgd61831b" class="outline-4">
<h4 id="orgd61831b">OpenGL Implement BRDF</h4>
<div class="outline-text-4" id="text-orgd61831b">
<ul class="org-ul">
<li><a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a><br /></li>
<li><a href="https://learnopengl.com/PBR/Lighting">https://learnopengl.com/PBR/Lighting</a><br /></li>
<li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a><br /></li>
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4763f86" class="outline-4">
<h4 id="org4763f86">DisneyBRDF</h4>
<div class="outline-text-4" id="text-org4763f86">
</div>
<div id="outline-container-org01388d1" class="outline-5">
<h5 id="org01388d1">BRDF 图像切片</h5>
<div class="outline-text-5" id="text-org01388d1">

<div id="org0e0c48f" class="figure">
<p><img src="./PhysicallyBasedRendering/00brdf_slice.jpg" alt="00brdf_slice.jpg" /><br />
</p>
</div>

<p>
图片说明：<br />
</p>
<ul class="org-ul">
<li>法线向量垂直向上<br /></li>
<li>半角向量是灯光向量和视角向量的中间向量，h为半角向量<br /></li>
<li>l 为灯光方向，v为视角方向<br /></li>
<li>&theta;(d) 表示灯光方向和半角向量的夹角 或者 视角方向和半角向量的夹角<br /></li>
<li>&theta;(h) 表示半角向量和法线的夹角<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org94da2c4" class="outline-5">
<h5 id="org94da2c4">DisneyDiffuse</h5>
<div class="outline-text-5" id="text-org94da2c4">
<p>
下面文件展示了 \(y(x)=1 + (FD90 - 1) (1 - cos((π θ_{l}) / 180))⁵ (1 + (FD90 - 1) (1 - cos((π x) / 180))⁵)\)<br />
<a href="./PhysicallyBasedRendering/02disney_brdf_diffuse.ggb">./PhysicallyBasedRendering/02disney_brdf_diffuse.ggb</a><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Unity &#23454;&#29616;&#26041;&#24335;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.</span>
<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">DisneyDiffuse</span>(<span style="color: #ce537a; font-weight: bold;">half</span> NdotV, <span style="color: #ce537a; font-weight: bold;">half</span> NdotL, <span style="color: #ce537a; font-weight: bold;">half</span> LdotH, <span style="color: #ce537a; font-weight: bold;">half</span> perceptualRoughness)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;
    <span style="color: #2aa1ae; background-color: #292e34;">// Two schlick fresnel term</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> lightScatter   = (1 + (fd90 - 1) * Pow5(1 - NdotL));
    <span style="color: #ce537a; font-weight: bold;">half</span> viewScatter    = (1 + (fd90 - 1) * Pow5(1 - NdotV));

    <span style="color: #4f97d7; font-weight: bold;">return</span> lightScatter * viewScatter;
}

<span style="color: #2aa1ae; background-color: #292e34;">// [Burley 2012, "Physically-Based Shading at Disney"]</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">Diffuse_Burley_Disney</span>( <span style="color: #ce537a; font-weight: bold;">float3</span> DiffuseColor, <span style="color: #ce537a; font-weight: bold;">float</span> Roughness, <span style="color: #ce537a; font-weight: bold;">float</span> NoV, <span style="color: #ce537a; font-weight: bold;">float</span> NoL, <span style="color: #ce537a; font-weight: bold;">float</span> VoH )
{
    <span style="color: #ce537a; font-weight: bold;">float</span> FD90 = 0.5 + 2 * VoH * VoH * Roughness;
    <span style="color: #ce537a; font-weight: bold;">float</span> FdV = 1 + (FD90 - 1) * Pow5( 1 - NoV );
    <span style="color: #ce537a; font-weight: bold;">float</span> FdL = 1 + (FD90 - 1) * Pow5( 1 - NoL );
    <span style="color: #4f97d7; font-weight: bold;">return</span> DiffuseColor * ( (1 / PI) * FdV * FdL );
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org75b0bd4" class="outline-5">
<h5 id="org75b0bd4">DisneySpecular</h5>
<div class="outline-text-5" id="text-org75b0bd4">
</div>
<div id="outline-container-org5a6eba9" class="outline-6">
<h6 id="org5a6eba9">法线分布项 D</h6>
<div class="outline-text-6" id="text-org5a6eba9">
<p>
<a href="./PhysicallyBasedRendering/02disney_brdf_D.ggb">./PhysicallyBasedRendering/02disney_brdf_D.ggb</a><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Generalized-Trowbridge-Reitz distribution</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">D_GTR1</span>(<span style="color: #ce537a; font-weight: bold;">float</span> alpha, <span style="color: #ce537a; font-weight: bold;">float</span> dotNH)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> a2 = alpha * alpha;
    <span style="color: #ce537a; font-weight: bold;">float</span> cos2th = dotNH * dotNH;
    <span style="color: #ce537a; font-weight: bold;">float</span> den = (1.0 + (a2 - 1.0) * cos2th);

    <span style="color: #4f97d7; font-weight: bold;">return</span> (a2 - 1.0) / (PI * <span style="color: #4f97d7;">log</span>(a2) * den);
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">D_GTR2</span>(<span style="color: #ce537a; font-weight: bold;">float</span> alpha, <span style="color: #ce537a; font-weight: bold;">float</span> dotNH)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> a2 = alpha * alpha;
    <span style="color: #ce537a; font-weight: bold;">float</span> cos2th = dotNH * dotNH;
    <span style="color: #ce537a; font-weight: bold;">float</span> den = (1.0 + (a2 - 1.0) * cos2th);

    <span style="color: #4f97d7; font-weight: bold;">return</span> a2 / (PI * den * den);
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">D_GTR2_aniso</span>(<span style="color: #ce537a; font-weight: bold;">float</span> dotHX, <span style="color: #ce537a; font-weight: bold;">float</span> dotHY, <span style="color: #ce537a; font-weight: bold;">float</span> dotNH, <span style="color: #ce537a; font-weight: bold;">float</span> ax, <span style="color: #ce537a; font-weight: bold;">float</span> ay)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> deno = dotHX * dotHX / (ax * ax) + dotHY * dotHY / (ay * ay) + dotNH * dotNH;
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0 / (PI * ax * ay * deno * deno);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdecd7ac" class="outline-6">
<h6 id="orgdecd7ac">Fresnel 项 F</h6>
<div class="outline-text-6" id="text-orgdecd7ac">
<p>
F0 表示入射光方向在 normal 方向上时，所对应的反射率。该值由折射率决定。<br />
</p>


<div id="orgffc30e8" class="figure">
<p><img src="./PhysicallyBasedRendering/00brdf_f0_tbl.jpg" alt="00brdf_f0_tbl.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>常用折射率表 <a href="https://baike.baidu.com/item/%E5%B8%B8%E7%94%A8%E6%8A%98%E5%B0%84%E7%8E%87%E8%A1%A8">https://baike.baidu.com/item/%E5%B8%B8%E7%94%A8%E6%8A%98%E5%B0%84%E7%8E%87%E8%A1%A8</a><br /></li>
<li>数百种常见材质的折射率值 <a href="https://www.btbat.com/12032.html">https://www.btbat.com/12032.html</a><br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">F_Schlick</span>(<span style="color: #ce537a; font-weight: bold;">float</span> HdotV, <span style="color: #ce537a; font-weight: bold;">float3</span> F0)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> F0 + (1 - F0) * <span style="color: #4f97d7;">pow</span>(1 - HdotV , 5.0));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2595d34" class="outline-6">
<h6 id="org2595d34">几何项 G</h6>
<div class="outline-text-6" id="text-org2595d34">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Smith GGX G&#39033;&#65292;&#21508;&#39033;&#21516;&#24615;&#29256;&#26412;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">smithG_GGX</span>(<span style="color: #ce537a; font-weight: bold;">float</span> NdotV, <span style="color: #ce537a; font-weight: bold;">float</span> alphaG)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> a = alphaG * alphaG;
    <span style="color: #ce537a; font-weight: bold;">float</span> b = NdotV * NdotV;
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / (NdotV + <span style="color: #4f97d7;">sqrt</span>(a + b - a * b));
}

<span style="color: #2aa1ae; background-color: #292e34;">// Smith GGX G&#39033;&#65292;&#21508;&#39033;&#24322;&#24615;&#29256;&#26412;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Derived G function for GGX</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">smithG_GGX_aniso</span>(<span style="color: #ce537a; font-weight: bold;">float</span> dotVN, <span style="color: #ce537a; font-weight: bold;">float</span> dotVX, <span style="color: #ce537a; font-weight: bold;">float</span> dotVY, <span style="color: #ce537a; font-weight: bold;">float</span> ax, <span style="color: #ce537a; font-weight: bold;">float</span> ay)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0 / (dotVN + <span style="color: #4f97d7;">sqrt</span>(<span style="color: #4f97d7;">pow</span>(dotVX * ax, 2.0) + <span style="color: #4f97d7;">pow</span>(dotVY * ay, 2.0) + <span style="color: #4f97d7;">pow</span>(dotVN, 2.0)));
}


<span style="color: #2aa1ae; background-color: #292e34;">// GGX&#28165;&#28422;&#20960;&#20309;&#39033;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// G GGX function for clearcoat</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">G_GGX</span>(<span style="color: #ce537a; font-weight: bold;">float</span> dotVN, <span style="color: #ce537a; font-weight: bold;">float</span> alphag)
{
        <span style="color: #ce537a; font-weight: bold;">float</span> a = alphag * alphag;
        <span style="color: #ce537a; font-weight: bold;">float</span> b = dotVN * dotVN;
        <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0 / (dotVN + <span style="color: #4f97d7;">sqrt</span>(a + b - a * b));
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org269332c" class="outline-5">
<h5 id="org269332c">Q&amp;A</h5>
<div class="outline-text-5" id="text-org269332c">
</div>
<div id="outline-container-org00540a5" class="outline-6">
<h6 id="org00540a5">文章中 &phi;(d) 如何理解？</h6>
<div class="outline-text-6" id="text-org00540a5">
<p>
&phi;(d) 就是球面坐标系中 &phi;<br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB">https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org35140fd" class="outline-5">
<h5 id="org35140fd">参考文档</h5>
<div class="outline-text-5" id="text-org35140fd">
<p>
英文 <a href="https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf">https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf</a><br />
中文 <a href="https://blog.csdn.net/poem_qianmo/article/details/88936992">https://blog.csdn.net/poem_qianmo/article/details/88936992</a><br />
中文 <a href="https://gameinstitute.qq.com/community/detail/123891">https://gameinstitute.qq.com/community/detail/123891</a><br />
DisneyBRDF Tool <a href="https://github.com/wdas/brdf">https://github.com/wdas/brdf</a><br />
基于物理着色（三）- Disney 和 UE4 的实现 <a href="https://zhuanlan.zhihu.com/p/20122884">https://zhuanlan.zhihu.com/p/20122884</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf99d1f1" class="outline-4">
<h4 id="orgf99d1f1">UnityBRDF</h4>
<div class="outline-text-4" id="text-orgf99d1f1">
</div>
<div id="outline-container-orgbee4f6a" class="outline-5">
<h5 id="orgbee4f6a">BRDF1</h5>
<div class="outline-text-5" id="text-orgbee4f6a">

<div id="org44ac953" class="figure">
<p><img src="./PhysicallyBasedRendering/unity_brdf1_pbs.jpg" alt="unity_brdf1_pbs.jpg" /><br />
</p>
</div>

<p>
下图展示了 SmithJointGGXVisibility 的推导：<br />
<img src="./PhysicallyBasedRendering/smith-joint-ggx-visibility.jpg" alt="smith-joint-ggx-visibility.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)">https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)</a><br /></li>
</ul>
</div>
<div id="outline-container-org76c43ec" class="outline-6">
<h6 id="org76c43ec">DiffuseTerm</h6>
<div class="outline-text-6" id="text-org76c43ec">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.</span>
<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">DisneyDiffuse</span>(<span style="color: #ce537a; font-weight: bold;">half</span> NdotV, <span style="color: #ce537a; font-weight: bold;">half</span> NdotL, <span style="color: #ce537a; font-weight: bold;">half</span> LdotH, <span style="color: #ce537a; font-weight: bold;">half</span> perceptualRoughness)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;
    <span style="color: #2aa1ae; background-color: #292e34;">// Two schlick fresnel term</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> lightScatter   = (1 + (fd90 - 1) * Pow5(1 - NdotL));
    <span style="color: #ce537a; font-weight: bold;">half</span> viewScatter    = (1 + (fd90 - 1) * Pow5(1 - NdotV));

    <span style="color: #4f97d7; font-weight: bold;">return</span> lightScatter * viewScatter;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2c79d5f" class="outline-6">
<h6 id="org2c79d5f">Specular G|V(Visibility) D</h6>
<div class="outline-text-6" id="text-org2c79d5f">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// --- G|V---</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Ref: http://jcgt.org/published/0003/02/03/paper.pdf </span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float</span> SmithJointGGXVisibilityTerm (<span style="color: #ce537a; font-weight: bold;">float</span> NdotL, <span style="color: #ce537a; font-weight: bold;">float</span> NdotV, <span style="color: #ce537a; font-weight: bold;">float</span> roughness)
{
<span style="color: #bc6ec5;">#if</span> 0
    <span style="color: #2aa1ae; background-color: #292e34;">// Original formulation:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//  G           = 1 / (1 + lambda_v + lambda_l);</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Reorder code to be more optimal</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> a          = roughness;
    <span style="color: #ce537a; font-weight: bold;">half</span> a2         = a * a;

    <span style="color: #ce537a; font-weight: bold;">half</span> lambdaV    = NdotL * <span style="color: #4f97d7;">sqrt</span>((-NdotV * a2 + NdotV) * NdotV + a2);
    <span style="color: #ce537a; font-weight: bold;">half</span> lambdaL    = NdotV * <span style="color: #4f97d7;">sqrt</span>((-NdotL * a2 + NdotL) * NdotL + a2);

    <span style="color: #2aa1ae; background-color: #292e34;">// Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5f / (lambdaV + lambdaL + 1e-5f);  <span style="color: #2aa1ae; background-color: #292e34;">// This function is not intended to be running on Mobile,</span>
                                                <span style="color: #2aa1ae; background-color: #292e34;">// therefore epsilon is smaller than can be represented by half</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> a = roughness;
    <span style="color: #ce537a; font-weight: bold;">float</span> lambdaV = NdotL * (NdotV * (1 - a) + a);
    <span style="color: #ce537a; font-weight: bold;">float</span> lambdaL = NdotV * (NdotL * (1 - a) + a);

<span style="color: #bc6ec5;">#if</span> defined(SHADER_API_SWITCH)
    <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5f / (lambdaV + lambdaL + 1e-4f); <span style="color: #2aa1ae; background-color: #292e34;">// work-around against hlslcc rounding error</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5f / (lambdaV + lambdaL + 1e-5f);
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// --- D ---</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float</span> GGXTerm (<span style="color: #ce537a; font-weight: bold;">float</span> NdotH, <span style="color: #ce537a; font-weight: bold;">float</span> roughness)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> a2 = roughness * roughness;
    <span style="color: #ce537a; font-weight: bold;">float</span> d = (NdotH * a2 - NdotH) * NdotH + 1.0f; <span style="color: #2aa1ae; background-color: #292e34;">// 2 mad</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> UNITY_INV_PI * a2 / (d * d + 1e-7f); <span style="color: #2aa1ae; background-color: #292e34;">// This function is not intended to be running on Mobile,</span>
                                            <span style="color: #2aa1ae; background-color: #292e34;">// therefore epsilon is smaller than what can be represented by half</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org99fe7be" class="outline-6">
<h6 id="org99fe7be">Specular G|V(Visibility) D Legacy</h6>
<div class="outline-text-6" id="text-org99fe7be">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// --- G|V---</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Smith-Schlick derived for Beckmann</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> SmithBeckmannVisibilityTerm (<span style="color: #ce537a; font-weight: bold;">half</span> NdotL, <span style="color: #ce537a; font-weight: bold;">half</span> NdotV, <span style="color: #ce537a; font-weight: bold;">half</span> roughness)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> c = 0.797884560802865h; <span style="color: #2aa1ae; background-color: #292e34;">// c = sqrt(2 / Pi)</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> k = roughness * c;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SmithVisibilityTerm</span> (NdotL, NdotV, k) * 0.25f; <span style="color: #2aa1ae; background-color: #292e34;">// * 0.25 is the 1/4 of the visibility term</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// Generic Smith-Schlick visibility term</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> SmithVisibilityTerm (<span style="color: #ce537a; font-weight: bold;">half</span> NdotL, <span style="color: #ce537a; font-weight: bold;">half</span> NdotV, <span style="color: #ce537a; font-weight: bold;">half</span> k)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> gL = NdotL * (1-k) + k;
    <span style="color: #ce537a; font-weight: bold;">half</span> gV = NdotV * (1-k) + k;
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0 / (gL * gV + 1e-5f); <span style="color: #2aa1ae; background-color: #292e34;">// This function is not intended to be running on Mobile,</span>
                                    <span style="color: #2aa1ae; background-color: #292e34;">// therefore epsilon is smaller than can be represented by half</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// --- D ---</span>
<span style="color: #2aa1ae; background-color: #292e34;">// BlinnPhong normalized as normal distribution function (NDF)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// for use in micro-facet model: spec=D*G*F</span>
<span style="color: #2aa1ae; background-color: #292e34;">// eq. 19 in https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> NDFBlinnPhongNormalizedTerm (<span style="color: #ce537a; font-weight: bold;">half</span> NdotH, <span style="color: #ce537a; font-weight: bold;">half</span> n)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// norm = (n+2)/(2*pi)</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> normTerm = (n + 2.0) * (0.5/UNITY_PI);

    <span style="color: #ce537a; font-weight: bold;">half</span> specTerm = <span style="color: #4f97d7;">pow</span> (NdotH, n);
    <span style="color: #4f97d7; font-weight: bold;">return</span> specTerm * normTerm;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgedd75ca" class="outline-6">
<h6 id="orgedd75ca">Specular F</h6>
<div class="outline-text-6" id="text-orgedd75ca">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> FresnelTerm (<span style="color: #ce537a; font-weight: bold;">half3</span> F0, <span style="color: #ce537a; font-weight: bold;">half</span> cosA)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> t = Pow5 (1 - cosA);   <span style="color: #2aa1ae; background-color: #292e34;">// ala Schlick interpoliation</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> F0 + (1-F0) * t;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org40fe3d2" class="outline-6">
<h6 id="org40fe3d2">BRDF1</h6>
<div class="outline-text-6" id="text-org40fe3d2">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Main Physically Based BRDF</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Derived from Disney work and based on Torrance-Sparrow micro-facet model</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   BRDF = kD / pi + kS * (D * V * F) / 4</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   I = BRDF * NdotL</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * NDF (depending on UNITY_BRDF_GGX):</span>
<span style="color: #2aa1ae; background-color: #292e34;">//  a) Normalized BlinnPhong</span>
<span style="color: #2aa1ae; background-color: #292e34;">//  b) GGX</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * Smith for Visiblity term</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * Schlick approximation for Fresnel</span>
<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">BRDF1_Unity_PBS</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> diffColor, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity, <span style="color: #ce537a; font-weight: bold;">half</span> smoothness,
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir,
    UnityLight light, UnityIndirect gi)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);
    <span style="color: #ce537a; font-weight: bold;">float3</span> halfDir = Unity_SafeNormalize (<span style="color: #ce537a; font-weight: bold;">float3</span>(light.dir) + viewDir);

<span style="color: #2aa1ae; background-color: #292e34;">// NdotV should not be negative for visible pixels, but it can happen due to perspective projection and normal mapping</span>
<span style="color: #2aa1ae; background-color: #292e34;">// In this case normal should be modified to become valid (i.e facing camera) and not cause weird artifacts.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// but this operation adds few ALU and users may not want it. Alternative is to simply take the abs of NdotV (less correct but works too).</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Following define allow to control this. Set it to 0 if ALU is critical on your platform.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// This correction is interesting for GGX with SmithJoint visibility function because artifacts are more visible in this case due to highlight edge of rough surface</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Edit: Disable this code by default for now as it is not compatible with two sided lighting used in SpeedTree.</span>
<span style="color: #bc6ec5;">#define</span> UNITY_HANDLE_CORRECTLY_NEGATIVE_NDOTV 0

<span style="color: #bc6ec5;">#if</span> UNITY_HANDLE_CORRECTLY_NEGATIVE_NDOTV
    <span style="color: #2aa1ae; background-color: #292e34;">// The amount we shift the normal toward the view vector is defined by the dot product.</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> shiftAmount = <span style="color: #4f97d7;">dot</span>(normal, viewDir);
    normal = shiftAmount &lt; 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;
    <span style="color: #2aa1ae; background-color: #292e34;">// A re-normalization should be applied here but as the shift is small we don't do it to save ALU.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//normal = normalize(normal);</span>

    <span style="color: #ce537a; font-weight: bold;">float</span> nv = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, viewDir)); <span style="color: #2aa1ae; background-color: #292e34;">// TODO: this saturate should no be necessary here</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> nv = <span style="color: #4f97d7;">abs</span>(<span style="color: #4f97d7;">dot</span>(normal, viewDir));    <span style="color: #2aa1ae; background-color: #292e34;">// This abs allow to limit artifact</span>
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #ce537a; font-weight: bold;">float</span> nl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, light.dir));
    <span style="color: #ce537a; font-weight: bold;">float</span> nh = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, halfDir));

    <span style="color: #ce537a; font-weight: bold;">half</span> lv = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(light.dir, viewDir));
    <span style="color: #ce537a; font-weight: bold;">half</span> lh = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(light.dir, halfDir));

    <span style="color: #2aa1ae; background-color: #292e34;">// Diffuse term</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;

    <span style="color: #2aa1ae; background-color: #292e34;">// Specular term</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// BUT 1) that will make shader look significantly darker than Legacy ones</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// and 2) on engine side "Non-important" lights have to be divided by Pi too in cases when they are injected into ambient SH</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> roughness = PerceptualRoughnessToRoughness(perceptualRoughness);
<span style="color: #bc6ec5;">#if</span> UNITY_BRDF_GGX
    <span style="color: #2aa1ae; background-color: #292e34;">// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.</span>
    roughness = <span style="color: #4f97d7;">max</span>(roughness, 0.002);
    <span style="color: #ce537a; font-weight: bold;">float</span> V = SmithJointGGXVisibilityTerm (nl, nv, roughness);
    <span style="color: #ce537a; font-weight: bold;">float</span> D = GGXTerm (nh, roughness);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Legacy</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> V = SmithBeckmannVisibilityTerm (nl, nv, roughness);
    <span style="color: #ce537a; font-weight: bold;">half</span> D = NDFBlinnPhongNormalizedTerm (nh, PerceptualRoughnessToSpecPower(perceptualRoughness));
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #ce537a; font-weight: bold;">float</span> specularTerm = V*D * UNITY_PI; <span style="color: #2aa1ae; background-color: #292e34;">// Torrance-Sparrow model, Fresnel is applied later</span>

<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        specularTerm = <span style="color: #4f97d7;">sqrt</span>(<span style="color: #4f97d7;">max</span>(1e-4h, specularTerm));
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value</span>
    specularTerm = <span style="color: #4f97d7;">max</span>(0, specularTerm * nl);
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_SPECULARHIGHLIGHTS_OFF</span>)
    specularTerm = 0.0;
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL&gt;0) dH = 1/(roughness^2+1)</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> surfaceReduction;
<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        surfaceReduction = 1.0-0.28*roughness*perceptualRoughness;      <span style="color: #2aa1ae; background-color: #292e34;">// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]</span>
<span style="color: #bc6ec5;">#   else</span>
        surfaceReduction = 1.0 / (roughness*roughness + 1.0);           <span style="color: #2aa1ae; background-color: #292e34;">// fade \in [0.5;1]</span>
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// To provide true Lambert lighting, we need to be able to kill specular completely.</span>
    specularTerm *= <span style="color: #4f97d7;">any</span>(specColor) ? 1.0 : 0.0;

    <span style="color: #ce537a; font-weight: bold;">half</span> grazingTerm = <span style="color: #4f97d7;">saturate</span>(smoothness + (1-oneMinusReflectivity));
    <span style="color: #ce537a; font-weight: bold;">half3</span> color =   diffColor * (gi.diffuse + light.color * diffuseTerm)
                    + specularTerm * light.color * FresnelTerm (specColor, lh)
                    + surfaceReduction * gi.specular * FresnelLerp (specColor, grazingTerm, nv);

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">half4</span>(color, 1);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb428a38" class="outline-5">
<h5 id="orgb428a38">BRDF2</h5>
<div class="outline-text-5" id="text-orgb428a38">

<div id="org5c72ade" class="figure">
<p><img src="./PhysicallyBasedRendering/unity_brdf2_pbs.jpg" alt="unity_brdf2_pbs.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgf9c28dc" class="outline-6">
<h6 id="orgf9c28dc">BRDF2</h6>
<div class="outline-text-6" id="text-orgf9c28dc">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Based on Minimalist CookTorrance BRDF</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * NDF (depending on UNITY_BRDF_GGX):</span>
<span style="color: #2aa1ae; background-color: #292e34;">//  a) BlinnPhong</span>
<span style="color: #2aa1ae; background-color: #292e34;">//  b) [Modified] GGX</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * Modified Kelemen and Szirmay-&#8203;Kalos for Visibility term</span>
<span style="color: #2aa1ae; background-color: #292e34;">// * Fresnel approximated with 1/LdotH</span>
<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">BRDF2_Unity_PBS</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> diffColor, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity, <span style="color: #ce537a; font-weight: bold;">half</span> smoothness,
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir,
    UnityLight light, UnityIndirect gi)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> halfDir = Unity_SafeNormalize (<span style="color: #ce537a; font-weight: bold;">float3</span>(light.dir) + viewDir);

    <span style="color: #ce537a; font-weight: bold;">half</span> nl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, light.dir));
    <span style="color: #ce537a; font-weight: bold;">float</span> nh = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, halfDir));
    <span style="color: #ce537a; font-weight: bold;">half</span> nv = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal, viewDir));
    <span style="color: #ce537a; font-weight: bold;">float</span> lh = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(light.dir, halfDir));

    <span style="color: #2aa1ae; background-color: #292e34;">// Specular term</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);
    <span style="color: #ce537a; font-weight: bold;">half</span> roughness = PerceptualRoughnessToRoughness(perceptualRoughness);

<span style="color: #bc6ec5;">#if</span> UNITY_BRDF_GGX

    <span style="color: #2aa1ae; background-color: #292e34;">// GGX Distribution multiplied by combined approximation of Visibility and Fresnel</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// https://community.arm.com/events/1155</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> a = roughness;
    <span style="color: #ce537a; font-weight: bold;">float</span> a2 = a*a;

    <span style="color: #ce537a; font-weight: bold;">float</span> d = nh * nh * (a2 - 1.f) + 1.00001f;
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
    <span style="color: #2aa1ae; background-color: #292e34;">// Tighter approximation for Gamma only rendering mode!</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// DVF = sqrt(DVF);</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> specularTerm = a / (<span style="color: #4f97d7;">max</span>(0.32f, lh) * (1.5f + roughness) * d);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> specularTerm = a2 / (<span style="color: #4f97d7;">max</span>(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// on mobiles (where half actually means something) denominator have risk of overflow</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))</span>
<span style="color: #bc6ec5;">#if</span> defined (SHADER_API_MOBILE)
    specularTerm = specularTerm - 1e-4f;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#else</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Legacy</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);
    <span style="color: #2aa1ae; background-color: #292e34;">// Modified with approximate Visibility function that takes roughness into account</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn't take into account roughness</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// and produced extremely bright specular at grazing angles</span>

    <span style="color: #ce537a; font-weight: bold;">half</span> invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; <span style="color: #2aa1ae; background-color: #292e34;">// approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> invF = lh;

    <span style="color: #ce537a; font-weight: bold;">half</span> specularTerm = ((specularPower + 1) * <span style="color: #4f97d7;">pow</span> (nh, specularPower)) / (8 * invV * invF + 1e-4h);

<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
    specularTerm = <span style="color: #4f97d7;">sqrt</span>(<span style="color: #4f97d7;">max</span>(1e-4f, specularTerm));
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined (SHADER_API_MOBILE)
    specularTerm = <span style="color: #4f97d7;">clamp</span>(specularTerm, 0.0, 100.0); <span style="color: #2aa1ae; background-color: #292e34;">// Prevent FP16 overflow on mobiles</span>
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_SPECULARHIGHLIGHTS_OFF</span>)
    specularTerm = 0.0;
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL&gt;0) dH = 1/(realRoughness^2+1)</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)</span>
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
    <span style="color: #ce537a; font-weight: bold;">half</span> surfaceReduction = 0.28;
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> surfaceReduction = (0.6-0.08*perceptualRoughness);
<span style="color: #bc6ec5;">#endif</span>

    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;

    <span style="color: #ce537a; font-weight: bold;">half</span> grazingTerm = <span style="color: #4f97d7;">saturate</span>(smoothness + (1-oneMinusReflectivity));
    <span style="color: #ce537a; font-weight: bold;">half3</span> color =   (diffColor + specularTerm * specColor) * light.color * nl
                    + gi.diffuse * diffColor
                    + surfaceReduction * gi.specular * FresnelLerpFast (specColor, grazingTerm, nv);

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">half4</span>(color, 1);
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc219969" class="outline-4">
<h4 id="orgc219969">UE4BRDF</h4>
<div class="outline-text-4" id="text-orgc219969">

<div id="orga90b2e0" class="figure">
<p><img src="./PhysicallyBasedRendering/ue4_brdf1.jpg" alt="ue4_brdf1.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile">https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdf81b03" class="outline-4">
<h4 id="orgdf81b03">Image Based Lighting</h4>
<div class="outline-text-4" id="text-orgdf81b03">

<div id="orgc53e05e" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_11_24_image_based_lighting_01.jpg" alt="2020_11_24_image_based_lighting_01.jpg" /><br />
</p>
</div>

<p>
约去 F 项的依据：<br />
对于光滑情形， wh 接近 n ，所以 F 基本是定值，分子分母可约去<br />
对于非光滑情形，L 已经变得很粗略了，所以做这种近似也影响不大。<br />
</p>

<p>
约去 dot(wh, n)的依据：<br />
对于镜面反射的 brdf f(wi,wo)，只会在反射方向 R 的附近有值。在不同方向入射时（除掠射角），brdf 的波瓣变化不大，因此，f(wo,wi(n),n) ≈ f(R, wi(R), R)，即 wo = n = R<br />
</p>

<p>
diffuse 部分    ： 将 irradiance*1/pi 烘培到 Cubemap 中，Cubemap 采样 uv 对应于被渲染点的 normal 方向<br />
specular 部分 1 ： 将 irradiance 的第一部分烘培到 Cubemap 中，Cubemap 采样 uv 对应于 wi 即 reflect(-V,N)<br />
specular 部分 2 ： 将 irradiance 的第二部分烘培到 Texture2D 中，uv.x 对应 NoV, uv.y 对应 roughness<br />
</p>

<p>
计算 specular 第一部分时，需要知道 wo(即 V)，才能求出 wh(即 H)，但视线方向 V 在预计算时，还无法知道。因此，假设 Normal 方向为视角方向 V，对 GGX 进行重要性采样得到微表面法线方向 H，利用 V 和 H 得到 wi（即 L），这样就可以进行预计算了。<br />
解释一下 ImportanceSampleGGX(float2 Xi,float roughness), Xi 为均匀分布的随机变量 roughness 为粗糙度，该函数内利用了 pdf-&gt;cdf-&gt;特定分布的随机变量 的方法得到了特定分布的θ,φ表示的微表面法线。<br />
</p>

<p>
计算 specular 第二部分时，假设了 specular 反射为各项同性，假定 N 为(0,1,0)，则使用 NoV 可以构造一个合法的 V 为(NoV,sqrt(1-NoV*Nov),0)，对 GGX 进行重要性采样得到微表面法线 H，利用 V 和 H 得到 L。这样就可以进行预计算了。<br />
</p>

<ul class="org-ul">
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a><br /></li>
<li>基于物理的渲染：基于图像照明(Image-based Lighting) <a href="https://zhuanlan.zhihu.com/p/261005894?utm_source=ZHShareTargetIDMore">https://zhuanlan.zhihu.com/p/261005894?utm_source=ZHShareTargetIDMore</a><br /></li>
<li>深入理解 PBR/基于图像照明 (IBL) <a href="https://zhuanlan.zhihu.com/p/66518450">https://zhuanlan.zhihu.com/p/66518450</a><br /></li>
<li>蒙特卡洛积分 <a href="https://zhuanlan.zhihu.com/p/146144853">https://zhuanlan.zhihu.com/p/146144853</a>  ImportanceSampleGGX 的原理可以参考该文章<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3b0f065" class="outline-4">
<h4 id="org3b0f065">球谐函数</h4>
<div class="outline-text-4" id="text-org3b0f065">

<div id="orgf9043b6" class="figure">
<p><img src="./PhysicallyBasedRendering/sh_lighting_001.jpg" alt="sh_lighting_001.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>球谐光照与 PRT 学习笔记（一）：引入 <a href="https://zhuanlan.zhihu.com/p/49436452">https://zhuanlan.zhihu.com/p/49436452</a><br /></li>
<li>球谐光照与 PRT 学习笔记（二）：蒙特卡洛积分与球面上的均匀采样 <a href="https://zhuanlan.zhihu.com/p/49746076">https://zhuanlan.zhihu.com/p/49746076</a><br /></li>
<li>球谐光照与 PRT 学习笔记（三）：球谐函数 <a href="https://zhuanlan.zhihu.com/p/50208005">https://zhuanlan.zhihu.com/p/50208005</a><br /></li>
<li>球谐光照与 PRT 学习笔记（四）：球谐函数的性质与球谐旋转 <a href="https://zhuanlan.zhihu.com/p/50699527">https://zhuanlan.zhihu.com/p/50699527</a><br /></li>
<li><p>
球谐光照与 PRT 学习笔记（五）：预计算传输与着色 <a href="https://zhuanlan.zhihu.com/p/51179426">https://zhuanlan.zhihu.com/p/51179426</a><br />
</p>

<p>
球谐函数的推导可以参考下面文章以及《数学物理方法》中勒让德多项式和球谐函数章节<br />
</p></li>
<li>(一)从拉普拉斯方程到球谐函数 <a href="https://zhuanlan.zhihu.com/p/66989673">https://zhuanlan.zhihu.com/p/66989673</a><br /></li>
<li>(二)蒙特卡洛积分和光照投影 <a href="https://zhuanlan.zhihu.com/p/68522268">https://zhuanlan.zhihu.com/p/68522268</a><br /></li>
<li>(三)光源和光照计算 <a href="https://zhuanlan.zhihu.com/p/68913680">https://zhuanlan.zhihu.com/p/68913680</a><br /></li>

<li>拉普拉斯算子 <a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90">https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90</a><br /></li>
<li>拉普拉斯方程 <a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B</a><br /></li>
<li>调和函数 <a href="https://baike.baidu.com/item/%E8%B0%83%E5%92%8C%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E8%B0%83%E5%92%8C%E5%87%BD%E6%95%B0</a><br /></li>
<li>连带勒让德方程 1 <a href="https://baike.baidu.com/item/%E8%BF%9E%E5%B8%A6%E5%8B%92%E8%AE%A9%E5%BE%B7%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E8%BF%9E%E5%B8%A6%E5%8B%92%E8%AE%A9%E5%BE%B7%E6%96%B9%E7%A8%8B</a><br /></li>
<li>连带勒让德方程 2 <a href="https://mathworld.wolfram.com/AssociatedLegendreDifferentialEquation.html">https://mathworld.wolfram.com/AssociatedLegendreDifferentialEquation.html</a><br /></li>
<li>连带勒让德函数 <a href="https://baike.baidu.com/item/%E8%BF%9E%E5%B8%A6%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E8%BF%9E%E5%B8%A6%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%87%BD%E6%95%B0</a><br /></li>
<li>勒让德方程 1 <a href="https://baike.baidu.com/item/%E5%8B%92%E8%AE%A9%E5%BE%B7%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E5%8B%92%E8%AE%A9%E5%BE%B7%E6%96%B9%E7%A8%8B</a><br /></li>
<li>勒让德方程 2 <a href="https://mathworld.wolfram.com/LegendreDifferentialEquation.html">https://mathworld.wolfram.com/LegendreDifferentialEquation.html</a><br /></li>
<li>勒让德函数 <a href="https://en.wikipedia.org/wiki/Legendre_function">https://en.wikipedia.org/wiki/Legendre_function</a><br /></li>
<li>伴随勒让德多项式 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F">https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F</a><br /></li>
<li>正交多项式 <a href="https://baike.baidu.com/item/%E6%AD%A3%E4%BA%A4%E5%A4%9A%E9%A1%B9%E5%BC%8F">https://baike.baidu.com/item/%E6%AD%A3%E4%BA%A4%E5%A4%9A%E9%A1%B9%E5%BC%8F</a><br /></li>
<li>勒让德多项式 <a href="https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F">https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F</a><br /></li>
<li>数学物理方法-勒让德多项式 <a href="../theory/MethodsOfMathematicalPhysics.html#org5d991ac">勒让德多项式</a><br /></li>
</ul>

<p>
Zonal Spherical Harmonics 为球谐函数的特殊形式，<br />
</p>
<ul class="org-ul">
<li>Zonal Spherical Harmonics <a href="https://en.wikipedia.org/wiki/Zonal_spherical_harmonics">https://en.wikipedia.org/wiki/Zonal_spherical_harmonics</a><br /></li>
</ul>

<p>
下面链接包含了（复）球谐函数表 和 实球谐函数表：<br />
</p>
<ul class="org-ul">
<li>球諧函數表 <a href="https://en.wikipedia.org/wiki/Table_of_spherical_harmonics">https://en.wikipedia.org/wiki/Table_of_spherical_harmonics</a><br /></li>
<li>UnityCatLikeCoding SH <a href="./UnityCatLikeCoding.html#org1fe776f">Spherical Harmonics</a><br /></li>
</ul>

<p>
从虚球谐函数推导出实球谐函数的方法可以参考 同济大学高等数学第七章第七节 常系数齐次线性微分方程 以及下面链接中的内容：<br />
</p>
<ul class="org-ul">
<li><a href="https://math.stackexchange.com/questions/1095011/in-the-real-spherical-harmonics-where-does-the-sqrt2-factor-come-from">https://math.stackexchange.com/questions/1095011/in-the-real-spherical-harmonics-where-does-the-sqrt2-factor-come-from</a><br /></li>
</ul>

<div id="org6a31fb5" class="figure">
<p><img src="./PhysicallyBasedRendering/sh_lighting_002.jpg" alt="sh_lighting_002.jpg" /><br />
</p>
</div>

<p>
按照上面推导出来的实函数符号和 wikipedia 上不同，这是因为左手坐标系、右手坐标系的问题，可以参考下面链接的解释：<br />
</p>
<ul class="org-ul">
<li><a href="https://math.stackexchange.com/questions/1883310/real-spherical-harmonics-sign">https://math.stackexchange.com/questions/1883310/real-spherical-harmonics-sign</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2bcf539" class="outline-4">
<h4 id="org2bcf539">PBR Detail</h4>
<div class="outline-text-4" id="text-org2bcf539">
</div>
<div id="outline-container-org7f7c669" class="outline-5">
<h5 id="org7f7c669">参考文档</h5>
<div class="outline-text-5" id="text-org7f7c669">
</div>
<div id="outline-container-org5e8f96d" class="outline-6">
<h6 id="org5e8f96d">How Is The NDF Really Defined?</h6>
<div class="outline-text-6" id="text-org5e8f96d">
<ul class="org-ul">
<li>How Is The NDF Really Defined? en <a href="http://www.reedbeta.com/blog/hows-the-ndf-really-defined/">http://www.reedbeta.com/blog/hows-the-ndf-really-defined/</a><br /></li>
<li>How Is The NDF Really Defined? cn <a href="https://www.jianshu.com/p/197bed54a099">https://www.jianshu.com/p/197bed54a099</a><br /></li>
<li><a href="http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb52aeaa" class="outline-6">
<h6 id="orgb52aeaa">Sampling microfacet BRDF</h6>
<div class="outline-text-6" id="text-orgb52aeaa">
<ul class="org-ul">
<li>Sampling microfacet BRDF <a href="https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/">https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org899e240" class="outline-6">
<h6 id="org899e240">Misc</h6>
<div class="outline-text-6" id="text-org899e240">
<p>
基于物理的渲染（PBR）白皮书（一）开篇：PBR 核心知识体系总结与概览     <a href="https://zhuanlan.zhihu.com/p/53086060">https://zhuanlan.zhihu.com/p/53086060</a><br />
基于物理的渲染（PBR）白皮书（二）PBR 核心理论与渲染光学原理总结       <a href="https://zhuanlan.zhihu.com/p/56967462">https://zhuanlan.zhihu.com/p/56967462</a><br />
基于物理的渲染（PBR）白皮书（三）迪士尼原则的 BRDF 与 BSDF 相关总结   <a href="https://zhuanlan.zhihu.com/p/60977923">https://zhuanlan.zhihu.com/p/60977923</a><br />
基于物理的渲染（PBR）白皮书（四）法线分布函数相关总结                 <a href="https://zhuanlan.zhihu.com/p/69380665">https://zhuanlan.zhihu.com/p/69380665</a><br />
基于物理的渲染（PBR）白皮书（五）几何函数相关总结                    <a href="https://zhuanlan.zhihu.com/p/81708753">https://zhuanlan.zhihu.com/p/81708753</a><br />
深入 BRDF 和 PBR 大作战！：微面理论 <a href="https://zhuanlan.zhihu.com/p/62904454">https://zhuanlan.zhihu.com/p/62904454</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd52bc24" class="outline-4">
<h4 id="orgd52bc24">参考资料</h4>
<div class="outline-text-4" id="text-orgd52bc24">
<ul class="org-ul">
<li>基于物理着色：BRDF <a href="https://zhuanlan.zhihu.com/rgba8">https://zhuanlan.zhihu.com/rgba8</a><br /></li>
<li>基于物理着色<br />
<ul class="org-ul">
<li>几种反射模型 <a href="https://zhuanlan.zhihu.com/p/20091064">https://zhuanlan.zhihu.com/p/20091064</a><br /></li>
<li>Microface 材质和多层材质 <a href="https://zhuanlan.zhihu.com/p/20119162">https://zhuanlan.zhihu.com/p/20119162</a><br /></li>
<li>Disney 和 UE4 的实现 <a href="https://zhuanlan.zhihu.com/p/20122884">https://zhuanlan.zhihu.com/p/20122884</a><br /></li>
<li>次表面散射 <a href="https://zhuanlan.zhihu.com/p/21247702">https://zhuanlan.zhihu.com/p/21247702</a><br /></li>
</ul></li>
<li>unity 材质数值图表 <a href="https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html">https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html</a><br /></li>
<li>PBR Book Online <a href="http://www.pbr-book.org/3ed-2018/contents.html">http://www.pbr-book.org/3ed-2018/contents.html</a><br /></li>
<li>为什么 PBR 中 Lambert 光照要除 PI? <a href="https://zhuanlan.zhihu.com/p/29837458">https://zhuanlan.zhihu.com/p/29837458</a><br /></li>
<li><a href="https://www.jordanstevenstechart.com/physically-based-rendering">https://www.jordanstevenstechart.com/physically-based-rendering</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgee58882" class="outline-2">
<h2 id="orgee58882">Misc</h2>
<div class="outline-text-2" id="text-orgee58882">
</div>
<div id="outline-container-orgecfd936" class="outline-3">
<h3 id="orgecfd936">Aniso</h3>
<div class="outline-text-3" id="text-orgecfd936">
</div>
<div id="outline-container-org0ae1c86" class="outline-4">
<h4 id="org0ae1c86">简单计算方式</h4>
<div class="outline-text-4" id="text-org0ae1c86">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed4</span> LightingAnisotropic(SurfaceAnisoOutput s,<span style="color: #ce537a; font-weight: bold;">fixed3</span> lightDir,<span style="color: #ce537a; font-weight: bold;">fixed3</span> viewDir,<span style="color: #ce537a; font-weight: bold;">fixed</span> atten)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> diffuse_ = <span style="color: #4f97d7;">dot</span>(s.Normal,lightDir);

    <span style="color: #ce537a; font-weight: bold;">float3</span> halfVect = <span style="color: #4f97d7;">normalize</span>(lightDir + viewDir);
    <span style="color: #ce537a; font-weight: bold;">fixed</span> HDotA = <span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(s.Normal+s.AnisoDir),halfVect);

    <span style="color: #ce537a; font-weight: bold;">float</span> aniso = <span style="color: #4f97d7;">max</span>(0,<span style="color: #4f97d7;">sin</span>((HDotA+<span style="color: #7590db;">_AnisoOffset</span>)*3.141));
    <span style="color: #ce537a; font-weight: bold;">float</span> spec = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">pow</span>(aniso,s.Gloss*128)) * s.<span style="color: #4f97d7; font-weight: bold;">Specular</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> specColor = spec*<span style="color: #7590db;">_SpecColor</span>.rgb;

    <span style="color: #ce537a; font-weight: bold;">fixed4</span> c;
    c.rgb = (s.Albedo * <span style="color: #7590db;">_LightColor0</span>.rgb * diffuse_) + (<span style="color: #7590db;">_LightColor0</span>.rgb * specColor) * atten * 2;
    c.a = 1.0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> c;
}

</pre>
</div>
<p>
说明：<br />
</p>
<ul class="org-ul">
<li>sin(HDotA*3.14) 将 sin 函数图像周期从（0-2Pi）缩放到（0-1） 所以该函数等价于 cos((HDotA-0.5)*3.14)<br /></li>
<li>sin(x*3.14)的函数值图像化如下，其效果是为了实现从中间到两边逐渐变暗的效果<br /></li>
</ul>


<div id="orgb27256f" class="figure">
<p><img src="./PhysicallyBasedRendering/01sin_fun_img.png" alt="01sin_fun_img.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge904356" class="outline-4">
<h4 id="orge904356">Gregory Ward</h4>
<div class="outline-text-4" id="text-orge904356">
<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/Cg_Programming/Unity/Brushed_Metal">https://en.wikibooks.org/wiki/Cg_Programming/Unity/Brushed_Metal</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc3ba778" class="outline-4">
<h4 id="orgc3ba778">参考资料</h4>
<div class="outline-text-4" id="text-orgc3ba778">
<ul class="org-ul">
<li>Unity Shader 之 不锈钢（各向异性材质）<a href="https://blog.csdn.net/joynson/article/details/77049813">https://blog.csdn.net/joynson/article/details/77049813</a><br /></li>
<li>UnityShaderAndEffectCookbook 第三节<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'Physically Based Rendering',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
