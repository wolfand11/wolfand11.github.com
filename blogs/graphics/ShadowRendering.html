<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-01 周二 23:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ShadowRendering</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">ShadowRendering</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf668ae7">Shadow Mapping</a>
<ul>
<li><a href="#orgeb6e4d9">原理</a></li>
<li><a href="#org3a5357a">Issues</a>
<ul>
<li><a href="#org097fa01">Self Occlusion</a>
<ul>
<li><a href="#org2ab8bcb">Unity 如何处理的 SelfOcclusion？</a></li>
<li><a href="#org6bcbf01">为什么光照方向和表面法线夹角越大，Self Occlusion 越严重？</a></li>
</ul>
</li>
<li><a href="#org1eec752">Aliasing</a></li>
<li><a href="#org5531b82">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2dafadd">Cascaded Shadow Mapping</a>
<ul>
<li><a href="#orgb3f78e8">原理</a></li>
</ul>
</li>
<li><a href="#org2548681">Unity ScreenSpaceShadows</a>
<ul>
<li><a href="#orgb1578e9">原理</a></li>
</ul>
</li>
<li><a href="#orgf869a20">Percentage Closer Filter</a>
<ul>
<li><a href="#org1a54506">原理</a>
<ul>
<li><a href="#org6800938">如何生成 2D Triangle Filter Kernel?</a></li>
<li><a href="#org3c353ad">如何生成 2D Gaussian Filter Kernel?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c10789">Percentage Closer Soft Shadow</a>
<ul>
<li><a href="#orgce50c78">原理</a></li>
</ul>
</li>
<li><a href="#org529e9c2">Planar Shadow</a>
<ul>
<li><a href="#org0aecf24">原理</a>
<ul>
<li><a href="#org1560038">ERROR: 反射摄像机渲染结果和场景摄像机相同？</a></li>
<li><a href="#orgbe1408e">ERROR: 穿过平面的物体，反射效果错误</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0775552">Dynamic Shadow Projector</a>
<ul>
<li><a href="#orgbf1360e">原理</a></li>
</ul>
</li>
<li><a href="#org755f6ad">参考资料</a></li>
</ul>
</div>
</div>
<p>
UnityShadow note.<br />
</p>
<div class="HTML" id="org0fdb2ee">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>
<div id="outline-container-orgf668ae7" class="outline-2">
<h2 id="orgf668ae7">Shadow Mapping</h2>
<div class="outline-text-2" id="text-orgf668ae7">
</div>
<div id="outline-container-orgeb6e4d9" class="outline-3">
<h3 id="orgeb6e4d9">原理</h3>
<div class="outline-text-3" id="text-orgeb6e4d9">
<ol class="org-ol">
<li>从灯光方向渲染场景，得到 shadow map<br /></li>
<li>从摄像机渲染场景时，将渲染的像素转化到灯光坐标系中，执行投影变换后得到像素在灯光坐标系下的深度值 Zl 以及采样 shadowmap 的 uv 坐标<br /></li>
<li>比较 shadowmap 中深度值 Z 和 Zl，Z&lt;Zl 说明当前像素在阴影中，否则说明当前像素被照亮<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org3a5357a" class="outline-3">
<h3 id="org3a5357a">Issues</h3>
<div class="outline-text-3" id="text-org3a5357a">
</div>
<div id="outline-container-org097fa01" class="outline-4">
<h4 id="org097fa01">Self Occlusion</h4>
<div class="outline-text-4" id="text-org097fa01">
<p>
用阴影贴图存储场景到光源的深度信息，其实是在光栅化阶段后，将场景深度信息进行离散化存储到精度有限的深度贴图中，深度贴图中每个图元对应的是一个小区域(假设该区域为 As)中心点的深度值 Z。 渲染物体时，fragment shader 中计算当前片段的深度值，该深度值同样是一个小区域(假设该区域为 Al)中心点的深度值 Zl。无法保证 As 和 Al 区域能一一对应起来，所以，在比较 Z 和 Zl 时，这两个值对应的并不是同一个点的深度。如下图所示：<br />
<img src="./ShadowRendering/shadow_map_self_occlusion_01.jpg" alt="shadow_map_self_occlusion_01.jpg" /><br />
</p>

<p>
这就会导致下图中出现黑白相间的条纹:<br />
<img src="./ShadowRendering/shadow_map_self_occlusion.jpg" alt="shadow_map_self_occlusion.jpg" /><br />
</p>

<p>
可以通过将像素深度值往光源方向的反方向偏移来解决该问题，其原理如下图所示：<br />
<img src="./ShadowRendering/shadow_map_self_occlusion_03.jpg" alt="shadow_map_self_occlusion_03.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float</span> closestDepth = <span style="color: #4f97d7; font-weight: bold;">texture</span>(shadowMap, projCoords.xy).r;
<span style="color: #ce537a; font-weight: bold;">float</span> bias = <span style="color: #4f97d7;">max</span>(0.05 * (1.0 - <span style="color: #4f97d7;">dot</span>(normal, lightDir)), 0.005);  <span style="color: #2aa1ae; background-color: #292e34;">// N L&#22841;&#35282;&#36234;&#23567;&#65292;&#20559;&#31227;&#36234;&#23567;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> shadow = currentDepth - bias &gt; closestDepth  ? 1.0 : 0.0; 
</pre>
</div>

<p>
上面的偏移方法会导致阴影跟着偏移，如下图所示：<br />
<img src="./ShadowRendering/shadow_map_self_occlusion_04.jpg" alt="shadow_map_self_occlusion_04.jpg" /><br />
</p>

<p>
还可以通过第二深度贴图来解决 Self Occlusion 问题，该方案可以避免阴影偏移的问题，其原理如下图：<br />
<img src="./ShadowRendering/second-depth-shadow mapping.jpg" alt="second-depth-shadow mapping.jpg" /><br />
</p>
</div>

<div id="outline-container-org2ab8bcb" class="outline-5">
<h5 id="org2ab8bcb">Unity 如何处理的 SelfOcclusion？</h5>
<div class="outline-text-5" id="text-org2ab8bcb">
<ol class="org-ol">
<li>渲染阴影贴图时，将物体顶点向 normal 反方向偏移，阴影贴图中记录的深度值会比正常情况要大。<br /></li>
<li>将近平面前的物体移到近平面，避免阴影显示不完整<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityClipSpaceShadowCasterPos</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> vertex, <span style="color: #ce537a; font-weight: bold;">float3</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> wPos = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, vertex);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_LightShadowBias.z != 0.0)
    {
        <span style="color: #ce537a; font-weight: bold;">float3</span> wNormal = UnityObjectToWorldNormal(normal);
        <span style="color: #ce537a; font-weight: bold;">float3</span> wLight = <span style="color: #4f97d7;">normalize</span>(UnityWorldSpaceLightDir(wPos.xyz));

        <span style="color: #2aa1ae; background-color: #292e34;">// apply normal offset bias (inset position along the normal)</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// bias needs to be scaled by sine between normal and light direction</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// (http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/)</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// unity_LightShadowBias.z contains user-specified normal offset amount</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// scaled by world space texel size.</span>

        <span style="color: #ce537a; font-weight: bold;">float</span> shadowCos = <span style="color: #4f97d7;">dot</span>(wNormal, wLight);
        <span style="color: #ce537a; font-weight: bold;">float</span> shadowSine = <span style="color: #4f97d7;">sqrt</span>(1-shadowCos*shadowCos);
        <span style="color: #2aa1ae; background-color: #292e34;">// &#20559;&#31227;&#37327;*sin(L&#21644;N&#30340;&#22841;&#35282;) </span>
        <span style="color: #ce537a; font-weight: bold;">float</span> normalBias = unity_LightShadowBias.z * shadowSine;

        <span style="color: #2aa1ae; background-color: #292e34;">// &#29289;&#20307;&#22352;&#26631;&#21521;normal&#21453;&#26041;&#21521;&#20559;&#31227;</span>
        wPos.xyz -= wNormal * normalBias;
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">mul</span>(UNITY_MATRIX_VP, wPos);
}
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityApplyLinearShadowBias</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> clipPos)
{
<span style="color: #bc6ec5;">#if</span> !(defined(SHADOWS_CUBE) &amp;&amp; defined(SHADOWS_CUBE_IN_DEPTH_TEX))
<span style="color: #bc6ec5;">    #if</span> defined(UNITY_REVERSED_Z)
        clipPos.z += <span style="color: #4f97d7;">max</span>(-1, <span style="color: #4f97d7;">min</span>(unity_LightShadowBias.x / clipPos.w, 0));
<span style="color: #bc6ec5;">    #else</span>
        clipPos.z += <span style="color: #4f97d7;">saturate</span>(unity_LightShadowBias.x/clipPos.w);
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// &#23558;&#36817;&#24179;&#38754;&#21069;&#30340;&#29289;&#20307;&#31227;&#21040;&#36817;&#24179;&#38754;</span>
<span style="color: #bc6ec5;">#if</span> defined(UNITY_REVERSED_Z)
    <span style="color: #ce537a; font-weight: bold;">float</span> clamped = <span style="color: #4f97d7;">min</span>(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> clamped = <span style="color: #4f97d7;">max</span>(clipPos.z, clipPos.w*UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">#endif</span>
    clipPos.z = <span style="color: #4f97d7;">lerp</span>(clipPos.z, clamped, unity_LightShadowBias.y);
    <span style="color: #4f97d7; font-weight: bold;">return</span> clipPos;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6bcbf01" class="outline-5">
<h5 id="org6bcbf01">为什么光照方向和表面法线夹角越大，Self Occlusion 越严重？</h5>
<div class="outline-text-5" id="text-org6bcbf01">
<p>
如下图所示光照方向和表面法线夹角越大，阴影贴图所对应的场景区域越大，每个阴影图元对应的区域越大。摄像机片段深度值和阴影深度值相差就越大。shadow bias 比较小的化，依然无法避免 Self Occlusion 问题。<br />
<img src="./ShadowRendering/shadow_map_self_occlusion_02.jpg" alt="shadow_map_self_occlusion_02.jpg" /><br />
<a href="./ShadowRendering/shadow_map_self_occlusion_02.ggb">./ShadowRendering/shadow_map_self_occlusion_02.ggb</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1eec752" class="outline-4">
<h4 id="org1eec752">Aliasing</h4>
<div class="outline-text-4" id="text-org1eec752">
<p>
使用 PCF 来解决 Aliasing。PCF 原理参考下文。<br />
</p>
</div>
</div>
<div id="outline-container-org5531b82" class="outline-4">
<h4 id="org5531b82">参考资料</h4>
<div class="outline-text-4" id="text-org5531b82">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
<li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_03.pdf">https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_03.pdf</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2dafadd" class="outline-2">
<h2 id="org2dafadd">Cascaded Shadow Mapping</h2>
<div class="outline-text-2" id="text-org2dafadd">
</div>
<div id="outline-container-orgb3f78e8" class="outline-3">
<h3 id="orgb3f78e8">原理</h3>
<div class="outline-text-3" id="text-orgb3f78e8">
<p>
场景中近处物体的阴影精度要求比较高，远处物体的阴影精度不需要太高。可以按照下图所示方法将视景体分为 Near、Middle、Far 三部分，分别对场景进行阴影渲染，近处阴影渲染所涵盖的场景比较小，远处阴影渲染所涵盖的场景范围比较大，假如各部分所占阴影贴图空间相同，则近处部分的阴影精度自然要高。我们甚至可以为近处分配更多的阴影贴图空间，更进一步提高近处阴影进度。<br />
</p>


<div id="org2d3de42" class="figure">
<p><img src="./ShadowRendering/cascaded_shadow_mapping.png" alt="cascaded_shadow_mapping.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org2548681" class="outline-2">
<h2 id="org2548681">Unity ScreenSpaceShadows</h2>
<div class="outline-text-2" id="text-org2548681">
</div>
<div id="outline-container-orgb1578e9" class="outline-3">
<h3 id="orgb1578e9">原理</h3>
<div class="outline-text-3" id="text-orgb1578e9">
<ol class="org-ol">
<li>在屏幕空间，根据深度缓冲区内容 和 ShadowMap 内容，得到屏幕空间的阴影。<br /></li>
<li>渲染物体时，直接采样屏幕空间阴影贴图得到阴影值。<br /></li>

<li>Unity 为什么使用 screen space shadow？ <a href="https://www.zhihu.com/question/289621666">https://www.zhihu.com/question/289621666</a><br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgf869a20" class="outline-2">
<h2 id="orgf869a20">Percentage Closer Filter</h2>
<div class="outline-text-2" id="text-orgf869a20">
</div>
<div id="outline-container-org1a54506" class="outline-3">
<h3 id="org1a54506">原理</h3>
<div class="outline-text-3" id="text-org1a54506">
<ul class="org-ul">
<li><a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch11.html">https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch11.html</a><br /></li>
</ul>
</div>

<div id="outline-container-org6800938" class="outline-4">
<h4 id="org6800938">如何生成 2D Triangle Filter Kernel?</h4>
<div class="outline-text-4" id="text-org6800938">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">import</span> numpy <span style="color: #4f97d7; font-weight: bold;">as</span> np

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">triangle_kernel</span>(kerlen):
    <span style="color: #7590db;">r</span> = np.arange(kerlen)
    <span style="color: #7590db;">kernel1d</span> = (kerlen + 1 - np.<span style="color: #4f97d7;">abs</span>(r - r[::-1])) / 2
    <span style="color: #7590db;">kernel2d</span> = np.outer(kernel1d, kernel1d)
    <span style="color: #7590db;">kernel2d</span> /= kernel2d.<span style="color: #4f97d7;">sum</span>()
    <span style="color: #4f97d7; font-weight: bold;">return</span> kernel2d

<span style="color: #4f97d7; font-weight: bold;">print</span>(triangle_kernel(4))
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">[[0.02777778 0.05555556 0.05555556 0.02777778]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.05555556 0.11111111 0.11111111 0.05555556]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.05555556 0.11111111 0.11111111 0.05555556]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.02777778 0.05555556 0.05555556 0.02777778]]</span>
<span style="color: #4f97d7; font-weight: bold;">print</span>(triangle_kernel(5))
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">[[0.01234568 0.02469136 0.03703704 0.02469136 0.01234568]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.02469136 0.04938272 0.07407407 0.04938272 0.02469136]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.03703704 0.07407407 0.11111111 0.07407407 0.03703704]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.02469136 0.04938272 0.07407407 0.04938272 0.02469136]</span>
<span style="color: #2aa1ae; background-color: #292e34;">#  </span><span style="color: #2aa1ae; background-color: #292e34;">[0.01234568 0.02469136 0.03703704 0.02469136 0.01234568]]</span>
</pre>
</div>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/56948729/how-to-create-a-triangle-kernel-in-python">https://stackoverflow.com/questions/56948729/how-to-create-a-triangle-kernel-in-python</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3c353ad" class="outline-4">
<h4 id="org3c353ad">如何生成 2D Gaussian Filter Kernel?</h4>
<div class="outline-text-4" id="text-org3c353ad">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">import</span> numpy <span style="color: #4f97d7; font-weight: bold;">as</span> np
<span style="color: #4f97d7; font-weight: bold;">import</span> scipy.stats <span style="color: #4f97d7; font-weight: bold;">as</span> st

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">gkern</span>(kernlen=21, nsig=3):
    <span style="color: #9f8766;">"""Returns a 2D Gaussian kernel."""</span>

    <span style="color: #7590db;">x</span> = np.linspace(-nsig, nsig, kernlen+1)
    <span style="color: #7590db;">kern1d</span> = np.diff(st.norm.cdf(x))
    <span style="color: #7590db;">kern2d</span> = np.outer(kern1d, kern1d)
    <span style="color: #4f97d7; font-weight: bold;">return</span> kern2d/kern2d.<span style="color: #4f97d7;">sum</span>()

<span style="color: #4f97d7; font-weight: bold;">print</span>(gkern(3,3))
</pre>
</div>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/29731726/how-to-calculate-a-gaussian-kernel-matrix-efficiently-in-numpy">https://stackoverflow.com/questions/29731726/how-to-calculate-a-gaussian-kernel-matrix-efficiently-in-numpy</a><br /></li>
<li><a href="http://dev.theomader.com/gaussian-kernel-calculator/">http://dev.theomader.com/gaussian-kernel-calculator/</a><br /></li>
<li><a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm">https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4c10789" class="outline-2">
<h2 id="org4c10789">Percentage Closer Soft Shadow</h2>
<div class="outline-text-2" id="text-org4c10789">
</div>
<div id="outline-container-orgce50c78" class="outline-3">
<h3 id="orgce50c78">原理</h3>
<div class="outline-text-3" id="text-orgce50c78">
<p>
依据投影点和遮挡物之间的距离计算 PCF 采样宽度，距离越远采样宽度越大，阴影越模糊；距离越近采样宽度越小，阴影越锐利。<br />
</p>


<div id="orga2a1a4a" class="figure">
<p><img src="./ShadowRendering/pcss_shadow_value.jpg" alt="pcss_shadow_value.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org529e9c2" class="outline-2">
<h2 id="org529e9c2">Planar Shadow</h2>
<div class="outline-text-2" id="text-org529e9c2">
</div>
<div id="outline-container-org0aecf24" class="outline-3">
<h3 id="org0aecf24">原理</h3>
<div class="outline-text-3" id="text-org0aecf24">
<p>
将模型顶点变换到投影平面上进行渲染。<br />
<img src="./ShadowRendering/planar_shadow.jpg" alt="planar_shadow.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/42781261">https://zhuanlan.zhihu.com/p/42781261</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/31504088">https://zhuanlan.zhihu.com/p/31504088</a><br /></li>
</ul>
</div>
<div id="outline-container-org1560038" class="outline-4">
<h4 id="org1560038">ERROR: 反射摄像机渲染结果和场景摄像机相同？</h4>
<div class="outline-text-4" id="text-org1560038">
<p>
reflectionCam.Render() 会触发 OnWillRenderObject()，导致两次反射抵消了反射效果，即相当于执行了如下代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">reflectionCam.worldToCameraMatrix = Camera.current.worldToCameraMatrix * reflectMatrix * reflectMatrix;&#12290;
</pre>
</div>

<p>
使用如下方法解决该 Bug：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnWillRenderObject</span>()
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36991;&#20813;&#20351;&#29992;&#28608;&#27963;&#30340;&#25668;&#20687;&#26426;&#36827;&#34892;&#28210;&#26579;</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span>(Camera.current == reflectionCam)
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span>;
      }
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbe1408e" class="outline-4">
<h4 id="orgbe1408e">ERROR: 穿过平面的物体，反射效果错误</h4>
<div class="outline-text-4" id="text-orgbe1408e">
<p>
错误效果如下：<br />
<img src="./ShadowRendering/plannar_reflection_error01.jpg" alt="plannar_reflection_error01.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0775552" class="outline-2">
<h2 id="org0775552">Dynamic Shadow Projector</h2>
<div class="outline-text-2" id="text-org0775552">
</div>
<div id="outline-container-orgbf1360e" class="outline-3">
<h3 id="orgbf1360e">原理</h3>
<div class="outline-text-3" id="text-orgbf1360e">
<ol class="org-ol">
<li>从灯光方向，对投影物体进行渲染，结果放入 RenderTexture _ShadowRT 中<br /></li>
<li>使用 Projector 渲染阴影接受物体，将_ShadowRT 投影到阴影接受物体上<br /></li>
</ol>

<p>
Projector 的原理：<br />
在正常渲染地面(假设地面为阴影接收物)时，将像素对应的坐标变换到 Projector 的屏幕空间，使用该屏幕空间坐标直接对_ShadowRT 进行采样就得到了当前渲染位置的阴影值。<br />
</p>

<p>
<img src="./ShadowRendering/projector-shadow.jpg" alt="projector-shadow.jpg" /><br />
<a href="./ShadowRendering/projector-shadow.gba">./ShadowRendering/projector-shadow.gba</a><br />
</p>

<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> vertex:<span style="color: #a45bad;">POSITION</span>)
{
    v2f o;
    o.pos = UnityObjectToClipPos(vertex);
    o.sproj = <span style="color: #4f97d7;">mul</span>(unity_Projector, vertex);
    UNITY_TRANSFER_FOG(o,o.pos);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i):SV_TARGET
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> shadowCol = <span style="color: #4f97d7;">tex2Dproj</span>(<span style="color: #7590db;">_ShadowTex</span>, UNITY_PROJ_COORD(i.sproj));
    <span style="color: #ce537a; font-weight: bold;">half</span> maskCol = <span style="color: #4f97d7;">tex2Dproj</span>(<span style="color: #7590db;">_FalloffTex</span>, UNITY_PROJ_COORD(i.sproj)).r;
    <span style="color: #ce537a; font-weight: bold;">half</span> a = shadowCol.r * maskCol;
    <span style="color: #ce537a; font-weight: bold;">float</span> c = 1.0 - <span style="color: #7590db;">_Intensity</span> * a;

    UNITY_APPLY_FOG_COLOR(i.fogCoord, c, <span style="color: #ce537a; font-weight: bold;">fixed4</span>(1,1,1,1));

    <span style="color: #4f97d7; font-weight: bold;">return</span> c;
}
</pre>
</div>
<p>
在正常渲染裤子的顶点时，顺便变换到投影器的屏幕空间，然后再渲染裤子的片段处理函数中将位于投影器屏幕空间的像素都换成眼睛即可。<br />
</p>
<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/42433900">https://zhuanlan.zhihu.com/p/42433900</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org755f6ad" class="outline-2">
<h2 id="org755f6ad">参考资料</h2>
<div class="outline-text-2" id="text-org755f6ad">
<ul class="org-ul">
<li>Unity 实时阴影实现——Cascaded Shadow Mapping <a href="https://zhuanlan.zhihu.com/p/45673049">https://zhuanlan.zhihu.com/p/45673049</a><br /></li>
<li>Cascaded Shadow Maps <a href="https://docs.microsoft.com/zh-cn/windows/desktop/DxTechArts/cascaded-shadow-maps">https://docs.microsoft.com/zh-cn/windows/desktop/DxTechArts/cascaded-shadow-maps</a><br /></li>
<li>Cascaded Shadow Maps <a href="http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html">http://ogldev.atspace.co.uk/www/tutorial49/tutorial49.html</a><br /></li>
<li>Unity3D 阴影和深度纹理总结 <a href="https://gameinstitute.qq.com/community/detail/117485">https://gameinstitute.qq.com/community/detail/117485</a><br /></li>
<li>Unity 的 Shader 如何控制投影颜色 <a href="https://www.cnblogs.com/sitt/p/4699369.html">https://www.cnblogs.com/sitt/p/4699369.html</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
