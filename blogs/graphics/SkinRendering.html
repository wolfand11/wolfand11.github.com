<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-21 Wed 23:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Skin Rendering</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Skin Rendering</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga45e3ad">皮肤医学结构</a>
<ul>
<li><a href="#orgf1ef102">表皮的分层</a>
<ul>
<li><a href="#org1ca1401">角质层 Stratum corneum</a></li>
<li><a href="#org8726cd3">透明层 Stratum lucidum</a></li>
<li><a href="#org93cad67">颗粒层 Stratum granulosum</a></li>
<li><a href="#org6277299">棘层 Stratum spinosum</a></li>
<li><a href="#orgc6dcc57">基底层 Stratum basale</a></li>
</ul>
</li>
<li><a href="#org993890b">皮肤结构图</a></li>
</ul>
</li>
<li><a href="#org29bc704">2007 Gem3Skin</a>
<ul>
<li><a href="#orgd04fdcb">实现总结</a>
<ul>
<li><a href="#orgb2c6296">高光</a></li>
<li><a href="#org2e4cc38">Diffuse</a>
<ul>
<li><a href="#orgbbd4321">计算 RhodtTexture</a></li>
<li><a href="#orgc46988a">计算 IrradianceTexture</a></li>
<li><a href="#org72de115">计算 StretchCorrectionTexture</a></li>
<li><a href="#orgb1447f1">计算 SeamMaskTexture</a></li>
<li><a href="#orgcab75fc">对 StretchTexture 和 IrradianceTexture 进行模糊</a>
<ul>
<li><a href="#org6e7cf3b">2D Blur to 1D Blur</a></li>
<li><a href="#orgb9274d8">高斯模糊近似 R(d)函数</a></li>
<li><a href="#org363c41c">代码实现</a></li>
</ul>
</li>
<li><a href="#orge2122b0">Translucent Shadow Maps</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd2a19a6">参考资料</a>
<ul>
<li><a href="#orgee25606">高斯卷积核求解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org779bb35">2009 Efficient rendering of local subsurface scattering</a></li>
<li><a href="#org0cd48b7">2011 Pre-Intergrating the Effects of Scattering</a>
<ul>
<li><a href="#orge2efdad">Pre-integrating the Effect of Scattering</a></li>
<li><a href="#org613d045">Scattering and Diffuse Light</a></li>
<li><a href="#org92d87aa">Scattering and Normal Maps</a></li>
<li><a href="#org068b43d">Shadow Scattering</a></li>
</ul>
</li>
<li><a href="#org194fdef">Improve Pre-Intergrating</a>
<ul>
<li><a href="#orgd894fe8">2013 Env Light Pre-Intergrating Scattering</a></li>
<li><a href="#org3ce8d46">Approximate Pre-Intergrating Scattering</a></li>
</ul>
</li>
<li><a href="#orgf43c2cc">CLX2 Skin</a>
<ul>
<li><a href="#orgda75179">BRDF</a>
<ul>
<li><a href="#orge0fe9c3">Fresnel</a></li>
<li><a href="#orgdbfd47a">D</a></li>
<li><a href="#org6f72cc4">G</a></li>
</ul>
</li>
<li><a href="#org9d65d48">Refract Light</a></li>
<li><a href="#org6386e5e">SSS</a></li>
</ul>
</li>
<li><a href="#org12e097a">2009 ScreenSpace Perceptual Rendering of Human Skin</a>
<ul>
<li><a href="#org59cf0fa">实现细节</a>
<ul>
<li><a href="#org009ee46">Blur Kernel width</a></li>
<li><a href="#orgda9828d">渲染流程和贴图空间 SSS 的对比</a></li>
<li><a href="#orgb9f23aa">缺陷</a></li>
</ul>
</li>
<li><a href="#org4c056a5">参考链接</a></li>
</ul>
</li>
<li><a href="#orga65cc7a">2010 Real-Time Realistic Skin Translucency</a>
<ul>
<li>
<ul>
<li><a href="#org490c578">算法基于下面 4 点观察</a></li>
<li><a href="#orgf5d52b4">基于上面 4 点观察，算法做出如下 3 点假设</a></li>
<li><a href="#org4d11c84">公式推导</a></li>
<li><a href="#orgbf243aa">实现细节</a></li>
</ul>
</li>
<li><a href="#org4e82d26">参考链接</a></li>
</ul>
</li>
<li><a href="#orgcae6b48"><span class="todo TODO">TODO</span> 2015 Separable-SSS</a>
<ul>
<li><a href="#org332ca80">参考链接</a></li>
</ul>
</li>
<li><a href="#orga710e72"><span class="todo TODO">TODO</span> 2018 Unity Efficient screen space subsurface scattering</a>
<ul>
<li><a href="#orgdbd37c7">参考链接</a></li>
</ul>
</li>
<li><a href="#org2221ce4">Misc</a>
<ul>
<li><a href="#orgf1cd9d5">Normal Map Mipmap</a></li>
<li><a href="#orgd138c14">NoLWrap</a></li>
</ul>
</li>
<li><a href="#org206f89e">参考资料</a></li>
</ul>
</div>
</div>
<p>
Skin Rendering note.<br />
</p>
<div class="HTML" id="org7abe9f3">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orga45e3ad" class="outline-2">
<h2 id="orga45e3ad">皮肤医学结构</h2>
<div class="outline-text-2" id="text-orga45e3ad">
<p>
皮肤分为 表皮 epidermis，真皮 dermis 和皮下组织 subcutaneous tissue<br />
</p>
</div>
<div id="outline-container-orgf1ef102" class="outline-3">
<h3 id="orgf1ef102">表皮的分层</h3>
<div class="outline-text-3" id="text-orgf1ef102">
</div>
<div id="outline-container-org1ca1401" class="outline-4">
<h4 id="org1ca1401">角质层 Stratum corneum</h4>
<div class="outline-text-4" id="text-org1ca1401">
<p>
位于表皮的最外层，由 5-20 层的扁平无核细胞组成，胞内细胞器结构消失，充满角蛋白。<br />
</p>
</div>
</div>
<div id="outline-container-org8726cd3" class="outline-4">
<h4 id="org8726cd3">透明层 Stratum lucidum</h4>
<div class="outline-text-4" id="text-org8726cd3">
<p>
仅见于掌跖。由 2-3 层扁平无核细胞组成。<br />
</p>
</div>
</div>
<div id="outline-container-org93cad67" class="outline-4">
<h4 id="org93cad67">颗粒层 Stratum granulosum</h4>
<div class="outline-text-4" id="text-org93cad67">
<p>
由 2-4 层梭形细胞组成，细胞内含有透明角质颗粒。<br />
</p>
</div>
</div>
<div id="outline-container-org6277299" class="outline-4">
<h4 id="org6277299">棘层 Stratum spinosum</h4>
<div class="outline-text-4" id="text-org6277299">
<p>
由 4-10 层多角形细胞组成，细胞间桥明显呈棘状。<br />
</p>
</div>
</div>
<div id="outline-container-orgc6dcc57" class="outline-4">
<h4 id="orgc6dcc57">基底层 Stratum basale</h4>
<div class="outline-text-4" id="text-orgc6dcc57">
<p>
位于表皮的最下层，为一层立方形或圆柱状细胞，细胞的长轴与基底膜带垂直，胞核呈卵圆形，胞浆内含有黑素颗粒，核分裂象常见。<br />
具有不断分裂增殖的能力，因此又称为生发层。由基底层移行至颗粒层最上层约需 14 天，再移行至角质层表面脱落又需 14 天，称为表皮通过时间。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org993890b" class="outline-3">
<h3 id="org993890b">皮肤结构图</h3>
<div class="outline-text-3" id="text-org993890b">

<div id="org20af9d0" class="figure">
<p><img src="SkinRendering/001_Skin_Structure_Image_01.jpg" alt="001_Skin_Structure_Image_01.jpg" width="200px" /><br />
</p>
</div>

<div id="orgfeaf892" class="figure">
<p><img src="SkinRendering/001_Skin_Structure_Image_02.jpg" alt="001_Skin_Structure_Image_02.jpg" width="200px" /><br />
</p>
</div>

<ul class="org-ul">
<li>皮肤结构 <a href="http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx">http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx</a><br /></li>
<li>皮肤的结构-表皮 <a href="http://www.truebuty.com/scstructure.html">http://www.truebuty.com/scstructure.html</a><br /></li>
<li><a href="https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/">https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org29bc704" class="outline-2">
<h2 id="org29bc704">2007 Gem3Skin</h2>
<div class="outline-text-2" id="text-org29bc704">
<ul class="org-ul">
<li>原文链接 Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
</ul>

<p>
下图是使用 2 个 Gaussian 函数，4个 Gaussian 函数来近似 Dipole 模型推导出的 绿光在大理石中散射的 diffuse profile：<br />
</p>

<div id="org026660e" class="figure">
<p><img src="./SkinRendering/gaussians-approx-dipole profiles.jpg" alt="gaussians-approx-dipole profiles.jpg" width="200px" /><br />
</p>
</div>

<p>
下图使用 6 个高斯函数来近似 Diffusion profile。rgb 三个通道都是用相同的这 6 个高斯函数，但是对应的高斯函数的权重不同。<br />
</p>

<div id="orga5cf8ba" class="figure">
<p><img src="./SkinRendering/002_gaussian-func-weights.png" alt="002_gaussian-func-weights.png" width="200px" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd04fdcb" class="outline-3">
<h3 id="orgd04fdcb">实现总结</h3>
<div class="outline-text-3" id="text-orgd04fdcb">
</div>
<div id="outline-container-orgb2c6296" class="outline-4">
<h4 id="orgb2c6296">高光</h4>
<div class="outline-text-4" id="text-orgb2c6296">
<p>
高光使用了基于物理的 BRDF，为了加速计算，对 BRDF 进行了预计算。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">PHBeckmann</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">nDotH</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">roughness</span>)
{
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">alpha</span> = acos(nDotH);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ta</span> = tan(alpha);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">r2</span> = roughness * roughness;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">val</span> = 1.0 / (r2*pow(nDotH, 4.0))*exp(-(ta*ta) / r2);
  <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5*pow(val, 0.1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2e4cc38" class="outline-4">
<h4 id="org2e4cc38">Diffuse</h4>
<div class="outline-text-4" id="text-org2e4cc38">
</div>
<div id="outline-container-orgbbd4321" class="outline-5">
<h5 id="orgbbd4321">计算 RhodtTexture</h5>
<div class="outline-text-5" id="text-orgbbd4321">
<p>
uv.u 为 NoL<br />
uv.v 为 roughness<br />
计算 BRDF 在半球空间的积分，得到所有被反射的比例，从而就可以得到剩余的被散射的比例。<br />
</p>
</div>
</div>

<div id="outline-container-orgc46988a" class="outline-5">
<h5 id="orgc46988a">计算 IrradianceTexture</h5>
<div class="outline-text-5" id="text-orgc46988a">
<p>
在贴图空间，计算被散射的能量。渲染模型，结果按照模型 UV 输出（这就是所谓的贴图空间渲染）。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
    {
        v2f o;
<span style="color: #bc6ec5;">        #if</span> UNITY_UV_STARTS_AT_TOP
        o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>((v.uv0 * 2 - 1)*<span style="color: #ce537a; font-weight: bold;">float2</span>(1,-1), 0, 1);
<span style="color: #bc6ec5;">        #else</span>
        o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.uv0 * 2 - 1, 0, 1);
<span style="color: #bc6ec5;">        #endif</span>
        o.tex = v.uv0;
        o.posWorld = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
        o.eyeVec.xyz = <span style="color: #7590db;">_WorldSpaceCameraPos</span> - o.posWorld.xyz;
        <span style="color: #4f97d7; font-weight: bold;">return</span> o;
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-org72de115" class="outline-5">
<h5 id="org72de115">计算 StretchCorrectionTexture</h5>
<div class="outline-text-5" id="text-org72de115">
<p>
在贴图空间，矫正贴图空间的模糊(曲率比较大的地方，相邻点的空间距离比其贴图上的距离要小)<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #2aa1ae; background-color: #292e34;">// &#21516;&#26679;&#26159;&#22312;&#36148;&#22270;&#31354;&#38388;&#36827;&#34892;&#35745;&#31639;&#65292;&#24471;&#21040;&#36148;&#22270;&#34987;&#25289;&#20280;&#30340;&#31243;&#24230;(&#20854;&#23454;&#20063;&#26159;&#27169;&#22411;&#26412;&#36523;&#30340;&#26354;&#29575;)</span>
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
    {
        <span style="color: #ce537a; font-weight: bold;">float3</span> posWorld = i.posWorld;
        <span style="color: #ce537a; font-weight: bold;">float3</span> derivU = <span style="color: #4f97d7;">ddx</span>(posWorld);
        <span style="color: #ce537a; font-weight: bold;">float3</span> derivV = <span style="color: #4f97d7;">ddy</span>(posWorld);
        <span style="color: #ce537a; font-weight: bold;">float</span> stretchU = 1 / <span style="color: #4f97d7;">length</span>(derivU) * <span style="color: #7590db;">_StretchScale</span>;
        <span style="color: #ce537a; font-weight: bold;">float</span> stretchV = 1 / <span style="color: #4f97d7;">length</span>(derivV) * <span style="color: #7590db;">_StretchScale</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(stretchU, stretchV, 0, 1);
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb1447f1" class="outline-5">
<h5 id="orgb1447f1">计算 SeamMaskTexture</h5>
<div class="outline-text-5" id="text-orgb1447f1">
<p>
使用(0,0,0,0) clear StretchTextureRT，生成 StretchTexture 时 alpha 始终填充 1，这样接缝外的 alpha 就会为 0。<br />
在贴图空间，将所有 StretchTexture 的 alpha 通道相乘就可以得到 SeamMask。<br />
</p>
</div>
</div>
<div id="outline-container-orgcab75fc" class="outline-5">
<h5 id="orgcab75fc">对 StretchTexture 和 IrradianceTexture 进行模糊</h5>
<div class="outline-text-5" id="text-orgcab75fc">
<p>
在贴图空间，对 IrradianceTexture 进行高斯模糊来模拟散射。一共使用 6 个高斯函数，RGB 通道使用不同的权重。6个高斯函数近似 multi-dipole profiles<br />
</p>
</div>
<div id="outline-container-org6e7cf3b" class="outline-6">
<h6 id="org6e7cf3b">2D Blur to 1D Blur</h6>
<div class="outline-text-6" id="text-org6e7cf3b">

<div id="org8d8cf08" class="figure">
<p><img src="./SkinRendering/2d_gaussian_blur_to_1d_gaussian_blur.jpg" alt="2d_gaussian_blur_to_1d_gaussian_blur.jpg" width="200px" /><br />
</p>
</div>

<div id="org75ddcb5" class="figure">
<p><img src="./SkinRendering/2d_gaussian_blur_to_1d_gaussian_blur_01.jpg" alt="2d_gaussian_blur_to_1d_gaussian_blur_01.jpg" width="200px" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/364517094">https://www.zhihu.com/question/364517094</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9274d8" class="outline-6">
<h6 id="orgb9274d8">高斯模糊近似 R(d)函数</h6>
<div class="outline-text-6" id="text-orgb9274d8">
<p>
R(d)<sub>r</sub> = 0.078*G(sqrt(7.41), d) + 0.358*G(sqrt(1.99), d) + 0.113*G(sqrt(7.41), d) + 0.118*G(sqrt(0.358), d) + 0.100*G(sqrt(0.0484), d) + 0.233*G(sqrt(0.0064), d);<br />
</p>

<div id="org353b24a" class="figure">
<p><img src="./SkinRendering/002_gaussian_approx_rd_001.jpg" alt="002_gaussian_approx_rd_001.jpg" width="200px" /><br />
</p>
</div>
<p width="200px">
<img src="./SkinRendering/002_gaussian_approx_rd_002.jpg" alt="002_gaussian_approx_rd_002.jpg" width="200px" /><br />
下面文件为一维高斯函数图形：<br />
<a href="./SkinRendering/002_gaussian_function.ggb">./SkinRendering/002_gaussian_function.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org363c41c" class="outline-6">
<h6 id="org363c41c">代码实现</h6>
<div class="outline-text-6" id="text-org363c41c">
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#36148;&#22270;&#31354;&#38388;&#65292;&#20808;&#23545;StretchTexture&#36827;&#34892;&#27169;&#31946;&#65292;&#28982;&#21518;&#20877;&#23545;IrradianceTexture&#36827;&#34892;&#27169;&#31946;</span>
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
    {
        <span style="color: #ce537a; font-weight: bold;">float</span> scale = <span style="color: #7590db;">_MainTex_TexelSize</span>.x * <span style="color: #7590db;">_GaussianWidth</span> / <span style="color: #7590db;">_BlurStepScale</span>;
        <span style="color: #ce537a; font-weight: bold;">float2</span> uvDelta = <span style="color: #ce537a; font-weight: bold;">float2</span>(scale, 0.0);
<span style="color: #bc6ec5;">        #if</span> defined(CONV_V)
            uvDelta.xy = uvDelta.yx;
<span style="color: #bc6ec5;">            #if</span> defined(ENABLE_STRETCH_CORRECTION)
                uvDelta.y *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).y;
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #else</span>
<span style="color: #bc6ec5;">            #if</span> defined(ENABLE_STRETCH_CORRECTION)
                uvDelta.x *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).x;
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #endif</span>
        <span style="color: #ce537a; font-weight: bold;">float2</span> coords = i.uv - uvDelta*3.0;
        <span style="color: #ce537a; font-weight: bold;">float4</span> sum = 0.0;
            <span style="color: #2aa1ae; background-color: #292e34;">// &#26399;&#26395;&#20026;0&#65292;&#26631;&#20934;&#24046;&#20026;1 &#30340;&#39640;&#26031;&#20989;&#25968;&#31163;&#25955;&#30340;&#20989;&#25968;&#20540;</span>
        <span style="color: #ce537a; font-weight: bold;">float</span> curve[7] = { 0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006 };
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> j = 0; j &lt; 7; j++)
        {
            <span style="color: #ce537a; font-weight: bold;">float4</span> tap = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, coords);
            sum += curve[j] * tap;
            coords += uvDelta;
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> sum;
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge2122b0" class="outline-5">
<h5 id="orge2122b0">Translucent Shadow Maps</h5>
<div class="outline-text-5" id="text-orge2122b0">
<ul class="org-ul">
<li>生成 TSM<br />
从光源方向渲染模型（设置 ViewProjection 矩阵为 LightVP），将模型的 depth 和 uv 写入到 TSM RenderTarget。<br /></li>
<li>读取 TSM<br />
渲染模型时，将模型的 worldPos 转化到光源投影空间（LightVP * worldPos）得到 lightProjPos，利用 lightProjPos.xy/lightProjPos.w 就可以对上一步生成的 TSM 进行采样。此时得到的数据为模型当前渲染的点沿光照方向的背侧的点。如下图：<br /></li>
<li><p>
应用 TSM<br />
得到背侧点的 uv 和 depth 后，使用 uv 采样 IrradianceTexture 可得到背侧点的散射能量。利用这些信息计算出从背侧散射到当前点的能量。<br />
</p>

<div id="orgd19d7e0" class="figure">
<p><img src="./SkinRendering/001_tsm_illustrate.jpg" alt="001_tsm_illustrate.jpg" width="200px" /><br />
</p>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd2a19a6" class="outline-3">
<h3 id="orgd2a19a6">参考资料</h3>
<div class="outline-text-3" id="text-orgd2a19a6">
<ul class="org-ul">
<li>Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
<li>角色渲染技术——皮肤 <a href="https://zhuanlan.zhihu.com/p/27014447">https://zhuanlan.zhihu.com/p/27014447</a><br /></li>
<li>GPU Gems 3 真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
</ul>
</div>
<div id="outline-container-orgee25606" class="outline-4">
<h4 id="orgee25606">高斯卷积核求解</h4>
<div class="outline-text-4" id="text-orgee25606">
<ul class="org-ul">
<li>如何通俗易懂地解释卷积？  <a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a><br /></li>
<li>Gaussian filter, or Gaussian blur <a href="http://www.librow.com/articles/article-9">http://www.librow.com/articles/article-9</a><br /></li>
<li>高斯函数 <a href="https://www.zhihu.com/question/33214189">https://www.zhihu.com/question/33214189</a><br /></li>
<li>理解图像卷积操作的意义 <a href="https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1">https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1</a><br /></li>
<li>高斯卷积核计算器 <a href="http://dev.theomader.com/gaussian-kernel-calculator/">http://dev.theomader.com/gaussian-kernel-calculator/</a><br /></li>
<li>将 2D 卷积核转化为 1D <a href="https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/">https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/</a><br /></li>
<li>2D GaussianBlur To 1D <a href="https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur">https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org779bb35" class="outline-2">
<h2 id="org779bb35">2009 Efficient rendering of local subsurface scattering</h2>
<div class="outline-text-2" id="text-org779bb35">
<p>
该方法是屏幕空间的方法。对于当前的 skin pixel p，使用重要性采样生成一系列样本 pi（这些样本的 Irradiance 会散射到 p），利用蒙特卡洛积分来计算次表面散射。<br />
</p>


<div id="org373094a" class="figure">
<p><img src="./SkinRendering/2009_eflss_001.png" alt="2009_eflss_001.png" width="200px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0cd48b7" class="outline-2">
<h2 id="org0cd48b7">2011 Pre-Intergrating the Effects of Scattering</h2>
<div class="outline-text-2" id="text-org0cd48b7">
</div>
<div id="outline-container-orge2efdad" class="outline-3">
<h3 id="orge2efdad">Pre-integrating the Effect of Scattering</h3>
<div class="outline-text-3" id="text-orge2efdad">
<p>
我们没有通过收集渲染位置处所有方向的入射光来实现次表面散射。而是探索预积分皮肤中的次表面散射效果。<br />
只有三件事情会引入可见的散射：<br />
</p>
<ol class="org-ol">
<li>模型曲率的变化<br /></li>
<li>normal map 中的突起<br /></li>
<li>遮挡光导致的阴影<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org613d045" class="outline-3">
<h3 id="org613d045">Scattering and Diffuse Light</h3>
<div class="outline-text-3" id="text-org613d045">
<p>
nDotL 是主要导致入射光变化的原因，其使得散射变得明显。<br />
我们考虑通过球谐光照模拟所有方向上的光，以此来预计算表面上任意一点的散射光效果。但是球谐方式只能高效地表示低频率变化的光，对于高频变化的光需要很多系数。因此，我们放弃了预计算散射效果，而选择预计算表面形状子集的散射衰减，并在渲染时确定最好的衰减.<br />
我们在运行时可以计算表面的曲率，其最大程度决定了光滑表面的散射效果。<br />
为了测量曲面上的散射，我们添加了曲率作为第二个参数。我们简单从一个方向照射给定曲率的球面，并测量各个角度上累计的光照。<br />
下图为散射光公式推导：<br />
</p>

<div id="org51b788f" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_01.jpg" alt="indirect-light-scatter_01.jpg" width="400px" /><br />
</p>
</div>

<p>
当前模型假设所有的皮肤和球相似，但是皮肤可以为任意拓扑结构。换句话说，当前模型假设给定点的散射由该点自身的曲率决定，而事实上是由该点周围所有点的曲率决定。因此，该模型在平滑的表面上(曲率变化不大的表面上)效果可以，但是曲率变化比较大时，就不适用了。幸运的是，大多数皮肤模型都有两层：使用几何表示光滑的表面，使用 normal map 表示表面细节。<br />
</p>

<ul class="org-ul">
<li>如何简明地解释曲率（curvature）？ <a href="https://www.zhihu.com/question/25952605">https://www.zhihu.com/question/25952605</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org92d87aa" class="outline-3">
<h3 id="org92d87aa">Scattering and Normal Maps</h3>
<div class="outline-text-3" id="text-org92d87aa">
<p>
皮肤上小的皱纹、毛孔通常通过 normal map 来表示。因为小折痕的法线总是要回到表面主法线方向，从小折痕反射的散射光和折痕更宽的不散射表面反射的光看起来很像。因此可以通过模糊 normal 来近似皱纹、毛孔等小褶皱照成的散射。对于不同波长的光，diffusion profiles 不同，模糊 normal 的方式也不同。<br />
</p>

<p>
从实际的物体抓取 normal 贴图时，发现 normal 会向表面法线偏转，而且不同波长的光偏转程度不同，红光比绿光偏转程度大。还观察到使用多个波长的光抓取的多个 normal 进行渲染要比使用单个 normal 效果要好。<br />
我们的做法为，假定原始的 normal map 是精确的表面法线，对其进行 blur 而得到每个波长对应的 normal。因此，不能为了得到更光滑的效果，而直接提供 blur 过的 normal map 做原始的 normal map，否则再对其进行 blur 得到的每个波长的 normal 将不正确。<br />
使用 diffusion profile 直接对 normal map 进行 blur 是不可行的，因为光照对于表面法线不是线性过程。需要使用 LEAN 或 CLEAN。<br />
</p>

<p>
值得注意的是，在法线贴图的过滤区域内，阴影/入射光/散射光项为常数时，使用非归一化的 normal 是一个可行的近似，此时我们有如下关系式：<br />
</p>
<p width="300px">
<img src="./SkinRendering/004_normal_filter_001.jpg" alt="004_normal_filter_001.jpg" width="300px" /><br />
上面关系式不是总成立的，因为 diffuse lighting 包含一个自阴影项 max(0, N.L)来取代上式中的 N.L。尽管如此，当法线过滤区域内都没阴影或都有阴影时，使用非归一化的法线依然是正确的。<br />
</p>

<p>
我们开发了一种近似的方法，其只用一张包含 mipmap 的法线贴图。使用该优化方法时，specular normal 的采样依然不变，但同时使用另一个采样器采样高一级的 mipmap 得到 red normal。然后将 specular normal 和 red normal 变换到 tangent 空间，对他们进行混合得到 green 和 blue normal。最后的 diffuse-lighting 计算需要执行三次（red-diffuse blue-diffuse green-diffuse）。<br />
</p>

<p>
如果法线贴图只包含很小的细节，甚至可以使用几何法线来代替 red normal。<br />
</p>
</div>
</div>
<div id="outline-container-org068b43d" class="outline-3">
<h3 id="org068b43d">Shadow Scattering</h3>
<div class="outline-text-3" id="text-org068b43d">
<p>
光散射到阴影是真实感皮肤的重要特性之一。使用一点小技巧就可以预计算阴影边界上的散射效果。<br />
</p>

<p>
我们可以将阴影映射算法当作一个衰减函数。当衰减为完全黑或完全白，对应着完全遮挡和完全不遮挡。我们可以重新设置完全黑和完全白之间的值。特别地，如果我们确定我们的阴影过滤器创建的半影尺寸足够容纳大部分的 diffusion profile，我们可以缩小原始半影的尺寸，多出来的尺寸用于基于 diffusion profile 的散射。<br />
</p>

<div id="orgfb6c4b5" class="figure">
<p><img src="./SkinRendering/004_shadow_scatter.jpg" alt="004_shadow_scatter.jpg" width="400px" /><br />
</p>
</div>

<p>
为了计算精确的衰减，我们将阴影半影和 diffusion profile 进行预积分。我们将阴影半影 P()定义为一个一维衰减函数，该函数来自于使用阴影贴图映射的 blur kernel 对硬阴影边界的过滤。假定阴影映射的 kernel 为单调递减的，则对应的衰减函数也是单调递减，这样就可以对阴影半影 P()求反函数 \(P^{-1}()\) 。这样就可以通过给定的阴影值获得对应的半影中的位置。例如，如果阴影映射为 BoxFilter，则阴影半影函数 P()就是一个线性的斜坡，此时对应的反函数 \(P^{-1}()\) 也是一个线性的斜坡。<br />
</p>

<p>
我们假定了阴影是投射在一个平面上的，如果表面倾斜度很大，半影尺寸将比我们预计算时使用的值大很多。因此，我们为阴影衰减贴图增加了第二个维度，其表示世界空间中的半影尺寸。最后，我们生成阴影 LUT 的公式如下：<br />
</p>

<div id="orgfa7c8a8" class="figure">
<p><img src="./SkinRendering/004_shadow_scatter_equation.jpg" alt="004_shadow_scatter_equation.jpg" width="400px" /><br />
</p>
</div>

<p>
半影宽度可以通过表面和对应光源的夹角得到，或者直接对阴影值进行求导。<br />
当半影被拉升映射到倾斜度很高的表面时，此时提供的散射衰减空间更大。可以对半影宽度值进行截取，以保证其在 LUT 贴图范围内。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org194fdef" class="outline-2">
<h2 id="org194fdef">Improve Pre-Intergrating</h2>
<div class="outline-text-2" id="text-org194fdef">
</div>
<div id="outline-container-orgd894fe8" class="outline-3">
<h3 id="orgd894fe8">2013 Env Light Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-orgd894fe8">
<ol class="org-ol">
<li>将皮肤次表面散射系数转化为 SH 系数<br /></li>
<li>计算 SH 环境光时，用 LightSH 系数*ScatterSH 系数就得到此表面散射后的环境光<br /></li>
</ol>

<p>
原理如下推导：<br />
</p>

<div id="org393e5c0" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_01.jpg" alt="indirect-light-scatter_01.jpg" width="400px" /><br />
</p>
</div>


<div id="orgf5ef009" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_02.jpg" alt="indirect-light-scatter_02.jpg" width="400px" /><br />
</p>
</div>

<p>
Tips：计算间接光照的 diffuse 部分时，会传入当前顶点的世界坐标系下的法线 wNormal，需要将 S(θ,r)的+z 方向和 wNormal 对齐。也就是上图中给 Rl 乘了一个变换系数得到了 Rl‘。<br />
</p>

<ul class="org-ul">
<li><a href="https://blog.selfshadow.com/publications/s2013-shading-course/#course_content">https://blog.selfshadow.com/publications/s2013-shading-course/#course_content</a><br /></li>
<li><a href="http://grephicsnerd.blogspot.com/2017/06/skin-shading-model.html">http://grephicsnerd.blogspot.com/2017/06/skin-shading-model.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3ce8d46" class="outline-3">
<h3 id="org3ce8d46">Approximate Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-org3ce8d46">
<ul class="org-ul">
<li><a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf43c2cc" class="outline-2">
<h2 id="orgf43c2cc">CLX2 Skin</h2>
<div class="outline-text-2" id="text-orgf43c2cc">
</div>
<div id="outline-container-orgda75179" class="outline-3">
<h3 id="orgda75179">BRDF</h3>
<div class="outline-text-3" id="text-orgda75179">
</div>
<div id="outline-container-orge0fe9c3" class="outline-4">
<h4 id="orge0fe9c3">Fresnel</h4>
<div class="outline-text-4" id="text-orge0fe9c3">
<p>
F 的计算中，将 5 次方转化为了 exp2 操作，来优化性能。<br />
有些 GPU 通过表查找来实现 exp2，exp2 只需要 1 条指令。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> F = specColor + <span style="color: #4f97d7;">saturate</span>(50 * specColor.g - specColor)*<span style="color: #4f97d7;">exp2</span>((-5.55473*VoH - 6.98316)*VoH);
</pre>
</div>

<ul class="org-ul">
<li>粗略判断 Shader 每条代码的成本 <a href="https://zhuanlan.zhihu.com/p/34629262">https://zhuanlan.zhihu.com/p/34629262</a><br /></li>
<li>Fresnel Equations, Schlick Approximation, Metals, and Dielectrics <a href="http://psgraphics.blogspot.com/2020/03/fresnel-equations-schlick-approximation.html">http://psgraphics.blogspot.com/2020/03/fresnel-equations-schlick-approximation.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdbfd47a" class="outline-4">
<h4 id="orgdbfd47a">D</h4>
<div class="outline-text-4" id="text-orgdbfd47a">
<p>
GGX 法线分布。使用两个粗糙度输入计算两个法线分布，最终的 D 项为 D1*1.5 + D2*0.5，因为 G 中的分母为 0.25（本应该为 0.5），所以此处 D1 和 D2 缩放因子的和为 2。<br />
Crystal 中 D 项为 D1+D2。<br />
</p>
<ul class="org-ul">
<li>D1 使用的是未缩放的粗糙度<br /></li>
<li>D2 使用了缩放后的粗糙度<br /></li>
</ul>

<p>
roughness 没用执行平方操作(即：需将 perceptualRoughness 转化为公式中使用的 roughness)<br />
</p>
</div>
</div>
<div id="outline-container-org6f72cc4" class="outline-4">
<h4 id="org6f72cc4">G</h4>
<div class="outline-text-4" id="text-org6f72cc4">
<p>
G 项和 SmithJointApprox 类似，但是系数不同。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org9d65d48" class="outline-3">
<h3 id="org9d65d48">Refract Light</h3>
<div class="outline-text-3" id="text-org9d65d48">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// normal &#20026;&#39030;&#28857;&#27861;&#32447;&#20809;&#26629;&#21270;&#25554;&#20540;&#30340;&#32467;&#26524; (&#20302;&#39057;&#27861;&#32447;)</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> RefractionNoL = <span style="color: #4f97d7;">saturate</span>(0.6 + <span style="color: #4f97d7;">dot</span>(normal, light.dir));
<span style="color: #2aa1ae; background-color: #292e34;">// attenuation &#20026;mainLight&#30340;&#38452;&#24433;&#39033;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> RefractionIrradiance = light.color * thickness * <span style="color: #7590db;">_SSSColor</span> * RefractionNoL * RefractionNoL * attenuation;
</pre>
</div>

<p>
<a href="./SkinRendering/005_clx_refract.ggb">./SkinRendering/005_clx_refract.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org6386e5e" class="outline-3">
<h3 id="org6386e5e">SSS</h3>
<div class="outline-text-3" id="text-org6386e5e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// SSS1 &#30452;&#25509;&#20351;&#29992; NoL&#23545; SSSLUT&#36827;&#34892;&#37319;&#26679;&#24471;&#21040;&#30340;&#20540;</span>

<span style="color: #2aa1ae; background-color: #292e34;">// SSS2 &#23545;&#38452;&#24433;&#36793;&#30028;&#25955;&#23556;&#30340;&#22788;&#29702;&#65292;SSS&#24378;&#24230;&#36234;&#22823;&#65292;&#38452;&#24433;&#36793;&#30028;&#21464;&#21270;&#26354;&#32447;&#36234;&#36235;&#36817;&#25243;&#29289;&#32447;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// DoL &#20026;&#27861;&#32447;&#36148;&#22270;&#20013;&#23384;&#20648;&#30340;&#27861;&#32447;&#65288;&#39640;&#39057;&#27861;&#32447;&#65289;&#19982;mainLight&#30340;&#28857;&#31215;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> LutUV2 = attenuation + (DoL-NoL) * attenuation;
<span style="color: #ce537a; font-weight: bold;">float3</span> SSS_Lut2 = <span style="color: #ce537a; font-weight: bold;">float3</span>(<span style="color: #4f97d7;">lerp</span>(<span style="color: #4f97d7;">sqrt</span>(LutUV2.r), LutUV2.r, 1 - <span style="color: #7590db;">_SSSIntensity</span>), LutUV2.rr);
SSS_Lut2 *= SSS_Lut2;
</pre>
</div>


<div id="orgdb557ec" class="figure">
<p><img src="./SkinRendering/clx_shadow_scatter.jpg" alt="clx_shadow_scatter.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org12e097a" class="outline-2">
<h2 id="org12e097a">2009 ScreenSpace Perceptual Rendering of Human Skin</h2>
<div class="outline-text-2" id="text-org12e097a">
</div>
<div id="outline-container-org59cf0fa" class="outline-3">
<h3 id="org59cf0fa">实现细节</h3>
<div class="outline-text-3" id="text-org59cf0fa">
</div>
<div id="outline-container-org009ee46" class="outline-4">
<h4 id="org009ee46">Blur Kernel width</h4>
<div class="outline-text-4" id="text-org009ee46">
<p>
Blur Kernel width 需要考虑下面两个情况<br />
</p>
<ul class="org-ul">
<li>远处的物体应该使用窄的 kernel<br /></li>
<li>depth map 中梯度变化大的也需要使用窄的 kernel<br /></li>
</ul>
<p>
使用下面的公式来实现：<br />
</p>

<div id="orga4f6e4b" class="figure">
<p><img src="./SkinRendering/007_kernel_width.jpg" alt="007_kernel_width.jpg" width="300px" /><br />
</p>
</div>

<p>
从上面公式可以看到，深度梯度增加会减小 kenel 宽度；这就限制了背景像素和 skin 像素进行卷积。在物体的边界处，深度梯度会很大，kernel 宽度就会很小。<br />
上面公式中的α值受下面一些因素影响：<br />
</p>
<ol class="org-ol">
<li>物体在 3D 空间中的尺寸<br /></li>
<li>摄像机的 FOV<br /></li>
<li>viewport size<br /></li>
</ol>

<p>
下图展示了α和β分别变化对最终渲染结果的影响：<br />
</p>

<div id="org1e89b80" class="figure">
<p><img src="./SkinRendering/007_alpha_beta_vary.jpg" alt="007_alpha_beta_vary.jpg" width="500px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BlurPS</span>(PassV2P input, <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #4f97d7;">step</span>) : SV_TARGET {
      <span style="color: #2aa1ae; background-color: #292e34;">// Gaussian weights for the six samples around the current pixel:</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//   -3 -2 -1 +1 +2 +3</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> w[6] = { 0.006,   0.061,   0.242,  0.242,  0.061, 0.006 };
      <span style="color: #ce537a; font-weight: bold;">float</span> o[6] = {  -1.0, -0.6667, -0.3333, 0.3333, 0.6667,   1.0 };

      <span style="color: #2aa1ae; background-color: #292e34;">// Fetch color and linear depth for current pixel:</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> colorM = colorTex.Sample(PointSampler, input.texcoord);
      <span style="color: #ce537a; font-weight: bold;">float</span> depthM = depthTex.Sample(PointSampler, input.texcoord);

      <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate center sample, multiplying it with its gaussian weight:</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> colorBlurred = colorM;
      colorBlurred.rgb *= 0.382;

      <span style="color: #2aa1ae; background-color: #292e34;">// Calculate the step that we will use to fetch the surrounding pixels,</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// where "step" is:</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//     step = sssStrength * gaussianWidth * pixelSize * dir</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// The closer the pixel, the stronger the effect needs to be, hence</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// the factor 1.0 / depthM.</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> finalStep = colorM.a * <span style="color: #4f97d7;">step</span> / depthM;

      <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate the other samples:</span>
      [unroll]
      <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> i = 0; i &lt; 6; i++) {
          <span style="color: #2aa1ae; background-color: #292e34;">// Fetch color and depth for current sample:</span>
          <span style="color: #ce537a; font-weight: bold;">float2</span> offset = input.texcoord + o[i] * finalStep;
          <span style="color: #ce537a; font-weight: bold;">float3</span> color = colorTex.SampleLevel(LinearSampler, offset, 0).rgb;
          <span style="color: #ce537a; font-weight: bold;">float</span> depth = depthTex.SampleLevel(PointSampler, offset, 0);

          <span style="color: #2aa1ae; background-color: #292e34;">// If the difference in depth is huge, we lerp color back to "colorM":</span>
          <span style="color: #ce537a; font-weight: bold;">float</span> s = <span style="color: #4f97d7;">min</span>(0.0125 * correction * <span style="color: #4f97d7;">abs</span>(depthM - depth), 1.0);
          color = <span style="color: #4f97d7;">lerp</span>(color, colorM.rgb, s);

          <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate:</span>
          colorBlurred.rgb += w[i] * color;
      }

      <span style="color: #2aa1ae; background-color: #292e34;">// The result will be alpha blended with current buffer by using specific</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// RGB weights. For more details, I refer you to the GPU Pro chapter :)</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> colorBlurred;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgda9828d" class="outline-4">
<h4 id="orgda9828d">渲染流程和贴图空间 SSS 的对比</h4>
<div class="outline-text-4" id="text-orgda9828d">

<div id="org8785f20" class="figure">
<p><img src="./SkinRendering/007_screenspace_sss_pipeline.jpg" alt="007_screenspace_sss_pipeline.jpg" width="300px" /><br />
</p>
</div>


<div id="org613bca0" class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline.jpg" alt="007_sssss_vs_tssss_pipeline.jpg" width="400px" /><br />
</p>
</div>


<div id="org8cd5493" class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline_02.jpg" alt="007_sssss_vs_tssss_pipeline_02.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb9f23aa" class="outline-4">
<h4 id="orgb9f23aa">缺陷</h4>
<div class="outline-text-4" id="text-orgb9f23aa">

<div id="org8090da0" class="figure">
<p><img src="./SkinRendering/007_sssss_limits.jpg" alt="007_sssss_limits.jpg" width="300px" /><br />
</p>
</div>

<ul class="org-ul">
<li>特定配置下会产生小的光晕、光环 例如，上图第一幅图鼻子和阴影接壤的地方。这是因为屏幕空间中相邻的像素在三维空间中可能并不相邻导致的。<br /></li>
<li>该算法没有考虑薄的、曲率高的地方的一些特性。 例如上图第二副图中的耳朵部位，上图第三幅图为使用 TSSSS 渲染的结果，其通过修改 Translucent Shadow Map 考虑了薄部位的特性。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4c056a5" class="outline-3">
<h3 id="org4c056a5">参考链接</h3>
<div class="outline-text-3" id="text-org4c056a5">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga65cc7a" class="outline-2">
<h2 id="orga65cc7a">2010 Real-Time Realistic Skin Translucency</h2>
<div class="outline-text-2" id="text-orga65cc7a">
</div>
<div id="outline-container-org490c578" class="outline-4">
<h4 id="org490c578">算法基于下面 4 点观察</h4>
<div class="outline-text-4" id="text-org490c578">
<ol class="org-ol">
<li>对于很多物体，我们可以对当前点的法线取反来近似背面点的法线。当正面和背面平行时，该近似是准确的。<br /></li>
<li>从背面照亮物体，我们从正面看时，观察者无法获得背面辐射照度的准确信息。<br /></li>
<li>材质的自由程很小或者几何体适度的厚时（例如：皮肤），透射是非常低频的现象。这是因为光经过物体内部时被散射，将光的大多数高频信息给消去了。<br /></li>
<li>对于人类皮肤，在表面上 albedo 不会有非常明显的变化，其维持在相似的皮肤色调上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf5d52b4" class="outline-4">
<h4 id="orgf5d52b4">基于上面 4 点观察，算法做出如下 3 点假设</h4>
<div class="outline-text-4" id="text-orgf5d52b4">
<ol class="org-ol">
<li>对正面法线取反来近似背面法线。  (基于观察 1)<br /></li>
<li>利用某种启发式方法我们可以预测背面的 Irradiance，并且很难注意到预测结果和真实结果的不同。 (基于观察 2)<br /></li>
<li>我们可以使用正面的 albedo 近似计算背面的 irradiance。（基于观察 2，4）<br />
即使我们使用高频法线来计算背面的 Irradiance，我们依然得到的是低频的透射光，因此我们假设可以使用低频法线得到近似的结果。我们使用顶点法线来计算背面的 Irradiance，而不是 normal map 中存储的法线，这样就可以舍去 Irradiance 的高频部分。此时，背面的 Irradiance 变化非常小，因此可以取单个值来近似整个卷积。(基于假设 3)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org4d11c84" class="outline-4">
<h4 id="org4d11c84">公式推导</h4>
<div class="outline-text-4" id="text-org4d11c84">

<div id="org63b3d35" class="figure">
<p><img src="./SkinRendering/008_translucent_equation.jpg" alt="008_translucent_equation.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbf243aa" class="outline-4">
<h4 id="orgbf243aa">实现细节</h4>
<div class="outline-text-4" id="text-orgbf243aa">
<p>
尽管使用取反的 Normal 来计算透射率避免了双重贡献（相对于两次都使用不取反 Normal 进行计算）。但是，使用取反 Normal 导致反射照亮区域和只受透射照亮的区域之间的过度不平滑。在过度区域，N.L 和 -N.L 都为 0。为了避免突然的照明变化，我们通过下面方式扩大透射照亮的区域：<br />
</p>

<div id="orgaad046b" class="figure">
<p><img src="./SkinRendering/008_enlarge_translucent_range.jpg" alt="008_enlarge_translucent_range.jpg" width="200px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">distance</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> posW, <span style="color: #ce537a; font-weight: bold;">float3</span> normalW, <span style="color: #ce537a; font-weight: bold;">int</span> i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Shrink the position to avoid artifacts on the silhouette:</span>
    posW = posW - 0.005 * normalW;

    <span style="color: #2aa1ae; background-color: #292e34;">// Transform to light space:</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> posL = <span style="color: #4f97d7;">mul</span>(<span style="color: #ce537a; font-weight: bold;">float4</span>(posW, 1.0), lights[i].viewproj);

    <span style="color: #2aa1ae; background-color: #292e34;">// Fetch depth from the shadow map:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// (Depth from shadow maps is expected to be linear)</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> d1 = shwmaps[i].Sample(<span style="color: #ce537a; font-weight: bold;">sampler</span>, posL.xy / posL.w);
    <span style="color: #ce537a; font-weight: bold;">float</span> d2 = posL.z;

    <span style="color: #2aa1ae; background-color: #292e34;">// Calculate the difference:</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">abs</span>(d1 - d2);
}
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">T</span>(<span style="color: #ce537a; font-weight: bold;">float</span> s) 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float3</span>(0.233, 0.455, 0.649) * <span style="color: #4f97d7;">exp</span>(-s*s/0.0064) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.1, 0.336, 0.344) * <span style="color: #4f97d7;">exp</span>(-s*s/0.0484) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.118, 0.198, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/0.187) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.113, 0.007, 0.007) * <span style="color: #4f97d7;">exp</span>(-s*s/0.567) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.358, 0.004, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/1.99) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.078, 0.0, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/7.41);
}
<span style="color: #ce537a; font-weight: bold;">float</span> s = scale * <span style="color: #4f97d7;">distance</span>(pos, Nvertex, i);
<span style="color: #ce537a; font-weight: bold;">float</span> E = <span style="color: #4f97d7;">max</span>(0.3 + <span style="color: #4f97d7;">dot</span>(-Nvertex, L), 0.0);
<span style="color: #ce537a; font-weight: bold;">float3</span> transmittance = T(s) * lights[i].color * attenuation * albedo.rgb * E;
<span style="color: #2aa1ae; background-color: #292e34;">// We add the contribution of this light</span>
M += transmittance + reflectance;
</pre>
</div>
</div>
</div>
<div id="outline-container-org4e82d26" class="outline-3">
<h3 id="org4e82d26">参考链接</h3>
<div class="outline-text-3" id="text-org4e82d26">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcae6b48" class="outline-2">
<h2 id="orgcae6b48"><span class="todo TODO">TODO</span> 2015 Separable-SSS</h2>
<div class="outline-text-2" id="text-orgcae6b48">
<p>
该论文提到出了两类方法，都只需要两个 1D 的卷积操作。第一类可以得出高质量的模拟效果，第二类则在效果和易操作性上做了权衡。<br />
论文发现，可以精确模拟 diffusion 的 kernels 通常在数学上是不可分离的，但是可以使用 low-rank factorization(低秩分解)来重建。下图展示了对模拟皮肤次表面散射的 diffuse reflectance profile 进行奇异值分解后，奇异值的衰减情况。从图可以看出，只有和前几个奇异值相关的分量对 profile 的重建有明显贡献。这使得低秩近似是可行的。<br />
</p>

<div id="org20df231" class="figure">
<p><img src="./SkinRendering/separable-sss-01.jpg" alt="separable-sss-01.jpg" width="300px" /><br />
</p>
</div>
</div>

<div id="outline-container-org332ca80" class="outline-3">
<h3 id="org332ca80">参考链接</h3>
<div class="outline-text-3" id="text-org332ca80">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga710e72" class="outline-2">
<h2 id="orga710e72"><span class="todo TODO">TODO</span> 2018 Unity Efficient screen space subsurface scattering</h2>
<div class="outline-text-2" id="text-orga710e72">
</div>
<div id="outline-container-orgdbd37c7" class="outline-3">
<h3 id="orgdbd37c7">参考链接</h3>
<div class="outline-text-3" id="text-orgdbd37c7">
<ul class="org-ul">
<li>Cross Bilateral Filter <a href="http://techtidings.blogspot.com/2012/03/jointcross-bilateral-filter.html">http://techtidings.blogspot.com/2012/03/jointcross-bilateral-filter.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2221ce4" class="outline-2">
<h2 id="org2221ce4">Misc</h2>
<div class="outline-text-2" id="text-org2221ce4">
</div>
<div id="outline-container-orgf1cd9d5" class="outline-3">
<h3 id="orgf1cd9d5">Normal Map Mipmap</h3>
<div class="outline-text-3" id="text-orgf1cd9d5">
<p>
该文件展示了 normal map 的混合：<br />
<a href="./SkinRendering/111_normal_map_lerp.ggb">./SkinRendering/111_normal_map_lerp.ggb</a><br />
</p>

<ul class="org-ul">
<li>Normal Map Mipmap <a href="https://www.jianshu.com/p/efabea28ed1a">https://www.jianshu.com/p/efabea28ed1a</a><br /></li>
<li>Mipmapping_Normal_Maps <a href="https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf">https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN video <a href="https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN">https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN ppt <a href="https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html">https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd138c14" class="outline-3">
<h3 id="orgd138c14">NoLWrap</h3>
<div class="outline-text-3" id="text-orgd138c14">
<p>
下面文件展示了 nol wrap 的曲线：<br />
<a href="./SkinRendering/111_nol_wrap.ggb">./SkinRendering/111_nol_wrap.ggb</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org206f89e" class="outline-2">
<h2 id="org206f89e">参考资料</h2>
<div class="outline-text-2" id="text-org206f89e">
<ul class="org-ul">
<li>《GPU Gems 3》：真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
<li>低成本皮肤渲染 Pre-integrated Skin <a href="https://zhuanlan.zhihu.com/p/35628106">https://zhuanlan.zhihu.com/p/35628106</a><br /></li>
<li>Pre-Integrated Skin <a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
<li>separable-sss <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
<li>GPU Gem3 Advanced Techniques for Realistic Real-Time Skin Rendering<br /></li>
<li>GPU Pro 1 Screen-Space Subsurface Scattering<br /></li>
<li>GPU Pro 2 Part2 Chapter1 Pre-Integrated Skin Shading<br /></li>
<li>GPU Pro 5 Part4 Chapter1 Realistic Real-Time Skin Rendering on Mobile<br /></li>
<li>SoulShell：实时虚拟角色 <a href="https://zhuanlan.zhihu.com/soulshell">https://zhuanlan.zhihu.com/soulshell</a><br /></li>
<li>天刀渲染 <a href="https://zhuanlan.zhihu.com/p/295347623?utm_source=com.alibaba.android.rimet">https://zhuanlan.zhihu.com/p/295347623?utm_source=com.alibaba.android.rimet</a><br /></li>
<li>sss-intro <a href="https://therealmjp.github.io/posts/sss-intro/">https://therealmjp.github.io/posts/sss-intro/</a><br /></li>
<li>Exploring Character Art Workflows: Skin Texturing Tips <a href="https://80.lv/articles/exploring-character-art-workflows-skin-texturing-tips/">https://80.lv/articles/exploring-character-art-workflows-skin-texturing-tips/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'Skin Rendering',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
