<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-01-04 周一 21:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Skin Rendering</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">Skin Rendering</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org71520ae">皮肤医学结构</a>
<ul>
<li><a href="#orgf503ad1">表皮的分层</a>
<ul>
<li><a href="#org3ac622f">角质层 Stratum corneum</a></li>
<li><a href="#orgaaa047b">透明层 Stratum lucidum</a></li>
<li><a href="#org1982927">颗粒层 Stratum granulosum</a></li>
<li><a href="#orge43e7e4">棘层 Stratum spinosum</a></li>
<li><a href="#org6962c1b">基底层 Stratum basale</a></li>
</ul>
</li>
<li><a href="#orgb93d9a3">皮肤结构图</a></li>
</ul>
</li>
<li><a href="#org34a6102">Gem3Skin</a>
<ul>
<li><a href="#org1944b7c">实现总结</a>
<ul>
<li><a href="#orgcea80d2">高光</a></li>
<li><a href="#orgb126fb3">Diffuse</a>
<ul>
<li><a href="#orgf5d2b31">计算 RhodtTexture，</a></li>
<li><a href="#org0b05dff">计算 IrradianceTexture</a></li>
<li><a href="#orgcb0545b">计算 StretchCorrectionTexture</a></li>
<li><a href="#org8554912">计算 SeamMaskTexture</a></li>
<li><a href="#orga9f170f">对 StretchTexture 和 IrradianceTexture 进行模糊</a>
<ul>
<li><a href="#orgb98cf9d">高斯模糊近似 R(d)函数</a></li>
<li><a href="#org22ecd55">代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc098b3b">参考资料</a>
<ul>
<li><a href="#orga284d87">高斯卷积核求解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf6999f3">Pre-Intergrating the Effects of Scattering</a>
<ul>
<li><a href="#org51ed167">Pre-integrating the Effect of Scattering</a></li>
<li><a href="#org7e4d0e1">Scattering and Diffuse Light</a></li>
<li><a href="#org84b60ba">Scattering and Normal Maps</a></li>
<li><a href="#org1cbe758">Shadow Scattering</a></li>
</ul>
</li>
<li><a href="#org1987432">Improve Pre-Intergrating</a>
<ul>
<li><a href="#orga214670">Env Light Pre-Intergrating Scattering</a></li>
<li><a href="#orgc23e589">Approximate Pre-Intergrating Scattering</a></li>
</ul>
</li>
<li><a href="#org44d4c67">CLX2 Skin</a>
<ul>
<li><a href="#org53b9012">refract light</a></li>
</ul>
</li>
<li><a href="#org178c317">ScreenSpace Perceptual Rendering of Human Skin</a>
<ul>
<li><a href="#orgc8a05d9">实现细节</a>
<ul>
<li><a href="#orgecc29e1">Blur Kernel width</a></li>
<li><a href="#org6079ebb">渲染流程和贴图空间 SSS 的对比</a></li>
<li><a href="#org58c26c2">缺陷</a></li>
</ul>
</li>
<li><a href="#org104b590">参考链接</a></li>
</ul>
</li>
<li><a href="#orge77cd14">Misc</a>
<ul>
<li><a href="#orgb343e8d">Normal Map Mipmap</a></li>
<li><a href="#orge46b232">NoLWrap</a></li>
</ul>
</li>
<li><a href="#orga4f1103">参考资料</a></li>
</ul>
</div>
</div>
<p>
Skin Rendering note.<br />
</p>
<div class="HTML">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org71520ae" class="outline-2">
<h2 id="org71520ae">皮肤医学结构</h2>
<div class="outline-text-2" id="text-org71520ae">
<p>
皮肤分为 表皮 epidermis，真皮 dermis 和皮下组织 subcutaneous tissue<br />
</p>
</div>
<div id="outline-container-orgf503ad1" class="outline-3">
<h3 id="orgf503ad1">表皮的分层</h3>
<div class="outline-text-3" id="text-orgf503ad1">
</div>
<div id="outline-container-org3ac622f" class="outline-4">
<h4 id="org3ac622f">角质层 Stratum corneum</h4>
<div class="outline-text-4" id="text-org3ac622f">
<p>
位于表皮的最外层，由 5-20 层的扁平无核细胞组成，胞内细胞器结构消失，充满角蛋白。<br />
</p>
</div>
</div>
<div id="outline-container-orgaaa047b" class="outline-4">
<h4 id="orgaaa047b">透明层 Stratum lucidum</h4>
<div class="outline-text-4" id="text-orgaaa047b">
<p>
仅见于掌跖。由 2-3 层扁平无核细胞组成。<br />
</p>
</div>
</div>
<div id="outline-container-org1982927" class="outline-4">
<h4 id="org1982927">颗粒层 Stratum granulosum</h4>
<div class="outline-text-4" id="text-org1982927">
<p>
由 2-4 层梭形细胞组成，细胞内含有透明角质颗粒。<br />
</p>
</div>
</div>
<div id="outline-container-orge43e7e4" class="outline-4">
<h4 id="orge43e7e4">棘层 Stratum spinosum</h4>
<div class="outline-text-4" id="text-orge43e7e4">
<p>
由 4-10 层多角形细胞组成，细胞间桥明显呈棘状。<br />
</p>
</div>
</div>
<div id="outline-container-org6962c1b" class="outline-4">
<h4 id="org6962c1b">基底层 Stratum basale</h4>
<div class="outline-text-4" id="text-org6962c1b">
<p>
位于表皮的最下层，为一层立方形或圆柱状细胞，细胞的长轴与基底膜带垂直，胞核呈卵圆形，胞浆内含有黑素颗粒，核分裂象常见。<br />
具有不断分裂增殖的能力，因此又称为生发层。由基底层移行至颗粒层最上层约需 14 天，再移行至角质层表面脱落又需 14 天，称为表皮通过时间。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb93d9a3" class="outline-3">
<h3 id="orgb93d9a3">皮肤结构图</h3>
<div class="outline-text-3" id="text-orgb93d9a3">
<p>
<img src="SkinRendering/001_Skin_Structure_Image_01.jpg" alt="001_Skin_Structure_Image_01.jpg" /><br />
<img src="SkinRendering/001_Skin_Structure_Image_02.jpg" alt="001_Skin_Structure_Image_02.jpg" /><br />
</p>

<ul class="org-ul">
<li>皮肤结构 <a href="http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx">http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx</a><br /></li>
<li>皮肤的结构-表皮 <a href="http://www.truebuty.com/scstructure.html">http://www.truebuty.com/scstructure.html</a><br /></li>
<li><a href="https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/">https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org34a6102" class="outline-2">
<h2 id="org34a6102">Gem3Skin</h2>
<div class="outline-text-2" id="text-org34a6102">
<ul class="org-ul">
<li>原文链接 Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
</ul>
</div>
<div id="outline-container-org1944b7c" class="outline-3">
<h3 id="org1944b7c">实现总结</h3>
<div class="outline-text-3" id="text-org1944b7c">
</div>
<div id="outline-container-orgcea80d2" class="outline-4">
<h4 id="orgcea80d2">高光</h4>
<div class="outline-text-4" id="text-orgcea80d2">
<p>
高光使用了基于物理的 BRDF，为了加速计算，对 BRDF 进行了预计算。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">PHBeckmann</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">nDotH</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">roughness</span>)
{
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">alpha</span> = acos(nDotH);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ta</span> = tan(alpha);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">r2</span> = roughness * roughness;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">val</span> = 1.0 / (r2*pow(nDotH, 4.0))*exp(-(ta*ta) / r2);
  <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5*pow(val, 0.1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb126fb3" class="outline-4">
<h4 id="orgb126fb3">Diffuse</h4>
<div class="outline-text-4" id="text-orgb126fb3">
</div>
<div id="outline-container-orgf5d2b31" class="outline-5">
<h5 id="orgf5d2b31">计算 RhodtTexture，</h5>
<div class="outline-text-5" id="text-orgf5d2b31">
<p>
计算 BRDF 在半球空间的积分，得到剩余的被散射的比例。<br />
</p>
</div>
</div>

<div id="outline-container-org0b05dff" class="outline-5">
<h5 id="org0b05dff">计算 IrradianceTexture</h5>
<div class="outline-text-5" id="text-org0b05dff">
<p>
在贴图空间，计算被散射的能量。渲染模型，结果按照模型 UV 输出（这就是所谓的贴图空间渲染）。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
<span style="color: #bc6ec5;">    #if</span> UNITY_UV_STARTS_AT_TOP
    o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>((v.uv0 * 2 - 1)*<span style="color: #ce537a; font-weight: bold;">float2</span>(1,-1), 0, 1);
<span style="color: #bc6ec5;">    #else</span>
    o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.uv0 * 2 - 1, 0, 1);
<span style="color: #bc6ec5;">    #endif</span>
    o.tex = v.uv0;
    o.posWorld = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
    o.eyeVec.xyz = <span style="color: #7590db;">_WorldSpaceCameraPos</span> - o.posWorld.xyz;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb0545b" class="outline-5">
<h5 id="orgcb0545b">计算 StretchCorrectionTexture</h5>
<div class="outline-text-5" id="text-orgcb0545b">
<p>
在贴图空间，矫正贴图空间的模糊(曲率比较大的地方，相邻点的空间距离比其贴图上的距离要小)<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21516;&#26679;&#26159;&#22312;&#36148;&#22270;&#31354;&#38388;&#36827;&#34892;&#35745;&#31639;&#65292;&#24471;&#21040;&#36148;&#22270;&#34987;&#25289;&#20280;&#30340;&#31243;&#24230;(&#20854;&#23454;&#20063;&#26159;&#27169;&#22411;&#26412;&#36523;&#30340;&#26354;&#29575;)</span>
<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> posWorld = i.posWorld;
    <span style="color: #ce537a; font-weight: bold;">float3</span> derivU = <span style="color: #4f97d7;">ddx</span>(posWorld);
    <span style="color: #ce537a; font-weight: bold;">float3</span> derivV = <span style="color: #4f97d7;">ddy</span>(posWorld);
    <span style="color: #ce537a; font-weight: bold;">float</span> stretchU = 1 / <span style="color: #4f97d7;">length</span>(derivU) * <span style="color: #7590db;">_StretchScale</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> stretchV = 1 / <span style="color: #4f97d7;">length</span>(derivV) * <span style="color: #7590db;">_StretchScale</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(stretchU, stretchV, 0, 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8554912" class="outline-5">
<h5 id="org8554912">计算 SeamMaskTexture</h5>
<div class="outline-text-5" id="text-org8554912">
<p>
在贴图空间，将所有 StretchTexture 的 alpha 通道相乘得到 SeamMask<br />
</p>
</div>
</div>
<div id="outline-container-orga9f170f" class="outline-5">
<h5 id="orga9f170f">对 StretchTexture 和 IrradianceTexture 进行模糊</h5>
<div class="outline-text-5" id="text-orga9f170f">
<p>
在贴图空间，对 IrradianceTexture 进行高斯模糊来模拟散射。一共使用 6 个高斯函数，RGB 通道使用不同的权重。6个高斯函数近似 multi-dipole profiles<br />
</p>
</div>
<div id="outline-container-orgb98cf9d" class="outline-6">
<h6 id="orgb98cf9d">高斯模糊近似 R(d)函数</h6>
<div class="outline-text-6" id="text-orgb98cf9d">
<p>
R(d)<sub>r</sub> = 0.078*G(sqrt(7.41), d) + 0.358*G(sqrt(1.99), d) + 0.113*G(sqrt(7.41), d) + 0.118*G(sqrt(0.358), d) + 0.100*G(sqrt(0.0484), d) + 0.233*G(sqrt(0.0064), d);<br />
<img src="./SkinRendering/002_gaussian_approx_rd_001.jpg" alt="002_gaussian_approx_rd_001.jpg" /><br />
<img src="./SkinRendering/002_gaussian_approx_rd_002.jpg" alt="002_gaussian_approx_rd_002.jpg" /><br />
下面文件为一维高斯函数图形：<br />
<a href="./SkinRendering/002_gaussian_function.ggb">./SkinRendering/002_gaussian_function.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org22ecd55" class="outline-6">
<h6 id="org22ecd55">代码实现</h6>
<div class="outline-text-6" id="text-org22ecd55">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#36148;&#22270;&#31354;&#38388;&#65292;&#20808;&#23545;StretchTexture&#36827;&#34892;&#27169;&#31946;&#65292;&#28982;&#21518;&#20877;&#23545;IrradianceTexture&#36827;&#34892;&#27169;&#31946;</span>
<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float</span> scale = <span style="color: #7590db;">_MainTex_TexelSize</span>.x * <span style="color: #7590db;">_GaussianWidth</span> / <span style="color: #7590db;">_BlurStepScale</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvDelta = <span style="color: #ce537a; font-weight: bold;">float2</span>(scale, 0.0);
<span style="color: #bc6ec5;">    #if</span> defined(CONV_V)
        uvDelta.xy = uvDelta.yx;
<span style="color: #bc6ec5;">        #if</span> defined(ENABLE_STRETCH_CORRECTION)
            uvDelta.y *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).y;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #if</span> defined(ENABLE_STRETCH_CORRECTION)
            uvDelta.x *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).x;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> coords = i.uv - uvDelta*3.0;
    <span style="color: #ce537a; font-weight: bold;">float4</span> sum = 0.0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26399;&#26395;&#20026;0&#65292;&#26631;&#20934;&#24046;&#20026;1 &#30340;&#39640;&#26031;&#20989;&#25968;&#31163;&#25955;&#30340;&#20989;&#25968;&#20540;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> curve[7] = { 0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006 };
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> j = 0; j &lt; 7; j++)
    {
        <span style="color: #ce537a; font-weight: bold;">float4</span> tap = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, coords);
        sum += curve[j] * tap;
        coords += uvDelta;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> sum;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc098b3b" class="outline-3">
<h3 id="orgc098b3b">参考资料</h3>
<div class="outline-text-3" id="text-orgc098b3b">
<ul class="org-ul">
<li>Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
<li>角色渲染技术——皮肤 <a href="https://zhuanlan.zhihu.com/p/27014447">https://zhuanlan.zhihu.com/p/27014447</a><br /></li>
<li>GPU Gems 3 真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
</ul>
</div>
<div id="outline-container-orga284d87" class="outline-4">
<h4 id="orga284d87">高斯卷积核求解</h4>
<div class="outline-text-4" id="text-orga284d87">
<ul class="org-ul">
<li>如何通俗易懂地解释卷积？  <a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a><br /></li>
<li>Gaussian filter, or Gaussian blur <a href="http://www.librow.com/articles/article-9">http://www.librow.com/articles/article-9</a><br /></li>
<li>高斯函数 <a href="https://www.zhihu.com/question/33214189">https://www.zhihu.com/question/33214189</a><br /></li>
<li>理解图像卷积操作的意义 <a href="https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1">https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1</a><br /></li>
<li>高斯卷积核计算器 <a href="http://dev.theomader.com/gaussian-kernel-calculator/">http://dev.theomader.com/gaussian-kernel-calculator/</a><br /></li>
<li>将 2D 卷积核转化为 1D <a href="https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/">https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/</a><br /></li>
<li>2D GaussianBlur To 1D <a href="https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur">https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf6999f3" class="outline-2">
<h2 id="orgf6999f3">Pre-Intergrating the Effects of Scattering</h2>
<div class="outline-text-2" id="text-orgf6999f3">
</div>
<div id="outline-container-org51ed167" class="outline-3">
<h3 id="org51ed167">Pre-integrating the Effect of Scattering</h3>
<div class="outline-text-3" id="text-org51ed167">
<p>
我们没有通过收集渲染位置处所有方向的入射光来实现次表面散射。而是探索预积分皮肤中的次表面散射效果。<br />
只有三件事情会引入可见的散射：<br />
</p>
<ol class="org-ol">
<li>模型曲率的变化<br /></li>
<li>normal map 中的突起<br /></li>
<li>遮挡光导致的阴影<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org7e4d0e1" class="outline-3">
<h3 id="org7e4d0e1">Scattering and Diffuse Light</h3>
<div class="outline-text-3" id="text-org7e4d0e1">
<p>
nDotL 是主要导致入射光变化的原因，其使得散射变得明显。<br />
我们考虑通过球谐光照模拟所有方向上的光，以此来预计算表面上任意一点的散射光效果。但是球谐方式只能高效地表示低频率变化的光，对于高频变化的光需要很多系数。因此，我们放弃了预计算散射效果，而选择预计算表面形状子集的散射衰减，并在渲染时确定最好的衰减.<br />
我们在运行时可以计算表面的曲率，其最大程度决定了光滑表面的散射效果。<br />
为了测量曲面上的散射，我们添加了曲率作为第二个参数。我们简单从一个方向照射给定曲率的球面，并测量各个角度上累计的光照。<br />
下图为散射光公式推导：<br />
<img src="./SkinRendering/004_scatter_factor_equation.jpg" alt="004_scatter_factor_equation.jpg" /><br />
</p>

<p>
当前模型假设所有的皮肤和球相似，但是皮肤可以为任意拓扑结构。换句话说，当前模型假设给定点的散射由该点自身的曲率决定，而事实上是由该点周围所有点的曲率决定。因此，该模型在平滑的表面上(曲率变化不大的表面上)效果可以，但是曲率变化比较大时，就不适用了。幸运的是，大多数皮肤模型都有两层：使用几何表示光滑的表面，使用 normal map 表示表面细节。<br />
</p>

<ul class="org-ul">
<li>如何简明地解释曲率（curvature）？ <a href="https://www.zhihu.com/question/25952605">https://www.zhihu.com/question/25952605</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org84b60ba" class="outline-3">
<h3 id="org84b60ba">Scattering and Normal Maps</h3>
<div class="outline-text-3" id="text-org84b60ba">
<p>
皮肤上小的皱纹、毛孔通常通过 normal map 来表示。小折痕的法线总是会返回表面主法线，因此从小折痕反射的散射光和不散射表面上折痕更宽的地方反射的光看起来很像。因此可以通过模糊 normal 来近似皱纹、毛孔等小褶皱照成的散射。对于不同波长的光，diffusion profiles 不同，模糊 normal 的方式也不同。<br />
</p>

<p>
从实际的物体抓取 normal 贴图时，发现 normal 会向表面法线偏转，而且不同波长的光偏转程度不同，红光比绿光偏转程度大。还观察到使用多个波长的光抓取的多个 normal 进行渲染要比使用单个 normal 效果要好。<br />
我们的做法为，假定原始的 normal map 是精确的表面法线，对其进行 blur 而得到每个波长对应的 normal。因此，不能为了得到更光滑的效果，而直接提供 blur 过的 normal map 做原始的 normal map，否则再对其进行 blur 得到的每个波长的 normal 将不正确。<br />
使用 diffusion profile 直接对 normal map 进行 blur 是不可行的，因为光照对于表面法线不是线性过程。需要使用 LEAN 或 CLEAN。<br />
</p>

<p>
值得注意的是，在法线贴图的过滤区域内，当法线的自阴影/入射光/散射光项为常数时，使用非归一化的 normal 是一个可行的近似，此时我们有如下关系式：<br />
<img src="./SkinRendering/004_normal_filter_001.jpg" alt="004_normal_filter_001.jpg" /><br />
上面关系式不是总成立的，因为 diffuse lighting 包含一个自阴影项 max(0, N.L)来取代上式中的 N.L。尽管如此，当法线过滤区域内都没阴影或都有阴影时，使用非归一化的法线依然是正确的。<br />
</p>

<p>
我们开发了一种近似的方法，其只用一张包含 mipmap 的法线贴图。使用该优化方法时，specular normal 的采样依然不变，但同时使用另一个采样器采样高一级的 mipmap 得到 red normal。然后将 specular normal 和 red normal 变换到 tangent 空间，对他们进行混合得到 green 和 blue normal。最后的 diffuse-lighting 计算需要执行三次。<br />
</p>

<p>
如果法线贴图只包含很小的细节，甚至可以使用几何法线来代替 red normal。<br />
</p>
</div>
</div>
<div id="outline-container-org1cbe758" class="outline-3">
<h3 id="org1cbe758">Shadow Scattering</h3>
<div class="outline-text-3" id="text-org1cbe758">
<p>
光散射到阴影是真实感皮肤的重要特性之一。使用一点小技巧就可以预计算阴影边界上的散射效果。<br />
</p>

<p>
我们可以将阴影映射算法当作一个衰减函数。当衰减为完全黑或完全白，对应着完全遮挡和完全不遮挡。我们可以重新设置完全黑和完全白之间的值。特别地，如果我们确定我们的阴影过滤器创建的半影尺寸足够容纳大部分的 diffusion profile，我们可以缩小原始半影的尺寸，多出来的尺寸用于基于 diffusion profile 的散射。<br />
<img src="./SkinRendering/004_shadow_scatter.jpg" alt="004_shadow_scatter.jpg" /><br />
<img src="./SkinRendering/004_shadow_scatter_equation.jpg" alt="004_shadow_scatter_equation.jpg" /><br />
</p>

<p>
为了计算精确的衰减，我们将阴影半影和 diffusion profile 进行预积分。我们将阴影半影 P()定义为一个一维衰减函数，该函数来自于使用阴影贴图映射的 blur kernel 对硬阴影边界的过滤。假定阴影映射的 kernel 为单调递减的，则对应的衰减函数也是单调递减，这样就可以对阴影半影 P()求反函数 \(P^{-1}()\) 。这样就可以通过给定的阴影值获得对应的半影中的位置。例如，如果阴影映射为 BoxFilter，则阴影半影函数 P()就是一个线性的斜坡，此时对应的反函数 \(P^{-1}()\) 也是一个线性的斜坡。<br />
</p>

<p>
我们假定了阴影是透射在一个平面上的，如果表面倾斜度很大，半影尺寸将比我们预计算时使用的值大很多。因此，我们为阴影衰减贴图增加了第二个维度，其表示世界空间中的半影尺寸。最后，我们生成阴影 LUT 的公式如下：<br />
</p>

<p>
半影宽度可以通过表面和对应光源的夹角得到，或者直接对阴影值进行求导。<br />
当半影拉升到倾斜度高的表面时，此时提供了散射衰减空间更大。此时，可以对半影宽度值进行截取，保证其在 LUT 贴图范围内。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1987432" class="outline-2">
<h2 id="org1987432">Improve Pre-Intergrating</h2>
<div class="outline-text-2" id="text-org1987432">
</div>
<div id="outline-container-orga214670" class="outline-3">
<h3 id="orga214670">Env Light Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-orga214670">
<ul class="org-ul">
<li><a href="https://blog.selfshadow.com/publications/s2013-shading-course/#course_content">https://blog.selfshadow.com/publications/s2013-shading-course/#course_content</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc23e589" class="outline-3">
<h3 id="orgc23e589">Approximate Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-orgc23e589">
<ul class="org-ul">
<li><a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org44d4c67" class="outline-2">
<h2 id="org44d4c67">CLX2 Skin</h2>
<div class="outline-text-2" id="text-org44d4c67">
</div>
<div id="outline-container-org53b9012" class="outline-3">
<h3 id="org53b9012">refract light</h3>
<div class="outline-text-3" id="text-org53b9012">
<p>
<a href="./SkinRendering/005_clx_refract.ggb">./SkinRendering/005_clx_refract.ggb</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org178c317" class="outline-2">
<h2 id="org178c317">ScreenSpace Perceptual Rendering of Human Skin</h2>
<div class="outline-text-2" id="text-org178c317">
</div>
<div id="outline-container-orgc8a05d9" class="outline-3">
<h3 id="orgc8a05d9">实现细节</h3>
<div class="outline-text-3" id="text-orgc8a05d9">
</div>
<div id="outline-container-orgecc29e1" class="outline-4">
<h4 id="orgecc29e1">Blur Kernel width</h4>
<div class="outline-text-4" id="text-orgecc29e1">
<p>
Blur Kernel width 需要考虑下面两个情况<br />
</p>
<ul class="org-ul">
<li>远处的物体应该使用窄的 kernel<br /></li>
<li>depth map 中梯度变化大的也需要使用窄的 kernel<br /></li>
</ul>
<p>
使用下面的公式来实现：<br />
<img src="./SkinRendering/007_kernel_width.jpg" alt="007_kernel_width.jpg" /><br />
</p>

<p>
从上面公式可以看到，深度梯度增加会减小 kenel 宽度；这就限制了背景像素和 skin 像素进行卷积。在物体的边界处，深度梯度会很大，kernel 宽度就会很小。<br />
上面公式中的α值受下面一些因素影响：<br />
</p>
<ol class="org-ol">
<li>物体在 3D 空间中的尺寸<br /></li>
<li>摄像机的 FOV<br /></li>
<li>viewport size<br /></li>
</ol>

<p>
下图展示了α和β分别变化对最终渲染结果的影响：<br />
<img src="./SkinRendering/007_alpha_beta_vary.jpg" alt="007_alpha_beta_vary.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BlurPS</span>(PassV2P input, <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #4f97d7;">step</span>) : SV_TARGET {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Gaussian weights for the six samples around the current pixel:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">-3 -2 -1 +1 +2 +3</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> w[6] = { 0.006,   0.061,   0.242,  0.242,  0.061, 0.006 };
    <span style="color: #ce537a; font-weight: bold;">float</span> o[6] = {  -1.0, -0.6667, -0.3333, 0.3333, 0.6667,   1.0 };

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fetch color and linear depth for current pixel:</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> colorM = colorTex.Sample(PointSampler, input.texcoord);
    <span style="color: #ce537a; font-weight: bold;">float</span> depthM = depthTex.Sample(PointSampler, input.texcoord);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Accumulate center sample, multiplying it with its gaussian weight:</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> colorBlurred = colorM;
    colorBlurred.rgb *= 0.382;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Calculate the step that we will use to fetch the surrounding pixels,</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">where "step" is:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//     </span><span style="color: #2aa1ae; background-color: #292e34;">step = sssStrength * gaussianWidth * pixelSize * dir</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">The closer the pixel, the stronger the effect needs to be, hence</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the factor 1.0 / depthM.</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> finalStep = colorM.a * <span style="color: #4f97d7;">step</span> / depthM;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Accumulate the other samples:</span>
    [unroll]
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> i = 0; i &lt; 6; i++) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fetch color and depth for current sample:</span>
        <span style="color: #ce537a; font-weight: bold;">float2</span> offset = input.texcoord + o[i] * finalStep;
        <span style="color: #ce537a; font-weight: bold;">float3</span> color = colorTex.SampleLevel(LinearSampler, offset, 0).rgb;
        <span style="color: #ce537a; font-weight: bold;">float</span> depth = depthTex.SampleLevel(PointSampler, offset, 0);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">If the difference in depth is huge, we lerp color back to "colorM":</span>
        <span style="color: #ce537a; font-weight: bold;">float</span> s = <span style="color: #4f97d7;">min</span>(0.0125 * correction * <span style="color: #4f97d7;">abs</span>(depthM - depth), 1.0);
        color = <span style="color: #4f97d7;">lerp</span>(color, colorM.rgb, s);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Accumulate:</span>
        colorBlurred.rgb += w[i] * color;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">The result will be alpha blended with current buffer by using specific</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">RGB weights. For more details, I refer you to the GPU Pro chapter :)</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> colorBlurred;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6079ebb" class="outline-4">
<h4 id="org6079ebb">渲染流程和贴图空间 SSS 的对比</h4>
<div class="outline-text-4" id="text-org6079ebb">

<div class="figure">
<p><img src="./SkinRendering/007_screenspace_sss_pipeline.jpg" alt="007_screenspace_sss_pipeline.jpg" /><br />
</p>
</div>


<div class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline.jpg" alt="007_sssss_vs_tssss_pipeline.jpg" /><br />
</p>
</div>


<div class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline_02.jpg" alt="007_sssss_vs_tssss_pipeline_02.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org58c26c2" class="outline-4">
<h4 id="org58c26c2">缺陷</h4>
<div class="outline-text-4" id="text-org58c26c2">

<div class="figure">
<p><img src="./SkinRendering/007_sssss_limits.jpg" alt="007_sssss_limits.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li>特定配置下会产生小的光晕、光环 例如，上图第一幅图鼻子和阴影接壤的地方。这是因为屏幕空间中相邻的像素在三维空间中可能并不相邻导致的。<br /></li>
<li>该算法没有考虑薄的、曲率高的地方的一些特性。 例如上图第二副图中的耳朵部位，上图第三幅图为使用 TSSSS 渲染的结果，其通过修改 Translucent Shadow Map 考虑了薄部位的特性。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org104b590" class="outline-3">
<h3 id="org104b590">参考链接</h3>
<div class="outline-text-3" id="text-org104b590">
<ul class="org-ul">
<li><a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li><a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge77cd14" class="outline-2">
<h2 id="orge77cd14">Misc</h2>
<div class="outline-text-2" id="text-orge77cd14">
</div>
<div id="outline-container-orgb343e8d" class="outline-3">
<h3 id="orgb343e8d">Normal Map Mipmap</h3>
<div class="outline-text-3" id="text-orgb343e8d">
<p>
该文件展示了 normal map 的混合：<br />
<a href="./SkinRendering/111_normal_map_lerp.ggb">./SkinRendering/111_normal_map_lerp.ggb</a><br />
</p>

<ul class="org-ul">
<li>Normal Map Mipmap <a href="https://www.jianshu.com/p/efabea28ed1a">https://www.jianshu.com/p/efabea28ed1a</a><br /></li>
<li>Mipmapping_Normal_Maps <a href="https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf">https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN video <a href="https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN">https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN ppt <a href="https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html">https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge46b232" class="outline-3">
<h3 id="orge46b232">NoLWrap</h3>
<div class="outline-text-3" id="text-orge46b232">
<p>
下面文件展示了 nol wrap 的曲线：<br />
<a href="./SkinRendering/111_nol_wrap.ggb">./SkinRendering/111_nol_wrap.ggb</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orga4f1103" class="outline-2">
<h2 id="orga4f1103">参考资料</h2>
<div class="outline-text-2" id="text-orga4f1103">
<ul class="org-ul">
<li>《GPU Gems 3》：真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
<li>低成本皮肤渲染 Pre-integrated Skin <a href="https://zhuanlan.zhihu.com/p/35628106">https://zhuanlan.zhihu.com/p/35628106</a><br /></li>
<li>Pre-Integrated Skin <a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
<li>separable-sss <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
<li>GPU Gem3 Advanced Techniques for Realistic Real-Time Skin Rendering<br /></li>
<li>GPU Pro 1 Screen-Space Subsurface Scattering<br /></li>
<li>GPU Pro 2 Part2 Chapter1 Pre-Integrated Skin Shading<br /></li>
<li>GPU Pro 5 Part4 Chapter1 Realistic Real-Time Skin Rendering on Mobile<br /></li>
<li>SoulShell：实时虚拟角色 <a href="https://zhuanlan.zhihu.com/soulshell">https://zhuanlan.zhihu.com/soulshell</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
