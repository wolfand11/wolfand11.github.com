<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-01-16 Tue 19:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Skin Rendering</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.github.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.github.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.github.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.github.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.github.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.github.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Skin Rendering</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga45e3ad">皮肤医学结构</a>
<ul>
<li><a href="#orgf1ef102">表皮的分层</a>
<ul>
<li><a href="#org1ca1401">角质层 Stratum corneum</a></li>
<li><a href="#org8726cd3">透明层 Stratum lucidum</a></li>
<li><a href="#org93cad67">颗粒层 Stratum granulosum</a></li>
<li><a href="#org6277299">棘层 Stratum spinosum</a></li>
<li><a href="#orgc6dcc57">基底层 Stratum basale</a></li>
</ul>
</li>
<li><a href="#org993890b">皮肤结构图</a></li>
</ul>
</li>
<li><a href="#org29bc704">2007 Gem3Skin</a>
<ul>
<li><a href="#orgd04fdcb">实现总结</a>
<ul>
<li><a href="#orgb2c6296">高光</a></li>
<li><a href="#org2e4cc38">Diffuse</a>
<ul>
<li><a href="#orgbbd4321">计算 RhodtTexture</a></li>
<li><a href="#orgc46988a">计算 IrradianceTexture</a></li>
<li><a href="#org72de115">计算 StretchCorrectionTexture</a></li>
<li><a href="#orgb1447f1">计算 SeamMaskTexture</a></li>
<li><a href="#orgcab75fc">对 StretchTexture 和 IrradianceTexture 进行模糊</a>
<ul>
<li><a href="#org6e7cf3b">2D Blur to 1D Blur</a></li>
<li><a href="#orgb9274d8">高斯模糊近似 R(d)函数</a></li>
<li><a href="#org363c41c">代码实现</a></li>
</ul>
</li>
<li><a href="#orge2122b0">Translucent Shadow Maps</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org12dcdcb">参考资料</a>
<ul>
<li><a href="#orgee25606">高斯卷积核求解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org779bb35">2009 Efficient rendering of local subsurface scattering</a></li>
<li><a href="#org0cd48b7">2011 Pre-Intergrating the Effects of Scattering</a>
<ul>
<li><a href="#orge2efdad">Pre-integrating the Effect of Scattering</a></li>
<li><a href="#org613d045">Scattering and Diffuse Light</a></li>
<li><a href="#org92d87aa">Scattering and Normal Maps</a></li>
<li><a href="#org068b43d">Shadow Scattering</a></li>
</ul>
</li>
<li><a href="#org194fdef">Improve Pre-Intergrating</a>
<ul>
<li><a href="#orgd894fe8">2013 Env Light Pre-Intergrating Scattering</a>
<ul>
<li><a href="#org31db911">如何理解需要通过卷积来计算 S(θ,r) 对应 SH 基函数的系数？</a></li>
</ul>
</li>
<li><a href="#org3ce8d46">Approximate Pre-Intergrating Scattering</a></li>
<li><a href="#org86c5095">参考资料</a></li>
</ul>
</li>
<li><a href="#orgf43c2cc">CLX2 Skin</a>
<ul>
<li><a href="#orgda75179">BRDF</a>
<ul>
<li><a href="#orge0fe9c3">Fresnel</a></li>
<li><a href="#orgdbfd47a">D</a></li>
<li><a href="#org6f72cc4">G</a></li>
</ul>
</li>
<li><a href="#org9d65d48">Refract Light</a></li>
<li><a href="#org6386e5e">SSS</a></li>
</ul>
</li>
<li><a href="#org12e097a">2009 ScreenSpace Perceptual Rendering of Human Skin</a>
<ul>
<li><a href="#orgf2609fc">实现细节</a>
<ul>
<li><a href="#org009ee46">Blur Kernel width</a></li>
<li><a href="#orgda9828d">渲染流程和贴图空间 SSS 的对比</a></li>
<li><a href="#orgb9f23aa">缺陷</a></li>
</ul>
</li>
<li><a href="#org01b4d42">参考链接</a></li>
</ul>
</li>
<li><a href="#orga65cc7a">2010 Real-Time Realistic Skin Translucency</a>
<ul>
<li>
<ul>
<li><a href="#org490c578">算法基于下面 4 点观察</a></li>
<li><a href="#orgf5d52b4">基于上面 4 点观察，算法做出如下 3 点假设</a></li>
<li><a href="#org4d11c84">公式推导</a></li>
<li><a href="#org5898e6e">实现细节</a></li>
</ul>
</li>
<li><a href="#org33d859a">参考链接</a></li>
</ul>
</li>
<li><a href="#orgcae6b48"><span class="todo TODO">TODO</span> 2015 Separable-SSS</a>
<ul>
<li><a href="#org96fcf68">参考链接</a></li>
</ul>
</li>
<li><a href="#orga710e72">2018 Unity Efficient screen space subsurface scattering</a>
<ul>
<li><a href="#org243ac18">Problems with Separable Subsurface Scattering</a></li>
<li><a href="#org35bd7d2">Burley's Normalized Diffusion Model</a></li>
<li><a href="#org73f8a9a">Implementing Subsurface Scattering</a>
<ul>
<li><a href="#org2f304d6">Subsurface Scattering Algorithm</a></li>
<li><a href="#org0656a35">Sampling the Diffusion Profile</a></li>
<li><a href="#orgd387a43">Bilateral Filtering</a></li>
<li><a href="#orgc24937d">Orders of Approximation</a></li>
<li><a href="#orgdf907b3">Translucency</a>
<ul>
<li><a href="#org50e6a15">Thin Object Translucency</a></li>
<li><a href="#orgf78698c">Thick Object Translucency</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org145f1f2">Optimizations</a></li>
<li><a href="#org83b4068">Limitation</a></li>
<li><a href="#org48bac70">Future Work</a></li>
<li><a href="#org59dbe87">参考链接</a></li>
</ul>
</li>
<li><a href="#org2221ce4">Misc</a>
<ul>
<li><a href="#orgf1cd9d5">Normal Map Mipmap</a></li>
<li><a href="#orgd138c14">NoLWrap</a></li>
</ul>
</li>
<li><a href="#org75fc7de">参考资料</a></li>
</ul>
</div>
</div>
<p>
Skin Rendering note.<br />
</p>
<div class="HTML" id="org8f56669">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orga45e3ad" class="outline-2">
<h2 id="orga45e3ad">皮肤医学结构</h2>
<div class="outline-text-2" id="text-orga45e3ad">
<p>
皮肤分为 表皮 epidermis，真皮 dermis 和皮下组织 subcutaneous tissue<br />
</p>
</div>
<div id="outline-container-orgf1ef102" class="outline-3">
<h3 id="orgf1ef102">表皮的分层</h3>
<div class="outline-text-3" id="text-orgf1ef102">
</div>
<div id="outline-container-org1ca1401" class="outline-4">
<h4 id="org1ca1401">角质层 Stratum corneum</h4>
<div class="outline-text-4" id="text-org1ca1401">
<p>
位于表皮的最外层，由 5-20 层的扁平无核细胞组成，胞内细胞器结构消失，充满角蛋白。<br />
</p>
</div>
</div>
<div id="outline-container-org8726cd3" class="outline-4">
<h4 id="org8726cd3">透明层 Stratum lucidum</h4>
<div class="outline-text-4" id="text-org8726cd3">
<p>
仅见于掌跖。由 2-3 层扁平无核细胞组成。<br />
</p>
</div>
</div>
<div id="outline-container-org93cad67" class="outline-4">
<h4 id="org93cad67">颗粒层 Stratum granulosum</h4>
<div class="outline-text-4" id="text-org93cad67">
<p>
由 2-4 层梭形细胞组成，细胞内含有透明角质颗粒。<br />
</p>
</div>
</div>
<div id="outline-container-org6277299" class="outline-4">
<h4 id="org6277299">棘层 Stratum spinosum</h4>
<div class="outline-text-4" id="text-org6277299">
<p>
由 4-10 层多角形细胞组成，细胞间桥明显呈棘状。<br />
</p>
</div>
</div>
<div id="outline-container-orgc6dcc57" class="outline-4">
<h4 id="orgc6dcc57">基底层 Stratum basale</h4>
<div class="outline-text-4" id="text-orgc6dcc57">
<p>
位于表皮的最下层，为一层立方形或圆柱状细胞，细胞的长轴与基底膜带垂直，胞核呈卵圆形，胞浆内含有黑素颗粒，核分裂象常见。<br />
具有不断分裂增殖的能力，因此又称为生发层。由基底层移行至颗粒层最上层约需 14 天，再移行至角质层表面脱落又需 14 天，称为表皮通过时间。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org993890b" class="outline-3">
<h3 id="org993890b">皮肤结构图</h3>
<div class="outline-text-3" id="text-org993890b">

<div id="orga44902e" class="figure">
<p><img src="SkinRendering/001_Skin_Structure_Image_01.jpg" alt="001_Skin_Structure_Image_01.jpg" width="200px" /><br />
</p>
</div>

<div id="orgb9972e6" class="figure">
<p><img src="SkinRendering/001_Skin_Structure_Image_02.jpg" alt="001_Skin_Structure_Image_02.jpg" width="200px" /><br />
</p>
</div>

<ul class="org-ul">
<li>皮肤结构 <a href="http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx">http://www.leo-pharma.cn/Home/Dermatology/general_knowledge/Skin_Structure.aspx</a><br /></li>
<li>皮肤的结构-表皮 <a href="http://www.truebuty.com/scstructure.html">http://www.truebuty.com/scstructure.html</a><br /></li>
<li><a href="https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/">https://opentextbc.ca/anatomyandphysiology/chapter/5-1-layers-of-the-skin/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org29bc704" class="outline-2">
<h2 id="org29bc704">2007 Gem3Skin</h2>
<div class="outline-text-2" id="text-org29bc704">
<ul class="org-ul">
<li>原文链接 Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
</ul>

<p>
下图是使用 2 个 Gaussian 函数，4个 Gaussian 函数来近似 Dipole 模型推导出的 绿光在大理石中散射的 diffuse profile：<br />
</p>

<div id="orge8c2d1d" class="figure">
<p><img src="./SkinRendering/gaussians-approx-dipole profiles.jpg" alt="gaussians-approx-dipole profiles.jpg" width="200px" /><br />
</p>
</div>

<p>
下图使用 6 个高斯函数来近似 Diffusion profile。rgb 三个通道都是用相同的这 6 个高斯函数，但是对应的高斯函数的权重不同。<br />
</p>

<div id="org4f1b4dd" class="figure">
<p><img src="./SkinRendering/002_gaussian-func-weights.png" alt="002_gaussian-func-weights.png" width="200px" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd04fdcb" class="outline-3">
<h3 id="orgd04fdcb">实现总结</h3>
<div class="outline-text-3" id="text-orgd04fdcb">
</div>
<div id="outline-container-orgb2c6296" class="outline-4">
<h4 id="orgb2c6296">高光</h4>
<div class="outline-text-4" id="text-orgb2c6296">
<p>
高光使用了基于物理的 BRDF，为了加速计算，对 BRDF 进行了预计算。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">PHBeckmann</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">nDotH</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">roughness</span>)
{
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">alpha</span> = acos(nDotH);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ta</span> = tan(alpha);
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">r2</span> = roughness * roughness;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">val</span> = 1.0 / (r2*pow(nDotH, 4.0))*exp(-(ta*ta) / r2);
  <span style="color: #4f97d7; font-weight: bold;">return</span> 0.5*pow(val, 0.1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2e4cc38" class="outline-4">
<h4 id="org2e4cc38">Diffuse</h4>
<div class="outline-text-4" id="text-org2e4cc38">
</div>
<div id="outline-container-orgbbd4321" class="outline-5">
<h5 id="orgbbd4321">计算 RhodtTexture</h5>
<div class="outline-text-5" id="text-orgbbd4321">
<p>
uv.u 为 NoL<br />
uv.v 为 roughness<br />
计算 BRDF 在半球空间的积分，得到所有被反射的比例，从而就可以得到剩余的被散射的比例。<br />
</p>
</div>
</div>

<div id="outline-container-orgc46988a" class="outline-5">
<h5 id="orgc46988a">计算 IrradianceTexture</h5>
<div class="outline-text-5" id="text-orgc46988a">
<p>
在贴图空间，计算被散射的能量。渲染模型，结果按照模型 UV 输出（这就是所谓的贴图空间渲染）。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
    {
        v2f o;
<span style="color: #bc6ec5;">        #if</span> UNITY_UV_STARTS_AT_TOP
        o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>((v.uv0 * 2 - 1)*<span style="color: #ce537a; font-weight: bold;">float2</span>(1,-1), 0, 1);
<span style="color: #bc6ec5;">        #else</span>
        o.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.uv0 * 2 - 1, 0, 1);
<span style="color: #bc6ec5;">        #endif</span>
        o.tex = v.uv0;
        o.posWorld = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
        o.eyeVec.xyz = <span style="color: #7590db;">_WorldSpaceCameraPos</span> - o.posWorld.xyz;
        <span style="color: #4f97d7; font-weight: bold;">return</span> o;
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-org72de115" class="outline-5">
<h5 id="org72de115">计算 StretchCorrectionTexture</h5>
<div class="outline-text-5" id="text-org72de115">
<p>
在贴图空间，矫正贴图空间的模糊(曲率比较大的地方，相邻点的空间距离比其贴图上的距离要小)<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #2aa1ae; background-color: #292e34;">// &#21516;&#26679;&#26159;&#22312;&#36148;&#22270;&#31354;&#38388;&#36827;&#34892;&#35745;&#31639;&#65292;&#24471;&#21040;&#36148;&#22270;&#34987;&#25289;&#20280;&#30340;&#31243;&#24230;(&#20854;&#23454;&#20063;&#26159;&#27169;&#22411;&#26412;&#36523;&#30340;&#26354;&#29575;)</span>
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
    {
        <span style="color: #ce537a; font-weight: bold;">float3</span> posWorld = i.posWorld;
        <span style="color: #ce537a; font-weight: bold;">float3</span> derivU = <span style="color: #4f97d7;">ddx</span>(posWorld);
        <span style="color: #ce537a; font-weight: bold;">float3</span> derivV = <span style="color: #4f97d7;">ddy</span>(posWorld);
        <span style="color: #ce537a; font-weight: bold;">float</span> stretchU = 1 / <span style="color: #4f97d7;">length</span>(derivU) * <span style="color: #7590db;">_StretchScale</span>;
        <span style="color: #ce537a; font-weight: bold;">float</span> stretchV = 1 / <span style="color: #4f97d7;">length</span>(derivV) * <span style="color: #7590db;">_StretchScale</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(stretchU, stretchV, 0, 1);
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb1447f1" class="outline-5">
<h5 id="orgb1447f1">计算 SeamMaskTexture</h5>
<div class="outline-text-5" id="text-orgb1447f1">
<p>
使用(0,0,0,0) clear StretchTextureRT，生成 StretchTexture 时 alpha 始终填充 1，这样接缝外的 alpha 就会为 0。<br />
在贴图空间，将所有 StretchTexture 的 alpha 通道相乘就可以得到 SeamMask。<br />
</p>
</div>
</div>
<div id="outline-container-orgcab75fc" class="outline-5">
<h5 id="orgcab75fc">对 StretchTexture 和 IrradianceTexture 进行模糊</h5>
<div class="outline-text-5" id="text-orgcab75fc">
<p>
在贴图空间，对 IrradianceTexture 进行高斯模糊来模拟散射。一共使用 6 个高斯函数，RGB 通道使用不同的权重。6个高斯函数近似 multi-dipole profiles<br />
</p>
</div>
<div id="outline-container-org6e7cf3b" class="outline-6">
<h6 id="org6e7cf3b">2D Blur to 1D Blur</h6>
<div class="outline-text-6" id="text-org6e7cf3b">

<div id="org9ee3d72" class="figure">
<p><img src="./SkinRendering/2d_gaussian_blur_to_1d_gaussian_blur.jpg" alt="2d_gaussian_blur_to_1d_gaussian_blur.jpg" width="200px" /><br />
</p>
</div>

<div id="org70f94fc" class="figure">
<p><img src="./SkinRendering/2d_gaussian_blur_to_1d_gaussian_blur_01.jpg" alt="2d_gaussian_blur_to_1d_gaussian_blur_01.jpg" width="200px" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/364517094">https://www.zhihu.com/question/364517094</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9274d8" class="outline-6">
<h6 id="orgb9274d8">高斯模糊近似 R(d)函数</h6>
<div class="outline-text-6" id="text-orgb9274d8">
<p>
R(d)<sub>r</sub> = 0.078*G(sqrt(7.41), d) + 0.358*G(sqrt(1.99), d) + 0.113*G(sqrt(7.41), d) + 0.118*G(sqrt(0.358), d) + 0.100*G(sqrt(0.0484), d) + 0.233*G(sqrt(0.0064), d);<br />
</p>

<div id="orgfcdfec5" class="figure">
<p><img src="./SkinRendering/002_gaussian_approx_rd_001.jpg" alt="002_gaussian_approx_rd_001.jpg" width="200px" /><br />
</p>
</div>
<p width="200px">
<img src="./SkinRendering/002_gaussian_approx_rd_002.jpg" alt="002_gaussian_approx_rd_002.jpg" width="200px" /><br />
下面文件为一维高斯函数图形：<br />
<a href="./SkinRendering/002_gaussian_function.ggb">./SkinRendering/002_gaussian_function.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org363c41c" class="outline-6">
<h6 id="org363c41c">代码实现</h6>
<div class="outline-text-6" id="text-org363c41c">
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#36148;&#22270;&#31354;&#38388;&#65292;&#20808;&#23545;StretchTexture&#36827;&#34892;&#27169;&#31946;&#65292;&#28982;&#21518;&#20877;&#23545;IrradianceTexture&#36827;&#34892;&#27169;&#31946;</span>
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
    {
        <span style="color: #ce537a; font-weight: bold;">float</span> scale = <span style="color: #7590db;">_MainTex_TexelSize</span>.x * <span style="color: #7590db;">_GaussianWidth</span> / <span style="color: #7590db;">_BlurStepScale</span>;
        <span style="color: #ce537a; font-weight: bold;">float2</span> uvDelta = <span style="color: #ce537a; font-weight: bold;">float2</span>(scale, 0.0);
<span style="color: #bc6ec5;">        #if</span> defined(CONV_V)
            uvDelta.xy = uvDelta.yx;
<span style="color: #bc6ec5;">            #if</span> defined(ENABLE_STRETCH_CORRECTION)
                uvDelta.y *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).y;
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #else</span>
<span style="color: #bc6ec5;">            #if</span> defined(ENABLE_STRETCH_CORRECTION)
                uvDelta.x *= <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_StretchTex</span>, i.uv).x;
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #endif</span>
        <span style="color: #ce537a; font-weight: bold;">float2</span> coords = i.uv - uvDelta*3.0;
        <span style="color: #ce537a; font-weight: bold;">float4</span> sum = 0.0;
            <span style="color: #2aa1ae; background-color: #292e34;">// &#26399;&#26395;&#20026;0&#65292;&#26631;&#20934;&#24046;&#20026;1 &#30340;&#39640;&#26031;&#20989;&#25968;&#31163;&#25955;&#30340;&#20989;&#25968;&#20540;</span>
        <span style="color: #ce537a; font-weight: bold;">float</span> curve[7] = { 0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006 };
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> j = 0; j &lt; 7; j++)
        {
            <span style="color: #ce537a; font-weight: bold;">float4</span> tap = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, coords);
            sum += curve[j] * tap;
            coords += uvDelta;
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> sum;
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge2122b0" class="outline-5">
<h5 id="orge2122b0">Translucent Shadow Maps</h5>
<div class="outline-text-5" id="text-orge2122b0">
<ul class="org-ul">
<li>生成 TSM<br />
从光源方向渲染模型（设置 ViewProjection 矩阵为 LightVP），将模型的 depth 和 uv 写入到 TSM RenderTarget。<br /></li>
<li>读取 TSM<br />
渲染模型时，将模型的 worldPos 转化到光源投影空间（LightVP * worldPos）得到 lightProjPos，利用 lightProjPos.xy/lightProjPos.w 就可以对上一步生成的 TSM 进行采样。此时得到的数据为模型当前渲染的点沿光照方向的背侧的点。如下图：<br /></li>
<li><p>
应用 TSM<br />
得到背侧点的 uv 和 depth 后，使用 uv 采样 IrradianceTexture 可得到背侧点的散射能量。利用这些信息计算出从背侧散射到当前点的能量。<br />
</p>

<div id="org433d643" class="figure">
<p><img src="./SkinRendering/001_tsm_illustrate.jpg" alt="001_tsm_illustrate.jpg" width="200px" /><br />
</p>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org12dcdcb" class="outline-3">
<h3 id="org12dcdcb">参考资料</h3>
<div class="outline-text-3" id="text-org12dcdcb">
<ul class="org-ul">
<li>Advanced Techniques for Realistic Real-Time Skin Rendering <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html</a><br /></li>
<li>角色渲染技术——皮肤 <a href="https://zhuanlan.zhihu.com/p/27014447">https://zhuanlan.zhihu.com/p/27014447</a><br /></li>
<li>GPU Gems 3 真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
</ul>
</div>
<div id="outline-container-orgee25606" class="outline-4">
<h4 id="orgee25606">高斯卷积核求解</h4>
<div class="outline-text-4" id="text-orgee25606">
<ul class="org-ul">
<li>如何通俗易懂地解释卷积？  <a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a><br /></li>
<li>Gaussian filter, or Gaussian blur <a href="http://www.librow.com/articles/article-9">http://www.librow.com/articles/article-9</a><br /></li>
<li>高斯函数 <a href="https://www.zhihu.com/question/33214189">https://www.zhihu.com/question/33214189</a><br /></li>
<li>理解图像卷积操作的意义 <a href="https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1">https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&amp;fps=1</a><br /></li>
<li>高斯卷积核计算器 <a href="http://dev.theomader.com/gaussian-kernel-calculator/">http://dev.theomader.com/gaussian-kernel-calculator/</a><br /></li>
<li>将 2D 卷积核转化为 1D <a href="https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/">https://blogs.mathworks.com/steve/2006/11/28/separable-convolution-part-2/</a><br /></li>
<li>2D GaussianBlur To 1D <a href="https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur">https://stackoverflow.com/questions/25216834/converting-2d-mask-to-1d-in-gaussian-blur</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org779bb35" class="outline-2">
<h2 id="org779bb35">2009 Efficient rendering of local subsurface scattering</h2>
<div class="outline-text-2" id="text-org779bb35">
<p>
该方法是屏幕空间的方法。对于当前的 skin pixel p，使用重要性采样生成一系列样本 pi（这些样本的 Irradiance 会散射到 p），利用蒙特卡洛积分来计算次表面散射。<br />
</p>


<div id="org43f3ca2" class="figure">
<p><img src="./SkinRendering/2009_eflss_001.png" alt="2009_eflss_001.png" width="200px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0cd48b7" class="outline-2">
<h2 id="org0cd48b7">2011 Pre-Intergrating the Effects of Scattering</h2>
<div class="outline-text-2" id="text-org0cd48b7">
</div>
<div id="outline-container-orge2efdad" class="outline-3">
<h3 id="orge2efdad">Pre-integrating the Effect of Scattering</h3>
<div class="outline-text-3" id="text-orge2efdad">
<p>
我们没有通过收集渲染位置处所有方向的入射光来实现次表面散射。而是探索预积分皮肤中的次表面散射效果。<br />
只有三件事情会引入可见的散射：<br />
</p>
<ol class="org-ol">
<li>模型曲率的变化<br /></li>
<li>normal map 中的突起<br /></li>
<li>遮挡光导致的阴影<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org613d045" class="outline-3">
<h3 id="org613d045">Scattering and Diffuse Light</h3>
<div class="outline-text-3" id="text-org613d045">
<p>
nDotL 是主要导致入射光变化的原因，其使得散射变得明显。<br />
我们考虑通过球谐光照模拟所有方向上的光，以此来预计算表面上任意一点的散射光效果。但是球谐方式只能高效地表示低频率变化的光，对于高频变化的光需要很多系数。因此，我们放弃了预计算散射效果，而选择预计算表面形状子集的散射衰减，并在渲染时确定最好的衰减.<br />
我们在运行时可以计算表面的曲率，其最大程度决定了光滑表面的散射效果。<br />
为了测量曲面上的散射，我们添加了曲率作为第二个参数。我们简单从一个方向照射给定曲率的球面，并测量各个角度上累计的光照。<br />
下图为散射光公式推导：<br />
</p>

<div id="orge863d58" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_01.jpg" alt="indirect-light-scatter_01.jpg" width="400px" /><br />
</p>
</div>

<p>
当前模型假设所有的皮肤和球相似，但是皮肤可以为任意拓扑结构。换句话说，当前模型假设给定点的散射由该点自身的曲率决定，而事实上是由该点周围所有点的曲率决定。因此，该模型在平滑的表面上(曲率变化不大的表面上)效果可以，但是曲率变化比较大时，就不适用了。幸运的是，大多数皮肤模型都有两层：使用几何表示光滑的表面，使用 normal map 表示表面细节。<br />
</p>

<ul class="org-ul">
<li>如何简明地解释曲率（curvature）？ <a href="https://www.zhihu.com/question/25952605">https://www.zhihu.com/question/25952605</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org92d87aa" class="outline-3">
<h3 id="org92d87aa">Scattering and Normal Maps</h3>
<div class="outline-text-3" id="text-org92d87aa">
<p>
皮肤上小的皱纹、毛孔通常通过 normal map 来表示。因为小折痕的法线总是要回到表面主法线方向，从小折痕反射的散射光和折痕更宽的不散射表面反射的光看起来很像。因此可以通过模糊 normal 来近似皱纹、毛孔等小褶皱照成的散射。对于不同波长的光，diffusion profiles 不同，模糊 normal 的方式也不同。<br />
</p>

<p>
从实际的物体抓取 normal 贴图时，发现 normal 会向表面法线偏转，而且不同波长的光偏转程度不同，红光比绿光偏转程度大。还观察到使用多个波长的光抓取的多个 normal 进行渲染要比使用单个 normal 效果要好。<br />
我们的做法为，假定原始的 normal map 是精确的表面法线，对其进行 blur 而得到每个波长对应的 normal。因此，不能为了得到更光滑的效果，而直接提供 blur 过的 normal map 做原始的 normal map，否则再对其进行 blur 得到的每个波长的 normal 将不正确。<br />
使用 diffusion profile 直接对 normal map 进行 blur 是不可行的，因为光照对于表面法线不是线性过程。需要使用 LEAN 或 CLEAN。<br />
</p>

<p>
值得注意的是，在法线贴图的过滤区域内，阴影/入射光/散射光项为常数时，使用非归一化的 normal 是一个可行的近似，此时我们有如下关系式：<br />
</p>
<p width="300px">
<img src="./SkinRendering/004_normal_filter_001.jpg" alt="004_normal_filter_001.jpg" width="300px" /><br />
上面关系式不是总成立的，因为 diffuse lighting 包含一个自阴影项 max(0, N.L)来取代上式中的 N.L。尽管如此，当法线过滤区域内都没阴影或都有阴影时，使用非归一化的法线依然是正确的。<br />
</p>

<p>
我们开发了一种近似的方法，其只用一张包含 mipmap 的法线贴图。使用该优化方法时，specular normal 的采样依然不变，但同时使用另一个采样器采样高一级的 mipmap 得到 red normal。然后将 specular normal 和 red normal 变换到 tangent 空间，对他们进行混合得到 green 和 blue normal。最后的 diffuse-lighting 计算需要执行三次（red-diffuse blue-diffuse green-diffuse）。<br />
</p>

<p>
如果法线贴图只包含很小的细节，甚至可以使用几何法线来代替 red normal。<br />
</p>
</div>
</div>
<div id="outline-container-org068b43d" class="outline-3">
<h3 id="org068b43d">Shadow Scattering</h3>
<div class="outline-text-3" id="text-org068b43d">
<p>
光散射到阴影是真实感皮肤的重要特性之一。使用一点小技巧就可以预计算阴影边界上的散射效果。<br />
</p>

<p>
我们可以将阴影映射算法当作一个衰减函数。当衰减为完全黑或完全白，对应着完全遮挡和完全不遮挡。我们可以重新设置完全黑和完全白之间的值。特别地，如果我们确定我们的阴影过滤器创建的半影尺寸足够容纳大部分的 diffusion profile，我们可以缩小原始半影的尺寸，多出来的尺寸用于基于 diffusion profile 的散射。<br />
</p>

<div id="org44445c0" class="figure">
<p><img src="./SkinRendering/004_shadow_scatter.jpg" alt="004_shadow_scatter.jpg" width="400px" /><br />
</p>
</div>

<p>
为了计算精确的衰减，我们将阴影半影和 diffusion profile 进行预积分。我们将阴影半影 P()定义为一个一维衰减函数，该函数来自于使用阴影贴图映射的 blur kernel 对硬阴影边界的过滤。假定阴影映射的 kernel 为单调递减的，则对应的衰减函数也是单调递减，这样就可以对阴影半影 P()求反函数 \(P^{-1}()\) 。这样就可以通过给定的阴影值获得对应的半影中的位置。例如，如果阴影映射为 BoxFilter，则阴影半影函数 P()就是一个线性的斜坡，此时对应的反函数 \(P^{-1}()\) 也是一个线性的斜坡。<br />
</p>

<p>
我们假定了阴影是投射在一个平面上的，如果表面倾斜度很大，半影尺寸将比我们预计算时使用的值大很多。因此，我们为阴影衰减贴图增加了第二个维度，其表示世界空间中的半影尺寸。最后，我们生成阴影 LUT 的公式如下：<br />
</p>

<div id="org0d5dbed" class="figure">
<p><img src="./SkinRendering/004_shadow_scatter_equation.jpg" alt="004_shadow_scatter_equation.jpg" width="400px" /><br />
</p>
</div>

<p>
半影宽度可以通过表面和对应光源的夹角得到，或者直接对阴影值进行求导。<br />
当半影被拉升映射到倾斜度很高的表面时，此时提供的散射衰减空间更大。可以对半影宽度值进行截取，以保证其在 LUT 贴图范围内。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org194fdef" class="outline-2">
<h2 id="org194fdef">Improve Pre-Intergrating</h2>
<div class="outline-text-2" id="text-org194fdef">
</div>
<div id="outline-container-orgd894fe8" class="outline-3">
<h3 id="orgd894fe8">2013 Env Light Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-orgd894fe8">
<ol class="org-ol">
<li>将皮肤次表面散射系数转化为 SH 系数<br /></li>
<li>计算 SH 环境光时，用 LightSH 系数*ScatterSH 系数就得到此表面散射后的环境光<br /></li>
</ol>

<p>
原理如下推导：<br />
</p>

<div id="org67ac655" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_01.jpg" alt="indirect-light-scatter_01.jpg" width="400px" /><br />
</p>
</div>


<div id="org77863b2" class="figure">
<p><img src="./SkinRendering/indirect-light-scatter_02.jpg" alt="indirect-light-scatter_02.jpg" width="400px" /><br />
</p>
</div>

<p>
Tips：计算间接光照的 diffuse 部分时，会传入当前顶点的世界坐标系下的法线 wNormal，需要将 S(θ,r)的+z 方向和 wNormal 对齐。也就是上图中给 Rl 乘了一个变换系数得到了 Rl‘。<br />
</p>
</div>
<div id="outline-container-org31db911" class="outline-4">
<h4 id="org31db911">如何理解需要通过卷积来计算 S(θ,r) 对应 SH 基函数的系数？</h4>
<div class="outline-text-4" id="text-org31db911">
<p>
形式化的证明：<br />
形式化的证明需要类比于泰勒展开的证明。即可以证明一个函数可以由多个基函数线性叠加，然后，证明基函数的系数为原函数和基函数的卷积。<br />
在 《数学物理方法》 书中有描述，Spherical Harmonics 是在球坐标系下求解 Laplace 方程时，进行变量分解后（分解为角度部分和半径部分），角度部分的解。如此发现了球谐函数。<br />
TODO<br />
</p>

<p>
直观的理解：<br />
也可以进行直观的理解，卷积的离散形式就是以过滤器函数为权重对被积函数求和。假设过滤器函数的离散值为 g0, g1, g2, g3，被积分函数的离散值为 f1, f2, f3, f4。则最终的结果为：<br />
g0*f0 + g1*f1 + g2*f2 + g3*f3<br />
这和两个向量的点积形式完全一样。因此，S(θ,r)和 SH 基函数卷积其实就是将 S(θ,r) 投影到 SH 基函数，卷积得到的值就是对应 SH 基函数的系数。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3ce8d46" class="outline-3">
<h3 id="org3ce8d46">Approximate Pre-Intergrating Scattering</h3>
<div class="outline-text-3" id="text-org3ce8d46">
<ul class="org-ul">
<li><a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org86c5095" class="outline-3">
<h3 id="org86c5095">参考资料</h3>
<div class="outline-text-3" id="text-org86c5095">
<ul class="org-ul">
<li><a href="https://blog.selfshadow.com/publications/s2013-shading-course/#course_content">https://blog.selfshadow.com/publications/s2013-shading-course/#course_content</a><br /></li>
<li><a href="http://grephicsnerd.blogspot.com/2017/06/skin-shading-model.html">http://grephicsnerd.blogspot.com/2017/06/skin-shading-model.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf43c2cc" class="outline-2">
<h2 id="orgf43c2cc">CLX2 Skin</h2>
<div class="outline-text-2" id="text-orgf43c2cc">
</div>
<div id="outline-container-orgda75179" class="outline-3">
<h3 id="orgda75179">BRDF</h3>
<div class="outline-text-3" id="text-orgda75179">
</div>
<div id="outline-container-orge0fe9c3" class="outline-4">
<h4 id="orge0fe9c3">Fresnel</h4>
<div class="outline-text-4" id="text-orge0fe9c3">
<p>
F 的计算中，将 5 次方转化为了 exp2 操作，来优化性能。<br />
有些 GPU 通过表查找来实现 exp2，exp2 只需要 1 条指令。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> F = specColor + <span style="color: #4f97d7;">saturate</span>(50 * specColor.g - specColor)*<span style="color: #4f97d7;">exp2</span>((-5.55473*VoH - 6.98316)*VoH);
</pre>
</div>

<ul class="org-ul">
<li>粗略判断 Shader 每条代码的成本 <a href="https://zhuanlan.zhihu.com/p/34629262">https://zhuanlan.zhihu.com/p/34629262</a><br /></li>
<li>Fresnel Equations, Schlick Approximation, Metals, and Dielectrics <a href="http://psgraphics.blogspot.com/2020/03/fresnel-equations-schlick-approximation.html">http://psgraphics.blogspot.com/2020/03/fresnel-equations-schlick-approximation.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdbfd47a" class="outline-4">
<h4 id="orgdbfd47a">D</h4>
<div class="outline-text-4" id="text-orgdbfd47a">
<p>
GGX 法线分布。使用两个粗糙度输入计算两个法线分布，最终的 D 项为 D1*1.5 + D2*0.5，因为 G 中的分母为 0.25（本应该为 0.5），所以此处 D1 和 D2 缩放因子的和为 2。<br />
Crystal 中 D 项为 D1+D2。<br />
</p>
<ul class="org-ul">
<li>D1 使用的是未缩放的粗糙度<br /></li>
<li>D2 使用了缩放后的粗糙度<br /></li>
</ul>

<p>
roughness 没用执行平方操作(即：需将 perceptualRoughness 转化为公式中使用的 roughness)<br />
</p>
</div>
</div>
<div id="outline-container-org6f72cc4" class="outline-4">
<h4 id="org6f72cc4">G</h4>
<div class="outline-text-4" id="text-org6f72cc4">
<p>
G 项和 SmithJointApprox 类似，但是系数不同。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org9d65d48" class="outline-3">
<h3 id="org9d65d48">Refract Light</h3>
<div class="outline-text-3" id="text-org9d65d48">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// normal &#20026;&#39030;&#28857;&#27861;&#32447;&#20809;&#26629;&#21270;&#25554;&#20540;&#30340;&#32467;&#26524; (&#20302;&#39057;&#27861;&#32447;)</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> RefractionNoL = <span style="color: #4f97d7;">saturate</span>(0.6 + <span style="color: #4f97d7;">dot</span>(normal, light.dir));
<span style="color: #2aa1ae; background-color: #292e34;">// attenuation &#20026;mainLight&#30340;&#38452;&#24433;&#39033;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> RefractionIrradiance = light.color * thickness * <span style="color: #7590db;">_SSSColor</span> * RefractionNoL * RefractionNoL * attenuation;
</pre>
</div>

<p>
<a href="./SkinRendering/005_clx_refract.ggb">./SkinRendering/005_clx_refract.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org6386e5e" class="outline-3">
<h3 id="org6386e5e">SSS</h3>
<div class="outline-text-3" id="text-org6386e5e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// SSS1 &#30452;&#25509;&#20351;&#29992; NoL&#23545; SSSLUT&#36827;&#34892;&#37319;&#26679;&#24471;&#21040;&#30340;&#20540;</span>

<span style="color: #2aa1ae; background-color: #292e34;">// SSS2 &#23545;&#38452;&#24433;&#36793;&#30028;&#25955;&#23556;&#30340;&#22788;&#29702;&#65292;SSS&#24378;&#24230;&#36234;&#22823;&#65292;&#38452;&#24433;&#36793;&#30028;&#21464;&#21270;&#26354;&#32447;&#36234;&#36235;&#36817;&#25243;&#29289;&#32447;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// DoL &#20026;&#27861;&#32447;&#36148;&#22270;&#20013;&#23384;&#20648;&#30340;&#27861;&#32447;&#65288;&#39640;&#39057;&#27861;&#32447;&#65289;&#19982;mainLight&#30340;&#28857;&#31215;</span>
<span style="color: #ce537a; font-weight: bold;">float</span> LutUV2 = attenuation + (DoL-NoL) * attenuation;
<span style="color: #ce537a; font-weight: bold;">float3</span> SSS_Lut2 = <span style="color: #ce537a; font-weight: bold;">float3</span>(<span style="color: #4f97d7;">lerp</span>(<span style="color: #4f97d7;">sqrt</span>(LutUV2.r), LutUV2.r, 1 - <span style="color: #7590db;">_SSSIntensity</span>), LutUV2.rr);
SSS_Lut2 *= SSS_Lut2;
</pre>
</div>


<div id="org4d0d8ac" class="figure">
<p><img src="./SkinRendering/clx_shadow_scatter.jpg" alt="clx_shadow_scatter.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org12e097a" class="outline-2">
<h2 id="org12e097a">2009 ScreenSpace Perceptual Rendering of Human Skin</h2>
<div class="outline-text-2" id="text-org12e097a">
</div>
<div id="outline-container-orgf2609fc" class="outline-3">
<h3 id="orgf2609fc">实现细节</h3>
<div class="outline-text-3" id="text-orgf2609fc">
</div>
<div id="outline-container-org009ee46" class="outline-4">
<h4 id="org009ee46">Blur Kernel width</h4>
<div class="outline-text-4" id="text-org009ee46">
<p>
Blur Kernel width 需要考虑下面两个情况<br />
</p>
<ul class="org-ul">
<li>远处的物体应该使用窄的 kernel<br /></li>
<li>depth map 中梯度变化大的也需要使用窄的 kernel<br /></li>
</ul>
<p>
使用下面的公式来实现：<br />
</p>

<div id="org6eed8c9" class="figure">
<p><img src="./SkinRendering/007_kernel_width.jpg" alt="007_kernel_width.jpg" width="300px" /><br />
</p>
</div>

<p>
从上面公式可以看到，深度梯度增加会减小 kenel 宽度；这就限制了背景像素和 skin 像素进行卷积。在物体的边界处，深度梯度会很大，kernel 宽度就会很小。<br />
上面公式中的α值受下面一些因素影响：<br />
</p>
<ol class="org-ol">
<li>物体在 3D 空间中的尺寸<br /></li>
<li>摄像机的 FOV<br /></li>
<li>viewport size<br /></li>
</ol>

<p>
下图展示了α和β分别变化对最终渲染结果的影响：<br />
</p>

<div id="orge267ef3" class="figure">
<p><img src="./SkinRendering/007_alpha_beta_vary.jpg" alt="007_alpha_beta_vary.jpg" width="500px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BlurPS</span>(PassV2P input, <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #4f97d7;">step</span>) : SV_TARGET {
      <span style="color: #2aa1ae; background-color: #292e34;">// Gaussian weights for the six samples around the current pixel:</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//   -3 -2 -1 +1 +2 +3</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> w[6] = { 0.006,   0.061,   0.242,  0.242,  0.061, 0.006 };
      <span style="color: #ce537a; font-weight: bold;">float</span> o[6] = {  -1.0, -0.6667, -0.3333, 0.3333, 0.6667,   1.0 };

      <span style="color: #2aa1ae; background-color: #292e34;">// Fetch color and linear depth for current pixel:</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> colorM = colorTex.Sample(PointSampler, input.texcoord);
      <span style="color: #ce537a; font-weight: bold;">float</span> depthM = depthTex.Sample(PointSampler, input.texcoord);

      <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate center sample, multiplying it with its gaussian weight:</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> colorBlurred = colorM;
      colorBlurred.rgb *= 0.382;

      <span style="color: #2aa1ae; background-color: #292e34;">// Calculate the step that we will use to fetch the surrounding pixels,</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// where "step" is:</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//     step = sssStrength * gaussianWidth * pixelSize * dir</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// The closer the pixel, the stronger the effect needs to be, hence</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// the factor 1.0 / depthM.</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> finalStep = colorM.a * <span style="color: #4f97d7;">step</span> / depthM;

      <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate the other samples:</span>
      [unroll]
      <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> i = 0; i &lt; 6; i++) {
          <span style="color: #2aa1ae; background-color: #292e34;">// Fetch color and depth for current sample:</span>
          <span style="color: #ce537a; font-weight: bold;">float2</span> offset = input.texcoord + o[i] * finalStep;
          <span style="color: #ce537a; font-weight: bold;">float3</span> color = colorTex.SampleLevel(LinearSampler, offset, 0).rgb;
          <span style="color: #ce537a; font-weight: bold;">float</span> depth = depthTex.SampleLevel(PointSampler, offset, 0);

          <span style="color: #2aa1ae; background-color: #292e34;">// If the difference in depth is huge, we lerp color back to "colorM":</span>
          <span style="color: #ce537a; font-weight: bold;">float</span> s = <span style="color: #4f97d7;">min</span>(0.0125 * correction * <span style="color: #4f97d7;">abs</span>(depthM - depth), 1.0);
          color = <span style="color: #4f97d7;">lerp</span>(color, colorM.rgb, s);

          <span style="color: #2aa1ae; background-color: #292e34;">// Accumulate:</span>
          colorBlurred.rgb += w[i] * color;
      }

      <span style="color: #2aa1ae; background-color: #292e34;">// The result will be alpha blended with current buffer by using specific</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// RGB weights. For more details, I refer you to the GPU Pro chapter :)</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> colorBlurred;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-orgda9828d" class="outline-4">
<h4 id="orgda9828d">渲染流程和贴图空间 SSS 的对比</h4>
<div class="outline-text-4" id="text-orgda9828d">

<div id="org901e9e9" class="figure">
<p><img src="./SkinRendering/007_screenspace_sss_pipeline.jpg" alt="007_screenspace_sss_pipeline.jpg" width="300px" /><br />
</p>
</div>


<div id="org6822c98" class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline.jpg" alt="007_sssss_vs_tssss_pipeline.jpg" width="400px" /><br />
</p>
</div>


<div id="orgf104454" class="figure">
<p><img src="./SkinRendering/007_sssss_vs_tssss_pipeline_02.jpg" alt="007_sssss_vs_tssss_pipeline_02.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb9f23aa" class="outline-4">
<h4 id="orgb9f23aa">缺陷</h4>
<div class="outline-text-4" id="text-orgb9f23aa">

<div id="org73c6c44" class="figure">
<p><img src="./SkinRendering/007_sssss_limits.jpg" alt="007_sssss_limits.jpg" width="300px" /><br />
</p>
</div>

<ul class="org-ul">
<li>特定配置下会产生小的光晕、光环 例如，上图第一幅图鼻子和阴影接壤的地方。这是因为屏幕空间中相邻的像素在三维空间中可能并不相邻导致的。<br /></li>
<li>该算法没有考虑薄的、曲率高的地方的一些特性。 例如上图第二副图中的耳朵部位，上图第三幅图为使用 TSSSS 渲染的结果，其通过修改 Translucent Shadow Map 考虑了薄部位的特性。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org01b4d42" class="outline-3">
<h3 id="org01b4d42">参考链接</h3>
<div class="outline-text-3" id="text-org01b4d42">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga65cc7a" class="outline-2">
<h2 id="orga65cc7a">2010 Real-Time Realistic Skin Translucency</h2>
<div class="outline-text-2" id="text-orga65cc7a">
</div>
<div id="outline-container-org490c578" class="outline-4">
<h4 id="org490c578">算法基于下面 4 点观察</h4>
<div class="outline-text-4" id="text-org490c578">
<ol class="org-ol">
<li>对于很多物体，我们可以对当前点的法线取反来近似背面点的法线。当正面和背面平行时，该近似是准确的。<br /></li>
<li>从背面照亮物体，我们从正面看时，观察者无法获得背面辐射照度的准确信息。<br /></li>
<li>材质的自由程很小或者几何体适度的厚时（例如：皮肤），透射是非常低频的现象。这是因为光经过物体内部时被散射，将光的大多数高频信息给消去了。<br /></li>
<li>对于人类皮肤，在表面上 albedo 不会有非常明显的变化，其维持在相似的皮肤色调上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf5d52b4" class="outline-4">
<h4 id="orgf5d52b4">基于上面 4 点观察，算法做出如下 3 点假设</h4>
<div class="outline-text-4" id="text-orgf5d52b4">
<ol class="org-ol">
<li>对正面法线取反来近似背面法线。  (基于观察 1)<br /></li>
<li>利用某种启发式方法我们可以预测背面的 Irradiance，并且很难注意到预测结果和真实结果的不同。 (基于观察 2)<br /></li>
<li>我们可以使用正面的 albedo 近似计算背面的 irradiance。（基于观察 2，4）<br />
即使我们使用高频法线来计算背面的 Irradiance，我们依然得到的是低频的透射光，因此我们假设可以使用低频法线得到近似的结果。我们使用顶点法线来计算背面的 Irradiance，而不是 normal map 中存储的法线，这样就可以舍去 Irradiance 的高频部分。此时，背面的 Irradiance 变化非常小，因此可以取单个值来近似整个卷积。(基于假设 3)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org4d11c84" class="outline-4">
<h4 id="org4d11c84">公式推导</h4>
<div class="outline-text-4" id="text-org4d11c84">

<div id="orge927aca" class="figure">
<p><img src="./SkinRendering/008_translucent_equation.jpg" alt="008_translucent_equation.jpg" width="400px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5898e6e" class="outline-4">
<h4 id="org5898e6e">实现细节</h4>
<div class="outline-text-4" id="text-org5898e6e">
<p>
尽管使用取反的 Normal 来计算透射率避免了双重贡献（相对于两次都使用不取反 Normal 进行计算）。但是，使用取反 Normal 导致反射照亮区域和只受透射照亮的区域之间的过度不平滑。在过度区域，N.L 和 -N.L 都为 0。为了避免突然的照明变化，我们通过下面方式扩大透射照亮的区域：<br />
</p>

<div id="org0da6eb8" class="figure">
<p><img src="./SkinRendering/008_enlarge_translucent_range.jpg" alt="008_enlarge_translucent_range.jpg" width="200px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">distance</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> posW, <span style="color: #ce537a; font-weight: bold;">float3</span> normalW, <span style="color: #ce537a; font-weight: bold;">int</span> i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Shrink the position to avoid artifacts on the silhouette:</span>
    posW = posW - 0.005 * normalW;

    <span style="color: #2aa1ae; background-color: #292e34;">// Transform to light space:</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> posL = <span style="color: #4f97d7;">mul</span>(<span style="color: #ce537a; font-weight: bold;">float4</span>(posW, 1.0), lights[i].viewproj);

    <span style="color: #2aa1ae; background-color: #292e34;">// Fetch depth from the shadow map:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// (Depth from shadow maps is expected to be linear)</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> d1 = shwmaps[i].Sample(<span style="color: #ce537a; font-weight: bold;">sampler</span>, posL.xy / posL.w);
    <span style="color: #ce537a; font-weight: bold;">float</span> d2 = posL.z;

    <span style="color: #2aa1ae; background-color: #292e34;">// Calculate the difference:</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">abs</span>(d1 - d2);
}
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">T</span>(<span style="color: #ce537a; font-weight: bold;">float</span> s)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float3</span>(0.233, 0.455, 0.649) * <span style="color: #4f97d7;">exp</span>(-s*s/0.0064) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.1, 0.336, 0.344) * <span style="color: #4f97d7;">exp</span>(-s*s/0.0484) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.118, 0.198, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/0.187) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.113, 0.007, 0.007) * <span style="color: #4f97d7;">exp</span>(-s*s/0.567) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.358, 0.004, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/1.99) +
    <span style="color: #ce537a; font-weight: bold;">float3</span>(0.078, 0.0, 0.0) * <span style="color: #4f97d7;">exp</span>(-s*s/7.41);
}
<span style="color: #ce537a; font-weight: bold;">float</span> s = scale * <span style="color: #4f97d7;">distance</span>(pos, Nvertex, i);
<span style="color: #ce537a; font-weight: bold;">float</span> E = <span style="color: #4f97d7;">max</span>(0.3 + <span style="color: #4f97d7;">dot</span>(-Nvertex, L), 0.0);
<span style="color: #ce537a; font-weight: bold;">float3</span> transmittance = T(s) * lights[i].color * attenuation * albedo.rgb * E;
<span style="color: #2aa1ae; background-color: #292e34;">// We add the contribution of this light</span>
M += transmittance + reflectance;
</pre>
</div>
</div>
</div>
<div id="outline-container-org33d859a" class="outline-3">
<h3 id="org33d859a">参考链接</h3>
<div class="outline-text-3" id="text-org33d859a">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcae6b48" class="outline-2">
<h2 id="orgcae6b48"><span class="todo TODO">TODO</span> 2015 Separable-SSS</h2>
<div class="outline-text-2" id="text-orgcae6b48">
<p>
该论文提到出了两类方法，都只需要两个 1D 的卷积操作。第一类可以得出高质量的模拟效果，第二类则在效果和易操作性上做了权衡。<br />
论文发现，可以精确模拟 diffusion 的 kernels 通常在数学上是不可分离的，但是可以使用 low-rank factorization(低秩分解)来重建。下图展示了对模拟皮肤次表面散射的 diffuse reflectance profile 进行奇异值分解后，奇异值的衰减情况。从图可以看出，只有和前几个奇异值相关的分量对 profile 的重建有明显贡献。这使得低秩近似是可行的。<br />
</p>

<div id="org5d7a132" class="figure">
<p><img src="./SkinRendering/separable-sss-01.jpg" alt="separable-sss-01.jpg" width="300px" /><br />
</p>
</div>
</div>

<div id="outline-container-org96fcf68" class="outline-3">
<h3 id="org96fcf68">参考链接</h3>
<div class="outline-text-3" id="text-org96fcf68">
<ul class="org-ul">
<li>2009 <a href="http://www.iryoku.com/sssss/">http://www.iryoku.com/sssss/</a><br /></li>
<li>2010 <a href="http://iryoku.com/translucency/">http://iryoku.com/translucency/</a><br /></li>
<li>2015 <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga710e72" class="outline-2">
<h2 id="orga710e72">2018 Unity Efficient screen space subsurface scattering</h2>
<div class="outline-text-2" id="text-orga710e72">
</div>
<div id="outline-container-org243ac18" class="outline-3">
<h3 id="org243ac18">Problems with Separable Subsurface Scattering</h3>
<div class="outline-text-3" id="text-org243ac18">
<ul class="org-ul">
<li>Gaussian 卷积核是可分的，因此比其他卷积核效率高（需要采样的数量比较少）。<br />
但是，只有在一个平面上才可分。<br /></li>
<li>Bilateral filtering 使得卷积变为假的的可分(pseudo-separabel)。<br />
只是结果看起来可以，但并不完全正确。<br /></li>
<li>两个 Gaussian 混合得到的函数显然是不可分的。只能执行 4 个 Pass 来实现。<br />
为两个 Gaussian 卷积核执行 4 个 Pass 在实践上消耗还是太高了<br /></li>
</ul>

<p>
下图展示了不同方法对 MC 结果逼近程度的比较：<br />
<img src="./SkinRendering/separable-vs-unity.jpg" alt="separable-vs-unity.jpg" /><br />
</p>

<p>
单个高斯函数的能够相对准确地近似多次散射，但即使是两个高斯函数的混合也难以准确表示单次和多次散射的组合。在上图片，可以看到白色表示参考结果，红色表示双高斯近似。<br />
</p>

<ul class="org-ul">
<li>混合的高斯对艺术家来说太不友好了。<br />
高斯只是个数学概念。<br />
艺术家被强制只能使用测量数据或人眼拟合确定的数据。<br />
调节参数有 7 个自由度，太多了<br />
有很多参数的组合是没有意义的<br /></li>
</ul>

<div id="org5cbc510" class="figure">
<p><img src="./SkinRendering/gaussian-not-artist-frientdly.jpg" alt="gaussian-not-artist-frientdly.jpg" /><br />
</p>
</div>

<p>
通过实现高斯混合模型，我们遇到了另一个问题 - 它并不适合艺术家使用。高斯函数只是一个数学概念，在 SSS 的背景下没有物理意义。当你有两个高斯函数和一个 lerp 参数时，这就是 7 个自由度，如何设置它们使得最终的组合有意义并不是很清楚。值得注意的是，熟练的艺术家仍然可以通过高斯混合模型获得出色的结果。但是，这可能是一个冗长复杂的过程，不适合 Unity。<br />
</p>
</div>
</div>
<div id="outline-container-org35bd7d2" class="outline-3">
<h3 id="org35bd7d2">Burley's Normalized Diffusion Model</h3>
<div class="outline-text-3" id="text-org35bd7d2">
<ul class="org-ul">
<li>Burley's Normalized Diffusion Model 也被称为 “Disney SSS” （A.k.a: also known as）<br /></li>
<li>该模型对 MC 数据拟合非常好<br /></li>
<li>概念模型考虑了参与介质中的单次和多次散射<br /></li>
</ul>

<p>
我们实现了 Burley 的归一化扩散模型，我们称之为 Disney SSS。它能够准确地匹配使用蒙特卡洛模拟获得的参考数据。因此，自然地，它能够同时考虑单次和多次散射。<br />
关于单次散射和多次散射，可以参考下图（该图来自 <a href="./AtmosphericScattering.html#orga025a62">./AtmosphericScattering.html#orga025a62</a> ）理解：<br />
<img src="./AtmosphericScattering/atmosphere-rendering-equation-01.jpg" alt="atmosphere-rendering-equation-01.jpg" /><br />
</p>

<p>
下图展示了该模型函数图像和对应的画面效果：<br />
<img src="./SkinRendering/burley-normalized-diffusion-model.jpg" alt="burley-normalized-diffusion-model.jpg" /><br />
</p>

<p>
该模型只有两个参数：体积反照率 A 和形状参数 s。两个参数都可以被解释为颜色。形状参数与散射距离成反比，这也是我们在用户界面中暴露的参数。<br />
如果我们观察结果曲线，就会发现两件事情：<br />
</p>
<ol class="org-ol">
<li>尖峰和长尾无法用单个高斯函数来建模。<br /></li>
<li>最终的滤波器明显是不可分离的。<br /></li>
</ol>

<p>
<img src="./SkinRendering/burley-pdf.jpg" alt="burley-pdf.jpg" /><br />
该 diffusion profile 是归一化的，可以直接用作概率密度函数（简称 PDF）。对于蒙特卡洛积分来说，这是一个很有用的特性，我们稍后会看到。<br />
</p>
</div>
</div>
<div id="outline-container-org73f8a9a" class="outline-3">
<h3 id="org73f8a9a">Implementing Subsurface Scattering</h3>
<div class="outline-text-3" id="text-org73f8a9a">

<div id="orgb98999d" class="figure">
<p><img src="./SkinRendering/burley-sss-impl0.jpg" alt="burley-sss-impl0.jpg" /><br />
</p>
</div>

<p>
漫反射 BRDF 时散射距离在像素的范围内时近似版本的 SSS。这意味着两种着色模型在一定距离后应该具有相同的视觉效果。为了实现这一点，我们使用 Disney 漫反射 BRDF 的公式来定义在电介质边界处的漫反射传输行为（diffuse transmision）。虽然它不完全匹配 GGX 模型定义的传输行为，但仍然比假设 Lambert 分布要好。<br />
</p>


<div id="orgc879b24" class="figure">
<p><img src="./SkinRendering/burley-sss-impl1.jpg" alt="burley-sss-impl1.jpg" /><br />
</p>
</div>

<p>
我们不对镜面传输（specular transmission）进行建模，因此我们的模型不能应用于低反照率材质，如玻璃。<br />
</p>

<p>
注意：<br />
传输（transmission）可能是一个令人困惑的术语。镜面传输是指在光滑电介质界面上的菲涅尔反射。而漫反射传输则是指通过粗糙电介质界面的传输，并且通常假设存在大量的多次散射。通常，这就是 Lambert 项。<br />
</p>


<div id="org1cd6a26" class="figure">
<p><img src="./SkinRendering/burley-sss-impl2.jpg" alt="burley-sss-impl2.jpg" /><br />
</p>
</div>

<p>
为了保证视觉一致性，我们直接使用表面反照率作为体积反照率。我们提供了两种反照率纹理的选项：<br />
</p>
<ol class="org-ol">
<li>Post-scatter texturing （后散射纹理）应该在反照率纹理已经包含一些由于 SSS 而导致的颜色渗透时使用。这种情况适用于扫描和照片。在这种模式下，我们只在出射位置应用反照率一次。<br /></li>
<li>PrePost-scatter texturing(前后散射纹理)会有效地模糊反照率，这可能会导致更柔和、更自然的外观，这在某些情况下是可取的。<br /></li>
</ol>

<p>
下图展示了这两种方式的对比：<br />
<img src="./SkinRendering/burley-sss-impl2-pre-post-diff.jpg" alt="burley-sss-impl2-pre-post-diff.jpg" /><br />
</p>

<p>
你可能会注意到，后散射选项在保留细节方面做得更好，这是预期的结果。差异很微小，所以我鼓励你稍后在一个好的显示屏上查看幻灯片。<br />
</p>


<div id="org1b84e13" class="figure">
<p><img src="./SkinRendering/burley-sss-impl3.jpg" alt="burley-sss-impl3.jpg" /><br />
</p>
</div>

<p>
由于 Burley 的 diffusion profiles 是归一化的，因此可以将 SSS 实现为一个能量守恒的模糊滤波器。你可以想象光能从入射点重新分布到周围的表面上.<br />
类似于之前的方法，我们在屏幕空间进行卷积，并利用深度缓冲来考虑表面的几何形状。<br />
</p>
</div>
<div id="outline-container-org2f304d6" class="outline-4">
<h4 id="org2f304d6">Subsurface Scattering Algorithm</h4>
<div class="outline-text-4" id="text-org2f304d6">

<div id="org921f635" class="figure">
<p><img src="./SkinRendering/burley-sss-impl4.jpg" alt="burley-sss-impl4.jpg" /><br />
</p>
</div>

<p>
Lighting pass:<br />
计算表面入射点处的入射辐射度(incident radiance)；<br />
从光源方向向表面内部进行 diffuse transmission （漫反射传输)；<br />
根据 texturing mode 应用入射点反照率；<br />
在渲染目标中记录传输的辐射度(radiance)<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-impl5.jpg" alt="burley-sss-impl5.jpg" /><br />
SSS pass:<br />
使用 diffuse profile 对 radiance buffer 进行双边滤波，以在出射点周围模拟扩散效果；<br />
根据 texturing mode 应用出射点反照率；<br />
在表面外部，在视图方向进行 diffuse transmission （漫反射传输）<br />
</p>

<p>
理想情况下，我们应该直接采样物体的表面，但这对实时应用来说开销太大。相反，我们使用一组在离线预计算的样本，并（概念上）将它们放在一个圆盘上，如上图中的虚线绿线所示。<br />
正如图片所示，这种平面近似并不一定与表面的形状匹配。更糟糕的是，由于将样本从圆盘投影到表面会扭曲距离，投影样本最终会落在不同的分布中。我们需要解决这个问题，但首先我们还是先谈一谈 disk sampling。<br />
</p>

<p>
注意：上面这种思路基本上是使用光子映射(photon mapping)的 SSS。<br />
</p>
</div>
</div>
<div id="outline-container-org0656a35" class="outline-4">
<h4 id="org0656a35">Sampling the Diffusion Profile</h4>
<div class="outline-text-4" id="text-org0656a35">
<p>
<img src="./SkinRendering/burley-sss-impl6-0.jpg" alt="burley-sss-impl6-0.jpg" /><br />
由于性能原因，我们只能采样一小部分样本，因此我们需要确保每个样本都是值得的。<br />
<img src="./SkinRendering/burley-sss-impl6-1.jpg" alt="burley-sss-impl6-1.jpg" /><br />
因此，我们采用重要性采样径向距离（radial distances）-我们根据 diffusion profile 的概率密度函数来分布它们。<br />
形状参数 s 是一个光谱值，它与散射距离成反比，而散射距离本身与方差成正比。<br />
由于我们希望最大可能地缩减方差(variance reduction)，我们选择重要性采样对应于最大散射距离的颜色通道（对于皮肤来说，是红色通道）。<br />
<img src="./SkinRendering/burley-sss-impl6-2.jpg" alt="burley-sss-impl6-2.jpg" /><br />
为了重要性采样，需要求累积分布函数（简称 CDF）的反函数。不幸的是，CDF 没有解析反函数，因此我们采用 Halley's 数值计算方法，该方法在实践中非常高效。<br />
</p>

<p>
Tips:<br />
CDF 是存在解析的反函数的。如下：<br />
<img src="./SkinRendering/burley-sss-impl6-4.jpg" alt="burley-sss-impl6-4.jpg" /><br />
</p>
<ul class="org-ul">
<li>inverse Burley CDF <a href="https://zero-radiance.github.io/post/sampling-diffusion/">https://zero-radiance.github.io/post/sampling-diffusion/</a><br /></li>
</ul>

<p>
<img src="./SkinRendering/burley-sss-impl6-3.jpg" alt="burley-sss-impl6-3.jpg" /><br />
最后，我们使用 Fibonacci sequence 来均匀采样 polar angle。它可以产生良好的球体和圆盘的样本分布，并且在许多情况下都很有用，比如 reflection probe filtering。<br />
我们使用蒙特卡罗积分方法来在 disk 上执行卷积。其实就是样本值和权重的点积。<br />
<img src="./SkinRendering/burley-sss-impl6-5.jpg" alt="burley-sss-impl6-5.jpg" /><br />
重要性采样过程会产生一个预计算的样本模式，可能会看起来像上图所示。注意，我们在原点附近采样更密集，因为大部分能量都集中在那里。<br />
</p>
</div>
</div>
<div id="outline-container-orgd387a43" class="outline-4">
<h4 id="orgd387a43">Bilateral Filtering</h4>
<div class="outline-text-4" id="text-orgd387a43">
<p>
<img src="./SkinRendering/burley-sss-impl7-0.jpg" alt="burley-sss-impl7-0.jpg" /><br />
现在我们知道如何预计算样本，前面提到由于将样本从圆盘投影到表面会扭曲距离，接下来解决该问题.<br />
</p>

<p>
由于表面几何形状与圆盘不对齐，并且我们使用预计算的样本，我们唯一的选择就是以某种方式重新为样本分配权重。这个过程被称为双边滤波。<br />
<img src="./SkinRendering/burley-sss-impl7-1.jpg" alt="burley-sss-impl7-1.jpg" /><br />
双边滤波使卷积考虑深度。这一点非常重要，不仅可以提高质量，还可以避免背景渗透到前景，反之亦然。如上图所示，没有使用双边滤波，使得背景中的草颜色渗透到了脸上。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-impl7-2.jpg" alt="burley-sss-impl7-2.jpg" /><br />
使用蒙特卡罗卷积公式，样本权重被定义为函数值与 PDF 之间的比率。修改函数值很容易-我们只需要使用进入点和出射点之间的欧几里得距离来求解 profile。<br />
</p>

<p>
注意：为了便于说明，数学上假设是一个直角三角形，因此使用勾股定理。一般来说，你还应该考虑透视扭曲(perspective distortion)[Mikkelsen 2010]。<br />
<img src="./SkinRendering/burley-sss-impl7-3.jpg" alt="burley-sss-impl7-3.jpg" /><br />
</p>

<p>
不幸的是，我们不能对 PDF 做同样的处理，因为我们的样本位置已经根据这个旧的“平面” PDF 进行了分布。<br />
</p>

<p>
如果我们将蒙特卡罗积分的公式与对面积积分的求积公式联系起来，我们可以看到 PDF 值与每个样本关联的面积成反比。但是如何计算这个面积？我们可以对表面做出某些假设，并添加一些余弦因子来考虑斜坡。<br />
然而，以一种通用和健壮（robust）的方式解决这个问题很困难，特别是由于屏幕空间中的信息是有限的。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-impl7-4.jpg" alt="burley-sss-impl7-4.jpg" /><br />
作为替代，我们可以简单地利用我们的滤波器应该是能量守恒的这一事实，将权重归一化为 1。<br />
</p>
</div>
</div>
<div id="outline-container-orgc24937d" class="outline-4">
<h4 id="orgc24937d">Orders of Approximation</h4>
<div class="outline-text-4" id="text-orgc24937d">
<p>
<img src="./SkinRendering/burley-sss-impl8-0.jpg" alt="burley-sss-impl8-0.jpg" /><br />
现在我们知道如何在圆盘上进行双边滤波，让我们考虑一下如何放置和定位这个圆盘。<br />
圆盘自然被放置在相机射线与几何体相交的位置，位于世界空间或相机空间。但是圆盘的方向呢？我们有几个选择。<br />
0 阶近似是将圆盘与屏幕平面平行，这直接对应于屏幕空间中的圆盘。这简单快速，但可能会导致几何体在斜角度上的样本分布不佳。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-impl8-1.jpg" alt="burley-sss-impl8-1.jpg" /><br />
更好的解决方案是将圆盘与表面点邻域的切平面对齐（一阶近似）。这可能很具有挑战性，因为 G-Buffer 通常不包含插值的顶点法线。不幸的是，使用着色法线可能会导致 artifacts，因为它通常与周围表面顶点的法线没有什么共同之处，甚至可能是背面的。<br />
</p>

<p>
值得注意的是，即使是简单的方法（0阶近似）在实践中也表现很好。<br />
</p>
</div>
</div>
<div id="outline-container-orgdf907b3" class="outline-4">
<h4 id="orgdf907b3">Translucency</h4>
<div class="outline-text-4" id="text-orgdf907b3">
<p>
<img src="./SkinRendering/burley-sss-impl9-0.jpg" alt="burley-sss-impl9-0.jpg" /><br />
SSS 也负责背光物体的半透明外观。<br />
虽然基本的物理过程完全相同，但出于效率原因，我们以一种更简单的方式来处理这种效果。我们实现了两种不同的方法。第一种方法只适用于薄物体（通常用于植被），第二种方法试图处理更一般的半透明情况。这两种方法之间的主要区别在于几何厚度，这迫使我们以两种不同的方式处理阴影。<br />
</p>
</div>
<div id="outline-container-org50e6a15" class="outline-5">
<h5 id="org50e6a15">Thin Object Translucency</h5>
<div class="outline-text-5" id="text-org50e6a15">
<p>
<img src="./SkinRendering/burley-sss-impl9-1.jpg" alt="burley-sss-impl9-1.jpg" /><br />
对于薄物体的半透明，我们使用 Jorge Jimenez 提出的简单模型。我们假设对于当前像素，几何体是一个具有恒定厚度的平面板，背面法线是反向的正面法线。厚度由艺术家创作的纹理贴图提供。<br />
此外，我们假设整个背面接收恒定的照明。由于几何体本身很薄，正面和背面的阴影是相同的，因此我们可以共享单个阴影贴图 fetch。<br />
在这种简化的设置下，可以在背面（back face）对 diffusion profile 的贡献进行解析积分。<br />
和之前一样，我们传输两次，并应用 front face 的反照率。<br />
</p>
</div>
</div>

<div id="outline-container-orgf78698c" class="outline-5">
<h5 id="orgf78698c">Thick Object Translucency</h5>
<div class="outline-text-5" id="text-orgf78698c">
<p>
<img src="./SkinRendering/burley-sss-impl9-2.jpg" alt="burley-sss-impl9-2.jpg" /><br />
对于较厚的物体，很明显不能重用 front face 的阴影（因为 back face 可能会遮挡 front face）。最初，我们尝试在运行时仅使用阴影贴图给出的最近遮挡物的距离来计算厚度。<br />
很明显，这种方法对于精细的几何特征来说效果不佳，因为阴影贴图的精度有限。<br />
作为替代，我们选择了一种杂合的方法。我们使用两种方法计算厚度，并取最大值，这为艺术家提供了使用“烘焙”厚度纹理来解决阴影映射问题的机会。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-impl9-3.jpg" alt="burley-sss-impl9-3.jpg" /><br />
这种方法确实需要一些微调，但是通过一些努力，可以实现合理的结果，如上图。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org145f1f2" class="outline-3">
<h3 id="org145f1f2">Optimizations</h3>
<div class="outline-text-3" id="text-org145f1f2">

<div id="org7c89de2" class="figure">
<p><img src="./SkinRendering/burley-sss-optimization0.jpg" alt="burley-sss-optimization0.jpg" /><br />
</p>
</div>

<p>
如我之前提到的，我们在离线重要性采样，并在运行时使用一组预计算的样本。SSS 通道本身是作为全屏 compute shader 实现的。<br />
它需要大量带宽，并且大量使用 LDS 来减少和芯片外存储器的数据传输。<br />
</p>
<ul class="org-ul">
<li>LDS （Local Data Share） <a href="./GPUArchitecture.html#org43b1c85">./GPUArchitecture.html#org43b1c85</a><br /></li>
</ul>


<div id="orge59f855" class="figure">
<p><img src="./SkinRendering/burley-sss-optimization1.jpg" alt="burley-sss-optimization1.jpg" /><br />
</p>
</div>

<p>
thread group（用数字表示）由 4 个 wavefronts 组成，线程按 Z-order curve 排序，以改善数据访问的局部性。<br />
LDS 缓存（显示为彩色块）包含 radiance 和线性深度值，并具有 2 个纹素的边界，以便每个像素至少有一个小的缓存邻居。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-optimization2.jpg" alt="burley-sss-optimization2.jpg" /><br />
我们在 G-Buffer Pass 期间用材质类型标记模板。这使我们能够创建分层模板表示，并在 SSS Pass 期间 discard 整个像素 tiles。<br />
在 lighting pass 期间，我们还标记 subsurface lighting buffer，以避免在 SSS Pass 期间执行每个像素的模板测试。<br />
我们还在 lighting pass 期间求解两个 transmission events(传输事件)。虽然这在概念上是错误的，但视觉差异非常小，这使我们可以在 SSS Pass 期间避免读取法线缓冲区。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-optimization3.jpg" alt="burley-sss-optimization3.jpg" /><br />
我们还实现了一个基本的 LOD 系统。<br />
我们根据滤波器在 3 个离散步骤中的屏幕空间 footprint 更改样本数量：<br />
我们禁用子像素大小的圆盘的滤波器，对于中等大小，我们使用 21 个样本，否则使用 55 个样本。<br />
</p>

<p>
视觉效果依然保持一致，LOD 过渡是不可见的。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-optimization4.jpg" alt="burley-sss-optimization4.jpg" /><br />
我们还发现随机按像素旋转样本分布很重要。这使我们可以用少量的噪声代替结构化的欠采样 artifacts。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-optimization5.jpg" alt="burley-sss-optimization5.jpg" /><br />
在 PS4 上，我们每个像素限制为 21 个样本。使用你在屏幕上看到的设置(PPT 中没有显示，具体设置信息)，compute shader 执行卷积并合并 diffuse 和 specular lighting buffers 需要 1.16 毫秒。<br />
</p>

<p>
<img src="./SkinRendering/burley-sss-vs-ssss.jpg" alt="burley-sss-vs-ssss.jpg" /><br />
<img src="./SkinRendering/burley-sss-vs-ssss1.jpg" alt="burley-sss-vs-ssss1.jpg" /><br />
Disney 模型的主要优点是更清晰的视觉效果，即使在相同的散射距离下也可以保留更多的法线贴图细节。<br />
</p>
</div>
</div>
<div id="outline-container-org83b4068" class="outline-3">
<h3 id="org83b4068">Limitation</h3>
<div class="outline-text-3" id="text-org83b4068">

<div id="orge15fb71" class="figure">
<p><img src="./SkinRendering/burley-limit0.jpg" alt="burley-limit0.jpg" /><br />
</p>
</div>

<p>
Subsurface 散射是将 subsurface lighting buffer 与 diffusion profile 卷积实现的。<br />
diffusion profile 是重要采样的，而光照不是。因此，光照信号的欠采样可能会导致典型的随机噪声。在足够的照明下，通常不会出现可见的问题。然而，人工照明条件可能会引起问题。<br />
例如，交替点亮和完全不点亮的简单棋盘格图案，在技术上来说这不是一个有限带宽的信号。<br />
我们使用时间抗锯齿来减少噪声量。<br />
</p>

<p>
<img src="./SkinRendering/burley-limit1.jpg" alt="burley-limit1.jpg" /><br />
我们方法的另一个局限性是卷积核具有非常大的屏幕 footprint。样本最终相距很远，破坏纹理高速缓存，降低了性能。<br />
最后，厚物体的半透明性做出了太多假设，无法为复杂厚物体产生准确的结果。<br />
</p>
</div>
</div>
<div id="outline-container-org48bac70" class="outline-3">
<h3 id="org48bac70">Future Work</h3>
<div class="outline-text-3" id="text-org48bac70">
<p>
<img src="./SkinRendering/burley-sss-futureW.jpg" alt="burley-sss-futureW.jpg" /><br />
在未来，我们希望将我们的实现进行扩展，以支持切线空间积分。由于插值顶点法线在 G-Buffer 中不可用，我们的计划是从深度缓冲区计算健壮的(robust)切线空间法线。<br />
</p>

<p>
对于半透明度，我们希望超越当前的“恒定厚度均匀照明板”模型。这需要对最近的背面进行 diffuse shading，并进行另一个屏幕空间 pass，将其与前面的 SSS 集成。<br />
</p>
</div>
</div>
<div id="outline-container-org59dbe87" class="outline-3">
<h3 id="org59dbe87">参考链接</h3>
<div class="outline-text-3" id="text-org59dbe87">
<ul class="org-ul">
<li>Cross Bilateral Filter <a href="http://techtidings.blogspot.com/2012/03/jointcross-bilateral-filter.html">http://techtidings.blogspot.com/2012/03/jointcross-bilateral-filter.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2221ce4" class="outline-2">
<h2 id="org2221ce4">Misc</h2>
<div class="outline-text-2" id="text-org2221ce4">
</div>
<div id="outline-container-orgf1cd9d5" class="outline-3">
<h3 id="orgf1cd9d5">Normal Map Mipmap</h3>
<div class="outline-text-3" id="text-orgf1cd9d5">
<p>
该文件展示了 normal map 的混合：<br />
<a href="./SkinRendering/111_normal_map_lerp.ggb">./SkinRendering/111_normal_map_lerp.ggb</a><br />
</p>

<ul class="org-ul">
<li>Normal Map Mipmap <a href="https://www.jianshu.com/p/efabea28ed1a">https://www.jianshu.com/p/efabea28ed1a</a><br /></li>
<li>Mipmapping_Normal_Maps <a href="https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf">https://developer.download.nvidia.com/whitepapers/2006/Mipmapping_Normal_Maps.pdf</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN video <a href="https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN">https://www.gdcvault.com/play/1014557/Spectacular-Specular-LEAN-and-CLEAN</a><br /></li>
<li>Spectacular-Specular-LEAN-and-CLEAN ppt <a href="https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html">https://fdocuments.in/document/spectacular-specular-lean-and-clean-specular-highlights-dan-baker-firaxis.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd138c14" class="outline-3">
<h3 id="orgd138c14">NoLWrap</h3>
<div class="outline-text-3" id="text-orgd138c14">
<p>
下面文件展示了 nol wrap 的曲线：<br />
<a href="./SkinRendering/111_nol_wrap.ggb">./SkinRendering/111_nol_wrap.ggb</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org75fc7de" class="outline-2">
<h2 id="org75fc7de">参考资料</h2>
<div class="outline-text-2" id="text-org75fc7de">
<ul class="org-ul">
<li>《GPU Gems 3》：真实感皮肤渲染技术总结 <a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a><br /></li>
<li>低成本皮肤渲染 Pre-integrated Skin <a href="https://zhuanlan.zhihu.com/p/35628106">https://zhuanlan.zhihu.com/p/35628106</a><br /></li>
<li>Pre-Integrated Skin <a href="http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html">http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html</a><br /></li>
<li>separable-sss <a href="https://github.com/iryoku/separable-sss">https://github.com/iryoku/separable-sss</a><br /></li>
<li>GPU Gem3 Advanced Techniques for Realistic Real-Time Skin Rendering<br /></li>
<li>GPU Pro 1 Screen-Space Subsurface Scattering<br /></li>
<li>GPU Pro 2 Part2 Chapter1 Pre-Integrated Skin Shading<br /></li>
<li>GPU Pro 5 Part4 Chapter1 Realistic Real-Time Skin Rendering on Mobile<br /></li>
<li>SoulShell：实时虚拟角色 <a href="https://zhuanlan.zhihu.com/soulshell">https://zhuanlan.zhihu.com/soulshell</a><br /></li>
<li>天刀渲染 <a href="https://zhuanlan.zhihu.com/p/295347623?utm_source=com.alibaba.android.rimet">https://zhuanlan.zhihu.com/p/295347623?utm_source=com.alibaba.android.rimet</a><br /></li>
<li>sss-intro <a href="https://therealmjp.github.io/posts/sss-intro/">https://therealmjp.github.io/posts/sss-intro/</a><br /></li>
<li>Exploring Character Art Workflows: Skin Texturing Tips <a href="https://80.lv/articles/exploring-character-art-workflows-skin-texturing-tips/">https://80.lv/articles/exploring-character-art-workflows-skin-texturing-tips/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'Skin Rendering',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
