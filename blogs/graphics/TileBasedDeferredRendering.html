<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-13 Fri 18:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TileBasedDeferredRendering</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" type="text/css" href="https://wolfand11.gitee.io/res/readtheorg_theme/css/htmlize.css"/>
         <link rel="stylesheet" type="text/css" href="https://wolfand11.gitee.io/res/readtheorg_theme/css/readtheorg.css"/>
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/lib/js/jquery.min.js"></script>
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/lib/js/bootstrap.min.js"></script>
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/lib/js/jquery.stickytableheaders.min.js"></script>
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/readtheorg_theme/js/readtheorg.js"></script>
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">TileBasedDeferredRendering</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4d62bbd">Immediate Mode Renderers (IMR)</a></li>
<li><a href="#org8c5962e">Tile Based Rendering (TBR)</a></li>
<li><a href="#org98955f6">Tile Based Deferred Rendering (TBDR)</a>
<ul>
<li><a href="#orgae7acae">Use Tile-Based Deferred Rendering Efficiently</a>
<ul>
<li><a href="#orgd93bdb0">避免 Logical Buffer Load 和 Store 操作</a></li>
<li><a href="#org721985c">Use Hidden Surface Removal Effectively</a></li>
</ul>
</li>
<li><a href="#org111222b">Q&amp;A</a>
<ul>
<li><a href="#orga3fcb8a">为什么 TBDR 可以实现 hidden surface removal ？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org31e2028">参考资料</a></li>
</ul>
</div>
</div>
<p>
TileBasedDeferredRendering note.<br />
</p>
<div class="HTML" id="orgdbf5e7e">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org4d62bbd" class="outline-2">
<h2 id="org4d62bbd">Immediate Mode Renderers (IMR)</h2>
<div class="outline-text-2" id="text-org4d62bbd">

<div id="org11df54e" class="figure">
<p><img src="./TileBasedDeferredRendering/00_imr_pipeline.jpg" alt="00_imr_pipeline.jpg" /><br />
</p>
</div>


<p>
Early Z 失效<br />
</p>
<ul class="org-ul">
<li>开启 Alpha Test（glEnable(GL_ALPHA_TEST)）：<br /></li>
<li>开启 Alpha Blend：<br /></li>
<li>Pixel Kill: pixel shader 中的 clip/discard 指令<br /></li>
<li>关闭深度测试：<br /></li>
<li></li>
</ul>
</div>
</div>

<div id="outline-container-org8c5962e" class="outline-2">
<h2 id="org8c5962e">Tile Based Rendering (TBR)</h2>
</div>

<div id="outline-container-org98955f6" class="outline-2">
<h2 id="org98955f6">Tile Based Deferred Rendering (TBDR)</h2>
<div class="outline-text-2" id="text-org98955f6">
</div>
<div id="outline-container-orgae7acae" class="outline-3">
<h3 id="orgae7acae">Use Tile-Based Deferred Rendering Efficiently</h3>
<div class="outline-text-3" id="text-orgae7acae">
</div>
<div id="outline-container-orgd93bdb0" class="outline-4">
<h4 id="orgd93bdb0">避免 Logical Buffer Load 和 Store 操作</h4>
<div class="outline-text-4" id="text-orgd93bdb0">
<p>
TBDR 图形处理器在绘制一个 Tile 时，会先将 framebuffer 对应的块从共享内存传输到 tile 内存中。这种内存的传输操作被称为 Logical Buffer Load。通常，在渲染下一帧时是不需要前一帧的内容的。为了避免加载前一帧缓冲区内容，可以在开始渲染新的一帧前调用 glClear。<br />
类似的，当 GPU 结束一个 Tile 的渲染后，必须将 tile 的像素数据写回共享内存。这种内存的传输操作被称为 Logical Buffer Store。渲染每帧必须至少有一次这样的数据传输，被显示在屏幕上的颜色渲染缓冲区必须被传输到共享内存，这样才会被 CoreAnimation 展示，其他的帧缓冲区（例如 depth stencil multisampling buffers）不需要保留，因为这些缓冲区的内容在下一帧会被重新创建。OpenGL ES 会自动将这些缓冲区写回共享内存，这会导致性能消耗。可以调用 glInvalidateFramebuffer（OpenGL ES 3.0）或者 glDiscardFramebufferEXT(OpenGL 1.1 or 2.0)来显示指定不写回共享内存。<br />
</p>
</div>
</div>
<div id="outline-container-org721985c" class="outline-4">
<h4 id="org721985c">Use Hidden Surface Removal Effectively</h4>
<div class="outline-text-4" id="text-org721985c">
<p>
当 blending 或者 alpha testing 开启，或者 fragment shader 中使用了 discard 或者使用 gl_FragDepth 输出变量。此时，GPU 无法使用深度缓冲区断定片段的可见性，因此必须为所有图元覆盖的每个像素点执行片段着色器。<br />
如果无法避免使用 blending、alpha testing、discard 指令，可以通过使用下面的策略来减少性能消耗：<br />
</p>
<ul class="org-ul">
<li>先渲染不透明物体，后渲染使用了 alpha testing、discard 指令的物体，最后渲染 alpha-blended 的物体<br /></li>
<li>修剪需要 discard、alpha-blended 的物体，减少处理的片段数量。<br /></li>
<li>在片段着色器中尽早使用 discard 指令，避免执行无用的计算。<br /></li>
<li>使用 alpha blending(将 alpha 设置为 zero)代替 alpha testing 或 discard 指令。这样颜色帧缓冲区不被修改，但是图形硬件依然可以使用 Z-buffer 进行优化处理。这样做确实修改了 depth buffer 中存储的值，所以需要从后到前排序透明图元。<br /></li>
<li>如果性能被不可避免的 discard 操作影响，可以考虑 Z-Prepass 渲染策略。先使用简单的片段着色器(其中只包含 discard 逻辑，避免耗时的光照计算)渲染一遍场景来填充 depth buffer。然后使用 GL_EQUAL 深度测试和光照渲染再渲染一遍场景。尽管多次渲染通常会导致性能问题，这种方式要比单次渲染中包含大量 discard 操作要性能更佳。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org111222b" class="outline-3">
<h3 id="org111222b">Q&amp;A</h3>
<div class="outline-text-3" id="text-org111222b">
</div>
<div id="outline-container-orga3fcb8a" class="outline-4">
<h4 id="orga3fcb8a">为什么 TBDR 可以实现 hidden surface removal ？</h4>
<div class="outline-text-4" id="text-orga3fcb8a">
<p>
因为 TBDR 中，当提交渲染指令到硬件后，渲染指令会被缓存到一个列表中。硬件不会处理这些指令，直到你显示 renderbuffer 或者 flush 指令 buff 时，才会开始处理顶点并且对像素着色。所以 TBDR 一次性处理了场景的所有顶点，这样 GPU 就可以在片段被处理之前知道场景中所有对象的遮挡关系从而进行隐藏表面消除。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org31e2028" class="outline-2">
<h2 id="org31e2028">参考资料</h2>
<div class="outline-text-2" id="text-org31e2028">
<ul class="org-ul">
<li><a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Performance/Performance.html">https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Performance/Performance.html</a><br /></li>
<li><a href="http://prog3.com/sbdm/blog/u013467442/article/details/40684479">http://prog3.com/sbdm/blog/u013467442/article/details/40684479</a><br /></li>
<li>深入 GPU 硬件架构及运行机制 <a href="https://www.cnblogs.com/timlly/p/11471507.html">https://www.cnblogs.com/timlly/p/11471507.html</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
