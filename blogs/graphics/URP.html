<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-22 Thu 18:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>URP</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.github.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.github.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.github.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.github.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.github.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.github.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">URP</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgdc3535c">CoreRP</a>
<ul>
<li><a href="#orgff3a530">Base</a>
<ul>
<li><a href="#org98ca4bb">Render Requests</a></li>
<li><a href="#orgc3a5f9f">RenderGraph</a>
<ul>
<li><a href="#org886cab1">Render graph fundamentals</a>
<ul>
<li><a href="#orgfa5d167">Main principles</a></li>
<li><a href="#orgc00861c">Resource Management</a></li>
<li><a href="#org5e9902e">Render graph execution overview</a></li>
</ul>
</li>
<li><a href="#orgd431ce0">参考资料</a></li>
</ul>
</li>
<li><a href="#orga41a0f3">RTHandle system</a></li>
<li><a href="#org10a92b7">Rendering Debugger</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb4cf694">URP</a>
<ul>
<li><a href="#orgc715c4e">Base</a>
<ul>
<li><a href="#org169a2cb">源码分析</a>
<ul>
<li><a href="#orgae73d74">源码分析方法</a>
<ul>
<li><a href="#org329a390">method 1: use urp</a></li>
<li><a href="#org1d23e4d">method 2: static analysis and editor debugging method</a></li>
<li><a href="#orge9c3b0b">method 3: app profiling method</a></li>
</ul>
</li>
<li><a href="#orga2e0aaf">RenderingPath</a>
<ul>
<li><a href="#org7db766a">Forward Rendering Path</a></li>
<li><a href="#orgab329c9">Deferred Rendering Path</a></li>
<li><a href="#org562157a">Forward Plus Rendering Path</a></li>
<li><a href="#orgf40e69d">参考资料</a></li>
</ul>
</li>
<li><a href="#org1e0f5f3">Forward Plus</a>
<ul>
<li><a href="#orgc244b93">URP12 ClusterRendering</a></li>
<li><a href="#org40df43d">URP14 ForwardPlus</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9804c6b">Native RenderPass</a></li>
<li><a href="#orgb2a5e9a">URPAsset</a>
<ul>
<li><a href="#orge9dc466">Runtime 修改 URPAsset 设置</a></li>
</ul>
</li>
<li><a href="#org2d603a3">RenderFeature</a>
<ul>
<li><a href="#orgd81cff0">Disable/Enable RenderFeature Runtime</a></li>
<li><a href="#org8eef992">Custom RenderFeature</a>
<ul>
<li><a href="#orgbc5acda">template</a></li>
<li><a href="#orgc6893e0">kawase blur</a></li>
<li><a href="#org1888f90">len flares</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org82dcb3e">Volume Framework</a>
<ul>
<li><a href="#orgb749e17">VolumeManager</a></li>
<li><a href="#orga75fc99">VolumeStack</a></li>
<li><a href="#org15516be">VolumeComponent</a></li>
<li><a href="#org1cc382e">VolumeParameter</a></li>
<li><a href="#orgcdda3e6">Volume</a>
<ul>
<li><a href="#org1587c7a">Volume Inspector 参数</a></li>
<li><a href="#org3bc6744">Volume 实现</a></li>
</ul>
</li>
<li><a href="#org796dfb1">VolumeProfile</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6b62fb5">Shader</a>
<ul>
<li><a href="#org57c3ff7">MultiPass</a></li>
<li><a href="#org79bb383">Lightmap 烘培</a></li>
<li><a href="#org4f3ca39">MRT</a></li>
</ul>
</li>
<li><a href="#org6751e26">Misc</a>
<ul>
<li><a href="#org378ab87">Upgrade Buildin Shader To URP</a>
<ul>
<li><a href="#org01b19c4">Point Light Effect Error</a></li>
<li><a href="#orgf8a9d15">Common</a></li>
</ul>
</li>
<li><a href="#orge9f53ea">Unity Buildin 和 URP 支持的 Feature 对比</a></li>
<li><a href="#org4682d78">创建一个 Lit Shader Graph 默认文件，生成的 shader 代码</a></li>
<li><a href="#org96d2c06">URP Buildin GI 比较</a></li>
<li><a href="#org970dc63">RenderTarget Load Store 设置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7183aad">HDRP</a>
<ul>
<li><a href="#org3978376">Base</a>
<ul>
<li><a href="#org90b407d">Introduce</a>
<ul>
<li><a href="#org1e268c7">What problem is HDRP trying to solve?</a>
<ul>
<li><a href="#org0a97659">统一、一致的光照</a></li>
<li><a href="#orgd829d05">性能至上</a></li>
<li><a href="#orge5cd6e4">最先进的技术</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org53c6bb1">Setup</a></li>
<li><a href="#orgb5c4a58">源码分析</a></li>
<li><a href="#org72e0802">RP Settings</a>
<ul>
<li><a href="#org3e938bc">HDRP Asset</a></li>
<li><a href="#orgcc23c2f">HDRP Global Settings</a></li>
<li><a href="#orgd9677aa">Frame Settings</a></li>
</ul>
</li>
<li><a href="#org34815a7">Shaders and Materials</a>
<ul>
<li><a href="#org0e2632f">Shaders</a>
<ul>
<li><a href="#org602a37e">AxF Shader</a></li>
<li><a href="#org86fc008">Decal</a></li>
<li><a href="#orgb002f90">Cotton/Wool Shader</a></li>
<li><a href="#org3bc7e77">Eye Shader</a></li>
<li><a href="#org467f957">Fog Volume Shader</a></li>
<li><a href="#org15d7132">Fullscreen Shader</a></li>
<li><a href="#orgf83c221">Hair Shader</a></li>
<li><a href="#orgf38fee9">Layered Lit Shader</a></li>
<li><a href="#org55f3315">Layered Lit Tessellation Shader</a></li>
<li><a href="#orgcce9453">Lit Shader</a></li>
<li><a href="#org2b59b01">Lit Tessellation Shader</a></li>
<li><a href="#orgb1919f4">Silk Shader</a></li>
<li><a href="#org4481e06">Terrain Lit Shader</a></li>
<li><a href="#org1bcaf76">Unlit Shader</a></li>
</ul>
</li>
<li><a href="#orgd673307">Material Type</a>
<ul>
<li><a href="#orgab63903">Subsurface Scattering</a></li>
<li><a href="#org7448c41">Compute Thickness</a></li>
</ul>
</li>
<li><a href="#org0bc9cf0">Master Stacks</a>
<ul>
<li><a href="#org287979b">Decal Master Stack</a></li>
<li><a href="#org79a7299">Eye Master Stack</a></li>
<li><a href="#orgf4bd8c8">Fabric Master Stack</a></li>
<li><a href="#org1edadc2">Fog Volume Master Stack</a></li>
<li><a href="#orge9a09c4">Fullscreen Master Stack</a></li>
<li><a href="#org10e2eb8">Hair Master Stack</a></li>
<li><a href="#org00a8a80">Lit Master Stack</a></li>
<li><a href="#org0cf831e">StackLit Master Stack</a></li>
<li><a href="#org8dbaea4">Unlit Master Stack</a></li>
<li><a href="#org4fda4a4">Canvas Master Stack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2176401">Lighting</a>
<ul>
<li><a href="#org65d27a1">Light</a>
<ul>
<li><a href="#org9daa567">Physical Light Units and Intensities</a></li>
<li><a href="#org515d21e">Exposure</a></li>
</ul>
</li>
<li><a href="#org38260df">SSGI RTGI</a></li>
<li><a href="#orgb939073">Reflection and Refraction</a>
<ul>
<li><a href="#org70d5072">Reflection</a></li>
<li><a href="#orgda74998">Refraction</a></li>
<li><a href="#org5eca10e">Recursive rendering</a></li>
<li><a href="#orgd2f664f">Path tracing</a></li>
<li><a href="#orgf1a0b90">How HDRP calculates color for reflection and refraction</a></li>
</ul>
</li>
<li><a href="#org4cddb2a">Environment Lighting</a>
<ul>
<li><a href="#org8efefc2">Visual Environment</a></li>
<li><a href="#org235cad3">Lighting Environment</a></li>
</ul>
</li>
<li><a href="#org4031aa4">Volumetric Lighting</a>
<ul>
<li><a href="#org1526820">Enabling Volumetric Lighting</a></li>
<li><a href="#org8203a0d">Fog</a></li>
</ul>
</li>
<li><a href="#org7f320e1">Shadow</a>
<ul>
<li><a href="#orgb7b77bb">Contact Shdows</a></li>
<li><a href="#org8773fcb">Micro Shadows</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4ab3b17">PostProcess</a>
<ul>
<li><a href="#org16c5c13">Exposure</a></li>
</ul>
</li>
<li><a href="#org673dfbe">Q&amp;A</a>
<ul>
<li><a href="#org4ed57aa">为什么 HDRP Global Settings 的 FrameSettings 部分又分了 Camera，Realtime Reflection、Baked or Custom Reflection 3 部分？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdf4f3fd">URP and HDRP Coexistence</a>
<ul>
<li><a href="#orgd7c74d5">Feature comparison</a>
<ul>
<li><a href="#org155e1f7">Platform Support</a></li>
<li><a href="#orge125447">Lighting</a></li>
</ul>
</li>
<li><a href="#orgfab7132">参考资料</a></li>
</ul>
</li>
<li><a href="#org9647968">ERROR</a>
<ul>
<li>
<ul>
<li><a href="#org075b550">Material 'Liquid' with Shader 'Custom/MyEffect/Unlit/Liquid' doesn't have a texture property '_MainTex' UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&amp;)</a></li>
<li><a href="#orgf5f1a53">error CS0246: The type or namespace name 'UnityTestAttribute' could not be found</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8bdc295">Terminology</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#org4bd1642">RTHandle</a></li>
<li><a href="#org462d16c">Light Cluster</a></li>
<li><a href="#org51a8d60">Render Graph</a></li>
<li><a href="#org6ee5fd6">AOV</a></li>
<li><a href="#orgca819a9">FPTL(Fine Pruned Tiled Lighting)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9ca30ee">参考资料</a></li>
</ul>
</div>
</div>
<p>
URP note.<br />
</p>
<div class="HTML" id="orgf02fa28">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgdc3535c" class="outline-2">
<h2 id="orgdc3535c">CoreRP</h2>
<div class="outline-text-2" id="text-orgdc3535c">
</div>
<div id="outline-container-orgff3a530" class="outline-3">
<h3 id="orgff3a530">Base</h3>
<div class="outline-text-3" id="text-orgff3a530">
</div>
<div id="outline-container-org98ca4bb" class="outline-4">
<h4 id="org98ca4bb">Render Requests</h4>
<div class="outline-text-4" id="text-org98ca4bb">
<p>
你可以使用 render request 在 Unity 渲染循环外，触发一个相机渲染到一个 render texture. 这些 render request 按照在 script 中的执行顺序被处理，所以不会涉及到回调。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@16.0/manual/User-Render-Requests.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@16.0/manual/User-Render-Requests.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc3a5f9f" class="outline-4">
<h4 id="orgc3a5f9f">RenderGraph</h4>
<div class="outline-text-4" id="text-orgc3a5f9f">
</div>
<div id="outline-container-org886cab1" class="outline-5">
<h5 id="org886cab1">Render graph fundamentals</h5>
<div class="outline-text-5" id="text-org886cab1">
</div>
<div id="outline-container-orgfa5d167" class="outline-6">
<h6 id="orgfa5d167">Main principles</h6>
<div class="outline-text-6" id="text-orgfa5d167">
<p>
在使用 RenderGraph API 写 render passes 之前，你需要知道下面一些基本原则：<br />
</p>
<ul class="org-ul">
<li>你不再需要直接处理资源了，你需要使用 render graph 系统指定的 handles。所有 RenderGraph APIs 都使用这些 handles 来操作资源。render graph 管理的资源类型有 RTHandles, ComputeBuffers 以及 RendererLists<br /></li>
<li>实际的资源引用只可以在一个 render pass 的执行代码（execution code）中被访问<br /></li>
<li>该框架要求显示声明 render passes。每个 render pass 必须声明其从哪些资源进行读取，又会写入到哪些资源<br /></li>
<li>每次执行 render graph，都不会进行持久化。这意味着在某次执行 render graph 中创建的资源无法传递到下一帧<br /></li>
<li>对于哪些需要持久化的资源（例如，从一帧传递给另外一帧的资源），你可以在 render graph 外面创建该资源，然后将其导入到 render graph。在依赖跟踪方面，它们的行为与任何其他 render graph 资源一样，但该 render graph 不处理它们的生命周期。<br /></li>
<li>render graph 主要使用 RTHandles 作为纹理资源。这对如何编写着色器代码以及如何设置它们有很多影响。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc00861c" class="outline-6">
<h6 id="orgc00861c">Resource Management</h6>
<div class="outline-text-6" id="text-orgc00861c">
<p>
render graph system 使用一帧的 high-level 表示来计算每个资源的生命周期。这意味着当你使用 RenderGraph API 创建一个资源时，render graph 系统此时并不会创建该资源。API 只是返回一个表示该资源的 handle(句柄)，你通过该 handle 来使用所有的 RenderGraph APIs。render graph 只会在第一个 pass 需要写入该资源前创建该资源。这样，创建和分配就可以分离开，创建并不意味着 render graph system 分配资源。相反，这意味着它提供了必要的内存来表示资源，以便它可以在渲染过程中使用该资源。 同理，它也会在最后一次需要读取该资源的 pass 之后释放该资源的内存。这样，render graph sytem 可以根据你在 pass 中声明的内容以最有效的方式重用内存。如果 render graph system 不执行需要指定资源的 pass，则系统不会为该资源分配内存。<br />
</p>
</div>
</div>
<div id="outline-container-org5e9902e" class="outline-6">
<h6 id="org5e9902e">Render graph execution overview</h6>
<div class="outline-text-6" id="text-org5e9902e">
<p>
render graph 的执行是一个三步过程（设置，编译，执行），每一帧 render graph 都会从头开始。 这是因为 graph 可以在帧与帧之间动态变化，例如，graph 会根据用户的操作而变化。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org19b546c"></a>Setup<br />
<div class="outline-text-7" id="text-org19b546c">
<p>
首先，设置所有的 render passes。在这里，你声明所有要执行的 render passes，以及每个 render pass 使用的资源。<br />
</p>
</div>
</li>
<li><a id="org9c9a102"></a>Compilation<br />
<div class="outline-text-7" id="text-org9c9a102">
<p>
其次，编译该 render graph。在该步骤中，render graph system 会剔除无用的 render pass(若 render pass 的输出没有被使用，则该 render pass 是无用的)。这样做可以减少 Setup 的处理工作(在设置 render graph 时不需要处理特殊逻辑了)。debug render passes 就是一个很好的离子。如果你声明了一个 render pass 来生成一些调试话输出，你不需要将其展现到 back buffer，render graph system 会自动剔除该 render pass。<br />
</p>

<p>
此步骤还会计算资源的生命周期。 这允许 render graph system 以高效的方式创建和释放资源，并可以正确计算同步点，以同步在 async compute pipeline 上执行 passes。<br />
</p>
</div>
</li>
<li><a id="orgbe45ad9"></a>Execution<br />
<div class="outline-text-7" id="text-orgbe45ad9">
<p>
最后，执行 render graph。render graph system 按照什么的顺序执行所有未被剔除的 render passes。在每个 render pass 之前，render graph system 会创建合适的资源，并在 render pass 之后释放这些资源(若这些资源不在被后续的 render passes 使用)<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd431ce0" class="outline-5">
<h5 id="orgd431ce0">参考资料</h5>
<div class="outline-text-5" id="text-orgd431ce0">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@16.0/manual/render-graph-system.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@16.0/manual/render-graph-system.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga41a0f3" class="outline-4">
<h4 id="orga41a0f3">RTHandle system</h4>
</div>
<div id="outline-container-org10a92b7" class="outline-4">
<h4 id="org10a92b7">Rendering Debugger</h4>
<div class="outline-text-4" id="text-org10a92b7">
<p>
实现 Rendering Debugger 的 Editor 代码在 Packages\com.unity.render-pipelines.core\Editor\Debugging\DebugWindow.cs。可以将自己的扩展嵌入到其中。可以参考 URP 中 DebugDisplaySettingsRendering 的实现。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb4cf694" class="outline-2">
<h2 id="orgb4cf694">URP</h2>
<div class="outline-text-2" id="text-orgb4cf694">
</div>
<div id="outline-container-orgc715c4e" class="outline-3">
<h3 id="orgc715c4e">Base</h3>
<div class="outline-text-3" id="text-orgc715c4e">
</div>
<div id="outline-container-org169a2cb" class="outline-4">
<h4 id="org169a2cb">源码分析</h4>
<div class="outline-text-4" id="text-org169a2cb">
<p>
<a href="./URP/Unity URP.xmind">./URP/Unity URP.xmind</a><br />
</p>

<p>
下图为 URP 处理流程：<br />
<img src="./URP/urp-flow.jpg" alt="urp-flow.jpg" /><br />
</p>

<p>
URP 12.1.6 版本中 ForwardRenderer 变为了 UniversalRenderer<br />
</p>

<ul class="org-ul">
<li>Unity URP 简要剖析 <a href="https://zhuanlan.zhihu.com/p/399297398">https://zhuanlan.zhihu.com/p/399297398</a><br /></li>
</ul>
</div>
<div id="outline-container-orgae73d74" class="outline-5">
<h5 id="orgae73d74">源码分析方法</h5>
<div class="outline-text-5" id="text-orgae73d74">
</div>
<div id="outline-container-org329a390" class="outline-6">
<h6 id="org329a390">method 1: use urp</h6>
<div class="outline-text-6" id="text-org329a390">
<p>
查看官方文档，了解 urp 相关的概念，功能。使用 urp 提供的功能。从整体来了解 urp。<br />
</p>
</div>
</div>

<div id="outline-container-org1d23e4d" class="outline-6">
<h6 id="org1d23e4d">method 2: static analysis and editor debugging method</h6>
<div class="outline-text-6" id="text-org1d23e4d">
<p>
将 com.unity.render-pipelines.core@14.0.7 和 com.unity.render-pipelines.universal@14.0.7 从 Test/Library/PackageCache 目录 copy 到 Test/Packages 目录，方便对 urp 源码进行修改来辅助调试。<br />
</p>

<p>
在 editor 下对源代码进行调试，结合对 urp 源代码静态分析，来分析 URP 的执行逻辑。<br />
</p>

<p>
可以使用 Understand 工具来辅助 urp 源代码的静态分析。 <a href="../tools/DeveloperTools.html#orgef5d86a">Understand 静态代码分析</a><br />
</p>
</div>
</div>
<div id="outline-container-orge9c3b0b" class="outline-6">
<h6 id="orge9c3b0b">method 3: app profiling method</h6>
<div class="outline-text-6" id="text-orge9c3b0b">
<p>
首先，编译 Windows 版本进行分析，BuildSettings 设置如下：<br />
Development Build = True<br />
Deep Profiling Support = True<br />
Script Debugging = True<br />
</p>

<p>
其次，使用 Unity Profiler 工具对 Test.exe 进行 Profiler<br />
在 Timeline 中可以看到一帧中，主线程和渲染线程函数的调用顺序，如下图：<br />
</p>


<div id="org6a9e5c5" class="figure">
<p><img src="./URP/urp-source-code01.jpg" alt="urp-source-code01.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga2e0aaf" class="outline-5">
<h5 id="orga2e0aaf">RenderingPath</h5>
<div class="outline-text-5" id="text-orga2e0aaf">
</div>
<div id="outline-container-org7db766a" class="outline-6">
<h6 id="org7db766a">Forward Rendering Path</h6>
<div class="outline-text-6" id="text-org7db766a">
<p>
前向渲染伪代码如下，可以看出 N 个物体 M 个光源的情况下，运行复杂度为 O(N*M)。光源数量对于计算复杂度影响很大，比较适合光源数量比较少的情况。<br />
</p>
<pre class="example" id="org5f36d15">
For each light:
    For each object affected by the light:
        framebuffer += object * light
</pre>
</div>
<ul class="org-ul">
<li><a id="orgcca376b"></a>优点<br />
<div class="outline-text-7" id="text-orgcca376b">
<ul class="org-ul">
<li>每个物体可以使用不同的光照模型和渲染技术<br /></li>
<li>支持 MSAA<br /></li>
</ul>
</div>
</li>
<li><a id="org69d8f04"></a>缺点<br />
<div class="outline-text-7" id="text-org69d8f04">
<ul class="org-ul">
<li>pixel shader 比较复杂，导致 Overdraw 消耗严重<br /></li>
<li>对多光源不友好，像素不受光源影响时，也需要处理该光源光照（CPU 端无法精确剔除，只要光源和物体有交集，物体的任何一点都需要处理光照）<br /></li>
<li>shader 中需要处理不同的光源类型，增加了 shader 变体或分支<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgab329c9" class="outline-6">
<h6 id="orgab329c9">Deferred Rendering Path</h6>
<div class="outline-text-6" id="text-orgab329c9">
<pre class="example" id="orgaf4850e">
For each object:
    Render to multiple targets
For each light:
    Apply light as a 2D postProcess
</pre>
</div>
<ul class="org-ul">
<li><a id="orge2cb2d1"></a>优点<br />
<div class="outline-text-7" id="text-orge2cb2d1">
<ul class="org-ul">
<li>解耦了 Mesh Draw 和 Light Draw，保证物体只被绘制一次，光源也只绘制一次，整体场景 Draw call 复杂度变成了 O(M+N)<br /></li>
<li>G-Buffer 除了用于直接光照外，还能够被用于一些间接光照的效果，也正是 G-Buffer 概念的提出，使得近十年来越来越多的算法从 World space 向 Screen Space 的演进<br /></li>
<li>使得每个着色器都专注于几何参数提取或者照明。这种分离使着色器的功能进行拆分，简化了着色器系统管理。使得 Shader 支持功能更加单一(这是优点也是缺点)<br /></li>
<li>只渲染可见的像素，节省计算量<br /></li>
</ul>
</div>
</li>
<li><a id="orgdd400c4"></a>缺点<br />
<div class="outline-text-7" id="text-orgdd400c4">
<ul class="org-ul">
<li>内存开销较大，G-Buffer 是主要元凶<br /></li>
<li>需要 MRT 的支持(OpenGL|ES3.0)<br /></li>
<li>读写 G-buffer 的内存带宽用量是性能瓶颈。每个光源计算都会去读取 GBuffer<br /></li>
<li>对透明物体的渲染存在问题。大多数是在 Deferred 渲染完之后，让透明物体走 Forward 渲染<br /></li>
<li>对多重采样抗锯齿(MultiSampling Anti-Aliasing, MSAA)的支持不友好<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org562157a" class="outline-6">
<h6 id="org562157a">Forward Plus Rendering Path</h6>
<div class="outline-text-6" id="text-org562157a">
<pre class="example" id="orgc984660">
foreach object in sceen
        get depth
foreach tile in screen:
        get max min depth
        Frustum  Intersection test
        Generate a list of light
foreach pixel in screen:
    foreach light in light_list_of_this_tile:
        pixelLighting += light_contribution_to_pixel(light,pixel)
</pre>
</div>
</div>
<div id="outline-container-orgf40e69d" class="outline-6">
<h6 id="orgf40e69d">参考资料</h6>
<div class="outline-text-6" id="text-orgf40e69d">
<ul class="org-ul">
<li>Tile Base Render (Forward+) <a href="https://zhuanlan.zhihu.com/p/553907076">https://zhuanlan.zhihu.com/p/553907076</a><br /></li>
<li>URP12 ClusterRendering 调研 <a href="https://zhuanlan.zhihu.com/p/489839605">https://zhuanlan.zhihu.com/p/489839605</a><br /></li>
<li>Deferred Shading <a href="./UnityCatLikeCoding.html#orgc1c5383">./UnityCatLikeCoding.html#orgc1c5383</a><br /></li>
<li>Deferred Lights  <a href="./UnityCatLikeCoding.html#org470faef">./UnityCatLikeCoding.html#org470faef</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1e0f5f3" class="outline-5">
<h5 id="org1e0f5f3">Forward Plus</h5>
<div class="outline-text-5" id="text-org1e0f5f3">
</div>
<div id="outline-container-orgc244b93" class="outline-6">
<h6 id="orgc244b93">URP12 ClusterRendering</h6>
<div class="outline-text-6" id="text-orgc244b93">
</div>
<ul class="org-ul">
<li><a id="org114dc9e"></a>cluster 排布<br />
<div class="outline-text-7" id="text-org114dc9e">

<div id="orgeb16079" class="figure">
<p><img src="./URP/cluster-subdivide.jpg" alt="cluster-subdivide.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf">https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf</a><br /></li>
<li>Cluster_Unity 实现概述 <a href="https://zhuanlan.zhihu.com/p/71932575">https://zhuanlan.zhihu.com/p/71932575</a><br /></li>
</ul>
</div>
</li>
<li><a id="org3dc6f63"></a>整体思路<br />
<div class="outline-text-7" id="text-org3dc6f63">
<ul class="org-ul">
<li>所有灯光根据离相机的距离按照从前向后排序<br /></li>
<li>将屏幕划分成多个 Tile，计算出每个 Tile 内包含的灯光，使用 Mask 来保存（例如第 3 位为 1 表示第三个灯和 Tile 相交，三这个序号由第一步的排序决定）。一个 Mask 使用一个 uint 表示，如果灯光超出 32 个，则会再多使用对应个数的 uint<br /></li>
<li>将相机根据近远裁平面从前往后切分成多个 Bin，每个 Bin 保存和其相交的最近和最远的灯光的序号（也就是会存下来两个值，minIndex 和 maxIndex，分别映射到由第一步得到的排序序号）<br /></li>
<li>将第二第三步得到的数据存储到 Constant Buffer 中待之后 GPU 读取<br /></li>
<li>光照着色时，首先，会根据当前顶点所在的 Tile 来读出对应的 Mask。其次，根据当前顶点所在 Bin，使用 Bin 的 minIndex 和 maxIndex 对刚刚读取到的 Mask 做一次过滤来得到最终受影响的灯光（例如 Mask 为 10011001，为了简化这里只用了 8 位。而 minIndex 为 4，maxIndex 为 6，这两个值代表的范围为 00111000。将这个范围与 Mask 做一次与运算后得到 00011000，便为最终影响这个顶点的那些灯光，即第 4 和第 5 个灯）。在获取到具体哪个灯后便可以执行正常的光照计算了<br /></li>
</ul>
</div>
</li>
<li><a id="org956a681"></a>参考资料<br />
<div class="outline-text-7" id="text-org956a681">
<ul class="org-ul">
<li>URP12 ClusterRendering 调研 <a href="https://zhuanlan.zhihu.com/p/489839605">https://zhuanlan.zhihu.com/p/489839605</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org40df43d" class="outline-6">
<h6 id="org40df43d">URP14 ForwardPlus</h6>
<div class="outline-text-6" id="text-org40df43d">
</div>
<ul class="org-ul">
<li><a id="org530a5cf"></a>整体思路<br />
<div class="outline-text-7" id="text-org530a5cf">
<ul class="org-ul">
<li>计算所有灯光的 minZ maxZ<br /></li>
<li>将相机根据近远裁平面从前往后切分成多个 Bin<br />
  使用 body bitmask 来存储每个 Bin 和所有灯光的相交关系（例如 BodyMask 00011001 表示和第 0，3，4 个灯光相交, 为了简化这里只用了 8 位 mask）<br />
使用 header bitmask 来存储 bin 内所有灯光的 minIndex 和 maxIndex（例如 HeaderMask 01000000 表示 minIndex 为 0，maxIndex 为 4，为了简化这里只是用了 4 位存储 lightIndex）<br /></li>
<li>将屏幕划分成多个 Tile, 计算每个灯光与 tiles 的相交情况，记录在 tileRanges 中。(为了计算一个灯光和所有 tiles 的相交关系，需要使用 1+tileResolution.y 个 range)<br />
range0 表示 Y 方向上灯光和 tiles 相交的最下面的行号和最上面的行号<br />
range1 表示 X 方向上灯光和第 1 行 tiles 相交的最左边列好和最右边列好<br />
rangeX 表示 X 方向上灯光和第 X 行 tiles 相交的最左边列好和最右边列好<br /></li>
<li>将上一步得到的 tileRanges 数据转化为 bitmask 数据，bitmask 数据为每个 tile 和所有灯光的相交关系。<br />
例如：Mask 00101001 表示当前 tile 和第 0，3，5 个灯光相交<br /></li>
<li>将第 2 步，第 4 步得到的数据存储到 Constant Buffer 中待之后 GPU 读取<br /></li>
<li>光照着色时，根据着色的位置计算出其所在的 tile 和 bin，然后读出 tileMask 和 binMask，两个 mask 做与得出影响当前着色点的灯光。<br />
例如：<br />
binBodyMask=00011001<br />
binHeaderMask=01000000(表示 minLightIndex 为 0，maxLightIndex 为 4，这两个值代表的范围为 00011111) 所以 binHeaderFinalMask=00011111<br />
tileMask=00101001<br />
bitMask &amp; tileMask=00001001 (表示第 0，3 个灯光对当前着色点有影响)<br />
bitMask &amp; tileMask &amp; binHeaderFinalMask = 00001001 (表示最终只有第 0, 3 个灯光对当前着色点有影响)<br /></li>
</ul>
</div>
</li>
<li><a id="orga5840a2"></a>Source Code<br />
<div class="outline-text-7" id="text-orga5840a2">
<p>
下面源码分析使用 14.08 版本的 URP:<br />
使用 unitycatlike\Assets\MyTest\URP_SRP\09_ForwardPlus\09_ForwardPlus-Simple.unity 示例场景<br />
GameView 分辨率设置为 1334, 750 iPhone8 分辨率<br />
Camera nearPlane=0.3 farPlane=1000<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9f284ba"></a>ForwardLight(InitParams initParams)<br />
<div class="outline-text-8" id="text-org9f284ba">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CreateForwardPlusBuffers</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UniversalRenderPipeline.maxZBinWords = 1024*4  &#36825;&#37324;&#30340;word&#23545;&#24212;&#30340;&#26159;&#19968;&#20010;uint&#30340;&#20869;&#23384;&#22823;&#23567;&#65292;&#19968;&#33324;&#20026;32bit</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27880;&#24847;&#65306;m_ZBins &#23384;&#20648;&#20102;&#22810;&#20010;bin&#30340;&#25968;&#25454;&#65292;&#20551;&#35774;&#19968;&#20010;bin&#23545;&#24212;m_ZBins&#20013;&#30340;elemsPerBin&#20010;element</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//      </span><span style="color: #2aa1ae; background-color: #292e34;">headerLength = 2</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//      </span><span style="color: #2aa1ae; background-color: #292e34;">elemsPerBin = headerLength+wordsPerTile</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">binCount</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//      </span><span style="color: #2aa1ae; background-color: #292e34;">&#20551;&#35774; n0=1 &#26469;&#31616;&#21270;&#38382;&#39064;, &#27492;&#26102;log2(n0)=0</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//      </span><span style="color: #2aa1ae; background-color: #292e34;">binCount = log2(nk) * UniversalRenderPipeline.maxZBinWords/{log2(nk)*(headerLength+wordsPerTile)}</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//               </span><span style="color: #2aa1ae; background-color: #292e34;">= UniversalRenderPipeline.maxZBinWords/(headerLength+wordsPerTile)</span>
    m_ZBins = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint</span>&gt;(UniversalRenderPipeline.maxZBinWords, Allocator.Persistent);
    m_ZBinsBuffer = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">GraphicsBuffer</span>(GraphicsBuffer.Target.Constant, UniversalRenderPipeline.maxZBinWords / 4, UnsafeUtility.<span style="color: #bc6ec5; font-weight: bold;">SizeOf</span>&lt;float4&gt;());
    m_ZBinsBuffer.name = <span style="color: #2d9574;">"URP Z-Bin Buffer"</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mobile     maxVisibleAdditionalLights &#20026; 32</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">non mobile maxVisibleAdditionalLights &#20026; 256</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">maxTileWords =&gt; (maxVisibleAdditionalLights &lt;= 32 ? 1024 : 4096) * 4;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">mobile maxTileWords=1024*4=4096</span>
    m_TileMasks = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint</span>&gt;(UniversalRenderPipeline.maxTileWords, Allocator.Persistent);
    m_TileMasksBuffer = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">GraphicsBuffer</span>(GraphicsBuffer.Target.Constant, UniversalRenderPipeline.maxTileWords / 4, UnsafeUtility.<span style="color: #bc6ec5; font-weight: bold;">SizeOf</span>&lt;float4&gt;());
    m_TileMasksBuffer.name = <span style="color: #2d9574;">"URP Tile Buffer"</span>;
}
</pre>
</div>
</div>
</li>
<li><a id="orgd296f78"></a>ForwardLight.PreSetup<br />
<ul class="org-ul">
<li><a id="orgd56206c"></a>计算 lightOffset，从列表中剔除掉所有 directional light<br />
<div class="outline-text-9" id="text-orgd56206c">
<p>
所有 directional light 都排在 renderingData.lightData.visibleLights 中的最前面。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">m_LightCount = renderingData.lightData.visibleLights.Length;
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightOffset</span> = 0;
<span style="color: #4f97d7; font-weight: bold;">while</span> (lightOffset &lt; m_LightCount &amp;&amp; renderingData.lightData.visibleLights[lightOffset].lightType == LightType.Directional)
{
    lightOffset++;
}
m_LightCount -= lightOffset;
m_DirectionalLightCount = lightOffset;
</pre>
</div>
</div>
</li>
<li><a id="orgfd34cfc"></a>计算 m_TileResolution<br />
<div class="outline-text-9" id="text-orgfd34cfc">
<p>
tile 为正方形，且 tile 的大小为 2 的 n 次幂，tile 最小为 8*8 pixel。场景灯光个数，以及屏幕分辨率都会影响 tile 的大小。<br />
<a id="orgfe7e94d"></a><br />
m_WordsPerTile     为表达一个 tile (或一个 bin，虽然名称中只包含 Tile，实际也用于 bin) 和所有 light 以及 reflectionProbe 的相交关系所需的字数（一个字为 32 位）<br />
m_ActualTileWidth  为一个 tile 的分辨率<br />
m_TileResolution   为 tile 的数量<br />
viewCount          VR 平台会有两个 view, 为简化分析，下面代码假定了 viewCount 为 1<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#20010;light&#21644;reflectonProbe &#37117;&#20250;&#21344;&#29992;&#19968;&#20010;bit&#65292;&#27599;&#20010;tile&#37117;&#35201;&#35760;&#24405;&#20854;&#21644;&#25152;&#26377;light&#12289;reflectionProbe&#30340;&#30456;&#20132;&#20851;&#31995;</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemsPerTile</span> = visibleLights.Length + reflectionProbeCount;
m_WordsPerTile = (itemsPerTile + 31) / 32;

m_ActualTileWidth = 8 &gt;&gt; 1;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">init is m_ActualTileWidth=4</span>
<span style="color: #4f97d7; font-weight: bold;">do</span>
{
    m_ActualTileWidth &lt;&lt;= 1; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set m_ActualTileWidth to 8</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20551;&#35774;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">screenResolution  &#20026;(1334, 750 iPhone8&#20998;&#36776;&#29575;)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;1&#27425;&#36845;&#20195;&#65306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_ActualTileWidth &#20026; 8</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_TileResolution = (1334+7, 750+7)/8 = (167.625, 94.625) = (167, 94)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;2&#27425;&#36845;&#20195;&#65306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_ActualTileWidth &#20026; 16</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_TileResolution = (1334+15, 750+15)/16 = (84, 47)</span>
    m_TileResolution = (screenResolution + m_ActualTileWidth - 1) / m_ActualTileWidth;
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mobile     maxVisibleAdditionalLights &#20026; 32</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">non mobile maxVisibleAdditionalLights &#20026; 256</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UniversalRenderPipeline.maxTileWords = (maxVisibleAdditionalLights &lt;= 32 ? 1024 : 4096) * 4;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532; 1 &#27425;&#36845;&#20195;&#65306;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">167*94=15698&gt;1024*4=4096</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532; 2 &#27425;&#36845;&#20195;&#65306;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">84*47=3948&lt;4096</span>
<span style="color: #4f97d7; font-weight: bold;">while</span> ((m_TileResolution.x * m_TileResolution.y * m_WordsPerTile * viewCount) &gt; UniversalRenderPipeline.maxTileWords);
</pre>
</div>
</div>
</li>

<li><a id="org6fddd85"></a>计算 m_ZBinScale, m_ZBinOffset, binCount<br />
<div class="outline-text-9" id="text-org6fddd85">
<p>
<a id="org216ec9a"></a><br />
binCount 表示在 z 方向上划分的 bin 的个数。<br />
bin 在 z 方向上的尺寸成等比数列。<br />
<img src="./URP/cluster-subdivide01.jpg" alt="cluster-subdivide01.jpg" /><br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639; m_WordsPerTile&#65292;word &#20026;32bit</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#20010;light&#21644;reflectonProbe &#37117;&#20250;&#21344;&#29992;&#19968;&#20010;bit&#65292;&#27599;&#20010;tile&#37117;&#35201;&#35760;&#24405;&#20854;&#21644;&#25152;&#26377;light&#12289;reflectionProbe&#30340;&#30456;&#20132;&#20851;&#31995;</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemsPerTile</span> = visibleLights.Length + reflectionProbeCount;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">itemsPerTile = 0               =&gt; m_WordsPerTile = 0    &#22330;&#26223;&#20013;&#27809;&#26377;light&#21644;reflectionProbe</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">itemsPerTile = 1,2,...32       =&gt; m_WordsPerTile = 1</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">itemsPerTile = 33,34,...64     =&gt; m_WordsPerTile = 2</span>
m_WordsPerTile = (itemsPerTile + 31) / 32;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Use to calculate binIndex = log2(z) * zBinScale + zBinOffset</span>
<span style="color: #9f8766;">//// UniversalRenderPipeline.maxZBinWords = 4096</span>
<span style="color: #9f8766;">//// headerLength = 2 &#20004;&#20010; header&#65292;&#19968;&#20010;&#29992;&#20110;&#35760;&#24405; light &#30456;&#20851;&#20449;&#24687;&#65292;&#19968;&#20010;&#29992;&#20110;&#35760;&#24405; reflectionProbe &#30456;&#20851;&#20449;&#24687;</span>
m_ZBinScale = UniversalRenderPipeline.maxZBinWords / ((math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(camera.farClipPlane) - math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(camera.nearClipPlane)) * (headerLength + m_WordsPerTile));
m_ZBinOffset = -math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(camera.nearClipPlane) * m_ZBinScale;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21270;&#31616;&#20043;&#21518; m_binCount = UniversalRenderPipeline.maxZBinWords / (headerLength + m_WordsPerTile)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20551;&#35774; m_WordsPerTile = 1 (&#28783;&#20809;+reflectionProbe &#25968;&#37327;&#23567;&#20110;32, &#21482;&#38656;&#35201; 1 word)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21017; m_binCount = 1365</span>
m_binCount = (<span style="color: #ce537a; font-weight: bold;">int</span>)(math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(camera.farClipPlane) * m_ZBinScale + m_ZBinOffset);
</pre>
</div>

<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/about-urp-14-forward.1377924/">https://forum.unity.com/threads/about-urp-14-forward.1377924/</a><br /></li>
<li>等比数列 <a href="https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97">https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97</a><br /></li>
<li>Cluster_Unity 实现概述 <a href="https://zhuanlan.zhihu.com/p/71932575">https://zhuanlan.zhihu.com/p/71932575</a><br /></li>
<li>对数性质和运算法则 <a href="https://zhuanlan.zhihu.com/p/569182404">https://zhuanlan.zhihu.com/p/569182404</a><br /></li>
</ul>
</div>
</li>
<li><a id="org2574cb5"></a>计算 light 对应的 minZ maxZ<br />
<div class="outline-text-9" id="text-org2574cb5">
<p>
对于 point light 只需要将其变换到 camera space，通过 light pos 和 light range 就可以计算出 minX maxZ。<br />
对于 spot light 则复杂一些，TODO。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemsPerTile</span> = visibleLights.Length + reflectionProbeCount;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#37324;&#20351;&#29992;&#30340; Allocator.TempJob &#31867;&#22411;&#30340;&#20869;&#23384;&#20998;&#37197;&#22120;</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">minMaxZs</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float2&gt;(itemsPerTile * viewCount, Allocator.TempJob);
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightMinMaxZJob</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">LightMinMaxZJob</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">IJobFor</span>
{
    worldToViewMatrix = worldToViewMatrix,
    lights = visibleLights,
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GetSubArray(start, length)</span>
    minMaxZs = minMaxZs.<span style="color: #bc6ec5; font-weight: bold;">GetSubArray</span>(0, m_LightCount * viewCount)
};
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Innerloop batch count of 32 is not special, just a handwavy amount to not have too much scheduling overhead nor too little parallelism.</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightMinMaxZHandle</span> = lightMinMaxZJob.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(m_LightCount, 32, <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">JobHandle</span>());
</pre>
</div>

<ul class="org-ul">
<li>spot light minZ maxZ <a href="https://iquilezles.org/www/articles/diskbbox/diskbbox.htm">https://iquilezles.org/www/articles/diskbbox/diskbbox.htm</a><br /></li>
</ul>
</div>
</li>
<li><a id="org1bc765a"></a>计算 reflectionProbe minZ maxZ<br />
<div class="outline-text-9" id="text-org1bc765a">
<p>
将 ReflectionProbe 对应的 Box 变换到 camera space，遍历 Box 的 8 个顶点，确定 minZ MaxZ<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">reflectionProbeMinMaxZJob</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">ReflectionProbeMinMaxZJob</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">IJobFor</span>
{
    worldToViewMatrix = worldToViewMatrix,
    reflectionProbes = reflectionProbes,
    minMaxZs = minMaxZs.<span style="color: #bc6ec5; font-weight: bold;">GetSubArray</span>(m_LightCount * viewCount, reflectionProbeCount * viewCount)
};
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">reflectionProbeMinMaxZHandle</span> = reflectionProbeMinMaxZJob.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(reflectionProbeCount, 32, lightMinMaxZHandle);
</pre>
</div>
</div>
</li>
<li><a id="orgb0ace92"></a>Binning<br />
<div class="outline-text-9" id="text-orgb0ace92">
<p>
计算 bin 内 lights、refelctionProbes 的 minLightIndex 和 maxLightIndex 记录在 header 中。<br />
计算 bin 和 lights、refelctionProbes 的相交情况，记录在 body 中，使用 bitmask 来存储。<br />
</p>

<p>
m_ZBins 中元素类型为 uint , 其为 1 个 word<br />
m_ZBins 中多个元素对应一个 bin, 具体来说 headerLength + wordsPerTile 个元素 对应 1 个 bin<br />
header:<br />
  headerLength = 2<br />
  header 对应两个 uint 元素，这两个元素都被填充为 emptyHeader<br />
  header0 用与记录 light 相关数据(header0 记录 该 bin 相交的 lights 中最小的 minLightIndex 和 最大的 maxLightIndex)<br />
  header1 用与记录 reflectionProbe 相关数据(header1 记录 该 bin 相交的 reflectionProbes 中最小的 minRPIndex 和 最大的 maxRPIndex)<br />
body:<br />
  header 后紧跟的 wordsPerTile 个元素用于记录 bin 和哪些 light 或 refletionProbe 有交集，该信息按照 bitmask 方式存储<br />
  例如，若 bin 和第 n 个 light 有交集，则 bodyUint |= 1&lt;&lt;n<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UniversalRenderPipeline.maxZBinWords = 1024*4</span>
m_ZBins = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint</span>&gt;(UniversalRenderPipeline.maxZBinWords, Allocator.Persistent);
</pre>
</div>
<p>
binCount <a href="#org216ec9a">ForwardPlus binCount</a><br />
wordsPerTile <a href="#orgfe7e94d">No description for this link</a><br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599; 128 &#20010; Bin &#32452;&#25104;&#19968;&#20010; Batch</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ZBinningJob.batchSize = 128</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zBinningBatchCount = 1365/128=11</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">zBinningBatchCount</span> = (m_BinCount + ZBinningJob.batchSize - 1) / ZBinningJob.batchSize;
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">zBinningJob</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">ZBinningJob</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">IJobFor</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bins &#20026; NativeArray&lt;uint&gt;</span>
    bins = m_ZBins,
    minMaxZs = minMaxZs,
    zBinScale = m_ZBinScale,
    zBinOffset = m_ZBinOffset,
    binCount = binCount,            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">binCount</span>
    wordsPerTile = m_WordsPerTile,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wordsPerTile</span>
    lightCount = m_LightCount,
    reflectionProbeCount = reflectionProbeCount,
    batchCount = zBinningBatchCount,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">batchCount</span>
    viewCount = viewCount,
    isOrthographic = camera.orthographic
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#20010;job &#22788;&#29702;&#19968;&#20010;batch&#65288;&#19968;&#20010; batch &#21253;&#21547; ZBinningJob.batchSize &#20010;bin&#65289;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21010;&#20998;&#20986;&#30340;job &#25968;&#37327;&#65288;&#21363;:batchCount&#65289; = (binCount + ZBinningJob.batchSize - 1) / ZBinningJob.batchSize</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">zBinningHandle</span> = zBinningJob.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(zBinningBatchCount*viewCount, 1, reflectionProbeMinMaxZHandle);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">jobIndex</span>) <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">jobIndex -&gt; [0, zBinningBatchCount*viewCount)</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">batchIndex</span> = jobIndex % batchCount;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">viewIndex</span> = jobIndex / batchCount;

    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">binStart</span> = batchSize * batchIndex;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">binEnd</span> = math.<span style="color: #bc6ec5; font-weight: bold;">min</span>(binStart + batchSize, binCount) - 1;

    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">binOffset</span> = viewIndex * binCount;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ushort.MaxValue=2^16-1=0x00FF=65535 &#32534;&#30721;&#21040;&#20302;16&#20301;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ushort.MinValue=0                   &#32534;&#30721;&#21040;&#39640;16&#20301;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">emptyHeader = (0x00FF &amp; 0xFFFF) | ((0 &amp; 0xFFFF) &lt;&lt; 16)=0x00FF=65535</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">emptyHeader</span> = <span style="color: #bc6ec5; font-weight: bold;">EncodeHeader</span>(<span style="color: #ce537a; font-weight: bold;">ushort</span>.MaxValue, <span style="color: #ce537a; font-weight: bold;">ushort</span>.MinValue);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#24403;&#21069;job&#23545;&#24212;&#30340;&#25152;&#26377;bins</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">binIndex</span> = binStart; binIndex &lt;= binEnd; binIndex++)
    {
        bins[(binOffset + binIndex) * (headerLength + wordsPerTile) + 0] = emptyHeader;
        bins[(binOffset + binIndex) * (headerLength + wordsPerTile) + 1] = emptyHeader;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Regarding itemOffset: minMaxZs contains [lights view 0, lights view 1, probes view 0, probes view 1] when</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">using XR single pass instanced, and otherwise [lights, probes]. So we figure out what the offset is based</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">on the view count and index.</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fill ZBins for lights.</span>
    <span style="color: #bc6ec5; font-weight: bold;">FillZBins</span>(binStart, binEnd, 0, lightCount, 0, viewIndex * lightCount, binOffset);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fill ZBins for reflection probes.</span>
    <span style="color: #bc6ec5; font-weight: bold;">FillZBins</span>(binStart, binEnd, lightCount, lightCount + reflectionProbeCount, 1, lightCount * (viewCount - 1) + viewIndex * reflectionProbeCount, binOffset);
}

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">uint</span> <span style="color: #bc6ec5; font-weight: bold;">EncodeHeader</span>(<span style="color: #ce537a; font-weight: bold;">uint</span> <span style="color: #7590db;">min</span>, <span style="color: #ce537a; font-weight: bold;">uint</span> <span style="color: #7590db;">max</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> (min &amp; 0xFFFF) | ((max &amp; 0xFFFF) &lt;&lt; 16);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20551;&#35774; light0 [minBinIndex=0, maxBinIndex=2]&#65292;light1 [minBinIndex=0, maxBinIndex=3]&#12290;&#24403;&#21069;&#27491;&#22312;&#22788;&#29702;bins 0&#21040;127&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#25152;&#26377;light&#65292;&#19979;&#38754;&#20551;&#35774;body&#21482;&#26377;4&#20010;bit&#65292;&#23454;&#38469;&#19978;light&#21644;reflectionProbe&#25968;&#37327;&#23567;&#20110;32&#26102;&#65292;&#24212;&#35813;&#20026;32&#20010;bit</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;light0&#26102;&#65292;tmpBinMin=max(0, 0)=0 tmpBinMax=min(2, 127)=2, &#21518;&#32493;&#20250;&#36941;&#21382;bin 0&#21040;2, header &#35760;&#24405;[0, 0], body&#35760;&#24405;(0001)</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;light1&#26102;&#65292;tmpBinMin=max(0, 0)=0 tmpBinMax=min(3, 127)=3, &#21518;&#32493;&#20250;&#36941;&#21382;bin 0&#21040;3, header&#35760;&#24405;[0, 0]=&gt;[0, 1], body&#35760;&#24405;(0001|0010=0011)</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FillZBins</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">binStart</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">binEnd</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">itemStart</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">itemEnd</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">headerIndex</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">itemOffset</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">binOffset</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#25152;&#26377;light or reflectionProbe</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">index</span> = itemStart; index &lt; itemEnd; index++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#24471; light &#23545;&#24212;&#30340; float2(minZ,maxZ)</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">minMax</span> = minMaxZs[itemOffset + index];
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30001;light&#30340;minZ maxZ &#24471;&#21040;light&#23545;&#24212;&#30340;minBin index &#21644; maxBin index</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21462; [lightBinMin, lightBinMax] &#21644; [binStart, binEnd] &#30340;&#20132;&#38598;, &#24471;&#21040; [tmpBinMin, tmpBinMax]</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">minBin</span> = math.<span style="color: #bc6ec5; font-weight: bold;">max</span>((<span style="color: #ce537a; font-weight: bold;">int</span>)((isOrthographic ? minMax.<span style="color: #ce537a; font-weight: bold;">x</span> : math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(minMax.x)) * zBinScale + zBinOffset), binStart);
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">maxBin</span> = math.<span style="color: #bc6ec5; font-weight: bold;">min</span>((<span style="color: #ce537a; font-weight: bold;">int</span>)((isOrthographic ? minMax.<span style="color: #ce537a; font-weight: bold;">y</span> : math.<span style="color: #bc6ec5; font-weight: bold;">log2</span>(minMax.y)) * zBinScale + zBinOffset), binEnd);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403; lights &#30340;&#25968;&#37327;&#36229;&#36807;32&#21518;&#65292;bin &#21644; lights &#30340; &#30456;&#20132;&#20449;&#24687;&#38656;&#35201;&#25918;&#21040;&#22810;&#20010; word &#20013;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wordIndex &#34920;&#31034;&#24403;&#21069; light &#30340;&#20449;&#24687;&#25918;&#22312;&#31532;&#20960;&#20010; word &#20013;</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">wordIndex</span> = index / 32;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bitMask &#34920;&#31034;&#24403;&#21069; light &#30340;&#20449;&#24687;&#25918;&#22312; word &#30340;&#21738;&#20010; bit &#20013;</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">bitMask</span> = 1u &lt;&lt; (index % 32);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382; tmpBinMin &#21040; tmpBinMax&#65292;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1: &#26356;&#26032; header &#35760;&#24405;&#30340; minLightIndex &#21644; maxLightIndex</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2: &#26356;&#26032; body &#35760;&#24405;&#30340; mask &#20449;&#24687;</span>
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">binIndex</span> = minBin; binIndex &lt;= maxBin; binIndex++)
        {
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">baseIndex</span> = (binOffset + binIndex) * (headerLength + wordsPerTile);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35299;&#30721;&#20986; header &#20013;&#23384;&#20648;&#30340; minLightIndex &#21644; maxLightIndex</span>
            <span style="color: #ce537a; font-weight: bold;">var</span> (<span style="color: #ce537a; font-weight: bold;">minIndex</span>, <span style="color: #ce537a; font-weight: bold;">maxIndex</span>) = <span style="color: #bc6ec5; font-weight: bold;">DecodeHeader</span>(bins[baseIndex + headerIndex]);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545; [oldMinLightIndex, oldMaxLightIndex] &#36827;&#34892;&#25193;&#23637;&#20197;&#21253;&#21547;&#24403;&#21069;&#30340; lightIndex, &#24471;&#21040; [newMinLightIndex, newMaxLightIndex]</span>
            minIndex = math.<span style="color: #bc6ec5; font-weight: bold;">min</span>(minIndex, (<span style="color: #ce537a; font-weight: bold;">uint</span>)index);
            maxIndex = math.<span style="color: #bc6ec5; font-weight: bold;">max</span>(maxIndex, (<span style="color: #ce537a; font-weight: bold;">uint</span>)index);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; [newMinLightIndex, newMaxLightIndex] &#26356;&#26032; header</span>
            bins[baseIndex + headerIndex] = <span style="color: #bc6ec5; font-weight: bold;">EncodeHeader</span>(minIndex, maxIndex);
            bins[baseIndex + headerLength + wordIndex] |= bitMask;
        }
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org95ee5fd"></a>Tiling<br />
<div class="outline-text-9" id="text-org95ee5fd">
<p>
计算每个 light 或 reflectionProbe 与 tiles 的相交情况，记录在 tileRanges 中。X方向每一行使用一个 range 记录相交的最左边 tile index 和最右边 tile index，Y 方向使用一个 range 记录相交的最下面 tile index 和最上面 tile index。<br />
从摄像机看 light sphere（point light），得到 light 的边界点(代码中的 horizon point), 将 horizon point 投影到近平面，从而计算出与 tiles 的相交情况。<br />
range               为 InclusiveRange 结构体变量，其中有两个成员 start 和 end。用于存储 light 相交的 tiles 的 start index 和 end index。<br />
                    Y 方向 range 的 取值范围为 [0, m_TileResolution.y)<br />
                    X 方向 range 的 取值范围为 [0, m_TileResolution.x)<br />
<a id="orgbce5b9a"></a>   为每个 light 或 reflectionProbe 记录与所有 tiles 相交情况需要的 range 数量<br />
                    X 方向一个 range 对应一行 tile，所以需要 m_TileResolution.y 个 range; 在 Y 方向只需要一个 range<br />
<a id="orgde6b214"></a>      存储所有 light 或 reflectionProbe 对应的 range 信息<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">short &#20026;int16, &#25152;&#20197;InclusiveRange &#21344;&#29992;4&#20010;&#23383;&#33410;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">short</span> <span style="color: #7590db;">start</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">short</span> <span style="color: #7590db;">end</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#25903;&#25345;VR&#24179;&#21488;&#65292;&#25152;&#20197;&#36825;&#37324;&#30340; fovHalfHeights &#20026;&#20004;&#20010;&#25968;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">We want to calculate `fovHalfHeight = tan(fov / 2)`</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">`projection[1][1]` contains `1 / tan(fov / 2)`</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">fovHalfHeights</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Fixed2</span>&lt;<span style="color: #ce537a; font-weight: bold;">float</span>&gt;(1.0f/viewToClips[0][1][1], 1.0f/viewToClips[1][1][1]);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Each light needs 1 range for Y, and a range per row. Align to 128-bytes to avoid false sharing.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">rangesPerItem &#30340;&#35745;&#31639;&#65306; &#27599;&#20010; light &#22312;Y&#26041;&#21521;&#38656;&#35201;&#19968;&#20010; range&#65292;X&#26041;&#21521;&#19968;&#20010; range &#23545;&#24212;&#19968;&#34892; tile&#65292;&#25152;&#20197;&#38656;&#35201; m_TileResolution.y &#20010; range</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#21069; m_TileResolution = (84, 47), UnsafeUtility.SizeOf&lt;InclusiveRange&gt;()=4</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">AlignByteCount(48*4=192, 128)=256 &#25968;&#25454;&#25353;&#29031;128&#20301;&#23545;&#40784;&#65292;&#20197;&#36991;&#20813; cache miss</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">rangesPerItem = AlignByteCount(48*4=192, 128)/4 = 64</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rangesPerItem</span> = <span style="color: #bc6ec5; font-weight: bold;">AlignByteCount</span>((1 + m_TileResolution.y) * UnsafeUtility.<span style="color: #bc6ec5; font-weight: bold;">SizeOf</span>&lt;<span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>&gt;(), 128) / UnsafeUtility.<span style="color: #bc6ec5; font-weight: bold;">SizeOf</span>&lt;<span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>&gt;();
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileRanges</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>&gt;(rangesPerItem * itemsPerTile * viewCount, Allocator.TempJob);
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tilingJob</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">TilingJob</span>
{
    <span style="color: #7590db;">lights</span> = visibleLights,
    <span style="color: #7590db;">reflectionProbes</span> = reflectionProbes,
    <span style="color: #7590db;">tileRanges</span> = tileRanges,
    <span style="color: #7590db;">itemsPerTile</span> = itemsPerTile,
    <span style="color: #7590db;">rangesPerItem</span> = rangesPerItem,
    <span style="color: #7590db;">worldToViews</span> = worldToViews,
    <span style="color: #7590db;">centerOffset</span> = cameraData.xrRendering &amp;&amp; cameraData.xr.viewCount &gt; 0 ? 2f * cameraData.xr.<span style="color: #bc6ec5; font-weight: bold;">ApplyXRViewCenterOffset</span>(math.<span style="color: #bc6ec5; font-weight: bold;">float2</span>(0.0f, 0.0f)) : float4.zero,
    <span style="color: #7590db;">tileScale</span> = (<span style="color: #ce537a; font-weight: bold;">float2</span>)screenResolution / m_ActualTileWidth,
    <span style="color: #7590db;">tileScaleInv</span> = m_ActualTileWidth / (<span style="color: #ce537a; font-weight: bold;">float2</span>)screenResolution,
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">viewPlaneHalfSize = (tan(fovX/2), tan(fovY/2))</span>
    <span style="color: #7590db;">viewPlaneHalfSizes</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Fixed2</span>&lt;<span style="color: #ce537a; font-weight: bold;">float2</span>&gt;(fovHalfHeights[0] * math.<span style="color: #bc6ec5; font-weight: bold;">float2</span>(cameraData.aspectRatio, 1), fovHalfHeights[1] * math.<span style="color: #bc6ec5; font-weight: bold;">float2</span>(cameraData.aspectRatio, 1)),
    <span style="color: #7590db;">viewPlaneHalfSizeInvs</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Fixed2</span>&lt;<span style="color: #ce537a; font-weight: bold;">float2</span>&gt;(math.<span style="color: #bc6ec5; font-weight: bold;">rcp</span>(fovHalfHeights[0] * math.<span style="color: #bc6ec5; font-weight: bold;">float2</span>(cameraData.aspectRatio, 1)), math.<span style="color: #bc6ec5; font-weight: bold;">rcp</span>(fovHalfHeights[1] * math.<span style="color: #bc6ec5; font-weight: bold;">float2</span>(cameraData.aspectRatio, 1))),
    <span style="color: #7590db;">tileCount</span> = m_TileResolution,
    <span style="color: #7590db;">near</span> = camera.nearClipPlane,
    <span style="color: #7590db;">isOrthographic</span> = camera.orthographic
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#20010;job&#22788;&#29702;&#19968;&#20010; light &#25110; reflectonProbe</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">itemsPerTile = visibleLights.Length + reflectionProbeCount;</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileRangeHandle</span> = tilingJob.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(itemsPerTile * viewCount, 1, reflectionProbeMinMaxZHandle);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">jobIndex</span>) <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">jobIndex -&gt; [0, itemsPerTile*viewCount)</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">index</span> = jobIndex % itemsPerTile;
    m_ViewIndex = jobIndex / itemsPerTile;
    m_CenterOffset = m_ViewIndex == 0 ? centerOffset.xy : centerOffset.zw;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_Offset &#25351;&#31034;&#24403;&#21069;light&#23545;&#24212;&#30340;tileRanges&#20013;&#30340;&#36215;&#22987;&#20301;&#32622;</span>
    m_Offset = jobIndex * rangesPerItem;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_TileYRange &#29992;&#20110;&#23384;&#20648;&#24403;&#21069;light &#22312;Y&#26041;&#21521;&#19978;&#30340;Range</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#37324;&#23558;&#20854;&#21021;&#22987;&#21270;&#20026; empty range</span>
    m_TileYRange = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>(<span style="color: #ce537a; font-weight: bold;">short</span>.MaxValue, <span style="color: #ce537a; font-weight: bold;">short</span>.MinValue);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#24403;&#21069;light&#25110; reflectionProbe &#23545;&#24212;&#30340;&#27599;&#20010;range&#65292;&#23545;&#20854;&#36827;&#34892;&#21021;&#22987;&#21270;</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">i</span> = 0; i &lt; rangesPerItem; i++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#24403;&#21069; light &#23545;&#24212;&#30340;&#25152;&#26377; range &#21021;&#22987;&#21270;&#20026; empty range</span>
        tileRanges[m_Offset + i] = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>(<span style="color: #ce537a; font-weight: bold;">short</span>.MaxValue, <span style="color: #ce537a; font-weight: bold;">short</span>.MinValue);
    }


    <span style="color: #4f97d7; font-weight: bold;">if</span> (index &lt; lights.Length)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#20132;&#25668;&#20687;&#26426; &#20351;&#29992; TileLightOrthographic &#36827;&#34892;&#22788;&#29702;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (isOrthographic) { <span style="color: #bc6ec5; font-weight: bold;">TileLightOrthographic</span>(index); }
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36879;&#35270;&#25668;&#20687;&#26426; &#20351;&#29992; TileLight &#36827;&#34892;&#22788;&#29702;</span>
        <span style="color: #4f97d7; font-weight: bold;">else</span> { <span style="color: #bc6ec5; font-weight: bold;">TileLight</span>(index); }
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> { <span style="color: #bc6ec5; font-weight: bold;">TileReflectionProbe</span>(index); }
}
</pre>
</div>

<p>
下图展示了，sphereClipRadius 的计算。<br />
<img src="./URP/forwardPlus-tiling0.jpg" alt="forwardPlus-tiling0.jpg" /><br />
<a href="./URP/forwardPlus-tiling0.ggb">./URP/forwardPlus-tiling0.ggb</a><br />
下图展示了，GetSphereHorizon 的计算逻辑。Tips: 当 lightSphere 和近平面相交时，会处理 clipping 逻辑，下图没展示这种特殊情况。<br />
<img src="./URP/forwardPlus-tiling1.jpg" alt="forwardPlus-tiling1.jpg" /><br />
<a href="./URP/forwardPlus-tiling1.ggb">./URP/forwardPlus-tiling1.ggb</a><br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36879;&#35270;&#25668;&#20687;&#26426; &#20351;&#29992; TileLight &#36827;&#34892;&#22788;&#29702;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">TileLight</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">lightIndex</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">light</span> = lights[lightIndex];
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightToWorld</span> = (<span style="color: #ce537a; font-weight: bold;">float4x4</span>)light.localToWorldMatrix;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightPositionVS</span> = math.<span style="color: #bc6ec5; font-weight: bold;">mul</span>(worldToViews[m_ViewIndex], math.<span style="color: #bc6ec5; font-weight: bold;">float4</span>(lightToWorld.c3.xyz, 1)).xyz;
    lightPositionVS.z *= -1;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (lightPositionVS.z &gt;= near) <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(lightPositionVS);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">lightDirectionVS</span> = math.<span style="color: #bc6ec5; font-weight: bold;">normalize</span>(math.<span style="color: #bc6ec5; font-weight: bold;">mul</span>(worldToViews[m_ViewIndex], math.<span style="color: #bc6ec5; font-weight: bold;">float4</span>(lightToWorld.c2.xyz, 0)).xyz);
    lightDirectionVS.z *= -1;

    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">halfAngle</span> = math.<span style="color: #bc6ec5; font-weight: bold;">radians</span>(light.spotAngle * 0.5f);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">range</span> = light.range;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rangesq</span> = <span style="color: #bc6ec5; font-weight: bold;">square</span>(range);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">cosHalfAngle</span> = math.<span style="color: #bc6ec5; font-weight: bold;">cos</span>(halfAngle);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">coneHeight</span> = cosHalfAngle * range;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Radius of circle formed by intersection of sphere and near plane.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Found using Pythagoras with a right triangle formed by three points:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(a) light position</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(b) light position projected to near plane</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(c) a point on the near plane at a distance `range` from the light position</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//     </span><span style="color: #2aa1ae; background-color: #292e34;">(i.e. lies both on the sphere and the near plane)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Thus the hypotenuse is formed by (a) and (c) with length `range`, and the known side is formed</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">by (a) and (b) with length equal to the distance between the near plane and the light position.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">The remaining unknown side is formed by (b) and (c) with length equal to the radius of the circle.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">m_ClipCircleRadius = sqrt(sq(light.range) - sq(m_Near - m_LightPosition.z));</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereClipRadius</span> = math.<span style="color: #bc6ec5; font-weight: bold;">sqrt</span>(rangesq - <span style="color: #bc6ec5; font-weight: bold;">square</span>(near - lightPositionVS.z));

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Assumes a point on the sphere, i.e. at distance `range` from the light position.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">If spot light, we check the angle between the direction vector from the light position and the light direction vector.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Note that division by range is to normalize the vector, as we know that the resulting vector will have length `range`.</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">p</span>) =&gt; light.lightType == LightType.Point ||
        math.<span style="color: #bc6ec5; font-weight: bold;">dot</span>(math.<span style="color: #bc6ec5; font-weight: bold;">normalize</span>(p - lightPositionVS), lightDirectionVS) &gt;= cosHalfAngle;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Project light sphere onto YZ plane, find the horizon points, and re-construct view space position of found points.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CalculateSphereYBounds(lightPositionVS, range, near, sphereClipRadius, out var sphereBoundY0, out var sphereBoundY1);</span>
    <span style="color: #bc6ec5; font-weight: bold;">GetSphereHorizon</span>(lightPositionVS.yz, range, near, sphereClipRadius, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundYZ0</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundYZ1</span>);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundY0</span> = math.<span style="color: #bc6ec5; font-weight: bold;">float3</span>(lightPositionVS.x, sphereBoundYZ0);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundY1</span> = math.<span style="color: #bc6ec5; font-weight: bold;">float3</span>(lightPositionVS.x, sphereBoundYZ1);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35831;&#21442;&#32771;&#19979;&#38754; ExpandY &#30340;&#27880;&#37322;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereBoundY0)) <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(sphereBoundY0);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereBoundY1)) <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(sphereBoundY1);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Project light sphere onto XZ plane, find the horizon points, and re-construct view space position of found points.</span>
    <span style="color: #bc6ec5; font-weight: bold;">GetSphereHorizon</span>(lightPositionVS.xz, range, near, sphereClipRadius, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundXZ0</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundXZ1</span>);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundX0</span> = math.<span style="color: #bc6ec5; font-weight: bold;">float3</span>(sphereBoundXZ0.x, lightPositionVS.y, sphereBoundXZ0.y);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereBoundX1</span> = math.<span style="color: #bc6ec5; font-weight: bold;">float3</span>(sphereBoundXZ1.x, lightPositionVS.y, sphereBoundXZ1.y);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereBoundX0)) <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(sphereBoundX0);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereBoundX1)) <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(sphereBoundX1);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (light.lightType == LightType.Spot)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    }

    m_TileYRange.<span style="color: #bc6ec5; font-weight: bold;">Clamp</span>(0, (<span style="color: #ce537a; font-weight: bold;">short</span>)(tileCount.y - 1));

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Plane:</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//     </span><span style="color: #2aa1ae; background-color: #292e34;">&#23631;&#24149;&#34987;&#21010;&#20998;&#20026;&#30456;&#21516;&#22823;&#23567;&#30340; tile&#65292;&#36825;&#37324;&#30340;&#19968;&#20010; plane &#23545;&#24212; X &#26041;&#21521;&#30340;&#19968;&#34892; tile</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639; X &#26041;&#21521;&#19978;&#27599;&#19968;&#34892;tile&#19982;light&#30340;&#30456;&#20132;&#24773;&#20917;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Calculate tile plane ranges for sphere.</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">planeIndex</span> = m_TileYRange.start + 1; planeIndex &lt;= m_TileYRange.end; planeIndex++)
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">planeRange</span> = InclusiveRange.empty;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fovHalfHeights = tan(fov/2)</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">viewPlaneHalfSizes = fovHalfHeights[0] * math.float2(cameraData.aspectRatio, 1)</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//     </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: &#19978;&#38754;&#30340;&#35745;&#31639;&#20013;&#27809;&#26377;&#32771;&#34385;nearPlane&#30340;&#20540;&#65292;&#25152;&#20197;&#65292;&#36825;&#37324;&#30340; viewPlane &#20026; z=1 &#22788;&#30340; viewPlane&#12290;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">planeY &#20026;&#24403;&#21069; plane &#22312;Y&#26041;&#21521;&#19978;&#30340;&#20301;&#32622; (viewPlane&#26368;&#19979;&#38754;&#20026; -viewPlaneHalfSizes.y&#65292;&#26368;&#19978;&#38754;&#20026; +viewPlaneHalfSizes.y)</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">planeY</span> = math.<span style="color: #bc6ec5; font-weight: bold;">lerp</span>(-viewPlaneHalfSizes[m_ViewIndex].y, viewPlaneHalfSizes[m_ViewIndex].y, planeIndex * tileScaleInv.y);
        <span style="color: #bc6ec5; font-weight: bold;">GetSphereYPlaneHorizon</span>(lightPositionVS, range, near, sphereClipRadius, planeY, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereTile0</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">sphereTile1</span>);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereTile0)) planeRange.<span style="color: #bc6ec5; font-weight: bold;">Expand</span>((<span style="color: #ce537a; font-weight: bold;">short</span>)math.<span style="color: #bc6ec5; font-weight: bold;">clamp</span>(<span style="color: #bc6ec5; font-weight: bold;">ViewToTileSpace</span>(sphereTile0).x, 0, tileCount.x - 1));
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #bc6ec5; font-weight: bold;">SpherePointIsValid</span>(sphereTile1)) planeRange.<span style="color: #bc6ec5; font-weight: bold;">Expand</span>((<span style="color: #ce537a; font-weight: bold;">short</span>)math.<span style="color: #bc6ec5; font-weight: bold;">clamp</span>(<span style="color: #bc6ec5; font-weight: bold;">ViewToTileSpace</span>(sphereTile1).x, 0, tileCount.x - 1));

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileIndex</span> = m_Offset + 1 + planeIndex;
        tileRanges[tileIndex] = InclusiveRange.<span style="color: #bc6ec5; font-weight: bold;">Merge</span>(tileRanges[tileIndex], planeRange);
        tileRanges[tileIndex - 1] = InclusiveRange.<span style="color: #bc6ec5; font-weight: bold;">Merge</span>(tileRanges[tileIndex - 1], planeRange);
    }

    tileRanges[m_Offset] = m_TileYRange;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Project onto Z=1, scale and offset into [0, tileCount]</span>
<span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">ViewToTileSpace</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">positionVS</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">positionCS</span> = m_CenterOffset + positionVS.xy / positionVS.z * viewPlaneHalfSizeInvs[m_ViewIndex];
    <span style="color: #4f97d7; font-weight: bold;">return</span> (positionCS * 0.5f + 0.5f) * tileScale;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; Y range &#21644; X ranges &#35760;&#24405;&#30340;&#25968;&#25454;&#65292;&#20174;&#32780;&#35760;&#24405;&#19979; light &#21644; tile &#30340;&#30456;&#20132;&#24773;&#20917;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#37324;&#24182;&#19981;&#20250;&#30495;&#27491;&#26356;&#26032; tileRanges &#20013;&#35760;&#24405;&#30340; Y range&#65292;&#21482;&#20250;&#26356;&#26032;&#20020;&#26102;&#30340; m_TileYRange&#65292;&#26368;&#21518;&#25165;&#20250;&#21033;&#29992; m_TileYRange &#26356;&#26032; tileRanges &#20013;&#35760;&#24405;&#30340; Y range</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Expands the tile Y range and the X range in the row containing the position.</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ExpandY</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">positionVS</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">var positionTS = math.clamp(ViewToTileSpace(positionVS), 0, tileCount - 1);</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">positionTS</span> = <span style="color: #bc6ec5; font-weight: bold;">ViewToTileSpace</span>(positionVS);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileY</span> = (<span style="color: #ce537a; font-weight: bold;">int</span>)positionTS.y;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileX</span> = (<span style="color: #ce537a; font-weight: bold;">int</span>)positionTS.x;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tileCount is m_TileResolution</span>
    m_TileYRange.<span style="color: #bc6ec5; font-weight: bold;">Expand</span>((<span style="color: #ce537a; font-weight: bold;">short</span>)math.<span style="color: #bc6ec5; font-weight: bold;">clamp</span>(tileY, 0, tileCount.y - 1));
    <span style="color: #4f97d7; font-weight: bold;">if</span> (tileY &gt;= 0 &amp;&amp; tileY &lt; tileCount.y &amp;&amp; tileX &gt;= 0 &amp;&amp; tileX &lt; tileCount.x)
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rowXRange</span> = tileRanges[m_Offset + 1 + tileY];
        rowXRange.<span style="color: #bc6ec5; font-weight: bold;">Expand</span>((<span style="color: #ce537a; font-weight: bold;">short</span>)tileX);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#31532; tileY &#34892; tile &#23545;&#24212;&#30340; range&#65292;&#20351;&#35813; range &#21253;&#21547;&#20256;&#20837;&#30340;&#20301;&#32622; positionVS</span>
        tileRanges[m_Offset + 1 + tileY] = rowXRange;
    }
}
</pre>
</div>
</div>
</li>
<li><a id="orge65ca53"></a>TileRangeExpansion<br />
<div class="outline-text-9" id="text-orge65ca53">
<p>
将 Tiling Job 得到的 Ranges 数据转化为 Mask 数据，存储到 m_TileMasks 中。<br />
<a id="orgc18263f"></a> ：<br />
    m_TileMasks 的数据类型为 uint 数组, NativeArray&lt;uint&gt; m_TileMasks;<br />
    m_TileMasks 中多个元素对应一个 tile 和所有 lights 或 refelctionProbe 的相交情况，具体来说是 wordsPerTile 个元素对应一个 tile<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">expansionJob</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">TileRangeExpansionJob</span>
{
    <span style="color: #7590db;">tileRanges</span> = tileRanges,
    <span style="color: #7590db;">tileMasks</span> = m_TileMasks,
    <span style="color: #7590db;">rangesPerItem</span> = rangesPerItem,
    <span style="color: #7590db;">itemsPerTile</span> = itemsPerTile,
    <span style="color: #7590db;">wordsPerTile</span> = m_WordsPerTile,
    <span style="color: #7590db;">tileResolution</span> = m_TileResolution,
};

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#20010;job&#22788;&#29702; &#19968;&#34892;tiles</span>
<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tilingHandle</span> = expansionJob.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(m_TileResolution.y * viewCount, 1, tileRangeHandle);
</pre>
</div>

<p>
关于 rangesPerItem:   <a href="#orgbce5b9a">No description for this link</a><br />
关于 wordsPerTile :  <a href="#orgfe7e94d">No description for this link</a><br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#31532;jobIndex&#34892;tiles</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">jobIndex</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rowIndex</span> = jobIndex % tileResolution.y;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">viewIndex</span> = jobIndex / tileResolution.y;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">compactCount</span> = 0;
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemIndices</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">short</span>&gt;(itemsPerTile, Allocator.Temp);
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemRanges</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">InclusiveRange</span>&gt;(itemsPerTile, Allocator.Temp);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compact the light ranges for the current row.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#27599;&#20010; light&#21644;reflectionProbe</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemIndex</span> = 0; itemIndex &lt; itemsPerTile; itemIndex++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">rangesPerItem  &#20026;&#35760;&#24405;&#27599;&#20010; light &#25110; reflectionProbe &#19982;&#25152;&#26377; tiles &#30456;&#20132;&#24773;&#20917;&#38656;&#35201;&#30340; range &#25968;&#37327;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">range &#20026;&#24403;&#21069; light &#19982; &#31532; rowIndex &#34892; tiles (&#20063;&#23601;&#26159;&#24403;&#21069;job&#22788;&#29702;&#30340;&#34892;)&#30340;&#30456;&#20132;&#20449;&#24687;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//       </span><span style="color: #2aa1ae; background-color: #292e34;">&#33509; range &#20026;&#31354;&#65292;&#35828;&#26126;&#24403;&#21069; light &#19982; &#24403;&#21069;job&#22788;&#29702;&#30340;&#34892; &#27809;&#26377;&#30456;&#20132;</span>
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">range</span> = tileRanges[viewIndex * rangesPerItem * itemsPerTile + itemIndex * rangesPerItem + 1 + rowIndex];
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>range.isEmpty)
        {
            itemIndices[compactCount] = (<span style="color: #ce537a; font-weight: bold;">short</span>)itemIndex;
            itemRanges[compactCount] = range;
            compactCount++;
        }
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wordsPerTile &#20026;&#34920;&#36798;&#19968;&#20010; tile &#21644;&#25152;&#26377; light &#20197;&#21450; reflectionProbe &#30340;&#30456;&#20132;&#20851;&#31995;&#25152;&#38656;&#30340;&#23383;&#25968;&#65288;&#19968;&#20010;&#23383;&#20026; 32 &#20301;&#65289;</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rowBaseMaskIndex</span> = viewIndex * wordsPerTile * tileResolution.x * tileResolution.y + rowIndex * wordsPerTile * tileResolution.x;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#24403;&#21069;&#34892;&#20013;&#30340;&#27599;&#19968;&#20010;tile</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileIndex</span> = 0; tileIndex &lt; tileResolution.x; tileIndex++)
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tileBaseIndex</span> = rowBaseMaskIndex + tileIndex * wordsPerTile;
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">i</span> = 0; i &lt; compactCount; i++)
        {
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemIndex</span> = (<span style="color: #ce537a; font-weight: bold;">int</span>)itemIndices[i];
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">wordIndex</span> = itemIndex / 32;
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">itemMask</span> = 1u &lt;&lt; (itemIndex % 32);
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">range</span> = itemRanges[i];
            <span style="color: #4f97d7; font-weight: bold;">if</span> (range.<span style="color: #bc6ec5; font-weight: bold;">Contains</span>((<span style="color: #ce537a; font-weight: bold;">short</span>)tileIndex))
            {
                tileMasks[tileBaseIndex + wordIndex] |= itemMask;
            }
        }
    }

    itemIndices.<span style="color: #bc6ec5; font-weight: bold;">Dispose</span>();
    itemRanges.<span style="color: #bc6ec5; font-weight: bold;">Dispose</span>();
}
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgfb7501c"></a>Shader<br />
<ul class="org-ul">
<li><a id="orgbe88da3"></a>Lighting.hlsl<br />
<div class="outline-text-9" id="text-orgbe88da3">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">//com.unity.render-pipelines.universal@14.0.8/ShaderLibrary/Lighting.hlsl</span>

<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_ADDITIONAL_LIGHTS</span>)
uint pixelLightCount = GetAdditionalLightsCount();

<span style="color: #bc6ec5;">#if</span> USE_FORWARD_PLUS
<span style="color: #4f97d7; font-weight: bold;">for</span> (uint lightIndex = 0; lightIndex &lt; <span style="color: #4f97d7;">min</span>(URP_FP_DIRECTIONAL_LIGHTS_COUNT, MAX_VISIBLE_LIGHTS); lightIndex++)
{
    FORWARD_PLUS_SUBTRACTIVE_LIGHT_CHECK

    Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

<span style="color: #bc6ec5;">#ifdef</span> <span style="color: #7590db;">_LIGHT_LAYERS</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
<span style="color: #bc6ec5;">#endif</span>
    {
        lightingData.additionalLightsColor += LightingPhysicallyBased(brdfData, brdfDataClearCoat, light,
                                                                      inputData.normalWS, inputData.viewDirectionWS,
                                                                      surfaceData.clearCoatMask, specularHighlightsOff);
    }
}
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// LIGHT_LOOP_BEGIN &#36825;&#37324;&#25191;&#34892; Forward Plus &#20809;&#29031;</span>
LIGHT_LOOP_BEGIN(pixelLightCount)
    Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

<span style="color: #bc6ec5;">#ifdef</span> <span style="color: #7590db;">_LIGHT_LAYERS</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
<span style="color: #bc6ec5;">#endif</span>
    {
        lightingData.additionalLightsColor += LightingPhysicallyBased(brdfData, brdfDataClearCoat, light,
                                                                      inputData.normalWS, inputData.viewDirectionWS,
                                                                      surfaceData.clearCoatMask, specularHighlightsOff);
    }
LIGHT_LOOP_END
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_ADDITIONAL_LIGHTS_VERTEX</span>)
lightingData.vertexLightingColor += inputData.vertexLighting * brdfData.diffuse;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</li>
<li><a id="org6d5be5b"></a>RealtimeLights.hlsl<br />
<div class="outline-text-9" id="text-org6d5be5b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// com.unity.render-pipelines.universal@14.0.8\ShaderLibrary\RealtimeLights.hlsl</span>
<span style="color: #bc6ec5;">#if</span> USE_FORWARD_PLUS &amp;&amp; defined(LIGHTMAP_ON) &amp;&amp; defined(LIGHTMAP_SHADOW_MIXING)
<span style="color: #bc6ec5;">    #define</span> FORWARD_PLUS_SUBTRACTIVE_LIGHT_CHECK <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_AdditionalLightsColor</span>[lightIndex].a &gt; 0.0h) <span style="color: #4f97d7; font-weight: bold;">continue</span>;
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">    #define</span> FORWARD_PLUS_SUBTRACTIVE_LIGHT_CHECK
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> USE_FORWARD_PLUS
<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_BEGIN(lightCount) { \
    uint lightIndex; \
    ClusterIterator <span style="color: #7590db;">_urp_internal_clusterIterator</span> = ClusterInit(inputData.normalizedScreenSpaceUV, inputData.positionWS, 0); \
    [loop] <span style="color: #4f97d7; font-weight: bold;">while</span> (ClusterNext(<span style="color: #7590db;">_urp_internal_clusterIterator</span>, lightIndex)) { \
        lightIndex += URP_FP_DIRECTIONAL_LIGHTS_COUNT; \
        FORWARD_PLUS_SUBTRACTIVE_LIGHT_CHECK
<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_END } }
<span style="color: #bc6ec5;">#elif</span> !<span style="color: #7590db;">_USE_WEBGL1_LIGHTS</span>
<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_BEGIN(lightCount) \
    <span style="color: #4f97d7; font-weight: bold;">for</span> (uint lightIndex = 0u; lightIndex &lt; lightCount; ++lightIndex) {

<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_END }
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// WebGL 1 doesn't support variable for loop conditions</span>
<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_BEGIN(lightCount) \
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> lightIndex = 0; lightIndex &lt; <span style="color: #7590db;">_WEBGL1_MAX_LIGHTS</span>; ++lightIndex) { \
        <span style="color: #4f97d7; font-weight: bold;">if</span> (lightIndex &gt;= (<span style="color: #ce537a; font-weight: bold;">int</span>)lightCount) <span style="color: #4f97d7; font-weight: bold;">break</span>;

<span style="color: #bc6ec5;">    #define</span> LIGHT_LOOP_END }
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</li>
<li><a id="org2eaa1a3"></a>Clustering.hlsl<br />
<div class="outline-text-9" id="text-org2eaa1a3">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// com.unity.render-pipelines.universal@14.0.8/ShaderLibrary/Clustering.hlsl</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> ClusterIterator
{
    uint tileOffset;
    uint zBinOffset;
    uint tileMask;
    <span style="color: #2aa1ae; background-color: #292e34;">// Stores the next light index in first 16 bits, and the max light index in the last 16 bits.</span>
    uint entityIndexNextMax;
};

ClusterIterator <span style="color: #bc6ec5; font-weight: bold;">ClusterInit</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> normalizedScreenSpaceUV, <span style="color: #ce537a; font-weight: bold;">float3</span> positionWS, <span style="color: #ce537a; font-weight: bold;">int</span> headerIndex)
{
    ClusterIterator state = (ClusterIterator)0;
    <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
}

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">ClusterNext</span>(<span style="color: #4f97d7; font-weight: bold;">inout</span> ClusterIterator it, <span style="color: #4f97d7; font-weight: bold;">out</span> uint entityIndex)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9804c6b" class="outline-4">
<h4 id="org9804c6b">Native RenderPass</h4>
<div class="outline-text-4" id="text-org9804c6b">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/urp-universal-renderer.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/urp-universal-renderer.html</a><br /></li>
<li><a href="https://forum.unity.com/threads/what-is-the-issue-with-native-renderpass-and-xr.1141285/">https://forum.unity.com/threads/what-is-the-issue-with-native-renderpass-and-xr.1141285/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb2a5e9a" class="outline-4">
<h4 id="orgb2a5e9a">URPAsset</h4>
<div class="outline-text-4" id="text-orgb2a5e9a">
</div>
<div id="outline-container-orge9dc466" class="outline-5">
<h5 id="orge9dc466">Runtime 修改 URPAsset 设置</h5>
<div class="outline-text-5" id="text-orge9dc466">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>.<span style="color: #7590db;">Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Reflection</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>.<span style="color: #7590db;">Rendering</span>.<span style="color: #7590db;">Universal</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">UniversalRenderPipelineAssetExtensions</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">GetRenderFeature</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #ce537a; font-weight: bold;">UniversalRenderPipelineAsset</span> <span style="color: #7590db;">asset</span>, <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">name</span>) <span style="color: #4f97d7; font-weight: bold;">where</span> T : ScriptableRendererFeature
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">type</span> = asset.<span style="color: #bc6ec5; font-weight: bold;">GetType</span>();
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">propertyInfo</span> = type.<span style="color: #bc6ec5; font-weight: bold;">GetField</span>(<span style="color: #2d9574;">"m_RendererDataList"</span>, BindingFlags.Instance | BindingFlags.NonPublic);

        <span style="color: #4f97d7; font-weight: bold;">if</span> (propertyInfo == <span style="color: #a45bad;">null</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">null</span>;
        }

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">scriptableRenderData</span> = (<span style="color: #ce537a; font-weight: bold;">ScriptableRendererData</span>[])propertyInfo.<span style="color: #bc6ec5; font-weight: bold;">GetValue</span>(<span style="color: #ce537a; font-weight: bold;">asset</span>);

        <span style="color: #4f97d7; font-weight: bold;">if</span> (scriptableRenderData != <span style="color: #a45bad;">null</span> &amp;&amp; scriptableRenderData.Length &gt; 0)
        {
            <span style="color: #4f97d7; font-weight: bold;">foreach</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">renderData</span> <span style="color: #4f97d7; font-weight: bold;">in</span> scriptableRenderData)
            {
                <span style="color: #4f97d7; font-weight: bold;">foreach</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rendererFeature</span> <span style="color: #4f97d7; font-weight: bold;">in</span> renderData.rendererFeatures)
                {
                    <span style="color: #4f97d7; font-weight: bold;">if</span> (rendererFeature <span style="color: #4f97d7; font-weight: bold;">is</span> T &amp;&amp; rendererFeature.name == name)
                    {
                        <span style="color: #4f97d7; font-weight: bold;">return</span> rendererFeature <span style="color: #4f97d7; font-weight: bold;">as</span> T;
                    }
                }
            }
        }

        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">null</span>;
    }

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">SetRenderFeatureEnable</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #ce537a; font-weight: bold;">UniversalRenderPipelineAsset</span> <span style="color: #7590db;">asset</span>, <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">name</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">enable</span>) <span style="color: #4f97d7; font-weight: bold;">where</span> T : ScriptableRendererFeature
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">feature</span> = <span style="color: #bc6ec5; font-weight: bold;">GetRenderFeature</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #ce537a; font-weight: bold;">asset</span>, <span style="color: #ce537a; font-weight: bold;">name</span>);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (feature)
            feature.<span style="color: #bc6ec5; font-weight: bold;">SetActive</span>(<span style="color: #ce537a; font-weight: bold;">enable</span>);

        <span style="color: #4f97d7; font-weight: bold;">return</span> feature;
    }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">EnableFeature</span>(<span style="color: #ce537a; font-weight: bold;">FeatureTag</span> <span style="color: #7590db;">featureTag</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isEnable</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">asset</span> =  GraphicsSettings.currentRenderPipeline <span style="color: #4f97d7; font-weight: bold;">as</span> UniversalRenderPipelineAsset;
    <span style="color: #4f97d7; font-weight: bold;">switch</span>(featureTag)
    {
    <span style="color: #4f97d7; font-weight: bold;">case</span> FeatureTag.kColorRT:
        asset.supportsCameraOpaqueTexture = isEnable;
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">case</span> FeatureTag.kDepthRT:
        asset.supportsCameraDepthTexture = isEnable;
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">case</span> FeatureTag.kUpdateDepthRT:
        asset.<span style="color: #bc6ec5; font-weight: bold;">SetRenderFeatureEnable</span>&lt;<span style="color: #ce537a; font-weight: bold;">CopyDepth</span>&gt;(<span style="color: #2d9574;">"UpdateDepth"</span>, isEnable);
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">case</span> FeatureTag.kPlaneReflectionRT:
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">TODO</span>
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2d603a3" class="outline-4">
<h4 id="org2d603a3">RenderFeature</h4>
<div class="outline-text-4" id="text-org2d603a3">
</div>
<div id="outline-container-orgd81cff0" class="outline-5">
<h5 id="orgd81cff0">Disable/Enable RenderFeature Runtime</h5>
<div class="outline-text-5" id="text-orgd81cff0">
<div class="org-src-container">
<pre class="src src-csharp">screenShotRendererFeature.<span style="color: #bc6ec5; font-weight: bold;">SetActive</span>(<span style="color: #ce537a; font-weight: bold;">enableSSRF</span>);
</pre>
</div>

<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/enable-or-disable-render-features-at-runtime.932571/">https://forum.unity.com/threads/enable-or-disable-render-features-at-runtime.932571/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8eef992" class="outline-5">
<h5 id="org8eef992">Custom RenderFeature</h5>
<div class="outline-text-5" id="text-org8eef992">
</div>
<div id="outline-container-orgbc5acda" class="outline-6">
<h6 id="orgbc5acda">template</h6>
<div class="outline-text-6" id="text-orgbc5acda">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>.<span style="color: #7590db;">Rendering</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">old version namespace</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">using UnityEngine.Rendering.LWRP;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>.<span style="color: #7590db;">Rendering</span>.<span style="color: #7590db;">Universal</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPassFeature</span> : <span style="color: #ce537a; font-weight: bold;">ScriptableRendererFeature</span>
{
    <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span> : <span style="color: #ce537a; font-weight: bold;">ScriptableRenderPass</span>
    {

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Mesh</span> <span style="color: #7590db;">Mesh</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">Material</span>;

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">CustomRenderPass</span>()
        {
            <span style="color: #4f97d7; font-weight: bold;">base</span>.profilingSampler = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">ProfilingSampler</span>(<span style="color: #bc6ec5; font-weight: bold;">nameof</span>(<span style="color: #7590db;">CustomRenderPassFeature</span>));
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">This method is called by the renderer before rendering a camera</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Override this method if you need to to configure render targets and their clear state, and to create temporary render target textures.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">If a render pass doesn't override this method, this render pass renders to the active Camera's render target.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;/c&gt; and &lt;c&gt;ConfigureClear&lt;/c&gt;.</span>
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnCameraSetup</span>(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>, <span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">RenderingData</span> <span style="color: #7590db;">renderingData</span>)
        {

        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">This method is called before executing the render pass.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">It can be used to configure render targets and their clear state. Also to create temporary render target textures.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">When empty this render pass will render to the active camera render target.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;/c&gt; and &lt;c&gt;ConfigureClear&lt;/c&gt;.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">The render pipeline will ensure target setup and clearing happens in an performance manner.</span>
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Configure</span>(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>, <span style="color: #ce537a; font-weight: bold;">RenderTextureDescriptor</span> <span style="color: #7590db;">cameraTextureDescriptor</span>)
        {
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Here you can implement the rendering logic.</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Use &lt;c&gt;ScriptableRenderContext&lt;/c&gt; to issue drawing commands or execute command buffers</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.</span>
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">RenderingData</span> <span style="color: #7590db;">renderingData</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span> = CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Get</span>();
            <span style="color: #4f97d7; font-weight: bold;">using</span> (<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">ProfilingScope</span>(<span style="color: #ce537a; font-weight: bold;">cmd</span>, <span style="color: #4f97d7; font-weight: bold;">base</span>.profilingSampler))
            {
                cmd.<span style="color: #bc6ec5; font-weight: bold;">DrawMeshInstanced</span>(Mesh, 0, Material, 0, <span style="color: #4f97d7; font-weight: bold;">new</span>[] { Matrix4x4.<span style="color: #bc6ec5; font-weight: bold;">TRS</span>(Vector3.zero, Quaternion.identity, Vector3.one) });
            }

            context.<span style="color: #bc6ec5; font-weight: bold;">ExecuteCommandBuffer</span>(cmd);
            CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Release</span>(cmd);
        }

        <span style="color: #9f8766;">/// Cleanup any allocated resources that were created during the execution of this render pass.</span>
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FrameCleanup</span>(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>)
        {
        }
    }

    <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span> <span style="color: #7590db;">m_ScriptablePass</span>;

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Create</span>()
    {
        Debug.<span style="color: #bc6ec5; font-weight: bold;">Log</span>(<span style="color: #2d9574;">"Create"</span>);

        m_ScriptablePass = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span>();
        m_ScriptablePass.Mesh = Resources.<span style="color: #bc6ec5; font-weight: bold;">Load</span>&lt;<span style="color: #ce537a; font-weight: bold;">Mesh</span>&gt;(<span style="color: #2d9574;">"Cube123"</span>);
        m_ScriptablePass.Material = Resources.<span style="color: #bc6ec5; font-weight: bold;">Load</span>&lt;<span style="color: #ce537a; font-weight: bold;">Material</span>&gt;(<span style="color: #2d9574;">"TestMaterial123"</span>);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Configures where the render pass should be injected.</span>
        m_ScriptablePass.renderPassEvent = RenderPassEvent.BeforeRenderingOpaques;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Here you can inject one or multiple render passes in the renderer.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">This method is called when setting up the renderer once per-camera.</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AddRenderPasses</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderer</span> <span style="color: #7590db;">renderer</span>, <span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">RenderingData</span> <span style="color: #7590db;">renderingData</span>)
    {
        renderer.<span style="color: #bc6ec5; font-weight: bold;">EnqueuePass</span>(m_ScriptablePass);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc6893e0" class="outline-6">
<h6 id="orgc6893e0">kawase blur</h6>
<div class="outline-text-6" id="text-orgc6893e0">
<ul class="org-ul">
<li><a href="https://github.com/sebastianhein/urp_kawase_blur/">https://github.com/sebastianhein/urp_kawase_blur/</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>.<span style="color: #7590db;">Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>.<span style="color: #7590db;">Rendering</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>.<span style="color: #7590db;">Rendering</span>.<span style="color: #7590db;">Universal</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">KawaseBlur</span> : <span style="color: #ce537a; font-weight: bold;">ScriptableRendererFeature</span>
{
    [System.Serializable]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> KawaseBlurSettings
    {
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">RenderPassEvent</span> <span style="color: #7590db;">renderPassEvent</span> = RenderPassEvent.AfterRenderingTransparents;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">blurMaterial</span> = <span style="color: #a45bad;">null</span>;

        [<span style="color: #bc6ec5; font-weight: bold;">Range</span>(2,15)]
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> blurPasses = 1;

        [<span style="color: #bc6ec5; font-weight: bold;">Range</span>(1,4)]
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> downsample = 1;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">copyToFramebuffer</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">targetName</span> = <span style="color: #2d9574;">"_blurTexture"</span>;
    }

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">KawaseBlurSettings</span> <span style="color: #7590db;">settings</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">KawaseBlurSettings</span>();

    <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span> : <span style="color: #ce537a; font-weight: bold;">ScriptableRenderPass</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">blurMaterial</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">passes</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">downsample</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">copyToFramebuffer</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">targetName</span>;
        <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">profilerTag</span>;

        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">tmpId1</span>;
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">tmpId2</span>;

        <span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span> <span style="color: #7590db;">tmpRT1</span>;
        <span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span> <span style="color: #7590db;">tmpRT2</span>;

        <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span> <span style="color: #7590db;">source</span> { <span style="color: #4f97d7; font-weight: bold;">get</span>; <span style="color: #4f97d7; font-weight: bold;">set</span>; }

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Setup</span>(<span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span> <span style="color: #7590db;">source</span>) {
            <span style="color: #4f97d7; font-weight: bold;">this</span>.source = source;
        }

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">CustomRenderPass</span>(<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">profilerTag</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">this</span>.profilerTag = profilerTag;
        }

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Configure</span>(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>, <span style="color: #ce537a; font-weight: bold;">RenderTextureDescriptor</span> <span style="color: #7590db;">cameraTextureDescriptor</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">width</span> = cameraTextureDescriptor.width / downsample;
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">height</span> = cameraTextureDescriptor.height / downsample;

            tmpId1 = Shader.<span style="color: #bc6ec5; font-weight: bold;">PropertyToID</span>(<span style="color: #2d9574;">"tmpBlurRT1"</span>);
            tmpId2 = Shader.<span style="color: #bc6ec5; font-weight: bold;">PropertyToID</span>(<span style="color: #2d9574;">"tmpBlurRT2"</span>);
            cmd.<span style="color: #bc6ec5; font-weight: bold;">GetTemporaryRT</span>(tmpId1, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32);
            cmd.<span style="color: #bc6ec5; font-weight: bold;">GetTemporaryRT</span>(tmpId2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32);

            tmpRT1 = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span>(tmpId1);
            tmpRT2 = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">RenderTargetIdentifier</span>(tmpId2);

            <span style="color: #bc6ec5; font-weight: bold;">ConfigureTarget</span>(tmpRT1);
            <span style="color: #bc6ec5; font-weight: bold;">ConfigureTarget</span>(tmpRT2);
        }

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">RenderingData</span> <span style="color: #7590db;">renderingData</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span> = CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Get</span>(profilerTag);

            <span style="color: #ce537a; font-weight: bold;">RenderTextureDescriptor</span> <span style="color: #7590db;">opaqueDesc</span> = renderingData.cameraData.cameraTargetDescriptor;
            opaqueDesc.depthBufferBits = 0;

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">first pass</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cmd.GetTemporaryRT(tmpId1, opaqueDesc, FilterMode.Bilinear);</span>
            cmd.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalFloat</span>(<span style="color: #2d9574;">"_offset"</span>, 1.5f);
            cmd.<span style="color: #bc6ec5; font-weight: bold;">Blit</span>(source, tmpRT1, blurMaterial);

            <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">i</span>=1; i&lt;passes-1; i++) {
                cmd.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalFloat</span>(<span style="color: #2d9574;">"_offset"</span>, 0.5f + i);
                cmd.<span style="color: #bc6ec5; font-weight: bold;">Blit</span>(tmpRT1, tmpRT2, blurMaterial);

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pingpong</span>
                <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">rttmp</span> = tmpRT1;
                tmpRT1 = tmpRT2;
                tmpRT2 = rttmp;
            }

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">final pass</span>
            cmd.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalFloat</span>(<span style="color: #2d9574;">"_offset"</span>, 0.5f + passes - 1f);
            <span style="color: #4f97d7; font-weight: bold;">if</span> (copyToFramebuffer) {
                cmd.<span style="color: #bc6ec5; font-weight: bold;">Blit</span>(tmpRT1, source, blurMaterial);
            } <span style="color: #4f97d7; font-weight: bold;">else</span> {
                cmd.<span style="color: #bc6ec5; font-weight: bold;">Blit</span>(tmpRT1, tmpRT2, blurMaterial);
                cmd.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalTexture</span>(targetName, tmpRT2);
            }

            context.<span style="color: #bc6ec5; font-weight: bold;">ExecuteCommandBuffer</span>(cmd);
            cmd.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();

            CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Release</span>(cmd);
        }

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FrameCleanup</span>(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>)
        {
        }
    }

    <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span> <span style="color: #7590db;">scriptablePass</span>;

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Create</span>()
    {
        scriptablePass = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPass</span>(<span style="color: #2d9574;">"KawaseBlur"</span>);
        scriptablePass.blurMaterial = settings.blurMaterial;
        scriptablePass.passes = settings.blurPasses;
        scriptablePass.downsample = settings.downsample;
        scriptablePass.copyToFramebuffer = settings.copyToFramebuffer;
        scriptablePass.targetName = settings.targetName;

        scriptablePass.renderPassEvent = settings.renderPassEvent;
    }

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AddRenderPasses</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderer</span> <span style="color: #7590db;">renderer</span>, <span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">RenderingData</span> <span style="color: #7590db;">renderingData</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">src</span> = renderer.cameraColorTarget;
        scriptablePass.<span style="color: #bc6ec5; font-weight: bold;">Setup</span>(src);
        renderer.<span style="color: #bc6ec5; font-weight: bold;">EnqueuePass</span>(scriptablePass);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1888f90" class="outline-6">
<h6 id="org1888f90">len flares</h6>
<div class="outline-text-6" id="text-org1888f90">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/containers/create-custom-renderer-feature-1.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/containers/create-custom-renderer-feature-1.html</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org82dcb3e" class="outline-4">
<h4 id="org82dcb3e">Volume Framework</h4>
<div class="outline-text-4" id="text-org82dcb3e">
</div>
<div id="outline-container-orgb749e17" class="outline-5">
<h5 id="orgb749e17">VolumeManager</h5>
<div class="outline-text-5" id="text-orgb749e17">
<p>
VolumeManager 中包含两个 VolumeStack，stack 和 m_DefaultStack。<br />
</p>
</div>
</div>
<div id="outline-container-orga75fc99" class="outline-5">
<h5 id="orga75fc99">VolumeStack</h5>
<div class="outline-text-5" id="text-orga75fc99">
<p>
VolumeStack 用于保存多个 Volume 混合后的参数值。默认情况下，VolumeManager 中有一个全局 VolumeStack，但如果你需要使用特定设置调用 VolumeManger 的 Update 并将结果存储以供以后使用，则可以使用 CreateStack() 创建自己的 VolumeStack。<br />
</p>

<ul class="org-ul">
<li>defaultParameters 属性：该属性是一个 (VolumeParameter parameter, VolumeParameter defaultValue) 二元组，<br />
<ul class="org-ul">
<li>parameter 用于存储 VolumeStack 的 components 中某个 VolumeComponent 对应的某个参数的引用<br /></li>
<li>defaultValue 用于存储 VolumeManager.defaultVolumeComponent 对应 VolumeComponent 的对应参数的默认值<br /></li>
<li>VolumeManager Update 开始时，会使用 defaultValue 重置 parameter<br /></li>
</ul></li>
<li>components 属性：用于保存多个 Volume 混合后的参数值。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org15516be" class="outline-5">
<h5 id="org15516be">VolumeComponent</h5>
<div class="outline-text-5" id="text-org15516be">
<p>
VolumeComponent 用于存储某种效果（如 Bloom）的所有参数。<br />
</p>

<ul class="org-ul">
<li>internal readonly List&lt;VolumeParameter&gt; parameterList; 属性存储了该效果的所有参数列表。<br /></li>
<li>Override(VolumeComponent state, float interpFactor) 该方法用当前的 VolumeComponent 保存的参数覆盖 state 持有的参数。interpFactor 可以指定当前参数和 state 参数的混合比例, 将混合后的结果参数覆盖为 state 的参数<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1cc382e" class="outline-5">
<h5 id="org1cc382e">VolumeParameter</h5>
<div class="outline-text-5" id="text-org1cc382e">
<p>
VolumeParameter 用于表示某类参数，例如 Vector3Parameter 为 Vector3 类型的参数。<br />
overrideState 为 False 时，VolumeManager 不会采用该 VolumeParameter 的参数值。因此，对该 VolumeParameter 的修改不会对画面效果产生影响<br />
</p>

<ul class="org-ul">
<li>overrideState 属性: 用于直接读写 VolumeParameter 的 m_OverrideState 标记<br /></li>
<li>value 属性: 用于直接读写 VolumeParameter 存储的 m_Value 参数值<br /></li>
<li>Override 函数: 用于设置 VolumeParameter 存储的参数值，并将 VolumeParameter 的 overrideState 标记为 true<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcdda3e6" class="outline-5">
<h5 id="orgcdda3e6">Volume</h5>
<div class="outline-text-5" id="text-orgcdda3e6">
<p>
Volume 是挂在 GameObject 上的 Component。用于定义效果的作用区域，其可以是 Global 类型(作用区域为全局)，也可以是 Local 类型(作用区域通过 Collider 定义)。其持有 VolumeProfile，VolumeProfile 用于 覆盖(Override) VolumeComponent 的默认值。<br />
</p>
</div>
<div id="outline-container-org1587c7a" class="outline-6">
<h6 id="org1587c7a">Volume Inspector 参数</h6>
<div class="outline-text-6" id="text-org1587c7a">
</div>
<ul class="org-ul">
<li><a id="org3f24e03"></a>Mode 参数<br />
<div class="outline-text-7" id="text-org3f24e03">
<p>
用于定义效果的作用区域，它有两种模式<br />
</p>
<ul class="org-ul">
<li>Global 使得 Volume 没有边界，其可以影响场景中的每个相机<br /></li>
<li>Local  通过 Collider 指定 Volume 的边界，只有在边界内的摄像机才会受影响<br /></li>
</ul>
<p>
Camera 上可以设置 VolumeTrigger。默认 Volume Trigger 为 null，则以 Camera 自己为 Trigger，即 Camera 进入 Volume 时 Volume 效果对该 Camera 生效。<br />
</p>
</div>
</li>
<li><a id="org239c982"></a>Blend Distance 参数<br />
<div class="outline-text-7" id="text-org239c982">
<p>
用于指定开始混合的最大距离。0 表示进入 Volume 才开始混合。当 blend distance 大于 0 时，摄像机没进入 Volume 之前就会开始混合，此时摄像机在 Volume 边界外也会受影响，如下图所示：<br />
<img src="./URP/volume-blendDis.jpg" alt="volume-blendDis.jpg" /><br />
假设摄像机到 Volume 最近边界的距离为 cam2VDis, cam2VDis 等于 blend distance 时混合权重为 0，cam2VDis 等于 0 时混合权重为 1。这样就可以模拟出 FadeIn FadeOut 的效果。<br />
</p>
</div>
</li>
<li><a id="orga333975"></a>Wight 参数<br />
<div class="outline-text-7" id="text-orga333975">
<p>
指定 Volume 对场景的影响权重。该值会被乘到混合权重上。<br />
</p>
</div>
</li>
<li><a id="orgffabdfc"></a>Priority 参数<br />
<div class="outline-text-7" id="text-orgffabdfc">
<p>
指定 Volume 的优先级。VolumeManager 会按照 Volume 的优先级从低到高处理每个 Volume，然后将 Volume 配置的参数混合到 VolumeStack 中，混合算法如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Volume has influence</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">interpFactor</span> = 1f;

<span style="color: #4f97d7; font-weight: bold;">if</span> (blendDistSqr &gt; 0f)
    interpFactor = 1f - (closestDistanceSqr / blendDistSqr);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">No need to clamp01 the interpolation factor as it'll always be in [0, 1] range</span>
<span style="color: #bc6ec5; font-weight: bold;">OverrideData</span>(stack, volume.profileRef.components, interpFactor * Mathf.<span style="color: #bc6ec5; font-weight: bold;">Clamp01</span>(volume.weight));
</pre>
</div>
<p>
所以，两个 Volume 有重叠区域时，若高优先级的 volume 的 weight 为 1，则会完全覆盖掉低优先级的 volume。当两个 Volume 优先级相同时，覆盖顺序是没有保证的，其和两个 Volume 的创建顺序有关。<br />
</p>
</div>
</li>
<li><a id="org10b1488"></a>Profile 参数<br />
<div class="outline-text-7" id="text-org10b1488">
<p>
指定 VolumeProfile，VolumeProfile 存储了调节后的 VolumeComponent 的参数值。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3bc6744" class="outline-6">
<h6 id="org3bc6744">Volume 实现</h6>
<div class="outline-text-6" id="text-org3bc6744">
<p>
Volume 有两个属性：profile 和 sharedProfile, 其 material sharedMaterial 概念类似。调用 profile 会以 sharedProfile 为基础创建新的实例。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org796dfb1" class="outline-5">
<h5 id="org796dfb1">VolumeProfile</h5>
<div class="outline-text-5" id="text-org796dfb1">
<ul class="org-ul">
<li>components 属性: 存储了所有的 VolumeComponent（VolumeComponent 存储某种效果的所有参数）<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org6b62fb5" class="outline-3">
<h3 id="org6b62fb5">Shader</h3>
<div class="outline-text-3" id="text-org6b62fb5">
</div>
<div id="outline-container-org57c3ff7" class="outline-4">
<h4 id="org57c3ff7">MultiPass</h4>
<div class="outline-text-4" id="text-org57c3ff7">
<p>
方案 1： shader 中多个 Pass。会打断 SRP Batch。<br />
方案 2： 为同一个物体使用多个材质<br />
</p>

<ul class="org-ul">
<li><a href="https://github.com/chavaloart/urp-multi-pass">https://github.com/chavaloart/urp-multi-pass</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org79bb383" class="outline-4">
<h4 id="org79bb383">Lightmap 烘培</h4>
<div class="outline-text-4" id="text-org79bb383">
<p>
<a href="./UnityCatLikeCoding.html#org05f9fb8">Lightmap 烘培</a><br />
</p>
</div>
</div>
<div id="outline-container-org4f3ca39" class="outline-4">
<h4 id="org4f3ca39">MRT</h4>
<div class="outline-text-4" id="text-org4f3ca39">
<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/mrt-in-urp.913469/">https://forum.unity.com/threads/mrt-in-urp.913469/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6751e26" class="outline-3">
<h3 id="org6751e26">Misc</h3>
<div class="outline-text-3" id="text-org6751e26">
</div>
<div id="outline-container-org378ab87" class="outline-4">
<h4 id="org378ab87">Upgrade Buildin Shader To URP</h4>
<div class="outline-text-4" id="text-org378ab87">
</div>
<div id="outline-container-org01b19c4" class="outline-5">
<h5 id="org01b19c4">Point Light Effect Error</h5>
<div class="outline-text-5" id="text-org01b19c4">
<ul class="org-ul">
<li><a href="http://www.kittehface.com/2020/05/light-universal-render-pipeline-to.html">http://www.kittehface.com/2020/05/light-universal-render-pipeline-to.html</a><br /></li>
<li><a href="https://forum.unity.com/threads/lwrp-urp-point-light-issues.809382/">https://forum.unity.com/threads/lwrp-urp-point-light-issues.809382/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf8a9d15" class="outline-5">
<h5 id="orgf8a9d15">Common</h5>
<div class="outline-text-5" id="text-orgf8a9d15">
<p>
URP 提供了下面工具，实现自动将 Buildin Material 升级为 URP Mateiral。<br />
Edit/Render Pipeline/Universal Render Pipeline/Upgrade Selected Materials to UniversalRP Materials<br />
</p>

<p>
工具实现在下面文件：<br />
com.unity.render-pipelines.universal@10.5.0\Editor\UniversalRenderPipelineMaterialUpgrader.cs<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/upgrading-your-shaders.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/upgrading-your-shaders.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge9f53ea" class="outline-4">
<h4 id="orge9f53ea">Unity Buildin 和 URP 支持的 Feature 对比</h4>
<div class="outline-text-4" id="text-orge9f53ea">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/universalrp-builtin-feature-comparison.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/universalrp-builtin-feature-comparison.html</a><br /></li>
<li>Upgrading shaders from Built-in <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/upgrading-your-shaders.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/upgrading-your-shaders.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4682d78" class="outline-4">
<h4 id="org4682d78">创建一个 Lit Shader Graph 默认文件，生成的 shader 代码</h4>
<div class="outline-text-4" id="text-org4682d78">
<p>
下面文件是对 Lit Shader Graph 默认文件简化后的 shader 代码。<br />
<a href="./URP/urp_lit_shader_graph.shader">./URP/urp_lit_shader_graph.shader</a><br />
</p>

<p>
shader 的 vert frag 入口函数被定义在 com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/PBRForwardPass.hlsl 文件中。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">PackedVaryings <span style="color: #bc6ec5; font-weight: bold;">vert</span>(Attributes input)
{
    Varyings output = (Varyings)0;
    output = BuildVaryings(input);
    PackedVaryings packedOutput = (PackedVaryings)0;
    packedOutput = PackVaryings(output);
    <span style="color: #4f97d7; font-weight: bold;">return</span> packedOutput;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(PackedVaryings packedInput) : SV_TARGET
{
    Varyings unpacked = UnpackVaryings(packedInput);
    UNITY_SETUP_INSTANCE_ID(unpacked);
    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(unpacked);

    SurfaceDescriptionInputs surfaceDescriptionInputs = BuildSurfaceDescriptionInputs(unpacked);
    SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);

<span style="color: #bc6ec5;">    #if</span> <span style="color: #7590db;">_ALPHATEST_ON</span>
        <span style="color: #ce537a; font-weight: bold;">half</span> alpha = surfaceDescription.Alpha;
        <span style="color: #4f97d7;">clip</span>(alpha - surfaceDescription.AlphaClipThreshold);
<span style="color: #bc6ec5;">    #elif</span> <span style="color: #7590db;">_SURFACE_TYPE_TRANSPARENT</span>
        <span style="color: #ce537a; font-weight: bold;">half</span> alpha = surfaceDescription.Alpha;
    #els
        <span style="color: #ce537a; font-weight: bold;">half</span> alpha = 1;
<span style="color: #bc6ec5;">    #endif</span>

    InputData inputData;
    InitializeInputData(unpacked, surfaceDescription, inputData);
    <span style="color: #2aa1ae; background-color: #292e34;">// TODO: Mip debug modes would require this, open question how to do this on ShaderGraph.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//SETUP_DEBUG_TEXTURE_DATA(inputData, unpacked.texCoord1.xy, _MainTex);</span>

<span style="color: #bc6ec5;">    #ifdef</span> <span style="color: #7590db;">_SPECULAR_SETUP</span>
        <span style="color: #ce537a; font-weight: bold;">float3</span> specular = surfaceDescription.<span style="color: #4f97d7; font-weight: bold;">Specular</span>;
        <span style="color: #ce537a; font-weight: bold;">float</span> metallic = 1;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #ce537a; font-weight: bold;">float3</span> specular = 0;
        <span style="color: #ce537a; font-weight: bold;">float</span> metallic = surfaceDescription.Metallic;
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0);
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_NORMALMAP</span>) &amp;&amp; defined(<span style="color: #7590db;">_NORMAL_DROPOFF_TS</span>)
        normalTS = surfaceDescription.NormalTS;
<span style="color: #bc6ec5;">    #endif</span>

    SurfaceData surface;
    surface.albedo              = surfaceDescription.BaseColor;
    surface.metallic            = <span style="color: #4f97d7;">saturate</span>(metallic);
    surface.specular            = specular;
    surface.smoothness          = <span style="color: #4f97d7;">saturate</span>(surfaceDescription.Smoothness),
    surface.occlusion           = surfaceDescription.Occlusion,
    surface.emission            = surfaceDescription.<span style="color: #4f97d7; font-weight: bold;">Emission</span>,
    surface.alpha               = <span style="color: #4f97d7;">saturate</span>(alpha);
    surface.normalTS            = normalTS;
    surface.clearCoatMask       = 0;
    surface.clearCoatSmoothness = 1;

<span style="color: #bc6ec5;">    #ifdef</span> <span style="color: #7590db;">_CLEARCOA</span>
        surface.clearCoatMask       = <span style="color: #4f97d7;">saturate</span>(surfaceDescription.CoatMask);
        surface.clearCoatSmoothness = <span style="color: #4f97d7;">saturate</span>(surfaceDescription.CoatSmoothness);
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">#ifdef</span> <span style="color: #7590db;">_DBUFFER</span>
    ApplyDecalToSurfaceData(unpacked.positionCS, surface, inputData);
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #ce537a; font-weight: bold;">half4</span> color = UniversalFragmentPBR(inputData, surface);

    color.rgb = MixFog(color.rgb, inputData.fogCoord);
    <span style="color: #4f97d7; font-weight: bold;">return</span> color;
}
</pre>
</div>
<p>
生成的 shader 代码<br />
</p>
</div>
</div>
<div id="outline-container-org96d2c06" class="outline-4">
<h4 id="org96d2c06">URP Buildin GI 比较</h4>
<div class="outline-text-4" id="text-org96d2c06">
<p>
下图为图 1<br />
</p>


<div id="orgd648425" class="figure">
<p><img src="./URP/gi_compare_01.png" alt="gi_compare_01.png" width="1500px" /><br />
</p>
</div>

<p>
下图为图 2<br />
</p>

<div id="org377e397" class="figure">
<p><img src="./URP/gi_compare_02.png" alt="gi_compare_02.png" width="1500px" /><br />
</p>
</div>

<p>
下图为图 3<br />
</p>

<div id="orge21f923" class="figure">
<p><img src="./URP/gi_compare_03.png" alt="gi_compare_03.png" width="1500px" /><br />
</p>
</div>

<p>
下图为图 4<br />
</p>

<div id="orgf3dad9c" class="figure">
<p><img src="./URP/gi_compare_04.png" alt="gi_compare_04.png" width="1500px" /><br />
</p>
</div>

<p>
下图为图 5<br />
</p>

<div id="orgceb5a43" class="figure">
<p><img src="./URP/gi_compare_05.png" alt="gi_compare_05.png" width="1500px" /><br />
</p>
</div>

<p>
图 1 中，Buildin 下 BakedGI 和 RealtimeGI 差别为什么很大？<br />
关闭 Mesh 的 LightProbe Blend，后差别几乎没有，说明 BakedGI 和 RealtimeGI 烘培所得的 LightProbe 不同，直接通过 FrameDebug 可以看到球谐系数不同。<br />
LightProbe 数据来自 AmbientColor，场景中方向光，场景中物体反射的光。前两个数据是相同的，所以只能是最后一个数据不同，而图 3 中，Buildin 下 BakedGI 和 RealtimeGI 差别不大，说明 Surface Shader 和 Standard Shader 烘培出来的结果不同。<br />
使用默认的 Surface Shader 进行测试，如图 5，发现 Buildin 下 BakedGI 和 RealtimeGI 差别不大。说明自定义的 Surface Shader 和默认的 Surface Shader 烘培出来的结果不同。<br />
</p>

<p>
检查自定义的 Surface Shader，发现其中会使用 viewDir，猜测在离线烘焙时，viewDir 的值为（0，0，0），所以导致 Custom Surface Shader MetaPass 返回的 albedo 是错误的。<br />
</p>
</div>
</div>
<div id="outline-container-org970dc63" class="outline-4">
<h4 id="org970dc63">RenderTarget Load Store 设置</h4>
<div class="outline-text-4" id="text-org970dc63">
<p>
ScriptableRenderer 对 SetRenderTarget 进行了一次封装，通过 ClearFlag 来自动化设置 RT 的 Load Store. 具体来逻辑如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Packages/com.unity.render-pipelines.universal@14.0.8/Runtime/ScriptableRenderer.cs</span>

<span style="color: #ce537a; font-weight: bold;">RenderBufferLoadAction</span> <span style="color: #7590db;">colorLoadAction</span> = ((<span style="color: #ce537a; font-weight: bold;">uint</span>)clearFlag &amp; (<span style="color: #ce537a; font-weight: bold;">uint</span>)ClearFlag.Color) != 0 ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load;
<span style="color: #ce537a; font-weight: bold;">RenderBufferLoadAction</span> <span style="color: #7590db;">depthLoadAction</span> = ((<span style="color: #ce537a; font-weight: bold;">uint</span>)clearFlag &amp; (<span style="color: #ce537a; font-weight: bold;">uint</span>)ClearFlag.Depth) != 0 ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org7183aad" class="outline-2">
<h2 id="org7183aad">HDRP</h2>
<div class="outline-text-2" id="text-org7183aad">
</div>
<div id="outline-container-org3978376" class="outline-3">
<h3 id="org3978376">Base</h3>
<div class="outline-text-3" id="text-org3978376">
</div>
<div id="outline-container-org90b407d" class="outline-4">
<h4 id="org90b407d">Introduce</h4>
<div class="outline-text-4" id="text-org90b407d">
<p>
高清渲染管线 (HDRP) 是由 Unity 针对现代（与计算着色器兼容的）平台开发的高保真可编程渲染管线 (Scriptable Render Pipeline)。<br />
</p>

<p>
HDRP 利用基于物理的光照技术、线性光照、HDR 光照和可配置的 Hybrid Tile/Cluster/Deferred/Forward lighting 架构，提供了必要的工具来创建符合高图形标准的游戏、技术 demos、动画等应用。<br />
</p>
</div>

<div id="outline-container-org1e268c7" class="outline-5">
<h5 id="org1e268c7">What problem is HDRP trying to solve?</h5>
<div class="outline-text-5" id="text-org1e268c7">
<p>
HDRP 旨在提供统一、一致的光照。这与性能以及最先进的技术息息相关。<br />
</p>
</div>

<div id="outline-container-org0a97659" class="outline-6">
<h6 id="org0a97659">统一、一致的光照</h6>
<div class="outline-text-6" id="text-org0a97659">
<p>
HDRP 是基于物理的渲染管线，这意味着你可以使用真实输入来创建场景。例如，灯光的光度以流明或勒克斯表示。<br />
现在，美术师可以独立于上下文创作资源。当上下文改变时，您的视觉效果仍能在项目中保持一致。<br />
</p>
</div>
</div>

<div id="outline-container-orgd829d05" class="outline-6">
<h6 id="orgd829d05">性能至上</h6>
<div class="outline-text-6" id="text-orgd829d05">
<p>
HDRP 功能在我们当前支持的所有平台上均可提供极高的性能。我们希望您能在不牺牲性能的情况下实现项目的美术愿景。<br />
</p>
</div>
</div>

<div id="outline-container-orge5cd6e4" class="outline-6">
<h6 id="orge5cd6e4">最先进的技术</h6>
<div class="outline-text-6" id="text-orge5cd6e4">
<p>
HDRP 采用了视频游戏行业的标准技术：基于物理的渲染、物理光单位和基于物理的组件，并提供了用户友好的工具。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org53c6bb1" class="outline-4">
<h4 id="org53c6bb1">Setup</h4>
<div class="outline-text-4" id="text-org53c6bb1">
<ol class="org-ol">
<li>安装 HDRP package<br /></li>
<li>打开 HDRP 设置向导 Window/Rendering/HDRP Wizard, 如果有设置错误，直接点击 FixAll<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgb5c4a58" class="outline-4">
<h4 id="orgb5c4a58">源码分析</h4>
<div class="outline-text-4" id="text-orgb5c4a58">
<p>
下图为 HDRP 处理流程：<br />
</p>


<div id="orgcf7f8d2" class="figure">
<p><img src="./URP/hdrp-flow.jpg" alt="hdrp-flow.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org72e0802" class="outline-4">
<h4 id="org72e0802">RP Settings</h4>
<div class="outline-text-4" id="text-org72e0802">
</div>
<div id="outline-container-org3e938bc" class="outline-5">
<h5 id="org3e938bc">HDRP Asset</h5>
<div class="outline-text-5" id="text-org3e938bc">
<p>
HDRP Asset (High Definition Render Pipeline Asset)控制项目的全局渲染设置，并负责创建 Render Pipeline 实例。类比于 URP Asset(Universal Render Pipeline Asset)。<br />
</p>

<p>
在 HDRP Asset 中开启某些渲染特性时，unity 才会为对应特性分配内存以及构建 shader variants。所以，可以通过在 HDRP Asset 中关闭某些渲染特性来减少内存占用。只可以在编辑器下，设置 HDRP Asset 中的渲染特性关闭或开启。<br />
运行时，可以通过 Frame Settings 来控制渲染特性开启关闭，但是，若 HDRP Asset 中没有开启某特性，Frame Settings 则无法开启该特性。<br />
</p>
</div>
</div>
<div id="outline-container-orgcc23c2f" class="outline-5">
<h5 id="orgcc23c2f">HDRP Global Settings</h5>
<div class="outline-text-5" id="text-orgcc23c2f">
<p>
Project Settings/HDRP Global Settings 下可以设置 HDRP Global Settings，其包含如下设置：<br />
</p>
<ul class="org-ul">
<li>Volume Profiles<br />
<ul class="org-ul">
<li>Default Volume Profile Asset    设置默认的 Volume Profile<br /></li>
<li>LookDev Volume Profile Asset    设置 LookDev 的 Volume Profile<br /></li>
</ul></li>
<li>Frame Settings(Default Values)    设置渲染相关的默认值<br />
<ul class="org-ul">
<li>Camera<br /></li>
<li>RealtimeReflection<br /></li>
<li>Baked or Custom Reflection<br /></li>
</ul></li>
<li>Layers Names<br />
<ul class="org-ul">
<li>Light Layer Names<br /></li>
<li>Decal Layer Names<br /></li>
</ul></li>
<li>Miscellaneous<br /></li>
<li>Shader Stripping<br /></li>
<li>Resources<br />
<ul class="org-ul">
<li>Player Resources<br /></li>
<li>Ray Tracing Resources<br /></li>
<li>Editor Resources<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd9677aa" class="outline-5">
<h5 id="orgd9677aa">Frame Settings</h5>
<div class="outline-text-5" id="text-orgd9677aa">
<p>
Frame Settings 是 Cameras 和 Reflection 相关的设置。在 Project Settings/HDRP Global Settings/Frame Settings(Default Values) 中设置 Frame Settings 的默认值。<br />
</p>

<p>
可以以 Component 的粒度对 Frame Settings 默认值进行 Override。在 Camera Component 上勾选 Rendering/Custom Frame Settings 来 Override。在 ReflectionProbeComponent 上勾选 Capture Settings/Custom Frame Settings 来 Override。<br />
</p>

<p>
Frame Settings 会影响所有的 Cameras 和 Reflection Probes。所有的 Cameras 和 Reflection Probes 要么使用默认的 FrameSettings, 要么使用 FrameSettings Override。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org34815a7" class="outline-4">
<h4 id="org34815a7">Shaders and Materials</h4>
<div class="outline-text-4" id="text-org34815a7">
</div>
<div id="outline-container-org0e2632f" class="outline-5">
<h5 id="org0e2632f">Shaders</h5>
<div class="outline-text-5" id="text-org0e2632f">
</div>
<div id="outline-container-org602a37e" class="outline-6">
<h6 id="org602a37e">AxF Shader</h6>
<div class="outline-text-6" id="text-org602a37e">
<p>
AxF 是 Apperance eXchange Format 的缩写，AxF 是交换材质外观数据的标准格式。通常情况下，AxF 文件的生成需要使用一个包含实时材料测量功能的工具套件（例如：X-Rite 的 Total Appearance Capture (TAC™) Ecosystem），从中可以生成各种纹理和模型属性。<br />
</p>

<ul class="org-ul">
<li>AxF 文件是一种用于存储 3D 模型材质的文件格式。它由 X-Rite 开发，并由 Khronos Group 维护。<br /></li>
</ul>

<p>
AxF.shader 位于 com.unity.render-pipelines.high-definition/Runtime/Material/AxF/AxF.shader<br />
</p>
</div>
</div>
<div id="outline-container-org86fc008" class="outline-6">
<h6 id="org86fc008">Decal</h6>
<div class="outline-text-6" id="text-org86fc008">
<p>
HDRP 中有两种方式来实现 decals<br />
</p>
<ul class="org-ul">
<li>使用 Decal Mesh 并手动防止 decal<br /></li>
<li>使用 Decal Projector 来投影 decal<br /></li>
</ul>

<p>
Decal.shader 位于 com.unity.render-pipelines.high-definition/Runtime/Material/Decal/Decal.shader<br />
DecalNormalBuffer.shader 位于 com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalNormalBuffer.shader<br />
</p>
</div>
</div>
<div id="outline-container-orgb002f90" class="outline-6">
<h6 id="orgb002f90">Cotton/Wool Shader</h6>
<div class="outline-text-6" id="text-orgb002f90">
<p>
使用 棉花、羊毛 shader 可以创建棉花、羊毛、亚麻或天鹅绒等纤维织物。纤维织物的外观受所用纤维的类型和编织方式影响，天然纤维通常较粗糙，因此会散射光线。<br />
</p>

<p>
CottonWool shader 是以 Fabric Master Stack 为基础创建的 ShaderGraph。位于 com.unity.render-pipelines.high-definition/Runtime/RenderPipelineResources/ShaderGraph/CottonWool.ShaderGraph<br />
</p>
</div>
</div>
<div id="outline-container-org3bc7e77" class="outline-6">
<h6 id="org3bc7e77">Eye Shader</h6>
<div class="outline-text-6" id="text-org3bc7e77">
<p>
Eye shader 是以 Eye Master Stack 为基础创建的 ShaderGraph。位于 Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipelineResources/ShaderGraph/Eye.shadergraph<br />
</p>
</div>
</div>
<div id="outline-container-org467f957" class="outline-6">
<h6 id="org467f957">Fog Volume Shader</h6>
<div class="outline-text-6" id="text-org467f957">
<p>
DefaultFogVolume shader 是以 Fog Volume Master Stack 为基础创建的 ShaderGraph。位于 Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipelineResources/ShaderGraph/DefaultFogVolume.shadergraph<br />
</p>
</div>
</div>
<div id="outline-container-org15d7132" class="outline-6">
<h6 id="org15d7132">Fullscreen Shader</h6>
<div class="outline-text-6" id="text-org15d7132">
<p>
HDRP 实现了 Fullscreen Master Stack, 以此为基础创建的 ShaderGraph 可以作为全屏效果的 shader。<br />
</p>
</div>
</div>
<div id="outline-container-orgf83c221" class="outline-6">
<h6 id="orgf83c221">Hair Shader</h6>
<div class="outline-text-6" id="text-orgf83c221">
<p>
Hair shader 是以 Hair Master Stack 为基础创建的 ShaderGraph。位于 Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipelineResources/ShaderGraph/Hair.shadergraph<br />
</p>
</div>
</div>
<div id="outline-container-orgf38fee9" class="outline-6">
<h6 id="orgf38fee9">Layered Lit Shader</h6>
<div class="outline-text-6" id="text-orgf38fee9">
<p>
Layered Lit Shader 允许你在同一个 GameObject 上堆叠多达 4 个材质。其为每一层使用的都是 Lit Materials。这使得在 HDRP 中创建逼真和多样的材质变得容易。主层是底层，可以通过漫反射、法线和高度影响上层。HDRP 会在主层上方按顺序渲染第一层、第二层和第三层。有关材质、着色器和纹理的信息。<br />
Layered Lit Shader 非常适合用于摄影测量。<br />
</p>

<p>
摄影测量是使用多个原始实物对象的照片来创建数字资产的过程。摄影测量有不同的用途，工作流程会根据上下文而有所不同。使用摄影测量进行游戏开发，需要考虑游戏开发时间和预算限制。<br />
</p>

<p>
LayeredLit.shader 位于 com.unity.render-pipelines.high-definition/Runtime/Material/LayeredLit/LayeredLit.shader<br />
</p>
</div>
</div>
<div id="outline-container-org55f3315" class="outline-6">
<h6 id="org55f3315">Layered Lit Tessellation Shader</h6>
<div class="outline-text-6" id="text-org55f3315">
<p>
Layered Lit Tessellation Shader 允许你在同一个 GameObject 上堆叠多达 4 个材质。其为每一层使用的都是 Lit Tessellation Materials。<br />
</p>

<p>
LayeredLitTessellation.shader 位于 com.unity.render-pipelines.high-definition/Runtime/Material/LayeredLit/LayeredLitTessellation.shader<br />
</p>
</div>
</div>
<div id="outline-container-orgcce9453" class="outline-6">
<h6 id="orgcce9453">Lit Shader</h6>
<div class="outline-text-6" id="text-orgcce9453">
<p>
使用 Lit Shader 可以轻松创建逼真的材质。其包含了 Subsurface scattering，Iridescence，Vertex or pixel displacement 等效果，并和 Decal 兼容。<br />
</p>

<p>
Subsurface scattering: 次表面散射是指光线在材料内部散射。这可以发生在皮肤和眼睛中，并导致它们看起来有光泽和柔软。<br />
Iridescence: 虹彩是指材料在不同角度下显示不同颜色的能力。这可以发生在珍珠和宝石中，并导致它们看起来有光泽和多彩。<br />
Vertex or pixel displacement: 顶点或像素位移是指在表面上创建细微变化的能力。这可以用于创建逼真的纹理和细节。<br />
Decal compatibility: 贴花兼容性是指着色器能够与贴花一起使用。贴花是可以附加到其他对象的 2D 图像。<br />
</p>
</div>
</div>
<div id="outline-container-org2b59b01" class="outline-6">
<h6 id="org2b59b01">Lit Tessellation Shader</h6>
</div>
<div id="outline-container-orgb1919f4" class="outline-6">
<h6 id="orgb1919f4">Silk Shader</h6>
<div class="outline-text-6" id="text-orgb1919f4">
<p>
Silk Shader 用于渲染各向异性纤维织物。可以使用 Silk shader 来创建丝绸、缎子、尼龙和涤纶等织物。丝绸和其他合成纤维通常比天然纤维更光滑，因为它们是作为单个光滑的细丝制成的。当这些纤维被编织在一起时，会产生具有各向异性镜面高光的织物。<br />
</p>

<p>
Silk Shader 是以 Fabric Master Stack 为基础创建的 ShaderGraph。位于 com.unity.render-pipelines.high-definition/Runtime/RenderPipelineResources/ShaderGraph/Silk.ShaderGraph<br />
</p>
</div>
</div>
<div id="outline-container-org4481e06" class="outline-6">
<h6 id="org4481e06">Terrain Lit Shader</h6>
<div class="outline-text-6" id="text-org4481e06">
<p>
Terrain Lit Shader 是 Lit Shader 的简单版本。Terrain Lit Material 可以使用 8 层 Terrain Layers。<br />
</p>
</div>
</div>
<div id="outline-container-org1bcaf76" class="outline-6">
<h6 id="org1bcaf76">Unlit Shader</h6>
</div>
</div>
<div id="outline-container-orgd673307" class="outline-5">
<h5 id="orgd673307">Material Type</h5>
<div class="outline-text-5" id="text-orgd673307">
<p>
Lit Shader, Lit Tessellation Shader 创建的材质包含了 Material Type 选项，可选类型如下：<br />
<img src="./URP/hdrp-lit-matType.jpg" alt="hdrp-lit-matType.jpg" /><br />
</p>

<ul class="org-ul">
<li>Subsurface Scattering  材质使用次表面散射工作流。次表面散射模拟了光线如何与半透明物体（如皮肤）相互作用并穿透它们。当光线穿透次表面散射材质的表面时，会在另一个点离开表面，光在离开表面之前会散射和模糊。<br /></li>
<li>Standard    材质使用金属工作流。<br /></li>
<li>Anisotropy  材质使用各向异性工作流。各向异性表面的亮点会随着您从不同角度查看材质而改变外观。使用此材质类型创建具有各向异性高光的材质。例如，拉丝金属或天鹅绒。<br /></li>
<li>Iridescence 材质使用彩虹工作流。虹彩表面会随着视角或照明角度的变化而逐渐改变颜色。使用此材质类型创建类似肥皂泡、虹彩金属或昆虫翅膀的材质。<br /></li>
<li>Specular Color  材质使用镜面颜色工作流。使用此材质类型创建具有有色镜面高光的材质。<br /></li>
<li>Translucent     材质使用半透明工作流。使用此材质类型和厚度贴图来模拟半透明物体，如植物叶子。与次表面散射材质不同，半透明材质不会模糊通过材质的光线。<br /></li>
</ul>

<p>
下图是 Iridescence、Translucency 以及 Subsurface Scattering 的对比:<br />
<img src="./URP/mat-type-compare.jpg" alt="mat-type-compare.jpg" /><br />
</p>
</div>

<div id="outline-container-orgab63903" class="outline-6">
<h6 id="orgab63903">Subsurface Scattering</h6>
<div class="outline-text-6" id="text-orgab63903">
<p>
次表面散射处理穿透表面并在表面下方区域内行进的光线。使用次表面散射可以使有机材料（如皮肤）看起来光滑自然，而不是粗糙且类似塑料。HDRP 使用屏幕空间模糊技术实现次表面散射。<br />
</p>

<p>
次表面散射还处理从背面穿透物体的光线，并使那些物体看起来透明。对于某些类型的对象，屏幕空间模糊效果可能不会产生很大的视觉差异。因此，HDRP 实现了两种材质类型：<br />
</p>
<ul class="org-ul">
<li>次表面散射 实现了屏幕空间模糊效果和透射（可以禁用后者）。 次表面散射材质类型适用于需要屏幕空间模糊效果的对象，例如皮肤。<br /></li>
<li>半透明仅模拟透射。 半透明材质类型适用于不需要屏幕空间模糊效果的对象，例如植物叶子。<br /></li>
</ul>

<p>
HDRP 将大部分 subsurface scattering 设置都存储在了 Diffusion Profile 中。在一个视角下，HDRP 同时支持多达 15 个自定义的 Diffusion Profile。<br />
</p>
</div>
</div>

<div id="outline-container-org7448c41" class="outline-6">
<h6 id="org7448c41">Compute Thickness</h6>
<div class="outline-text-6" id="text-org7448c41">
<p>
HDRP 可以使用光路来使透明或不透明的材料在网格内部的较大区域内看起来更致密。这被称为 Compute Thickness(计算厚度)。<br />
Compute Thickness 非常适用于透明材质（透明材质会使用次表面散射或折射，这些效果会使用到 Thickness）。你也可以在平面几何（如草和叶子）上使用它。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org0bc9cf0" class="outline-5">
<h5 id="org0bc9cf0">Master Stacks</h5>
<div class="outline-text-5" id="text-org0bc9cf0">
<p>
<a href="./UnityShaderAndEffectCookbook.html#orgc8e7ea5">Master Stack</a><br />
</p>
</div>

<div id="outline-container-org287979b" class="outline-6">
<h6 id="org287979b">Decal Master Stack</h6>
<div class="outline-text-6" id="text-org287979b">
<p>
使用 Decal Master Stack 可以创建投影或放置到场景中的贴花。Decal Master Stack 材质类型类似于标准 Decal Shader，但不能使用此版本来创建投影在透明材料上的贴花。<br />
</p>
</div>
</div>
<div id="outline-container-org79a7299" class="outline-6">
<h6 id="org79a7299">Eye Master Stack</h6>
<div class="outline-text-6" id="text-org79a7299">
<p>
使用 Eye Master Stack 可以实现自定义的基于物理的眼睛材质。它模拟了两层材质，第一层描述了角膜和表面上的液体，第二层描述了通过第一层可见的巩膜和虹膜。它支持各种效果，如角膜折射、焦散(caustics)、瞳孔调节、 角膜缘变黑(limbal darkening) 和 次表面散射。<br />
</p>

<p>
Corneal refraction: Corneal refraction 是指光线在通过角膜时发生折射。这会导致眼睛看起来明亮而清晰。<br />
Caustics: Caustics 是指光线在表面上发生反射或折射时产生的明亮图案。这可以发生在眼睛的虹膜上，并导致眼睛看起来有光泽。<br />
Pupil dilation: Pupil dilation 是指瞳孔大小的变化。瞳孔会在光线很强时变小，在光线很弱时变大。这可以帮助眼睛调节光线量。<br />
Limbal darkening: Limbal darkening 是指眼睛周围的区域比其他区域更暗。这是一个正常的生理现象，它可以帮助眼睛看起来更真实。<br />
Subsurface scattering: Subsurface scattering 是指光线在材料内部散射。这可以发生在皮肤和眼睛中，并导致它们看起来有光泽和柔软。<br />
</p>
</div>
</div>
<div id="outline-container-orgf4bd8c8" class="outline-6">
<h6 id="orgf4bd8c8">Fabric Master Stack</h6>
<div class="outline-text-6" id="text-orgf4bd8c8">
<p>
使用 Fabric Master Stack 可以创建各种各类型的纤维织物。其以棉花羊毛或各向异性的丝为基础，并支持各种附加效果如次表面散射来创建真实感纤维织物。<br />
</p>
</div>
</div>
<div id="outline-container-org1edadc2" class="outline-6">
<h6 id="org1edadc2">Fog Volume Master Stack</h6>
<div class="outline-text-6" id="text-org1edadc2">
<p>
使用 Fog Volume Master Stack 可以创建各种体积烟雾效果。<br />
</p>
</div>
</div>
<div id="outline-container-orge9a09c4" class="outline-6">
<h6 id="orge9a09c4">Fullscreen Master Stack</h6>
<div class="outline-text-6" id="text-orge9a09c4">
<p>
使用 Fullscreen Master Stack 可以创建各种全屏后处理效果。<br />
</p>
</div>
</div>
<div id="outline-container-org10e2eb8" class="outline-6">
<h6 id="org10e2eb8">Hair Master Stack</h6>
<div class="outline-text-6" id="text-org10e2eb8">
<p>
使用 Hair Master Stack 可以创建真实的头发和毛。为了创建逼真的头发效果，hair shader 使用了称为 hair cards 的 layers。每个 hair card 表示头发的不同部分。如果你使用半透明的 hair cards，你需要对他们进行手动排序，使得从任意视角这些 hair cards 的排序都是从后到前。<br />
</p>
</div>
</div>

<div id="outline-container-org00a8a80" class="outline-6">
<h6 id="org00a8a80">Lit Master Stack</h6>
<div class="outline-text-6" id="text-org00a8a80">
<p>
使用 Lit Master Stack 可以渲染各种基于物理的材质。其支持各种效果，例如：次表面散射，各向异性，彩虹色，镜面颜色，以及半透明。<br />
</p>
</div>
</div>

<div id="outline-container-org0cf831e" class="outline-6">
<h6 id="org0cf831e">StackLit Master Stack</h6>
<div class="outline-text-6" id="text-org0cf831e">
<p>
StackLit Master Stack 可以渲染比 Lit Master Stack 更复杂的材质。它包含 Lit Shader 中所有可用的功能，某些方面甚至提供了更高级或更高质量的版本。例如，它使用更高级的镜面遮蔽形式，并为区域光计算各向异性反射（Lit shader 只为其他类型光源技术各向异性反射）。它还考虑了两个垂直堆叠的物理层之间的光相互作用，以及外观更复杂的通用基层。<br />
</p>
</div>
</div>
<div id="outline-container-org8dbaea4" class="outline-6">
<h6 id="org8dbaea4">Unlit Master Stack</h6>
<div class="outline-text-6" id="text-org8dbaea4">
<p>
使用 Unlit Master Stack 创建不受光影响的 shader。<br />
</p>
</div>
</div>
<div id="outline-container-org4fda4a4" class="outline-6">
<h6 id="org4fda4a4">Canvas Master Stack</h6>
<div class="outline-text-6" id="text-org4fda4a4">
<p>
使用 Unlit Master Stack 为 UGUI UI 元素创建 shader。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2176401" class="outline-4">
<h4 id="org2176401">Lighting</h4>
<div class="outline-text-4" id="text-org2176401">
</div>
<div id="outline-container-org65d27a1" class="outline-5">
<h5 id="org65d27a1">Light</h5>
<div class="outline-text-5" id="text-org65d27a1">
</div>
<div id="outline-container-org9daa567" class="outline-6">
<h6 id="org9daa567">Physical Light Units and Intensities</h6>
<div class="outline-text-6" id="text-org9daa567">
<p>
HDRP 使用物理光照单位 (Plysical Light Units PLU) 进行照明。这些单位基于现实生活中的光照测量，如在灯泡包装或摄影光度计上看到的。注意，当 lights 使用物理光照单位时，为了让其正确工作，需要遵守 HDRP 单位约定（1 个 Unity 单位等于 1 米）。<br />
</p>


<div id="orgd1466f9" class="figure">
<p><img src="./PhysicallyBasedRendering/2020_06_08_radiomery_photometric.jpg" alt="2020_06_08_radiomery_photometric.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://google.github.io/filament/Filament.html#lighting/">https://google.github.io/filament/Filament.html#lighting/</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6efab7b"></a>Lighting Terms<br />
<ul class="org-ul">
<li><a id="orga500ac1"></a>luminosity function<br />
<div class="outline-text-8" id="text-orga500ac1">
<p>
<a href="./PhysicallyBasedRendering.html#orgf0b8f14">Radiometry-luminosity function</a><br />
</p>


<div id="orgc080310" class="figure">
<p><img src="./PhysicallyBasedRendering/cie-rgb-cie-XYZ.jpg" alt="cie-rgb-cie-XYZ.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="org0b163f4"></a>luminous flux<br />
<div class="outline-text-8" id="text-org0b163f4">

<div id="org3591aed" class="figure">
<p><img src="./URP/GlossaryLighting-luminous-flux.png" alt="GlossaryLighting-luminous-flux.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgf5c8726"></a>luminous intensity<br />
<div class="outline-text-8" id="text-orgf5c8726">

<div id="org44932f7" class="figure">
<p><img src="./URP/GlossaryLighting-luminous-intensity.png" alt="GlossaryLighting-luminous-intensity.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgdb05807"></a>illuminance &amp; luminance<br />
<div class="outline-text-8" id="text-orgdb05807">

<div id="orgb2135f4" class="figure">
<p><img src="./URP/GlossaryLighting-illumination-luminance.png" alt="GlossaryLighting-illumination-luminance.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="org8ffc7dd"></a>punctual lights<br />
<div class="outline-text-8" id="text-org8ffc7dd">
<p>
从单个点发出光的光源被称为精确光源。HDRP 中的 Spot Light 和 Point Light 都是 punctual lights。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org0b7ff4c"></a>Units<br />
<div class="outline-text-7" id="text-org0b7ff4c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">单位</th>
<th scope="col" class="org-left">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Lumen</td>
<td class="org-left">PointLight SpotLight AreaLight</td>
</tr>

<tr>
<td class="org-left">Candela</td>
<td class="org-left">PointLight SpotLight</td>
</tr>

<tr>
<td class="org-left">Lux</td>
<td class="org-left">DirectionalLight PointLight SpotLight</td>
</tr>

<tr>
<td class="org-left">Nits</td>
<td class="org-left">AreaLight</td>
</tr>

<tr>
<td class="org-left">EV100</td>
<td class="org-left">PointLight SpotLight AreaLight</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="org1355342"></a>Lumen<br />
<div class="outline-text-8" id="text-org1355342">
<p>
luminous flux 的单位。luminous flux 表示单位时间的能量，即功率。<br />
</p>
</div>
</li>
<li><a id="org42072fe"></a>Candela<br />
<div class="outline-text-8" id="text-org42072fe">
<p>
luminous intensity 的单位。luminous intensity 表示单位立体角的功率。<br />
</p>
</div>
</li>
<li><a id="org29cee11"></a>Lux  (lumen per square meter)<br />
<div class="outline-text-8" id="text-org29cee11">
<p>
illuminance 的单位。illuminance 表示单位面积的功率。<br />
</p>
</div>
</li>
<li><a id="orgb52e23d"></a>Nits (candela per square meter)<br />
<div class="outline-text-8" id="text-orgb52e23d">
<p>
luminance 的单位。luminance 表示单位面积单位立体角的功率。<br />
</p>
</div>
</li>
<li><a id="org1bc54f5"></a>Exposure value<br />
<div class="outline-text-8" id="text-org1bc54f5">
<p>
在摄影中，曝光值（Exposure Value，EV）代表能够给出同样曝光的所有相机光圈快门组合。<br />
EV100 是指在 ISO 100 感光度下，使用 f/1.4 光圈和 1/125 秒快门速度所获得的曝光值。EV100 是标准曝光，也就是说，在光线充足的环境中，使用 EV100 可以获得正常曝光的照片。<br />
</p>

<p>
曝光值计算公式如下：<br />
EVs = log2(N^2/t)<br />
</p>

<p>
EV100 计算公式如下：<br />
EV100 = EVs - log2(S/100)<br />
从上面公式可以看出，当 S=100 时，EV100 = EVs<br />
</p>

<p>
从上面公式可以推导出如下公式：<br />
EVs = EV100 + log2(S/100)<br />
EV100 = EVs - log2(S/100)<br />
EV100 = log2(N^2/t) - log2(S/100)<br />
EV100 = log2((N^2/t) / (S/100)) = log2(N^2/t/100/S)<br />
上面公式就是 Unity HDRP 中 PhysicalCamera.hlsl 中 ComputeEV100 函数计算 EV100 所使用的方法。<br />
</p>

<p>
变量说明：<br />
</p>
<ul class="org-ul">
<li>N 是光圈(f 值越小，光圈越大);<br /></li>
<li>t 是曝光时间(快门)，单位为秒;<br /></li>
<li>其中 S 是感光度，即 ISO<br /></li>
</ul>

<p>
HDRP 灯可以使用 EV100，即 ISO 100 胶片的 EV。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge896c83"></a>EV &amp; Light(Lux)<br />
<div class="outline-text-9" id="text-orge896c83">
<p>
在给定照明条件下所采用的 F 值与曝光时间由下式给出:<br />
N^2/t = LS/K<br />
EVs = log2(LS/K)<br />
</p>

<p>
同样也可以由入射式测光结果计算拍摄参数:<br />
N^2/t = ES/C<br />
EVs = log2(ES/C)<br />
</p>

<p>
变量说明：<br />
</p>
<ul class="org-ul">
<li>L 是场景平均辉度(就是平均亮度)<br /></li>
<li>K 是反射式测光表校正常数<br /></li>
<li>E 是照度<br /></li>
<li>C 是入射式测光表校正常数<br /></li>
</ul>

<p>
不同厂商所选用的反射式测光表校正常数之间有微小的差别。一个普遍的选择是 12.5（佳能，尼康和世光）。在感光度 100 时，曝光值与亮度的关系为（推导参考下面给出的链接原文）：<br />
L = 2^(EVs-3)<br />
</p>

<p>
入射式测光表的情况比反射式测光表要复杂得多，因为校正常数 C 与传感器类型有关。有两种传感器很常见：平面型（余弦响应）和半球型（心形响应）。<br />
用平面型传感器测量照度时，C 的典型值是 250，而照度的单位是勒克斯（lux）。在 C = 250 时，照度与感光度 100 下的曝光值的关系为（推导参考下面给出的链接原文）:<br />
E = 2.5*2^(EVs)<br />
</p>

<p>
尽管（用平面型传感器）测量得到的照度可以用以指示对于一个平面物体的曝光，这一办法对于通常的场景却不是那么有用，因为这些场景中的许多元素都不是平的，其相对于相机的朝向也各不相同。半球型传感器在测量影像曝光时更为实用。对于半球型传感器，C值通常在 320（美能达）和 340（世光）之间。如果对“照度”的定义不那么严格的话，半球型传感器所测得的结果可以说是指示了“场景照度”。<br />
</p>

<ul class="org-ul">
<li>EVMeter-理论篇 <a href="https://www.emoe.xyz/evmeter-theory/">https://www.emoe.xyz/evmeter-theory/</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgdf53f90"></a>感光度 ISO<br />
<div class="outline-text-9" id="text-orgdf53f90">
<ul class="org-ul">
<li><a href="https://www.adobe.com/creativecloud/photography/hub/guides/photography-basics-iso-speed.html">https://www.adobe.com/creativecloud/photography/hub/guides/photography-basics-iso-speed.html</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orge50f282"></a>What is ISO?<br />
<div class="outline-text-10" id="text-orge50f282">
<p>
ISO 是相机对光的敏感度，无论是胶片还是数码传感器。最简单的说法是，它将在使照片变亮或变暗方面发挥作用。ISO 与光圈和快门速度一起构成摄影三个基本支柱。<br />
</p>
</div>
</li>
<li><a id="org851b0f8"></a>Common ISO speeds and what they mean<br />
<div class="outline-text-10" id="text-org851b0f8">
<p>
不同的 ISO 设置以数字表示。这些数字由国际标准化组织 (ISO) 设定（这就是 ISO 表示感光度的由来）。<br />
尽管每台相机都提供不同的 ISO 值范围，但无论型号如何，您都会遇到常见的设置集。通常将最低 ISO 设置称为“base ISO”。以下是从低到高 ISO 的典型标准集：<br />
</p>
<ul class="org-ul">
<li>100<br /></li>
<li>200<br /></li>
<li>400<br /></li>
<li>800<br /></li>
<li>1600<br /></li>
<li>3200<br /></li>
<li>6400<br /></li>
</ul>
<p>
注意 ISO 按倍数增加，其直接与亮度级别相关。这意味着 ISO 800 将为照片添加两倍于 ISO 400 的亮度。<br />
</p>
</div>
</li>
<li><a id="orga90f948"></a>How does ISO affect my photo?<br />
<div class="outline-text-10" id="text-orga90f948">
<p>
ISO 越低，传入的光量越少，但图像质量越高。相反，当提高 ISO 时，将获得更多的光线。但是，增加光线太多可能会显示出很多颗粒，也称为“噪点”。<br />
与管理光圈和快门速度一样，设置 ISO 速度始终是保持足够光线而不牺牲质量的微妙平衡。<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org20c0553"></a>Exposure compensation<br />
<div class="outline-text-9" id="text-org20c0553">
<p>
在光照度均匀一致的场合，拍摄该照明下的物体，无论其黑白，达到准确的曝光所用的光圈快门感光度是一样的。<br />
</p>

<p>
相机的内置测光表测光是测量通过镜头的被摄景物入射光线。你会发现，在均匀一致的照明下，测量黑色物体和测量白色物体，所得曝光值不同。黑色反光少，白色发光多。不要认为相机能辨别物体的反光率，测光表能做的仅是测量被摄物的反射光线量。当看到黑色物体，反光较少，相机会误认为环境照度低，提高曝光；若看到白色物体，相机会认为环境光照度强，需压低曝光。白色还原成中灰是曝光不足，黑色还原成中灰是曝光过度。<br />
</p>

<p>
为纠正相机的教条主义错误，在对深色暗调物体测光时，需减少曝光；反之则增加曝光。摄影上称之为白加黑减。这就是曝光补偿控件存在的意义。<br />
</p>

<ul class="org-ul">
<li>曝光补偿的用途？ <a href="https://www.zhihu.com/question/19730015">https://www.zhihu.com/question/19730015</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgda57cbf"></a>18% Gray<br />
<div class="outline-text-9" id="text-orgda57cbf">
<p>
人对世界感知不是线性的而是对数的。这里不是单指光通量，还包括对重量、数量、音量、时间等。<br />
达到准确的曝光的期望是：让曝光正好处于“某种”平衡亮部和暗部的正中间并且尽可能多的记录细节。<br />
</p>

<p>
50%反射率的灰色在灰阶渐变中几乎偏向白色了，完全不在中间，会导致暗部细节不够。而 18%反射率的灰色，在人眼里正好处于黑白渐变正中间。<br />
</p>

<p>
在摄影中，通常将中灰色（18% Grey）作为参考标准。如果图像中的中灰色区域看起来正常，则说明曝光是正确的。<br />
如果图像中的中灰色区域看起来过暗，则说明曝光过低。可以通过增加光圈或减小快门速度来提高曝光。<br />
如果图像中的中灰色区域看起来过亮，则说明曝光过高。可以通过减小光圈或增加快门速度来降低曝光。<br />
</p>

<ul class="org-ul">
<li>18%灰板的原理是什么？ <a href="https://www.zhihu.com/question/19865979">https://www.zhihu.com/question/19865979</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org8a36e75"></a>Light intensities<br />
<ul class="org-ul">
<li><a id="orgdd1075f"></a>Natural<br />
<div class="outline-text-8" id="text-orgdd1075f">
<p>
不同条件下自然光源的光测量：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Illuminance (lux)</th>
<th scope="col" class="org-left">Natural light level</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">120 000</td>
<td class="org-left">Very bright sunlight.</td>
<td class="org-left">非常明亮的阳光</td>
</tr>

<tr>
<td class="org-left">110 000</td>
<td class="org-left">Bright sunlight.</td>
<td class="org-left">明亮的阳光</td>
</tr>

<tr>
<td class="org-left">20 000</td>
<td class="org-left">Blue sky at midday.</td>
<td class="org-left">中午的蓝天</td>
</tr>

<tr>
<td class="org-left">1 000 - 2 000</td>
<td class="org-left">Overcast sky at midday.</td>
<td class="org-left">中午阴云密布的天空</td>
</tr>

<tr>
<td class="org-left">&lt; 1</td>
<td class="org-left">Moonlight with a clear night sky.</td>
<td class="org-left">晴朗夜空中的月光</td>
</tr>

<tr>
<td class="org-left">0.002</td>
<td class="org-left">Starry night without moonlight. Includes airglow.</td>
<td class="org-left">没有月光的繁星之夜。包括大气光</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org1543794"></a>Artificial<br />
<div class="outline-text-8" id="text-org1543794">
<p>
人造光源的近似光测量：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Luminous flux (lumen)</th>
<th scope="col" class="org-left">Source</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">12.57</td>
<td class="org-left">Candle light.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">烛光</td>
</tr>

<tr>
<td class="org-left">&lt; 100</td>
<td class="org-left">Small decorative light, such as a small LED lamp.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">小装饰灯，如小型 LED 灯</td>
</tr>

<tr>
<td class="org-left">200 - 300</td>
<td class="org-left">Decorative lamp, such as a lamp that does not provide the main lighting for a bright room.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">装饰灯，例如不是为明亮房间提供主照明的灯</td>
</tr>

<tr>
<td class="org-left">400 - 800</td>
<td class="org-left">Ceiling lamp for a regular room.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">普通房间的吸顶灯</td>
</tr>

<tr>
<td class="org-left">800 - 1 200</td>
<td class="org-left">Ceiling lamp for a large brightly lit room.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">大型明亮房间的吸顶灯</td>
</tr>

<tr>
<td class="org-left">1 000 - 40 000</td>
<td class="org-left">Bright street light.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">明亮的路灯</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org4f56315"></a>Indoor<br />
<div class="outline-text-8" id="text-org4f56315">
<p>
在设计功能性房间和建筑物时，建筑师使用以下近似值作为参考：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Illuminance (lux)</th>
<th scope="col" class="org-left">Room type</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">150 - 300</td>
<td class="org-left">Bedroom.</td>
<td class="org-left">卧室</td>
</tr>

<tr>
<td class="org-left">300 - 500</td>
<td class="org-left">Classroom.</td>
<td class="org-left">教室</td>
</tr>

<tr>
<td class="org-left">300 - 750</td>
<td class="org-left">Kitchen.</td>
<td class="org-left">厨房</td>
</tr>

<tr>
<td class="org-left">300 - 500</td>
<td class="org-left">Kitchen Counter or Office.</td>
<td class="org-left">厨房柜台或办公室</td>
</tr>

<tr>
<td class="org-left">100 - 300</td>
<td class="org-left">Bathroom.</td>
<td class="org-left">浴室</td>
</tr>

<tr>
<td class="org-left">750 - 1000</td>
<td class="org-left">Supermarket.</td>
<td class="org-left">超市</td>
</tr>

<tr>
<td class="org-left">30</td>
<td class="org-left">City street at night</td>
<td class="org-left">夜晚的城市街道</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org39c017f"></a>Lighting and exposure diagram<br />
<div class="outline-text-8" id="text-org39c017f">
<p>
以下备忘单包含了现实世界中常见光源的色温值和光强度。此外还包含不同光照场景的曝光值。<br />
<img src="./URP/LightCheatSheet.png" alt="LightCheatSheet.png" /><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org515d21e" class="outline-6">
<h6 id="org515d21e">Exposure</h6>
<div class="outline-text-6" id="text-org515d21e">
<p>
要使用基于物理的光照和材质，需要正确设置场景曝光。HDRP 包括几种曝光计算方法，适用于大多数使用场景。HDRP 以 EV100 表示其使用的所有曝光值。<br />
</p>

<p>
HDRP 包含如下几种计算曝光的方法：<br />
</p>
<ul class="org-ul">
<li>Fixed  你可以手动设置场景曝光<br /></li>
<li>Automatic  根据屏幕内容自动设置曝光<br /></li>
<li>Automatic Histogram  使用 Histogram 控制来扩展自动曝光<br /></li>
<li>Curve Mapping    将当前场景的曝光映射到自定义的曲线<br /></li>
<li>Use Physical Camera  使用当前的物理摄像机设置来设置场景的曝光<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org5f644c7"></a>ConvertEV100ToExposure and GetCurrentExposureMultiplier<br />
<div class="outline-text-7" id="text-org5f644c7">
<p>
无论使用那种算法计算曝光，在写入最终的 _OutputTexture 时，都使用 ConvertEV100ToExposure 来将 EV100 转化为 Exposure（这里 Exposure 并不是 EV 值，而是 1.0/maxLuminance）。 在 Lit.shader 中使用该值来缩放光照计算后的结果。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org9c05bab"></a>ConvertEV100ToExposure<br />
<div class="outline-text-8" id="text-org9c05bab">
<p>
ConvertEV100ToExposure 的计算原理如下，其将 EV100 转化<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// exposureScale &#20026; LensImperfectionExposureScale</span>
<span style="color: #2aa1ae; background-color: #292e34;">// float s_LensAttenuation = 0.65f</span>
<span style="color: #2aa1ae; background-color: #292e34;">// exposureScale = LensImperfectionExposureScale = (78.0f / (100.0f * s_LensAttenuation)) = 1.2</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">ConvertEV100ToExposure</span>(<span style="color: #ce537a; font-weight: bold;">float</span> EV100, <span style="color: #ce537a; font-weight: bold;">float</span> exposureScale)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Compute the maximum luminance possible with H_sbs sensitivity</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// maxLum = 78 / ( S * q ) * N^2 / t</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//        = 78 / ( S * q ) * 2^ EV_100</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//        = 78 / (100 * s_LensAttenuation) * 2^ EV_100</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//        = exposureScale * 2^ EV</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Reference: http://en.wikipedia.org/wiki/Film_speed</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> maxLuminance = exposureScale * <span style="color: #4f97d7;">pow</span>(2.0, EV100);
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0 / maxLuminance;
}
</pre>
</div>
<p>
推导可以参考如下内容：<br />
<img src="./URP/ev100ToExposure.jpg" alt="ev100ToExposure.jpg" /><br />
</p>
<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Film_speed">http://en.wikipedia.org/wiki/Film_speed</a><br /></li>
</ul>

<p>
假如我们将 EV100 设置为 14（即晴天正午的标准曝光），则 maxLuminance=1.2*2^14=19660.8 最终得到的 Exposure 为 1/19660.8=5.086*10^-5。<br />
</p>
</div>
</li>

<li><a id="org18b8896"></a>GetCurrentExposureMultiplier<br />
<div class="outline-text-8" id="text-org18b8896">
<p>
场景中物体在执行完光照计算后，会应用曝光，Lit.shader 相关处理代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Lit.shader</span>

LightLoopOutput lightLoopOutput;
LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);
<span style="color: #ce537a; font-weight: bold;">float3</span> diffuseLighting = lightLoopOutput.diffuseLighting;
<span style="color: #ce537a; font-weight: bold;">float3</span> specularLighting = lightLoopOutput.specularLighting;

diffuseLighting *= GetCurrentExposureMultiplier();
specularLighting *= GetCurrentExposureMultiplier();

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetCurrentExposureMultiplier</span>()
{
<span style="color: #bc6ec5;">#if</span> SHADEROPTIONS_PRE_EXPOSITION
    <span style="color: #2aa1ae; background-color: #292e34;">// _ProbeExposureScale is a scale used to perform range compression to avoid saturation of the content of the probes. It is 1.0 if we are not rendering probes.</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">LOAD_TEXTURE2D</span>(<span style="color: #7590db;">_ExposureTexture</span>, <span style="color: #ce537a; font-weight: bold;">int2</span>(0, 0)).x * <span style="color: #7590db;">_ProbeExposureScale</span>;
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_ProbeExposureScale</span>;
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
<p>
假设场景灯光为 130000 lux，物体反射率为 18%，则最终应用过曝光后的颜色为 130000*0.18*5.086*10^5 = 0.91548<br />
假设物体反射率为 100%，则最终应用过曝光后的颜色为 130000*5.086*10^5 = 6.6118<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org1087407"></a>Fixed<br />
<div class="outline-text-7" id="text-org1087407">
<p>
这是用于计算曝光的最简单，但最不灵活的方法。如果场景具有相对均匀的曝光或想要拍摄静态区域的图像时，它非常有用。还可以使用 local Volumes 在场景中的各种固定曝光值之间进行混合。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Exposure.compute</span>
[numthreads(1,1,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">KFixedExposure</span>(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// ParamEV100 &#23601;&#26159;Volume &#20013;&#35774;&#32622;&#30340; FixedExposure&#20540;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> ev100 = ParamEV100;
    <span style="color: #2aa1ae; background-color: #292e34;">// ParamExposureCompensation &#23601;&#26159;Volume&#20013;&#35774;&#32622;&#30340; Exposure Compensation &#20540;</span>
    ev100 -= ParamExposureCompensation;
    <span style="color: #7590db;">_OutputTexture</span>[dispatchThreadId] = <span style="color: #ce537a; font-weight: bold;">float2</span>(ConvertEV100ToExposure(ev100, LensImperfectionExposureScale), ev100);
}

</pre>
</div>
<p>
上面算法写入 _OutputTexture 的值为 1.0/maxLuminance, 在 Lit.shader 中使用该值来缩放光照计算后的结果。<br />
</p>
</div>
</li>
<li><a id="org11d91b1"></a>Automatic<br />
<ul class="org-ul">
<li><a id="orgdb7d0f6"></a>Automatic<br />
<div class="outline-text-8" id="text-orgdb7d0f6">
<p>
人眼在非常黑暗和非常明亮的区域中都能感知光线。然而，在任何单一时刻，眼睛只能感觉到总体范围的大约百万分之一的对比度。通过调整和重新定义黑色，眼睛可以良好感知多个亮度级别。<br />
</p>

<p>
Automatic 模式根据屏幕上的亮度级别范围来动态调整曝光。这种调整会逐渐进行，也就是说，当从黑暗的区域中出来时，用户可能会因明亮的室外光线而短暂感到目眩。同样，当从明亮的区域移动到黑暗的区域时，摄像机需要一些时间适应。<br />
</p>

<p>
下面列出重要的设置选项：<br />
</p>
<ul class="org-ul">
<li>Target Mid Gray: 设置自动曝光使用的所需中间灰度级（即，自动曝光系统将平均场景亮度映射到的灰度值）。 注意，HDRP 中使用的镜头模型不是完美镜头，因此它无法精确地映射到选定值。<br /></li>
</ul>

<p>
物体的亮度与色彩是由物体对光线的反射率来决定的。例如纯黑色的放射率是 0，纯白色的反射率是 100%，处于中间的灰度的反射率是 18%，这就是 18% 中间灰度。<br />
正确的曝光就是指具有一定反射率的物体在最终的图像中被还原到了其相应的灰度级，如反射率为 18% 的物体，在图像中被还原到了中间灰。<br />
</p>

<p>
HDRP 中 AutoExposure，的实现在 Exposure.compute 中。分一下三个 Pass：<br />
</p>
<ul class="org-ul">
<li>kPrePass     读取 ColorRT，计算每个像素的 luminance，再由 luminance 计算 EV100, 最终写入_OutputTexture 的为(EV100, weight)<br /></li>
<li>kReduction   计算出所有像素加起来平均的 EV100 的中间结果<br /></li>
<li>kReduction   计算出所有像素加起来平均的 EV100，根据平均 EV100 计算 Exposure(这里 Exposure 是 1/maxLuminance)<br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-shader">[numthreads(8,8,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">KPrePass</span>(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// For XR, interleave single-pass views in a checkerboard pattern</span>
    UNITY_XR_ASSIGN_VIEW_INDEX((dispatchThreadId.x + dispatchThreadId.y) % <span style="color: #7590db;">_XRViewCount</span>)

    PositionInputs posInputs = GetPositionInput(<span style="color: #ce537a; font-weight: bold;">float2</span>(dispatchThreadId), rcp(PREPASS_TEX_SIZE), uint2(8u, 8u));
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv = ClampAndScaleUVForBilinear(posInputs.positionNDC);
    <span style="color: #ce537a; font-weight: bold;">float</span> luma = SampleLuminance(uv);

    <span style="color: #ce537a; font-weight: bold;">float</span> weight = WeightSample(dispatchThreadId, PREPASS_TEX_SIZE.xx, luma);

    <span style="color: #2aa1ae; background-color: #292e34;">// MeterCalibrationConstant &#20026; s_LightMeterCalibrationConstant = 12.5f</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> logLuma = ComputeEV100FromAvgLuminance(<span style="color: #4f97d7;">max</span>(luma, 1e-4), MeterCalibrationConstant);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span>
    <span style="color: #7590db;">_OutputTexture</span>[posInputs.positionSS] = <span style="color: #ce537a; font-weight: bold;">float2</span>(logLuma, weight);
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">ComputeEV100FromAvgLuminance</span>(<span style="color: #ce537a; font-weight: bold;">float</span> avgLuminance, <span style="color: #ce537a; font-weight: bold;">float</span> calibrationConstant)
{
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> K = calibrationConstant;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">log2</span>(avgLuminance * 100.0 / K);
}
</pre>
</div>

<p>
MeterCalibrationConstant 为 s_LightMeterCalibrationConstant = 12.5f，其为反射式测光表校正常数。包括 ComputeEV100FromAvgLuminance 的计算原理等详细信息可以参考 <a href="#orge896c83">EV &amp; Light(Lux)</a><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Automatic</span>
<span style="color: #ce537a; font-weight: bold;">float</span> exposure = AdaptExposure(avgLuminance - ParamExposureCompensation);
exposure = <span style="color: #4f97d7;">clamp</span>(exposure, ParamExposureLimitMin, ParamExposureLimitMax);
<span style="color: #7590db;">_OutputTexture</span>[groupId.xy] = <span style="color: #ce537a; font-weight: bold;">float2</span>(ConvertEV100ToExposure(exposure, LensImperfectionExposureScale), exposure);
<span style="color: #4f97d7; font-weight: bold;">break</span>;
</pre>
</div>


<ul class="org-ul">
<li>自动曝光的原理 <a href="https://zhuanlan.zhihu.com/p/33462189">https://zhuanlan.zhihu.com/p/33462189</a> 有道云备份<br /></li>
</ul>
</div>
</li>
<li><a id="orgea1da5e"></a>Automatic Histogram<br />
<div class="outline-text-8" id="text-orgea1da5e">
<p>
自动直方图 (Automatic Histogram) 是自动模式的扩展。为了获得更稳定的曝光结果，此模式将计算图像的直方图，从而可以从曝光计算中排除图像的某些部分。这可用于丢弃屏幕上极亮或极暗的区域。<br />
</p>

<p>
曝光直方图是相机对于不同亮度的像素数量分布的直观表现，是判断画面曝光的参考图表。横坐标表示画面的明暗度，从左到右表示纯黑色到纯白色，纵坐标表示不同亮度值的像素数量。<br />
</p>

<ul class="org-ul">
<li>相机的曝光直方图 <a href="https://baijiahao.baidu.com/s?id=1627800369557192053&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1627800369557192053&amp;wfr=spider&amp;for=pc</a> 有道云备份<br /></li>
<li>學習看直方圖（Histogram） 助你判斷準確的曝光 <a href="https://www.canon.com.hk/tc/club/article/itemDetail.do?itemId=10322&amp;page=1">https://www.canon.com.hk/tc/club/article/itemDetail.do?itemId=10322&amp;page=1</a><br /></li>
</ul>

<p>
下面列出重要的设置选项：<br />
</p>
<ul class="org-ul">
<li>Histogram Percentages:  使用此字段可选择要用于自动曝光计算的直方图范围。此字段的值为百分数。这意味着，例如，如果将低百分位数设置为 X，在一个像素的强度低于屏幕上所有像素中的 (100-X)% 的情况下，HDRP 将从曝光计算中丢弃该像素。同样，如果将高百分位数设置为 Y，则意味着在一个像素的强度高于 Y% 的情况下，HDRP 会从曝光计算中丢弃该像素。这使得曝光计算可以丢弃阴影和高亮区域中不必要的边缘值。<br /></li>
<li>Use Curve Remapping:  指定是否在此曝光模式之上应用曲线映射。<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orga573686"></a>自动曝光的原理<br />
<div class="outline-text-9" id="text-orga573686">
<p>
下面 python 代码展示了基于直方图的自动曝光算法:<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">import</span> cv2
<span style="color: #4f97d7; font-weight: bold;">import</span> numpy <span style="color: #4f97d7; font-weight: bold;">as</span> np

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">auto_exposure</span>(image):
  <span style="color: #9f8766;">"""</span>
<span style="color: #9f8766;">  &#22522;&#20110;&#30452;&#26041;&#22270;&#30340;&#33258;&#21160;&#26333;&#20809;&#31639;&#27861;</span>
<span style="color: #9f8766;">  Args: image: &#36755;&#20837;&#22270;&#20687;</span>
<span style="color: #9f8766;">  Returns: &#26333;&#20809;&#21518;&#30340;&#22270;&#20687;</span>
<span style="color: #9f8766;">  """</span>

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#30452;&#26041;&#22270;</span>
  <span style="color: #7590db;">hist</span> = cv2.calcHist([image], [0], <span style="color: #a45bad;">None</span>, [256], [0, 255])

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#24179;&#22343;&#20142;&#24230;</span>
  <span style="color: #7590db;">mean</span> = hist.<span style="color: #4f97d7;">sum</span>() / hist.size

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#30830;&#23450;&#26333;&#20809;&#20540;</span>
  <span style="color: #7590db;">exposure</span> = 1.0/mean;

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#24212;&#29992;&#26333;&#20809;&#20540;</span>
  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">pixel = abs(pixel*alpha + beta)</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> cv2.convertScaleAbs(image, alpha=exposure, beta=0)

<span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #4f97d7;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#21152;&#36733;&#22270;&#20687;</span>
  <span style="color: #7590db;">image</span> = cv2.imread(<span style="color: #2d9574;">"image.jpg"</span>)

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#24212;&#29992;&#33258;&#21160;&#26333;&#20809;</span>
  <span style="color: #7590db;">exposed_image</span> = auto_exposure(image)

  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">&#26174;&#31034;&#22270;&#20687;</span>
  cv2.imshow(<span style="color: #2d9574;">"Original"</span>, image)
  cv2.imshow(<span style="color: #2d9574;">"Exposed"</span>, exposed_image)
  cv2.waitKey(0)
</pre>
</div>

<p>
HDR 空间下的颜色范围是无限的，我们需要缩小这个范围，毕竟场景屏幕上的颜色大部分都是一个比较”合理的“可控的值。然后对这个颜色值求亮度，量化这个亮度，使它由连续变离散，确定有限采样次数，比如 64 次，这样我们就表示出了柱状图 x 轴的意义。然后，就可以遍历场景屏幕上的每一个像素，计算柱状图的 Y 轴（即，对于 x 轴上的亮度，屏幕上有多少个相关的像素）。<br />
</p>

<ul class="org-ul">
<li>【UE4ToUnity】自动曝光 Histogram <a href="https://zhuanlan.zhihu.com/p/76416912">https://zhuanlan.zhihu.com/p/76416912</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org715ad37"></a>Metering Mode<br />
<div class="outline-text-8" id="text-org715ad37">
<p>
Metering Mode 用于设置摄像机如何测量当前的场景曝光。Metering Mode 有如下几个选项：<br />
</p>
<ul class="org-ul">
<li>Average：摄像机使用整个亮度缓冲区来测量曝光。<br /></li>
<li>Spot：摄像机仅使用缓冲区的中心来测量曝光。如果只想根据屏幕中央的内容进行曝光，这很有用。<br /></li>
<li>Center Weighted：摄像机将一个权重应用于缓冲区中的每个像素，然后使用它们来测量曝光。中心的像素具有最大权重，屏幕边界处的像素具有最小权重，而其间的像素越接近屏幕边界，权重将逐渐降低。<br /></li>
<li>Mask Weighted：摄像机将一个权重应用于缓冲区中的每个像素，然后使用权重来测量曝光。为了指定权重，此方法使用在 Weight Texture Mask 字段中设置的纹理。请注意，如果未提供纹理，此计量模式等效于 Average。<br /></li>
<li>Procedural Mask：摄像机将一个权重应用于缓冲区中的每个像素，然后使用权重来测量曝光。权重是使用遮罩生成的，而遮罩是采用以下参数由程序生成的：<br /></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">属性</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">Center Around Exposure target</td>
<td class="org-left">程序化遮罩是否将围绕在摄像机中设置为曝光目标 (Exposure Target) 的游戏对象的中心</td>
</tr>

<tr>
<td class="org-left">Center</td>
<td class="org-left">设置程序化计量遮罩的中心（[0,0] 表示屏幕的左下角，[1,1] 表示屏幕的右上角）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">仅当禁用 Center Around Exposure target 时可用</td>
</tr>

<tr>
<td class="org-left">Offset</td>
<td class="org-left">设置遮罩居中位置的偏移。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">仅当启用 Center Around Exposure target 时可用</td>
</tr>

<tr>
<td class="org-left">Radii</td>
<td class="org-left">以一半屏幕的分数形式（如 0.5 表示在两个方向上拉伸一半屏幕的遮罩）设置程序化遮罩的半径（水平和垂直）</td>
</tr>

<tr>
<td class="org-left">Softness</td>
<td class="org-left">设置遮罩的柔和度。该值越高，对遮罩边缘像素的影响越小</td>
</tr>

<tr>
<td class="org-left">Mask Min Intensity</td>
<td class="org-left">低于此阈值的所有像素（以 EV100 为单位）将在计量遮罩中被分配权重 0</td>
</tr>

<tr>
<td class="org-left">Mask Max Intensity</td>
<td class="org-left">高于此阈值的所有像素（以 EV100 为单位）将在计量遮罩中被分配权重 0</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
<li><a id="org93f4808"></a>Curve Mapping<br />
<div class="outline-text-7" id="text-org93f4808">
<p>
Curve Mapping 模式是 Automatic 模式的变体。可以操纵曲线，而不是设置限制，其中的 X 轴表示当前场景曝光，Y 轴表示所需的曝光。这可让你以更精确和受控的方式一次性为所有光照条件设置曝光。<br />
</p>
</div>
</li>
<li><a id="org403cff8"></a>Use Physical Camera<br />
<div class="outline-text-7" id="text-org403cff8">
<p>
此模式主要依赖于摄像机的物理设置 (Physical Settings)<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org38260df" class="outline-5">
<h5 id="org38260df">SSGI RTGI</h5>
<div class="outline-text-5" id="text-org38260df">
<p>
下图是 SSGI 和 RTGI 的对比，RTGI 更加真实一些，SSGI 使得画面整体偏蓝（由于无法获得屏幕外信息，所以使用了天空球颜色）<br />
<img src="./URP/ssgi-rtgi.jpg" alt="ssgi-rtgi.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgb939073" class="outline-5">
<h5 id="orgb939073">Reflection and Refraction</h5>
<div class="outline-text-5" id="text-orgb939073">
</div>
<div id="outline-container-org70d5072" class="outline-6">
<h6 id="org70d5072">Reflection</h6>
<div class="outline-text-6" id="text-org70d5072">
<p>
HDRP 使用如下技术来技术反射：<br />
</p>
<ul class="org-ul">
<li>Screen space reflections<br /></li>
<li>Realtime and baked Reflection Probe sampling<br /></li>
<li>Sky reflection<br /></li>
</ul>

<p>
下面是几种反射技术的对比：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">反射技术</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">性能消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Screen space reflection</td>
<td class="org-left">SSR 会利用 screen depth buffer 和 color buffer 计算反射。实时抓取所有物体的反射</td>
<td class="org-left">高</td>
</tr>

<tr>
<td class="org-left">Ray traced reflection</td>
<td class="org-left">RayTracedReflection 使用 ray tracing 计算反射。实时抓取所有物体的反射</td>
<td class="org-left">高</td>
</tr>

<tr>
<td class="org-left">Realtime Reflection Probe</td>
<td class="org-left">手动放置 Reflection Probe。实时抓取所有物体的反射</td>
<td class="org-left">和 Probe 分辨率有关</td>
</tr>

<tr>
<td class="org-left">Baked Reflection Probe</td>
<td class="org-left">手动放置 Reflection Probe。在烘培阶段只抓取静态物体的反射</td>
<td class="org-left">低</td>
</tr>

<tr>
<td class="org-left">Sky reflection</td>
<td class="org-left">反射材质显示对天空的反射</td>
<td class="org-left">低</td>
</tr>
</tbody>
</table>

<p>
下图是 Screen space reflection 和 Ray traced reflection 的对比，SSR 迭代 75 次右侧金色金属球无法显示右侧银色金属球，迭代 300 次右侧金色金属球无法显示角色轮廓:<br />
<img src="./URP/ssr-rtr.jpg" alt="ssr-rtr.jpg" /><br />
</p>
</div>

<ul class="org-ul">
<li><a id="org4c0208a"></a>Screen Space Reflection<br />
<div class="outline-text-7" id="text-org4c0208a">
<p>
SSR 有三种 Tracing Modes：<br />
</p>
<ul class="org-ul">
<li>RayMarching<br />
<ul class="org-ul">
<li>描述 : 使用屏幕空间的 RayMarching 技术<br /></li>
<li>limitation : 只有将 RenderingPass 设置为 Before Refraction 时，半透明 Emissive 材质才会被 SSR 计算<br /></li>
</ul></li>
<li>RayTracing<br />
<ul class="org-ul">
<li>描述 : 使用 ray traced reflection<br /></li>
<li>limitation : 半透明 Emissive 材质不会被计算; decal 不会被计算<br /></li>
</ul></li>
<li>Mixed<br />
<ul class="org-ul">
<li>描述 : 将 Ray Marching 和 Ray Tracing 结合起来<br /></li>
<li>limitation : 只有 Lit shader 选为 Deferred 才可以使用该模式<br /></li>
</ul></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org12afbba"></a>SSR Volume<br />
<ul class="org-ul">
<li><a id="orgc84eb38"></a>RayMarching<br />
<div class="outline-text-9" id="text-orgc84eb38">
<p>
PBR Accumulation<br />
World Space Speed Rejection           会导致禁止的物体噪声增大，但是，当摄像机运动时会有时域的混合，可以减低摄像机运动导致的噪声<br />
	Speed Rejection Scaler Factor     用于计算 clamp 速度的最大值<br />
    Speed Smooth Rejection            速度平滑，开启后可以减少噪声。<br />
Speed Rejection                       用于控制基于速度拒绝时域样本的速度阈值, 大于阈值的样本都被拒绝 (该速度阈值是经过归一化的)<br />
Speed From Reflection Surface         表示计算速度时，考虑接收反射的物体的运动速度<br />
Speed From Reflected Surface          表示计算速度时，考虑被反射的物体的运动速度<br />
</p>
</div>
</li>

<li><a id="org0f9537a"></a>参考资料<br />
<div class="outline-text-9" id="text-org0f9537a">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/manual/reference-screen-space-reflection.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/manual/reference-screen-space-reflection.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgad710a3"></a>Mixed tracing<br />
<div class="outline-text-8" id="text-orgad710a3">
<p>
对于屏幕上可见的几何体使用 ray marching 进行求交，对于屏幕外的几何体使用 ray tracing 求交。这样就可以使得反射可以处理屏幕上的不透明粒子，顶点动画，decals。<br />
Tips： 该选项只能再 Performance mode 并且 Lit Shader Mode 被设置为 deferred 时才可以使用。<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgef84539"></a>Ray-Traced Reflection<br /></li>

<li><a id="org185284e"></a>Reflection hierarchy<br />
<div class="outline-text-7" id="text-org185284e">
<p>
为了获得最高质量的反射，HDRP 使用能为每个像素提供最佳精度的反射技术，同时确保它与其他所有技术融合。为此，HDRP 会求解所有照明技术，直到总权重达到 1。<br />
</p>

<ul class="org-ul">
<li>屏幕空间反射控制自己的权重。<br /></li>
<li>反射探针有一个可以手动编辑的权重属性。这允许你为重叠的反射探针设置权重，以便正确混合它们。<br /></li>
<li>天空反射的权重固定为 1。<br /></li>
</ul>

<p>
要为给定像素选择最佳的反射技术，HDRP 会检查可用的技术，并按特定的顺序进行检查，称为反射层次结构。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgda74998" class="outline-6">
<h6 id="orgda74998">Refraction</h6>
<div class="outline-text-6" id="text-orgda74998">
</div>
<ul class="org-ul">
<li><a id="org748f661"></a>Understand Refraction<br />
<div class="outline-text-7" id="text-org748f661">
<p>
当光线从一种材质进入另一种材质时，会发射偏折，这种现象就是折射。我们的眼睛只能观察到穿过透明材质的折射现象，光进入不透明材质后大多数都会被吸收。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2879c2c"></a>How refraction works in HDRP<br />
<div class="outline-text-8" id="text-org2879c2c">
<p>
HDRP 需要得到穿过透明像素所看到的颜色。对于每个透明像素，HDRP 从摄像机位置开始沿着相反的光的方向来计算光的偏折：<br />
</p>
<ol class="org-ol">
<li>HDRP 获得视角向量，其为进入人眼的光的方向<br /></li>
<li>当光进入物体后，HDRP 会对光进行偏折。为了计算光偏折多少以及光在物体内传播多远，HDRP 会根据材质的 Surface Type 设置并使用简单的形状来近似物体内部的体积<br /></li>
<li>当光离开物体时，HDRP 会会使用简单的形状来近似物体内部的体积再将光偏折回来<br /></li>
<li>HDRP 会将光线和 Proxy Volume 进行求交，来获得光穿过透明像素看到的颜色<br /></li>
</ol>

<p>
Tips: 上面提到的使用简单的形状来近似物体内部的体积的技术被称为折射模型(refraction model)<br />
</p>
</div>
</li>
<li><a id="org798eca2"></a>Create a refractive Material<br />
<div class="outline-text-8" id="text-org798eca2">
<p>
使用 HDRP Lit Shader 创建折射材质:<br />
</p>
<ol class="org-ol">
<li>Surface Options 部分，将 Rendering Pass 设置为 Default<br /></li>
<li>Surface Options 部分，将 Surface Type 设置为 Transparent<br /></li>
<li>Surface Inputs 部分，Base Map 颜色设置时，将 Alpha 设置为小于 1 的值。<br /></li>
<li>Transparency Inputs 部分，选择 Refraction Model 为 None 以外的选项<br /></li>
</ol>
</div>
</li>
<li><a id="orgf373f9a"></a>Control refraction<br />
<div class="outline-text-8" id="text-orgf373f9a">
<p>
控制折射效果<br />
</p>
<ol class="org-ol">
<li>为物体设置近似的形状，从而使得光线偏折更精确<br /></li>
<li>设置折射率，从而控制光线偏折的量<br /></li>
<li>设置 Transmission Color 和光的吸收<br /></li>
<li>设置材质的 smoothness，控制折射的模糊程度<br /></li>
<li>添加 Reflection Probe，从而可以精确获得穿过半透明像素看到的颜色<br /></li>
<li>使用合适的 Proxy Volume 形状<br /></li>
</ol>
</div>
</li>
<li><a id="org079a15e"></a>Other types of refraction<br />
<div class="outline-text-8" id="text-org079a15e">
<ul class="org-ul">
<li>Recursive Rendering  递归渲染允许每像素包含多个折射表面。<br /></li>
<li>Path tracing 路径跟踪使用折射率和材料属性创建准确的折射，但通常效率太低不适合实时渲染，因为路径跟踪器会发射真实的光路，不对形状或距离进行近似。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org48227f5"></a>Refraction models<br />
<div class="outline-text-7" id="text-org48227f5">
<p>
refraction model 告诉 HDRP 哪种简单的形状最接近物体内部的形状。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd708612"></a>Sphere refraction model<br />
<div class="outline-text-8" id="text-orgd708612">
<p>
如果物体是实心的凸形（convex shape），则使用球面折射模型。凸形是指表面不平行，向物体中心弯曲的形状。例如，一个圆形的弹珠。<br />
</p>

<p>
使用该模型，HDRP 为每个表面像素执行如下折射处理：<br />
</p>
<ol class="org-ol">
<li>当光进入物体时，HDRP 使用物体表面的 normal 作为计算第一次折射的一部分。这决定了光偏折的多少<br /></li>
<li>HDRP 使用一个球来近似物体的形状，球的直径决定了光在物体内传播的距离<br /></li>
<li>当光离开物体时，HDRP 使用球表面的 normal 作为计算第二次折射的一部分。这决定了光偏折会来的多少<br /></li>
</ol>

<p>
<img src="./URP/sphere-refraction-model.jpg" alt="sphere-refraction-model.jpg" /><br />
上图以 3 个像素为例展示了 HDRP 如何计算折射光线:<br />
</p>
<ul class="org-ul">
<li>橘色的实线表示从摄像机到像素的方向；<br /></li>
<li>白色的圆表示使用球来近似物体的厚度;<br /></li>
<li>蓝色的实线表示表面的法线；<br /></li>
</ul>
<p>
为了控制球的直径，可以在材质的 Transparency Inputs 部分，修改 Refraction Thickness 或添加一个 Refraction Thickness Map。<br />
</p>

<p>
为一个球体使用球折射模型，你会在场景中观察到上下倒立的像，产生这种现象的原理如下。光线离开玻璃球时偏折了很多，使得他们相交然后碰到树的相反的一端。<br />
<img src="./URP/sphere-model-reverse-img.jpg" alt="sphere-model-reverse-img.jpg" /><br />
<img src="./URP/refraction-inversion.png" alt="refraction-inversion.png" /><br />
</p>
</div>
</li>
<li><a id="org44f7a06"></a>Planar refraction model<br />
<div class="outline-text-8" id="text-org44f7a06">
<p>
当物体形状符合如下情况时，使用 Planar refraction model:<br />
</p>
<ul class="org-ul">
<li>物体的表面几乎是平行的，如立方体形状的冰块<br /></li>
<li>物体是空心的，这意味着实心壁有平行的表面。例如，空心玻璃<br /></li>
</ul>
<p>
你应该为一个空心的球体使用 Planar refraciton model，如气泡<br />
</p>

<p>
使用该模型，HDRP 为每个表面像素执行如下折射处理：<br />
</p>
<ol class="org-ol">
<li>当光进入物体时，HDRP 使用物体表面的 normal 作为计算第一次折射的一部分。这决定了光偏折的多少<br /></li>
<li>HDRP 使用一个平行平面来近似出射表面（这就是平面投影 plannar projection），物体表面和该平面的距离决定了光在物体内传播的距离<br /></li>
<li>当光离开物体时，HDRP 将光线偏折回原来方向<br /></li>
</ol>


<div id="org7efbeff" class="figure">
<p><img src="./URP/planar-refraction-model.jpg" alt="planar-refraction-model.jpg" /><br />
</p>
</div>

<p>
上图以 3 个像素为例展示了 HDRP 如何计算折射光线:<br />
</p>
<ul class="org-ul">
<li>橘色的实线表示从摄像机到像素的方向；<br /></li>
<li>蓝色的虚线表示平行平面用来近似物体的厚度(白线为平行平面之间的距离，其为物体的厚度);<br /></li>
<li>蓝色的实线表示表面的法线；<br /></li>
</ul>
<p>
为了控制平行平面间的距离，可以在材质的 Transparency Inputs 部分，修改 Refraction Thickness 或添加一个 Refraction Thickness Map。将 thickness 设置为物体近似的宽度。宽度越大，折射效果越明显，其原理如下。厚度越大，光的偏移越多，变形越明显。<br />
<img src="./URP/planar-model-thickness-effect.jpg" alt="planar-model-thickness-effect.jpg" /><br />
<img src="./URP/planar-refraction-compare.png" alt="planar-refraction-compare.png" /><br />
</p>
</div>
</li>
<li><a id="orgdfed5ca"></a>Thin refraction model<br />
<div class="outline-text-8" id="text-orgdfed5ca">
<p>
thin refraction model 和 planar refraction model 一样，只是 Refraction Thickness 被固定为 5mm. 无法修改该值。<br />
</p>

<p>
当使用 Path Tracing Volume 时，你应该为薄的物体使用该 refraction model，其可以提供更好的性能。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org4e8b721"></a>Screen Space Refraction<br />
<div class="outline-text-7" id="text-org4e8b721">
<p>
Screen Space Refraction 使用 color buffer 或 Reflection Probes 来计算折射效果.<br />
</p>

<p>
通过 Screen Space Refraction Volume 可以控制 Screen Weight Distance 参数，该参数影响 Screen Space Refraction 对颜色的采样从 color buffer 渐变为 下一级的速度。增大 Screen Weight Distance 可以减少物体上折射颜色之间的缝隙（从 screen color buffer 计算的折射颜色，从 ReflectionProbe 或 Skybox 计算的折射颜色之间会有缝隙）<br />
</p>

<p>
参考 <a href="#orgf1a0b90">How HDRP calculates color for reflection and refraction</a><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5eca10e" class="outline-6">
<h6 id="org5eca10e">Recursive rendering</h6>
<div class="outline-text-6" id="text-org5eca10e">
<p>
<a href="./UnityRayTracing.html#orgff3a454">Recursive rendering</a><br />
</p>
</div>
</div>
<div id="outline-container-orgd2f664f" class="outline-6">
<h6 id="orgd2f664f">Path tracing</h6>
<div class="outline-text-6" id="text-orgd2f664f">
<p>
<a href="./UnityRayTracing.html#org55835e6">Path tracing</a><br />
</p>
</div>
</div>
<div id="outline-container-orgf1a0b90" class="outline-6">
<h6 id="orgf1a0b90">How HDRP calculates color for reflection and refraction</h6>
<div class="outline-text-6" id="text-orgf1a0b90">
<p>
HDRP 计算反射颜色或折射颜色时，会按照一个层级结构来工作。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orgc09197a"></a>Default hierarchy<br />
<div class="outline-text-7" id="text-orgc09197a">
<ol class="org-ol">
<li>如果光相交的位置在屏幕上，HDRP 使用 color buffer 中的内容（其存储了场景的可见部分）。对于反射来说，需要开启 SSR，才能生效。<br /></li>
<li>如果场景中存在 ReflectionProbe，并且物体在 ReflectionProbe 影响范围内，则使用 ReflectionProbe 的 Cubemap<br /></li>
<li>如果存在 sky，则使用 sky 的 Cubemap 或 sky 的颜色<br /></li>
<li>使用黑色<br /></li>
</ol>

<p>
HDRP 使用的 color buffer 只包含了不透明物体，所以无法通过折射物看到其他折射物<br />
</p>
</div>
</li>
<li><a id="orge069df0"></a>Hierarchy if you use ray-traced reflections<br />
<div class="outline-text-7" id="text-orge069df0">
<p>
如果使用 ray-traced reflections, forward rendering 模式下 HDRP 在 depth prepass 中会将 normal 和 roughness 写入_NormalBufferTexture RT 中, 依据 NormalBufferTexture 中存储信息，以及摄像机方向，发射反射射线以获得被反射物的材质信息和光源信息。然后使用这些信息通过结合 diffuse color 和 specular color 来计算最终的照明。<br />
</p>

<p>
发生下面情况时，HDRP 只使用 specular color：<br />
</p>
<ul class="org-ul">
<li>射线没有碰到任何物体<br /></li>
<li>射线弹射次数超过了 SSR 设置的 Bounce Count 值<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org19086a1"></a>Diffuse Color<br />
<div class="outline-text-8" id="text-org19086a1">
<p>
HDRP 按照如下层级结构来确定 diffuse color：<br />
</p>
<ol class="org-ol">
<li>如果场景中存在 Probe Volume, 则使用 Probe Volume 中的照明数据<br /></li>
<li>如果该位置存在 baked lightmap, 则使用 lightmap texture<br /></li>
<li>如果存在 LightProbe，并且物体在 LightProbe 影响范围内，则使用 LightProbe 的数据<br /></li>
<li>如果在 Lighting-&gt;Environment-&gt;Static Lighting Sky 设置了静态的 sky texture，则使用该 cubemap texture 对应的 ambient probe<br /></li>
<li>使用黑色<br /></li>
</ol>
</div>
</li>
<li><a id="org0515038"></a>Specular Color<br />
<div class="outline-text-8" id="text-org0515038">
<p>
HDRP 按照如下层级结构来确定 specular color：<br />
</p>
<ol class="org-ol">
<li>如果场景中存在 Reflection Probe 并且物体在 Probe 影响范围内，则使用 ReflectionProbe 对应的 cubemap texture<br /></li>
<li>如果存在 sky，则使用 sky 的 Cubemap<br /></li>
<li>使用黑色<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="orgfac330f"></a>Control how Materials use each hierarchy<br />
<div class="outline-text-7" id="text-orgfac330f">
<p>
可以通过 Screen Space Reflection Volume 上的 Minimum Smoothness 来控制层级的选择。<br />
例如，若使用 ray-traced reflection 并将 Minimum Smoothness 设置为 0.9:<br />
</p>
<ul class="org-ul">
<li>对于 smoothness 值大于等于 0.9 的区域，将使用 ray-traced reflections hierarchy。<br /></li>
<li>对于 smoothness 值小于 0.9 的区域，将使用 specular hierarchy<br /></li>
</ul>
</div>
</li>

<li><a id="org8d17670"></a>How reflections in reflections work<br />
<div class="outline-text-7" id="text-org8d17670">
<p>
以下图为例来进行说明：<br />
<img src="./URP/refraction-hierarchy-reflections-inside-reflections.png" alt="refraction-hierarchy-reflections-inside-reflections.png" /><br />
上面场景所采用的设置为<br />
</p>
<ul class="org-ul">
<li>开启 Ray-traced reflections, 并且 Bounce Count 设置为 1<br /></li>
<li>Minimum Smoothness 设置为 0.9<br /></li>
<li>胶囊体为动态物体，smoothness 比较低<br /></li>
<li>银色金属球 smoothness 小于 0.9<br /></li>
<li>金属金属球 smoothness 大于 0.9<br /></li>
<li>小水坑 smoothness 大于 0.9<br /></li>
</ul>

<p>
因为 BounceCount 设置为 1，所以当射线离开第一个物体到达第二个物体后就会停止弹射，即只弹射一次。所以，反射物中反射的物体不会反射出其他物体。HDRP 会降低 hierarchy 去确定第二个物体的颜色。如果该物体的 Smoothness 值比较高，其几乎会使用 specular color 并采用 specular color hierarchy。如果该物体的 Smoothness 值比较低，其几乎会使用 diffuse color 并且采用 diffuse color hierarchy。<br />
</p>

<ul class="org-ul">
<li>对于银色金属球，其 smoothness 小于 0.9，所以使用 specular hierarchy。这意味着其使用备用的 Reflection Probe 方案，所以其无法反射出动态的胶囊体<br /></li>
<li>在小水坑中，反射出来的金色金属球使用了 fallback 的 specular color hierarchy 和 Reflection Probe，因为该金属球的 smothness 值比较高。所以，反射出来的金色金属球中没有再反射出胶囊体<br /></li>
<li>再金属金属球中，反射出来的地面使用了 fallback 的 diffuse color hierarchy 和地面的 lightmap，因为地面的 smoothness 值比较低。<br /></li>
<li>再金属金属球中，反射出来的胶囊体使用了 fallback 的 diffuse color hierarchy 和 ambient probe，因为胶囊体的 smoothness 值比较低且没有 lightmap。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4cddb2a" class="outline-5">
<h5 id="org4cddb2a">Environment Lighting</h5>
<div class="outline-text-5" id="text-org4cddb2a">
<p>
环境照明（Environment Lighting）用于模拟来自场景周围环境的照明。通常使用环境照明来模拟天空照明，但也可以使用它来模拟有色环境光(colored ambient light)或照明棚(lighting studio)。在 HDRP 中，环境照明有两部分：<br />
</p>

<ul class="org-ul">
<li>视觉环境(visual environment) 由 Visual Environment Volume override 控制。这控制了你通过相机看到的天空盒，并代表了环境照明的视觉方面。使用内置渲染管道，你可以根据场景自定义视觉环境照明设置。作为对比，HDRP 的 Visual Environment 使用 Volume 框架可以在同一场景中平滑地插值你的天空（和雾）的不同环境照明设置。<br /></li>
<li>照明环境(lighting environment)，由 Lighting 窗口的 Environment (HDRP) 部分控制。HDRP 使用照明环境来计算场景的间接环境光。它不使用 Volume 框架，因为 HDRP 的间接环境光目前仅支持一个环境照明源。<br /></li>
</ul>

<p>
本质上，使用视觉环境(visual environment)来控制场景中的天空的外观，使用照明环境(lighting environment)来控制天空如何影响间接环境光。<br />
</p>
</div>
<div id="outline-container-org8efefc2" class="outline-6">
<h6 id="org8efefc2">Visual Environment</h6>
<div class="outline-text-6" id="text-org8efefc2">
<p>
Unity 工程的 HDRP Asset 有如下两个属性会影响 Visual Environment：<br />
</p>
<ul class="org-ul">
<li>Reflection Size：控制 sky cubemap 的分辨率。在未受到 local Reflection Probes 影响的区域，unity 会使用该 cube map 作为备用的 Reflection Probe。<br /></li>
<li>Lighting Override Mask ： 使用 LayerMask 可以解耦 Camera 看到的天空和天空所影响的 ambient lighting。例如，你想要一个黑暗的天空，但是需要一个更亮的环境光以便依然可以看到东西。<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org1e65f7f"></a>Visual Environment Volume<br />
<div class="outline-text-7" id="text-org1e65f7f">
<p>
通过 Visual Environment Volume 可以控制 Sky、Wind。下面列出设置选项：<br />
</p>
<ul class="org-ul">
<li>Sky/Sky Type: 设置使用的天空类型，HDRP 有 3 种内置的天空类型<br />
<ul class="org-ul">
<li>HDRI Sky<br /></li>
<li>Gradient Sky<br /></li>
<li>Physically Based Sky<br /></li>
</ul></li>
<li>Sky/Background Clouds: 设置云的类型<br />
<ul class="org-ul">
<li>None: 不渲染任何云<br /></li>
<li>Cloud Layer:使用 Cloud Layer sytem 渲染云<br /></li>
</ul></li>
<li>Sky/Ambient Mode: 设置 ambient light 的模式。有 Static 和 Dynamic 两种模式<br />
<ul class="org-ul">
<li>Static: Ambient light 来自烘培好的天空，该天空通过 Lighting 窗口中 Environment/Static Lighting Sky 的设置。该 ambient light 既影响实时 GI 也影响烘培 GI。<br /></li>
<li>Dynamic: Ambient light 来自当前 Visual Environment Volume 在 Sky/Sky Type 中设置的天空。该 ambient light 可以实时改变。如果你使用 baked GI，改变 environment lighting 只影响不使用 Ambient Probes 照明的 GameObjects。如果你使用 real-time GI, 改变 environment lighting 会影响 lightmaps 和 Ambient Probes。<br /></li>
</ul></li>
<li>Wind/Global Orientation: 设置风向，相对于世界空间的 x 轴朝向<br /></li>
<li>Wind/Global Speed: 设置风速，单位为千米/小时<br /></li>
</ul>
</div>
</li>
<li><a id="orge72ab82"></a>HDRI Sky<br />
<div class="outline-text-7" id="text-orge72ab82">
<p>
High-dynamic-range imaging(HDRI) sky 只是使用一个 cubemap 贴图来表示一个简单的天空，使用 HDRI Sky Volume 可以设置 HDRI Sky，例如：可以定义 HDRP 如何更新该 HDRI Sky 生成的间接光照(indirect lighting)。<br />
</p>

<p>
使用 HDRI Sky：<br />
</p>
<ol class="org-ol">
<li>在 Visual Environment Volume 中将 SkyType 选为 HDRI Sky<br /></li>
<li>在 HDRI Sky Volume 中开启 HDRI Sky<br /></li>
</ol>
</div>
</li>

<li><a id="org0a9fba1"></a>Gradient Sky<br />
<div class="outline-text-7" id="text-org0a9fba1">
<p>
使用 Gradient Sky Volume 可以 3 种颜色，HDRP 在这三种颜色之间进行插值来创建一个渐变的天空。在运行时，可以修改这 3 种颜色值。<br />
</p>

<p>
使用 Gradient Sky：<br />
</p>
<ol class="org-ol">
<li>在 Visual Environment Volume 中将 SkyType 选为 Gradient Sky<br /></li>
<li>在 Gradient Sky Volume 中开启 Gradient Sky<br /></li>
</ol>
</div>
</li>

<li><a id="org89b65d4"></a>Physically Based Sky<br />
<div class="outline-text-7" id="text-org89b65d4">
<p>
物理天空（Physically Based Sky）模拟了一个球形的星球，其大气由两部分组成，密度根据高度呈指数递减。这意味着，海平面以上的高度越高，大气越稀薄。<br />
</p>

<p>
该模拟是预先处理的，这意味着它只运行一次，而不是每帧运行一次。该模拟会评估所有光线和视角的所有大气散射情况，并将结果存储在多个 3D 纹理中，Unity 会在运行时对其进行重新采样。预计算是场景无关的，只取决于物理天空的设置。<br />
</p>

<p>
物理天空的大气有两种类型的粒子：<br />
</p>
<ul class="org-ul">
<li>瑞利散射的空气粒子。<br /></li>
<li>具有各向异性米散射的气溶胶粒子。可以使用气溶胶来模拟污染、高度雾或薄雾。<br /></li>
</ul>

<p>
可以使用物理天空来模拟白天和黑夜的天空。运行时更改白天或黑夜不会影响性能。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgde12cec"></a>Implementation Details<br />
<div class="outline-text-8" id="text-orgde12cec">
<p>
Physically Based Sky 采用了 Precomputed Atmospheric Scattering (Bruneton and Neyret, 2008) 论文所提的方法。<br />
</p>

<p>
该技术假设你始终从行星表面上方查看场景。这意味着，如果摄像机位于行星表面以下，则天空将照常渲染，就好像摄像机位于地面上一样。行星表面的位置取决于是否启用或禁用球形模式：<br />
</p>

<ul class="org-ul">
<li>启用球形模式，则行星半径和行星中心位置属性定义了表面的位置。在此模式下，表面在距离行星中心位置设置的距离处的半径为行星半径。<br /></li>
<li>禁用球形模式，则使用海平面属性定义表面的位置。在此模式下，表面在 xz 平面上无限延伸，海平面设置其世界空间高度。<br /></li>
</ul>

<p>
无论哪种模式，默认值都将行星表面设置为场景原点的 y 轴上的 0。由于球形模式的默认值模拟地球，因此半径如此之大，以至于在创建场景环境时，可以将表面视为平坦。如果你希望场景环境的某些区域低于当前的表面高度，则可以垂直偏移场景环境，使最低区域高于 y 轴上的 0，或降低表面高度。要执行此操作：<br />
</p>

<ul class="org-ul">
<li>如果处于球形模式，则可以降低行星半径，或将行星中心位置向下移动。<br /></li>
<li>如果没有处于球形模式，则降低海平面。<br /></li>
</ul>

<p>
行星不会在深度缓冲区中渲染，这意味着它不会遮挡镜头眩光，也不会在使用运动模糊时正确工作。<br />
</p>
</div>
</li>
<li><a id="orgf30417c"></a>Warmup performance impact<br />
<div class="outline-text-8" id="text-orgf30417c">
<p>
当切换到一个 Physically Based Sky 或从一个 Physically Based Sky 切换走时，会导致明显的帧率下降。这是因为 HDRP 需要执行大量的预计算来渲染一个 Physically Based Sky，所以，在开始的一些帧比其他类型的天空会花费更多的时间（依赖于 Number of bounces 参数的设置）。<br />
</p>

<p>
当使用 Volume 系统在两个不同的 Physically Based Sky 之间插值时，也会导致重新执行预计算。这同样会导致明显的帧率下降。为了避免该问题，应该为场景使用同一组参数的 Physically Based Sky, 通过修改太阳光方向和亮度来达到想要的效果。<br />
</p>

<p>
当下面这些参数被修改后，会导致 HDRP 重新执行预计算：<br />
</p>
<ul class="org-ul">
<li>Type<br /></li>
<li>Planetary Radius<br /></li>
<li>Ground Tint<br /></li>
<li>Air Maximum Altitude<br /></li>
<li>Air Density<br /></li>
<li>Air Tint<br /></li>
<li>Aerosol Maximum Altitude<br /></li>
<li>Aerosol Density<br /></li>
<li>Aerosol Tint<br /></li>
<li>Aerosol Anisotropy<br /></li>
<li>Number of Bounces<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgc468dff"></a>Clouds<br />
<div class="outline-text-7" id="text-orgc468dff">
<p>
HDRP 有两种 Cloud 解决方案：<br />
</p>
<ul class="org-ul">
<li>Cloud Layer<br /></li>
<li>Volumetric Clouds<br /></li>
</ul>
<p>
可以一起使用两种解决方案。此时，你可以使用 Volumetric Clouds 作为近处的，可交互（接受雾和体积光）的云，使用 Cloud Layer 作为远处的云（其为 skybox 的一部分）<br />
TIPS: Cloud Layer 和 Volumetric Clouds 都不支持 Planet Center Position 设置。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org237c449"></a>Cloud Layer<br />
<div class="outline-text-8" id="text-org237c449">
<p>
Cloud Layer 是在 sky 之上渲染的 2D 贴图，可以通过使用一个 flowmap 来控制其运动。其还支持在地面上透射阴影。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orgc032605"></a>About the cloud map<br />
<div class="outline-text-9" id="text-orgc032605">
<p>
cloud map 是按照 LatLong 布局（有时称为圆柱或等距矩形）的 2D RGBA 贴图，其中每个通道都包含一种云的不透明度。为了渲染，HDRP 使用 Volume override 的四个参数 Opacity R、Opacity G、Opacity B、 Opaticy A 将 cloud map 的四个通道混合在一起。这样就可以使用单个纹理和 Volume framework 来更改云的各个方面。 如果启用“Upper Hemisphere Only”，则 cloud map 将被解释为仅包含 LatLong 纹理的上半部分。这意味着云只会覆盖地平线以上的天空。<br />
</p>

<p>
默认情况下，HDRP 使用名为 DefaultCloudMap 的 cloud map。 此纹理红色通道表示积云(cumulus clouds)、绿色通道表示层云(stratus clouds)、蓝色通道表示卷云(cirrus clouds)、Alpha 通道表示稀疏云(wispy clouds)。<br />
</p>

<p>
注意：此 cloud map 的格式与 Volumetric Clouds 使用的 cloud map 不同。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org23f6a79"></a>Volumetric Clouds<br />
<div class="outline-text-8" id="text-org23f6a79">
<p>
Volumetric Clouds 为可交互的云，其可以渲染阴影，可接受雾和体积光。HDRP 使用如下资源来生成和渲染体积云：<br />
</p>
<ul class="org-ul">
<li>a cloud lookup table: 定义高度（altidude）、密度、以及光照属性<br /></li>
<li>a cloud volume: 定义 HDRP 在场景中生成体积云的区域<br /></li>
<li>a cloud map: 从顶部俯视场景，其定义了云体积（cloud volume）中，哪些区域有云<br /></li>
</ul>
<p>
使用这三种资源，HDRP 执行如下两个过程来生成体积云：<br />
</p>
<ol class="org-ol">
<li>Shaping: HDRP 使用大比例缩放后的噪声来创造云的形状<br /></li>
<li>Erosion: 在第一步的基础上，HDRP 使用小比例缩放后的噪声为来云的边缘添加局部细节<br /></li>
</ol>
</div>

<ul class="org-ul">
<li><a id="org4177e63"></a>Cloud map and cloud lookup table<br />
<div class="outline-text-9" id="text-org4177e63">
<p>
cloud map 和 cloud LUT 贴图定义了体积云的形状和外观。这两种纹理都是 channel-packed 的（按通道打包的），其中每个通道都包含具有特定用途的独立的灰度纹理。这两个纹理对于创作来说并不简单，因此如果项目需要非常特定的云最好仅将 Cloud Control 设置为 Manual，你也可以使用工具辅助来生成这两种纹理。<br />
</p>

<p>
对于 cloud map，颜色通道表示内容如下：<br />
</p>
<ul class="org-ul">
<li>红色：覆盖范围。 指定纹理上云的密度。<br />
<ul class="org-ul">
<li>接近 0 的值表示受噪声影响较小的云区域。<br /></li>
<li>接近 1 的值表示受噪声影响更大的云区域。<br /></li>
</ul></li>
<li>绿色：雨。 指定云中较亮/较暗的区域。<br />
<ul class="org-ul">
<li>接近 0 的值表示降雨较少且颜色较浅的云区域。<br /></li>
<li>接近 1 的值表示降雨较多且颜色较深的云区域。<br /></li>
</ul></li>
<li>蓝色：类型。 沿着 cloud LUT(云查找表)的水平轴进行映射，以指定的纹素表示世界位置处的云属性。<br /></li>
</ul>

<p>
对于 Cloud LUT，颜色通道代表：<br />
</p>
<ul class="org-ul">
<li>红色：配置文件覆盖范围。 根据云体积内云的高度确定云的密度。<br /></li>
<li>绿色：侵蚀和塑造。 确定云体积的哪些区域更容易受到侵蚀和塑造。 值接近 1 意味着云更容易受到侵蚀和塑造。<br /></li>
<li>蓝色：环境光遮挡。 HDRP 在计算体积云的光照时应用于 ambient probe(环境探针)的乘数。<br /></li>
</ul>

<p>
导入这两个贴图纹理时，要禁用 sRGB。 为了获得最佳效果，请勿使用任何压缩。<br />
</p>

<p>
注意：此 cloud map 的格式与 Cloud Layer 功能使用的 cloud map 不同。<br />
</p>
</div>
</li>

<li><a id="orga727869"></a>Limitations<br />
<div class="outline-text-9" id="text-orga727869">
<ul class="org-ul">
<li>Volumetric clouds 和 Before Refraction renderer queue 中的半透明物体行为和限制类似<br /></li>
<li>默认情况下，出于性能考虑，Planar Reflection Probes 和 realtime Reflection Probes 不会渲染 Volumetric Clouds<br /></li>
<li>当为 Reflection Probes 开启 Volumetric clouds 后，为了性能，会以低分辨率渲染 Volumetric clouds，并且不包含任何时域累积<br /></li>
<li>默认情况下，Baked Reflection Probes 会以全分辨率渲染 Volumetric clouds，当不包含任何时域累积<br /></li>
<li>ray-traced 效果不会考虑 Volumetric clouds<br /></li>
<li>透射比（Transmittance）不会以线性的方式应用到 camera 颜色，以提供一个更好和太阳光(或其他高亮度的像素)的混合。若 camera 开启了 MSAA，由于内部限制，会使用不同的混合配置，其可能会导致云的边缘更黑一些<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org235cad3" class="outline-6">
<h6 id="org235cad3">Lighting Environment</h6>
<div class="outline-text-6" id="text-org235cad3">
<p>
HDRP 使用照明环境(Lighting Environment)来计算场景的间接环境光。<br />
Window/Rendering/Lighting 打开 Lighting 窗口，在 Environment 的选项下，可以对 Lighting Environment 相关的设置进行修改。Lighting Environment 相关的设置如下：<br />
</p>
<ul class="org-ul">
<li>Profile: 用于 Sky 的 Volume Profile。该 Volume Profile 必须包含至少一个 Sky Volume override。该 Volume Profile 和场景种的主要方向光的交互作用会影响最终烘培的光的显示效果<br /></li>
<li>Static Lighting Sky: 间接环境光模拟所使用的天空。下拉框种只包含，Volume Profile 中所包含的 sky type。例如，若 Volume Profile 中包含一个 Gradient Sky Volume override, 则你可以在该下拉框中选择 Gradient Sky<br /></li>
<li>Static Lighting Background Clouds: 间接环境光模拟所使用的背景云。下拉框种只包含，Volume Profile 中所包含的 cloud type。<br /></li>
<li>Static Lighting Volumetric Clouds: 开启此选项时，在间接环境光模拟中会包含 Volumetric Clouds<br /></li>
</ul>

<p>
你可以为 Lighting Environment 和场景使用相同的 Volume Profile。这样 baked lighting 和 场景可视化背景会使用相同的 sky settings，baked lighting 就会精确匹配运行时的场景可视化背景。若你想分开控制照明环境(Lighting Environment)的 light baking 和场景的可视化背景, 你可以为 Lighting Environment 和场景使用不同的 Volume Profile。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orgc0c0602"></a>Decoupling the visual environment from the lighting environment<br />
<div class="outline-text-7" id="text-orgc0c0602">
<p>
在 Unity 工程的 HDRP Asset 中可以使用 Lighting/Sky/Lighting Override Mask 选项来将 Lighting Environment 和 Visual Environment 分离开。<br />
</p>

<p>
如果将 Lighting Override Mask 设置为 Nothing，或一组没有 Volume 的 Layers，则没有 Layers 充当 override。这意味着环境照明(environment lighting)来自影响摄像机的所有 Volume。如果将 Lighting Override Mask 设置为包含具有 Volume 的 Layers，则 HDRP 仅使用这些 Layers 上的 Volume 来计算环境照明(environment lighting)。<br />
</p>

<p>
以下是将天空照明与视觉天空分离，并为每个使用不同 Volume 配置文件的一个示例：<br />
当你使用包含太阳的 HDRI 天空时。要使太阳在应用程序中实时可见，你的天空背景必须显示具有太阳的 HDRI 天空。要实现来自太阳的实时光照，你必须在场景中使用定向光，并在烘焙过程中使用与第一个相同但不包含太阳的 HDRI 天空。如果你使用包含太阳的 HDRI 天空来烘焙光照，则太阳会两次（一次来自定向光，一次来自烘焙过程）影响光照，并使光照看起来不真实。<br />
</p>
</div>
</li>

<li><a id="orgab42884"></a>Ambient Light Probe<br />
<div class="outline-text-7" id="text-orgab42884">
<p>
HDRP 将 Ambient Light Probe 作为 indirect diffuse lighting 的最终备选。其会影响下面内容：<br />
</p>
<ul class="org-ul">
<li>若场景没有计算 indirect ambient light（当 unity 没有为该场景计算任何 lightmaps 或 LightProbes）, 则影响所有 Mesh Renderers<br /></li>
<li>影响 Light Probe Mode 设置为 Off 的 Mesh Renderers<br /></li>
<li>若 Volumetric Clouds Volume 的 Lighting/Ambient Light Probe dimmer 的值大于 0，则影响 Volumetric Fog<br /></li>
</ul>

<p>
Ambient Light Probe 可以是静态的（根据 Lighting 窗口中 Environment/Static Lighting Sky 的设置生成）也可以是动态的（更具当前 Lighting Environment/Profile 中使用的 sky 动态更新）。在 Lighting 窗口中 Environment/Profile 对于的 Volume 配置文件中，将 Sky/Ambient Mode 修改为 Dynamic。Ambient Light Probe 就会在运行时随当前 Lighting Environment/Profile 中使用的 sky 动态更新。<br />
</p>
</div>
</li>
<li><a id="org4debb39"></a>Ambient Reflection Probe<br />
<div class="outline-text-7" id="text-org4debb39">
<p>
HDRP 将 Ambient Reflection Probe 作为 indirect specular lighting 的最终备选。其只会影响 local Reflection Probes，SSR 以及 Raytraced Reflections 影响不到的区域。<br />
</p>
</div>
</li>
<li><a id="org92e6d4c"></a>Reflection Probe<br />
<div class="outline-text-7" id="text-org92e6d4c">
<p>
Reflection Probe 和 Cameras 的工作方式相同，他们都使用 Volume system，在 Visual Environment Volume 的设置会影响到 Reflection Probes 和 Cameras，渲染 Reflection Probe 和 Cameras 都会使用来自 sky 的 environment lighting。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4031aa4" class="outline-5">
<h5 id="org4031aa4">Volumetric Lighting</h5>
<div class="outline-text-5" id="text-org4031aa4">
<p>
HDRP 包含了一个 volumetric lighting system，使用其可渲染 Volumetric Fog。HDRP 还实现了一个统一的 lighting system，所有的场景组件（如，Lights，不透明和半透明的 GameObjects）都可以和雾进行交互，使得雾看起来有体积感。<br />
</p>
</div>
<div id="outline-container-org1526820" class="outline-6">
<h6 id="org1526820">Enabling Volumetric Lighting</h6>
<div class="outline-text-6" id="text-org1526820">
<ol class="org-ol">
<li>HDRP Asset 中，Lighting 部分，开启 Volumetric Fog 和 Volumetric Clouds<br /></li>
<li>HDRP Global Settings 中，Frame Settings/Camera(Reltime Reflection or Baked-Custom Reflection)/Lighting，开启 Fog 和 Volumetrics<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org8203a0d" class="outline-6">
<h6 id="org8203a0d">Fog</h6>
<div class="outline-text-6" id="text-org8203a0d">
<p>
HDRP 实现由指数雾组件组成的多层雾，其密度随着距摄像机的距离和高度呈指数变化。HDRP 允许你向该指数雾添加可选的体积组件，以真实地模拟灯光和雾的交互，可以对辉光(glow)和黄昏光线进行物理上合理的渲染，这些光线是从中心点（如太阳）穿过云和树木等物体间隙的光束。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org6277c2d"></a>Atmospheric Scattering<br />
<div class="outline-text-7" id="text-org6277c2d">
<p>
当悬浮在大气中的颗粒将穿过它们的一部分光向各个方向扩散（或散射）时，就会发生大气散射。<br />
</p>

<p>
引起大气散射的自然效应包括雾、云或薄雾。<br />
</p>

<p>
HDRP 通过将颜色叠加到对象上来模拟雾效果，具体取决于对象与相机的距离。 这非常适合模拟室外环境中的雾气或薄雾。 你可以使用它来隐藏远处游戏对象的剪裁，如果你减少相机的远剪裁平面以增强性能，这将非常有用。<br />
</p>

<p>
HDRP 实现指数雾，其中密度随着距摄像机的距离呈指数变化。 所有材质类型（点亮或未点亮）都能对雾做出正确反应。 HDRP 根据距摄像机的距离和世界空间高度计算雾密度。<br />
</p>

<p>
雾可以使用背景天空作为颜色源，而不是使用恒定的颜色。 在这种情况下，HDRP 从当前天空设置生成的立方体贴图的不同 mipmap 中采样颜色。 所选 mip 在最低分辨率和最高分辨率 mipmap 之间线性变化，具体取决于距相机的距离以及雾组件的 Mip Fog 属性中的值。 还可以限制 HDRP 使用的最高 mip 的分辨率。 这样做会增加雾的体积效果，并且比实际的体积雾消耗更少的资源。<br />
</p>

<p>
或者，可以为靠近相机的游戏对象启用体积雾。 其可以真实地模拟了光与雾的相互作用，从而可以对辉光和黄昏光线进行物理上合理的渲染，这些光线是从中心点（如太阳）穿过云和树木等物体间隙的光束。<br />
</p>
</div>
</li>
<li><a id="orgb0153a8"></a>Global Fog<br />
<div class="outline-text-7" id="text-orgb0153a8">
<p>
Global Volumetric fog 比 Local Volumetric Fog 有更好的性能和质量。Global fog 是一个高度雾，其有几个重要的属性：<br />
</p>
<ul class="org-ul">
<li>Base Height:<br />
<ul class="org-ul">
<li>到摄像机的距离小于 Base Height 的区域，其雾浓度为一个常数（这个区域内的雾无变化）<br /></li>
<li>到摄像机的距离大于 Base Height 的区域，其雾浓度按照指数衰减<br /></li>
</ul></li>
<li>Fog Attenuation Distance: 控制全局的雾的基础浓度，决定了能透过雾看到多远（以米为单位）。在此距离处，雾吸收并散射了 63% 的背景光。<br /></li>
<li>Maximum Height: 控制雾浓度按照高度的衰减；从而可以在靠近地面的地方有很高的浓度，高度越高浓度越低<br /></li>
<li>Max Fog Distance: 控制将雾应用到天空盒或背景时的距离（以米为单位）。 也决定了距离雾(Distant Fog)的范围。为了获得最佳结果，将其设置为大于相机剪裁平面的远值。 否则，场景的游戏对象和天空盒上的雾之间会出现差异。 请注意，相机的远剪裁平面是平坦的，而 HDRP 在相机周围的球体内应用雾。<br /></li>
</ul>
</div>
</li>

<li><a id="orgdb0a97d"></a>Local Volumetric Fog<br />
<ul class="org-ul">
<li><a id="org476f317"></a>Limitations<br />
<div class="outline-text-8" id="text-org476f317">
<p>
为了改进性能，HDRP 沿着摄像机焦轴（focal axis）将 Local Volumetric Fog 体素化为 64 或 128 个切片。这导致了如下一些限制：<br />
</p>
<ul class="org-ul">
<li>Local Volumetric Fog 无法支持体积阴影（volumetric shadowing）. 如果你将 Local Volumetric Fog 放置到一个 Light 和一个表面之间，Local Fog Volume 不会减弱到达表面的光的亮度。<br /></li>
<li>在 Local Fog Volume 的边界可能会有明显的锯齿。为了隐藏该 aliasing artifacts，应该使用 Local Volumetric Fog 搭配 Global Fog。也可以使用 Density Mask 和 Blend Distance 来减弱 Local Fog Volume 边缘硬度<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7f320e1" class="outline-5">
<h5 id="org7f320e1">Shadow</h5>
<div class="outline-text-5" id="text-org7f320e1">
</div>
<div id="outline-container-orgb7b77bb" class="outline-6">
<h6 id="orgb7b77bb">Contact Shdows</h6>
<div class="outline-text-6" id="text-orgb7b77bb">
<ul class="org-ul">
<li><a href="./ShadowRendering.html#org64ea251">Constact Shadow</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org5fe4aaf"></a>Using Contact Shadows<br />
<div class="outline-text-7" id="text-org5fe4aaf">
<ol class="org-ol">
<li>HDRP Asset 的 Lighting/Shadows/Use Contact Shaodws 勾选 High Medium Low<br /></li>
<li>HDRP Global Settings/Frame Settings/Camera/Lighting/Contact Shadows<br /></li>
<li>HDRP Global Settings/Default Volume Profile Asset 添加 Contact Shadows Volume Override 并开启<br />
<ul class="org-ul">
<li>在场景中可以添加 Volume 对参数进行修改<br /></li>
</ul></li>
<li>在要渲染 Contact Shaodws 的 Light 组件上，勾选 Shaodws/Contact Shadows/Enable<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8773fcb" class="outline-6">
<h6 id="org8773fcb">Micro Shadows</h6>
<div class="outline-text-6" id="text-org8773fcb">
<ul class="org-ul">
<li><a href="./ShadowRendering.html#orga2443d2">Micro Shadow</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4ab3b17" class="outline-4">
<h4 id="org4ab3b17">PostProcess</h4>
<div class="outline-text-4" id="text-org4ab3b17">
</div>
<div id="outline-container-org16c5c13" class="outline-5">
<h5 id="org16c5c13">Exposure</h5>
</div>
</div>
<div id="outline-container-org673dfbe" class="outline-4">
<h4 id="org673dfbe">Q&amp;A</h4>
<div class="outline-text-4" id="text-org673dfbe">
</div>
<div id="outline-container-org4ed57aa" class="outline-5">
<h5 id="org4ed57aa">为什么 HDRP Global Settings 的 FrameSettings 部分又分了 Camera，Realtime Reflection、Baked or Custom Reflection 3 部分？</h5>
<div class="outline-text-5" id="text-org4ed57aa">
<p>
Camera 表示的是场景中摄像机渲染，需要按照效果需求和性能需求进行配置<br />
Realtime Reflection 表示的是实时的 Reflection Probe 的渲染，实时渲染反射会造成很大性能开销，所以，该渲染对应的配置需要低一些<br />
Baked or Custom Reflection 表示的是烘培的 Reflection Probe 的渲染，只在烘培阶段执行一次，所以，该渲染对应的配置可以高一些<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdf4f3fd" class="outline-2">
<h2 id="orgdf4f3fd">URP and HDRP Coexistence</h2>
<div class="outline-text-2" id="text-orgdf4f3fd">
</div>
<div id="outline-container-orgd7c74d5" class="outline-3">
<h3 id="orgd7c74d5">Feature comparison</h3>
<div class="outline-text-3" id="text-orgd7c74d5">
</div>
<div id="outline-container-org155e1f7" class="outline-4">
<h4 id="org155e1f7">Platform Support</h4>
</div>
<div id="outline-container-orge125447" class="outline-4">
<h4 id="orge125447">Lighting</h4>
</div>
</div>

<div id="outline-container-orgfab7132" class="outline-3">
<h3 id="orgfab7132">参考资料</h3>
<div class="outline-text-3" id="text-orgfab7132">
<ul class="org-ul">
<li>Render pipeline feature comparison <a href="https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html">https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html</a><br /></li>
<li>Scriptable Render Pipeline Coexistence <a href="https://portal.productboard.com/8ufdwj59ehtmsvxenjumxo82/c/1841-scriptable-render-pipeline-coexistence?utm_medium=social&amp;utm_source=portal_share">https://portal.productboard.com/8ufdwj59ehtmsvxenjumxo82/c/1841-scriptable-render-pipeline-coexistence?utm_medium=social&amp;utm_source=portal_share</a><br /></li>
<li>Scriptable Render Pipeline Coexistence Status <a href="https://forum.unity.com/threads/whats-the-status-of-coexistence-and-the-impact-on-features.1440463/">https://forum.unity.com/threads/whats-the-status-of-coexistence-and-the-impact-on-features.1440463/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9647968" class="outline-2">
<h2 id="org9647968">ERROR</h2>
<div class="outline-text-2" id="text-org9647968">
</div>
<div id="outline-container-org075b550" class="outline-4">
<h4 id="org075b550">Material 'Liquid' with Shader 'Custom/MyEffect/Unlit/Liquid' doesn't have a texture property '_MainTex' UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&amp;)</h4>
<div class="outline-text-4" id="text-org075b550">
<p>
URP 中使用_BaseMap 代替了_MainTex。并在_BaseMap 的前面标记了[MainTexture]。Editor 中有代码依赖_MainTex 命名，所以导致了该错误。<br />
在 Shader 'Custom/MyEffect/Unlit/Liquid' 的 Property 部分添加如下代码就可以解决该问题<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// ObsoleteProperties</span>
<span style="color: #2aa1ae; background-color: #292e34;">//[HideInInspector] _MainTex("BaseMap", 2D) = "white" {}</span>
<span style="color: #2aa1ae; background-color: #292e34;">//[HideInInspector] _Color("Base Color", Color) = (1, 1, 1, 1)</span>
</pre>
</div>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Material-mainTexture.html">https://docs.unity3d.com/ScriptReference/Material-mainTexture.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf5f1a53" class="outline-4">
<h4 id="orgf5f1a53">error CS0246: The type or namespace name 'UnityTestAttribute' could not be found</h4>
<div class="outline-text-4" id="text-orgf5f1a53">
<p>
HDRP package 移动到 Packages 目录下报该错误。安装 Test Framework package (com.unity.test-framework)可以解决该问题。<br />
com.unity.test-framework 会生成 UnityEngine.TestRunner 和 UnityEditor.TestRunner。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8bdc295" class="outline-2">
<h2 id="org8bdc295">Terminology</h2>
<div class="outline-text-2" id="text-org8bdc295">
</div>
<div id="outline-container-org4bd1642" class="outline-5">
<h5 id="org4bd1642">RTHandle</h5>
<div class="outline-text-5" id="text-org4bd1642">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@12.1/manual/rthandle-system-fundamentals.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@12.1/manual/rthandle-system-fundamentals.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org462d16c" class="outline-5">
<h5 id="org462d16c">Light Cluster</h5>
<div class="outline-text-5" id="text-org462d16c">
<p>
在 ray-traced 效果(如 Reflections, Global Illumination, Recursive Rendering 等)中，为了计算光弹射。HDRP 会使用一个数据结构来存储每个区域对应的光源集合。在光栅化中，HDRP 为不透明物体使用 tile 结构，为半透明物体使用 cluster 结构。对于 ray tracing 来说，这两种结构的主要不同在于 LightCluster 的 ray tracing 不是基于摄像机视锥体的。HDRP 为 Raytracing 构建了轴对齐的网格，每个 cell 中存储和该 cell 相交的光源列表。可以使用 Volume Light Cluster Override 来改变 HDRP 构建该结构的参数, 如下：<br />
<img src="./UnityRayTracing/hdrp-raytracing-light-cluster.png" alt="hdrp-raytracing-light-cluster.png" /><br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@12.1/manual/Ray-Tracing-Light-Cluster.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@12.1/manual/Ray-Tracing-Light-Cluster.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org51a8d60" class="outline-5">
<h5 id="org51a8d60">Render Graph</h5>
<div class="outline-text-5" id="text-org51a8d60">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@12.1/manual/render-graph-system.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@12.1/manual/render-graph-system.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6ee5fd6" class="outline-5">
<h5 id="org6ee5fd6">AOV</h5>
<div class="outline-text-5" id="text-org6ee5fd6">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.0/manual/AOVs.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.0/manual/AOVs.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgca819a9" class="outline-5">
<h5 id="orgca819a9">FPTL(Fine Pruned Tiled Lighting)</h5>
<div class="outline-text-5" id="text-orgca819a9">
<ul class="org-ul">
<li>2016 <a id="org6890eff"></a> Lighting/Fine Pruned Tiled Light Lists <a href="GPUProReference.html#ID-afc353de-fb3a-4107-8284-316c966080d5">Fine Pruned Tiled Light Lists</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9ca30ee" class="outline-2">
<h2 id="org9ca30ee">参考资料</h2>
<div class="outline-text-2" id="text-org9ca30ee">
<ul class="org-ul">
<li>CoreRP Library API <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@14.0/api/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@14.0/api/</a><br /></li>
<li>CoreRP Library Manual <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@14.0/manual/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@14.0/manual/</a><br /></li>
<li>Universal RP API <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/api/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/api/</a><br /></li>
<li>Universal RP Manual <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/</a><br /></li>
<li>High Definition Render Pipeline API <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/api/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/api/</a><br /></li>
<li>High Definition Render Pipeline Manual <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/manual/">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@16.0/manual/</a><br /></li>
<li>Graphics Github <a href="https://github.com/Unity-Technologies/Graphics">https://github.com/Unity-Technologies/Graphics</a><br /></li>
<li>Render pipeline feature comparison <a href="https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html">https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html</a><br /></li>
<li>Unity Platform Roadmap <a href="https://portal.productboard.com/8ufdwj59ehtmsvxenjumxo82/">https://portal.productboard.com/8ufdwj59ehtmsvxenjumxo82/</a><br /></li>
<li>Unity Graphics Github <a href="https://github.com/Unity-Technologies/Graphics">https://github.com/Unity-Technologies/Graphics</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'URP',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
