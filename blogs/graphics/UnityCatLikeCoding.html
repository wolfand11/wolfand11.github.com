<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-09-23 Mon 13:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UnityCatLikeCoding</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.github.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.github.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.github.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.github.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.github.io/res/blog-tools.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.github.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">UnityCatLikeCoding</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8c6a396">UnityCatLikeCoding</a>
<ul>
<li><a href="#orgfd6ba02">Basics</a>
<ul>
<li><a href="#org46cc543">Building a Graph</a></li>
<li><a href="#org3b98bb9">Mathematical Surfaces</a>
<ul>
<li><a href="#org24c7c99">Ripple</a></li>
<li><a href="#org621789f">Sphere</a></li>
<li><a href="#org6764948">Torus</a></li>
</ul>
</li>
<li><a href="#orge99aae2">Compute Shaders</a>
<ul>
<li><a href="#org9929ee1">Print Compute Buffer</a></li>
</ul>
</li>
<li><a href="#org6850e5a">Jobs</a>
<ul>
<li><a href="#org22304c1">Burst</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9f2dfb5">Mesh Basics &amp; Procedural Meshes</a>
<ul>
<li><a href="#orgf42814b">Mesh Basics</a></li>
<li><a href="#orge088b8c">Procedural Meshes</a></li>
</ul>
</li>
<li><a href="#orgd7e7c3f">Rendering &amp; Advanced Rendering &amp; CustomSRP</a>
<ul>
<li><a href="#org76b2dc1">Rendering</a>
<ul>
<li><a href="#org2f06cbd">Shader Fundamentals</a>
<ul>
<li><a href="#orga3a38ba">基础知识</a></li>
<li><a href="#org6354e57">Shader Semantics</a></li>
<li><a href="#orgd457e79">Shader Commands</a></li>
<li><a href="#org06aa74a">Unity 定义的变量</a></li>
<li><a href="#org63f0d27">Unity Shader 定义的宏</a></li>
<li><a href="#orgb62d35e">Unity Shader Compiler</a></li>
<li><a href="#orgdec899b">Unity shader 预编译命令</a></li>
<li><a href="#orgc1fe6bd">Shader 汇编指令</a></li>
<li><a href="#org1e5c1c0">pack and unpack data</a></li>
<li><a href="#org6479fe0">GPU 性能</a></li>
</ul>
</li>
<li><a href="#org7659915">Combining Textures</a>
<ul>
<li><a href="#org9bbf9c3">Linear Color Space</a></li>
</ul>
</li>
<li><a href="#orgf17f808">The First Light</a>
<ul>
<li><a href="#org0153c93">normal 从物体空间到世界空间的变换</a></li>
<li><a href="#org7795ef6">Tags LightMode=ForwardBase</a></li>
<li><a href="#orgc3cbf9e">BlinnPhong</a></li>
<li><a href="#org384df9d">Energy Conservation</a></li>
<li><a href="#orge0bfe92">Specular / Metallic Workflow</a></li>
</ul>
</li>
<li><a href="#org6c67b91">Multi Lights</a>
<ul>
<li><a href="#orge2ebcf9">Light Coord</a></li>
<li><a href="#org6db1b8d">Light Attenuation</a></li>
<li><a href="#org8451e75">Mixing Lights</a></li>
<li><a href="#orga7ebe88">Cookies</a></li>
<li><a href="#org7567f17">Vertex Lights</a></li>
<li><a href="#orgdd8ae4f">Spherical Harmonics</a></li>
</ul>
</li>
<li><a href="#org343ea68">Bumpiness</a>
<ul>
<li><a href="#org862e4e2">高度图转 normal map 的方法</a></li>
<li><a href="#org2df7f35">Normal 向量的插值</a></li>
<li><a href="#org930589b">Normal 贴图存储惯例</a></li>
<li><a href="#org4940555">DXT5nm 存储 normal 贴图</a></li>
<li><a href="#orgc2576af">缩放 Normal</a></li>
<li><a href="#org6695134">Blending Normals</a></li>
<li><a href="#org509c704">Tangent Space And Tangent Space To World Space</a></li>
</ul>
</li>
<li><a href="#org301a0ce">Shadows</a>
<ul>
<li><a href="#org1238770">方向光阴影</a></li>
<li><a href="#org82e0085">Spot Light Shadow</a></li>
<li><a href="#orgcbda3ec">相关宏定义</a></li>
<li><a href="#org5edccfa">参考资料</a></li>
</ul>
</li>
<li><a href="#orged32d72">Reflection</a>
<ul>
<li><a href="#orgd4d0eb4">Environment Mapping</a></li>
<li><a href="#org29a2f1f">Imperfect Reflections</a></li>
<li><a href="#org6f80d1c">Box Projection</a></li>
<li><a href="#orgdbe6048">Blending Reflection Probes</a></li>
<li><a href="#orgd928fb8">Bouncing Reflections</a></li>
</ul>
</li>
<li><a href="#org1a71296">ComplexMaterials &amp; More Complexity</a>
<ul>
<li><a href="#orgf744d6e">Emission</a></li>
<li><a href="#org9d1b460">Smoothness &amp; Metallic Map</a></li>
<li><a href="#orgc64be3d">Occlusion</a></li>
</ul>
</li>
<li><a href="#orgce50f8e">Transparency</a>
<ul>
<li><a href="#org3835774">Cutout</a></li>
<li><a href="#org7e2bba0">Semitransparent</a></li>
<li><a href="#org7df3a20">RenderType tag</a></li>
<li><a href="#org5779731">Fading vs Transparency</a></li>
</ul>
</li>
<li><a href="#org8c7a596">Semitransparent Shadows</a>
<ul>
<li><a href="#orgcd0f687">Cutout Shadow</a></li>
<li><a href="#org4ab8e8e">Transparenct Shadow</a></li>
</ul>
</li>
<li><a href="#orgc1c5383">Deferred Shading</a>
<ul>
<li><a href="#org4c1853c">Forward Path vs Deferred Path</a></li>
<li><a href="#orgbf6d7ec">Support Deferred Path</a></li>
<li><a href="#orgc3d5834">Deferred Reflections</a></li>
</ul>
</li>
<li><a href="#orge9a445b">Fog</a>
<ul>
<li><a href="#org1397f38">Forward Fog</a></li>
<li><a href="#orge45994c">Deferred Fog</a></li>
</ul>
</li>
<li><a href="#org470faef">Deferred Lights</a>
<ul>
<li><a href="#org3bada48">Light Shader</a></li>
<li><a href="#org5015fa8">Directional Lights</a></li>
<li><a href="#org6b7c7a7">Point Lights</a></li>
<li><a href="#orga6a8fbf">Spotlights</a></li>
<li><a href="#org71fcfc2">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgd3782da">Static Lighting</a>
<ul>
<li><a href="#org10e25f0">Lightmapping 光照贴图</a></li>
<li><a href="#orgd6f33e1">使用光照贴图</a></li>
<li><a href="#org05f9fb8">生成光照贴图</a></li>
<li><a href="#org2bcfda5">Directional Lightmaps 具有方向的光照贴图</a></li>
<li><a href="#orgdf00492">Light Probes</a></li>
<li><a href="#orgf75befb">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org775261a">Mixed Lighting</a>
<ul>
<li><a href="#org1c638f2">烘培光照贴图的优缺点</a></li>
<li><a href="#org18d001b">Baking Indirect Light</a></li>
<li><a href="#orga192855">Using a Shadowmask</a></li>
<li><a href="#orgdce4db7">Subtractive Shadows</a></li>
<li><a href="#orgd1006df">总结</a></li>
<li><a href="#org28fb102">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org91d80ab">RealtimeGI ProbeVolumes LOD Groups</a>
<ul>
<li><a href="#org25b502d">Realtime Globall Illumination</a></li>
<li><a href="#org73fda99">Light Probe Proxy Volumes</a></li>
<li><a href="#org64db08c">LOD Groups</a></li>
</ul>
</li>
<li><a href="#org0eea7f7">GPU Instancing</a>
<ul>
<li><a href="#org584baf3">Batching Instances</a></li>
<li><a href="#orge95aaf2">Mixing Material Properties</a></li>
</ul>
</li>
<li><a href="#orgc032892">Parallax</a>
<ul>
<li><a href="#org43b0903">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5a0b365">Advanced Rendering</a>
<ul>
<li><a href="#org37cdb17">Flat and Wireframe Shading</a>
<ul>
<li><a href="#org0f94691">Barycentric Coordinates</a></li>
<li><a href="#orgd33a503">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org8136984">Tessellation</a>
<ul>
<li><a href="#org2ae2a34">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org738c6a7">Surface Displacement</a></li>
<li><a href="#org0dd093b">Bloom</a>
<ul>
<li><a href="#orgfaf998e">利用 Downsampling Upsampling 模糊图片的原理</a></li>
</ul>
</li>
<li><a href="#orgb9c5ba4">Depth of Field</a>
<ul>
<li><a href="#org850801a">光学原理</a></li>
<li><a href="#orge0924fb">实现原理</a></li>
<li><a href="#orgea49d7e">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgd852369">FXAA</a>
<ul>
<li><a href="#org925cf78">SSAA MSAA</a></li>
<li><a href="#orgc8f724c">MLAA and SMAA</a></li>
<li><a href="#org0307c97">参考资源</a></li>
</ul>
</li>
<li><a href="#orgff16210">Triplanar Mapping</a>
<ul>
<li><a href="#org2268f5b">求解 Normal</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge313fd2">CustomSRP</a>
<ul>
<li><a href="#org6d611b1">CustomSRP 1.0</a>
<ul>
<li><a href="#org9a3698b">Custom Render Pipeline</a></li>
<li><a href="#org98f516b">Draw Calls</a></li>
<li><a href="#org7b90b15">Directianl Lights</a></li>
<li><a href="#org055af17">Directional Shadows</a></li>
<li><a href="#org4ef3ff2">Baked Light</a></li>
<li><a href="#orge5574e5">Shadow Masks</a></li>
<li><a href="#org210f3e3">LOD and Reflections</a></li>
<li><a href="#org179ab68">Complex Maps</a></li>
<li><a href="#orgccfcfba">Point and Spot Lights</a></li>
<li><a href="#orgb1d1fd1">Point and Spot Shadows</a></li>
<li><a href="#org6681e28">Post Processing</a></li>
<li><a href="#org043b616">HDR</a></li>
<li><a href="#orged98a5d">Color Grading</a></li>
<li><a href="#org655e61b">Multiple Cameras</a></li>
<li><a href="#orgc56108b">Particles</a></li>
<li><a href="#org6824234"><span class="todo TODO">TODO</span> FXAA</a></li>
</ul>
</li>
<li><a href="#org1f7a080">CustomSRP 2.0</a>
<ul>
<li><a href="#orgb2ead2b">CustomRenderPipeline 中管理 RenderGraph</a></li>
<li><a href="#org998c8df">使用 RenderGraph 方式来录制执行一个渲染 Pass</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgce7485b">MyTest</a>
<ul>
<li><a href="#org016aeb6">TestReplaceShader</a>
<ul>
<li><a href="#orgb6dd4a0">SetReplacementShader VS RenderWithShader</a></li>
<li><a href="#org99d5274">Q&amp;A</a>
<ul>
<li><a href="#orgdd0a092">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org95e5019">BilinearFiltering</a></li>
<li><a href="#orga30d3ae">SphereMapping</a>
<ul>
<li><a href="#orgae6644b">参考资料</a></li>
</ul>
</li>
<li><a href="#org5aacae4">Unity Universal SRP</a>
<ul>
<li><a href="#orgbdba2e0">Q&amp;A</a>
<ul>
<li><a href="#org3098ba3">为什么 GameView 下摄像机的后处理效果没有生效？</a></li>
</ul>
</li>
<li><a href="#orgdd745c1">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0b303fd">Q&amp;A</a>
<ul>
<li><a href="#orgb6ca463">如何判断投影矩阵是否为透视投影？</a></li>
<li><a href="#org3c8f09f">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</a></li>
<li><a href="#org587610f">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</a></li>
<li><a href="#org9e63074">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</a></li>
<li><a href="#orgef76ff5">为什么点光源阴影需要绘制场景 6 次？</a></li>
<li><a href="#org82716e8">Renderer.receiveShadows 是如何控制关闭接收阴影的？</a></li>
<li><a href="#org2ccf9d4">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</a></li>
</ul>
</li>
<li><a href="#org9696108">参考资料</a></li>
</ul>
</div>
</div>
<p>
UnityCatLikeCoding note.<br />
</p>
<div class="HTML" id="org74173e1">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org8c6a396" class="outline-2">
<h2 id="org8c6a396">UnityCatLikeCoding</h2>
<div class="outline-text-2" id="text-org8c6a396">
</div>
<div id="outline-container-orgfd6ba02" class="outline-3">
<h3 id="orgfd6ba02">Basics</h3>
<div class="outline-text-3" id="text-orgfd6ba02">
</div>
<div id="outline-container-org46cc543" class="outline-4">
<h4 id="org46cc543">Building a Graph</h4>
<div class="outline-text-4" id="text-org46cc543">
<ul class="org-ul">
<li>Heart Function <a href="https://zhidao.baidu.com/question/760898001022081444.html">https://zhidao.baidu.com/question/760898001022081444.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3b98bb9" class="outline-4">
<h4 id="org3b98bb9">Mathematical Surfaces</h4>
<div class="outline-text-4" id="text-org3b98bb9">
</div>
<div id="outline-container-org24c7c99" class="outline-5">
<h5 id="org24c7c99">Ripple</h5>
<div class="outline-text-5" id="text-org24c7c99">

<div id="orgd625f76" class="figure">
<p><img src="./UnityCatLikeCoding/00_ripple_func.png" alt="00_ripple_func.png" /><br />
</p>
</div>

<p>
下面文件可以交互演示：<br />
<a href="./UnityCatLikeCoding/00_ripple_func.ggb">./UnityCatLikeCoding/00_ripple_func.ggb</a><br />
</p>

<p>
下图可以更直观地理解各个参数的意义：<br />
<img src="./UnityCatLikeCoding/00_ripple_func1.jpg" alt="00_ripple_func1.jpg" /><br />
</p>

<ul class="org-ul">
<li>Wave Function <a href="https://www.khanacademy.org/science/physics/mechanical-waves-and-sound/mechanical-waves/v/wave-equation">https://www.khanacademy.org/science/physics/mechanical-waves-and-sound/mechanical-waves/v/wave-equation</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org621789f" class="outline-5">
<h5 id="org621789f">Sphere</h5>
<div class="outline-text-5" id="text-org621789f">
<p>
u-&gt;[-1, 1]<br />
v-&gt;[-1, 1]<br />
[cos(pi*u), v, sin(pi*u)]            可以绘制出一个圆<br />
</p>

<p>
r = cos(0.5*pi*v)<br />
[r * sin(pi*u), v, r*cos(pi*u)]      可以绘制出一个球<br />
</p>

<p>
将球的函数变换为如下形式，可以方便地对球的 r 进行变化：<br />
<img src="./UnityCatLikeCoding/00_sphere_func.png" alt="00_sphere_func.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org6764948" class="outline-5">
<h5 id="org6764948">Torus</h5>
<div class="outline-text-5" id="text-org6764948">

<div id="orgd034ba0" class="figure">
<p><img src="./UnityCatLikeCoding/00_torus_func1.jpeg" alt="00_torus_func1.jpeg" /><br />
</p>
</div>


<div id="orgfc8a3e4" class="figure">
<p><img src="./UnityCatLikeCoding/00_torus_func.png" alt="00_torus_func.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge99aae2" class="outline-4">
<h4 id="orge99aae2">Compute Shaders</h4>
<div class="outline-text-4" id="text-orge99aae2">
<p>
GPU 执行 compute shader 时，会将其工作划分为多个组，然后对这些组进行调度，使得这些组独立地并行运行。每个组又由多个 threads 组成，这些 threads 执行相同的计算，但是输入数据不同。我们需要在 computer shader 中使用 numthreads 属性来指定每个组包含多少个 threads，其需要 3 个整数参数。最简单的方式是将三个参数都指定为 1，表示每个组都只包含 1 个 thread。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">[numthreads(1,1,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FunctionKernel</span>() {}
</pre>
</div>

<p>
GPU 硬件包含的计算单元始终以 lockstep 方式运行特定固定数量的 thread。这些被称为 wraps 或 wavefronts。 如果一个组的 threads 数量小于 wrap 包含的 threads 大小，一些 threads 将空闲运行，浪费时间。如果一个组的线程的数量反而超过了 wrap 包含的 threads 大小，那么 GPU 将为每组分配更多的 wraps。 一般来说，64 个线程是一个很好的默认值，因为它与 AMD GPU 的 wrap 大小相匹配，而 NVidia GPU wrap 的大小为 32 个，因此后者将会为每个组分配两个 wraps。实际上，硬件更复杂，可以用线程组做更多的事情，在本节中，我们实现的 Graph 不会用到。<br />
</p>

<p>
numthreads 的三个参数可用于在一、二或三个维度上组织线程。 例如，(64, 1, 1) 在一个维度上给了我们 64 个线程，而 (8, 8, 1) 给了我们相同的数量，但呈现为 2D 8×8 方形网格。实现 GPUGraph 时，我们基于 2D UV 坐标定义我们的点，所以我们使用 [numthreads(8,8,1)]，Z 维度为 1。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">[numthreads(8,8,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FunctionKernel</span>(uint3 id:SV_DispatchThreadID) <span style="color: #2aa1ae; background-color: #292e34;">// &#27599;&#20010;thread&#36890;&#36807;&#19968;&#20010;3&#32500;&#25972;&#22411;&#21521;&#37327;&#21807;&#19968;&#34920;&#31034;</span>
{
}
</pre>
</div>

<p>
我们使用 computeShader.Dispatch 函数来发布 GPU compute shader 计算请求。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">groups</span> = Mathf.<span style="color: #bc6ec5; font-weight: bold;">CeilToInt</span>(resolution / 8f);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">kernelIdx</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsX</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsY</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsZ</span>
computeShader.<span style="color: #bc6ec5; font-weight: bold;">Dispatch</span>(0, groups, groups, 1);
</pre>
</div>


<div id="orge3af862" class="figure">
<p><img src="./UnityCatLikeCoding/computer_shader_terminology.jpg" alt="computer_shader_terminology.jpg" width="800px" /><br />
</p>
</div>


<div id="orgc1830fe" class="figure">
<p><img src="./UnityCatLikeCoding/00_computer_shader_terminology01.png" alt="00_computer_shader_terminology01.png" width="700px" /><br />
</p>
</div>

<p>
Tips:<br />
</p>
<ol class="org-ol">
<li>上图展示的不是 unity 中的 Dispatch, 而是 d3d 中的 ID3D11DeviceContext::Dispatch 函数<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Dispatch</span>([in] UINT ThreadGroupCountX, [in] UINT ThreadGroupCountY, [in] UINT ThreadGroupCountZ);
</pre>
</div>

<ol class="org-ol">
<li>SV_GroupIndex<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">dim.x dim.y &#20026; numthreads &#20013;&#25351;&#23450;&#30340;x&#65292;y&#30340;&#32500;&#24230;</span>
SV_GroupIndex = SV_GroupThreadID.z * dimx * dimy + SV_GroupThreadID.y * dimx + SV_GroupThreadID.x
</pre>
</div>

<ol class="org-ol">
<li>unity Dispatch 函数的接口如下<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c">public <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Dispatch</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">kernelIndex</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">threadGroupsX</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">threadGroupsY</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">threadGroupsZ</span>);
</pre>
</div>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch">https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch</a><br /></li>
<li><a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html</a><br /></li>
</ul>
</div>
<div id="outline-container-org9929ee1" class="outline-5">
<h5 id="org9929ee1">Print Compute Buffer</h5>
<div class="outline-text-5" id="text-org9929ee1">
<p>
Tips:<br />
使用 CommandBuffer 提交渲染命令时，命令是延迟执行的，所以需要使用 CommandBuffer 获取 ComputeBuffer 中的数据，否则获取到的数据是执行命令前的数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">PrintComputerBuffer</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #ce537a; font-weight: bold;">CommandBuffer</span> <span style="color: #7590db;">cmd</span>, <span style="color: #ce537a; font-weight: bold;">ComputeBuffer</span> <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">prefixInfo</span>) <span style="color: #4f97d7; font-weight: bold;">where</span> T : <span style="color: #4f97d7; font-weight: bold;">struct</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">DoPrint</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #ce537a; font-weight: bold;">T</span>[] <span style="color: #7590db;">tData</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">info</span> = <span style="color: #2d9574;">""</span>;
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; tData.Length; i++)
        {
            info += <span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">Format</span>(<span style="color: #2d9574;">" {0} "</span>, tData[i]);
        }
        Debug.<span style="color: #bc6ec5; font-weight: bold;">LogWarningFormat</span>(<span style="color: #2d9574;">"{0} : {1} - {2}"</span>, prefixInfo, buffer.count, info);
    };
    <span style="color: #4f97d7; font-weight: bold;">if</span> (cmd!=<span style="color: #a45bad;">null</span>)
    {
        cmd.<span style="color: #bc6ec5; font-weight: bold;">RequestAsyncReadback</span>(buffer, request =&gt;
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span> (request.hasError)
            {
                Debug.<span style="color: #bc6ec5; font-weight: bold;">LogWarningFormat</span>(<span style="color: #2d9574;">"{0} : {1}"</span>, prefixInfo, <span style="color: #2d9574;">"read buffer error"</span>);
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">tData</span> = request.<span style="color: #bc6ec5; font-weight: bold;">GetData</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
                <span style="color: #bc6ec5; font-weight: bold;">DoPrint</span>(tData.<span style="color: #bc6ec5; font-weight: bold;">ToArray</span>());
            }
        });
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #ce537a; font-weight: bold;">T</span>[] <span style="color: #7590db;">tData</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">T</span>[buffer.count * buffer.stride / Marshal.<span style="color: #bc6ec5; font-weight: bold;">SizeOf</span>(<span style="color: #4f97d7; font-weight: bold;">typeof</span>(T))];
        buffer.<span style="color: #bc6ec5; font-weight: bold;">GetData</span>(tData);
        <span style="color: #bc6ec5; font-weight: bold;">DoPrint</span>(tData);
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6850e5a" class="outline-4">
<h4 id="org6850e5a">Jobs</h4>
<div class="outline-text-4" id="text-org6850e5a">
<p>
一般来说，分形（Fractal）是具有自相似性的东西，简单来说，这意味着它的较小部分看起来与较大部分相似。 例如海岸线和大量植物。 例如，一棵树的树枝可能看起来像树干，只是更小。数学和几何上也有分形。 例如：Mandelbrot 和 Julia 集、Koch 雪花、Menger 海绵和 Sierpiński 三角形。<br />
</p>

<p>
可以通过从初始形状开始构建几何分形，然后将其较小的副本附加到自身，然后生成较小的自身版本，依此类推。这在理论上可以永远持续下去，创造出无限数量的形状，但仍占据有限的空间。 我们可以在 Unity 中创建类似的东西，但在性能下降太多之前只能达到几个层次。<br />
</p>
</div>

<div id="outline-container-org22304c1" class="outline-5">
<h5 id="org22304c1">Burst</h5>
<div class="outline-text-5" id="text-org22304c1">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Job adding two floating point values together</span>
[<span style="color: #bc6ec5; font-weight: bold;">BurstCompile</span>(FloatPrecision.Standard, FloatMode.Fast, CompileSynchronously=<span style="color: #a45bad;">true</span>)]
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> MyJob : <span style="color: #ce537a; font-weight: bold;">IJob</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">a</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">b</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">float</span>&gt; <span style="color: #7590db;">result</span>;

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>()
    {
        result[0] = a + b;
    }
}
</pre>
</div>

<ul class="org-ul">
<li>BurstCompile  显式指定 unity 使用 Burst 来编译我们的 MyJob job 结构体。当 job 第一次被执行时，其会被 Burst 在后台进行编译，此时会使用常规的 C#编译版本。当 Burst 编译完成后，才会切换到 Burst 编译版本。<br /></li>
<li>CompileSynchronously=true 表示强制 editor 立即编译 job 的 Burst 版本，unity 会卡住，直到编译完成。<br /></li>
<li>FloatMode.Fast FastMode 允许 Burst 对数学操作重新排序，例如 a+b*c 变为 b*c+a, 这样可以使用一条 madd 指令执行计算。通常对操作顺序进行重拍不会导致逻辑错误，但是由于浮点数限制，重拍可能导致结果有稍微变化。如果这些小的差异无关紧要，就可以开启 FastMode。<br /></li>
<li>FloatPrecision.Standard 浮点数精度会控制 sin, cos 这些函数的精度。虽然，本节中没有直接使用这些函数。但是创建 quaternions 会间接使用。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9f2dfb5" class="outline-3">
<h3 id="org9f2dfb5">Mesh Basics &amp; Procedural Meshes</h3>
<div class="outline-text-3" id="text-org9f2dfb5">
</div>
<div id="outline-container-orgf42814b" class="outline-4">
<h4 id="orgf42814b">Mesh Basics</h4>
</div>
<div id="outline-container-orge088b8c" class="outline-4">
<h4 id="orge088b8c">Procedural Meshes</h4>
</div>
</div>
<div id="outline-container-orgd7e7c3f" class="outline-3">
<h3 id="orgd7e7c3f">Rendering &amp; Advanced Rendering &amp; CustomSRP</h3>
<div class="outline-text-3" id="text-orgd7e7c3f">
</div>
<div id="outline-container-org76b2dc1" class="outline-4">
<h4 id="org76b2dc1">Rendering</h4>
<div class="outline-text-4" id="text-org76b2dc1">
</div>
<div id="outline-container-org2f06cbd" class="outline-5">
<h5 id="org2f06cbd">Shader Fundamentals</h5>
<div class="outline-text-5" id="text-org2f06cbd">
</div>
<div id="outline-container-orga3a38ba" class="outline-6">
<h6 id="orga3a38ba">基础知识</h6>
<div class="outline-text-6" id="text-orga3a38ba">
</div>
<ul class="org-ul">
<li><a id="org3507dd2"></a>MatrixType<br />
<div class="outline-text-7" id="text-org3507dd2">
<p>
可以参考 unitycatlikecoding\Rendering\Assets\MyTest\03TestShaderMatrix 工程中的展示效果。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Properties</span>
  {
      <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
      [Enum(NotDefineM,0,DefineM,1,DefineMWithVect,2)] DefineMatrix(<span style="color: #2d9574;">"DefineMatrix"</span>, <span style="color: #4f97d7; font-weight: bold;">Float</span>) = 0
  }
  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      <span style="color: #ce537a; font-weight: bold;">float4</span> translatedVertex = v.vertex + 0.5;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix != 0)
      {
          <span style="color: #ce537a; font-weight: bold;">float4x4</span> translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
              1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1
          );
          <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix == 1)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// unity shader&#20013;&#21521;&#37327;&#20026;&#21015;&#21521;&#37327;</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#30697;&#38453;&#27599;&#19968;&#21015;&#34920;&#31034;&#21464;&#25442;&#21518;&#26032;&#22352;&#26631;&#31995;&#30340;&#22522;&#22352;&#26631;&#36724;</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// xAxis = &#65288;2,1,0)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// yAxis = &#65288;0,1,0)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// zAxis = &#65288;0,0,2)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#30452;&#25509;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
              translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
                  2, 0, 0, 0,
                  1, 1, 0, 0,
                  0, 0, 2, 0,
                  0, 0, 0, 1
              );
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (DefineMatrix == 2)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;&#21521;&#37327;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> row0 = <span style="color: #ce537a; font-weight: bold;">float4</span>(2, 0, 0, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row1 = <span style="color: #ce537a; font-weight: bold;">float4</span>(1, 1, 0, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 2, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row3 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 0, 1);
              translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(row0,row1,row2,row3);
          }
          translatedVertex = <span style="color: #4f97d7;">mul</span>(translateM, translatedVertex);
      }
      o.wNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
      o.vertex = UnityObjectToClipPos(translatedVertex);
      o.uv = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
  {
      <span style="color: #ce537a; font-weight: bold;">fixed4</span> col = 1;
      <span style="color: #ce537a; font-weight: bold;">float3x3</span> colM = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
          1, 1, 0,
          0, 1, 0,
          0, 0, 1
      );
      <span style="color: #2aa1ae; background-color: #292e34;">// colM[0]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;0&#34892;&#30340;&#25968;&#25454;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// colM[2]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;2&#34892;&#30340;&#25968;&#25454;</span>
      col.rgb = colM[0];
      <span style="color: #ce537a; font-weight: bold;">float3</span> lightDir = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz;
      <span style="color: #4f97d7; font-weight: bold;">return</span> col*<span style="color: #4f97d7;">dot</span>(lightDir, i.wNormal);
      <span style="color: #2aa1ae; background-color: #292e34;">//return col;</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="org6761e53"></a>Array<br />
<div class="outline-text-7" id="text-org6761e53">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#22312;shader&#20013;&#20351;&#29992;&#25968;&#32452;&#24120;&#37327;</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> gaussianFilter3x3[9] =
{
    0.02487913, 0.10797294, 0.02487913,
    0.10797294, 0.46859173, 0.10797294,
    0.02487913, 0.10797294, 0.02487913,
};

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> gaussianFilter5x5[25] =
{
    0.00120229, 0.00828598, 0.01569749, 0.00828598, 0.00120229,
    0.00828598, 0.05710569, 0.10818462, 0.05710569, 0.00828598,
    0.01569749, 0.10818462, 0.20495178, 0.10818462, 0.01569749,
    0.00828598, 0.05710569, 0.10818462, 0.05710569, 0.00828598,
    0.00120229, 0.00828598, 0.01569749, 0.00828598, 0.00120229,
};
</pre>
</div>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/55409085/correct-way-for-declaring-a-unity-shader-array">https://stackoverflow.com/questions/55409085/correct-way-for-declaring-a-unity-shader-array</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgd29f157"></a>SV 含义<br />
<div class="outline-text-7" id="text-orgd29f157">
<p>
SV_POSITION、SV_TARGET 中 SV 表示 System Value<br />
SV_TARGET 表示 fragment shader 写入最终颜色值的默认目标对象，其实就是帧缓冲区对象<br />
</p>
</div>
</li>
<li><a id="orgf5cb2dc"></a>ST 含义<br />
<div class="outline-text-7" id="text-orgf5cb2dc">
<p>
贴图附加的 Tiling 和 Offset 属性。ST 表示 Scale 和 Translation.<br />
</p>
</div>
</li>
<li><a id="orgdf8042b"></a>贴图坐标系<br />
<div class="outline-text-7" id="text-orgdf8042b">
<p>
OpenGL 坐标原点在左下角<br />
D3D 坐标原点在左上角<br />
</p>
</div>
</li>

<li><a id="org20f9d4d"></a>MipMap 和 FilterMode<br />
<div class="outline-text-7" id="text-org20f9d4d">
<p>
MipMap       用于处理贴图图元密度大于像素密度的情况，一个像素对应多个贴图图元时，如果没有 mipmap，在多个贴图图元中采用一个图元而丢弃其他。有 mipmap 时，则使用更低分辨率的贴图让 像素密度和贴图密度相接近。<br />
FilterMode   用于处理贴图图元密度小于像素密度的情况，采样器会对靠近采样点的图元进行采样，然后对这些图元进行插值，来得到最终颜色值。<br />
</p>

<p>
Bilinear texture filtering  会对靠近采样点的四个图元进行加权平均。<br />
</p>

<p>
<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering</a><br />
</p>
</div>
</li>
<li><a id="orgdb7fec9"></a>TRANSFORM_TEX<br />
<div class="outline-text-7" id="text-orgdb7fec9">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#26041;&#27861;&#23450;&#20041;&#22312; UnityCG.cginc</span>
<span style="color: #bc6ec5;">#define</span> TRANSFORM_TEX(tex,name) (tex.xy * name##<span style="color: #7590db;">_ST</span>.xy + name##<span style="color: #7590db;">_ST</span>.zw)
</pre>
</div>
</div>
</li>
<li><a id="orgb13497a"></a>tex2Dbias tex2Dlod<br />
<div class="outline-text-7" id="text-orgb13497a">
<p>
tex2Dbias(s, t) : Samples a 2D texture after biasing the mip level by t.w.<br />
tex2Dlod(s, t)  : Samples a 2D texture with mipmaps. The mipmap LOD is specified in t.w.<br />
</p>

<ul class="org-ul">
<li>tex2Dbias <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias</a><br /></li>
<li>tex2Dlod <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod</a><br /></li>
<li><a href="https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/">https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/</a><br /></li>
</ul>
</div>
</li>
<li><a id="org9353fc3"></a>tex2Dproj<br />
<div class="outline-text-7" id="text-org9353fc3">
<p>
在对纹理进行采样之前，tex2Dproj 将输入的 UV xy 坐标除以其 w 坐标<br />
</p>

<ul class="org-ul">
<li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dproj">https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dproj</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/107627483">https://zhuanlan.zhihu.com/p/107627483</a><br /></li>
</ul>
</div>
</li>
<li><a id="org607b880"></a>SampleCmp SampleCmpLevelZero<br />
<div class="outline-text-7" id="text-org607b880">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">Object</span>.SampleCmp(
    <span style="color: #ce537a; font-weight: bold;">SamplerComparisonState</span> <span style="color: #7590db;">S</span>,
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">Location</span>,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36148;&#22270;&#22352;&#26631; &#35813;&#21442;&#25968;&#31867;&#22411;&#38543;&#36148;&#22270;&#31867;&#22411;&#21464;&#21270;  Texture1D=&gt;float Texture2D=&gt;float2</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">CompareValue</span>, <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27604;&#36739;&#30340;&#20540;</span>
    [<span style="color: #ce537a; font-weight: bold;">int</span> Offset]        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21487;&#36873;&#30340;&#36148;&#22270;&#22352;&#26631;&#20559;&#31227; &#35813;&#21442;&#25968;&#31867;&#22411;&#38543;&#36148;&#22270;&#31867;&#22411;&#21464;&#21270;  Texture1D=&gt;float Texture2D=&gt;float2</span>
);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36820;&#22238;&#20540;&#20026;[0,1]</span>
</pre>
</div>
<p>
使用 SampleCmp 对 Shadowmap 采样可以代替 shader 中执行的比较操作。详情参考下面文章:<br />
<a href="./.UnityShaderSourceCode.html#orgf8ed859">./.UnityShaderSourceCode.html#orgf8ed859</a><br />
</p>

<ul class="org-ul">
<li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-to-samplecmp">https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-to-samplecmp</a><br /></li>
</ul>
</div>
</li>
<li><a id="orge93a3dc"></a>atan2 atan<br />
<div class="outline-text-7" id="text-orge93a3dc">
<p>
HLSL atan2(y, x) == GLSL atan(y, x)<br />
</p>

<ul class="org-ul">
<li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-atan2">https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-atan2</a><br /></li>
<li><a href="https://docs.gl/sl4/atan">https://docs.gl/sl4/atan</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgb088c50"></a>lerp 函数意义<br />
<div class="outline-text-7" id="text-orgb088c50">

<div id="org2ec7102" class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp.png" alt="00_lerp.png" /><br />
</p>
</div>

<p>
x = 0 时，y = p; x = 1 时，y = q;<br />
lerp(p, q, x) lerp(p(1-x), q, x) lerp(p(1-x)^2, q, x) 三个函数，依次减弱 p 的效果。<br />
</p>


<div id="org3f9388a" class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp_func.png" alt="00_lerp_func.png" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/00_lerp_func.ggb">./UnityCatLikeCoding/00_lerp_func.ggb</a><br />
</p>
</div>
</li>
<li><a id="org9a2228a"></a>ddx ddy<br />
<div class="outline-text-7" id="text-org9a2228a">
<p>
ddx(var_i) 求出 var_i 变量在当前像素块 x 方向的变化量<br />
ddy(var_i) 求出 var_i 变量在当前像素块 y 方向的变化量<br />
</p>

<ul class="org-ul">
<li><a href="http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104">http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgb0fec96"></a>fwidth<br />
<div class="outline-text-7" id="text-orgb0fec96">
<p>
fwidth(var_i) = abs(ddx(var_i)) + abs(ddy(var_i))<br />
</p>
</div>
</li>
<li><a id="org5f83486"></a>smoothstep<br />
<div class="outline-text-7" id="text-org5f83486">
<p>
smoothstep(a, b, c) 平滑的阶跃函数，c&lt;=a 返回 0，c&gt;=b 返回 1<br />
</p>

<p>
t = (c-a)/(b-a)<br />
t = saturate(t)<br />
result = 3t^2 - 2t^3<br />
</p>

<p>
下图展示了 smoothstep 和 step 的对比：<br />
</p>

<div id="org4df15b5" class="figure">
<p><img src="./UnityCatLikeCoding/00_smoothstep.png" alt="00_smoothstep.png" width="800px" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/00step-smoothstep.ggb">./UnityCatLikeCoding/00step-smoothstep.ggb</a><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6354e57" class="outline-6">
<h6 id="org6354e57">Shader Semantics</h6>
<div class="outline-text-6" id="text-org6354e57">
</div>
<ul class="org-ul">
<li><a id="orgee1cb10"></a>Screen space pixel position: VPOS<br />
<div class="outline-text-7" id="text-orgee1cb10">
<p>
VPOS 输出的变量中保存的是屏幕像素点坐标，坐标值为整数值。<br />
VPOS 和 SV_POSITION 不能同时出现在 vout 中，需要使用 fin 将两者分离。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Screen Position"</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Properties</span>
      {
          <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
      }
      <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">Pass</span>
          {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">              #pragma</span> vertex vert
<span style="color: #bc6ec5;">              #pragma</span> fragment frag
<span style="color: #bc6ec5;">              #pragma</span> target 3.0
<span style="color: #bc6ec5;">              #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
              <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
              {
                  <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
              };

              <span style="color: #4f97d7; font-weight: bold;">struct</span> vout {
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                  <span style="color: #ce537a; font-weight: bold;">float4</span> outpos : <span style="color: #a45bad;">SV_POSITION</span>;
              };

              <span style="color: #4f97d7; font-weight: bold;">struct</span> fin
              {
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                  UNITY_VPOS_TYPE screenPos : <span style="color: #a45bad;">VPOS</span>;
              };

<span style="color: #bc6ec5;">              #define</span> vert_out vout
<span style="color: #bc6ec5;">              #define</span> frag_in fin

              vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata i)
              {
                  vert_out o;
                  o.uv = i.uv;
                  o.outpos = UnityObjectToClipPos(i.vertex);
                  <span style="color: #4f97d7; font-weight: bold;">return</span> o;
              }

              <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;

              <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (frag_in i) : <span style="color: #a45bad;">SV_Target</span>
              {
                  <span style="color: #2aa1ae; background-color: #292e34;">// screenPos.xy will contain pixel integer coordinates.</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// return i.screenPos.x &lt; _ScreenParams.x/2 ? 0 : 1;</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// use them to implement a checkerboard pattern that skips rendering</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// 4x4 blocks of pixels</span>

                  <span style="color: #2aa1ae; background-color: #292e34;">// checker value will be negative for 4x4 blocks of pixels</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// in a checkerboard pattern</span>
                  i.screenPos.xy = <span style="color: #4f97d7;">floor</span>(i.screenPos.xy * 0.25) * 0.5;
                  <span style="color: #ce537a; font-weight: bold;">float</span> checker = -<span style="color: #4f97d7;">frac</span>(i.screenPos.r + i.screenPos.g);

                  <span style="color: #2aa1ae; background-color: #292e34;">// clip HLSL instruction stops rendering a pixel if value is negative</span>
                  <span style="color: #4f97d7;">clip</span>(checker);

                  <span style="color: #2aa1ae; background-color: #292e34;">// for pixels that were kept, read the texture and output it</span>
                  <span style="color: #ce537a; font-weight: bold;">fixed4</span> c = <span style="color: #4f97d7;">tex2D</span> (<span style="color: #7590db;">_MainTex</span>, i.uv);
                  <span style="color: #4f97d7; font-weight: bold;">return</span> c;
              }
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="orgff5c382"></a>Face orientation: VFACE<br />
<div class="outline-text-7" id="text-orgff5c382">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Face Orientation"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_ColorFront</span> (<span style="color: #2d9574;">"Front Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (1,0.7,0.7,1)
        <span style="color: #7590db;">_ColorBack</span> (<span style="color: #2d9574;">"Back Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (0.7,1,0.7,1)
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #2aa1ae; background-color: #292e34;">// turn off backface culling</span>

            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0

            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">vert</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>) : <span style="color: #a45bad;">SV_POSITION</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
            }

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorFront</span>;
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorBack</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (<span style="color: #ce537a; font-weight: bold;">fixed</span> facing : <span style="color: #a45bad;">VFACE</span>) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// VFACE input positive for frontbaces,</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// negative for backfaces. Output one</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// of the two colors depending on that.</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> facing &gt; 0 ? <span style="color: #7590db;">_ColorFront</span> : <span style="color: #7590db;">_ColorBack</span>;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// or</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace = 1;
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    vFace = i.vFace &gt; 0 ? 1 : -1;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> vFace*2-1;
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org046392b"></a>error Shader error in 'Custom/MyEffect/GNoiseBall': Non system-generated input signature parameter () cannot appear after a system generated value. at line 98 (on d3d11)<br />
<div class="outline-text-8" id="text-org046392b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> wPos : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">fixed3</span> wNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
};
<span style="color: #2aa1ae; background-color: #292e34;">// &#23558;&#19978;&#38754;&#32467;&#26500;&#20307;&#22768;&#26126;&#25913;&#20026;&#19979;&#38754;&#26041;&#24335;&#65292;&#23601;&#21487;&#20197;&#36991;&#20813;&#35813;&#38169;&#35823;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> wPos : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">fixed3</span> wNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    UNITY_VERTEX_INPUT_INSTANCE_ID            <span style="color: #2aa1ae; background-color: #292e34;">// &#24320;&#21551;GPU Instance&#21518;&#65292;UNITY_VERTEX_INPUT_INSTANCE_ID&#38656;&#35201;&#25918;&#32622;&#22312;VFACE&#21069;&#38754;</span>
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
};
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org0a185fa"></a>参考资料<br />
<div class="outline-text-7" id="text-org0a185fa">
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd457e79" class="outline-6">
<h6 id="orgd457e79">Shader Commands</h6>
<div class="outline-text-6" id="text-orgd457e79">
</div>
<ul class="org-ul">
<li><a id="org20a727a"></a>AlphaToMask<br />
<div class="outline-text-7" id="text-org20a727a">
<p>
<a href="#org36a4aa4">AlphaToMask AlphaToCoverage 的原理是什么？</a><br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/SL-AlphaToMask.html">https://docs.unity3d.com/Manual/SL-AlphaToMask.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org06aa74a" class="outline-6">
<h6 id="org06aa74a">Unity 定义的变量</h6>
<div class="outline-text-6" id="text-org06aa74a">
<p>
_WorldSpaceLightPos0      世界空间 Light 位置<br />
_LightColor0              Light 颜色<br />
_WorldSpaceCameraPos      世界坐标摄像机位置<br />
_LightTexture0            Light 没有使用 Cookie 时，该变量存储衰减贴图。使用了 Cookie 时，存储 Cookie 贴图。 (Directional Light 没有衰减贴图)<br />
_LightTextureB0           Light 使用了 Cookie 时，该变量存储衰减贴图。 (Directional Light 没有衰减贴图)<br />
</p>

<p>
unity_WorldToShadow       float4x4[4]	用于 spot lights 或 方向光的 4 级级联阴影<br />
</p>

<p>
_LightShadowData          // 参考有道笔记 UnitySourceCode.md<br />
</p>

<p>
_ProjectionParams         <i>/ x=1 or -1(-1 if projection is flipped)  y=near z=far w=1/far<br />
_ScreenParams             /</i> x=widthPixels y=heightPixels z=1.0+1.0/width w=1.0+1.0/height<br />
_ZBufferParams 						<i>/ 用于线性化 ZBuffer 中的值，<br />
                          /</i> x=1-far/near<br />
                          <i>/ y=far/near<br />
                          /</i> z=x/far=(1-far/near)/far=(near-far)/(near*far)<br />
                          <i>/ w=y/far=(1/near)<br />
_XXX_TexelSize            /</i> Vector4(1 / tex_width, 1 / tex_height, tex_width, tex_height)<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">zc0</span>, <span style="color: #7590db;">zc1</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL would be this:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc0 = (1.0 - m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc1 = (1.0 + m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">D3D is this:</span>
zc0 = 1.0 - m_FarClip / m_NearClip;
zc1 = m_FarClip / m_NearClip;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now set _ZBufferParams with (zc0, zc1, zc0/m_FarClip, zc1/m_FarClip);</span>
</pre>
</div>

<p>
unity_SpecCube0_ProbePosition   第一个反射探针的位置，如果场景中不存在反射探针，则默认传递环境反射(Lighting / Environment Reflections / Source 下可以设置环境反射)的数据，环境反射。<br />
unity_SpecCube0_BoxMin          第一个反射探针对应的 Box 在世界空间中坐标最小值，反射探针为环境反射时，该值为 (Infinity, Infinity, Infinity, 1)<br />
unity_SpecCube0_BoxMax          第一个反射探针对应的 Box 在世界空间中坐标最大值，反射探针为环境反射时，该值为 (-Infinity, -Infinity, -Infinity, 1)<br />
unity_SpecCube0_BoxMin.w        存储了第一个反射探针和第二个反射探针的插值比例，1 表示全部使用第一个反射探针，0 表示全部使用第二个反射探针.(只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合)<br />
unity_SpecCube0_HDR.r           存储了反射探针的强度，对应反射探针的 Runtime setting/Intensity 和 Lighting/Scene/EnvironmentReflections/IntensityMultiplier(IntensityMultiplier 只是 Intensity 的系数，所以 FrameDebug 中看到的值和该值并不同)<br />
</p>


<div id="orgd5b3589" class="figure">
<p><img src="./UnityCatLikeCoding/01_08re_default_env_reflection_data.png" alt="01_08re_default_env_reflection_data.png" /><br />
</p>
</div>


<p>
<a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a><br />
</p>
<ul class="org-ul">
<li>_ZBufferParams values? <a href="https://forum.unity.com/threads/_zbufferparams-values.39332/">https://forum.unity.com/threads/_zbufferparams-values.39332/</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgc2adc85"></a>Unity shader matrix<br />
<div class="outline-text-7" id="text-orgc2adc85">
<p>
Unity camera space 和 OpenGL 习惯一致，view space 为：Z轴负方向为 forward 方向。而 Unity 物体空间和世界空间，都是以 Z 轴正方向为 forward 方向。<br />
Unity 中矩阵是列主序的，但是 FrameDebug 中显示的矩阵是行主序的。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4623529"></a>各种坐标系统惯例<br />
<div class="outline-text-8" id="text-org4623529">
<p>
<a href="../theory/ComputerGraphicMath.html#orgde50d8f">../theory/ComputerGraphicMath.html#orgde50d8f</a><br />
</p>
</div>
</li>
<li><a id="orgceeea76"></a>透视投影矩阵<br />
<div class="outline-text-8" id="text-orgceeea76">
<p>
<a href="../theory/ComputerGraphicMath.html#org2453edc">../theory/ComputerGraphicMath.html#org2453edc</a><br />
</p>
</div>
</li>
<li><a id="org681f40a"></a>UNITY_MATRIX_P(glstate_matrix_projection) and unity_CameraProjection<br />
<div class="outline-text-8" id="text-org681f40a">
<p>
unity_CameraProjection 等价与 Camera 组件的 projectionMatrix。其采用 OpenGL 形式的投影矩阵。<br />
UNITY_MATRIX_P 为对应于当前使用的 GraphicAPI 的渲染的投影矩阵（所谓渲染的投影矩阵，就是 shader 中使用的投影矩阵）。<br />
</p>

<p>
使用  GL.GetGPUProjectionMatrix 函数可以将 unity_CameraProjection 转化为适用于当前 GraphicAPI 的 UNITY_MATRIX_P。GL.GetGPUProjectionMatrix 的实现请参考文档 Unity Source Code.md 的 Unity Perspective Matrix 部分。<br />
</p>

<p>
下图来自 UnityCatLikeCoding/MyTest/03TestShaderMatrix 工程中的展示效果:<br />
<img src="./UnityCatLikeCoding/glstate_matrix_projection.jpg" alt="glstate_matrix_projection.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mat != <span style="color: #a45bad;">null</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">cam</span> = Camera.main;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (cam != <span style="color: #a45bad;">null</span>)
        {
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_WorldToLocalMat"</span>, cam.transform.worldToLocalMatrix);
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_WorldToCamMat"</span>, cam.worldToCameraMatrix);
            <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">customProjMat</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span>();
            <span style="color: #bc6ec5; font-weight: bold;">CalcGLProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">customProjMat</span>, cam);
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_CustomProjMat"</span>, customProjMat);
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_GPUProjMatTrue"</span>, GL.<span style="color: #bc6ec5; font-weight: bold;">GetGPUProjectionMatrix</span>(customProjMat, <span style="color: #a45bad;">true</span>));
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_GPUProjMatFalse"</span>, GL.<span style="color: #bc6ec5; font-weight: bold;">GetGPUProjectionMatrix</span>(customProjMat, <span style="color: #a45bad;">false</span>));
            mat.<span style="color: #bc6ec5; font-weight: bold;">SetMatrix</span>(<span style="color: #2d9574;">"_UnityCamProjMat"</span>, cam.projectionMatrix);
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalcMyProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">mat</span>, <span style="color: #ce537a; font-weight: bold;">Camera</span> <span style="color: #7590db;">cam</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (cam == <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">n</span> = cam.nearClipPlane;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">f</span> = cam.farClipPlane;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Fov Axis is Vertical</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">fovV</span> = Mathf.Deg2Rad * cam.fieldOfView;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">zoomy</span> = 1f / Mathf.<span style="color: #bc6ec5; font-weight: bold;">Tan</span>(fovV / 2f);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cam.aspect = width / height</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">zoomx</span> = zoomy / cam.aspect;
    mat.m00 = zoomx;
    mat.m11 = zoomy;
    mat.m22 = (f + n) / (f - n);
    mat.m23 = 1f;
    mat.m32 = 2 * f * n / (n - f);
    <span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">      zoomx  0      0            0</span>
<span style="color: #2aa1ae; background-color: #292e34;">      0      zoomy  0            0</span>
<span style="color: #2aa1ae; background-color: #292e34;">      0      0      (f+n)/(f-n)  1</span>
<span style="color: #2aa1ae; background-color: #292e34;">      0      0      2nf/(n-f)    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    *</span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">MyProjMat2GLProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">mat</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">flipZMat</span> = Matrix4x4.identity;
    flipZMat.m22 = -1;

    mat = flipZMat * mat;
    mat = mat.transpose;
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalcGLProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">mat</span>, <span style="color: #ce537a; font-weight: bold;">Camera</span> <span style="color: #7590db;">cam</span>)
{
    <span style="color: #bc6ec5; font-weight: bold;">CalcMyProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">mat</span>, cam);
    <span style="color: #bc6ec5; font-weight: bold;">MyProjMat2GLProjMat</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">mat</span>);
}
</pre>
</div>

<ul class="org-ul">
<li>What's difference between UNITY_MATRIX_P and unity_CameraProjection? <a href="https://forum.unity.com/threads/whats-difference-between-unity_matrix_p-and-unity_cameraprojection.1079549/">https://forum.unity.com/threads/whats-difference-between-unity_matrix_p-and-unity_cameraprojection.1079549/</a><br /></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html">https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgc05de60"></a>UNITY_MATRIX_V<br />
<div class="outline-text-8" id="text-orgc05de60">
<p>
unity 的 view matrix 采用 OpenGL 方式，不同 GraphicAPI 不会影响 view matrix。<br />
</p>

<p>
下图来自 UnityCatLikeCoding/MyTest/03TestShaderMatrix 工程中的展示效果:<br />
<img src="./UnityCatLikeCoding/unity-view-matrix.jpg" alt="unity-view-matrix.jpg" /><br />
</p>
</div>
</li>
<li><a id="org95bfa15"></a>参考资料<br />
<div class="outline-text-8" id="text-org95bfa15">
<ul class="org-ul">
<li>Shader 当中的坐标变化 <a href="https://liangz0707.github.io/whoimi/blogs/unity/Shader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E5%8C%96.html">https://liangz0707.github.io/whoimi/blogs/unity/Shader%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E5%8C%96.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org63f0d27" class="outline-6">
<h6 id="org63f0d27">Unity Shader 定义的宏</h6>
<div class="outline-text-6" id="text-org63f0d27">
<p>
shader 各个阶段对应的预处理器宏<br />
SHADER_STAGE_VERTEX<br />
SHADER_STAGE_FRAGMENT<br />
SHADER_STAGE_DOMAIN<br />
SHADER_STAGE_HULL<br />
SHADER_STAGE_GEOMETRY<br />
SHADER_STAGE_COMPUTE<br />
</p>

<p>
UNITY_COMPILER_HLSL                            使用 HLSL 编译时，定义该宏(for D3D or GLCore/GLES3/GLES platforms)<br />
UNITY_COMPILER_HLSL2GLSL                       使用 hlsl2glsl 编译时，定义该宏<br />
UNITY_COMPILER_CG                              使用 NVIDIA 的 Cg<br />
</p>

<p>
<a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a><br />
<a href="https://docs.unity3d.com/Manual/SL-ShadingLanguage.html">https://docs.unity3d.com/Manual/SL-ShadingLanguage.html</a><br />
</p>

<p>
UNITY_ENABLE_REFLECTION_BUFFERS                TODO-How?  延迟渲染模式下，延迟渲染反射球时会设置该变量开启。延迟渲染模式下，默认该变量是开启的，在 Graphics Settings 中将 DeferredReflections 选项选为 NoSupport 即可关闭。<br />
<a href="https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html">https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html</a><br />
</p>

<p>
UNITY_USE_NATIVE_HDR                           查看 2019 版本的源代码发现相关代码被注释掉了，UNITY_USE_NATIVE_HDR 应该永远都不会被开启<br />
</p>
<ul class="org-ul">
<li>UNITY_USE_NATIVE_HDR <a href="https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6">https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb62d35e" class="outline-6">
<h6 id="orgb62d35e">Unity Shader Compiler</h6>
<div class="outline-text-6" id="text-orgb62d35e">
<ul class="org-ul">
<li>Windows &amp; Microsoft platforms (DX11, DX12 and Xbox One) all use Microsoft’s HLSL compiler (currently d3dcompiler_47).<br /></li>
<li>OpenGL Core , OpenGL ES 3, OpenGL ES 2.0 and Metal use Microsoft’s HLSL followed by bytecode translation into GLSL or Metal, using HLSLcc.<br /></li>
<li>OpenGL ES 2.0 can use source level translation via hlsl2glslfork and glsl optimizer. This is enabled by adding #pragma prefer_hlsl2glsl gles<br /></li>
<li>Other console platforms use their respective compilers (e.g. PSSL on PS4).<br /></li>
<li>Surface Shaders use Cg 2.2 and MojoShader for code generation analysis step.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdec899b" class="outline-6">
<h6 id="orgdec899b">Unity shader 预编译命令</h6>
<div class="outline-text-6" id="text-orgdec899b">
<div class="org-src-container">
<pre class="src src-shader">multi_compile_local   <span style="color: #2aa1ae; background-color: #292e34;">// &#20026;&#26412;&#22320;&#21464;&#20307;&#65292;&#21482;&#21457;&#29983;&#22312;&#26412;Shader&#65292;&#38750;&#20840;&#23616;&#25511;&#21046;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc1fe6bd" class="outline-6">
<h6 id="orgc1fe6bd">Shader 汇编指令</h6>
<div class="outline-text-6" id="text-orgc1fe6bd">
</div>
<ul class="org-ul">
<li><a id="orgce45297"></a>D3D11 汇编指令<br />
<div class="outline-text-7" id="text-orgce45297">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mul result opt1 opt2</td>
<td class="org-left">opt1 乘 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">add result opt1 opt2</td>
<td class="org-left">opt1 加 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mad result opt1 opt2 opt3</td>
<td class="org-left">opt1 乘 opt2 再加 opt3 保存结果到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mov result opt1</td>
<td class="org-left">将 opt1 数据保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_sampler s0, mode_default</td>
<td class="org-left">创建贴图采样对象 s0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_resource_texture2d(float,float,float,float) t0</td>
<td class="org-left">创建 2D 贴图资源 t0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sample result.xyzw, uv.xyxx, t0.xyzw, s0</td>
<td class="org-left">使用 s0 采样器以 uv 为贴图坐标，对贴图资源 t0 进行采样将结果保存到 result 中</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orge3515a2"></a>Misc<br />
<div class="outline-text-7" id="text-orge3515a2">
<p>
rcp 求倒数<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1e5c1c0" class="outline-6">
<h6 id="org1e5c1c0">pack and unpack data</h6>
<div class="outline-text-6" id="text-org1e5c1c0">
<p>
urp 下面文件中，包含了很多 pack 和 unpack 方法。<br />
com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9253723"></a>pack unpack int<br />
<div class="outline-text-7" id="text-org9253723">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Packs an integer stored using at most 'numBits' into a [0..1] real.</span>
real <span style="color: #bc6ec5; font-weight: bold;">PackInt</span>(uint i, uint numBits)
{
    uint maxInt = (1u &lt;&lt; numBits) - 1u;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(i * rcp(maxInt));
}

<span style="color: #2aa1ae; background-color: #292e34;">// Unpacks a [0..1] real into an integer of size 'numBits'.</span>
uint <span style="color: #bc6ec5; font-weight: bold;">UnpackInt</span>(real f, uint numBits)
{
    uint maxInt = (1u &lt;&lt; numBits) - 1u;
    <span style="color: #4f97d7; font-weight: bold;">return</span> (uint)(f * maxInt + 0.5); <span style="color: #2aa1ae; background-color: #292e34;">// Round instead of truncating</span>
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6479fe0" class="outline-6">
<h6 id="org6479fe0">GPU 性能</h6>
<div class="outline-text-6" id="text-org6479fe0">
<ul class="org-ul">
<li>GPU GFLOPS <a href="https://gflops.surge.sh/">https://gflops.surge.sh/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7659915" class="outline-5">
<h5 id="org7659915">Combining Textures</h5>
<div class="outline-text-5" id="text-org7659915">
</div>
<div id="outline-container-org9bbf9c3" class="outline-6">
<h6 id="org9bbf9c3">Linear Color Space</h6>
<div class="outline-text-6" id="text-org9bbf9c3">
</div>
<ul class="org-ul">
<li><a id="org7bc8f2b"></a>Linear Color Space 原理<br />
<div class="outline-text-7" id="text-org7bc8f2b">
<p>
sRGB 颜色空间的 EOTF（ gamma 电信号到线性光信号的转换函数）通常被近似为 e<sup>2.2</sup><br />
sRGB 颜色空间的 OETF（线性光信号到 gamma 电信号的转换函数）通常被近似为 l<sup>1</sup><br />
准确的 EOTF 和 OETF 如下：<br />
<img src="./UnityCatLikeCoding/sRGB-gamma-linear-TF.jpg" alt="sRGB-gamma-linear-TF.jpg" /><br />
</p>

<p>
Gamma space 是指经过 gamma 矫正的颜色。gamma 矫正是对光照亮度的调整。最简单的方式是提升原始值某次幂，如 \(originalValue^{gamma}\) 。<br />
gamma=1 表示没有改变。gamma=2 表示对原始值求平方。<br />
</p>

<p>
这种转换原本是为了适应非线性的 CRT 显示器的。一个附加的好处是这种转换刚好和我们眼睛对不同光强度的敏感程度相一致。人眼对不同的暗的颜色要比不同的亮的颜色更加敏感。所以使用更多位数字存储暗颜色是很有意义的，求幂运算可以实现该需求，它会将比较小的值扩展到一个更大的范围，同时将较大的值压缩到一个小的范围。<br />
</p>

<p>
运用最广泛的图片颜色格式是 sRGB.<br />
</p>
<ul class="org-ul">
<li>Encoding with gamma 1/2.2 即 \(originalValue^{\frac{1}{2.2}} = originalValue^{0.45}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear-to-gamma.png" alt="01_03ct_linear-to-gamma.png" /><br /></li>
<li>Decoding with gamma 2.2 即 \(originalValue^{2.2}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma-to-linear.png" alt="01_03ct_gamma-to-linear.png" /><br /></li>
<li>伽马矫正函数图示<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_correct.png" alt="01_03ct_gamma_correct.png" /><br /></li>
</ul>

<p>
横坐标为编码前的颜色值，纵坐标为编码后的颜色值。蓝色的线表示线性编码前后颜色值不变。红色的线表示 Gamma 编码前后颜色值变大。以 0.5 为分界线，1/2.2 Gamma 编码后，[0-0.5] 被扩展到了 [0-0.7297&#x2026;] [0.5-1] 被压缩到了 [0.7297&#x2026; - 1]。1/2.2 Gamma 编码的图片要比 Linear 编码的图片亮度高。<br />
</p>

<p>
下面的 HTML 可用于 GammaToLinear 转换<br />
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #4f97d7; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
    &lt;<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;<span style="font-weight: bold; font-style: italic; text-decoration: underline;">&#39068;&#33394;&#36716;&#25442;</span>&lt;/<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"originColor"</span>&gt;
            TD &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oR"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oG"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oB"</span> value =<span style="color: #2d9574;">"64"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"newColor"</span>&gt;
            Qin &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nR"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nG"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nB"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">button</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"button"</span> <span style="color: #7590db;">onclick</span>=<span style="color: #2d9574;">'convertColor()'</span>&gt;&#36716;&#25442;&lt;/<span style="color: #bc6ec5; font-weight: bold;">button</span>&gt;
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

    &lt;<span style="color: #bc6ec5; font-weight: bold;">script</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text/javascript"</span>&gt;
     function convertColor()
     {
         var r = document.getElementById("oR").value / 255;
         var g = document.getElementById("oG").value / 255;
         var b = document.getElementById("oB").value / 255;

         //window.alert("test = " + r + b + g);
         document.getElementById("nR").value = Math.round(Math.pow(r, 1/2.2) * 255);
         document.getElementById("nG").value = Math.round(Math.pow(g, 1/2.2) * 255);
         document.getElementById("nB").value = Math.round(Math.pow(b, 1/2.2) * 255);
     }
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">script</span>&gt;

&lt;/<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// GammaToLinearSpace(col.rgb);  &#19979;&#38754;&#20195;&#30721;&#26159; GammaToLinearSpace &#30340;&#27719;&#32534;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat1.xyz = u_xlat0.xyz * u_xlat1.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}

<span style="color: #2aa1ae; background-color: #292e34;">// LinearToGammaSpace(col.rgb); &#19979;&#38754;&#20195;&#30721;&#26159; LinearToGammaSpace &#30340;&#27719;&#32534;&#20195;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat16_1.xyz = <span style="color: #4f97d7;">max</span>(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat16_2.xyz = <span style="color: #4f97d7;">log2</span>(u_xlat16_1.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat16_2.xyz = <span style="color: #4f97d7;">exp2</span>(u_xlat16_2.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = <span style="color: #4f97d7;">max</span>(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#26159; &#22270;&#29255;Gamma&#21644;Linear&#36716;&#25442;&#24037;&#20855;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>.<span style="color: #7590db;">Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEditor</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">LinearGammaConvert</span> : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">_assetPathList</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt;();
    [<span style="color: #bc6ec5; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageLinearToGamma"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">LinearToGamma</span>()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(path, <span style="color: #a45bad;">true</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }

    [<span style="color: #bc6ec5; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageGammaToLinear"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GammaToLinear</span>()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(path, <span style="color: #a45bad;">false</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(<span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">pathList</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(Selection.objects!=<span style="color: #a45bad;">null</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">obj</span> <span style="color: #4f97d7; font-weight: bold;">in</span> Selection.objects)
            {
                <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">GetAssetPath</span>(obj);
                <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span><span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(path))
                {
                    pathList.<span style="color: #bc6ec5; font-weight: bold;">Add</span>(path);
                }
            }
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">imgPath</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isToGamma</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(imgPath)) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">textureImportor</span> = AssetImporter.<span style="color: #bc6ec5; font-weight: bold;">GetAtPath</span>(imgPath) <span style="color: #4f97d7; font-weight: bold;">as</span> TextureImporter;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (textureImportor == <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        textureImportor.isReadable = <span style="color: #a45bad;">true</span>;
        textureImportor.sRGBTexture = <span style="color: #a45bad;">!</span>isToGamma;
        textureImportor.textureCompression = TextureImporterCompression.Uncompressed;
        textureImportor.<span style="color: #bc6ec5; font-weight: bold;">SaveAndReimport</span>();

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">texture</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">LoadAssetAtPath</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture2D</span>&gt;(imgPath);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">gammaValue</span> = isToGamma ? 0.4545f : 2.2f;
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">pixels</span> = texture.<span style="color: #bc6ec5; font-weight: bold;">GetPixels</span>();
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">i</span>=0; i&lt;pixels.Length; i++)
        {

            pixels[i].r = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].r, gammaValue);
            pixels[i].g = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].g, gammaValue);
            pixels[i].b = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].b, gammaValue);
        }
        texture.<span style="color: #bc6ec5; font-weight: bold;">SetPixels</span>(pixels);
        texture.<span style="color: #bc6ec5; font-weight: bold;">Apply</span>();
        System.IO.File.<span style="color: #bc6ec5; font-weight: bold;">WriteAllBytes</span>(imgPath, texture.<span style="color: #bc6ec5; font-weight: bold;">EncodeToTGA</span>());
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org66e17a2"></a>Unity Gamma and Linear workflow<br />
<ul class="org-ul">
<li><a id="orged2e08e"></a>Gamma Workflow<br />
<div class="outline-text-8" id="text-orged2e08e">
<p>
gamma space 下 shader 中的值全部为 gamma 编码，输出到 swapchain RT 时，不需要硬件执行 gamma 编码，所以 framebuffer RT format 为 B8G8R8A8_UNORM<br />
贴图的 sRGB 设置不会有任何作用，贴图都是 sRGB。当 color channel 值为 0.5，从 shader 中对贴图采样得到的值也是 0.5。<br />
</p>
</div>
</li>
<li><a id="orgd4443c4"></a>Linear Workflow<br />
<div class="outline-text-8" id="text-orgd4443c4">
<p>
linear space 下 shader 中的值全部为 linear 值，输出到 swapchain RT 时，需要硬件执行 gamma 编码，所以 swapchain framebuffer RT format 为 B8G8R8A8_SRGB<br />
贴图的 sRGB 设置会生效。当 color channel 值为 0.5，若贴图设置为 sRGB 时，从 shader 中对贴图采样得到的值为 0.21223。若贴图未设置为 sRGB，从 shader 中对贴图采样得到的值为 0.5。<br />
</p>

<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/understanding-srgb-and-gamma-corrected-values-in-the-render-pipeline.783224/">https://forum.unity.com/threads/understanding-srgb-and-gamma-corrected-values-in-the-render-pipeline.783224/</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgfd38b0d"></a>DetailTex 叠加到 MainTex 上为什么需要乘二？<br />
<div class="outline-text-7" id="text-orgfd38b0d">
<p>
MainTex 颜色范围为[0-1] DetailTex 颜色范围也为[0-1], 如果将 DetailTex 制作为灰度图并且颜色值取 0.5，那么 MainTex*DetailTex*2 可以保证图片亮度不会变化。DetailTex 颜色值小于 0.5 的地方就会减低颜色亮度，大于 0.5 的地方就会提高颜色亮度。<br />
但是，当 Unity 引擎切换到线性空间，乘二是不正确的。DetailTex 转化为线性空间时，0.5 的 DetailTex 颜色值会变为 \(0.5^{2.2}=0.2176\) ,乘二后为 0.4352, 所以颜色亮度会减低。最好的解决方案是当 Unity 引擎切换到线性空间时，应该乘 \(frac{1}{0.5^{2.2}}=frac{1}{0.2176}=4.5956\)<br />
Unity 中 unity_ColorSpaceDouble 用来处理不同的颜色空间乘不同的值。<br />
</p>
</div>
</li>
<li><a id="orga5bdca4"></a>SetVector SetColor<br />
<div class="outline-text-7" id="text-orga5bdca4">
<p>
GammaSpace 下，SetVector SetColor 效果没有差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_SetValue.png" alt="01_03ct_gamma_SetValue.png" /><br />
LinearSpace 下，SetVector SetColor 效果会有明显差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear_SetValue.png" alt="01_03ct_linear_SetValue.png" /><br />
</p>

<p>
编辑器中设置的值和 Shader Property List 中设置的值是相同的。<br />
线性空间下，通过 SetColor 传入的值被认为是经过 Gamma=1/2.2=0.4545 编码的值，Unity 引擎会对该值进行 Gamma=2.2 的编码(对 Gamma=1/2.2 进行解码)，从而将 Gamma 空间的值转换为线性空间。所以，SetVector(0.5^2.2, 0, 0, 0) 和 SetColor(0.5, 0, 0, 0)的效果是等价的。<br />
</p>

<ul class="org-ul">
<li>官网文档说明 <a href="https://docs.unity3d.com/ScriptReference/Material.SetVector.html">https://docs.unity3d.com/ScriptReference/Material.SetVector.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="org2edd4a9"></a>参考资料<br />
<div class="outline-text-7" id="text-org2edd4a9">
<ul class="org-ul">
<li>Linear or gamma workflow <a href="https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html">https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html</a><br /></li>
<li>Gamma 空间是什么，为什么我们需要它 <a href="https://blog.csdn.net/qq_18229381/article/details/78053018">https://blog.csdn.net/qq_18229381/article/details/78053018</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf17f808" class="outline-5">
<h5 id="orgf17f808">The First Light</h5>
<div class="outline-text-5" id="text-orgf17f808">
</div>
<div id="outline-container-org0153c93" class="outline-6">
<h6 id="org0153c93">normal 从物体空间到世界空间的变换</h6>
<div class="outline-text-6" id="text-org0153c93">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// obj to world</span>
i.normal = <span style="color: #4f97d7;">mul</span>(<span style="color: #4f97d7;">transpose</span>((<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject), v.normal);

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float3</span> UnityObjectToWorldNormal( <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float3</span> norm )
{
<span style="color: #bc6ec5;">#ifdef</span> UNITY_ASSUME_UNIFORM_SCALING
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToWorldDir</span>(norm);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &#25913;&#21464;&#24038;&#20056; &#21491;&#20056;&#39034;&#24207; &#31561;&#20215;&#20110; &#30697;&#38453;&#36716;&#32622;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// mul(IT_M, norm) =&gt; mul(norm, I_M) =&gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)}</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(<span style="color: #4f97d7;">mul</span>(norm, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject));
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>

<p>
<a href="./PhysicallyBasedRendering.html#org99f3740">Normal 和 Vector 的不同</a><br />
</p>
</div>
</div>
<div id="outline-container-org7795ef6" class="outline-6">
<h6 id="org7795ef6">Tags LightMode=ForwardBase</h6>
<div class="outline-text-6" id="text-org7795ef6">
<p>
定义该 Tags 才可以在 shader 中访问场景中主方向光的信息。<br />
</p>
</div>
</div>

<div id="outline-container-orgc3cbf9e" class="outline-6">
<h6 id="orgc3cbf9e">BlinnPhong</h6>
<div class="outline-text-6" id="text-orgc3cbf9e">
<p>
视角不逆光时的显示效果如下：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone.png" alt="01_04fl_blinnphone.png" /><br />
</p>

<p>
视角逆光时会有显示错误。错误如下图：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone_error.png" alt="01_04fl_blinnphone_error.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org384df9d" class="outline-6">
<h6 id="org384df9d">Energy Conservation</h6>
<div class="outline-text-6" id="text-org384df9d">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Unity &#23454;&#29616;&#30340;&#33021;&#37327;&#23432;&#24658; UnityStandardUtils.cginc</span>

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge0bfe92" class="outline-6">
<h6 id="orge0bfe92">Specular / Metallic Workflow</h6>
<div class="outline-text-6" id="text-orge0bfe92">
</div>
<ul class="org-ul">
<li><a id="orga4ee241"></a>Specular Workflow<br />
<div class="outline-text-7" id="text-orga4ee241">
<p>
Specular Workflow 中将 Specular Color 的强度提高来实现金属材质。将 Specular Color 的强度减弱来实现非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#40664;&#35748;&#26159; Specular Workflow</span>
<span style="color: #bc6ec5;">#ifndef</span> UNITY_SETUP_BRDF_INPUT
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT SpecularSetup
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData SpecularSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> specGloss = SpecularGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor = specGloss.rgb;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = specGloss.a;

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = EnergyConservationBetweenDiffuseAndSpecular (Albedo(i_tex), specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #2aa1ae; background-color: #292e34;">// Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524; specColor &#19981;&#26159;&#28784;&#24230;&#22270;&#65292;diffuse &#39068;&#33394;&#20250;&#26174;&#31034;&#24322;&#24120;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org62d0742"></a>Metallic Workflow<br />
<div class="outline-text-7" id="text-org62d0742">
<p>
Metallic Workflow 中通过金属度来实现金属和非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#33258;&#24049;&#30340; shader &#20013;&#23450;&#20041; UNITY_SETUP_BRDF_INPUT = MetallicSetup &#26469;&#25351;&#23450;&#20351;&#29992; Metallic &#27969;&#31243;</span>
<span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT MetallicSetup
<span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData MetallicSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half2</span> metallicGloss = MetallicGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half</span> metallic = metallicGloss.x;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = metallicGloss.y; <span style="color: #2aa1ae; background-color: #292e34;">// this is 1 minus the square root of real roughness m.</span>

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = DiffuseAndSpecularFromMetallic (Albedo(i_tex), metallic, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DiffuseAndSpecularFromMetallic (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half</span> metallic, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    specColor = <span style="color: #4f97d7;">lerp</span> (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);
    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);

    <span style="color: #2aa1ae; background-color: #292e34;">// &#36820;&#22238; diffuseColor</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// metallic=1 diffuseColor=0                             oneMinusReflectivity=0</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// metallic=0 diffuseColor=albedo*oneMinusDielectricSpec oneMinusReflectivity=oneMinusDielectricSpec</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
}

<span style="color: #2aa1ae; background-color: #292e34;">// &#24120;&#37327;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.5, 0.5, 0.5, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(2.0, 2.0, 2.0, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.22, 0.707, 0.071, 0.0) <span style="color: #2aa1ae; background-color: #292e34;">// Legacy: alpha is set to 0.0 to specify gamma mode</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">// Linear values</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.214041144, 0.214041144, 0.214041144, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(4.59479380, 4.59479380, 4.59479380, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.04, 0.04, 0.04, 1.0 - 0.04) <span style="color: #2aa1ae; background-color: #292e34;">// standard dielectric reflectivity coef at incident angle (= 4%)</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.0396819152, 0.458021790, 0.00609653955, 1.0) <span style="color: #2aa1ae; background-color: #292e34;">// Legacy: alpha is set to 1.0 to specify linear mode</span>
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> OneMinusReflectivityFromMetallic(<span style="color: #ce537a; font-weight: bold;">half</span> metallic)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// &#25512;&#23548;&#65306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// We'll need oneMinusReflectivity, so</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// store (1-dielectricSpec) in unity_ColorSpaceDielectricSpec.a, then</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//                  = alpha - metallic * alpha</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusDielectricSpec = unity_ColorSpaceDielectricSpec.a;
    <span style="color: #2aa1ae; background-color: #292e34;">// metallic=0 Reflectivity=DielectricSpec OneMinusReflectivity=oneMinusDielectricSpec</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// metallic=1 Reflectivity=1              OneMinusReflectivity=0</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6c67b91" class="outline-5">
<h5 id="org6c67b91">Multi Lights</h5>
<div class="outline-text-5" id="text-org6c67b91">
</div>
<div id="outline-container-orge2ebcf9" class="outline-6">
<h6 id="orge2ebcf9">Light Coord</h6>
<div class="outline-text-6" id="text-orge2ebcf9">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord4 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex));
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    ( (a.<span style="color: #7590db;">_LightCoord</span>.z &gt; 0) * UnitySpotCookie(a.<span style="color: #7590db;">_LightCoord</span>) * UnitySpotAttenuate(a.<span style="color: #7590db;">_LightCoord</span>.xyz) * SHADOW_ATTENUATION(a) )
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx)
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a)
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a)
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord2 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xy;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#define</span> UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2)
<span style="color: #bc6ec5;">#define</span> LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2)
<span style="color: #2aa1ae; background-color: #292e34;">// vertex shader &#20013;&#65292;&#35745;&#31639;_LightCoord</span>
<span style="color: #bc6ec5;">#define</span> UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord)
<span style="color: #bc6ec5;">#define</span> TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6db1b8d" class="outline-6">
<h6 id="org6db1b8d">Light Attenuation</h6>
<div class="outline-text-6" id="text-org6db1b8d">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #ifdef</span> POINT
  <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
  unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
      unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
            <span style="color: #2aa1ae; background-color: #292e34;">// &#25353;&#29031;&#36317;&#31163;&#30340;&#24179;&#26041;&#34928;&#20943;</span>
      <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> SPOT
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
      unityShadowCoord4x4 unity_WorldToLight;
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotCookie(unityShadowCoord4 LightCoord)
      {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679;&#26102;&#20174;&#40784;&#27425;&#22352;&#26631;&#31995;&#36716;&#25442;&#21040;&#27431;&#25289;&#22352;&#26631;&#31995;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20559;&#31227; 0.5 &#36825;&#26679;&#28783;&#20809;&#22352;&#26631;&#31995;&#21407;&#28857;&#23601;&#21644;&#22270;&#29255;&#20013;&#24515;&#28857;&#23545;&#24212;&#20102;</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, LightCoord.xy / LightCoord.w + 0.5).w;
      }
      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotAttenuate(unityShadowCoord3 LightCoord)
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(LightCoord, LightCoord).xx).r;
      }
<span style="color: #bc6ec5;">      #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1))
<span style="color: #bc6ec5;">      #else</span>
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
          DECLARE_LIGHT_COORD(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = (lightCoord.z &gt; 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = UNITY_SHADOW_ATTENUATION(input, worldPos);
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> POINT_COOKIE
      <span style="color: #ce537a; font-weight: bold;">samplerCUBE_float</span> <span style="color: #7590db;">_LightTexture0</span>;
      unityShadowCoord4x4 unity_WorldToLight;
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
<span style="color: #bc6ec5;">      #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz
<span style="color: #bc6ec5;">      #else</span>
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
          DECLARE_LIGHT_COORD(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
          <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> DIRECTIONAL_COOKIE
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xy
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgf2c00e9"></a>Point Light<br />
<div class="outline-text-7" id="text-orgf2c00e9">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> lightVector = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz - i.worldPos;
light.dir = <span style="color: #4f97d7;">normalize</span>(lightVector);
<span style="color: #2aa1ae; background-color: #292e34;">// &#20998;&#27597;&#20013;&#21152; 1 &#26159;&#20026;&#20102;&#36991;&#20813;&#29289;&#20307;&#21040;&#20809;&#28304;&#36317;&#31163;&#23567;&#20110; 1 &#26102;&#65292;&#20809;&#29031;&#24378;&#24230;&#34987;&#25918;&#22823;</span>
<span style="color: #ce537a; font-weight: bold;">half</span> attenuation = 1 / (1 + <span style="color: #4f97d7;">dot</span>(lightVector, lightVector));
light.color = <span style="color: #7590db;">_LightColor0</span>.rgb * attenuation;
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8451e75" class="outline-6">
<h6 id="org8451e75">Mixing Lights</h6>
<div class="outline-text-6" id="text-org8451e75">
<p>
通过增加 shader 变体来实现对混合灯光的支持。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT
</pre>
</div>
</div>
</div>
<div id="outline-container-orga7ebe88" class="outline-6">
<h6 id="orga7ebe88">Cookies</h6>
<div class="outline-text-6" id="text-orga7ebe88">
<p>
Spot Light 默认支持 Cookie，Spot Light 的形状是通过 Cookie 来实现。SpotLight 的 Cookie 贴图的 Wrap 模式采用 Clamp。<br />
Direcional 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图的 Wrap 模式采用 Repeat。<br />
Point 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图是 Cube 贴图，Wrap 模式采用 Clamp。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#31561;&#20215;&#20110;  #pragma multi_compile_fwdadd</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT DIRECTIONAL_COOKIE POINT_COOKIE
</pre>
</div>

<ul class="org-ul">
<li>multi_compile_fwdbase 变体 <a href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7567f17" class="outline-6">
<h6 id="org7567f17">Vertex Lights</h6>
<div class="outline-text-6" id="text-org7567f17">
<p>
灯光数量增加后，drawcall 数量会成倍增加。Unity 可以设置逐像素光照的数量。如果将超出数量限制的光照直接不进行计算，会导致明显的显示错误，可以采用更廉价的顶点光照来代替像素光照。<br />
Unity 在 Base Pass 中实现顶点光照。引擎会寻找包含 VERTEXLIGHT_ON 关键字的 Base Pass 着色器。<br />
顶点光照只支持 点光源，方向光和聚光灯都能在顶点着色器中计算。<br />
在 Light 的 RenderMode 属性中，可以设置重要类型，Important 类型的光照总是逐像素光照，Not Important 类型的光照永远不会被当作逐像素光照，Auto 类型的光照其重要性由引擎来决定。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// UnityCG.cginc</span>
<span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#20989;&#25968;&#36820;&#22238;&#20102;4&#20010;&#28857;&#20809;&#28304;&#23545;&#20110;&#24403;&#21069;&#39030;&#28857;&#30340;&#32508;&#21512;&#20809;&#29031;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#39030;&#28857;&#20013;&#35745;&#31639; 4 &#20010;&#28857;&#20809;&#28304;&#20809;&#29031;&#65292;&#24403;&#20809;&#28304;&#25968;&#30446;&#19981;&#36275; 4 &#20010;&#26102;&#65292;&#35745;&#31639;&#28040;&#32791;&#20381;&#28982;&#26159; 4 &#20010;&#20809;&#29031;&#30340;&#35745;&#31639;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way.</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">Shade4PointLights</span> (
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosX, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosY, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosZ,
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor0, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor1, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor2, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor3,
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightAttenSq,
    <span style="color: #ce537a; font-weight: bold;">float3</span> pos, <span style="color: #ce537a; font-weight: bold;">float3</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// to light vectors</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightX = lightPosX - pos.x;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightY = lightPosY - pos.y;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightZ = lightPosZ - pos.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// squared lengths</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> lengthSq = 0;
    lengthSq += toLightX * toLightX;
    lengthSq += toLightY * toLightY;
    lengthSq += toLightZ * toLightZ;
    <span style="color: #2aa1ae; background-color: #292e34;">// don't produce NaNs if some vertex position overlaps with the light</span>
    lengthSq = <span style="color: #4f97d7;">max</span>(lengthSq, 0.000001);

    <span style="color: #2aa1ae; background-color: #292e34;">// NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> ndotl = 0;
    ndotl += toLightX * normal.x;
    ndotl += toLightY * normal.y;
    ndotl += toLightZ * normal.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// correct NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> corr = <span style="color: #4f97d7;">rsqrt</span>(lengthSq);
    ndotl = <span style="color: #4f97d7;">max</span> (<span style="color: #ce537a; font-weight: bold;">float4</span>(0,0,0,0), ndotl * corr);
    <span style="color: #2aa1ae; background-color: #292e34;">// attenuation lightAttenSq &#29992;&#20110;&#25913;&#36827;&#39030;&#28857;&#20809;&#29031;&#30340;&#25928;&#26524;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
    <span style="color: #ce537a; font-weight: bold;">float4</span> diff = ndotl * atten;
    <span style="color: #2aa1ae; background-color: #292e34;">// final color</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> col = 0;
    col += lightColor0 * diff.x;
    col += lightColor1 * diff.y;
    col += lightColor2 * diff.z;
    col += lightColor3 * diff.w;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdd8ae4f" class="outline-6">
<h6 id="orgdd8ae4f">Spherical Harmonics</h6>
<div class="outline-text-6" id="text-orgdd8ae4f">
</div>
<ul class="org-ul">
<li><a id="orgc44646a"></a>原理概述<br />
<div class="outline-text-7" id="text-orgc44646a">
<p>
球谐函数背后的思想是你可以只用一个连续函数来描述所有入射光在某个点的效果，这个函数定义在球的表面。<br />
通常来说，这个函数是用球面坐标表示的。但是也可以使用 3D 坐标，这样我们就可以使用物体的 normal 向量对函数进行采样了。<br />
为了创建这样的函数，你必须在所有方向上对光照强度进行采样，然后将结果转换为单个连续的函数。为了达到完美模拟，你必须为表面的每个点做这样的工作。这当然是无法做到的，所以我们只能做到近似效果。<br />
</p>

<p>
首先，我们只从对象本地原点的角度定义函数。光照条件在随物体表面变化不大时效果还是可以的。小物体，或者光照比较弱或光照离物体很远时满足这种情况。幸运的是，这恰好是那些不值得逐像素计算的光照或者顶点光照。<br />
其次，我们必须近似函数自身。你可以将任何连续的函数分解为多个不同频率的函数。这些被称为波段。对于任意一个函数，你可能需要无数个波段来模拟。<br />
</p>

<p>
<a href="../graphics/PhysicallyBasedRendering.html#org78ade6f">球谐函数</a><br />
</p>
</div>
</li>
<li><a id="org5891299"></a>Spherical Harmonics Bands<br />
<div class="outline-text-7" id="text-org5891299">
<p>
第一个基带：使用一个常量颜色值是最简单近似灯光的方式。光照在各个方向上都是相同的。使用单个子函数表示，这个子函数为一个常量值。<br />
第二个基带：第二个基带引入了线性方向光，对于每一个轴向，其描述了最多的光照来自哪儿。使用三个函数表示，每个函数包含一个我们法线的坐标值，并乘上一个常量。<br />
第三个基带：第三个基带更加复杂，它有 5 个函数组成。这些函数都是二次方的，他们包含了两个法线坐标的乘积。<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">l band NO</th>
<th scope="col" class="org-right">sub func count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
下表为最大阶数 n 下，对应所有基带的子函数的个数<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">n^2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1=1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">1+3=4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">1+3+5=9</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">1+3+5+7=16</td>
</tr>
</tbody>
</table>

<p>
下图列出了各个基带的子函数，每一项都需要再乘上 \(\frac{1}{2\sqrt{\pi}}\)<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_param.png" alt="01_05ml_sh_param.png" /><br />
</p>

<p>
完整的归一化之后的(复)球谐函数如下：<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_base_func.jpg" alt="01_05ml_sh_base_func.jpg" /><br />
</p>

<p>
因此我们可以使用 9 个因子来近似表示任何一种光照情况，考虑到颜色有 RGB 三个分量，一共需要使用 3*9=27 个因子。<br />
</p>

<p>
下图为 unity 中传递给 shader 的球谐数据:<br />
</p>
<ul class="org-ul">
<li>unity_SHAr.rgba 存储了光照 r 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBr.rgba + unitySHC.r 存储了光照 r 分量的第 2 个基带的参数因子<br /></li>
<li>unity_SHAg.rgba 存储了光照 g 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBg.rgba + unitySHC.g 存储了光照 g 分量的第 2 个基带的参数因子<br /></li>
<li>unity_SHAb.rgba 存储了光照 b 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBb.rgba + unitySHC.b 存储了光照 b 分量的第 2 个基带的参数因子<br /></li>
</ul>


<div id="org1411552" class="figure">
<p><img src="./UnityCatLikeCoding/01_05ml_unity_sh_param.png" alt="01_05ml_unity_sh_param.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="org182d938"></a>ShadeSH9<br />
<div class="outline-text-7" id="text-org182d938">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL0L1</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x;

    <span style="color: #2aa1ae; background-color: #292e34;">// Linear (L1) + constant (L0) polynomial terms</span>
    x.r = <span style="color: #4f97d7;">dot</span>(unity_SHAr,normal);
    x.g = <span style="color: #4f97d7;">dot</span>(unity_SHAg,normal);
    x.b = <span style="color: #4f97d7;">dot</span>(unity_SHAb,normal);

    <span style="color: #4f97d7; font-weight: bold;">return</span> x;
}

<span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL2</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x1, x2;
    <span style="color: #2aa1ae; background-color: #292e34;">// 4 of the quadratic (L2) polynomials</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> vB = normal.xyzz * normal.yzzx;
    x1.r = <span style="color: #4f97d7;">dot</span>(unity_SHBr,vB);
    x1.g = <span style="color: #4f97d7;">dot</span>(unity_SHBg,vB);
    x1.b = <span style="color: #4f97d7;">dot</span>(unity_SHBb,vB);

    <span style="color: #2aa1ae; background-color: #292e34;">// Final (5th) quadratic (L2) polynomial</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> vC = normal.x*normal.x - normal.y*normal.y;
    x2 = unity_SHC.rgb * vC;

    <span style="color: #4f97d7; font-weight: bold;">return</span> x1 + x2;
}

<span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #2aa1ae; background-color: #292e34;">// output in active color space</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSH9</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Linear + constant polynomial terms</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> res = SHEvalLinearL0L1 (normal);

    <span style="color: #2aa1ae; background-color: #292e34;">// Quadratic polynomials</span>
    res += SHEvalLinearL2 (normal);

<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        res = LinearToGammaSpace (res);
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>
</div>
</li>
<li><a id="orgde79f63"></a>环境光和 LightProbe<br />
<div class="outline-text-7" id="text-orgde79f63">
<p>
环境光和 LightProbe 都使用了球谐光照。在 Unity 中叠加到了间接光照的 diffuse 中。<br />
环境光对应一组球谐系数。每个 LightProbe 也对应存储一组球谐系数。全局照明系统会烘培环境光探针，即使用球谐参数保存环境光参数，但是当几何体使用了光照探针和 Lightmaps 时，并不会应用环境光探针，因为环境光影响在光照探针和 Lightmaps 中已经存在了。只有当不存在光照探针和 Lightmap 时，才会使用环境光探针。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html">https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html</a><br /></li>
</ul>

<p>
Tips:<br />
RenderSettings.ambientIntensity 只会影响 ambientProbe，而不会影响 LightProbe。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/RenderSettings-ambientIntensity.html">https://docs.unity3d.com/ScriptReference/RenderSettings-ambientIntensity.html</a><br /></li>
</ul>
<p>
unity 通过 SkyManager 来管理环境光(environment lighting). SkyManager 会自动生成一个 ambientProbe 和 default reflection probe 来 capture environtment lighting。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/using-skymanager.html">https://docs.unity3d.com/Manual/using-skymanager.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Should SH (light probe / ambient) calculations be performed?</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#24320;&#21551;&#26102;&#65292;&#19981;&#25191;&#34892;SH&#35745;&#31639;&#12290;When both static and dynamic lightmaps are available, no SH evaluation is performed</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#20851;&#38381;&#26102;&#65292;&#19968;&#23450;&#25191;&#34892;SH&#35745;&#31639;&#12290; When static and dynamic lightmaps are not available, SH evaluation is always performed</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#23545;&#20110;&#20302;&#32423;LOD&#65292;&#38745;&#24577;lightmap&#21644;LightProbe&#23454;&#26102;&#20840;&#23616;&#29031;&#26126;&#21487;&#20197;&#21512;&#24182;&#22312;&#19968;&#36215;&#12290; For low level LODs, static lightmap and real-time GI from light probes can be combined together</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - forwardadd,shdowcaster&#31561;Pass&#19981;&#38656;&#35201;&#25191;&#34892;SH&#35745;&#31639;&#12290;Passes that don't do ambient (additive, shadowcaster etc.) should not do SH either.</span>
<span style="color: #bc6ec5;">#define</span> UNITY_SHOULD_SAMPLE_SH (defined(LIGHTPROBE_SH) &amp;&amp; !defined(UNITY_PASS_FORWARDADD) &amp;&amp; !defined(UNITY_PASS_PREPASSBASE) &amp;&amp; !defined(UNITY_PASS_SHADOWCASTER) &amp;&amp; !defined(UNITY_PASS_META))

<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSHPerPixel</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> ambient, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> ambient_contrib = 0.0;

<span style="color: #bc6ec5;">    #if</span> UNITY_SAMPLE_FULL_SH_PER_PIXEL
        <span style="color: #2aa1ae; background-color: #292e34;">// Completely per-pixel</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

            ambient_contrib += SHEvalLinearL2(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));

            ambient += <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient_contrib);

<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace(ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #elif</span> (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE
        <span style="color: #2aa1ae; background-color: #292e34;">// Completely per-vertex</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// nothing to do here. Gamma conversion on ambient from SH takes place in the vertex shader, see ShadeSHPerVertex.</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// L2 per-vertex, L0..L1 &amp; gamma-correction per-pixel</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// Ambient in this case is expected to be always Linear, see ShadeSHPerVertex()</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

        ambient = <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient+ambient_contrib);     <span style="color: #2aa1ae; background-color: #292e34;">// include L2 contribution in vertex shader before clamp.</span>
<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace (ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> ambient;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> UnityGI UnityGI_Base(UnityGIInput data, <span style="color: #ce537a; font-weight: bold;">half</span> occlusion, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
    UnityGI o_gi;
    ResetUnityGI(o_gi);

    <span style="color: #2aa1ae; background-color: #292e34;">// Base pass with Lightmap support is responsible for handling ShadowMask / blending here for performance reason</span>
<span style="color: #bc6ec5;">    #if</span> defined(HANDLE_SHADOWS_BLENDING_IN_GI)
        <span style="color: #ce537a; font-weight: bold;">half</span> bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
        <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - data.worldPos, UNITY_MATRIX_V[2].xyz);
        <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
        data.atten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.light = data.light;
    o_gi.light.color *= data.atten;

    <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;&#35843;&#29992; ShadeSHPerPixel &#26041;&#27861;&#35745;&#31639;&#29615;&#22659;&#20809; /LightProbe&#30340;&#29699;&#35856;&#20809;&#29031;&#65292;&#23558;&#32467;&#26524;&#23384;&#20648;&#21040;indirectLight.diffuse&#20013;</span>
<span style="color: #bc6ec5;">    #if</span> UNITY_SHOULD_SAMPLE_SH
        o_gi.indirect.diffuse = ShadeSHPerPixel(normalWorld, data.ambient, data.worldPos);
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #2aa1ae; background-color: #292e34;">// Baked lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">half4</span> bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);
        <span style="color: #ce537a; font-weight: bold;">half3</span> bakedColor = DecodeLightmap(bakedColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> bakedDirTex = UNITY_SAMPLE_TEX2D_SAMPLER (unity_LightmapInd, unity_Lightmap, data.lightmapUV.xy);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap (o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// not directional lightmap</span>
            o_gi.indirect.diffuse += bakedColor;

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap(o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #ifdef</span> DYNAMICLIGHTMAP_ON
        <span style="color: #2aa1ae; background-color: #292e34;">// Dynamic lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> realtimeColorTex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, data.lightmapUV.zw);
        <span style="color: #ce537a; font-weight: bold;">half3</span> realtimeColor = DecodeRealtimeLightmap (realtimeColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">half4</span> realtimeDirTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap, data.lightmapUV.zw);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (realtimeColor, realtimeDirTex, normalWorld);
<span style="color: #bc6ec5;">        #else</span>
            o_gi.indirect.diffuse += realtimeColor;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.indirect.diffuse *= occlusion;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o_gi;
}

</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org343ea68" class="outline-5">
<h5 id="org343ea68">Bumpiness</h5>
<div class="outline-text-5" id="text-org343ea68">
</div>
<div id="outline-container-org862e4e2" class="outline-6">
<h6 id="org862e4e2">高度图转 normal map 的方法</h6>
<div class="outline-text-6" id="text-org862e4e2">
</div>
<ul class="org-ul">
<li><a id="orga9fae19"></a>方案 1<br />
<div class="outline-text-7" id="text-orga9fae19">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。求出 u 或 v 方向的 tangent。<br /></li>
<li>将 tangent 绕 z 轴旋转 90 度，就是 normal。<br /></li>
</ol>

<div id="orgeb9bc41" class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_vector-rotation.png" alt="01_06bu_vector-rotation.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#21033;&#29992; u &#26041;&#21521;&#39640;&#24230;&#21464;&#21270;&#26469;&#27714; normal</span>
<span style="color: #ce537a; font-weight: bold;">float2</span> delta = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> h1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv);
<span style="color: #ce537a; font-weight: bold;">float</span> h2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + delta);

<span style="color: #2aa1ae; background-color: #292e34;">// scale normal with 1/delta.x &#31532;&#19968;&#31181;&#24418;&#24335;&#28040;&#38500;&#20102;&#38500;&#27861;&#65292;&#32780;&#19988;&#25913;&#21892;&#20102;&#31934;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// i.normal = float3(delta.x, h2 - h1, 0); &lt;==&gt; i.normal = float3(1, (h2 - h1)/delta.x, 0);</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(delta.x, h2 - h1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#25442; x &#21644; y &#23558; tangent &#36716;&#21270;&#20026; normal</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, delta.x, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#25918;&#22823;y&#20943;&#24369;normal&#25928;&#26524;</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, 1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#20063;&#21487;&#20197;&#21033;&#29992; v &#26041;&#21521;&#39640;&#24230;&#26469;&#21464;&#21270;&#27714; normal.&#23454;&#29616;&#26041;&#27861;&#30456;&#21516;</span>
</pre>
</div>

<p>
下图为使用该方式计算 normal 的效果图<br />
<img src="./UnityCatLikeCoding/20_01_08_HMapTangentAsNormal.png" alt="20_01_08_HMapTangentAsNormal.png" /><br />
</p>
</div>
</li>
<li><a id="orga33b2f8"></a>方案 2<br />
<div class="outline-text-7" id="text-orga33b2f8">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 u/v 方向的 tangent 进行叉乘生成 normal。<br /></li>
</ol>

<p>
下面是向量叉乘公式:<br />
<img src="./UnityCatLikeCoding/20_01_09_vectorCrossProduct.png" alt="20_01_09_vectorCrossProduct.png" /><br />
</p>

<p>
此处 tangent 向量叉乘计算结果为：<br />
</p>
\begin{equation}
  \begin{bmatrix}
  0\\
  {f_v}'\\
  1
  \end{bmatrix} \times
  \begin{bmatrix}
  1\\
  {f_u}'\\
  0
  \end{bmatrix} =
  \begin{bmatrix}
  {f_v}'*0-1*{f_u}'\\
  1*1-0*0 \\
  0*{f_u}'-{f_v}'*1
  \end{bmatrix} =
  \begin{bmatrix}
  -{f_u}'\\
  1 \\
  -{f_v}'
  \end{bmatrix}
\end{equation}

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> du = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x * 0.5, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> u1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - du);
<span style="color: #ce537a; font-weight: bold;">float</span> u2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + du);
<span style="color: #ce537a; font-weight: bold;">float3</span> tu = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, u2 - u1, 0);

<span style="color: #ce537a; font-weight: bold;">float2</span> dv = <span style="color: #ce537a; font-weight: bold;">float2</span>(0, <span style="color: #7590db;">_HeightMap_TexelSize</span>.y * 0.5);
<span style="color: #ce537a; font-weight: bold;">float</span> v1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - dv);
<span style="color: #ce537a; font-weight: bold;">float</span> v2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + dv);
<span style="color: #ce537a; font-weight: bold;">float3</span> tv = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, v2 - v1, 1);

i.normal = <span style="color: #4f97d7;">cross</span>(tv, tu);
i.normal = <span style="color: #4f97d7;">normalize</span>(i.normal);
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2df7f35" class="outline-6">
<h6 id="org2df7f35">Normal 向量的插值</h6>
<div class="outline-text-6" id="text-org2df7f35">
<p>
Normal 贴图的 Filter，以及顶点的 Normal 向量在传递到片段着色器过程中的插值 都会导致 normal 向量不再是单位向量，所以需要重新单位化。<br />
</p>
</div>
</div>
<div id="outline-container-org930589b" class="outline-6">
<h6 id="org930589b">Normal 贴图存储惯例</h6>
<div class="outline-text-6" id="text-org930589b">
<p>
Normal 贴图通用的惯例是将向上的方向存储到 z 分量.所以，在 shader 中采样出来 normal 向量后需要调换 y 分量和 z 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org4940555" class="outline-6">
<h6 id="org4940555">DXT5nm 存储 normal 贴图</h6>
<div class="outline-text-6" id="text-org4940555">
<p>
其只存储了 normal 的 x，y 分量，丢弃掉了 z 分量。z 分量通过计算得到 \(z=\sqrt{1-x^2-y^2}\) .<br />
x 分量存储在 A 通道，y 分量存储在 G 通道。R 通道和 B 通道没有使用。<br />
DXT5 按照 4x4 个像素为一个块进行压缩。R 占用 5 位，B 占用 5 位，G 占用 6 位，A 占用 8 位。RGB 公用一个查找表，A 单独使用一个查找表。所以将 x 分量存储到 A 通道可以保持 x 分量和 y 分量的独立性。<br />
手机平台不支持 DXT5nm 格式，在手机平台 unity 仍然使用通用的 rgb 进行编码。<br />
</p>
</div>
</div>
<div id="outline-container-orgc2576af" class="outline-6">
<h6 id="orgc2576af">缩放 Normal</h6>
<div class="outline-text-6" id="text-orgc2576af">
<p>
只需要在单位化 normal 前，对 normal 的 x 分量和 z 分量进行缩放，就可以强化和弱化 y 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org6695134" class="outline-6">
<h6 id="org6695134">Blending Normals</h6>
<div class="outline-text-6" id="text-org6695134">
<p>
回顾使用高度图生成 normal 贴图的方法，可以知道，如果希望 normal 效果叠加，其实就是将高度叠加，也就是斜率叠加（斜率为 h/x, 贴图各个地方 x 都相同，因此高度相当于斜率）。<br />
normal 贴图中存储的值为:(s 表示单位化过程中，对各个分量的缩放)<br />
</p>
\begin{bmatrix}
-s{f_u}'\\
-s{f_v}'\\
s \\
\end{bmatrix}
<p>
所以叠加 MainNormalTex 和 DetailNormalTex 的高度后得到的 normal 为<br />
</p>
\begin{bmatrix}
\frac{M_x}{M_z} + \frac{D_x}{D_z} \\
\frac{M_y}{M_z} + \frac{D_y}{D_z} \\
1 \\
\end{bmatrix}

<p>
Whiteout Blending : 对上面得到的 normal 乘 \(M_zD_z\) ，然后丢弃掉对 x 和 y 分量的缩放、这样可以强化 X 和 Y 分量<br />
</p>
\begin{equation}
  \begin{bmatrix}
  \frac{M_x}{M_z} + \frac{D_x}{D_z} \\
  \frac{M_y}{M_z} + \frac{D_y}{D_z} \\
  1 \\
  \end{bmatrix} * M_zD_z =
  \begin{bmatrix}
    M_xD_z + D_xM_z \\
    M_yD_z + D_yM_z \\
    M_zD_z \\
  \end{bmatrix} =
  \begin{bmatrix}
    M_x + D_x \\
    M_y + D_y \\
    M_zD_z \\
  \end{bmatrix}
\end{equation}

<p>
下面这段文字翻译自 Blending in Detial 文章：<br />
在开发 Reoriented Normal Mapping 方法时，我们希望新的方法满足下面的属性，从而能让艺术家从直观上理解其行为：<br />
属性 1：符合逻辑，方法有清晰的数学理论基础。（如：有清晰的几何解释）<br />
属性 2：处理恒等情况，如果其中一个 normal map 是平的，则输出和另外一个 normal map 一样。<br />
属性 3：不会变平，两个 normal map 的强度都会被保持。<br />
</p>

<p>
尽管 Whiteout 方法看似可行，但是其并不完全具备上面的第一和第三条属性。为了满足这些属性，我们的策略是对 detail normal 进行旋转使其跟随 base normal 对应的表面，就像切空间的 normal 会被变换以跟随几何表面的法线。<br />
</p>

<p>
Unity 中 base normal 和 detail normal 的混合使用了类似的思路，但是，其构造的 detail normal 旋转矩阵使用的三个向量并不是正交的。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> n1 = <span style="color: #4f97d7;">tex2D</span>(texBase,   uv).xyz*2 - 1;
<span style="color: #ce537a; font-weight: bold;">float3</span> n2 = <span style="color: #4f97d7;">tex2D</span>(texDetail, uv).xyz*2 - 1;

<span style="color: #ce537a; font-weight: bold;">float3x3</span> nBasis = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.z, n1.y, -n1.x), <span style="color: #2aa1ae; background-color: #292e34;">// +90 degree rotation around y axis</span>
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.x, n1.z, -n1.y), <span style="color: #2aa1ae; background-color: #292e34;">// -90 degree rotation around x axis</span>
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.x, n1.y,  n1.z));

<span style="color: #ce537a; font-weight: bold;">float3</span> r = <span style="color: #4f97d7;">normalize</span>(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);
<span style="color: #4f97d7; font-weight: bold;">return</span> r*0.5 + 0.5;
</pre>
</div>

<ul class="org-ul">
<li>Blending in Detail <a href="https://blog.selfshadow.com/publications/blending-in-detail/index.html">https://blog.selfshadow.com/publications/blending-in-detail/index.html</a><br /></li>
<li>Normal Blend 方法总结 <a href="https://zhuanlan.zhihu.com/p/364821684">https://zhuanlan.zhihu.com/p/364821684</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org509c704" class="outline-6">
<h6 id="org509c704">Tangent Space And Tangent Space To World Space</h6>
<div class="outline-text-6" id="text-org509c704">
<p>
TangentSpace 基向量如下：(假设左手坐标系，Tangent 对应 x 轴，Normal 对应 y 轴，Binormal 对应 z 轴)<br />
</p>
<ul class="org-ul">
<li>Tangent 向量对应 U axis<br /></li>
<li>Normal 向量对应表面法线<br /></li>
<li>Binormal（或 Bitangent）向量对应 V axis。Binormal = Tangent x Normal = -(Normal x Tangent)。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orge9c9593"></a>为什么要在 tangent vector 的 w 分量中存储-1 或 1？<br />
<div class="outline-text-7" id="text-orge9c9593">
<p>
创建左右对称的 3D 模型(例如：人类，动物)时，通常会对 mesh 进行作于镜像。这样就只需要编辑半部分模型，而且也只需要一半的贴图数据。在进行模型镜像的时候，顶点的 normal,tangent,向量也需要进行镜像，但是 binormal 向量则不需要。可以通过在 tangent 的 w 分量中存储-1 来表示 binormal 为非镜像的，tangent 的 w 分量中存储 1 来表示 binormal 为镜像的。<br />
</p>
</div>
</li>
<li><a id="orgb2134f5"></a>为什么不需要对 worldTangent 和 worldBinormal 进行 normalize?<br />
<div class="outline-text-7" id="text-orgb2134f5">
<p>
worldTangent worldBinormal 只用于得到 TangentToWorld 变换矩阵，从而将 tangentNormal 转换为 worldNormal。不会直接使用 worldTangent worldBinormal 用于光照计算，所以不需要 normalize。<br />
</p>
</div>
</li>
<li><a id="orgf719c64"></a>为什么 Unity 中没有对法线 y、z 分量进行调换？<br />
<div class="outline-text-7" id="text-orgf719c64">

<div id="orge2522d0" class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_tangent_normal_to_world_normal.png" alt="01_06bu_tangent_normal_to_world_normal.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// Unity &#23454;&#29616;</span>
  <span style="color: #ce537a; font-weight: bold;">half3x3</span> <span style="color: #bc6ec5; font-weight: bold;">CreateTangentToWorldPerVertex</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> tangent, <span style="color: #ce537a; font-weight: bold;">half</span> tangentSign)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// For odd-negative scale transforms we need to flip the sign</span>
      <span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #4f97d7;">sign</span> = tangentSign * unity_WorldTransformParams.w;
      <span style="color: #ce537a; font-weight: bold;">half3</span> binormal = <span style="color: #4f97d7;">cross</span>(normal, tangent) * <span style="color: #4f97d7;">sign</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// TIPS: normal &#25918;&#21040;&#20102;&#26368;&#21518;&#19968;&#21015;&#20174;&#32780;&#21644;&#27861;&#32447;&#30340;&#30495;&#23454;&#30340;y&#30456;&#23545;&#24212;&#65292;&#20174;&#32780;&#23454;&#29616;&#20102;&#27861;&#32447;y&#65292;z&#20998;&#37327;&#30340;&#35843;&#25442;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">half3x3</span>(tangent, binormal, normal);
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// vertex shader</span>
  <span style="color: #ce537a; font-weight: bold;">float4</span> tangentWorld = <span style="color: #ce537a; font-weight: bold;">float4</span>(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);
  <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);

  <span style="color: #2aa1ae; background-color: #292e34;">// fragment shader</span>
  <span style="color: #ce537a; font-weight: bold;">half3</span> tangent = tangentToWorld[0].xyz;
  <span style="color: #ce537a; font-weight: bold;">half3</span> binormal = tangentToWorld[1].xyz;
  <span style="color: #ce537a; font-weight: bold;">half3</span> normal = tangentToWorld[2].xyz;
  <span style="color: #2aa1ae; background-color: #292e34;">// TIPS:</span>
  <span style="color: #ce537a; font-weight: bold;">float3</span> normalWorld = tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org301a0ce" class="outline-5">
<h5 id="org301a0ce">Shadows</h5>
<div class="outline-text-5" id="text-org301a0ce">
</div>
<div id="outline-container-org1238770" class="outline-6">
<h6 id="org1238770">方向光阴影</h6>
<div class="outline-text-6" id="text-org1238770">
</div>
<ul class="org-ul">
<li><a id="orgacf4512"></a>ShadowBias<br />
<div class="outline-text-7" id="text-orgacf4512">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgae3c796"></a>开启屏幕空间阴影<br />
<ul class="org-ul">
<li><a id="org44a5d78"></a>开启关闭的方法<br />
<div class="outline-text-8" id="text-org44a5d78">
<ul class="org-ul">
<li>关闭 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 No Support，Tier 中取消勾选 Cascaded Shadows 。<br /></li>
<li>开启 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 Built-in shader，Tier 中勾选 Cascaded Shadows 。<br /></li>
</ul>
</div>
</li>
<li><a id="org350b031"></a>Rendering to Depth Texture<br />
<div class="outline-text-8" id="text-org350b031">
<p>
Unity 绘制场景中物体将其深度写入到 DepthTexture<br />
</p>


<div id="org69eecca" class="figure">
<p><img src="./UnityCatLikeCoding/01_07sh_depth.png" alt="01_07sh_depth.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="org37961df"></a>Rendering To Shadow Maps<br />
<div class="outline-text-8" id="text-org37961df">
<p>
Unity 在光源位置对场景进行绘制，将物体深度写入到 Shadowmap<br />
开启 shadow cascades 后，会多次绘制阴影。开启 2 级会绘制两次，开启 4 级会绘制 4 次。<br />
</p>

<p>
下图为第一个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows.png" alt="01_07sh_4cascades_shadows.png" /><br />
</p>

<p>
下图为第二个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_2.png" alt="01_07sh_4cascades_shadows_2.png" /><br />
</p>
</div>
</li>

<li><a id="org833101a"></a>Collecting Shadows<br />
<div class="outline-text-8" id="text-org833101a">
<p>
Unity 使用 Hidden/Internal-ScreenSpaceShadows shader 绘制一个全屏的矩形，以前面得到的 DepthTexture 和 Shadowmap 为输入，对于每一个片段通过比较对应的场景摄像机的深度和光照摄像机的深度得出屏幕空间的阴影贴图。<br />
在这个过程中，Unity 通过 Filtering 来实现软阴影。<br />
</p>

<p>
下图为第一个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_1.png" alt="01_07sh_screenspace_shadows_1.png" /><br />
下图为第二个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_2.png" alt="01_07sh_screenspace_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="orgce83db7"></a>最终结果<br />
<div class="outline-text-8" id="text-orgce83db7">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_drawcall.png" alt="01_07sh_4cascades_drawcall.png" /><br />
</p>

<p>
下图为绘制结果：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_result.png" alt="01_07sh_4cascades_shadows_result.png" /><br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc90bc7f"></a>为什么 unity 要在渲染 shadowmap 和 collecting 之间切换？<br />
<div class="outline-text-9" id="text-orgc90bc7f">
<p>
因为每个光源需要它自己的屏幕空间阴影贴图，但是从光源视角渲染阴影贴图所用到的 RenderTarget 可以被复用。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org152e18d"></a>关闭屏幕空间阴影<br />
<ul class="org-ul">
<li><a id="org178a09f"></a>Rendering To Shadow Maps<br />
<div class="outline-text-8" id="text-org178a09f">
<p>
下图为第一个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_1.png" alt="01_07sh_noss_shadows_1.png" /><br />
下图为第二个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_2.png" alt="01_07sh_noss_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="org710c55d"></a>最终结果<br />
<div class="outline-text-8" id="text-org710c55d">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_3.png" alt="01_07sh_noss_shadows_3.png" /><br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgb3bf718"></a>ShadowQuality<br />
<div class="outline-text-7" id="text-orgb3bf718">
<p>
减低 ShadowDistance 可以提高阴影精度，但是会缩小阴影范围。<br />
设置投影类型 QualitySettings.shadowProjection = ShadowProjection.CloseFit; 可以提高阴影精度。<br />
开启 Cascade。<br />
</p>
</div>
</li>
<li><a id="org1549639"></a>ForwardAddPass 阴影支持<br />
<div class="outline-text-7" id="text-org1549639">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#26041;&#26696;1 fwd pass &#20013;&#28155;&#21152;&#22914;&#19979;&#21629;&#20196;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile_fwdadd_fullshadows

  <span style="color: #2aa1ae; background-color: #292e34;">// &#26041;&#26696;2</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// 2.1 fwd pass &#20013;&#20462;&#25913;Tag</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// 2.2&#28155;&#21152; DIRECTIONAL SHADOWS_SCREEN&#21464;&#20307;</span>
  <span style="color: #4f97d7; font-weight: bold;">Tags</span>
  {
      <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"ForwardAdd"</span>
      <span style="color: #2d9574;">"SHADOWSUPPORT"</span>=<span style="color: #2d9574;">"true"</span>
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// ...</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRECTIONAL
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ SHADOWS_SCREEN
</pre>
</div>
</div>
</li>
<li><a id="org16bdd45"></a>参考资料<br />
<div class="outline-text-7" id="text-org16bdd45">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org82e0085" class="outline-6">
<h6 id="org82e0085">Spot Light Shadow</h6>
</div>
<div id="outline-container-orgcbda3ec" class="outline-6">
<h6 id="orgcbda3ec">相关宏定义</h6>
<div class="outline-text-6" id="text-orgcbda3ec">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏定义</th>
<th scope="col" class="org-left">DrawCall</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UNITY_NO_SCREENSPACE_SHADOWS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">开启屏幕空间阴影</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">Directional 和 Spot 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">PointLight 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN</td>
<td class="org-left">RenderForward ForwardBasePass</td>
<td class="org-left">主 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN DIRECTIONAL</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">第二个 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH SPOT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Spot 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE POINT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Point 开启阴影对应的宏定义</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>DIRECTIONAL SPOT POINT 3 个对应 Light 组件上的 LightType 的设置<br /></li>
<li>SHADOWS_SCREEN SHADOWS_DEPTH SHADOWS_CUBE 对应物体 Renderer 组件上的 ReceiveShadow 设置<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5edccfa" class="outline-6">
<h6 id="org5edccfa">参考资料</h6>
<div class="outline-text-6" id="text-org5edccfa">
<ul class="org-ul">
<li>Signed Distance Field Shadow in Unity <a href="https://zhuanlan.zhihu.com/p/37918356">https://zhuanlan.zhihu.com/p/37918356</a><br /></li>
<li>Unity 平面阴影(王者荣耀阴影实现) <a href="https://zhuanlan.zhihu.com/p/42781261">https://zhuanlan.zhihu.com/p/42781261</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orged32d72" class="outline-5">
<h5 id="orged32d72">Reflection</h5>
<div class="outline-text-5" id="text-orged32d72">
</div>
<div id="outline-container-orgd4d0eb4" class="outline-6">
<h6 id="orgd4d0eb4">Environment Mapping</h6>
<div class="outline-text-6" id="text-orgd4d0eb4">
</div>
<ul class="org-ul">
<li><a id="org4fa5662"></a>缺少 Indirect Specular Lighting<br />
<div class="outline-text-7" id="text-org4fa5662">
<p>
在 shader 中组合了 diffuse specular ambient 后，感觉应该可以创建出看上去真实的画面了，然而物体表面依然暗淡，闪耀的表面效果看起来不正确。闪耀的表面应该像镜子，特别是表面为金属时。（完美的镜面反射会反射所有光照，所以其不存在 diffuse.光滑度越高、金属度越高，材质越接近完美镜面。）<br />
下图为 Metallic Smoothness 取不同值时的渲染效果:<br />
<img src="./UnityCatLikeCoding/01_08re_no_indirect_spec_lighting1.png" alt="01_08re_no_indirect_spec_lighting1.png" /><br />
上图 metallic=1 时，env ambient 几乎对渲染没有任何影响，这是因为金属度越高反射率越大，反射率越大其漫反射部分就越少(参考 PhysicalTheory.org 中 金属和非金属放射光的差异 的描述)，所以 ambient 对于 metallic=1 的材质几乎没有任何影响。<br />
上图 metallic=1 Smoothness=1 时，几乎是一个黑色的球，只能看到一个很小的高光，这个很小的高光是表面将直接光源反射到了朝向我们的方向(朝向摄像机的方向)。之所以渲染结果是黑球，是因为 shader 中只包含了直接光照和间接光照的 diffuse（也就是 ambient），为了反射环境，需要添加间接光照的高光反射，即 indirectLight.specular。<br />
</p>
</div>
</li>

<li><a id="orgc821fa2"></a>Indirect Specular Lighting 特点<br />
<div class="outline-text-7" id="text-orgc821fa2">
<p>
视线和法线夹角越大，Fresnel 反射越强。表面越光滑 Fresnel 反射越强。<br />
<img src="./UnityCatLikeCoding/01_08re_fresnel_smoothness.png" alt="01_08re_fresnel_smoothness.png" /><br />
</p>

<p>
因为 Fresnel 间接反射来源于间接光照(上图中直接光照颜色为白色，间接光照的高光直接设置为了红色)，所以它产生的效果独立于直接光照，因此上图中即使处于阴影部分的边缘处 Fresnel 反射依然很强，其独立于直接光源的阴影。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i) {
    UnityIndirect indirectLight;
    indirectLight.diffuse = 0;
    indirectLight.specular = 0;

<span style="color: #bc6ec5;">    #if</span> defined(VERTEXLIGHT_ON)
        indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(FORWARD_BASE_PASS)
        indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
        <span style="color: #2aa1ae; background-color: #292e34;">// &#38388;&#25509;&#39640;&#20809;&#39068;&#33394;&#35774;&#32622;&#20026;&#20102;&#32418;&#33394;</span>
        indirectLight.specular = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, 0, 0);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org29a2f1f" class="outline-6">
<h6 id="org29a2f1f">Imperfect Reflections</h6>
<div class="outline-text-6" id="text-org29a2f1f">
<p>
模糊的反射是通过环境贴图的 mipmap 来实现的。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org313bac7"></a>Metals VS Nonmetals<br />
<div class="outline-text-7" id="text-org313bac7">
<p>
金属和非金属表面都可以产生清晰的反射，但是他们看起来是不同的。镜面反射在闪耀的电介质材质(非金属)上效果会很强，但是镜面反射并不会主导电介质材质(非金属)的外观，他们仍然表现出大量的可见的 diffuse 反射。<br />
<img src="./UnityCatLikeCoding/01_08re_dielectric.png" alt="01_08re_dielectric.png" /><br />
</p>

<p>
金属会改变镜面反射的颜色，但是非金属则不会。这对于镜面高光和环境镜面反射都适用。下图中金属的镜面高光颜色为红色，非金属是白色。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_nonmetal.png" alt="01_08re_metal_nonmetal.png" /><br />
</p>
</div>
</li>

<li><a id="orge160ff9"></a>Mirrors and Shadows<br />
<div class="outline-text-7" id="text-orge160ff9">
<p>
间接反射是独立于表面的直接照明的。这在其阴影区域会更加明显。对于非金属，这会让表面更亮一些，你依然可以看到直接光照导致的阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_nonmetal_with_shadow.png" alt="01_08re_nonmetal_with_shadow.png" /><br />
同样的规则适用于金属。但是，金属的间接反射起主导作用。因此，直接光照和阴影会随着光泽度增加而消失。完美镜面上不存在阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_with_shadow.png" alt="01_08re_metal_with_shadow.png" /><br />
现实世界中很少有完美的镜面。现实世界中的材质都是由金属和非金属混合而成的，可以通过调节金属度来模拟不完美的镜面材质。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6f80d1c" class="outline-6">
<h6 id="org6f80d1c">Box Projection</h6>
<div class="outline-text-6" id="text-org6f80d1c">
<p>
ReflectionProbe 的 Box 区域是和世界坐标轴对齐的，它不受旋转和缩放影响。<br />
BoxProjection 原理如下图所示：<br />
<img src="./UnityCatLikeCoding/01_08re_box_projection.JPG" alt="01_08re_box_projection.JPG" /><br />
<img src="./UnityCatLikeCoding/01_08re_box_projection_3D.png" alt="01_08re_box_projection_3D.png" /><br />
<a href="./UnityCatLikeCoding/01_08re_box_projection.ggb">./UnityCatLikeCoding/01_08re_box_projection.ggb</a><br />
</p>

<p>
BoxProjection 对应代码实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">BoxProjection</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> dir, <span style="color: #ce537a; font-weight: bold;">half3</span> pos, <span style="color: #ce537a; font-weight: bold;">half4</span> cubemapPos, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMin, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMax)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// cubemapPos.w &#25511;&#21046; BoxProjection &#26159;&#21542;&#29983;&#25928;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// UNITY_BRANCH &#29992;&#20110;&#24320;&#21551;&#30495;&#27491;&#30340;&#20998;&#25903;</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (cubemapPos.w &gt; 0)
    {
        <span style="color: #ce537a; font-weight: bold;">half3</span> factors = ((dir &gt; 0 ? boxMax : boxMin) - pos) / dir;
        <span style="color: #ce537a; font-weight: bold;">half</span> realFactor = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(factors.x, factors.y), factors.z);
        <span style="color: #4f97d7; font-weight: bold;">return</span> dir * realFactor + (pos - cubemapPos);
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> dir;
}
</pre>
</div>

<ul class="org-ul">
<li>关于 UNITY_BRANCH   <a href="https://forum.unity.com/threads/correct-use-of-unity_branch.476804/">https://forum.unity.com/threads/correct-use-of-unity_branch.476804/</a><br /></li>
<li>HLSL branch flatten <a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdbe6048" class="outline-6">
<h6 id="orgdbe6048">Blending Reflection Probes</h6>
<div class="outline-text-6" id="text-orgdbe6048">
<p>
只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">ReflectionProbeUsage</span>
{
    <span style="color: #7590db;">Off</span> = 0,                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20851;&#38381;&#21453;&#23556;&#25506;&#38024;</span>
    <span style="color: #7590db;">BlendProbes</span> = 1,              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21482;&#21644;&#21453;&#23556;&#25506;&#38024;&#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">BlendProbesAndSkybox</span> = 2,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21487;&#20197;&#21644; skybox &#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">Simple</span> = 3                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20351;&#29992;&#20854;&#20013;&#19968;&#20010;&#21453;&#23556;&#25506;&#38024;&#25110; skybox&#65292;&#19981;&#36827;&#34892;&#28151;&#21512;</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#28151;&#21512;&#21453;&#23556;&#25506;&#38024;&#30340;&#36923;&#36753;</span>
  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir)
  {
      UnityIndirect indirect;
      indirect.diffuse = 0;
      indirect.specular = 0;
<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS)
      indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));

      <span style="color: #ce537a; font-weight: bold;">half</span> roughness = 1 - <span style="color: #7590db;">_Smoothness</span>;
      roughness *= 1.7 - 0.7 * roughness;

      <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir = <span style="color: #4f97d7;">reflect</span>(-viewDir, i.worldNormal);
      <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir1 = BoxProjection(reflectDir, i.worldPos,
          unity_SpecCube0_ProbePosition,
          unity_SpecCube0_BoxMin,
          unity_SpecCube0_BoxMax);
      <span style="color: #ce537a; font-weight: bold;">half4</span> envColor = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflectDir1, roughness*UNITY_SPECCUBE_LOD_STEPS);
      envColor.rgb = DecodeHDR(envColor, unity_SpecCube0_HDR);
      UNITY_BRANCH
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_SpecCube0_BoxMin.a &lt; 0.9999)
      {
          <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir2 = BoxProjection(reflectDir, i.worldPos,
              unity_SpecCube1_ProbePosition,
              unity_SpecCube1_BoxMin,
              unity_SpecCube1_BoxMax);
          <span style="color: #ce537a; font-weight: bold;">half4</span> envColor2 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, reflectDir2, roughness*UNITY_SPECCUBE_LOD_STEPS);
          <span style="color: #2aa1ae; background-color: #292e34;">// DecodeHDR &#20013;&#20195;&#30721;&#22788;&#29702;&#20102; intensity &#36923;&#36753;</span>
          envColor2.rgb = DecodeHDR(envColor2, unity_SpecCube1_HDR);
          envColor = <span style="color: #4f97d7;">lerp</span>(envColor2, envColor, unity_SpecCube0_BoxMin.a);
      }
      <span style="color: #2aa1ae; background-color: #292e34;">//indirect.specular = half3(1, 0, 0);</span>
      indirect.specular = envColor.rgb;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }
</pre>
</div>

<p>
下面着重列出 Reflection CubeMap 的采样<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Step 1</span>
<span style="color: #2aa1ae; background-color: #292e34;">// MetallicSetup</span>
<span style="color: #ce537a; font-weight: bold;">half</span> smoothness = metallicGloss.y; <span style="color: #2aa1ae; background-color: #292e34;">// this is 1 minus the square root of real roughness m.</span>
<span style="color: #2aa1ae; background-color: #292e34;">// SpecularSetup</span>
<span style="color: #ce537a; font-weight: bold;">half</span> smoothness = specGloss.a;

<span style="color: #2aa1ae; background-color: #292e34;">// Step 2</span>
perceptualRoughness = 1 - smoothness

<span style="color: #2aa1ae; background-color: #292e34;">// Step 3</span>
indirectSpecular = Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE(unity_SpecCube0), data.probeHDR[0], glossIn);

<span style="color: #2aa1ae; background-color: #292e34;">// Unity_GlossyEnvironment builtin_shaders/CGIncludes/UnityImageBasedLighting.cginc</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">Unity_GlossyEnvironment</span> (UNITY_ARGS_TEXCUBE(tex), <span style="color: #ce537a; font-weight: bold;">half4</span> hdr, Unity_GlossyEnvironmentData glossIn)
{
    <span style="color: #ce537a; font-weight: bold;">half</span> perceptualRoughness = glossIn.roughness <span style="color: #2aa1ae; background-color: #292e34;">/* perceptualRoughness */</span> ;

<span style="color: #2aa1ae; background-color: #292e34;">// TODO: CAUTION: remap from Morten may work only with offline convolution, see impact with runtime convolution!</span>
<span style="color: #2aa1ae; background-color: #292e34;">// For now disabled</span>
<span style="color: #bc6ec5;">#if</span> 0
    <span style="color: #ce537a; font-weight: bold;">float</span> m = PerceptualRoughnessToRoughness(perceptualRoughness); <span style="color: #2aa1ae; background-color: #292e34;">// m is the real roughness parameter</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> fEps = 1.192092896e-07F;
    <span style="color: #2aa1ae; background-color: #292e34;">// remap to spec power. See eq. 21 in --&gt; http://jbit.net/~sparky/academic/mm_brdf.pdf</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &lt;&lt;Microfacet Based Bidirectional Reflectance Distribution Function&gt;&gt;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &#38463;&#37324;&#20113;&#22791;&#20221;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> n =  (2.0/<span style="color: #4f97d7;">max</span>(fEps, m*m))-2.0;

    <span style="color: #2aa1ae; background-color: #292e34;">// remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// --&gt; https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &#26377;&#36947;&#20113;&#22791;&#20221; &lt;&lt;Power Drops Within Lys&gt;&gt;</span>
    n /= 4;

    <span style="color: #2aa1ae; background-color: #292e34;">// remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)</span>
    perceptualRoughness = <span style="color: #4f97d7;">pow</span>( 2/(n+2), 0.25);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// MM: came up with a surprisingly close approximation to what the #if 0'ed out code above does.</span>
    perceptualRoughness = perceptualRoughness*(1.7 - 0.7*perceptualRoughness);
<span style="color: #bc6ec5;">#endif</span>


    <span style="color: #ce537a; font-weight: bold;">half</span> mip = perceptualRoughnessToMipmapLevel(perceptualRoughness);
    <span style="color: #ce537a; font-weight: bold;">half3</span> R = glossIn.reflUVW;
    <span style="color: #ce537a; font-weight: bold;">half4</span> rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, R, mip);

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">DecodeHDR</span>(rgbm, hdr, isGammaSpace ? 1 : 0);
}

define <span style="color: #bc6ec5; font-weight: bold;">UNITY_SPECCUBE_LOD_STEPS</span> (6)
<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">perceptualRoughnessToMipmapLevel</span>(<span style="color: #ce537a; font-weight: bold;">half</span> perceptualRoughness)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS;
}

<span style="color: #2aa1ae; background-color: #292e34;">// Decodes HDR textures</span>
<span style="color: #2aa1ae; background-color: #292e34;">// handles dLDR, RGBM formats</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeHDR(<span style="color: #ce537a; font-weight: bold;">half4</span> data, <span style="color: #ce537a; font-weight: bold;">half4</span> decodeInstructions, <span style="color: #ce537a; font-weight: bold;">int</span> colorspaceIsGamma)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Take into account texture alpha if decodeInstructions.w is true(the alpha value affects the RGB channels)</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> alpha = decodeInstructions.w * (data.a - 1.0) + 1.0;

    <span style="color: #2aa1ae; background-color: #292e34;">// If Linear mode is not supported we can skip exponent part</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(colorspaceIsGamma)
        <span style="color: #4f97d7; font-weight: bold;">return</span> (decodeInstructions.x * alpha) * data.rgb;

    <span style="color: #4f97d7; font-weight: bold;">return</span> (decodeInstructions.x * <span style="color: #4f97d7;">pow</span>(alpha, decodeInstructions.y)) * data.rgb;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd928fb8" class="outline-6">
<h6 id="orgd928fb8">Bouncing Reflections</h6>
<div class="outline-text-6" id="text-orgd928fb8">
<p>
Lighting/Scene 下的数据记录在当前打开的场景文件中，每个场景的数据可以不同。<br />
</p>

<p>
EnvironmentLighting/Source               指定天空球作为环境光来源，还是自定义环境光来源。<br />
EnvironmentLighting/IntensityMultiplier  当 EnvironmentLighting/Source 为 Skybox 时，该调节项控制天空球光照亮度.<br />
</p>

<p>
EnvironmentReflections/Source              指定使用天空球作为环境反射源，还是自定义环境反射源。<br />
EnvironmentReflections/IntensityMultiplier 控制反射源在场景中提供反射的因子，值为 1 时符合物理规律。<br />
EnvironmentReflections/Bounces             指定烘培反射 Probe 时，光线弹射次数<br />
</p>

<p>
Tips:<br />
EnvironmentReflections/Bounces 对 EnvCubeMap 的烘培没有影响，但对 Refelction Probe 的烘培有影响。如下图所示，bounces 为 2 时，ReflectionCubeMap 中的球体反射了地面的红色。<br />
</p>


<div id="orgdcbe517" class="figure">
<p><img src="./UnityCatLikeCoding/01_08re_env_ref_bounces.jpg" alt="01_08re_env_ref_bounces.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1a71296" class="outline-5">
<h5 id="org1a71296">ComplexMaterials &amp; More Complexity</h5>
<div class="outline-text-5" id="text-org1a71296">
</div>
<div id="outline-container-orgf744d6e" class="outline-6">
<h6 id="orgf744d6e">Emission</h6>
<div class="outline-text-6" id="text-orgf744d6e">
<p>
Unity HDR Color 的计算逻辑如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">[<span style="color: #7590db;">Serializefield</span>] <span style="color: #4f97d7; font-weight: bold;">private</span> Color _emissionColorValue;
[<span style="color: #7590db;">Serializefield</span>] <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">float</span> _intensity;

mat.<span style="color: #bc6ec5; font-weight: bold;">SetVector</span>(<span style="color: #2d9574;">"_EmissionColor"</span>, _emissionColorValue * Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(2, _intensity));
</pre>
</div>
<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/change-a-materials-emission-color-intensity-property.611206/">https://forum.unity.com/threads/change-a-materials-emission-color-intensity-property.611206/</a><br /></li>
</ul>

<p>
Shader 中实现 Emission 的方法：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  [<span style="color: #7590db;">NoScaleOffset</span>] _EmissionMap (<span style="color: #2d9574;">"Emission"</span>, 2D) = <span style="color: #2d9574;">"black"</span> {}
  [<span style="color: #7590db;">HDR</span>]_Emission (<span style="color: #2d9574;">"Emission"</span>, Color) = (0, 0, 0)

<span style="color: #bc6ec5;">  #pragma</span> shader_feature _EMISSION_MAP

  sampler2D _EmissionMap;
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_Emission</span>;

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
<span style="color: #bc6ec5;">    #if</span> <span style="color: #bc6ec5;">defined</span>(_EMISSION_MAP)
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(_EmissionMap, i.uv.xy) * _Emission;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> _Emission;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">  #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">MyFragmentProgram</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) : SV_TARGET
  {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>

      <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">color</span> = <span style="color: #bc6ec5; font-weight: bold;">UNITY_BRDF_PBS</span>(
                                    albedo, specularTint,
                                    oneMinusReflectivity, <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(i),
                                    i.normal, viewDir,
                                    <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(i), <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span>(i, viewDir)
                                    );
      color.rgb += <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span>(i);
      <span style="color: #4f97d7; font-weight: bold;">return</span> color;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org9d1b460" class="outline-6">
<h6 id="org9d1b460">Smoothness &amp; Metallic Map</h6>
<div class="outline-text-6" id="text-org9d1b460">
<p>
将 MetallicMap 和 SmoothnessMap 存储到一张 DXT5 格式的贴图中 ，Metallic Map 放到贴图 r 通道, Smoothness Map 放到贴图 a 通道。等价于使用两张 DXT1 格式贴图分别存储。因为 DXT5 分开对 RGB 和 A 通道进行压缩。<br />
</p>
</div>
</div>

<div id="outline-container-orgc64be3d" class="outline-6">
<h6 id="orgc64be3d">Occlusion</h6>
<div class="outline-text-6" id="text-orgc64be3d">
<div class="org-src-container">
<pre class="src src-csharp">  [<span style="color: #7590db;">NoScaleOffset</span>] _OcclusionMap (<span style="color: #2d9574;">"Occlusion"</span>, 2D) = <span style="color: #2d9574;">"white"</span> {}
  <span style="color: #bc6ec5; font-weight: bold;">_OcclusionStrength</span>(<span style="color: #2d9574;">"Occlusion Strength"</span>, <span style="color: #bc6ec5; font-weight: bold;">Range</span>(0, 1)) = 1

<span style="color: #bc6ec5;">  #pragma</span> shader_feature _OCCLUSION_MAP

  sampler2D _OcclusionMap;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_OcclusionStrength</span>;

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(_OCCLUSION_MAP)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(1, <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(_OcclusionMap, i.uv.xy).g, _OcclusionStrength);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Occlusion &#21516;&#26102;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;&#21644;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;&#26102;&#65292;Occlusion&#25928;&#26524;&#20250;&#36807;&#24378;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;Occlusion&#26159;&#22522;&#20110;&#29289;&#20307;&#24418;&#29366;&#30340;&#32780;&#19981;&#26159;&#29305;&#23450;&#20809;&#29031;&#30340;&#65292;&#20854;&#21482;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#20250;&#26356;&#21512;&#29702;&#19968;&#20123;&#12290;&#20985;&#30165;&#36234;&#28145;&#30340;&#22320;&#26041;&#65292;&#21508;&#20010;&#26041;&#21521;&#30340;&#38388;&#25509;&#20809;&#29031;&#20943;&#24369;&#36234;&#22810;&#65292;&#32780;&#30452;&#25509;&#20809;&#29031;&#29031;&#36827;&#20985;&#30165;&#26102;&#65292;&#36824;&#26159;&#21487;&#20197;&#21152;&#23558;&#20854;&#29031;&#20142;&#12290;</span>
  <span style="color: #ce537a; font-weight: bold;">UnityLight</span> <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
      <span style="color: #bc6ec5; font-weight: bold;">UNITY_LIGHT_ATTENUATION</span>(attenuation, i, i.worldPos);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;atten&#30456;&#20056;&#26469;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
      attenuation *= <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
      light.color = _LightColor0.rgb * attenuation;
      light.ndotl = <span style="color: #bc6ec5; font-weight: bold;">DotClamped</span>(i.normal, light.dir);
      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }

  <span style="color: #ce537a; font-weight: bold;">UnityIndirect</span> <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">viewDir</span>) {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">occlusion</span> = <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;&#38388;&#25509;&#20809;&#29031;&#30340;diffuse&#12289;specular&#30456;&#20056;&#26469;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
      indirectLight.diffuse *= occlusion;
      indirectLight.specular *= occlusion;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgce50f8e" class="outline-5">
<h5 id="orgce50f8e">Transparency</h5>
<div class="outline-text-5" id="text-orgce50f8e">
</div>
<div id="outline-container-org3835774" class="outline-6">
<h6 id="org3835774">Cutout</h6>
<div class="outline-text-6" id="text-org3835774">
<ul class="org-ul">
<li>clip 操作对于移动平台的 TBDR 来说消耗比较大，通过添加 _RENDERING_CUTOUT ShaderFeature，对于不需要 clip 的材质可以提升渲染性能。<br /></li>
<li>修改 cutout 材质的渲染队列，让其在不透明(Opaque)物体之后绘制，这样如果 cutout 材质对应的物体被不透明物体遮挡了，就可以避免对 cutout 物体的绘制，从而提高性能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7e2bba0" class="outline-6">
<h6 id="org7e2bba0">Semitransparent</h6>
<div class="outline-text-6" id="text-org7e2bba0">
<ul class="org-ul">
<li>半透明物体需要采用 Blend SrcAlpha OneMinusSrcAlpha 的混合方式，这样才能将半透明物体后面的物体透出来。<br /></li>
<li>半透明物体不能写深度缓冲区，否则半透明物体叠加在一起时，深度测试会剔除掉物体的一部分，导致渲染结果不正确。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7df3a20" class="outline-6">
<h6 id="org7df3a20">RenderType tag</h6>
<div class="outline-text-6" id="text-org7df3a20">
<p>
下面是 Unity 内置 shader 的 Shader replacement tags, 在使用替换的 shader 进行渲染时，需要使用为 shader 设置的"RenderType" tag。<br />
</p>
<ul class="org-ul">
<li>Opaque: most of the shaders (Normal , Self Illuminated, Reflective, terrain shaders).<br /></li>
<li>Transparent: most semitransparent shaders (Transparent, Particle, Font, terrain additive pass shaders).<br /></li>
<li>TransparentCutout: masked transparency shaders (Transparent Cutout, two pass vegetation shaders).<br /></li>
<li>Background: Skybox shaders.<br /></li>
<li>Overlay: GUITexture, Halo, Flare shaders.<br /></li>
<li>TreeOpaque: terrain engine tree bark.<br /></li>
<li>TreeTransparentCutout: terrain engine tree leaves.<br /></li>
<li>TreeBillboard: terrain engine billboarded trees.<br /></li>
<li>Grass: terrain engine grass.<br /></li>
<li>GrassBillboard: terrain engine billboarded grass.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5779731" class="outline-6">
<h6 id="org5779731">Fading vs Transparency</h6>
<div class="outline-text-6" id="text-org5779731">
<ul class="org-ul">
<li>Fade Mode<br />
Fade Mode 中，使用的混合模式为 Blend SrcAlpha OneMinusSrcAlpha，几何体的颜色会依据 alpha 值降隐，漫反射和高光反射都会降隐。这种效果对于玻璃是不合适的，玻璃是全透明的，但是依然有清晰的高光和反射。<br /></li>
<li><p>
Transparent Mode<br />
Transparent Mode 中，使用的混合模式为 Blend One OneMinusSrcAlpha, albedo 会乘 alpha 值，因此漫反射会根据 alpha 值降隐，高光反射会影响到透明度。这种模式适用于玻璃。<br />
光线被反射后，透过半透明物体的光线会对应减少，如果所有光线都被反射，则不透明度为 1，如果没有光线被反射，则不透明度为原始值。y=kx+b 两个方程两个未知数，即可求出最终的 alpha 值。<br />
k * Reflectivity + b = newAlpha<br />
光线都被反射: Reflectivity=1 newAlpha=1          k*1 + b = 1          k=1-b<br />
光线没被反射: Reflectivity=0 newAlpha=oldAlpha   k*0 + b = oldAplha   b=oldAlpha<br />
newAlpha = (1-oldAlpha) * Reflectivity + oldAlpha<br />
         = Reflectivity - oldAlpha*Reflectivity + oldAlpha<br />
         = Reflectivity + oldAlpha*(1 - Reflectivity)<br />
         = oneMinusReflectivity + oldAlpha*oneMinusReflectivity<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_RENDERING_TRANSPARENT</span>)
    albedo *= alpha;
    alpha = 1 - oneMinusReflectivity + alpha * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #endif</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8c7a596" class="outline-5">
<h5 id="org8c7a596">Semitransparent Shadows</h5>
<div class="outline-text-5" id="text-org8c7a596">
</div>
<div id="outline-container-orgcd0f687" class="outline-6">
<h6 id="orgcd0f687">Cutout Shadow</h6>
<div class="outline-text-6" id="text-orgcd0f687">
<p>
透贴的阴影只需要在 ShadowCaster Pass 的片段着色器中使用 clip(alpha - _Cutoff)指令将对应的片段剔除就可以了。<br />
</p>
</div>
</div>
<div id="outline-container-org4ab8e8e" class="outline-6">
<h6 id="org4ab8e8e">Transparenct Shadow</h6>
<div class="outline-text-6" id="text-org4ab8e8e">
<p>
使用 Dithering 技术来实现半透明阴影。依据 alpha 值 clip 投影表面，从而模拟出半透明阴影。下图为使用这种技术实现的阴影效果：<br />
<img src="./UnityCatLikeCoding/20_01_16_semitransparent_shadow.png" alt="20_01_16_semitransparent_shadow.png" /><br />
</p>

<p>
_DitherMaskLOD Unity 使用的 Dither 贴图的模式如下，其一共包含 16 种模式，每个模式中的小像素块是 4x4 的像素块。开始是一个全空的模式(下图最右边)，依次向左每个模式填充一个像素块，直到模式中有 7 个像素块被填充。然后图案翻转，直到所有像素被填充。<br />
<img src="./UnityCatLikeCoding/20_01_16_dither-patterns.png" alt="20_01_16_dither-patterns.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679; _DitherMaskLOD &#29992;&#21040;&#30340;uv.z&#30340;&#33539;&#22260;&#20026;[0, 1] &#22240;&#20026;&#19968;&#20849;&#26377;16&#31181;&#27169;&#24335;&#65292;&#25152;&#20197;uv.z = 0 &#23545;&#24212;&#31532;&#19968;&#31181;&#27169;&#24335;uv.z = 1.0/16.0 = 0.0625 &#23545;&#24212;&#31532;&#20108;&#31181;&#27169;&#24335; uv.z = 0.9375 &#23545;&#24212;&#31532;15&#20013;&#27169;&#24335;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// alpha*0.9375 &#24403;alpha&#36234;&#23567;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#21491;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;0&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#24403;alpha&#36234;&#22823;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#24038;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;1&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#20174;&#32780;&#27169;&#25311;&#20102;&#21322;&#36879;&#26126;&#30340;&#38452;&#24433;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> uv = <span style="color: #ce537a; font-weight: bold;">float3</span>(i.vpos.xy, alpha*0.9375);
<span style="color: #ce537a; font-weight: bold;">float</span> dither = <span style="color: #4f97d7;">tex3D</span>(<span style="color: #7590db;">_DitherMaskLOD</span>, uv);
<span style="color: #4f97d7;">clip</span>(dither - 0.01);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc1c5383" class="outline-5">
<h5 id="orgc1c5383">Deferred Shading</h5>
<div class="outline-text-5" id="text-orgc1c5383">
</div>
<div id="outline-container-org4c1853c" class="outline-6">
<h6 id="org4c1853c">Forward Path vs Deferred Path</h6>
<div class="outline-text-6" id="text-org4c1853c">
</div>
<ul class="org-ul">
<li><a id="orgadc5973"></a>DrawCall 对比<br />
<div class="outline-text-7" id="text-orgadc5973">
<p>
当场景中只有一个方向光时，Forward Path 和 Deferred Path 的 DrawCall 数目相差不多，Forward Path 因为需要单独生成 DepthTexture，在开始的 DepthPass 中多出了 48 个 DrawCall<br />
场景中有两个方向光时，Forward Path 比 Deferred Path 多出了很多 DrawCall。<br />
</p>

<p>
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall0.png" alt="20_01_16_deferred_renderring_drawcall0.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall1.png" alt="20_01_16_deferred_renderring_drawcall1.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall2.png" alt="20_01_16_deferred_renderring_drawcall2.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall3.png" alt="20_01_16_deferred_renderring_drawcall3.png" /><br />
</p>
</div>

<ul class="org-ul">
<li><a id="orge2d942a"></a>为什么场景中存在多个光照时，Deferred Path 比 Forward Path 的 DrawCall 数目更少？<br />
<div class="outline-text-8" id="text-orge2d942a">
<p>
为了渲染物体，shader 必须抓取物体的 mesh 数据，将其转化到正确的坐标空间中，然后将数据进行插值，最后，获取表面属性，计算光照。<br />
Forward Path 必须为照亮物体的每一个像素光源执行前面提到的步骤，因为 DepthBuffer 已经被填充，所以额外的 Pass 比第一个 Pass 消耗要少一些，而且它们不需要考虑间接光照。但是，他们依然需要重复处理第一个 Pass 已经做过的很多工作。<br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work.png" alt="01_12de_duplicate-work.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work1.png" alt="01_12de_duplicate-work1.png" /><br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgcc3a69e"></a>GBuffer 内容<br />
<div class="outline-text-7" id="text-orgcc3a69e">
<p>
<img src="./UnityCatLikeCoding/01_12de_gbuffer0.png" alt="01_12de_gbuffer0.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer1.png" alt="01_12de_gbuffer1.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer2.png" alt="01_12de_gbuffer2.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer3.png" alt="01_12de_gbuffer3.png" /><br />
</p>
</div>
</li>
<li><a id="org0f5cf63"></a>Rendering Lights<br />
<ul class="org-ul">
<li><a id="orgfbb3de4"></a>Directional Lights<br />
<div class="outline-text-8" id="text-orgfbb3de4">
<p>
因为方向光影响所有物体，通过渲染一个覆盖整个视图的四边形来计算方向光的渲染。Unity 默认使用 Internal-DeferredShading.shader 来渲染这个四边形。(每个方向光使用一个四边形计算一次，多个方向光计算多次)<br />
下图中使用了两个方向光，其中渲染了两次：<br />
<img src="./UnityCatLikeCoding/01_12de_directional_light_rendering.png" alt="01_12de_directional_light_rendering.png" /><br />
</p>
</div>
</li>
<li><a id="org25c3351"></a>Spot Lights<br />
<div class="outline-text-8" id="text-org25c3351">
<p>
spot light 不会影响所有物体，使用一个棱锥体可以表示 Spot light 照亮的体积，所以通过渲染一个棱锥体来执行 Spot Light 的渲染，这样只有棱锥体可见区域会被渲染。如果棱锥体完全被其他物体遮挡，则不需要渲染该 spot light。如果棱锥体的任何一个片段被渲染，将会执行该 spot light 的光照计算。<br />
只有真的有物体在 spot light 照亮的体积中时，光照计算才是有意义的。在棱锥体后面的几何体是不需要渲染的，因为 spot light 照不到该几何体。<br />
  为了避免渲染不必要的片段，首先使用 Internal-StencilWrite.shader 渲染棱锥体，该 Pass 会写入模板缓冲区，用来标识哪些片段需要渲染。不过当棱锥体和摄像机近平面交叉时不能使用该技术，因为此时近平面外的正面被摄像机剔除，只有反面写入了模板值。<br />
<img src="./UnityCatLikeCoding/01_12de_spot_light_rendering.png" alt="01_12de_spot_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="org9d2bdda"></a>Point lights<br />
<div class="outline-text-8" id="text-org9d2bdda">
<p>
point light 和 spot light 类似，只是使用球体来表示 point light 照亮的体积。<br />
<img src="./UnityCatLikeCoding/01_12de_point_light_rendering.png" alt="01_12de_point_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="orgfed23fb"></a>Light Volume<br />
<div class="outline-text-8" id="text-orgfed23fb">
<p>
直接渲染 Light Volume 而不做特殊处理会有以下问题：<br />
</p>
<ol class="org-ol">
<li>当灯光和近平面相交时，可见的 Light Volume 是背面，不关闭背面剔除 。灯光就不可见了。<br /></li>
<li><p>
由于我们是将 Light Volume 投影到屏幕上来得到光源影响范围。这会导致 Light Volume 远离屏幕一侧的物体也会参与光照计算。如下图：<br />
</p>

<div id="org74b7be9" class="figure">
<p><img src="./UnityCatLikeCoding/render_deferred_lighting_02.png" alt="render_deferred_lighting_02.png" width="150px" /><br />
</p>
</div></li>
</ol>

<p>
可以利用模板缓冲区来解决上面问题，具体做法如下：<br />
a. 渲染 Light Volume，开启深度测试，Cull Back（渲染正面），关闭深度写入，模板测试全通过。<br />
b. 深度测试失败, 模板值减 1，深度测试成功，模板值不变<br />
c. 再次渲染 LightVolume, 开启深度测试，Cull Front（渲染背面），关闭深度写入，模板测试全通过。<br />
d. 深度测试失败，模板值加 1，深度测试成功，模板值不变<br />
e. 再次渲染 LightVolume, 开启模板测试, 进行光照计算。<br />
</p>

<div id="orge85a264" class="figure">
<p><img src="./UnityCatLikeCoding/render_deferred_lighting_01.png" alt="render_deferred_lighting_01.png" width="150px" /><br />
</p>
</div>

<p>
Tips: 该方法还适用于多光源<br />
</p>

<div id="org7a7c6b4" class="figure">
<p><img src="./UnityCatLikeCoding/render_deferred_lighting_03.png" alt="render_deferred_lighting_03.png" width="150px" /><br />
</p>
</div>

<p>
详细解释可以参考:<br />
</p>
<ul class="org-ul">
<li>英文版 <a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
<li>中文版 <a href="https://zhuanlan.zhihu.com/p/232350788">https://zhuanlan.zhihu.com/p/232350788</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org210d577"></a>Light Range<br />
<div class="outline-text-7" id="text-org210d577">
<p>
延迟渲染中，Unity 默认使用 LDR(Low Dynamic Range)渲染场景，此时颜色值被写入到 ARGB32 格式的贴图中，Unity 使用对数运算来编码颜色从而扩大存储的颜色范围。Final Deferred Pass 会将这些颜色值转化为正常范围的颜色值。可以在 Camera 中可以设置是否开启 HDR。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  col.xyz += <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(i);
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(DEFERRED_PASS)
    output.gBuffer0.rgb = albedo;
    output.gBuffer0.a = <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
    output.gBuffer1.rgb = specColor;
    output.gBuffer1.a = smoothness;
    output.gBuffer2 = <span style="color: #bc6ec5; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">    #if</span> <span style="color: #a45bad;">!</span><span style="color: #bc6ec5;">defined</span>(UNITY_HDR_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#25351;&#25968;-&#23545;&#25968;&#36816;&#31639;&#26469;&#32534;&#30721;&#35299;&#30721;&#39068;&#33394;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exp2(-col.rgb) = 2^{-col.rgb}</span>
      col.rgb = <span style="color: #bc6ec5; font-weight: bold;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    output.gBuffer3 = col;
<span style="color: #bc6ec5;">  #else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return indirect.specular.rgbr;</span>
    output.color = col;
<span style="color: #bc6ec5;">  #endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DEFFERRED_PASS</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<p>
下图为不开启和开启 HDR 对于的 RenderTarget 贴图格式：<br />
<img src="./UnityCatLikeCoding/01_12de_ldr.png" alt="01_12de_ldr.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_hdr.png" alt="01_12de_hdr.png" /><br />
</p>
</div>
</li>

<li><a id="org967bc6e"></a>Mixing Rendering Modes<br />
<div class="outline-text-7" id="text-org967bc6e">
<p>
场景中一部分物体使用的 shader 不支持延迟渲染模式时，引擎会先执行延迟渲染，将支持延迟渲染的物体绘制出来，然后再执行前向渲染，将其他不支持延迟渲染的物体绘制出来。<br />
Unity 的延迟渲染不支持半透明物体，半透明物体需要 Forward rendering 阶段来渲染(因为半透明物体意味着需要将半透明物体叠在其后面的物体上，每多一个半透物体重叠就额外需要一整套 GBuffer 来存储对应半透明物体的渲染数据)。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgbf6d7ec" class="outline-6">
<h6 id="orgbf6d7ec">Support Deferred Path</h6>
<div class="outline-text-6" id="text-orgbf6d7ec">
</div>
<ul class="org-ul">
<li><a id="orgfe5e84d"></a>创建 deferred pass<br />
<div class="outline-text-7" id="text-orgfe5e84d">
<p>
延迟渲染需要 GPU 支持 MRT(multiple render targets).<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Tags</span> {
          <span style="color: #2aa1ae; background-color: #292e34;">// &#34920;&#31034;&#35813;Pass&#29992;&#20110;&#24310;&#36831;&#28210;&#26579;</span>
          <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"Deferred"</span>
      }

      <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">      #pragma</span> target 3.0
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22914;&#26524;GPU&#19981;&#25903;&#25345;MRT&#21017;&#25490;&#38500;&#24403;&#21069;Pass</span>
<span style="color: #bc6ec5;">      #pragma</span> exclude_renderers nomrt

      <span style="color: #2aa1ae; background-color: #292e34;">// &#24310;&#36831;&#28210;&#26579;&#19981;&#25903;&#25345; _RENDERING_FADE&#21644; _RENDERING_TRANSPARENT</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature _ <span style="color: #7590db;">_RENDERING_CUTOUT</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_METALLIC_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature _ <span style="color: #7590db;">_SMOOTHNESS_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESS_METALLIC</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_NORMAL_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_OCCLUSION_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_MASK</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_ALBEDO_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_NORMAL_MAP</span>

<span style="color: #bc6ec5;">      #pragma</span> vertex MyVertexProgram
<span style="color: #bc6ec5;">      #pragma</span> fragment MyFragmentProgram

<span style="color: #bc6ec5;">      #define</span> DEFERRED_PASS

<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"MyDeferred.cginc"</span>
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
  }
</pre>
</div>
</div>
</li>

<li><a id="org97ab56b"></a>deferred pass frag output<br />
<div class="outline-text-7" id="text-org97ab56b">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> FragmentOutput {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#24310;&#36831;&#28210;&#26579;&#38656;&#35201;&#23558;&#25968;&#25454;&#20445;&#23384;&#21040;&#22810;&#20010;RenderTarget</span>
<span style="color: #bc6ec5;">      #if</span> defined(DEFERRED_PASS)
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">      #endif</span>
  };
</pre>
</div>
</div>
</li>
<li><a id="orgedca05a"></a>gbufer0123<br />
<div class="outline-text-7" id="text-orgedca05a">
<div class="org-src-container">
<pre class="src src-shader">  FragmentOutput output;
<span style="color: #bc6ec5;">  #if</span> defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HDR_ON)
      color.rgb = <span style="color: #4f97d7;">exp2</span>(-color.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer0.rgb &#35760;&#24405;albedo</span>
    output.gBuffer0.rgb = albedo;
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer0.a&#35760;&#24405;Occlusion</span>
    output.gBuffer0.a = GetOcclusion(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer1.rgb &#35760;&#24405;&#20102; specularColor</span>
    output.gBuffer1.rgb = specularTint;
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer1.a &#35760;&#24405;&#20102;Smoothness</span>
    output.gBuffer1.a = GetSmoothness(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer2&#20013;&#35760;&#24405;&#20102;normal</span>
    output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal * 0.5 + 0.5, 1);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer3&#20013;&#35760;&#24405;&#20102;Emissive &#21644; environment ambient&#65292;&#21518;&#32493;&#20809;&#29031;&#35745;&#31639;&#24471;&#21040;&#30340;&#39068;&#33394;&#37117;&#20250;&#21472;&#21152;&#21040;GBuffer3&#20013;</span>
    output.gBuffer3 = color;
<span style="color: #bc6ec5;">  #else</span>
    output.color = ApplyFog(color, i);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>为什么自己写的 DeferredPass GBuffer0 中输出了高光颜色，GBuffer1 中颜色比较暗?<br />
FrameDebug 发现 MetallicMap 的贴图使用了 Unity 的默认贴图，进一步检查发现 shader 属性列表中定义的属性名称和 shader 中使用的名称不一致。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc80ee4e"></a>support LDR<br />
<div class="outline-text-7" id="text-orgc80ee4e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
    output.gBuffer0.rgb = albedo;
    output.gBuffer0.a = GetOcclusion(i);
    output.gBuffer1.rgb = specColor;
    output.gBuffer1.a = smoothness;
    output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HDR_ON)
    col.rgb = <span style="color: #4f97d7;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    output.gBuffer3 = col;
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//return indirect.specular.rgbr;</span>
    output.color = col;
<span style="color: #bc6ec5;">#endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// DEFFERRED_PASS</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>Tone mapping 进化论 <a href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a><br /></li>
<li>Tone Mapping 与 Gamma Correction <a href="https://zhuanlan.zhihu.com/p/79203830">https://zhuanlan.zhihu.com/p/79203830</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc3d5834" class="outline-6">
<h6 id="orgc3d5834">Deferred Reflections</h6>
<div class="outline-text-6" id="text-orgc3d5834">
</div>
<ul class="org-ul">
<li><a id="org99e4e28"></a>Unity 内置的屏幕空间反射<br />
<div class="outline-text-7" id="text-org99e4e28">
<p>
延迟渲染时，反射球会被渲染，反射球被投影到和反射球体积有交叉的几何体上。因此，反射球的反射不会扩展到反射球体积之外。反射球的渲染类似于灯光的渲染，只是反射球是使用正方体渲染的。<br />
多个反射球按照顺序渲染，首先 skybox 被渲染，会覆盖整个视图。然后，各个反射球被渲染，每个反射球只会覆盖其体积内的表面。多个反射球体积有重叠时，重叠区域内，先绘制的反射球会被后绘制的反射球覆盖。<br />
默认情况下，体积大的反射球会先绘制，这样体积小的反射球就可以覆盖体积大的反射球。你可以通过修改反射球的 Importance 属性值来调整它的绘制顺序。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_probe_params.png" alt="01_12de_reflection_probe_params.png" /><br />
</p>
</div>
</li>

<li><a id="org87cf2ec"></a>延迟渲染使用非屏幕空间反射<br />
<div class="outline-text-7" id="text-org87cf2ec">
<p>
关闭延迟渲染的屏幕空间反射后，Unity 会采用前向渲染的方式计算反射，将反射效果写入 GBuffer3 中。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_no_screen_space.png" alt="01_12de_reflection_no_screen_space.png" /><br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge9a445b" class="outline-5">
<h5 id="orge9a445b">Fog</h5>
<div class="outline-text-5" id="text-orge9a445b">
</div>
<div id="outline-container-org1397f38" class="outline-6">
<h6 id="org1397f38">Forward Fog</h6>
<div class="outline-text-6" id="text-org1397f38">
<p>
在 LightSetting 可以设置雾相关的属性。<br />
</p>

<ul class="org-ul">
<li>ForwardPath 中为什么天空盒子不受雾效果的影响？<br />
雾效果是在 Standard Shader 中的片段着色器中，对片段颜色进行修改来实现的。Unity 的天空盒并没有使用 Standard Shader 进行渲染，所以其不受雾影响。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org3f8ebac"></a>Linear Fog<br />
<div class="outline-text-7" id="text-org3f8ebac">
<p>
线性模式的雾可以设置雾生效的最小距离和最大距离。离摄像机距离小于最小距离时没有雾的效果，在最小距离到最大距离雾的效果逐渐增加到最大，大于最大距离时显示最大雾的效果（即物体完全呈现雾的颜色）<br />
</p>

<p>
LinearFog 计算公式 \(f = \frac{fogEnd - fogCoor}{fogEnd-fogStart}\)<br />
</p>
</div>
</li>
<li><a id="org13fcd4f"></a>Exponential Fog<br />
<div class="outline-text-7" id="text-org13fcd4f">
<p>
一次指数模式的雾。<br />
</p>

<p>
ExponentialFog 计算公式 \(f = 2^{-fogCoor*fogDensity}\)<br />
</p>
</div>
</li>
<li><a id="org546d728"></a>Exponential Squared Fog<br />
<div class="outline-text-7" id="text-org546d728">
<p>
二次指数模式的雾。<br />
</p>

<p>
ExponentialSquaredFog 计算公式 \(f = 2^{-(fogCoor*fogDensity)^{2}}\)<br />
</p>


<div id="org5e14143" class="figure">
<p><img src="./UnityCatLikeCoding/01_14fo_expFog.jpg" alt="01_14fo_expFog.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgcb6a305"></a>Depth-Based Fog<br />
<div class="outline-text-7" id="text-orgcb6a305">
<p>
Unity Shader 使用裁剪空间坐标的 w 分量作为 Fog Coordinate，裁剪空间坐标的 w 分量为投影变换前摄像机坐标系下坐标的 z 分量。这种计算雾的方式也称为基于深度的雾计算。<br />
基于深度的雾计算比基于距离的雾计算效率更高。基于距离的雾比基于深度的雾效果要好，基于深度的雾在摄像机旋转视角时，雾效会变化。下图说明了其中的原理：<br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_001.png" alt="01_14fo_depth_vs_distance_001.png" /><br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_002.png" alt="01_14fo_depth_vs_distance_002.png" /><br />
</p>
</div>
</li>

<li><a id="orgff89656"></a>代码实现<br />
<ul class="org-ul">
<li><a id="orgac0bc7e"></a>ApplyFog<br />
<div class="outline-text-8" id="text-orgac0bc7e">
<div class="org-src-container">
<pre class="src src-shader">  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      o.pos = UnityObjectToClipPos(v.vertex);
      o.uv.xy  = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      o.worldNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
      o.worldPos = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22522;&#20110;&#28145;&#24230;&#30340;&#38654;</span>
<span style="color: #bc6ec5;">  #if</span> FOG_DEPTH
      <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL clip space z range = [-near, far]</span>
      o.worldPos.w = o.pos.z;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> tangentWorld = UnityObjectToWorldDir(v.tangent.xyz);
      <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = MCreateTangentToWorldPerVertex(o.worldNormal, tangentWorld, v.tangent.w);
      o.tangentToWorld[0] = tangentToWorld[0];
      o.tangentToWorld[1] = tangentToWorld[1];
      o.tangentToWorld[2] = tangentToWorld[2];
      ComputeVertexLightColor(o);

<span style="color: #bc6ec5;">      #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS)
      TRANSFER_SHADOW(o);
<span style="color: #bc6ec5;">      #else</span>
      UNITY_TRANSFER_SHADOW(o, 0);
<span style="color: #bc6ec5;">      #endif</span>
      COMPUTE_LIGHT_COORDS(o);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }


  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ApplyFog</span>(<span style="color: #ce537a; font-weight: bold;">float</span> color, v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos);
<span style="color: #bc6ec5;">  #if</span> FOG_DEPTH
      viewDistance = UNITY_Z_0_FAR_FROM_CLIPSPACE(i.worldPos.w);
<span style="color: #bc6ec5;">  #endif</span>
      UNITY_CALC_FOG_FACTOR_RAW(viewDistance);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#22810;&#20809;&#28304;&#25903;&#25345; &#21482;&#38656;&#35201;&#23545;&#31532;&#19968;&#20010;&#20809;&#28304;&#21472;&#21152;&#38654;&#30340;&#39068;&#33394;&#23601;&#21487;&#20197;&#20102;&#65292;&#20854;&#20182;&#20809;&#28304;&#21482;&#26681;&#25454;&#38654;&#30340;&#24378;&#24230;&#36827;&#34892;&#20943;&#24369;&#12290;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> fogColor = 0;
<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS)
      fogColor = unity_FogColor.rgb;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(fogColor, color, unityFogFactor);
  }
</pre>
</div>
</div>
</li>
<li><a id="org5195192"></a>UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) 将 zclip space z value map to [0, far]<br />
<div class="outline-text-8" id="text-org5195192">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(UNITY_REVERSED_Z)
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z == 1
        <span style="color: #2aa1ae; background-color: #292e34;">//D3d with reversed Z =&gt; z clip range is [near, 0] -&gt; remapping to [0, far]</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(((1.0-(coord)/<span style="color: #7590db;">_ProjectionParams</span>.y)*<span style="color: #7590db;">_ProjectionParams</span>.z),0)
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//GL with reversed z =&gt; z clip range is [near, -far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(-(coord), 0)
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#elif</span> UNITY_UV_STARTS_AT_TOP
    <span style="color: #2aa1ae; background-color: #292e34;">//D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//Opengl =&gt; z clip range is [-near, far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>为什么此处不需要将 Z 值线性化？而从深度缓存区取出的深度值需要线性化？<br />
 ClipSpace 的 Z 值(OpenGL Clip Space Z Range=[-near,far])没有经过透视除法，所以其 Z 值本身就是线性的;<br />
深度缓冲区中的 Z 值（Depth Buffer Z Range=[0, 1]）经过了透视除法，其值不是线性的(10%近处的场景占用了 0-0.9 范围的深度)。<br />
<ul class="org-ul">
<li>Depth Testing <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a><br /></li>
<li>linear Depth Buffer(线性深度缓冲区) <a href="https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html">https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc0783f3"></a>UNITY_CALC_FOG_FACTOR_RAW 实现了前面的计算公式<br />
<div class="outline-text-8" id="text-orgc0783f3">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(FOG_LINEAR)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = (end-z)/(end-start) = z * (-1/(end-start))+(end/(end-start))</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        (coord) * unity_FogParams.z + unity_FogParams.w
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = exp(-density*z)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        unity_FogParams.y * (coord); \
        unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor)
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP2)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = exp(-(density*z)^2)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        unity_FogParams.x * (coord); \
        unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor*unityFogFactor)
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = 0.0
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// x = density / sqrt(ln(2)), useful for Exp2 mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// y = density / ln(2), useful for Exp mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// z = -1/(end-start), useful for Linear mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// w = end/(end-start), useful for Linear mode</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> unity_FogParams;
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orge45994c" class="outline-6">
<h6 id="orge45994c">Deferred Fog</h6>
<div class="outline-text-6" id="text-orge45994c">
</div>
<ul class="org-ul">
<li><a id="org20cd182"></a>Shader Source Code<br />
<div class="outline-text-7" id="text-org20cd182">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Custom/DeferredFog"</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
      <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
      <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_CameraDepthTexture</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_FrustumCorners</span>[4];

      <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
          <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      };

      <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
          <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
          <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
          <span style="color: #ce537a; font-weight: bold;">float3</span> ray;
<span style="color: #bc6ec5;">          #endif</span>
      };

      Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
          Interpolators i;
          i.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.vertex.xy, 0.0, 1.0);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#30452;&#25509;&#36890;&#36807;&#19977;&#35282;&#24418;&#39030;&#28857;&#22352;&#26631;&#27714;&#30340;uv&#22352;&#26631;</span>
          i.uv = (v.vertex + 1) * 0.5;
<span style="color: #bc6ec5;">          #if</span> UNITY_UV_STARTS_AT_TOP
            i.uv= i.uv * <span style="color: #ce537a; font-weight: bold;">float2</span>(1.0, -1.0) + <span style="color: #ce537a; font-weight: bold;">float2</span>(0.0, 1.0);
<span style="color: #bc6ec5;">          #endif</span>
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
            <span style="color: #2aa1ae; background-color: #292e34;">// &#23558; i.uv &#26144;&#23556;&#20026;&#25968;&#32452;&#30340;&#32034;&#24341;&#20540;</span>
            i.ray = <span style="color: #7590db;">_FrustumCorners</span>[i.uv.x+2*i.uv.y]
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> i;
      }

      <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">FragmentProgram</span> (Interpolators i) : <span style="color: #a45bad;">SV_Target</span> {
          <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, i.uv);
          depth = Linear01Depth(depth);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20026;&#20102;&#21644;Forward Path&#20013;&#28145;&#24230;&#38654;&#35745;&#31639;&#19968;&#30452;&#38656;&#35201;&#20943;&#25481;near , &#21442;&#32771; UNITY_Z_0_FAR_FROM_CLIPSPACE &#20989;&#25968;&#20013;&#30340;&#22788;&#29702;</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// _ProjectionParams // x=1 or -1  y=near z=far w=1/far</span>
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
          <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(depth * i.ray);
<span style="color: #bc6ec5;">          #else</span>
          <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = depth * <span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y;
<span style="color: #bc6ec5;">          #endif</span>
          UNITY_CALC_FOG_FACTOR_RAW(viewDistance);
          unityFogFactor = <span style="color: #4f97d7;">saturate</span>(unityFogFactor);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#22825;&#31354;&#30418;&#28145;&#24230;&#20540;&#20026;1&#65292;&#36890;&#36807;&#19979;&#38754;&#21028;&#26029;&#65292;&#35753;&#38654;&#19981;&#24433;&#21709;&#22825;&#31354;&#30418;</span>
          <span style="color: #4f97d7; font-weight: bold;">if</span> (depth &gt; 0.9999)
          {
              unityFogFactor = 1;
          }
          <span style="color: #ce537a; font-weight: bold;">float3</span> color = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv).rgb;
          <span style="color: #ce537a; font-weight: bold;">float3</span> foggedColor = <span style="color: #4f97d7;">lerp</span>(unity_FogColor.rgb, color, unityFogFactor);
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(foggedColor, 1);
      }
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

      <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
          <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">              #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">              #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">              #pragma</span> multi_compile_fog
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
          <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">              #define</span> FOG_DISTANCE
<span style="color: #bc6ec5;">              #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">              #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">              #pragma</span> multi_compile_fog
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="orgfeb1bbc"></a>Depth-Based Fog<br /></li>
<li><a id="org6526a6e"></a>Distance Based Fog<br />
<div class="outline-text-7" id="text-org6526a6e">
<p>
从摄像机原点向远平面发射一条射线，如果从原点到远平面之间有物体，这射线最先接触的物体的交点到摄像机原点的距离就是我们要求的距离。<br />
从摄像机原点 O 到远平面交点 F 的射线(向量 OF)和从原点 O 到最先接触物体的交点 I 的射线(向量 OI)之间的关系为 \(OF=depth*OI\) ,其中 depth 为交点 I 对应的深度值。<br />
在 vertex shader 中设置每个顶点对应的 \(ray=\overrightarrow{OF}\) ,在 fragment shader 中就会得到各个像素对应的 OF 向量。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org470faef" class="outline-5">
<h5 id="org470faef">Deferred Lights</h5>
<div class="outline-text-5" id="text-org470faef">
</div>
<div id="outline-container-org3bada48" class="outline-6">
<h6 id="org3bada48">Light Shader</h6>
<div class="outline-text-6" id="text-org3bada48">
</div>
<ul class="org-ul">
<li><a id="org0501beb"></a>两个 Pass<br />
<div class="outline-text-7" id="text-org0501beb">
<p>
DeferredShading 需要两个 Pass。第一个 Pass 执行光照计算，第二个 Pass 处理 LDR 模式下的颜色解码。<br />
当 HDR 没开启时，光照数据是按照指数-对数运算编码解码的，前面的 DeferredShading 使用指数运算进行了编码，此时需要使用对数运算进行解码。<br />
</p>
</div>
</li>
<li><a id="orge7f54d9"></a>Avoiding the Sky<br />
<div class="outline-text-7" id="text-orge7f54d9">
<p>
当 HDR 没有开启时，SceneView 中天空盒会显示不正确(Unity 2020.1.4f1 版本)，在第二个 Pass 中使用 StencilBuffer 作为 Mask，从而避免对数运算解码对天空盒对应的像素进行操作。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
      <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
      <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
      <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off

      <span style="color: #4f97d7; font-weight: bold;">Stencil</span> {
          <span style="color: #4f97d7; font-weight: bold;">Ref</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
          <span style="color: #4f97d7; font-weight: bold;">ReadMask</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
          <span style="color: #4f97d7; font-weight: bold;">CompBack</span> Equal
          <span style="color: #4f97d7; font-weight: bold;">CompFront</span> Equal
      }
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5015fa8" class="outline-6">
<h6 id="org5015fa8">Directional Lights</h6>
<div class="outline-text-6" id="text-org5015fa8">
<p>
使用正交投影矩阵渲染一个矩形。具体实现参考有道云笔记 Unity Source Code.md<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9d99066"></a>读取 G-Buffer 数据使用的 UV<br />
<div class="outline-text-7" id="text-org9d99066">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
  };

  Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
      Interpolators i;
      i.pos = UnityObjectToClipPos(v.vertex);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35835;&#21462;G-Buffer&#25968;&#25454;&#20351;&#29992;&#30340;UV</span>
      i.uv = ComputeScreenPos(i.pos);
      <span style="color: #4f97d7; font-weight: bold;">return</span> i;
  }
</pre>
</div>
</div>
</li>
<li><a id="orga37f896"></a>像素对应的世界坐标位置<br />
<div class="outline-text-7" id="text-orga37f896">
<p>
从原始透视摄像机到近平面四个角的射线存储在绘制四边形的 normal 中。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> ray : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
      Interpolators i;
      i.pos = UnityObjectToClipPos(v.vertex);
      i.uv = ComputeScreenPos(i.pos);
      i.ray = v.normal;
      <span style="color: #4f97d7; font-weight: bold;">return</span> i;
  }
  <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
  {
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv = i.uv.xy / i.uv.w;
      <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, uv);
      depth = Linear01Depth(depth);
      <span style="color: #ce537a; font-weight: bold;">float3</span> rayToFarPlane = i.ray * <span style="color: #7590db;">_ProjectionParams</span>.z / i.ray.z;
      <span style="color: #ce537a; font-weight: bold;">float3</span> viewPos = rayToFarPlane * depth;
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27714;&#20687;&#32032;&#23545;&#24212;&#30340;&#19990;&#30028;&#22352;&#26631;&#20301;&#32622;&#65292;unity_CameraToWorld&#30697;&#38453;&#20026;&#21407;&#22987;&#36879;&#35270;&#25668;&#20687;&#26426;&#21040;&#19990;&#30028;&#31354;&#38388;&#30340;&#36716;&#25442;&#30697;&#38453;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos = <span style="color: #4f97d7;">mul</span>(unity_CameraToWorld, <span style="color: #ce537a; font-weight: bold;">float4</span>(viewPos, 1)).xyz;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="orgf4f786a"></a>Supporting LDR<br />
<div class="outline-text-7" id="text-orgf4f786a">
<p>
HDR 模式下，DeferredShading 只需要一个 Pass，该 Pass 的 Blend 模式设置为 Blend One One。直接将光照效果叠在之前计算的 Emission 等之上。<br />
LDR 模式下，DeferredShading 需要两个 Pass：<br />
第一个 Pass 执行光照计算，计算所得的颜色为 exp2(-lightingResult)，该值需要和之前 GBuffer 存储的颜色 exp2(-emissionGBuffer)组合起来，因此其 Blend 模式设置为 Blend DstColor Zero。<br />
第二个 Pass 对颜色进行解码，其 Blend 模式设置为 Blend One Zero。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6b7c7a7" class="outline-6">
<h6 id="org6b7c7a7">Point Lights</h6>
<div class="outline-text-6" id="text-org6b7c7a7">
<p>
将点光源当作一个球来进行渲染。具体渲染流程如下：<br />
</p>
<ol class="org-ol">
<li>按照下面方法，使用模板标记出处于球体内的对象：<br />
<ol class="org-ol">
<li><p>
Write Depth Off, DepthTest LEqual, Cull Front; 渲染点光源对应的球，未通过深度测试的像素，Stencil 值加 1。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">        <span style="color: #4f97d7; font-weight: bold;">Stencil</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">ReadMask</span>  8
            <span style="color: #4f97d7; font-weight: bold;">WriteMask</span> 8
            <span style="color: #4f97d7; font-weight: bold;">Comp</span>  always
            <span style="color: #4f97d7; font-weight: bold;">Pass</span>  keep
            <span style="color: #4f97d7; font-weight: bold;">Fail</span>  keep
            <span style="color: #4f97d7; font-weight: bold;">ZFail</span> IncrementSaturate
        }
</pre>
</div></li>
<li>Write Depth Off, DepthTest LEqual, Cull Back;  渲染点光源对应的球，未通过深度测试的像素，Stencil 值减 1。<br /></li>
</ol></li>
<li><p>
Depth Aways, Cull Front; Stencil 如下; 渲染点光源对应的球。<br />
Tips: 此处 Cull Front 来处理摄像机在点光源球内的情况。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">     <span style="color: #4f97d7; font-weight: bold;">Stencil</span>
     {
         <span style="color: #4f97d7; font-weight: bold;">Ref</span>       0
         <span style="color: #4f97d7; font-weight: bold;">ReadMask</span>  8
         <span style="color: #4f97d7; font-weight: bold;">WriteMask</span> 8
         <span style="color: #4f97d7; font-weight: bold;">Comp</span>  Greater
         <span style="color: #4f97d7; font-weight: bold;">Pass</span>  keep
         <span style="color: #4f97d7; font-weight: bold;">Fail</span>  keep
         <span style="color: #4f97d7; font-weight: bold;">ZFail</span> keep
     }
</pre>
</div></li>
</ol>

<p>
详细的原理解释可以参考下面的链接：<br />
</p>
<ul class="org-ul">
<li><a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
</ul>

<p>
Unity Stencil 对 8 位模板值每位的分配如下：<br />
</p>
<ol class="org-ol">
<li>Bit #7 标记非背景的对象<br /></li>
<li>Bit #6 标记非 lightmapped 对象<br /></li>
<li>Bit #5 Unity 未使用<br /></li>
<li>Bit #4 用于光照体的 Culling<br /></li>
<li>Bit #1-3 用于 light layer culling mask<br /></li>

<li><a href="https://docs.unity3d.com/Manual/SL-Stencil.html">https://docs.unity3d.com/Manual/SL-Stencil.html</a><br /></li>
</ol>
</div>
</div>
<div id="outline-container-orga6a8fbf" class="outline-6">
<h6 id="orga6a8fbf">Spotlights</h6>
<div class="outline-text-6" id="text-orga6a8fbf">
<p>
因为方向光可以影响到所有的物体，因此通过绘制全屏的矩形来实现方向光照明。SpotLight 只会影响其锥形范围内的物体，通常不需要为整个屏幕像素计算 SpotLight，通过绘制一个包含了 SpotLight 的金字塔来实现 SpotLight 照明。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org099e5f3"></a>像素对应的世界坐标位置<br />
<div class="outline-text-7" id="text-org099e5f3">
<div class="org-src-container">
<pre class="src src-shader">  unity_v2f_deferred <span style="color: #bc6ec5; font-weight: bold;">vert_deferred</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>)
  {
      unity_v2f_deferred o;
      o.pos = UnityObjectToClipPos(vertex);
      o.uv = ComputeScreenPos(o.pos);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#20174;&#36879;&#35270;&#25668;&#20687;&#26426;&#21407;&#28857;&#21040;&#20687;&#32032;&#23545;&#24212;&#30340;&#39030;&#28857;&#30340;&#23556;&#32447;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// TODO Unity Camera Space&#21644;OpenGL&#24815;&#20363;&#30456;&#21516;&#65292;&#21363;Camera&#30340;forward&#26041;&#21521;&#20026;Z&#36724;&#30340;&#36127;&#26041;&#21521;&#65292;&#22240;&#27492;&#65292;&#27492;&#22788;&#38656;&#35201;&#21453;&#21521;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html</span>
      o.ray = UnityObjectToViewPos(vertex) * <span style="color: #ce537a; font-weight: bold;">float3</span>(-1,-1,1);

      <span style="color: #2aa1ae; background-color: #292e34;">// normal contains a ray pointing from the camera to one of near plane's</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// corners in camera space when we are drawing a full screen quad.</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// Otherwise, when rendering 3D shapes, use the ray calculated here.</span>
      o.ray = <span style="color: #4f97d7;">lerp</span>(o.ray, normal, <span style="color: #7590db;">_LightAsQuad</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org71fcfc2" class="outline-6">
<h6 id="org71fcfc2">Q&amp;A</h6>
<div class="outline-text-6" id="text-org71fcfc2">
</div>
<ul class="org-ul">
<li><a id="org36ae608"></a>为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？<br />
<div class="outline-text-7" id="text-org36ae608">
<p>
参考有道云笔记 Unity Source Code.md，可以看出 Directional 对应的四边形的顶点 Position 数据为(0,0,nearPlane) (0,1,nearPlane) (1,1,nearPlane) (1,0,nearPlane)。绘制该矩形使用的矩阵为正交矩阵。这四个顶点经过正交矩阵变换后就是屏幕上 4 个角的点，nearPlane 对应 4 个角经过透视投影变换后也为屏幕上 4 个角的点。<br />
</p>
</div>
</li>

<li><a id="orgb54a889"></a>为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？<br />
<div class="outline-text-7" id="text-orgb54a889">
<p>
DeferredShading 为了不覆盖之前 ColorBuffer 中的内容，其混合模式使用了 Blend One One, 所以当 DeferredShading 返回 0 时，其实显示的是之前绘制的内容。<br />
</p>
</div>
</li>
<li><a id="org44716a3"></a>为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？<br />
<div class="outline-text-7" id="text-org44716a3">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// ForwardShading</span>
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySpotCookie</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> lightCoord)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;uv&#38656;&#35201;&#20559;&#31227;0.5</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB</span>, lightCoord.xy / lightCoord.w + 0.5).w;
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredShading</span>
<span style="color: #bc6ec5;">  #if</span> defined(SPOT)
    <span style="color: #ce537a; font-weight: bold;">float4</span> uvCookie = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #ce537a; font-weight: bold;">float4</span>(worldPos, 1));
    uvCookie.xy /= uvCookie.w;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;uv&#19981;&#38656;&#35201;&#20559;&#31227;0.5 Unity&#22312;&#24341;&#25806;&#23618;&#35745;&#31639;unity_WorldToLight&#26102;&#32771;&#34385;&#20102;uv&#30340;&#20559;&#31227;&#65292;&#27492;&#22788;&#23601;&#19981;&#38656;&#35201;&#36827;&#34892;&#35745;&#31639;&#20102;&#12290;</span>
    atten *= tex2Dbias(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #ce537a; font-weight: bold;">float4</span>(uvCookie.xy, 0, -8)).w;
    atten *= uvCookie.w &lt; 0;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_DEPTH)
      shadowed = <span style="color: #a45bad;">true</span>;
      sAtten = CalcSAtten(sFade, worldPos);
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">  #else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd3782da" class="outline-5">
<h5 id="orgd3782da">Static Lighting</h5>
<div class="outline-text-5" id="text-orgd3782da">
</div>
<div id="outline-container-org10e25f0" class="outline-6">
<h6 id="org10e25f0">Lightmapping 光照贴图</h6>
<div class="outline-text-6" id="text-org10e25f0">
</div>
<ul class="org-ul">
<li><a id="orga72fc23"></a>简介<br />
<div class="outline-text-7" id="text-orga72fc23">
<p>
计算光照是比较昂贵的开销。虽然延迟渲染允许我们使用很多灯光，但是阴影依然是一个限制因素。如果我们的场景是动态的，我们无法避免这些计算。但是如果灯光和场景不会改变，我们就可以计算一次灯光后重用它。这样我们就可以放置很多灯光在场景中，而不需要在运行时渲染这些灯光。我们也可以使用区域灯光，这种灯光只能在烘培光照贴图的情况下使用。<br />
</p>
</div>
</li>
<li><a id="orge3476ef"></a>Unity 中使用光照贴图的步骤<br />
<div class="outline-text-7" id="text-orge3476ef">
<ol class="org-ol">
<li>把灯光的模式从 Realtime 切换为 Baked<br />
灯光一共有三种模式<br />
<ul class="org-ul">
<li>Realtime 实时灯光<br /></li>
<li>Baked 烘培灯光<br /></li>
<li>Mixed 混合灯光(既用于实时光照计算，又用于烘培光照计算)<br /></li>
</ul></li>
<li>在 Lighting Setting 中勾选 Baked Global Illumination.设置 Lighting Mode 为 Baked Indirect<br />
Lighting Mode 一共有三种模式<br />
<ul class="org-ul">
<li>Baked Indirect <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html">https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html</a><br /></li>
<li>Shadowmask <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html</a><br /></li>
<li>Subtractive <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html</a><br /></li>
</ul></li>
<li>将场景中固定不变的物体标记为 Lightmap Static<br />
MeshRenderer 组件的 Inspector 窗口中有一个 Lightmap Static 勾选框，其修改的就是 Lightmap Static 标记<br /></li>
</ol>

<p>
当场景中只有 Baked 模式的灯光时，光照贴图提供的光照要比实时光照效果暗一些。这是因为烘培的光照贴图只有 diffuse 光照，没有 specular 光照。specular 光照依赖于视角，即 specular 和摄像机方向相关，通常来说摄像机是可变的，所以无法在光照贴图中包含摄像机相关信息。这种限制意味着，光照贴图适用于微弱的光照和不闪亮(黯淡)的表面，不适用于强烈的光照和闪耀的表面。如果你需要 specular 光照，你必须使用实时光照。所以通常你需要混合使用烘培和实时光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6916e30"></a>Light=Baked LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Baked 模式）<br />
<div class="outline-text-8" id="text-org6916e30">
<p>
lightmapper 会将直接光和间接光都烘培到光照贴图中。此时，引擎向 shader 中传递的_LightColor0 值为(0,0,0,0)，所以实时调节灯光强度，不会有效果。<br />
这种模式下，无论场景中有多少灯光，运行时，只渲染一次物体。此时场景中没有实时光，此时不需要渲染阴影贴图，观察到的阴影效果是光照贴图中的颜色信息造成的。<br />
</p>
</div>
</li>
<li><a id="org4e754d3"></a>Light=Mixed LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Mixed 模式）<br />
<div class="outline-text-8" id="text-org4e754d3">
<p>
lightmapper 只会将间接光烘培到光照贴图中，所以该模式下的光照贴图比 Baked 模式下的要暗。此时，引擎会将正确的_LightColor0 传给 shader，所以实时调节灯光强度，会有效果（只会对直接光照有效果）。<br />
此时场景中有实时光，此时需要渲染阴影贴图，并且静态物体和动态物体都需要绘制阴影贴图。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org9b12d4a"></a>Lightmapping Settings<br />
<div class="outline-text-7" id="text-org9b12d4a">
<p>
Lightmapper 有两种<br />
</p>
<ul class="org-ul">
<li>Enlighten<br /></li>
<li>Progressive 该方式会增量式生成 lightmaps，会优先生成当前 scene view 可见的物体的 lightmap，这对于编辑是比较方便的。<br /></li>
</ul>

<p>
Directional Mode 有两种<br />
</p>
<ul class="org-ul">
<li>Directional Mode 生成两张 lightmap 贴图，一张存储物体接收到的光亮度和颜色。另一张存储主要光照的方向，以及主要光照在所有光照中占的比例。<br /></li>
<li>Non-Direction<br /></li>
<li><a href="https://docs.unity3d.com/Manual/LightmappingDirectional.html">https://docs.unity3d.com/Manual/LightmappingDirectional.html</a><br /></li>
</ul>

<p>
Ambient Occlusion : 它是间接光照在角落和褶皱处的阴影。它是一种人为增强效果，可以提升深度感。Ambient Occlusion 单单基于表面的隐藏程度，其不会考虑光照的真实路径。所以，和自发光表面结合使用时，会有明显错误。<br />
</p>
</div>
</li>
<li><a id="org2ae5949"></a>Indirect Light<br />
<div class="outline-text-7" id="text-org2ae5949">
<p>
烘培光照会考虑光照在多个表面的弹射，光子的每次弹射，都会损失一些能量，并且会被交互的材质修改颜色。Unity 在烘培间接光照时，都会考虑这些因素。<br />
</p>
</div>
</li>

<li><a id="org2538697"></a>Transparency<br />
<div class="outline-text-7" id="text-org2538697">
<p>
对于单面透明物体，需要创建 Lightmap Parameters，将 IsTransparent 参数指定为 True，将 Lightmap Parameters 指定给单面透明物体。半透明物体会让间接光照通过，而不透明物体会阻挡间接光照。<br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_error.png" alt="01_16sl_transparentObj_bake_error.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_correct.png" alt="01_16sl_transparentObj_bake_correct.png" /><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd6f33e1" class="outline-6">
<h6 id="orgd6f33e1">使用光照贴图</h6>
<div class="outline-text-6" id="text-orgd6f33e1">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#24403;&#20351;&#29992;lightmaps&#21518;&#65292;unity &#23558;&#19981;&#20250;&#21253;&#21547;&#39030;&#28857;&#20809;&#29031;&#35745;&#31639;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON

  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmap uv</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> tangentToWorld[3] : <span style="color: #a45bad;">TEXCOORD2</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos : <span style="color: #a45bad;">TEXCOORD5</span>;
      UNITY_SHADOW_COORDS(6)
      DECLARE_LIGHT_COORDS(7)
<span style="color: #bc6ec5;">  #ifdef</span> VERTEXLIGHT_ON
      <span style="color: #ce537a; font-weight: bold;">float3</span> vertexLightColor : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">  #elif</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmapUV</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">  #endif</span>
  };

  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>

<span style="color: #bc6ec5;">  #if</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22240;&#20026; lightmap&#30340;transformation&#27809;&#26377;&#34987;&#23450;&#20041;&#20026;unity_Lightmap_ST&#65292;&#25152;&#20197;&#26080;&#27861;&#20351;&#29992;TRANSFORM_TEX&#23439;</span>
      o.lightmapUV = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir) {
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #if</span> defined(VERTEXLIGHT_ON)
      indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmap &#21644;&#39030;&#28857;&#20809;&#29031;&#19981;&#20250;&#21516;&#26102;&#20986;&#29616;</span>
      indirectLight.diffuse = 0;
      <span style="color: #2aa1ae; background-color: #292e34;">// DecodeLightmap &#20250;&#22788;&#29702;&#20809;&#29031;&#36148;&#22270;&#19981;&#21516;&#26684;&#24335;</span>
      indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">      #else</span>
      indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #endif</span>

      <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
  }
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org84f84f2"></a>lightmap encode and decode<br />
<div class="outline-text-7" id="text-org84f84f2">
<p>
线性空间下，lightmap 被标记为 sRGB(RGB 使用 gamma 编码，A使用线性值)，在 shader 中采样 lightmap 并 decode 后，颜色值为 linear 值。<br />
Gamma 空间下，lightmap ，最终颜色值为 gamma 颜色空间。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org02d332a"></a>RGBM<br />
<div class="outline-text-8" id="text-org02d332a">
<p>
RGBM encoding<br />
在 RGB 通道存储颜色，在 A 通道存储亮度(multiplier 相乘系数 M)，<br />
Gamma Space RGBM 编码的 lightmaps.a 存储的亮度范围为 0-5，LIGHTMAP_HDR_MULTIPLIER=5.0，LIGHTMAP_HDR_EXPONENT=1.0<br />
Linear Space RGBM 编码的 lightmaps.a 存储的亮度范围为 0-34.49 (5^2.2=34.49) LIGHTMAP_HDR_MULTIPLIER=5^2.2=34.49，LIGHTMAP_HDR_EXPONENT=2.2<br />
decodeInstructions.x 为 LIGHTMAP_HDR_MULTIPLIER<br />
decodeInstructions.y 为 LIGHTMAP_HDR_EXPONENT<br />
</p>

<p>
RGBM decoding<br />
decoding formula : rgb = lightmap.rgb * (LIGHTMAP_HDR_MULTIPLIER * pow(lightmap.a, LIGHTMAP_HDR_EXPONENT))。<br />
</p>

<p>
decode 代码如下所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeLightmapRGBM (<span style="color: #ce537a; font-weight: bold;">half4</span> data, <span style="color: #ce537a; font-weight: bold;">half4</span> decodeInstructions)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// If Linear mode is not supported we can skip exponent part</span>
<span style="color: #bc6ec5;">    #if</span> defined(UNITY_COLORSPACE_GAMMA)
<span style="color: #bc6ec5;">      # if</span> defined(UNITY_FORCE_LINEAR_READ_FOR_RGBM)
          <span style="color: #4f97d7; font-weight: bold;">return</span> (decodeInstructions.x * data.a) * <span style="color: #4f97d7;">sqrt</span>(data.rgb);
<span style="color: #bc6ec5;">      # else</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> (decodeInstructions.x * data.a) * data.rgb;
<span style="color: #bc6ec5;">      # endif</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> (decodeInstructions.x * <span style="color: #4f97d7;">pow</span>(data.a, decodeInstructions.y)) * data.rgb;
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</li>
<li><a id="orge2f22fa"></a>dLDR<br />
<div class="outline-text-8" id="text-orge2f22fa">
<p>
dLDR 全称为 Double Low Dynamic Range<br />
</p>

<p>
dLDR encoding<br />
简单将[0, decodeInstructions.x]范围映射到[0, 1]范围。超过 decodeInstructions.x 的亮度被截断为 decodeInstructions.x。<br />
encoding formula : lightmap.rgb = rgb / decodeInstructions.x<br />
Gamma Space decodeInstructions.x = 2.0<br />
Linear Space decodeInstructions.x = pow(2.0, 2.2) = 4.59<br />
</p>

<p>
dLDR decoding<br />
decoding formula : rgb = lightmap.rgb * decodeInstructions.x。<br />
decode 代码如下所示：<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Decodes doubleLDR encoded lightmaps.</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeLightmapDoubleLDR( <span style="color: #ce537a; font-weight: bold;">fixed4</span> color, <span style="color: #ce537a; font-weight: bold;">half4</span> decodeInstructions)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// decodeInstructions.x contains 2.0 when gamma color space is used or pow(2.0, 2.2) = 4.59 when linear color space is used on mobile platforms</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> decodeInstructions.x * color.rgb;
}
</pre>
</div>
</div>
</li>
<li><a id="org5cf43f5"></a>HDR<br />
<div class="outline-text-8" id="text-org5cf43f5">
<p>
HDR lightmaps 不使用任何 encoding 机制，其所支持的颜色范围为 16 位浮点贴图格式所表示的范围，即[0, 65504]<br />
</p>
</div>
</li>

<li><a id="orgc460950"></a>指定 lightmap 编码格式<br />
<div class="outline-text-8" id="text-orgc460950">
<p>
Edit &gt; Project Settings &gt; Player &gt; Other Settings &gt; Lightmap Encoding<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mobile</th>
<th scope="col" class="org-left">Other</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">High Quality</td>
<td class="org-left">HDR</td>
<td class="org-left">HDR</td>
</tr>

<tr>
<td class="org-left">Normal Quality</td>
<td class="org-left">RGBM encoding</td>
<td class="org-left">RGBM encoding</td>
</tr>

<tr>
<td class="org-left">Low Quality</td>
<td class="org-left">dLDR</td>
<td class="org-left">RGBM encoding</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org269a8ed"></a>参考资料<br />
<div class="outline-text-8" id="text-org269a8ed">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/Lightmaps-TechnicalInformation.html">https://docs.unity3d.com/Manual/Lightmaps-TechnicalInformation.html</a><br /></li>
<li>Unity3D ShaderLab 之 DecodeLightmap 解读 <a href="https://zhuanlan.zhihu.com/p/35096536">https://zhuanlan.zhihu.com/p/35096536</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org05f9fb8" class="outline-6">
<h6 id="org05f9fb8">生成光照贴图</h6>
<div class="outline-text-6" id="text-org05f9fb8">
</div>
<ul class="org-ul">
<li><a id="org5f9eace"></a>lightmapper 默认规则<br />
<div class="outline-text-7" id="text-org5f9eace">
<p>
lightmapper 不会使用实时渲染管线，所以它并不会使用我们的自己的 shader 来渲染 lightmap。<br />
lightmapper 会通过材质的 RenderType 来决定怎样对待物体表面:<br />
</p>
<ul class="org-ul">
<li>RenderType="Opaque" 不透明物体<br /></li>
<li>RenderType="Transparent" 半透明物体<br /></li>
<li>RenderType="TransparentCutout" 透贴型物体<br /></li>
</ul>
</div>
</li>

<li><a id="org32d5057"></a>通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper<br />
<div class="outline-text-7" id="text-org32d5057">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Name</span> <span style="color: #2d9574;">"META-MyLightmapping"</span>
      <span style="color: #4f97d7; font-weight: bold;">Tags</span>
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// LightMode &#24517;&#39035;&#20026; Meta</span>
          <span style="color: #2d9574;">"LightMode"</span>=<span style="color: #2d9574;">"Meta"</span>
      }
      <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
      <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"MyStaticLighting_Lightmapping.cginc"</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//#include "MyStaticLighting_Lightmapping_Test.cginc"</span>
<span style="color: #bc6ec5;">      #pragma</span> vertex vert
<span style="color: #bc6ec5;">      #pragma</span> fragment frag
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_METALLICMAP_ON</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_ALBEDODETAIL_ON</span>
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
  }

<span style="color: #bc6ec5;">  #ifndef</span> MY_STATICLIGHTING_LIGHTMAPPING
<span style="color: #bc6ec5;">  #define</span> MY_STATICLIGHTING_LIGHTMAPPING

<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">"UnityPBSLighting.cginc"</span>
<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">"UnityMetaPass.cginc"</span>

  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
  };

  <span style="color: #2aa1ae; background-color: #292e34;">//#define _MainTex _MainTexM</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//#define _MainTex_ST _MainTexM_ST</span>

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailTex</span>;
  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailTex_ST</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailMask</span>;
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_EmissiveMap</span>;
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Smoothness</span>;
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Metallic</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MetallicSmoothnessMap</span>;

  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv1.xy, unity_LightmapST, unity_LightmapST);

      <span style="color: #2aa1ae; background-color: #292e34;">//v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//o.pos = UnityObjectToClipPos(v.vertex);</span>

      o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(v2f i)
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Color</span>.a;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetDetailMask</span>(v2f i)
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_DetailMask</span>, i.uv.zw);
  }

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlbedo</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> albedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy);
      albedo *= <span style="color: #7590db;">_Color</span>;
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_ALBEDODETAIL_ON</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> detailAlbedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailTex</span>, i.uv.zw);
      albedo = <span style="color: #4f97d7;">lerp</span>(albedo, albedo*detailAlbedo*unity_ColorSpaceDouble, GetDetailMask(i));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
  }
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> emissive = 0;
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_EMISSION</span>)
      emissive = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_EmissiveMap</span>, i.uv);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #4f97d7;">dot</span>(emissive, emissive) &lt; 0.001)
      {
          emissive = <span style="color: #7590db;">_EmissionColor</span>;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          emissive = emissive * <span style="color: #7590db;">_EmissionColor</span>;
      }
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> emissive;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetMetallic</span>(v2f i)
  {
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).r * <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(v2f i)
  {
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>) &amp;&amp; defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #elif</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : SV_TARGET
  {
      UnityMetaInput o;
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Emission = float3(0, 0, 1);</span>
      o.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Albedo = float3(1, 0, 0);</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> oneMinusReflectivity;
      o.Albedo = DiffuseAndSpecularFromMetallic(GetAlbedo(i), GetMetallic(i), o.SpecularColor, oneMinusReflectivity);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#25552;&#20379;&#30340;&#38388;&#25509;&#20809;&#29031;&#20250;&#36234;&#22810;, &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#20250;&#36234;&#22810;&#21453;&#23556;Specular&#20809;&#29031;&#20986;&#21435;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> roughness = SmoothnessToRoughness(GetSmoothness(i)) * 0.5;
      o.Albedo += o.SpecularColor * roughness;
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Albedo = GetAlbedo(i);</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// Specular&#21644;&#35270;&#35282;&#30456;&#20851;&#65292;&#26080;&#27861;&#28888;&#22521;SpecularColor</span>
      o.SpecularColor = 0;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(o);
  }

  <span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span> (UnityMetaInput IN)
  {
      <span style="color: #ce537a; font-weight: bold;">half4</span> res = 0;
<span style="color: #bc6ec5;">      #if</span> !defined(EDITOR_VISUALIZATION)
      <span style="color: #2aa1ae; background-color: #292e34;">// MetaPass &#20250;&#34987;&#35843;&#29992;&#22810;&#27425;, &#20351;&#29992;unity_MetaFragmentControl &#26469;&#25511;&#21046;&#36820;&#22238;Albedo&#36824;&#26159;Emission</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaFragmentControl.x)
      {
          res = <span style="color: #ce537a; font-weight: bold;">half4</span>(IN.Albedo,1);
          <span style="color: #2aa1ae; background-color: #292e34;">// d3d9 shader compiler doesn't like NaNs and infinity.</span>
          unity_OneOverOutputBoost = <span style="color: #4f97d7;">saturate</span>(unity_OneOverOutputBoost);
          <span style="color: #2aa1ae; background-color: #292e34;">// Apply Albedo Boost from LightmapSettings.</span>
          res.rgb = <span style="color: #4f97d7;">clamp</span>(<span style="color: #4f97d7;">pow</span>(res.rgb, unity_OneOverOutputBoost), 0, unity_MaxOutputValue);
      }
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaFragmentControl.y)
      {
          <span style="color: #ce537a; font-weight: bold;">half3</span> emission;
          <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_UseLinearSpace)
          emission = IN.<span style="color: #4f97d7; font-weight: bold;">Emission</span>;
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          emission = GammaToLinearSpace(IN.<span style="color: #4f97d7; font-weight: bold;">Emission</span>);

          res = <span style="color: #ce537a; font-weight: bold;">half4</span>(emission, 1.0);
      }
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> res;
  }
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</li>
<li><a id="org964a071"></a>半透明物体烘培<br />
<div class="outline-text-7" id="text-org964a071">
<p>
对于透明物体，lightmapper 会通过材质的_Color 属性值的 a 分量，以及_MainTex 贴图的 a 分量来确定透明度，所以不能使用_MainColor _Tint 等代替_Color，也不能使用_DiffuseTex _Albedo 等代替_MainTex。lightmapper 会通过材质的 _Cutoff 属性值，作为透贴门槛值， 所以不能使用_AlphaCutoff 等属性代替_Cutoff。<br />
</p>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>lightmapper 不会调用 shader 中的函数来获取 Alpha 值。<br /></li>
<li>Blend Mode 不会影响烘培结果<br /></li>
<li>RenderQueue 不会影响烘培结果<br /></li>
<li>2020.3.17 版本中，[MainTexture] [MainColor] 对于不透明烘培是没作用的。但是，影响半透明物体的烘培。<br /></li>
<li>使用 [MainTexture] [MainColor]， 此时贴图名称可以为 _BaseMap 以外的其他名称。但是，SceneView 中 Baked Global Illumination/Albedo, 依然会依赖 _BaseMap, _BaseColor 名字。<br /></li>
<li>2020.3.17 版本中，[HideInInspector] _Color("Base Color", Color) = (1, 1, 1, 1) 对于烘培也是没作用的。但是，烘培系统会读取这些数据，如果不存在会有错误日志。(不透明物体不会报错)<br /></li>
</ul>

<p>
Rendering/16StaticLighting/16StaticLighting_My_Baked_Transparent 该场景可以测试透明物体的烘培。将 MyStaticLighting.shader 中 Property 中的_Color 用_ColorM 代替，开启 TEST_META_PROP_NAME 宏定义，就可以测试上面规则。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(TEST_META_PROP_NAME)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ColorM</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_Color</span> <span style="color: #7590db;">_ColorM</span>
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTexM</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTexM_ST</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_MainTex</span> <span style="color: #7590db;">_MainTexM</span>
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_MainTex_ST</span> <span style="color: #7590db;">_MainTexM_ST</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColorM</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_EmissionColor</span> <span style="color: #7590db;">_EmissionColorM</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<p>
<img src="./UnityCatLikeCoding/01_16sl_MainTexM_result.png" alt="01_16sl_MainTexM_result.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_MainTex_result.png" alt="01_16sl_MainTex_result.png" /><br />
</p>

<ul class="org-ul">
<li>Baked Transparency <a href="https://catlikecoding.com/unity/tutorials/custom-srp/baked-light/">https://catlikecoding.com/unity/tutorials/custom-srp/baked-light/</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgf2d9654"></a>烘培参数<br />
<div class="outline-text-7" id="text-orgf2d9654">
<p>
Lightmapper/Max Bounces 设置为 0 可以只烘培直接光照<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2bcfda5" class="outline-6">
<h6 id="org2bcfda5">Directional Lightmaps 具有方向的光照贴图</h6>
<div class="outline-text-6" id="text-org2bcfda5">
</div>
<ul class="org-ul">
<li><a id="org6960bf9"></a>简介<br />
<div class="outline-text-7" id="text-org6960bf9">
<p>
lightmapper 只使用了顶点的几何数据，它没有考虑法线贴图数据。光照贴图的精度太低了，无法捕捉到传统法线贴图提供的细节。这意味着静态光照将会比较平。<br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-realtime.png" alt="01_16sl_normal-maps-realtime.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-lightmapped.png" alt="01_16sl_normal-maps-lightmapped.png" /><br />
上面两张图是，使用法线贴图的情况下，实时光照和烘培光照的效果对比。可以看到在烘培光照中，法线贴图的影响几乎没有，画面中微弱的法线效果来自环境反射。<br />
</p>
</div>
</li>

<li><a id="orgabbe6c3"></a>方向性<br />
<div class="outline-text-7" id="text-orgabbe6c3">
<p>
将 Directional Mode 设置为 Directional，就可以让法线贴图和烘培的光照协同工作。 在 Lighting/Lightmapping Settings/DirecionalMode 中，可以设置 Directional Mode = Directional。<br />
Directional Mode=Directional 时，unity 会生成两张光照贴图，一张就像之前一样的光照强度贴图，用于存储光照强度。新的另一张为光照方向贴图 rgb 通道用于存储最多的烘培光照的来源方向，a 通道用于描述接受到的总的光照有多少来自该主导方向(totalLight*alpha=dirLight =&gt; totalLight=dirLight/alpha)。<br />
</p>

<p>
下图为 NonDirectional 和 Directional 模式的对比：<br />
<img src="./UnityCatLikeCoding/01_16sl_non-directional.jpg" alt="01_16sl_non-directional.jpg" /><br />
<img src="./UnityCatLikeCoding/01_16sl_directional.jpg" alt="01_16sl_directional.jpg" /><br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/LightmappingDirectional.html">https://docs.unity3d.com/Manual/LightmappingDirectional.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="orga41dbf8"></a>使用烘培的方向贴图<br />
<div class="outline-text-7" id="text-orga41dbf8">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#24320;&#21551;&#28888;&#22521;&#26041;&#21521;&#36148;&#22270;&#30340;&#23439;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED


  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
<span style="color: #bc6ec5;">      #ifdef</span> VERTEXLIGHT_ON
      indirect.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">      #else</span>
      indirect.diffuse = 0;
<span style="color: #bc6ec5;">      #endif</span>
      indirect.specular = 0;


<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS) || defined(DEFFERRED_PASS)
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
              <span style="color: #2aa1ae; background-color: #292e34;">//indirect.diffuse = UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV);</span>
              indirect.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">              #if</span> defined(DIRLIGHTMAP_COMBINED)
              <span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679;&#28888;&#22521;&#30340;&#26041;&#21521;&#36148;&#22270;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap,i.lightmapUV);
              <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;Half Lambert&#35745;&#31639;Diffuse</span>
              indirect.diffuse = DecodeDirectionalLightmap(indirect.diffuse, lightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #else</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeDirectionalLightmap (<span style="color: #ce537a; font-weight: bold;">half3</span> color, <span style="color: #ce537a; font-weight: bold;">fixed4</span> dirTex, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
  <span style="color: #2aa1ae; background-color: #292e34;">// In directional (non-specular) mode Enlighten bakes dominant light</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// direction in a way, that using it for half Lambert and then dividing</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// by a "rebalancing coefficient" gives a result close to plain diffuse</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// response lightmaps, but normalmapped.</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// Note that dir is not unit length on purpose. Its length is</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// "directionality", like for the directional specular lightmaps.</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> halfLambert = <span style="color: #4f97d7;">dot</span>(normalWorld, dirTex.xyz - 0.5) + 0.5;

    <span style="color: #4f97d7; font-weight: bold;">return</span> color * halfLambert / <span style="color: #4f97d7;">max</span>(1e-4h, dirTex.w);
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdf00492" class="outline-6">
<h6 id="orgdf00492">Light Probes</h6>
<div class="outline-text-6" id="text-orgdf00492">
<p>
Lightmaps 只对静态物体起作用，对动态物体不起作用。这会导致动态物体无法融入烘培光照的场景。Unity 使用 LightProbe 来存储其所在点的烘培光照信息，LightProbe 没有使用贴图存储光照信息，其使用 Spherical Harmonics 存储这些信息。<br />
场景中的动态物体会使用 LightProbe 存储的烘培光照信息来取代全局的环境数据。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfff9969"></a>为什么 SceneView 中不显示 LightProbe？<br />
<div class="outline-text-7" id="text-orgfff9969">
<p>
SceneView 下 Gizmos/3D Icon 被缩放到最小了。<br />
</p>
</div>
</li>
<li><a id="org9a573dc"></a>为什么 LightProb 对于动态物体不生效？<br />
<div class="outline-text-7" id="text-org9a573dc">
<p>
两个 LightProb 是无作用的，需要让 LightProbe 形成网才能生效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf75befb" class="outline-6">
<h6 id="orgf75befb">Q&amp;A</h6>
<div class="outline-text-6" id="text-orgf75befb">
</div>
<ul class="org-ul">
<li><a id="org39b45d2"></a>使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？<br />
<div class="outline-text-7" id="text-org39b45d2">
<ul class="org-ul">
<li>关于 3D 模型的二套 UV <a href="https://zhuanlan.zhihu.com/p/83322397">https://zhuanlan.zhihu.com/p/83322397</a><br /></li>
</ul>
</div>
</li>
<li><a id="org413f959"></a>什么错误导致 lightmap 中不包含 Emission 颜色？<br />
<div class="outline-text-7" id="text-org413f959">
<ul class="org-ul">
<li>缺乏 Meta Pass<br /></li>
<li><p>
Meta Pass 的 Fragment 没有按照如下方式输出<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : SV_TARGET
    {
        UnityMetaInput surfaceData;
        surfaceData.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
        surfaceData.Albedo = GetAlbedo(i);
        surfaceData.SpecularColor = 0;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(surfaceData);
    }
</pre>
</div></li>
<li>材质的 MaterialGlobalIlluminationFlags 没设置为 BakedEmissive<br /></li>
<li><p>
vertex 着色器函数中输出的 SV_POSITION 不正确<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    v2f_meta <span style="color: #bc6ec5; font-weight: bold;">vert_test</span>(VertexInput v)
    {
        v2f_meta o;
        <span style="color: #2aa1ae; background-color: #292e34;">//o.pos = UnityObjectToClipPos(v.vertex);  // &#36825;&#26679;&#35745;&#31639;&#24471;&#20986;&#30340;pos&#26159;&#38169;&#35823;&#30340;&#12290;</span>
        o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
        o.uv = TexCoords(v);
        <span style="color: #4f97d7; font-weight: bold;">return</span> o;
    }
</pre>
</div></li>
<li>unity lightmap 数据清除有 bug，清除 lightmap 后，隐藏一个物体，再烘培，检查数据是否正确。<br />
lightmap 缓存极其不稳定，有时候隐藏了烘培依然不可以，需要隐藏一个其他物体再来一次。<br /></li>
<li><del>frag 着色器的 out 标记 SV_TARGET 是否全部使用大写</del> SV_Target 也是可以的<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org49ebd4d"></a>参考资料<br />
<div class="outline-text-8" id="text-org49ebd4d">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/MetaPass.html">https://docs.unity3d.com/Manual/MetaPass.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>

<li><a id="org9cb763d"></a>Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数<br />
<div class="outline-text-7" id="text-org9cb763d">
<p>
宏定义写错了 DEFERRED_PASS 写成了 DEFFERRED_PASS。导致采样 unity_Lightmap unity_LightmapInd 的代码没有执行到，所以引擎没将图片传给 GPU。<br />
</p>
</div>
</li>
<li><a id="orgdda8cfd"></a>烘培点光源，光穿过了不透明物体<br />
<div class="outline-text-7" id="text-orgdda8cfd">
<p>
光源阴影为 None 导致该问题，需要将点光源的阴影类型设置为 Hard 或 Soft。<br />
方向光把阴影设置为 NoneShaodws 也会穿过不透明物体。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org775261a" class="outline-5">
<h5 id="org775261a">Mixed Lighting</h5>
<div class="outline-text-5" id="text-org775261a">
</div>
<div id="outline-container-org1c638f2" class="outline-6">
<h6 id="org1c638f2">烘培光照贴图的优缺点</h6>
<div class="outline-text-6" id="text-org1c638f2">
</div>
<ul class="org-ul">
<li><a id="orgcd68c06"></a>缺点<br />
<div class="outline-text-7" id="text-orgcd68c06">
<ul class="org-ul">
<li>无法烘培高光<br /></li>
<li>烘培光照只能通过 LightProbe 对动态物体产生影响<br /></li>
<li>烘培光照无法生成实时阴影<br /></li>
</ul>
</div>
</li>
<li><a id="orgd84eba7"></a>优点<br />
<div class="outline-text-7" id="text-orgd84eba7">
<ul class="org-ul">
<li>烘培光照包含间接光照，实时光照不包含间接光照。间接光照可以极大提升场景的真实感。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org18d001b" class="outline-6">
<h6 id="org18d001b">Baking Indirect Light</h6>
<div class="outline-text-6" id="text-org18d001b">
<p>
实时光照和烘培光照各有优缺点，通过下面方式可以将实时光照和烘培光照结合使用。<br />
</p>
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Baked Indirect<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，烘培光照贴图时会发生两个变化：<br />
</p>
<ol class="org-ol">
<li>lightmapper 只会将间接光照存储到光照贴图中，所以此时的光照贴图比之前要暗一些。<br /></li>
<li>lightmap 只用于为静态物体提供间接光照，静态物体的直接光照也由场景中灯光实时提供；动态物体间接光由 light probe 提供，直接光照由场景中灯光实时提供。<br /></li>
</ol>

<p>
注意:<br />
在上面的设置下，静态物体也需要实时画阴影贴图。这种模式相当于实时光照的工作再加上光照贴图实现的间接光照，所以这种模式是比较消耗性能的。<br />
</p>
</div>
</div>
<div id="outline-container-orga192855" class="outline-6">
<h6 id="orga192855">Using a Shadowmask</h6>
<div class="outline-text-6" id="text-orga192855">
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Baked<br /></li>
</ol>
<p>
这样设置时，并不会生产 shadowmask，此时相当于完全烘培 （相当于 Light=Baked LightingMode=BakedIndirect 设置下的烘培）。<br />
</p>

<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，间接光照和 mixed lights 的阴影 attenuation 都会存储到光照贴图中，阴影会存储到单独的一张 shadowmask 贴图中。<br />
如果只有 1 盏灯那么 shadowmask 只会占 r 通道，shadowmask 最多 4 个通道，所以最多可以支持 4 盏灯。<br />
</p>

<p>
这种模式比 MixedLight+BakedIndirect 的优势在于静态物体不需要实时画阴影。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org92b5656"></a>Sampling the Shadowmask<br />
<div class="outline-text-7" id="text-org92b5656">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowFade</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">float</span> atten)
  {
<span style="color: #bc6ec5;">  #if</span> HANDLE_SHADOWS_BLENDING_IN_GI
      <span style="color: #ce537a; font-weight: bold;">float</span> viewZ = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos, UNITY_MATRIX_V[2].xyz);
      <span style="color: #ce537a; font-weight: bold;">float</span> shadowFadeDistance = UnityComputeShadowFadeDistance(i.worldPos, viewZ);
      <span style="color: #ce537a; font-weight: bold;">float</span> sFade = UnityComputeShadowFade(shadowFadeDistance);
      <span style="color: #ce537a; font-weight: bold;">float</span> bakedAtten = UnitySampleBakedOcclusion(i.lightmapUV, i.worldPos);
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(atten, bakedAtten, sFade);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// unity_OcclusionMaskSelector &#35813;&#21521;&#37327;&#21482;&#26377;&#19968;&#20010;&#20998;&#37327;&#20250;&#34987;&#35774;&#32622;&#20026;1&#65292;&#29992;&#20110;&#21305;&#37197;&#24403;&#21069;&#34987;&#28210;&#26579;&#30340;&#28783;&#20809;</span>
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySampleBakedOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos) {
<span style="color: #bc6ec5;">  #if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
          <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D_SAMPLER(unity_ShadowMask, unity_Lightmap, lightmapUV.xy);
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(<span style="color: #4f97d7;">dot</span>(rawOcclusionMask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> UnityMixRealtimeAndBakedShadows (<span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> bakedShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> fade)
  {
  <span style="color: #2aa1ae; background-color: #292e34;">// &#26080;&#23454;&#21160;&#24577;&#38452;&#24433;&#26102;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
<span style="color: #bc6ec5;">  #if</span> !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; !defined(SHADOWS_CUBE)
      <span style="color: #4f97d7; font-weight: bold;">return</span> bakedShadowAttenuation;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #if</span> defined (LIGHTMAP_SHADOW_MIXING)
          realtimeShadowAttenuation = <span style="color: #4f97d7;">saturate</span>(realtimeShadowAttenuation + fade);
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">min</span>(realtimeShadowAttenuation, bakedShadowAttenuation);
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// shadowFadeDistance&#33539;&#22260;&#20869;&#65292;&#20351;&#29992;sFadeFactor&#22312;&#23454;&#26102;&#38452;&#24433;&#21644;&#28888;&#22521;&#38452;&#24433;&#20043;&#38388;&#25554;&#20540;</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// &#36229;&#20986;shadowFadeDistance&#21518;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(realtimeShadowAttenuation, bakedShadowAttenuation, fade);
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #else</span> <span style="color: #2aa1ae; background-color: #292e34;">//no shadowmask &#27809;&#26377;&#20351;&#29992;shadowmask&#26102;&#65292;&#20351;&#29992;&#23454;&#26102;&#38452;&#24433;atten+shadowFadeFactor</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(realtimeShadowAttenuation + fade);
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="org532a2da"></a>Support Deferred Path<br />
<div class="outline-text-7" id="text-org532a2da">
<p>
DeferredShading 中将 ShadowMask 写入到 GBuffer4 中<br />
DeferredLighting 中读取 GBuffer4 内容，对直接光照进行衰减<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredShading (MixedLighting.shader)</span>

  <span style="color: #4f97d7; font-weight: bold;">struct</span> frag_output
  {
<span style="color: #bc6ec5;">  #if</span> defined(DEFERRED_PASS)
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
          <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer4 : <span style="color: #a45bad;">SV_Target4</span>;
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">  #endif</span>
  };

  frag_output <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i)
  {
      frag_output output;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWSMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
          <span style="color: #ce537a; font-weight: bold;">float2</span> shadowUV = 0;
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
          shadowUV = i.lightmapUV;
<span style="color: #bc6ec5;">          #endif</span>
          output.gBuffer4 = UnityGetRawBakedOcclusions(shadowUV, i.worldPos.xyz);
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredLighting (MixedLighting_DeferredLighting.shader)</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowMaskAttenuation</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK)
      <span style="color: #ce537a; font-weight: bold;">float4</span> mask = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CameraGBufferTexture4</span>, uv);
      atten = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(mask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
  }

  UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float</span> viewZ)
  {
      UnityLight light;
      <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
      <span style="color: #ce537a; font-weight: bold;">float</span> sAtten = 1;
      <span style="color: #ce537a; font-weight: bold;">float</span> sFade = GetShadowFade(worldPos, viewZ);
      <span style="color: #ce537a; font-weight: bold;">bool</span> shadowed = <span style="color: #a45bad;">false</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK)
          shadowed = <span style="color: #a45bad;">true</span>;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (shadowed)
      {
          <span style="color: #ce537a; font-weight: bold;">float</span> smAtten = GetShadowMaskAttenuation(uv);
          sAtten = UnityMixRealtimeAndBakedShadows(sAtten, smAtten, sFade);
          <span style="color: #2aa1ae; background-color: #292e34;">//sAtten = saturate(sAtten + sFade);</span>
<span style="color: #bc6ec5;">          #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
<span style="color: #bc6ec5;">              #if</span> !defined(SHADOWS_SHADOWMASK)
              UNITY_BRANCH
              <span style="color: #4f97d7; font-weight: bold;">if</span> (sFade &gt; 0.99)
              {
                  sAtten = 1;
              }
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #endif</span>
      }
      light.color = <span style="color: #7590db;">_LightColor</span>.rgb * atten * sAtten;
      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }
</pre>
</div>
</div>
</li>
<li><a id="orgd9836fc"></a>Distance Shadowmask Mode<br />
<div class="outline-text-7" id="text-orgd9836fc">
<p>
Unity2017 版本之前 Distance Shadowmask 在 Lighting Setting 中设置，Unity2017 版本以及之后版本在 QualitySettings 中设置。<br />
</p>

<p>
注意：<br />
这种模式下，ShadowDistance 外使用 ShadowMask（相当于 ShadowMask 模式），ShadowDistance 内使用实时阴影（相当于 MixedLight+BakedIndirect，静态物体和动态物体都需要绘制阴影贴图，所以这种模式也是比较消耗性能的）。<br />
</p>
</div>
</li>
<li><a id="org22fe81d"></a>Multiple Lights<br />
<div class="outline-text-7" id="text-org22fe81d">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">//ForwardAdd Pass &#28155;&#21152;&#22914;&#19979;&#20195;&#30721;&#65292;UNITY_LIGHT_ATTENUATION &#23601;&#21487;&#20197;&#27491;&#30830;&#24037;&#20316;&#20102;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SHADOWMASK
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdce4db7" class="outline-6">
<h6 id="orgdce4db7">Subtractive Shadows</h6>
<div class="outline-text-6" id="text-orgdce4db7">
</div>
<ul class="org-ul">
<li><a id="orgbac351e"></a>简介<br />
<div class="outline-text-7" id="text-orgbac351e">
<p>
Subtractive mode 只适用于 forward path。Subtractive Mode 的理念是静态物体依然通过 lightmaps 照亮，并且同时将动态物体的阴影因素考虑进去，这是通过减低阴影区域光照贴图的亮度来实现的。这种方式不生成 Shadow Mask 贴图。<br />
Subtractive mode 只适用于一个方向光，因此只支持主方向光的阴影。<br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的 Lightmap 贴图的对比如下（由烘培 16StaticLighting_Unity 场景生成）：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su.jpg" alt="01_17ml_bi_sm_su.jpg" /><br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的生成阴影贴图的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su_drawcall.jpg" alt="01_17ml_bi_sm_su_drawcall.jpg" /><br />
</p>

<p>
注意： LightMode 为 Mixed，Lighting Mode 为 BakedIndirect 时，静态物体依然会绘制阴影。<br />
</p>
</div>
</li>
<li><a id="org73016ca"></a>实现<br />
<div class="outline-text-7" id="text-org73016ca">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #if</span> defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #define</span> SUBTRACTIVE_LIGHTING 1
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>

  UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (Interpolators i)
  {
      UnityLight light;
      <span style="color: #2aa1ae; background-color: #292e34;">// Subtractive&#27169;&#24335;&#19979;&#65292;&#38745;&#24577;&#29289;&#20307;&#30340;&#30452;&#25509;&#20809;&#29031;&#37117;&#34987;&#28888;&#22521;&#21040;lightmap&#20013;&#20102;&#65292;&#19981;&#38656;&#35201;&#35745;&#31639;&#30452;&#25509;&#20809;&#29031;</span>
<span style="color: #bc6ec5;">      #if</span> defined(DEFERRED_PASS)  || SUBTRACTIVE_LIGHTING
          light.dir = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
          light.color = 0;
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #endif</span>

      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// Unity&#23454;&#29616;&#20013;&#23545;&#24212;&#30340;&#20989;&#25968;&#20026;&#65306;SubtractMainLightWithRealtimeAttenuationFromLightmap</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
  {
<span style="color: #bc6ec5;">  #if</span> SUBTRACTIVE_LIGHTING
      UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
      attenuation = GetShadowFade(i, attenuation);
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = 1;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
      <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
      <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
      subtractedLight = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#25903;&#25345;ShadowStrength</span>
      subtractedLight = <span style="color: #4f97d7;">lerp</span>(subtractedLight, indirect.diffuse, <span style="color: #7590db;">_LightShadowData</span>.x);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#38745;&#24577;&#29289;&#20307;&#19978;&#28888;&#22521;&#30340;&#38452;&#24433;&#20063;&#20250;&#26174;&#31034;unity_ShadowColor.rgb&#39068;&#33394;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//indirect.diffuse = indirect.diffuse;</span>

      <span style="color: #2aa1ae; background-color: #292e34;">// &#21482;&#20462;&#25913;&#21160;&#24577;&#29289;&#20307;&#22312;&#38745;&#24577;&#29289;&#20307;&#19978;&#25237;&#23556;&#30340;&#38452;&#24433;</span>
      indirect.diffuse = <span style="color: #4f97d7;">min</span>(subtractedLight, indirect.diffuse);
<span style="color: #bc6ec5;">  #endif</span>
  }

</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd1006df" class="outline-6">
<h6 id="orgd1006df">总结</h6>
<div class="outline-text-6" id="text-orgd1006df">
<p>
Lighting Setting 中选中 Mixed Lighting/Baked Global Illumination 勾选框，开启离线烘培。<br />
</p>

<p>
离线烘培结果由以下 4 个配置决定：<br />
</p>
<ul class="org-ul">
<li>Lighting/Scene/LightingSetting/Mixed Lighting/Lighting Mode (BakedIndirect, Shadowmask, Subtractive)<br /></li>
<li>Lighting/Scene/LightingSetting/Lightmapping Settings/Directional Mode (Directional, Non-Directional)<br /></li>
<li>场景中 Light 的 Mode (Realtime, Baked, Mixed)<br /></li>
<li>场景中 GameObject 的 Static Mark 是否包含 Contribute GI(unity 2020 版本) | Lightmap Static(unity 2017 版本)<br /></li>
</ul>

<p>
场景中元素对烘培的贡献：<br />
</p>
<ul class="org-ul">
<li>Light:  被标记为 Realtime 的 Light 对离线烘培系统不产生任何影响。<br /></li>
<li>Object:<br />
<ul class="org-ul">
<li>动态物体不会对离线烘培系统产生任何影响。例如，烘培场景时，动态的发绿色光的球不会导致 lightmap 贴图变绿。<br /></li>
<li>离线烘培的 LightProbe 会为动态物体提供间接光照。离线烘培的 lightmap 会为静物体提供间接光照（某些情况下，还包含直接光照）。<br /></li>
</ul></li>
</ul>

<p>
使用离线烘培对渲染的影响包括一下方面：<br />
</p>
<ul class="org-ul">
<li>直接光间接光如何计算<br />
<ul class="org-ul">
<li>diffuse 如何计算<br /></li>
<li>specular 如何计算<br /></li>
</ul></li>
<li>阴影如何计算<br /></li>
</ul>

<p>
Light 对象的 Mode 为 Baked 时，Lighting Mode 任意：<br />
</p>
<ul class="org-ul">
<li>直接光和间接光都烘培，两者都在 lightmap 中。运行时，Baked Light 对动态物体不起任何作用。烘培的 LightProbe 为动态物体提供间接光照。<br /></li>
<li>无 specular。<br /></li>
<li>阴影包含在 lightmap 中。动态物体对静态物体不投影。静态物体对动态物体不投影。<br /></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mixed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BakedIndirect</td>
<td class="org-left">只烘培间接光，直接光实时计算</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">静态物体也需要实时生成阴影贴图。</td>
</tr>

<tr>
<td class="org-left">Shadowmask</td>
<td class="org-left">只烘培间接光，直接光实时计算。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">烘培 ShadowMask。静态物体不需要实时生成阴影贴图。静态物体无法在动态物体上投影</td>
</tr>

<tr>
<td class="org-left">DistanceShadowmask</td>
<td class="org-left">只烘培间接光，直接光实时计算。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">烘培 ShadowMask。远处的静态物体不需实时生成阴影贴图。近处的静态物体需实时生成阴影贴图，近处的静态物体可在动态物体上投影</td>
</tr>

<tr>
<td class="org-left">Subtractive</td>
<td class="org-left">直接光和间接光都烘培，两者都在 lightmap 中。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">无 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">阴影包含在 lightmap 中。动态物体对静态物体投影，静态物体对动态物体不投影</td>
</tr>
</tbody>
</table>

<p>
Tips:<br />
烘培时设置灯光 Mode 为 Baked. 运行起来后修改 Light 的 Mode 不起作用。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Light-lightmapBakeType.html">https://docs.unity3d.com/ScriptReference/Light-lightmapBakeType.html</a><br /></li>
</ul>

<p>
下图是 Light Mode Baked VS Mixed 的对比，从图可以看出：<br />
</p>
<ul class="org-ul">
<li>Light Mode 为 Baked 时，不同 Lighting Mode 设置并不会起作用，此时 Lighting Mode 相当于 BakedIndirect。<br /></li>
<li>Light Mode 为 Mixed 时，烘培的光照贴图会变暗，因为此时只烘焙了间接光照。<br /></li>
</ul>

<div id="org22156f7" class="figure">
<p><img src="./UnityCatLikeCoding/light_mode_baked_vs_mixed.png" alt="light_mode_baked_vs_mixed.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org28fb102" class="outline-6">
<h6 id="org28fb102">Q&amp;A</h6>
<div class="outline-text-6" id="text-org28fb102">
</div>
<ul class="org-ul">
<li><a id="org5af9ee5"></a>如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？<br />
<div class="outline-text-7" id="text-org5af9ee5">
<p>
一般来说，这样做是不正确的，这会导致 Realtime 灯光没有间接光照效果。但是，也要考虑项目的实际情况，例如，灯光会移动时，应该将其设置为 realtime，灯光移动时间接光照不动会导致穿帮。<br />
</p>
</div>
</li>
<li><a id="orgd3f1759"></a>烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？<br />
<div class="outline-text-7" id="text-orgd3f1759">
<p>
LightMode 为 Mixed，LightingMode 为 BakedIndirect，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 Distance ShadowMask 的情况下，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 ShadowMask 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
LightMode 为 Mixed，LightingMode 为 Substractive 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
</p>
</div>
</li>
<li><a id="org1c259fa"></a>ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图<br />
<div class="outline-text-7" id="text-org1c259fa">
<p>
关闭 Unity，重新打开，可以解决该问题。<br />
</p>
</div>
</li>
<li><a id="org3713524"></a>Deferred Path 模式下的间接光照计算是怎样的？<br />
<div class="outline-text-7" id="text-org3713524">
<p>
indirect.diffuse DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。<br />
indirect.specular 的计算则分是否开启屏幕空间反射，不开启时，DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。开启时，则在屏幕空间反射时计算。<br />
</p>
</div>
</li>
<li><a id="org315623b"></a>Error: 阴影轮廓处有光晕<br />
<div class="outline-text-7" id="text-org315623b">
<p>
<img src="./UnityCatLikeCoding/01_17ml_shadow_error.png" alt="01_17ml_shadow_error.png" /><br />
经过检查发现是计算 Normal 时有错误，在下面代码的注释中有具体说明<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetNormal</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">_NORMAL_ON</span>)
      normal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_NormalMap</span>, i.uv).wy * 2 - 1;
      normal.xy *= <span style="color: #7590db;">_BumpScale</span>;
      normal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal.xy, normal.xy)));
      normal = normal.xzy;
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">_NORMALDETAIL_ON</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> detailNormal;
      detailNormal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailNormal</span>, i.uv).wy * 2 - 1;
      detailNormal.xy *= <span style="color: #7590db;">_BumpScale</span>;
      detailNormal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(detailNormal.xy, detailNormal.xy)));
      detailNormal = <span style="color: #4f97d7;">lerp</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(0,1,0), detailNormal.xzy, GetDetailMask(i));

      normal.x = normal.x + detailNormal.x;
      normal.y = normal.y * detailNormal.y;
      normal.z = normal.z + detailNormal.z;
<span style="color: #bc6ec5;">  #endif</span>
      normal = <span style="color: #4f97d7;">normalize</span>(normal);

<span style="color: #bc6ec5;">  #define</span> <span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> wTangent = i.tangentToWorld[0];
      <span style="color: #ce537a; font-weight: bold;">float3</span> wBinormal = i.tangentToWorld[1];
      <span style="color: #ce537a; font-weight: bold;">float3</span> wNormal = i.tangentToWorld[2];
      <span style="color: #2aa1ae; background-color: #292e34;">// &#19978;&#38754;&#20195;&#30721;&#24050;&#32463;&#23558;normal&#21521;&#19978;&#30340;&#20998;&#37327;&#20174;z&#25442;&#21040;&#20102;y&#65292;&#25152;&#20197;&#36825;&#37324;&#21644;wNormal&#30456;&#20056;&#30340;&#24212;&#35813;&#26102;normal&#30340;y&#20998;&#37327;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// normal = normalize(wTangent*normal.x + wBinormal*normal.y + wNormal*normal.z);</span>
      normal = <span style="color: #4f97d7;">normalize</span>(wTangent*normal.x + wNormal*normal.y + wBinormal*normal.z);
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> normal;
  }
</pre>
</div>
</div>
</li>
<li><a id="orgaf78a7b"></a>Error: Subtractive 模式下动态物体的阴影很淡<br />
<div class="outline-text-7" id="text-orgaf78a7b">

<div id="org61841c7" class="figure">
<p><img src="./UnityCatLikeCoding/01_17ml_subtractive_dynamicObj_shadow_error.png" alt="01_17ml_subtractive_dynamicObj_shadow_error.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
  {
<span style="color: #bc6ec5;">  #if</span> SUBTRACTIVE_LIGHTING
      UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
      attenuation = GetShadowFade(i, attenuation);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
      <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
      <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
      indirect.diffuse = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org91d80ab" class="outline-5">
<h5 id="org91d80ab">RealtimeGI ProbeVolumes LOD Groups</h5>
<div class="outline-text-5" id="text-org91d80ab">
</div>
<div id="outline-container-org25b502d" class="outline-6">
<h6 id="org25b502d">Realtime Globall Illumination</h6>
<div class="outline-text-6" id="text-org25b502d">
</div>
<ul class="org-ul">
<li><a id="org2d481da"></a>简介<br />
<div class="outline-text-7" id="text-org2d481da">
<p>
烘培光照虽然对静态几何体(通过光照贴图)和动态几何体(通过光照探针)起作用，但是烘培光照无法处理动态光照(Realtime Mode Light)。Mixed Mode Light 可以实时调节一些参数，但是过多的调整会让没有改变的烘培间接光照变得很明显。所以，当你有一个室外的场景时，太阳是不能改变的，它不能像真实生活中一样东升西落在空中穿行，因为这需要不断改变全局照明，所以只能让场景冻结在某个时间点上。<br />
为了让间接光照支持光照方向的实时改变，Unity 使用 Enlighten 系统来计算实时全局照明。其就像烘培间接光一样工作，不同的是 Enlighten 是在运行时计算光照贴图和光照探针的。<br />
计算间接光需要知道光照在静态表面之间是如何弹射的，也就是需要知道哪些表面有可能会被哪些表面在哪些角度上产生影响。计算出这些关系需要很多工作，不可能在运行时完成。所以，这些数据是由编辑器计算并存储起来，运行时 Enlighten 会利用这些数据来计算光照贴图和光照探针。即使如此，实时全局照明也只适用于低分辨率的光照贴图。<br />
</p>

<p>
注意：无论是 RealtimeGI 的光照贴图，还是 BakedGI 的光照贴图，只有标记为 Lightmap 静态的物体，才会使用烘培的光照贴图。而动态的物体则使用烘培的 LightProbe 数据。<br />
</p>
</div>
</li>
<li><a id="org8bd7f48"></a>Baking Realtime GI<br />
<div class="outline-text-7" id="text-org8bd7f48">
<p>
Realtime GI 使用自己的 lightmap 坐标，Unity 会基于光照贴图和物体的设置自动生成这些 UV 坐标，这些 UV 坐标值被存储到 Mesh 的第三套 UV 通道。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// unity_LightmapST &#26159;&#28888;&#22521;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// unity_DynamicLightmapST&#26159;&#21160;&#24577;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
      o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);

      o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaVertexPosition</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex, <span style="color: #ce537a; font-weight: bold;">float2</span> uv1, <span style="color: #ce537a; font-weight: bold;">float2</span> uv2, <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapST, <span style="color: #ce537a; font-weight: bold;">float4</span> dynlightmapST)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#36890;&#36807;unity_MetaVertexControl&#26469;&#25511;&#21046;&#24403;&#21069;&#25805;&#20316;&#30340;&#26159;&#28888;&#22521;&#20809;&#29031;GI&#36824;&#26159;&#21160;&#24577;&#20809;&#29031;GI</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.x)
      {
          vertex.xy = uv1 * lightmapST.xy + lightmapST.zw;
          <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL right now needs to actually use incoming vertex position,</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// so use it in a very dummy way</span>
          vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
      }
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.y)
      {
          vertex.xy = uv2 * dynlightmapST.xy + dynlightmapST.zw;
          <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL right now needs to actually use incoming vertex position,</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// so use it in a very dummy way</span>
          vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
      }
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
  }
</pre>
</div>
<p>
注意：<br />
烘培光照贴图和实时光照贴图都会用到 meta pass。所以当开启实时 GI 时，在打包的时候 meta pass 也会被包含进去。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org0b59b5b"></a><span class="todo TODO">TODO</span> 为什么 Realtime GI 不公用静态光照贴图的模型 UV？<br /></li>
</ul>
</li>
<li><a id="org11fa217"></a>Sampling Realtime Lightmaps<br />
<div class="outline-text-7" id="text-org11fa217">
<p>
所有的实时灯光都会对实时 GI 有贡献。但是，典型的用法是，只将主方向光作用于实时 GI，因为主方向光代表着太阳，其会在天空中移动。实时 GI 的所有功能对方向光都是有效的，实时 GI 不支持点光源和 SpotLight 的阴影。因此，当使用会投影的点光源和 SpotLight 时，最终会得到不正确的间接光照。<br />
如果你想将某个实时光从实时 GI 中排除，只需要将该灯光的 IndirectMultiplier 设置为 0。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader">  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #if</span> defined(DYNAMICLIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#21160;&#24577;Lightmap&#20351;&#29992;&#20102;&#21644;&#38745;&#24577;Lightmap&#19981;&#21516;&#30340;&#39068;&#33394;&#26684;&#24335;&#65292;&#38656;&#35201;&#19981;&#21516;&#30340;&#35299;&#30721;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> dynamicLightDiffuse = DecodeRealtimeLightmap(UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, i.dynamicLightmapUV));
<span style="color: #bc6ec5;">      #if</span> defined(DIRLIGHTMAP_COMBINED)
          <span style="color: #ce537a; font-weight: bold;">float4</span> dynamicLightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap,i.dynamicLightmapUV);
          indirect.diffuse += DecodeDirectionalLightmap(dynamicLightDiffuse, dynamicLightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">      #else</span>
          indirect.diffuse += dynamicLightDiffuse;
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809;</span>
      indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="orgf2a889b"></a>Emissive Light<br />
<div class="outline-text-7" id="text-orgf2a889b">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> EmissiveOscillator : MonoBehaviour
  {
      Renderer r;
      <span style="color: #4f97d7; font-weight: bold;">Material</span> mat;
      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Start</span>()
      {
          r = GetComponent&lt;Renderer&gt;();
          mat = r.material;
      }

      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">Color</span> c = <span style="color: #4f97d7; font-weight: bold;">Color</span>.Lerp(<span style="color: #4f97d7; font-weight: bold;">Color</span>.white, <span style="color: #4f97d7; font-weight: bold;">Color</span>.black, Mathf.Sin(Time.time * Mathf.PI) * 0.5f + 0.5f);
          mat.SetColor(<span style="color: #2d9574;">"_EmissionColor"</span>, c);

          <span style="color: #2aa1ae; background-color: #292e34;">// &#26356;&#26032;&#23454;&#26102;GI</span>

          <span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#20250;&#35302;&#21457;&#20351;&#29992;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
          <span style="color: #2aa1ae; background-color: #292e34;">//r.UpdateGIMaterials();</span>

          <span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#19981;&#20250;&#35302;&#21457;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#21482;&#26159;&#30452;&#25509;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
          DynamicGI.SetEmissive(r, c);
      }
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org73fda99" class="outline-6">
<h6 id="org73fda99">Light Probe Proxy Volumes</h6>
<div class="outline-text-6" id="text-org73fda99">
<p>
烘培 GI 和实时 GI 都是通过 LightProbe 作用于动态物体的。物体的位置用于插值 LightProbe 数据，插值得到的数据再应用于 GI。这对于小物体来说是可行的，但是对于大物体来说就太粗暴了。<br />
</p>

<p>
LLPV（light probe proxy volume）可以解决该问题。其会传递给 shader 一组经过插值的 LightProbe 数据，而不是一个。这些数据会存储到一张浮点型 3D 贴图中，且该贴图需要支持线性过滤模式，只有现代图形显卡才能支持。<br />
在 Graphics/TierSettings/EnableLightProbeProxyVolume 中开启 LightProbeProxyVolume。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
<span style="color: #bc6ec5;">      #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
          <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1)
          {
                <span style="color: #2aa1ae; background-color: #292e34;">// Light Probe Proxy Volume &#21482;&#20351;&#29992;&#20102;&#20004;&#20010;&#22522;&#24102;</span>
              indirect.diffuse = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.worldNormal, 1), i.worldPos);
              indirect.diffuse = <span style="color: #4f97d7;">max</span>(0, indirect.diffuse);
<span style="color: #bc6ec5;">              #if</span> defined(UNITY_COLORSPACE_GAMMA)
                  indirect.diffuse = LinearToGammaSpace(indirect.diffuse);
<span style="color: #bc6ec5;">              #endif</span>
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809; LightProbe ShadeSH9&#20013;&#24050;&#32463;&#22788;&#29702;&#20102;&#39068;&#33394;&#31354;&#38388;&#30340;&#38382;&#39064;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
          }
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809; LightProbe</span>
          indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org64db08c" class="outline-6">
<h6 id="org64db08c">LOD Groups</h6>
<div class="outline-text-6" id="text-org64db08c">
</div>
<ul class="org-ul">
<li><a id="org0a622a9"></a>Baked GI and Lod Group<br />
<div class="outline-text-7" id="text-org0a622a9">
<p>
在烘培静态光照贴图时，使用的是 LOD0。即使在运行时显示的是 LOD1 或者是 LOD culled ，此时阴影和间接光照都是使用的烘培 LOD0 所得数据。<br />
<img src="./UnityCatLikeCoding/01_18ml_lod1_01.jpg" alt="01_18ml_lod1_01.jpg" /><br />
但是 LOD1 依然会使用 lightmap，其采样的数据和 LOD0 采样的数据并不同(分布在 lightmap 贴图的不同位置)，Unity 利用烘培的 LightProbe 来计算 LOD1 的间接光照然后写入到 Lightmap 中，所以烘培带有 LOD 的场景时，需要添加 LightProbe，否则 LOD1 的间接光照会变为黑色，从而显得很暗。<br />
下图是，开启 LightProbe 和关闭 LightProbe 烘焙场景得到的不同效果:<br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withoutLightProbe.png" alt="01_18ml_lodGroup_bake_withoutLightProbe.png" /><br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withLightProbe.png" alt="01_18ml_lodGroup_bake_withLightProbe.png" /><br />
</p>
</div>
</li>
<li><a id="orgcc106aa"></a>Realtime GI and Lod Group<br />
<div class="outline-text-7" id="text-orgcc106aa">
<p>
当只开启 Realtime GI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且取消勾选 BakedGlobalIllumination），在运行时 Lod0 依然使用实时烘培的光照贴图，而 Lod1 会使用 LightProbe 数据(运行时，选中显示 Lod1 的物体，SceneView 下可以看到其使用的 LightProbe，这里需要强调的是，即使 Lod1 是静态物体其使用的也是 LightProbe)。<br />
</p>

<p>
在同时使用 RealtimeGI 和 BakedGI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且勾选 BakedGlobalIllumination），Lod0 会同时使用 Realtime Lightmap （实时光的贡献）和 Baked Lightmap（烘培光的贡献），而 Lod1 只会使用 Baked Lightmap，因为 lightmap 和球谐光照无法同时使用，Lod1 就不会受到 realtime GI 的影响。<br />
</p>

<p>
注意：烘培和渲染 Lod 是完全独立的，如果实时 GI 比烘培 GI 更重要，可以在运行时设置 LOD1 为非 lightmap-static，这样 LOD1 就会使用 Realtime GI 的 LightProbe。<br />
</p>
</div>
</li>
<li><a id="org8d77a2b"></a>Cross-fading Between Lod Levels<br />
<div class="outline-text-7" id="text-org8d77a2b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #pragma</span> multi_compile _ LOD_FADE_CROSSFADE

  <span style="color: #2aa1ae; background-color: #292e34;">// 4*64 &#22823;&#23567;&#36148;&#22270;</span>
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DitherMaskLOD2D</span>;

  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UnityApplyDitherCrossFade</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> vpos)
  {
      vpos /= 4; <span style="color: #2aa1ae; background-color: #292e34;">// the dither mask texture is 4x4</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// unity_LODFade&#21464;&#37327;&#23384;&#20648;&#20102;&#24403;&#21069;fade&#30340;&#24635;&#37327;&#65292;&#25972;&#20010;&#36807;&#31243;&#19968;&#20849;16&#27493;(fade&#19968;&#27493;&#30340;&#20540;&#20026;1/16)</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// quantized lod fade by 16 levels</span>
      vpos.y = <span style="color: #4f97d7;">frac</span>(vpos.y) * 0.0625 <span style="color: #2aa1ae; background-color: #292e34;">/* 1/16 */</span> + unity_LODFade.y;
      <span style="color: #4f97d7;">clip</span>(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DitherMaskLOD2D</span>, vpos).a - 0.5);
  }
</pre>
</div>

<p>
unity_LODFade.x  0-1 范围的 fade 值<br />
unity_LODFade.y  量化为 16 阶后的 fade 值<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="org8d97243"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org54790dc"></a><span class="todo TODO">TODO</span> 为什么不将 LOD1 像 LOD0 那样处理，再渲染一次 LOD1 得到精确的亮度数据写入光照贴图中？<br /></li>
<li><a id="org1a471c3"></a><span class="todo TODO">TODO</span> 为什么球谐光照和 lightmap 无法同时使用？<br /></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0eea7f7" class="outline-5">
<h5 id="org0eea7f7">GPU Instancing</h5>
<div class="outline-text-5" id="text-org0eea7f7">
</div>
<div id="outline-container-org584baf3" class="outline-6">
<h6 id="org584baf3">Batching Instances</h6>
<div class="outline-text-6" id="text-org584baf3">
</div>
<ul class="org-ul">
<li><a id="org90881c7"></a>Baching 简介<br />
<div class="outline-text-7" id="text-org90881c7">
<p>
向 GPU 提交绘制命令会花费时间。将数据（mesh 和材质属性）提交给 GPU 也会耗费时间。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge927910"></a>Static Batching<br />
<div class="outline-text-8" id="text-orge927910">
<p>
Unity 可以将很多材质相同的静态物体合并为一个大的静态物体（可以减少 SetPassCall 但减少 DrawCall 的程度会打折扣），只有使用相同材质的物体才能以这种方式合并。Static Batching 会增加包体大小和内存消耗（使用相同 Mesh 的多个物体被合并为一个大的静态物体时，不会公用同一个 Mesh，而是对一个 Mesh 复制多次来填充大 Mesh，所有定点都被变换到同一个模型坐标系下，所以无法公用同一个 Mesh）<br />
</p>

<ul class="org-ul">
<li>Static Batching 可以减少 SetPassCall，但减少 DrawCall 的程度会打折扣。(lightmap 不同，submesh 被遮挡剔除都会打断 drawCall)<br /></li>
</ul>

<p>
Tips:<br />
SetPassCall 是切换材质时，执行的操作。StaticBatch 将相同材质的物体合并在一起，因此可以减少 SetPassCall<br />
</p>

<ul class="org-ul">
<li><a href="https://answers.unity.com/questions/1178741/setpass-calls-important-to-keep-this-number-low.html">https://answers.unity.com/questions/1178741/setpass-calls-important-to-keep-this-number-low.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="orged06a3b"></a>Dynamic Batching:<br />
<div class="outline-text-8" id="text-orged06a3b">
<p>
Dynamic Batching for meshes: 对于足够小的一系列 Mesh，运行时 Unity 在 CPU 端会将他们变换到世界空间，将他们合并为一个大的 mesh(动态合并大物体的消耗太大了)。(可以减少 DrawCall)<br />
Dynamic batching for dynamically generated geometries: 对于 Build-in Particle Systems, Line Renderers, Trail Renderers。动态合批的工作方式如下：(不能减少 DrawCall)<br />
</p>

<ol class="org-ol">
<li>对于每个 Renderer，Unity 会将所有可以动态合批的内容构建到一个大的顶点缓存区中。<br /></li>
<li>renderer 会设置该 batch 的材质状态<br /></li>
<li>Unity 将顶点缓冲区绑定到 GPU<br /></li>
<li>对于 batch 内的每个 renderer，Unity 会更新顶点缓冲区的偏移量，然后提交一个新的 draw call<br /></li>
</ol>
</div>
</li>
<li><a id="org39e7382"></a>GPU Instancing<br />
<div class="outline-text-8" id="text-org39e7382">
<p>
运行时通知 GPU 绘制同一个 mesh 多次，GPU Instancing 无法将不同的 mesh 或材质合并，但是其并不要求 mesh 必须为小 mesh。<br />
</p>

<ul class="org-ul">
<li>Baching Compare <a href="#orga561059">Batching Compare</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgd76434f"></a>Support GPU Instancing<br />
<ul class="org-ul">
<li><a id="orga036632"></a>支持 GPU Instancing<br />
<div class="outline-text-8" id="text-orga036632">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327;SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;
  };

  vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      vert_out o;
      UNITY_INITIALIZE_OUTPUT(vert_out, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27714;&#35299;&#24403;&#21069;&#23454;&#20363;&#30340; Obj2World World2Obj&#30697;&#38453;</span>
      UNITY_SETUP_INSTANCE_ID(v);
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="org55f8e27"></a>Unity 对 GPU Instancing 的封装<br />
<div class="outline-text-8" id="text-org55f8e27">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;instanceID</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> uint unity_InstanceID;

CBUFFER_START(UnityDrawCallInfo)
    <span style="color: #2aa1ae; background-color: #292e34;">// Where the current batch starts within the instanced arrays.</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> unity_BaseInstanceID;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// &#31995;&#32479;&#21464;&#37327;&#21517;&#31216;SV_InstanceID</span>
<span style="color: #bc6ec5;">#define</span> UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;

<span style="color: #bc6ec5;">#define</span> UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;

<span style="color: #2aa1ae; background-color: #292e34;">// Redefine some of the built-in variables /</span>
<span style="color: #2aa1ae; background-color: #292e34;">// macros to make them work with instancing.</span>
UNITY_INSTANCING_CBUFFER_START(PerDraw0)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorldArray[UNITY_INSTANCED_ARRAY_SIZE];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObjectArray[UNITY_INSTANCED_ARRAY_SIZE];
UNITY_INSTANCING_CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;instance&#25968;&#25454;&#35206;&#30422;&#21407;&#22987;&#23450;&#20041;&#20869;&#23481;</span>
<span style="color: #bc6ec5;">#define</span> unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
<span style="color: #bc6ec5;">#define</span> unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</pre>
</div>

<p>
forward base pass, shadow pass, deferred pass 都支持 GPU Instancing.<br />
forward add pass 不支持 GPU Instancing.<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org9e3e17a"></a>Batch Size<br />
<div class="outline-text-7" id="text-org9e3e17a">
<p>
每个 Batch 都需要自己的矩阵数组。这些数据被发送给 GPU，然后被存储在内存缓冲区(D3D 的 ConstantBuffer,OpenGL 的 UniformBuffer)中。这些缓冲区有最大容量限制，这限制了每个 batch 的实例数量。<br />
假设台式机每个 UniformBuffer 的大小为 64KB，一个矩阵有 16 个浮点数，每个浮点数需要 4 字节存储，每个实例需要 1 个 object-to-world 变换矩阵，如果使用了法线贴图，则还需要 1 个 world-to-object 变换矩阵(用于将法线变换到世界空间)<br />
16*4*2 = 128Byte 64KB/128B=64*1024B/128=512<br />
</p>

<p>
UNITY_INSTANCED_ARRAY_SIZE 默认被定义为 500, 移动平台下被定义为 250.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#36890;&#36807;&#19979;&#38754;&#30340;&#25351;&#20196;&#21487;&#20197;&#23558;&#23454;&#20363;&#25968;&#37327;&#20462;&#25913;&#20026;512</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options maxcount:512
</pre>
</div>
<ul class="org-ul">
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge95aaf2" class="outline-6">
<h6 id="orge95aaf2">Mixing Material Properties</h6>
<div class="outline-text-6" id="text-orge95aaf2">
<p>
所有 DrawCall Batching 都需要物体使用相同的材质。<br />
可以通过 MaterialPropertyBlock 来修改材质属性，从而实现使用相同材质的物体可以有不同的外观，但是通过 MaterialPropertyBlock 修改材质属性，依然会导致 GPU Instancing 失败，因为不同的实例使用了不同的材质属性。<br />
只有在 shader 中定义一个被修改属性的 buffer，Unity 才会将存储在 Material Property Block 中的属性当作数组传递到 GPU(和 Unity 在 GPUInstancing 时对变换矩阵数组的操作一样)，此时 GPU Instancing 才会生效。<br />
MaterialPropertyBlock 支持 Color,Float,Matrix,Vector 类型的属性，如果想支持 Texture 类型，可以使用 TextureArray 然后添加一个 Index 属性将 Index 属性放到 InstancingBuffer 中。<br />
多个属性可以组合放在同一个 Buffer 中，需要注意每个 Buffer 有尺寸限制。另外，Buffer 都是 32 位对齐的，也就是说一个 Float 占用的空间和一个 Vector 占用空间相同。可以使用多个 Buffer，但是 Buffer 的数量也是有限制的，而且 Buffer 也是有性能消耗的。当 GPUInstancing 开启后，每个被放入 Buffer 的属性都会变为一个数组，所以应该只将每个实例都不同的属性放入 Buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;

  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> vert_out
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> frag_in
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  };

  vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      vert_out o;
      UNITY_INITIALIZE_OUTPUT(vert_out, o);
      UNITY_SETUP_INSTANCE_ID(v);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23558;InstanceID&#20256;&#36882;&#21040;fragment</span>
      UNITY_TRANSFER_INSTANCE_ID(v, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(frag_in i)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;InstanceID&#33719;&#21462;&#24403;&#21069;&#23454;&#20363;&#30340;&#23646;&#24615;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> alpha = UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, <span style="color: #7590db;">_Color</span>).a;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * alpha;
  }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#20250;&#23558; unity_LODFade &#25918;&#20837;Buffer&#65292;&#36825;&#26679;&#22312;&#35774;&#32622;LodFadeMode=CrossFade&#26102;&#65292;GPUInstancing&#19981;&#20250;&#22833;&#25928;</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options lodfade
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc032892" class="outline-5">
<h5 id="orgc032892">Parallax</h5>
<div class="outline-text-5" id="text-orgc032892">
</div>
<div id="outline-container-org43b0903" class="outline-6">
<h6 id="org43b0903">参考资料</h6>
<div class="outline-text-6" id="text-org43b0903">
<ul class="org-ul">
<li>Parallax-Mapping <a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">https://learnopengl.com/Advanced-Lighting/Parallax-Mapping</a><br /></li>
<li>Learn about Parallax en <a href="https://github.com/UPBGE/upbge/issues/1009">https://github.com/UPBGE/upbge/issues/1009</a><br /></li>
<li>Learn about Parallax cn <a href="https://zhuanlan.zhihu.com/p/128682162">https://zhuanlan.zhihu.com/p/128682162</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org5a0b365" class="outline-4">
<h4 id="org5a0b365">Advanced Rendering</h4>
<div class="outline-text-4" id="text-org5a0b365">
</div>
<div id="outline-container-org37cdb17" class="outline-5">
<h5 id="org37cdb17">Flat and Wireframe Shading</h5>
<div class="outline-text-5" id="text-org37cdb17">
</div>
<div id="outline-container-org0f94691" class="outline-6">
<h6 id="org0f94691">Barycentric Coordinates</h6>
</div>

<div id="outline-container-orgd33a503" class="outline-6">
<h6 id="orgd33a503">Q&amp;A</h6>
<div class="outline-text-6" id="text-orgd33a503">
</div>
<ul class="org-ul">
<li><a id="org081d434"></a>为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？<br />
<div class="outline-text-7" id="text-org081d434">
<p>
cross 操作需要注意向量的正反方向，将所得向量取反就可以了。<br />
</p>
</div>
</li>
<li><a id="org1d39f58"></a>其他 flat shading 方法<br />
<div class="outline-text-7" id="text-org1d39f58">
<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/solved-flat-shading.410943/">https://forum.unity.com/threads/solved-flat-shading.410943/</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8136984" class="outline-5">
<h5 id="org8136984">Tessellation</h5>
<div class="outline-text-5" id="text-org8136984">
</div>
<div id="outline-container-org2ae2a34" class="outline-6">
<h6 id="org2ae2a34">Q&amp;A</h6>
<div class="outline-text-6" id="text-org2ae2a34">
</div>
<ul class="org-ul">
<li><a id="org846cb3f"></a>ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;<br />
<div class="outline-text-7" id="text-org846cb3f">
<p>
Unity_patchconstantfunc 改为 UNITY_patchconstantfunc 就可以了。<br />
</p>
</div>
</li>

<li><a id="orgc53fa9c"></a>ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'<br />
<div class="outline-text-7" id="text-orgc53fa9c">
<p>
TessControlPoint 中成员使用了 float 类型，appdata 中使用的 half 类型。使用同一类型就可以了<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org738c6a7" class="outline-5">
<h5 id="org738c6a7">Surface Displacement</h5>
</div>
<div id="outline-container-org0dd093b" class="outline-5">
<h5 id="org0dd093b">Bloom</h5>
<div class="outline-text-5" id="text-org0dd093b">
</div>
<div id="outline-container-orgfaf998e" class="outline-6">
<h6 id="orgfaf998e">利用 Downsampling Upsampling 模糊图片的原理</h6>
<div class="outline-text-6" id="text-orgfaf998e">
<ul class="org-ul">
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering</a><br /></li>
<li><a href="#orgfc1eb0b">No description for this link</a><br /></li>
<li>高斯模糊 <a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html">http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb9c5ba4" class="outline-5">
<h5 id="orgb9c5ba4">Depth of Field</h5>
<div class="outline-text-5" id="text-orgb9c5ba4">
</div>
<div id="outline-container-org850801a" class="outline-6">
<h6 id="org850801a">光学原理</h6>
<div class="outline-text-6" id="text-org850801a">
<ul class="org-ul">
<li>光学成像原理之景深 <a href="https://blog.csdn.net/mingjinliu/article/details/103648118">https://blog.csdn.net/mingjinliu/article/details/103648118</a> 有道笔记有备份<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge0924fb" class="outline-6">
<h6 id="orge0924fb">实现原理</h6>
<div class="outline-text-6" id="text-orge0924fb">
</div>
<ul class="org-ul">
<li><a id="orgc1f70ad"></a>COC Pass (CircleOfConfusionPass)<br />
<div class="outline-text-7" id="text-orgc1f70ad">
<p>
采样摄像机深度贴图，转化为摄像机空间中的深度，计算 COC，将 COC 的值写入 RT。<br />
</p>

<p>
计算 COC 公式如下：<br />
COC = (EyeDepth - _FocusDistance)/_FocusRange;<br />
</p>

<p>
Circle of confusion 是物体上一个点在胶片上对应的一个圆圈<br />
</p>
</div>
</li>
<li><a id="org6789cd6"></a>PreFilterPass<br />
<div class="outline-text-7" id="text-org6789cd6">
<p>
对原来的 RenderTarget 进行 DownSampling，同时将 COC 的值写入到 A 通道。<br />
</p>

<p>
Tips：<br />
降采样，为了保证图片不变暗颜色的权重计算使用下面方法：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">ColorWeight</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> c)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / (1 + <span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(c.r, c.g),c.b));
}
</pre>
</div>

<p>
降采样，为了保证 coc 值正确，写入的 coc 做如下取舍：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> coc0 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.xy).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.zy).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.xw).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc3 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.zw).r;
<span style="color: #ce537a; font-weight: bold;">half</span> cocMin = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(coc0, coc1), coc2), coc3);
<span style="color: #ce537a; font-weight: bold;">half</span> cocMax = <span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(coc0, coc1), coc2), coc3);
<span style="color: #ce537a; font-weight: bold;">half</span> coc = cocMax &gt;= -cocMin ? cocMax : cocMin;
</pre>
</div>
</div>
</li>
<li><a id="org11f3d49"></a>Bokeh<br />
<div class="outline-text-7" id="text-org11f3d49">
<p>
Bokeh Pass 主要模拟了 DOF 模糊的圆圈效果。<br />
</p>

<p>
CoC(Circle Of Confusion) 决定了 Bokeh 效果在每个点上的强度，Aperture 决定了 Bokeh 的形状。图片是由很多个 Aperture 形状投影到成像平面得到的。<br />
一种创建 Bokeh 的方法是，使用每个图元的颜色为该图元渲染一个 Sprite，Sprite 的大小和不透明度都基于图元的 CoC（这种方式耗费很大，其需要大量的 Overdraw）。（该方法是将一个片段投影到多个片段上）<br />
另一种方式是，每个片段从所有可能影响该片段的图元累加颜色，这种方法不需要额外的几何体，但是需要进行多次贴图采样。<br />
</p>

<p>
使用 DiskKernels 来对上一步生成的贴图进行采样(以当前像素点为中心采样一个圆盘)，每个样本的权重按照如下方式来计算：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">Weight</span>(<span style="color: #ce537a; font-weight: bold;">half</span> coc, <span style="color: #ce537a; font-weight: bold;">half</span> radius)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//return coc &gt;= radius;  // &#22914;&#26524;coc&#22823;&#20110;radius&#21017;&#26435;&#37325;&#20026;1&#65292;&#21542;&#21017;&#20026;0</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>((coc - radius + 2) / 2);
}
</pre>
</div>
<p>
实现中可以利用 COC 的正负来分离开 DOF 的前景和背景，coc 为负的部分为前景，正的部分为背景。<br />
</p>
</div>
</li>
<li><a id="org049d0cd"></a>PostFilterPass<br />
<div class="outline-text-7" id="text-org049d0cd">
<p>
使用 Tent Filter 进一步将 DOF 的结果模糊，减弱 Bokeh 圆圈上很多个小圆点的 Artifact。<br />
</p>
</div>
</li>
<li><a id="orga84b224"></a>CombinePass<br />
<div class="outline-text-7" id="text-orga84b224">
<p>
使用 CoC Texture 来指导 DOF 贴图和原始未模糊的贴图.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> dofStrength = <span style="color: #4f97d7;">smoothstep</span>(0.1, 1, <span style="color: #4f97d7;">abs</span>(coc));
<span style="color: #ce537a; font-weight: bold;">half3</span> color = <span style="color: #4f97d7;">lerp</span>(source.rgb, dof.rgb, dofStrength);
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgea49d7e" class="outline-6">
<h6 id="orgea49d7e">Q&amp;A</h6>
<div class="outline-text-6" id="text-orgea49d7e">
</div>
<ul class="org-ul">
<li><a id="org8275e64"></a>为什么开启 MSAA 的时候，DOF 效果会错误？<br /></li>
<li><a id="orgef3eb85"></a>为什么 DOF 效果要么覆盖全屏，要么没有？<br />
<div class="outline-text-7" id="text-orgef3eb85">
<p>
检查 DOF 中使用的 depth 贴图，发现 depth 贴图是 unity 默认的灰色贴图。设置摄像机 depthTextureMode 为 Depth。即可解决该问题。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd852369" class="outline-5">
<h5 id="orgd852369">FXAA</h5>
<div class="outline-text-5" id="text-orgd852369">
</div>
<div id="outline-container-org925cf78" class="outline-6">
<h6 id="org925cf78">SSAA MSAA</h6>
<div class="outline-text-6" id="text-org925cf78">
<p>
SSAA 通过渲染更大分辨率的画面，通过 Downsampling 来消除锯齿。<br />
MSAA 一个片段中分配多个采样点 N，计算被覆盖的采样点个数 X，从而获得当前片段颜色和片段中原始颜色的混合比例（X/N 为当前片段颜色 N-X/N 为原始颜色）。<br />
</p>

<p>
MSAA 跟 SSAA 不同的地方在于，SSAA 对于所有子采样点着色，而 MSAA 只使用当前像素中心点对应的属性进行着色。这是 MSAA 相对于 SSAA 来说最大的好处。<br />
MSAA 样本位置和重建函数都依赖于硬件实现(新的 GPU 和图形 API 支持在着色器中自定义重建过程)。<br />
</p>

<p>
开启 MSAA 时，光栅化阶段执行的操作：<br />
</p>
<ol class="org-ol">
<li>光栅化插值顶点属性时，取像素中心点对应的位置（因为，pixel shader 调用的位置就是在像素中心点），来生成该像素对应的属性。<br /></li>
<li><p>
对于每个样本都会执行覆盖测试(样本位置依赖于硬件实现)，而不再对像素中心点执行覆盖测试。如果样本在三角形内（或者样本通过了 top-left rule），则其对应的 mask[sampleIdx]被设置为 1.<br />
</p>
<ul class="org-ul">
<li>Tips: 如果像素内没有样本被覆盖，就算像素中心点被覆盖了，该像素依然不会被渲染。如下图最左边从上往下第二个三角形。<br /></li>
</ul>

<div id="org7b00448" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA_raster_rule.png" alt="02_06fxaa_SMAA_raster_rule.png" width="500px" /><br />
</p>
</div></li>
<li>如果 Early-Per-Fragment Test 开启，则对于被覆盖的每个样本（mask 为 1 的样本）都会执行 Scissor Test、 Stencil Test、Depth Buffer Test。（每个样本可能由不同的三角形覆盖）。<br /></li>
</ol>

<p>
开启 MSAA 时，Pixel Shader 执行的操作：<br />
</p>
<ol class="org-ol">
<li>Pixel Shader 使用像素中心点对应的属性执行 Pixel Shader 中的计算。<br /></li>
</ol>

<p>
开启 MSAA 时，Per-Fragment Operations 阶段：<br />
</p>
<ol class="org-ol">
<li>将 Pixel Shader 中计算的结果，copy 到有效样本（对于 mask 为 1 切通过 depth-stencil 测试的样本）对应的 multisample buffer 中。<br /></li>
<li>如果 Early-Per-Fragment Test 没有开启，则对于被覆盖的每个样本（mask 为 1 的样本）都会执行 Scissor Test、 Stencil Test、Depth Buffer Test。<br /></li>
<li>对每个有效样本执行 blending dithering 以及 logical operations。此时，修改的都是 multisample buffer 中的内容，而不是 color buffer 中的内容。<br />
<ul class="org-ul">
<li>有效样本 是指 mask 为 1 且通过了之前各种 Test 的样本。<br /></li>
</ul></li>
<li>使用重建函数利用 multisample buffer 中的内容构建出最终的颜色和深度，并写入到 color buffer 和 depth buffer 中。<br />
<ul class="org-ul">
<li>不同平台使用不同方式，新的 GPU 和图形 API 支持在着色器中自定义重建过程。<br /></li>
<li>参考资料：MSAA depth resolve <a href="http://aicdg.com/ue4-msaa-depth/">http://aicdg.com/ue4-msaa-depth/</a><br /></li>
</ul></li>
</ol>
<p>
下图展示了 Pixel Shader 之后执行的操作：<br />
</p>

<div id="org000b2de" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA_after_pixel_shader.png" alt="02_06fxaa_SMAA_after_pixel_shader.png" width="500px" /><br />
</p>
</div>

<p>
下图展示了 MSAA 的实现原理：<br />
</p>

<div id="orgafe584f" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA.png" alt="02_06fxaa_SMAA.png" width="500px" /><br />
</p>
</div>

<p>
在 OpenGL 中使用 MSAA 时，需要为一个像素存储多个样本值，因此，需要使用 multisample buffer 来代替默认的 buffer。大多数窗口系统可以为我们提供一个 multisample buffer 来代替 default buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLFW &#31383;&#21475;&#31995;&#32479;&#36890;&#36807;&#19979;&#38754;&#25509;&#21475;&#26469;&#25351;&#23450;&#20351;&#29992;multisample buffer</span>
  glfwWindowHint(GLFW_SAMPLES, 4);
  glEnable(GL_MULTISAMPLE);
</pre>
</div>

<p>
当我们自己离屏渲染时，如果需要开启 MSAA，则需要自己创建 multisample buffer<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Off-Screen MSAA</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">CONFIG-BUFFER</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure MSAA framebuffer</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">framebuffer</span>;
  glGenFramebuffers(1, &amp;framebuffer);
  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a multisampled color attachment texture</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">textureColorBufferMultiSampled</span>;
  glGenTextures(1, &amp;textureColorBufferMultiSampled);
  glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled);
  glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGB, SCR_WIDTH, SCR_HEIGHT, GL_TRUE);
  glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a (also multisampled) renderbuffer object for depth and stencil attachments</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">rbo</span>;
  glGenRenderbuffers(1, &amp;rbo);
  glBindRenderbuffer(GL_RENDERBUFFER, rbo);
  glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);
  glBindRenderbuffer(GL_RENDERBUFFER, 0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure second post-processing framebuffer</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">intermediateFBO</span>;
  glGenFramebuffers(1, &amp;intermediateFBO);
  glBindFramebuffer(GL_FRAMEBUFFER, intermediateFBO);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a color attachment texture</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">screenTexture</span>;
  glGenTextures(1, &amp;screenTexture);
  glBindTexture(GL_TEXTURE_2D, screenTexture);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, <span style="color: #a45bad;">NULL</span>);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we only need a color buffer</span>

  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">DRAW-CALL</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">------</span>
  glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. draw scene as normal in multisampled buffers</span>
  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
  glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glEnable(GL_DEPTH_TEST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set transformation matrices</span>
  shader.use();
  <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span> = <span style="color: #a45bad;">glm</span>::perspective(<span style="color: #a45bad;">glm</span>::radians(camera.Zoom), (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_WIDTH / (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_HEIGHT, 0.1f, 1000.0f);
  shader.setMat4(<span style="color: #2d9574;">"projection"</span>, projection);
  shader.setMat4(<span style="color: #2d9574;">"view"</span>, camera.GetViewMatrix());
  shader.setMat4(<span style="color: #2d9574;">"model"</span>, <span style="color: #a45bad;">glm</span>::mat4(1.0f));

  glBindVertexArray(cubeVAO);
  glDrawArrays(GL_TRIANGLES, 0, 36);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. now blit multisampled buffer(s) to normal colorbuffer of intermediate FBO. Image is stored in screenTexture</span>
  glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);
  glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
  glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. now render quad with scene's visuals as its texture image</span>
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_DEPTH_TEST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">draw Screen quad</span>
  screenShader.use();
  glBindVertexArray(quadVAO);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, screenTexture); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use the now resolved color attachment as the quad's texture</span>
  glDrawArrays(GL_TRIANGLES, 0, 6);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------------------------------------</span>
  glfwSwapBuffers(window);
  glfwPollEvents();
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org9c01a0a"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org5e66804"></a>Unity 中开启了 MSAA 后，如何生成后处理 DOF 中需要的 DepthTexture 的？<br />
<div class="outline-text-8" id="text-org5e66804">
<p>
Unity 2021.3.1 , URP 12.1.6, Editor 下修改 Graphic API，开启 MSAA 4x ，FrameDebug 得到如下信息：<br />
</p>

<div id="org97691f3" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-unity-msaa-depth.jpg" alt="advanced-rendering_05_fxaa-unity-msaa-depth.jpg" width="1000px" /><br />
</p>
</div>

<ul class="org-ul">
<li>Unity 里，如果开启了 MSAA，怎么直接读取渲染场景时的深度？ <a href="https://www.zhihu.com/question/449384579">https://www.zhihu.com/question/449384579</a><br /></li>
</ul>
</div>
</li>
<li><a id="org651d162"></a>Unity 开启 MSAA 后的性能消耗如何？<br />
<div class="outline-text-8" id="text-org651d162">

<div id="orgc6539f9" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-unity-msaa-depth.jpg" alt="advanced-rendering_05_fxaa-unity-msaa-depth.jpg" width="1000px" /><br />
</p>
</div>

<p>
从上图可以看到，OpenGL ES 3.2 平台下，开启 MSAA 时，Unity 会开启 PreDepthPass，通过该 Pass 来生成深度图。<br />
</p>

<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/msaa-performance-on-mobile.825450/">https://forum.unity.com/threads/msaa-performance-on-mobile.825450/</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgafbe0e0"></a>开启 MSAA 后 DepthBuffer 和 StencilBuffer 的分辨率会提高，Resolve depth stencil 时，直接对 Depth 值和 Stencil 值进行平均显然是错误的，那么，Resolve 是如何处理 Depth 和 Stencil 的呢？<br />
<div class="outline-text-8" id="text-orgafbe0e0">
<p>
游戏引擎随笔 0x15：现代图形 API 的 MSAA 文章中详细表述了该问题。Depth 和 Stencil 不会使用平均的方式，而是使用 Min(使用最小的值),Max(使用最大的值),Sample0(使用第 0 个样本存储的值)。<br />
具体执行 Resolve 的方式，则分为两类：硬件 Resolving 和利用 Shader 来实现 Resolving。另外，不同图形 API，处理 Resolve 方式也不同。<br />
</p>

<ul class="org-ul">
<li>游戏引擎随笔 0x15：现代图形 API 的 MSAA <a href="https://zhuanlan.zhihu.com/p/263101710">https://zhuanlan.zhihu.com/p/263101710</a><br /></li>
</ul>
</div>
</li>
<li><a id="org660381d"></a>为什么 MSAA 每个子采样点需要独立存储颜色和深度？<br />
<div class="outline-text-8" id="text-org660381d">
<p>
因为不同的三角形可能覆盖同一个像素的不同子采样点。此时该像素会执行多次片段着色器，需要将不同的颜色值 copy 到 multisample color buffer 和 multisample depth buffer。<br />
</p>


<div id="org629ebd9" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-msaa-detail.jpg" alt="advanced-rendering_05_fxaa-msaa-detail.jpg" width="800px" /><br />
</p>
</div>
</div>
</li>
<li><a id="orge4aa5ed"></a>延迟渲染为什么不支持 MSAA？<br />
<div class="outline-text-8" id="text-orge4aa5ed">
<p>
技术上来说是可行的，只需要分配 Multisample Buffer 给 MRT 就可以了。但是开启 MSAA 后，GBuffer 的尺寸会成倍增加，带宽消耗成倍增加。另外，开启 MSAA 后，延迟渲染不做任何修改的话，渲染结果是错误的。延迟渲染第一节阶段生成 GBuffer 内容是没问题的，第二个阶段，读取 GBuffer 内容时，此时样本覆盖值都是 1，所以 color，normal，depth 读出来是 4 个样本的平均值，对于颜色来说没问题，normal 和 depth 就是错误的。<br />
</p>

<p>
一种可行的方法是，延迟渲染第一阶段开启 MSAA，然后将 GBuffer Resolve 为正常尺寸的 RT，第二个阶段拿 Resolve 出来的 GBuffer 做光照渲染。<br />
</p>

<ul class="org-ul">
<li>延迟渲染与 MSAA 的那些事 <a href="https://zhuanlan.zhihu.com/p/135444145">https://zhuanlan.zhihu.com/p/135444145</a><br /></li>
<li>延迟渲染为什么不支持 MSAA？ <a href="https://www.zhihu.com/question/366668747">https://www.zhihu.com/question/366668747</a><br /></li>
</ul>
</div>
</li>
<li><a id="org03b570c"></a>MSAA 为什么会影响 HDR 开启后的效果？<br />
<div class="outline-text-8" id="text-org03b570c">
<p>
MSAA Resolve 阶段会平均样本颜色，在 ToneMapping 之前 Resolve 样本颜色，得到的颜色值会偏向颜色值更大的样本颜色，从而会导致锯齿很明显。下面文章中都提到了该问题。<br />
</p>

<ul class="org-ul">
<li>MSAA 基础 <a href="http://aicdg.com/aa/">http://aicdg.com/aa/</a> (有道备份)<br /></li>
<li>移动端高性能图形开发 - 详解 MSAA <a href="https://zhuanlan.zhihu.com/p/382063141">https://zhuanlan.zhihu.com/p/382063141</a><br /></li>
<li>HDR inverse tone mapping MSAA resolve <a href="https://theagentd.blogspot.com/2013/01/hdr-inverse-tone-mapping-msaa-resolve.html">https://theagentd.blogspot.com/2013/01/hdr-inverse-tone-mapping-msaa-resolve.html</a>  (有道备份)<br /></li>
</ul>
</div>
</li>
<li><a id="org36a4aa4"></a>AlphaToMask AlphaToCoverage 的原理是什么？<br />
<div class="outline-text-8" id="text-org36a4aa4">
<p>
开启 MSAA ，执行完 fragment shader 后，需要根据每个 sample 的 occlusion mask 将 fragColor copy 到对应 MultiSamplerFrameBuffer。<br />
开启 AlphaToCoverage 时，执行完 fragment shader 后，会根据 sample 的 alpha 生成一个临时的 occlusion mask。然后将临时覆盖值与片段覆盖值进行与运算，以生成新的片段覆盖值。<br />
<del>执行 copy 操作时，会将 fragColor.a*fragColor.rgb 作为 rgb，a 值依然为 fragColor.a。</del><br />
</p>

<p>
<del>假设像素有 4 个样本 s0,s1,s2,s3，只有 s0 和 s1 被覆盖，则只将 fragColor copy 给 s0 和 s1 对应的 MultiSamplerFrameBuffer</del><br />
<del>s0=float4(fragColor.rgb*fragColor.a, fragColor.a);</del><br />
<del>s1=float4(fragColor.rgb*fragColor.a, fragColor.a);</del><br />
</p>

<p>
<del>resolve color rt 阶段 4 个样本已经都是对当前像素有效的样本:</del><br />
<del>resolvedColor = (s0.rgba + s1.rgba + s2.rgba + s3.rgba)/4</del><br />
</p>



<p>
下面 OpenGL ES 3.1 Specification 中关于 AlphaToCoverage 的描述:<br />
</p>
<pre class="example" id="org6245bc7">
如果启用了 SAMPLE_ALPHA_TO_COVERAGE，则会生成一个临时覆盖值，其中每个位由绘制缓冲区零（参见第 14.2.3 节）中对应采样位置（参见第 13.2.1 节）的 alpha 值确定。然后将临时覆盖值与片段覆盖值进行“与”运算，以生成新的片段覆盖值。

这种临时覆盖的生成方式与样本覆盖（参见第 13.6.3 节）相同，但它是片段 alpha 值（限定在 [0, 1] 范围内）的函数。该函数不必完全相同，但必须具有相同的比例性和不变性。
</pre>

<p>
下图为开启 MSAA AlphaToCoverage 和 没开启时的对比：<br />
<img src="./UnityCatLikeCoding/alpha2Mask-test.jpg" alt="alpha2Mask-test.jpg" /><br />
</p>

<p>
详情参考 Assets/MyTest/URP_SRP/11_AlphaToMask/AlphaToMaskTree.shader 的实现。<br />
</p>

<ul class="org-ul">
<li><a href="https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f</a><br /></li>
<li>为什么 Alpha to coverage 方法不需要排序？ <a href="https://www.zhihu.com/question/25822656">https://www.zhihu.com/question/25822656</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org21fb410"></a>参考资料<br />
<div class="outline-text-7" id="text-org21fb410">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing</a><br /></li>
<li>深入剖析 MSAA <a href="https://www.cnblogs.com/ghl_carmack/p/8245032.html">https://www.cnblogs.com/ghl_carmack/p/8245032.html</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">https://en.wikipedia.org/wiki/Multisample_anti-aliasing</a><br /></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules</a><br /></li>
<li>对多重采样（MSAA）原理的一些疑问 <a href="https://www.zhihu.com/question/58595055/answer/157756410">https://www.zhihu.com/question/58595055/answer/157756410</a> （如果丢失可以参考有道云笔记备份）<br /></li>
<li>OpenGL ES 3.0 Specification <a href="https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf">https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf</a><br /></li>
<li>OpenGL ES 3.1 Specification <a href="https://registry.khronos.org/OpenGL/specs/es/3.1/es_spec_3.1.pdf">https://registry.khronos.org/OpenGL/specs/es/3.1/es_spec_3.1.pdf</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc8f724c" class="outline-6">
<h6 id="orgc8f724c">MLAA and SMAA</h6>
<div class="outline-text-6" id="text-orgc8f724c">
<ul class="org-ul">
<li>SMAA <a href="https://zhuanlan.zhihu.com/p/342211163">https://zhuanlan.zhihu.com/p/342211163</a> 网易云笔记备份<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0307c97" class="outline-6">
<h6 id="org0307c97">参考资源</h6>
<div class="outline-text-6" id="text-org0307c97">
<ul class="org-ul">
<li><a href="http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html">http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html</a><br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgff16210" class="outline-5">
<h5 id="orgff16210">Triplanar Mapping</h5>
<div class="outline-text-5" id="text-orgff16210">
</div>
<div id="outline-container-org2268f5b" class="outline-6">
<h6 id="org2268f5b">求解 Normal</h6>
<div class="outline-text-6" id="text-org2268f5b">
</div>
<ul class="org-ul">
<li><a id="org875d149"></a>TangentNormal<br />
<div class="outline-text-7" id="text-org875d149">

<div id="org89ec06a" class="figure">
<p><img src="./UnityCatLikeCoding/02_07tm_CalcNormal.jpg" alt="02_07tm_CalcNormal.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="org51831af"></a>TangentNormalToWorldNormal WorldNormalToTangentNormal<br />
<div class="outline-text-7" id="text-org51831af">
<p>
tangentNormal 向上的方向始终为 z，worldNormal 向上的方向随不同投影面而变化。YZ 平面，worldNormal 向上方向在 x 轴方向；XZ 平面，worldNormal 向上在 y 轴方向；XY 平面，worldNormal 向上在 z 轴方向。<br />
tangentNormalX.xyz = worldNormal.zyx  worldNormal 向上的方向为 x 而不是 z，<br />
worldNormal.xyz = tangentNormalX.zyx  tangentNormalX 向上的方向为 z 而不是 x<br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge313fd2" class="outline-4">
<h4 id="orge313fd2">CustomSRP</h4>
<div class="outline-text-4" id="text-orge313fd2">
</div>
<div id="outline-container-org6d611b1" class="outline-5">
<h5 id="org6d611b1">CustomSRP 1.0</h5>
<div class="outline-text-5" id="text-org6d611b1">
</div>
<div id="outline-container-org9a3698b" class="outline-6">
<h6 id="org9a3698b">Custom Render Pipeline</h6>
<div class="outline-text-6" id="text-org9a3698b">
</div>
<ul class="org-ul">
<li><a id="org64fa9c8"></a>架构<br />
<div class="outline-text-7" id="text-org64fa9c8">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipelineAsset.cs &#21019;&#24314;CustomRenderPipeline&#23454;&#20363;&#65292;&#25552;&#20379;&#32473;unity&#24341;&#25806;</span>
  [<span style="color: #bc6ec5; font-weight: bold;">CreateAssetMenu</span>(menuName = <span style="color: #2d9574;">"Rendering/CustomRenderPipeline"</span>)]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> CustomRenderPipelineAsset : <span style="color: #ce537a; font-weight: bold;">RenderPipelineAsset</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span> <span style="color: #bc6ec5; font-weight: bold;">CreatePipeline</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span>();
      }
  }

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipeline.cs &#23454;&#29616;CustomRenderPipeline&#31867;&#21151;&#33021;&#12290;&#36845;&#20195;&#28210;&#26579;&#21508;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span> : <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span>
{
    <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span> <span style="color: #7590db;">renderer</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>();
    <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Render</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #ce537a; font-weight: bold;">Camera</span>[] <span style="color: #7590db;">cameras</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">camera</span> <span style="color: #4f97d7; font-weight: bold;">in</span> cameras)
        {
            renderer.<span style="color: #bc6ec5; font-weight: bold;">Render</span>(context, camera);
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CameraRenderer.cs CameraRenderer.Editor.cs &#23454;&#29616;CameraRenderer&#31867;&#21151;&#33021;&#12290;&#28210;&#26579;&#26576;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">partial</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org396897e"></a>CommandBuffer BeginSample EndSample<br />
<div class="outline-text-7" id="text-org396897e">
<p>
CommandBuffer 的 BeginSample 和 EndSample 方法也需要调用 context.ExecuteCommandBuffer(buffer);才能生效。<br />
另外 CommandBuffer 的 BeginSample 和 EndSample 需要成对。<br />
</p>
</div>
</li>
<li><a id="org92e1a39"></a>CameraClearFlags<br />
<div class="outline-text-7" id="text-org92e1a39">
<p>
CameraClearFlags 定义的 4 个枚举不是互相独立的，其表示了一个降量清除。例如，除了 CameraClearFlags.Nothing 以外，其他枚举都需要清除深度缓冲区。<br />
CameraClearFlags.Skybox     ==&gt; Clear Z+Stencil<br />
CameraClearFlags.Color      ==&gt; Clear Color+Z+Stencil<br />
CameraClearFlags.SolidColor<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">CameraClearFlags</span>
  {
      <span style="color: #7590db;">Skybox</span> = 1,
      <span style="color: #7590db;">Color</span> = 2,
      <span style="color: #7590db;">SolidColor</span> = 2,
      <span style="color: #7590db;">Depth</span> = 3,
      <span style="color: #7590db;">Nothing</span> = 4
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org98f516b" class="outline-6">
<h6 id="org98f516b">Draw Calls</h6>
<div class="outline-text-6" id="text-org98f516b">
</div>
<ul class="org-ul">
<li><a id="org2a6c298"></a>Write a HLSL Shader<br />
<ul class="org-ul">
<li><a id="org12ee00b"></a>shader 中顶点坐标为什么使用 float4 而不是使用 float3？<br />
<div class="outline-text-8" id="text-org12ee00b">
<p>
3D 空间的坐标点被定义为 4 维向量，并且 w 分量设置为 1，而 3D 空间的方向向量的 w 分量则被设置为 0。这样可以使用相同的变换矩阵来对点和向量进行变换，因此使用 float4 表示顶点。<br />
假如向量为行向量，矩阵中第 4 行存储的是平移信息，3D 空间中的点变换需要平移，因此其 w 分量为 1，而 3D 空间的向量不需要平移变换，因此其 w 分量为 0。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org3d7d84e"></a>Batching<br />
<div class="outline-text-7" id="text-org3d7d84e">
<p>
合批是指将 DrawCall 合并，减少 CPU 和 GPU 沟通消耗的时间。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1ddcea3"></a>SRP batcher<br />
<div class="outline-text-8" id="text-org1ddcea3">
<p>
最简单的方式是开启 SRP batcher。但是，选中我们的 Unlit.shader 文件，在 Inspector 面板上提示 not compatible。<br />
SRPBatcher 带来了如下两点优化：<br />
</p>
<ol class="org-ol">
<li>SRP batcher 并没有减少 draw call 的数量，其会将材质的属性缓存在 GPU，从而避免每次 draw call 都需要从 CPU 发送材质属性到 GPU，这样就减少了 CPU 和 GPU 交互的数据量，也减少了 CPU 执行每个 DrawCall 时的工作。<br />
<img src="./UnityCatLikeCoding/srpBatcher0.jpg" alt="srpBatcher0.jpg" /><br /></li>
<li>SRP batcher 将所有 PerObject 数据放到一个大的 StorageBuffer 中，不需要每个 Object 上传一次，而是将所有 PerObject 数据一次上传。DrawCall 之前为 Object 绑定合适的 Offset 就可以了。这极大减少了 CPU 和 GPU 交互频率，性能提升很大。<br />
<img src="./UnityCatLikeCoding/srpBatcher1.jpg" alt="srpBatcher1.jpg" /><br /></li>
</ol>

<p>
注意：<br />
</p>
<ol class="org-ol">
<li>不会减少 draw call 数量<br /></li>
<li>支持多个物体使用相同 shader 定义的不同材质，每个材质使用不同的材质属性。<br /></li>
<li>支持多个物体使用相同的材质。<br /></li>
<li>不支持每个物体使用相同材质而拥有不同的材质属性，即不支持 MaterialPropertyBlock.<br /></li>
<li>不支持粒子<br /></li>
<li>若 shader Properties 部分除去渲染状态（Blend Mode, ZTest Mode 等）外，没有其他属性，会强制开启 SRP batcher。<br /></li>
</ol>

<p>
通过如下方式支持 SRP batcher：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// UnlitPass.hlsl</span>
  CBUFFER_START(UnityPerMaterial)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseColor</span>;
  CBUFFER_END

  <span style="color: #2aa1ae; background-color: #292e34;">// UnityInput.hlsl</span>
  CBUFFER_START(UnityPerDraw)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorld;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LODFade;
    real4 unity_WorldTransformParams;
  CBUFFER_END

  <span style="color: #2aa1ae; background-color: #292e34;">// CustomRenderPipeline.cs &#22686;&#21152;&#26500;&#36896;&#20989;&#25968;&#65292;&#35774;&#32622;&#21551;&#29992;SRP Batching</span>
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">CustomRenderPipeline</span> ()
  {
      GraphicsSettings.useScriptableRenderPipelineBatching = <span style="color: #a45bad;">true</span>;
  }
</pre>
</div>

<p>
在 CustomURP 实现中，使用的 CBUFFER 如下：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgebfbcb6"></a>LitInput.hlsl<br />
<div class="outline-text-9" id="text-orgebfbcb6">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// LitInput.hlsl</span>
CBUFFER_START(UnityPerMaterial)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseMap_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseColor</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_EmissionColor</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_ZWrite</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Metallic</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Smoothness</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Occlusion</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Fresnel</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailMap_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailAlbedo</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailSmoothness</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_NormalScale</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailNormalScale</span>;
CBUFFER_END(UnityPerMaterial)
</pre>
</div>
</div>
</li>
<li><a id="org4004f5c"></a>UnityInput.hlsl<br />
<div class="outline-text-9" id="text-org4004f5c">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// UnityInput.hlsl</span>
CBUFFER_START(UnityPerDraw)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorld;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LODFade;
    real4 unity_WorldTransformParams;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_RenderingLayer;

    real4 unity_LightData;
    real4 unity_LightIndices[2];

    <span style="color: #2aa1ae; background-color: #292e34;">// Unity&#20063;&#20250;&#23558;ShadowMask&#25968;&#25454;&#28888;&#22521;&#21040;LightProbes&#20013;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbesOcclusion;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#21453;&#23556;&#29699;&#30456;&#20851;&#23646;&#24615;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SpecCube0_HDR;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LightmapST;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_DynamicLightmapST;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAr;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAg;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAb;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBr;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBg;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBb;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHC;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeParams;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ProbeVolumeWorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeSizeInv;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeMin;
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="org4e8c2a9"></a>Shadow.hlsl<br />
<div class="outline-text-9" id="text-org4e8c2a9">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Shadow.hlsl</span>
CBUFFER_START(<span style="color: #7590db;">_CustomShadows</span>)
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">_CascadeCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_CascadeCullingSpheres</span>[MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_CascadeData</span>[MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> <span style="color: #7590db;">_DirectionalShadowMatrices</span>[MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT*MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> <span style="color: #7590db;">_OtherShadowMatrices</span>[MAX_SHADOWED_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherShadowTiles</span>[MAX_SHADOWED_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ShadowDistanceFade</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ShadowAtlasSize</span>;
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="orgf74db6e"></a>Light.hlsl<br />
<div class="outline-text-9" id="text-orgf74db6e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Light.hlsl</span>
CBUFFER_START(<span style="color: #7590db;">_CustomLight</span>)
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DirectionalLightCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightColors</span>[MAX_DIRECTIONAL_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightDirectionsAndMasks</span>[MAX_DIRECTIONAL_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightShadowData</span>[MAX_DIRECTIONAL_LIGHT_COUNT];

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">_OtherLightCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightColors</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightPositions</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightDirectionsAndMasks</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightSpotAngles</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightShadowData</span>[MAX_OTHER_LIGHT_COUNT];
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="org9f3037c"></a>参考资料<br />
<div class="outline-text-9" id="text-org9f3037c">
<ul class="org-ul">
<li>SRPBatcher Doc <a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a><br /></li>
<li>SRPBatcher 加速渲染 <a href="https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran">https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran</a><br /></li>
<li>从 DX 角度看 SRPBatcher <a href="https://zhuanlan.zhihu.com/p/508206639">https://zhuanlan.zhihu.com/p/508206639</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org78db6e6"></a>GPU Instancing<br />
<ul class="org-ul">
<li><a id="org414c432"></a>MaterialPropertyBlock 实现多个物体使用同一个材质，而拥有不同材质属性<br />
<div class="outline-text-9" id="text-org414c432">
<p>
<a href="#orge95aaf2">Mixing Material Properties</a><br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">PerObjectMaterialProperties.cs</span>
  <span style="color: #4f97d7; font-weight: bold;">using</span> UnityEngine;
  [<span style="color: #7590db;">DisallowMultipleComponent</span>]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> PerObjectMaterialProperties : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">baseColorId</span> = Shader.<span style="color: #bc6ec5; font-weight: bold;">PropertyToID</span>(<span style="color: #2d9574;">"_BaseColor"</span>);
      [<span style="color: #7590db;">SerializeField</span>]
      Color baseColor = Color.white;
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span> <span style="color: #7590db;">block</span>;

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Awake</span>()
      {
          <span style="color: #bc6ec5; font-weight: bold;">OnValidate</span>();
      }

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnValidate</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">if</span>(block==<span style="color: #a45bad;">null</span>)
          {
              block = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span>();
          }
          block.<span style="color: #bc6ec5; font-weight: bold;">SetColor</span>(baseColorId, baseColor);
          <span style="color: #bc6ec5; font-weight: bold;">GetComponent</span>&lt;<span style="color: #ce537a; font-weight: bold;">Renderer</span>&gt;().<span style="color: #bc6ec5; font-weight: bold;">SetPropertyBlock</span>(block);
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="orgd1a182c"></a>GPU Instancing<br />
<div class="outline-text-9" id="text-orgd1a182c">
<p>
GPU instancing 适用于每个物体具有不同材质属性的情况。其只需要为多个物体发布一个 draw call，但是这些物体必须使用相同的 mesh。CPU 会收集每个物体的变换矩阵和材质属性，并将他们放到一个数组中，然后发送给 GPU，GPU 按照数据被提供的顺序遍历进行渲染。<br />
</p>

<p>
注意：GPU instancing 多个物体必须是相同的材质实体。不同的材质实体，就算材质属性完全相同也不能合批。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#29992;&#20110;&#24320;&#21551;GPU Instancing</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile_instancing
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgd0a0005"></a>Dynamic Batching<br />
<div class="outline-text-8" id="text-orgd0a0005">
<p>
Dynamic Batching 会将多个共享相同材质的小 mesh 合并为一个大 mesh（Sphere 的 Mesh 比较大，不支持 DynamicBatching，Cube 支持）。该方法不支持每个物体具有不同材质属性的情况。<br />
通常 GPU Instancing 要比 Dynamic Batching 要更好。Dynamic Batching 会有一些陷阱，例如当物体的 scale 不同时，合成的大 mesh 的 normal 向量不保证是归一化的。<br />
</p>

<p>
事先被标记为 Batching-Static 的物体会执行 Static Batching，其和 Dynamic Batching 工作方式类似，除了需要更多的内存和存储空间外，其没有其他陷阱。<br />
</p>

<p>
按照下面方式开启 Dynamic Batching:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">drawingSettings</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">DrawingSettings</span>(unlitShaderTagId, sortingSettings)
  {
      enableDynamicBatching = <span style="color: #a45bad;">true</span>,
      enableInstancing = <span style="color: #a45bad;">false</span>
  };
</pre>
</div>
</div>
</li>
<li><a id="orga561059"></a>Batching Compare<br />
<div class="outline-text-8" id="text-orga561059">
<ul class="org-ul">
<li>Static Batching <a href="#org90881c7">Baching 简介</a><br /></li>
<li>Dynamic Batching <a href="#org90881c7">Baching 简介</a><br /></li>
<li>GPU Instancing <a href="#org90881c7">Baching 简介</a><br /></li>
<li>SRP Batching <a href="#org3d7d84e">Batching</a><br /></li>

<li>Draw call batching <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br /></li>
<li>Static Batching <a href="https://docs.unity3d.com/Documentation/Manual/static-batching.html">https://docs.unity3d.com/Documentation/Manual/static-batching.html</a><br /></li>
<li>Dynamic Batching <a href="https://docs.unity3d.com/Manual/dynamic-batching.html">https://docs.unity3d.com/Manual/dynamic-batching.html</a><br /></li>
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
<li>SRPBatcher <a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2f2eaa0"></a>Transparency<br /></li>
</ul>
</div>
<div id="outline-container-org7b90b15" class="outline-6">
<h6 id="org7b90b15">Directianl Lights</h6>
<div class="outline-text-6" id="text-org7b90b15">
</div>
<ul class="org-ul">
<li><a id="org1fd7a15"></a>Lighting<br />
<ul class="org-ul">
<li><a id="org6a4013c"></a>如何可视化光栅化对顶点 normal 线性插值后，normal 不再归一化？<br />
<div class="outline-text-8" id="text-org6a4013c">
<div class="org-src-container">
<pre class="src src-shader">base.rgb = <span style="color: #4f97d7;">abs</span>(<span style="color: #4f97d7;">length</span>(input.normalWS) - 1.0) * 10.0;
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgb047680"></a>BRDF<br />
<div class="outline-text-7" id="text-orgb047680">
<p>
Incoming Light : 光线方向和表面法线没有对齐时，表面接受到的入射光能量会变小。通过为入射光添加 N.L 系数可以实现该规律。<br />
Outgoing Light : 出射光线的分布有三种类型。完美镜面反射（Specular Reflection）、模糊反射（Glossy Reflection）、漫反射（Diffuse）<br />
由于表面光滑，Specular Reflection 会将入射光反射到同一个方向。<br />
由于微表面朝向不同，Glossy Reflection 会将入射光反射到偏离反射方向的方向上。<br />
光线进入物体后，Diffuse 会将入射光向各个方向等概率反射出来。<br />
</p>

<p>
表面对光的反射是各不相同的，通常金属会将光按照 Specular Reflection 全部反射，其没有 Diffuse。电介质(非金属)也会有 Specular Reflection，不同电介质反射不同，其平均值为 0.04。<br />
<a href="../theory/PhysicalTheory.html#org7f134f3">../theory/PhysicalTheory.html#org7f134f3</a><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org055af17" class="outline-6">
<h6 id="org055af17">Directional Shadows</h6>
<div class="outline-text-6" id="text-org055af17">
</div>
<ul class="org-ul">
<li><a id="org6941d64"></a>Rendering Shadows<br />
<div class="outline-text-7" id="text-org6941d64">
<p>
将 RT 分割为多个 Tile，设置 viewPort 来支持将多个方向光的阴影贴图画到同一个 RT 上。<br />
</p>
</div>
</li>
<li><a id="org522eeba"></a>Sampling Shadows<br />
<ul class="org-ul">
<li><a id="org8588781"></a>为什么要使用翻转的 ZBuffer（Reversed-ZBuffer）？<br />
<div class="outline-text-8" id="text-org8588781">
<p>
使用 0 表示深度为 0，使用 1 表示深度为最大，这样很直观。但是，反向 ZBuffer 再加上浮点型深度值可以增加深度位数的利用率，减少 ZFighting。具体原理如下文：<br />
</p>
<ul class="org-ul">
<li>反向 Z(Reversed-Z)的深度缓冲原理 <a href="https://zhuanlan.zhihu.com/p/75517534">https://zhuanlan.zhihu.com/p/75517534</a><br /></li>
</ul>
</div>
</li>
<li><a id="org796a5bc"></a>ConvertToAtlasMatrix 实现<br />
<div class="outline-text-8" id="text-org796a5bc">
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#25191;&#34892;&#23558;[-1,1]&#36716;&#21270;&#20026;[0, 1] &#32553;&#25918;0.5&#20877;&#20559;&#31227;0.5</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">    unity&#20351;&#29992;&#30340;&#21015;&#21521;&#37327;&#65292;&#30697;&#38453;&#38656;&#35201;&#24038;&#20056;</span>
<span style="color: #2aa1ae; background-color: #292e34;">    scaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0.5    0     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0    0.5     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0   0.5    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">    translateM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    1      0     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      1     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>
<span style="color: #2aa1ae; background-color: #292e34;">  */</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#25191;&#34892; atlas &#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">    atlasOffsetM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    1      0     0    offsetX</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      1     0    offsetY</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">    atlasScaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    scale  0     0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      scale 0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0     1</span>
<span style="color: #2aa1ae; background-color: #292e34;">  */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#26368;&#32456;&#32452;&#21512;&#20986;&#26469;&#30340;&#21464;&#25442;&#30697;&#38453;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">atlasScaleM * atlasOffsetM * translateM * scaleM * originM</span>
</pre>
</div>
<ul class="org-ul">
<li>行向量和列向量对比 <a href="../theory/ComputerGraphicMath.html#orgc0b8c77">../theory/ComputerGraphicMath.html#orgc0b8c77</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgb42a5cf"></a>Cascaded Shadow Maps<br />
<div class="outline-text-7" id="text-orgb42a5cf">
<p>
绘制方向光的阴影贴图时使用的是正交投影，因此阴影贴图上的一个图元对应了世界空间中固定大小的尺寸，如果该尺寸太大，会导致每个阴影贴图图元都占据多个像素，这会导致阴影边缘有锯齿，以及小的阴影会消失。该问题可以通过增加阴影贴图大小来缓解。<br />
当使用透视投影时，场景中越远的物体会变的越小。在某个可视距离阴影贴图上的一个图元只会对应显示器上的一个像素，这是理论上最优的。越靠近摄像机我们需要越高的阴影贴图分辨率，而远处的地方低分辨率的阴影贴图也足够了。理想的情况是，我们依据阴影接受者距离摄像机的距离，动态改变阴影贴图的精度。<br />
Cascaded Shadows maps 的理念是，将投摄阴影的物体渲染多次，这样每个光照在 atlas 上就对应了多个 Tile，这就被称为多个层级。第一个层级只会覆盖靠近摄像机的一小片区域，随后的层级会逐渐放大覆盖的区域。shader 中会采样最合适的层级。<br />
</p>

<p>
Unity 会创建一个 culling sphere 用于确定每个层级所覆盖的区域。阴影的投影矩阵为正交矩阵，视景体为长方体，其和 Culling Sphere 比较接近，但是还包含了 Sphere 周围的空间。因此 culling 区域外的阴影也可以被看到。光的方向和 Culling Sphere 是无关的（该 CullingSphere 和摄像机位置相关），因此所有的方向光使用相同的 culling spheres。<br />
</p>

<p>
这些 spheres 也用于确定，从哪个层级的阴影贴图进行采样。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga91187f"></a>Shadow Fade<br />
<div class="outline-text-8" id="text-orga91187f">
<p>
阴影渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_fade_shadow.jpg" alt="03_04ds_fade_shadow.jpg" /><br />
Cascade 渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_cascade_fade.jpg" alt="03_04ds_cascade_fade.jpg" /><br />
</p>
</div>
</li>
<li><a id="orge620622"></a>Shadow Quality<br />
<ul class="org-ul">
<li><a id="orgee5a6d9"></a>Depth Bias<br />
<div class="outline-text-9" id="text-orgee5a6d9">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-csharp">buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(50000f, 0f);
<span style="color: #bc6ec5; font-weight: bold;">ExcuteBuffer</span>();
context.<span style="color: #bc6ec5; font-weight: bold;">DrawShadows</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">shadowSettings</span>);
buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(0f, 0f);
</pre>
</div>
</div>
</li>
<li><a id="orgb78a6ad"></a>NormalBias<br />
<div class="outline-text-9" id="text-orgb78a6ad">
<p>
<del>不正确的自阴影是由于投影的深度贴图图元覆盖了多个片段</del> 不正确的自阴影是由于像素以其中心点对应的位置和阴影深度贴图图元对应的位置不一致导致的（即使提高阴影贴图精度，中心点的位置和深度贴图中的图元对应的位置也可能不重合），阴影深度贴图记录的深度为像素中心点旁边一点的深度，导致物体从其表面伸出来。因此如果将物体缩小足够大小，该问题将不会出现。但是，缩放投影体会导致阴影比原来要小。<br />
我们也可以从相反的方向来做：在采样阴影贴图时，将物体表面放大。这样我们就会采样远离表面一段距离的深度值，只要足够远就可以避免不正确的自阴影。这会稍微改变阴影的位置，可能会导致边缘的不对其以及错误的阴影，但是这点瑕疵比 Peter-Panning 要小很多。<br />
</p>
</div>
</li>
<li><a id="org101210c"></a>Shadow Pancaking<br />
<div class="outline-text-9" id="text-org101210c">
<p>
在为一个方向光渲染阴影投射体时，应该尽量将摄像机近平面往前移，这样可以增加深度精度，但是，这意味着投影体可能会不再摄像机视野内，其可能在近平面之前，这会导致该物体被裁剪，而其本不该被裁剪。<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_01.png" alt="03_04ds_shadow_error_01.png" /><br />
通过下面代码可以处理该问题：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  Varyings <span style="color: #bc6ec5; font-weight: bold;">ShadowCasterPassVertex</span>(Attributes input)
  {
      Varyings output;
      UNITY_SETUP_INSTANCE_ID(input);
      UNITY_TRANSFER_INSTANCE_ID(input, output);
      <span style="color: #ce537a; font-weight: bold;">float3</span> positionWS = TransformObjectToWorld(input.positionOS);
      <span style="color: #2aa1ae; background-color: #292e34;">// Transform World to Homogeneous Clip</span>
      output.positionCS = TransformWorldToHClip(positionWS);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#28210;&#26579;&#26041;&#21521;&#20809;&#20351;&#29992;&#30340;&#26159;&#27491;&#20132;&#25237;&#24433;, &#23558;&#36817;&#24179;&#38754;&#21069;&#30340;&#29289;&#20307;&#31227;&#21040;&#36817;&#24179;&#38754;</span>
<span style="color: #bc6ec5;">      #if</span> UNITY_REVERSED_Z
      output.positionCS.z = <span style="color: #4f97d7;">min</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">      #else</span>
      output.positionCS.z = <span style="color: #4f97d7;">max</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, <span style="color: #7590db;">_BaseMap_ST</span>);
      output.baseUV = input.baseUV * baseST.xy + baseST.zw;
      <span style="color: #4f97d7; font-weight: bold;">return</span> output;
  }
</pre>
</div>

<p>
上面的处理方式会导致新的问题，因为对于横穿近平面的物体，其只有部分顶点的数据是正确的，如果物体很大，其阴影会变形。下图展示了这种错误：<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_02.png" alt="03_04ds_shadow_error_02.png" /><br />
</p>

<p>
该问题可以通过支持 light 的 shadowNearPlane 来避免。也可以将大物体划分为小物体。<br />
</p>
<ul class="org-ul">
<li>Shadow pancaking <a href="https://docs.unity3d.com/Manual/ShadowPerformance.html">https://docs.unity3d.com/Manual/ShadowPerformance.html</a><br /></li>
</ul>
</div>
</li>

<li><a id="orge1d7e76"></a>PCF Shadow<br />
<div class="outline-text-9" id="text-orge1d7e76">
<p>
扩大采样区域后会导致 Shadow Acne 再次出现。需要对应增加 normal biase。<br />
扩大采样区域后意味着，我们可以采样到 cascade culling sphere 外面的区域。通过减小 culling sphere 半径来避免该问题。<br />
</p>
</div>
</li>

<li><a id="org09c39ac"></a>Blending Cascades<br />
<div class="outline-text-9" id="text-org09c39ac">

<div id="orga780d4e" class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_blend_cascade_shadow.png" alt="03_04ds_blend_cascade_shadow.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="org1ae2c23"></a>Culling Bias<br />
<div class="outline-text-9" id="text-org1ae2c23">
<p>
使用 Cascaded Shadow Maps 的一个缺点是，对于每个灯光，我们需要渲染相同的投影体多次。如果可以为高层级的 Cascade 剔除一些阴影投射体，并保证其内容总是被低层级的 Cascade 所覆盖，则会节省很多 DrawCall。如下参数可以实现该功能：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">splitData.shadowCascadeBlendCullingFactor = 1f;
</pre>
</div>


<div id="org8b76a00" class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_culling_for_large_cascade.png" alt="03_04ds_culling_for_large_cascade.png" /><br />
</p>
</div>

<p>
shadowCascadeBlendCullingFactor 会被用于和 culling sphere 半径相乘，其值必须为(0,1)范围，值越大，Unity 会剔除越多的物体，值越低，多层级之间共享的渲染对象越多。使用比较低的值，就可以让不同层级之间在重叠区域做混合。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html">https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgbbf550a"></a>Transparency<br /></li>
<li><a id="org4adac98"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org8f2ca8b"></a>FrameDebug 中有无限多个<br />
<div class="outline-text-8" id="text-org8f2ca8b">
<p>
CommandBuffer.BeginSample 和 CommandBuffer.EndSample 数量不对称会导致该问题。<br />
</p>
</div>
</li>
<li><a id="orgcc57b81"></a>ERROR: Dimensions of color surface does not match dimensions of depth surface<br />
<div class="outline-text-8" id="text-orgcc57b81">
<p>
CameraRenderer.cs 文件中 Render 函数内，先执行 Setup 后执行 lighting.Setup 就会出现该问题。因为 lighting.Setup 执行后，RT 没有切换回摄像机 RT，从 FrameDebug 可以看出该问题。<br />
<img src="./UnityCatLikeCoding/03_04ds_rt_error.jpg" alt="03_04ds_rt_error.jpg" /><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-org4ef3ff2" class="outline-6">
<h6 id="org4ef3ff2">Baked Light</h6>
<div class="outline-text-6" id="text-org4ef3ff2">
</div>
<ul class="org-ul">
<li><a id="org0b328f3"></a>Baking Static Light<br />
<div class="outline-text-7" id="text-org0b328f3">
<p>
光照可以被提前计算，然后将结果保存到光照贴图和 light probes 中。这种方式，有一个好处是，可以添加无法实时计算的间接光照效果。这种间接光照属于全局照明的一部分，间接光照不是直接从光源发出的光照，其为从环境或者发光表面经过间接反射照亮物体的光。<br />
</p>

<p>
Fully-Baked Light（Light 组件的 Mode 选择 Baked，Lighting Setting 的 LightingMode 选择 BakedIndirect） 会将直接光照和间接光照都烘培到光照贴图。<br />
</p>

<p>
环境间接光照 Intensity Multiplier 设置为 0 和 1 的对比：<br />
<img src="./UnityCatLikeCoding/03_05bl_env_indirect_light.png" alt="03_05bl_env_indirect_light.png" /><br />
</p>
</div>
</li>
<li><a id="org4c3d017"></a>GPU Instancing 和烘培<br />
<div class="outline-text-7" id="text-org4c3d017">
<p>
理论上来说，可以使用 TextureArray，让静态烘培物体 lightmap 不同时，依然可以 GPU Instancing。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge5574e5" class="outline-6">
<h6 id="orge5574e5">Shadow Masks</h6>
<div class="outline-text-6" id="text-orge5574e5">
<p>
Unity 也会将 ShadowMask 数据烘培到 LightProbes 中，通过如下方式可以采样 LightProbes 中的 ShadowMask 数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">SampleBakedShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightMapUV, Surface surfaceWS)
  {
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SAMPLE_TEXTURE2D</span>(unity_ShadowMask, samplerunity_ShadowMask, lightMapUV);
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x)
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SampleProbeOcclusion</span>(
              TEXTURE3D_ARGS(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH),
              surfaceWS.position, unity_ProbeVolumeWorldToObject,
              unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z,
              unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz
          );
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> unity_ProbesOcclusion;
      }
<span style="color: #bc6ec5;">      #endif</span>
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org210f3e3" class="outline-6">
<h6 id="org210f3e3">LOD and Reflections</h6>
</div>
<div id="outline-container-org179ab68" class="outline-6">
<h6 id="org179ab68">Complex Maps</h6>
<div class="outline-text-6" id="text-org179ab68">
</div>
<ul class="org-ul">
<li><a id="orge18020f"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org1288003"></a>贴图设置中的 FadeOut Mip Maps 属性是做什么用的？<br />
<div class="outline-text-8" id="text-org1288003">
<p>
FadeOut Mip Maps 主要用于避免远处 DetailMap 有明显的 tiling 模式。<br />
</p>

<ul class="org-ul">
<li>FadeOut Mip Maps <a href="https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/">https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgccfcfba" class="outline-6">
<h6 id="orgccfcfba">Point and Spot Lights</h6>
<div class="outline-text-6" id="text-orgccfcfba">
</div>
<ul class="org-ul">
<li><a id="orgaaf57d9"></a>Lights Per Object<br />
<div class="outline-text-7" id="text-orgaaf57d9">
<p>
Unity 确定每个物体会由哪些光照所影响，并将该信息发送给 GPU。这样在渲染每个物体时，只需要计算影响该物体的光照，而忽略不影响该物体的光照。这种方案对于很多小物体组成的场景来说是很适用的，而对于大物体来说则不适用，因为如果光照只影响大物体的一小部分区域，在渲染该大物体时，依然需要对其整个表面执行光照计算。<br />
</p>

<p>
需要注意的是，当开启 LightsPerObject 后，GPU instancing 可能会失效，因为只有受光照印象数量相同，并且索引列表匹配的物体才会被分为一组。SRP batcher 则不受影响。<br />
</p>
</div>
</li>
<li><a id="org4bd3c78"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="orgf8fe847"></a><span class="todo TODO">TODO</span> 灯光的位置、方向为什么可以通过 localToWorldMatrix 矩阵获取？<br />
<div class="outline-text-8" id="text-orgf8fe847">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">spot light</span>
<span style="color: #ce537a; font-weight: bold;">Vector4</span> <span style="color: #7590db;">position</span> = visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(3);
otherLightDirections[index] = -visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(2);
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-orgb1d1fd1" class="outline-6">
<h6 id="orgb1d1fd1">Point and Spot Shadows</h6>
<div class="outline-text-6" id="text-orgb1d1fd1">
</div>
<ul class="org-ul">
<li><a id="orgeb9638a"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org0c80873"></a><span class="todo TODO">TODO</span> 解决 Spot Light Shadow Acne 问题的原理？<br /></li>
<li><a id="orgedc9665"></a>Unity 渲染 Point Light 阴影时会从上往下渲染，导致渲染的物体为背面，如何转化为正面渲染物体？<br />
<div class="outline-text-8" id="text-orgedc9665">
<div class="org-src-container">
<pre class="src src-csharp">cullingResults.<span style="color: #bc6ec5; font-weight: bold;">ComputePointShadowMatricesAndCullingPrimitives</span>(
                light.<span style="color: #ce537a; font-weight: bold;">visibleLightIndex</span>, (<span style="color: #ce537a; font-weight: bold;">CubemapFace</span>)i, fovBias*0,
                <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">viewMatrix</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">projectionMatrix</span>,
                <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">ShadowSplitData</span> <span style="color: #7590db;">splitData</span>
            );
viewMatrix.m11 = -viewMatrix.m11;
viewMatrix.m12 = -viewMatrix.m12;
viewMatrix.m13 = -viewMatrix.m13;
</pre>
</div>
</div>
</li>
<li><a id="org406d186"></a>Fov Bias 如何求解？<br />
<div class="outline-text-8" id="text-org406d186">
<p>
Fov Bias 计算原理如下：<br />
<img src="./UnityCatLikeCoding/03_10pss_point_light_fovBias.png" alt="03_10pss_point_light_fovBias.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">fovBias</span> = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Atan</span>(1f + bias + filterSize) * Mathf.Rad2Deg * 2f - 90f;
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org6681e28" class="outline-6">
<h6 id="org6681e28">Post Processing</h6>
<div class="outline-text-6" id="text-org6681e28">
</div>
<ul class="org-ul">
<li><a id="org0a3177e"></a>CommandBuffer.DrawProcedural<br />
<div class="outline-text-7" id="text-org0a3177e">
<p>
CommandBuffer.DrawProcedural 该函数会在 GPU 上执行一个 DrawCall，但是没有任何 vertex 或 index buffer。通常在 vertex shader 中，通过使用 SV_VertexID 和 SV_InstanceID 来从某些 buffer 中获取数据。<br />
SV_VertexID 为顶点编号。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="org2dc5045"></a>使用双线性过滤优化高斯模糊的原理是什么？<br />
<div class="outline-text-7" id="text-org2dc5045">
<p>
GPU 对贴图的双线性过滤通过硬件实现，性能非常高。使用双线性过滤，一次采样可以获得 4 个样本点的值，利用 GPU 的双线性过滤，通过对采样点位置进行调整可以实现和高斯 Filter 等价的权重。<br />
</p>

<ul class="org-ul">
<li>基于线性采样的高效高斯模糊实现 cn <a href="https://zhuanlan.zhihu.com/p/58182228">https://zhuanlan.zhihu.com/p/58182228</a><br /></li>
<li>基于线性采样的高效高斯模糊实现 en <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a><br /></li>
<li>高斯模糊的几种优化方法 <a href="https://cloud.tencent.com/developer/article/1035559">https://cloud.tencent.com/developer/article/1035559</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org043b616" class="outline-6">
<h6 id="org043b616">HDR</h6>
<div class="outline-text-6" id="text-org043b616">
</div>
<ul class="org-ul">
<li><a id="orgb6f6e97"></a>High Dynamic Range<br />
<ul class="org-ul">
<li><a id="org3dc9ee5"></a>HDR Post Processing<br />
<div class="outline-text-8" id="text-org3dc9ee5">
<p>
HDR 和 LDR bloom 的区别可能是非常大，也可能非常小，这取决于场景的亮度。通常 bloom 的 threshold 被设置为 1，因此只有 HDR 颜色会对 bloom 效果产生贡献。这样画面上闪耀的颜色表示其对于显示器来说太亮了。<br />
因为 bloom 效果的原理是平均颜色，因此即使一个非常亮的像素最终可能影响一大片区域。例如，当 2x2 块的颜色值分别为 0,0,0,1 时，由于 downsampling 的平均，最终的颜色值为 0.25。但是如果是 HDR 版本的平均 0,0,0 和 10，则最终的颜色值为 2.5。<br />
</p>
</div>
</li>
<li><a id="org6f4a288"></a>Fighting Fireflies<br />
<div class="outline-text-8" id="text-org6f4a288">
<p>
HDR 的一个缺点是，其会导致图片上一小片区域的亮度比其周围大很多。当这些区域的大小为一个像素或者更小时，其可以极大地改变相对大小，并在运动过程中突然出现或消失，这会导致闪烁。这些区域被称为萤火虫。当应用 bloom 时，这些区域会出现频闪。<br />
完全消除该问题需要无限大的分辨率，这是不可能的。我们可以在 Pre-Filtering 阶段更激进地对图片进行模糊，将 fireflies 淡出。<br />
在 PreFiltering 阶段，对周围 9 个像素点进行采样，每个采样点的颜色按照 1/(l+1)分配权重，l为该颜色的亮度(luminance)。其原理如下图所示：<br />
</p>


<div id="org9fb7bef" class="figure">
<p><img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies.png" alt="03_11hdr_bloom_fireflies.png" /><br />
</p>
</div>

<p>
因为在 Pre-Filtering 后会执行 GaussianBlur，因此前面对 9 个像素的采样可以优化为对 5 个像素的采样：<br />
<img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies02.png" alt="03_11hdr_bloom_fireflies02.png" /><br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org9cb0816"></a>Scattering Bloom<br />
<div class="outline-text-7" id="text-org9cb0816">
<p>
摄像机不是完美的，其镜头无法正确聚焦所有的光。一部分光会散射到更大的区域，就如目前我们实现的 bloom 效果一样。越好的摄像机会散射越少的光。摄像机镜头对光的散射和目前实现的 additive bloom 效果的最大区别为，摄像机镜头对光的散射不会增加光照，其只会将光照 diffuse 化。人眼也不是完美的，进入人眼的光也会被散射。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org820453a"></a>Bloom 流程<br />
<div class="outline-text-8" id="text-org820453a">
<p>
下图为迭代三次的 Boom 流程图：<br />
<img src="./UnityCatLikeCoding/03_11pp_bloom.png" alt="03_11pp_bloom.png" /><br />
</p>

<p>
Pre-FilterPass 中将大于 Threshold 的颜色筛选出来。<br />
BlurHorizontalPass BlurVerticalPass 对上一步筛选出来的像素进行高斯模糊，BlurHorizontalPass 还执行 Downsampling 操作。<br />
CombinePass 将模糊后的和模糊前的图片进行合并。<br />
</p>
</div>
</li>
<li><a id="org80045f1"></a>Scatter Limits<br />
<div class="outline-text-8" id="text-org80045f1">
<p>
在 BloomSettings 中添加 scatter 变量来控制被散射的光的量。当 scatter=0，表示完全不散射。当 scatter=1，表示完全散射。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomCombineScatterPassFragment</span>(Varyings input) : SV_TARGET
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>)
      {
          lowRes = GetSourceBicubic(input.fxUV).rgb;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          lowRes = GetSource(input.fxUV).rgb;
      }
      <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// scatter = 0 &#21017;&#19981;&#25955;&#23556; scatter=1&#21017;&#23436;&#20840;&#25955;&#23556;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
  }
</pre>
</div>
</div>
</li>
<li><a id="org570d0f7"></a>Threshold<br />
<div class="outline-text-8" id="text-org570d0f7">
<p>
Scattering Bloom 在最终 Combine 阶段需要对 lowRes 进行补偿，因为 lowRes 中只包含了需要 Bloom 的部分(即超过 Threshold 值的颜色)。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomScatterFinalPassFragment</span> (Varyings input) : SV_TARGET {
      <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>) {
          lowRes = GetSourceBicubic(input.fxUV).rgb;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span> {
          lowRes = GetSource(input.fxUV).rgb;
      }
      <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23545;lowRes&#36827;&#34892;&#34917;&#20607;</span>
      lowRes += highRes - ApplyBloomThreshold(highRes);
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
  }
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org2af6d52"></a>Tone Mapping<br />
<div class="outline-text-7" id="text-org2af6d52">
<p>
尽管我们可以在 HDR 模式下进行渲染，但是对于常规的摄像机，其最终的 frameBuffer 总是 LDR 格式的。这使得颜色通道被裁剪为 1，实际上最终图片上的白点的值为 1。特别亮的颜色最终和完全饱和的颜色看起来是没有差别的。下图的场景中，包含了多个等级的光照，以及多个发光的物体。其中最强的发光体的亮度为 8，最亮的光源光照强度为 200.<br />
</p>

<p>
<img src="./UnityCatLikeCoding/03_11pp_non_fx_001.png" alt="03_11pp_non_fx_001.png" /><br />
没有使用后期效果，很难看出那个物体或者那个光源是亮度最强的。下图为使用了 Bloom 后期特效后的效果：<br />
<img src="./UnityCatLikeCoding/03_11pp_use_fx_001.png" alt="03_11pp_use_fx_001.png" /><br />
上图中发光的物体明显是比较亮的，但是依然无法确定其相对于场景中剩余物体有多亮。调整图片的亮度使得最亮的颜色不要超过 1，这样就可以确定物体之间的相对亮度关系了。我们可以统一将整个图片变暗，但是这会导致图片中的大部分颜色变得太暗，以至于无法清晰看到。理想的情况是，我们对于很亮的颜色调节很多，而对于暗的颜色调节很少。因此，我们需要非统一的颜色调节方案。这样的颜色调节并不是光源自身的物理属性改变，而是光源被人感知的变化。例如，我们的眼睛对于暗的色调比亮的色调更加敏感。<br />
</p>

<p>
将 HDR 转换为 LDR 的操作被称为 Tone Mapping，其源于摄影和电影的发展。传统的照片和电影也是只具有有限的亮度范围，以及非统一的光照敏感度，因此很多技术被开发出来用于执行 ToneMapping。没有唯一正确的 ToneMapping。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2056233"></a>Reinhard<br />
<div class="outline-text-8" id="text-org2056233">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ToneMappingReinhardPassFragment</span> (Varyings input) : SV_TARGET
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> color = GetSource(input.fxUV);
      color.rgb /= color.rgb + 1.0;
      <span style="color: #4f97d7; font-weight: bold;">return</span> color;
  }
</pre>
</div>
</div>
</li>
<li><a id="orga441d34"></a>Neutral<br />
<div class="outline-text-8" id="text-orga441d34">
<p>
Reinhard tone mapping 的 white point 理论上为无穷大。下图中对 Reinhard Tone Mapping 进行改进，可以支持配置 white point 的值。<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_reinhard01.png" alt="03_11pp_tonemapping_reinhard01.png" /><br />
下图为 Uncharted2 中使用的 ToneMapping：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_uncharted2.png" alt="03_11pp_tonemapping_uncharted2.png" /><br />
下图为 Unity 中的 NeutralToneMap：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_neutral.png" alt="03_11pp_tonemapping_neutral.png" /><br />
</p>
</div>
</li>
<li><a id="orgd924ded"></a>ACES<br />
<div class="outline-text-8" id="text-orgd924ded">
<p>
ACES Tonemapping 和其他模式的最大区别在于，ACES 对于特别亮的颜色会执行色域偏移，将其推向白色。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orged98a5d" class="outline-6">
<h6 id="orged98a5d">Color Grading</h6>
<div class="outline-text-6" id="text-orged98a5d">
</div>
<ul class="org-ul">
<li><a id="orgecd7ed0"></a>Color Adjustments<br />
<div class="outline-text-7" id="text-orgecd7ed0">
<p>
粗略来算，调节视频、照片和数字图片的颜色分三个步骤:<br />
首先是颜色矫正(color correction)，其目的是为了让图像匹配我们所观察到的场景，以补偿媒介的局限性。<br />
其次是色彩分级(color grading)，其为了得到期望的外观和感觉，这种结果和原始场景不匹配，而且也不需要逼真。这两个步骤通常被合并到同一个 color grading 步骤中。<br />
最后是色调映射(tone Mapping)，其将 HDR 颜色映射到显示器的显示范围。<br />
</p>

<p>
对图像只使用 tone mapping，会让图像趋向更加缺乏色彩，除非图像非常明亮。ACES 稍微增加了暗颜色的对比，但是其无法代替 color grading。<br />
</p>

<p>
davinciresolve 是专业的影视后期调色工具, 下面链接中有后期调色相关的教学视频：<br />
</p>
<ul class="org-ul">
<li><a href="http://www.blackmagicdesign.com/sg/products/davinciresolve/training">http://www.blackmagicdesign.com/sg/products/davinciresolve/training</a><br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org3c443be"></a>Post Exposure<br />
<div class="outline-text-8" id="text-org3c443be">
<p>
Post Exposure 用于模拟摄像机的曝光，但是其被用于其他后期效果之后，并在其他 color grading 效果之前。其是一个非真实感的美术工具，可用于微调曝光而不影响其他效果，例如 bloom。<br />
</p>
</div>
</li>
<li><a id="orgbb54d00"></a>Constrast Saturate<br />
<div class="outline-text-8" id="text-orgbb54d00">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradingContrast</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color) {
      color = LinearToLogC(color);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#33410;&#23545;&#27604;&#24230;&#30340;&#31639;&#27861;</span>
      color = (color - ACEScc_MIDGRAY) * <span style="color: #7590db;">_ColorAdjustments</span>.y + ACEScc_MIDGRAY;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">LogCToLinear</span>(color);
  }

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeSaturation</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> color)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> luminance = Luminance(color);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#33410;&#39281;&#21644;&#24230;&#30340;&#31639;&#27861;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> (color - luminance) * <span style="color: #7590db;">_ColorAdjustments</span>.w + luminance;
  }
</pre>
</div>

<p>
调节对比度和饱和度的公式类似，saturate 为直线的斜率，saturate 的范围为(0-2)，(1-saturate)*luminance 为直线 y 轴截距。<br />
saturate 为 0 时，最终颜色为 luminance，最终颜色只有明暗没有色彩。<br />
saturate 为 1 时，最终颜色为 color，饱和度和明度都没有变化。<br />
saturate 为 2 时，最终颜色为 color*2 - luminance，最终颜色的明度没有改变，色彩值翻倍。<br />
<img src="./UnityCatLikeCoding/03_12cg_saturate.png" alt="03_12cg_saturate.png" /><br />
<a href="./UnityCatLikeCoding/03_12cg_saturate.ggb">./UnityCatLikeCoding/03_12cg_saturate.ggb</a><br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</li>
<li><a id="org8d0adba"></a>Color Filter<br />
<div class="outline-text-8" id="text-org8d0adba">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeColorFilter</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// ColorFilter &#30340;&#31639;&#27861;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> color * <span style="color: #7590db;">_ColorFilter</span>.rgb;
  }
</pre>
</div>
</div>
</li>
<li><a id="org99e3839"></a>Hue Shift<br /></li>
<li><a id="org0aadfc4"></a>White Balance<br />
<div class="outline-text-8" id="text-org0aadfc4">
<p>
白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；<br />
白平衡本质上是调节两个参数：色温和色调，色温调节蓝-黄偏色，色调调节绿-品红偏色。通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换；<br />
</p>

<ul class="org-ul">
<li><a href="./PhysicallyBasedRendering.html#org39d7d9e">白平衡原理</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/27165715">https://zhuanlan.zhihu.com/p/27165715</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgf88f3fc"></a>Split Toning<br />
<div class="outline-text-8" id="text-orgf88f3fc">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="orgc816795"></a>Channel Mixer<br />
<div class="outline-text-8" id="text-orgc816795">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="org593afb0"></a>Shadows Midtones Highlights<br />
<div class="outline-text-8" id="text-org593afb0">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="orgd2956d2"></a>ACES Color Spaces<br />
<div class="outline-text-8" id="text-orgd2956d2">
<p>
Academy Color Encoding System(ACES)是在电影艺术与科学学院的支持下创建的彩色图像编码系统。 ACES 的特点是色彩准确的工作流程，“无论来源如何，都能无缝交换高质量的电影图像”。ACES 主要有下图所示的 3 个流程组成：<br />
<img src="./UnityCatLikeCoding/aces-simplified.jpg" alt="aces-simplified.jpg" /><br />
</p>
<ul class="org-ul">
<li>A: IDT 用于将导入的贴图、图片和渲染结果转化为 ACEScg colorspace<br /></li>
<li>B: ACEScg 为渲染和工作空间(VFX 和 CG 在该颜色空间下进行)<br /></li>
<li>C: RRT(Rendering Reference Transform)+ODT(Output Device Transform) 为 Output Transform。RRT 负责把图像从 scene-referred 空间转换到 high dynamic range output-referred 空间，而 ODT 负责继续把 RRT 的结果转换到特定的输出设备的颜色空间下。RRT + ODT 是一次把 scene-referred 图像完整地呈现到特定显示设备的转换操作<br /></li>
</ul>

<p>
ACES Primary and White Point Coordinates<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">AP0:ACES 2065-1</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">white point</th>
<th scope="col" class="org-right">AP1:cg,cc,cct,proxy</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">red</td>
<td class="org-right">green</td>
<td class="org-right">blue</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">red</td>
<td class="org-right">green</td>
<td class="org-right">blue</td>
</tr>

<tr>
<td class="org-left">x</td>
<td class="org-right">0.7347</td>
<td class="org-right">0.0000</td>
<td class="org-right">0.0001</td>
<td class="org-right">0.32168</td>
<td class="org-right">0.713</td>
<td class="org-right">0.165</td>
<td class="org-right">0.128</td>
</tr>

<tr>
<td class="org-left">y</td>
<td class="org-right">0.2653</td>
<td class="org-right">1.0000</td>
<td class="org-right">-0.0770</td>
<td class="org-right">0.33767</td>
<td class="org-right">0.293</td>
<td class="org-right">0.830</td>
<td class="org-right">0.044</td>
</tr>
</tbody>
</table>


<div id="org41760b4" class="figure">
<p><img src="./UnityCatLikeCoding/aces-color-space-chromaticity-diagram.jpg" alt="aces-color-space-chromaticity-diagram.jpg" /><br />
</p>
</div>

<p>
当使用 ACES tone mapping 时，为了得到更好的结果，Unity 在 ACES 颜色空间下执行大多数 color grading。<br />
Post exposure 和 white balance 总是在线性空间下被应用。从 Constrast 开始，将 linear color 转化为 ACEScc 颜色空间。<br />
</p>

<p>
unity_to_ACES  可以从 linear color 转化为 ACES 颜色空间<br />
ACES_to_ACEScc 可以从 ACES 转化为 ACEScc 颜色空间<br />
ACEScc_to_ACES 可以从 ACEScc 颜色空间转化为 ACES 颜色空间<br />
ACES_to_ACEScg 可以从 ACES 颜色空间转化为 ACEScg 颜色空间<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgcd9d1d9"></a>ACES2065-1<br />
<div class="outline-text-9" id="text-orgcd9d1d9">
<p>
ACES2065-1 是 ACES 色彩空间的核心，也是唯一使用 AP0 RGB 原色的色彩空间。它使用光度线性传输特性（photo-metrically linear transfer characteristics），即 伽马值为 1.0，并且是唯一用于设施之间交换的 ACES 空间，对于存档图像/视频文件非常重要。<br />
</p>

<p>
ACES2065-1 的代码值是线性值，在输入变换中被缩放，因此：<br />
</p>
<ul class="org-ul">
<li>一个完美的白色漫射器将映射为 (1, 1, 1) RGB 代码值。<br /></li>
<li>18% 灰卡的照片曝光将映射为  (0.18,0.18,0.18) RGB 代码值。<br /></li>
</ul>
<p>
对于普通场景，ACES2065-1 代码值经常超过 1.0 ，编码时可以保持非常高范围的镜面反射和高光。 ACES2065-1 代码值的内部处理和存储必须采用每通道至少 16 位的浮点运算。 ACES 的 Pre-release 版本（即 1.0 之前的版本）将 ACES2065-1 定义为唯一的色彩空间。 因此，旧应用程序在提及“ACES 色彩空间”时可能会提及 ACES2065-1。 此外，由于其重要性和线性特性，并且是基于 AP0 原色的颜色空间，它也被错误地称为“Linear ACES”、“ACES.lin”、“SMPTE2065-1”甚至“AP0 色彩空间” ”。<br />
</p>

<p>
SMPTE ST2065-4 定义了 ACES2065-1 静态图像的正确编码，用于 OpenEXR 文件和文件序列以及元数据标志/字段。<br />
SMPTE 2065-5 定义了 ACES2065-1 视频序列编码，用于在 MXF 文件及其元数据字段。<br />
</p>
</div>
</li>
<li><a id="org42d577d"></a>ACEScg<br />
<div class="outline-text-9" id="text-org42d577d">
<p>
ACEScg(ACES computer graphics space)颜色空间定义略大于 ITU Rec.2020 颜色空间，并进行线性编码，以改进计算机图形渲染和合成工具中的使用。<br />
</p>

<p>
ACEScg 是一种场景线性编码，与 ACES2065-1 类似，但 ACEScg 使用 AP1 原色，更接近可感知的原色。ACEScg 是为视觉效果工作而开发的，由于 ACES2065-1 的原色中蓝色原色为负值，且原色在可感知色域之外，所以，ACES2065 显然不是一个可用的工作空间。<br />
</p>

<p>
AP1 原色更接近可感知颜色的色品图，而且它们都不是负值。 这对于根据视觉效果的需要渲染和合成图像数据非常重要。<br />
</p>
</div>
</li>
<li><a id="orgd0d88e5"></a>ACEScc &amp; ACEScct<br />
<div class="outline-text-9" id="text-orgd0d88e5">
<p>
ACEScc(ACES color correction space) 色彩空间定义略大于 ITU Rec.2020 色彩空间，并进行对数编码，以改进色彩校正器和分级工具中的使用。<br />
ACEScct（ACES color correction space with toe）色彩空间定义略大于 ITU Rec.2020 色彩空间，并进行对数编码，以改进在色彩校正器和分级工具中的使用，类似于 Cineon 文件的 toe behavior。<br />
</p>

<p>
与 ACEScg 一样，ACEScc 和 ACEScct 也使用 AP1 原色。 它们的与众不同之处在于，ACEScc 和 ACEScct 使用对数曲线，而不是场景线性传输编码，这使得它们更适合颜色分级。 分级工作流程传统上使用对数编码图像数据，很大程度上是因为电影摄影中使用的物理胶片对光具有对数响应。<br />
</p>

<p>
ACEScc 是一个纯对数函数，但 ACEScct 有一个接近黑色的 toe，用于模拟照相负片的最小密度，以及传统的 DPX 或 Cineon 对数曲线。<br />
</p>

<p>
ACEScc，是完全使用对数进行编码，你基本上可以把它理解成 ACES 的 log 模式，在实际调色时感觉也会非常像。而 ACEScct，则是将 log 曲线的下方末端抬起，形成了一个类似于脚趾的形状，使其更加类似于传统的『对数型』曲线，比如 LogC，S-Log 等。这一变化将使用户在进行 Lift（针对图像阴影区）操作时，会使阴影区有更明显的雾状化，从而与传统胶片扫描结果更为类似。<br />
<img src="./UnityCatLikeCoding/acescc-acescct.jpg" alt="acescc-acescct.jpg" /><br />
</p>

<ul class="org-ul">
<li>ACEScc 与 ACEScct 的区别 <a href="https://zhuanlan.zhihu.com/p/257103138">https://zhuanlan.zhihu.com/p/257103138</a><br /></li>
</ul>
</div>
</li>
<li><a id="orge07a21e"></a>ACESproxy<br />
<div class="outline-text-9" id="text-orge07a21e">
<p>
ACESproxy (ACES proxy color space) 色彩空间定义略大于 ITU Rec.2020 色彩空间，采用对数编码（如 ACEScc，而不是 ACEScct），并以 10 位/通道或 12 位/通道、整数算术数字表示形式表示。 此编码专门设计用于在不支持浮点算术编码的数字设备（例如 SDI 电缆、监视器和一般基础设施）之间仅传输代码值。<br />
</p>
</div>
</li>

<li><a id="orgccac658"></a>参考资料<br />
<div class="outline-text-9" id="text-orgccac658">
<ul class="org-ul">
<li><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/">https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/</a><br /></li>
<li>漫谈 HDR 和色彩管理（四）HDR 标准和 ACES <a href="https://zhuanlan.zhihu.com/p/144775352">https://zhuanlan.zhihu.com/p/144775352</a><br /></li>
<li>Academy Color Encoding System <a href="https://en.wikipedia.org/wiki/Academy_Color_Encoding_System">https://en.wikipedia.org/wiki/Academy_Color_Encoding_System</a><br /></li>
<li><a href="https://acescolorspace.com/">https://acescolorspace.com/</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orge3c5180"></a>LUT<br />
<div class="outline-text-7" id="text-orge3c5180">
<p>
为每个像素执行所有的 color grading 步骤需要很多工作量。我们可以定义一些变体，从而只应用对内容有修改的 color grading，但是这需要很多 Keywords 或 Passes。我们可以将 color grading 烘培到一个 loopup table(LUT)中，通过对该 LUT 进行采样来执行颜色转换。这样的 LUT 为一个 3D 贴图，通常大小为 32x32x32。填充该贴图，运行时对该贴图采样比直接对整张图片执行 color grading 计算要少很多工作量。<br />
</p>

<p>
LUT 记录的是任何一种颜色经过 ColorGrading 之后对应的颜色。<br />
</p>

<p>
LUT RT 可以为 LDR（PC Editor 下为 R8G8B8A8-UNorm），也可以为 HDR(PC Editor 下为 R16G16B16A16-SFloat)。<br />
LUT LDR RT 既支持 LDR 渲染，也支持 HDR 渲染。<br />
LUT HDR RT 只支持 HDR 渲染。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd25b6aa"></a>LUT Color Matrix<br />
<ul class="org-ul">
<li><a id="orga315af3"></a>LUT Texture 生成时，LUT 如何编码颜色？<br />
<div class="outline-text-9" id="text-orga315af3">
<p>
对于 2D 的 LUT，lutTexture 的 x 方向对应 R 和 B，y 方向对应 G。最终 LUT 整张图就对应了 (0,0,0) 到 (1,1,1) 的所有颜色<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Returns the default value for a given position on a 2D strip-format color lookup table</span>
<span style="color: #2aa1ae; background-color: #292e34;">// lut_height &#20026;LUT rt&#30340;ySize, &#21516;&#26102;LUT &#30340;&#26041;&#22359;&#25968;&#37327;&#20063;&#20026;&#35813;&#20540;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// params = (lut_height, 0.5 / lut_width, 0.5 / lut_height, lut_height / lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">GetLutStripValue</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float4</span> params)
{
    uv -= params.yz;
    real3 color;
    <span style="color: #2aa1ae; background-color: #292e34;">// uv.x[0,1] &#23545;&#24212;&#20102;lut_height &#20010;R[0-1], &#27599;&#20010;&#26041;&#22359;&#30340;x &#23545;&#24212;R[0,1]</span>
    color.r = <span style="color: #4f97d7;">frac</span>(uv.x * params.x);
    <span style="color: #2aa1ae; background-color: #292e34;">// uv.x[0,1] &#23545;&#24212;&#20102; lut_height &#20010; B[0-1], &#31532;&#19968;&#20010;&#26041;&#22359;&#23545;&#24212;B=0&#65292;&#26368;&#21518;&#19968;&#20010;&#26041;&#22359;&#23545;&#24212;B=1</span>
    color.b = uv.x - color.r / params.x;
    <span style="color: #2aa1ae; background-color: #292e34;">// uv.y[0,1] &#23545;&#24212;&#20102; G[0-1], &#27599;&#20010;&#26041;&#22359;&#30340; y &#23545;&#24212;G[0,1]</span>
    color.g = uv.y;
    <span style="color: #4f97d7; font-weight: bold;">return</span> color * params.w;
}
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgfc1fb3c"></a>Gen LUT<br />
<div class="outline-text-8" id="text-orgfc1fb3c">
<p>
LDR 渲染时，会始终使用 FragLutBuilderLdr 来生成 LUT。<br />
HDR 渲染时，URPA Grading Mode 设置为 LDR 则使用 FragLutBuilderLdr 来生成 LUT; URPA Grading Mode 设置为 HDR 则使用 FragLutBuilderHdr 来生成 LUT<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga2c3389"></a>LDR FragLutBuilderLdr<br />
<div class="outline-text-9" id="text-orga2c3389">
<p>
FragLutBuilderLdr 直接在 LDR 的线性颜色上开始工作。最终，输出时会将结果 clamp to [0, 1]<br />
Tips:<br />
FragLutBuilderLdr 不会执行 Tonemapping 操作。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">FragLutBuilderLdr</span>(Varyings input) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> colorLinear = GetLutStripValue(input.texcoord, <span style="color: #7590db;">_Lut_Params</span>);

    <span style="color: #2aa1ae; background-color: #292e34;">// White balance in LMS space</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Do contrast in log after white balance</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Color filter is just an unclipped multiplier</span>
    colorLinear *= <span style="color: #7590db;">_ColorFilter</span>.xyz;

    <span style="color: #2aa1ae; background-color: #292e34;">// Split toning &#20026;&#20102;&#19982; Adobe &#20135;&#21697;&#20013;&#19968;&#33268;&#37319;&#29992; GammaSpace</span>

    colorLinear = PositivePow(colorGamma, 2.2);

    <span style="color: #2aa1ae; background-color: #292e34;">// Channel mixing (Adobe style)</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Shadows, midtones, highlights</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Lift, gamma, gain</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// HSV operations</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Global saturation</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// YRGB curves</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">half4</span>(<span style="color: #4f97d7;">saturate</span>(colorLinear), 1.0);
}
</pre>
</div>
</div>
</li>
<li><a id="orgfa7b0d8"></a>HDR FragLutBuilderHdr<br />
<div class="outline-text-9" id="text-orgfa7b0d8">
<p>
FragLutBuilderHdr 会先利用 LogCToLinear 将 [0,1]的 LDR 颜色变化为[0, 52.7]的 HDR 颜色，在 HDR 的线性颜色上开始工作。<br />
</p>

<p>
没开启 HDROutput 时，FragLutBuilderHdr 会执行 Tonemapping 操作。<br />
开启 HDROutput 时，FragLutBuilderHdr 不会执行 Tonemapping 操作，会执行 ProcessColorForHDR。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">FragLutBuilderHdr</span>(Varyings input) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Lut space</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// We use Alexa LogC (El 1000) to store the LUT as it provides a good enough range</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// (~58.85666) and is good enough to be stored in fp16 without losing precision in the</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// darks</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> colorLutSpace = GetLutStripValue(input.texcoord, <span style="color: #7590db;">_Lut_Params</span>);

    <span style="color: #2aa1ae; background-color: #292e34;">// Color grade &amp; tonemap</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> gradedColor = ColorGrade(colorLutSpace);

<span style="color: #bc6ec5;">    #ifdef</span> HDR_COLORSPACE_CONVERSION      <span style="color: #2aa1ae; background-color: #292e34;">// &#22788;&#29702; HDROutput</span>
    gradedColor = ProcessColorForHDR(gradedColor);
<span style="color: #bc6ec5;">    #else</span>
    gradedColor = Tonemap(gradedColor);
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(gradedColor, 1.0);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGrade</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> colorLutSpace)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Switch back to linear</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> colorLinear = LogCToLinear(colorLutSpace);

    <span style="color: #2aa1ae; background-color: #292e34;">// White balance in LMS space</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Do contrast in log after white balance</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Color filter is just an unclipped multiplier</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Split toning &#20026;&#20102;&#19982; Adobe &#20135;&#21697;&#20013;&#19968;&#33268;&#37319;&#29992; GammaSpace</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Channel mixing (Adobe style)</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Shadows, midtones, highlights</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Lift, gamma, gain</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// HSV operations</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// Global saturation</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// YRGB curves &#20174;&#32654;&#26415;&#24037;&#20316;&#27969;&#31243;&#26469;&#30475;&#65292;&#35813;&#27493;&#39588;&#39068;&#33394;&#38656;&#35201;&#22312;[0,1], &#25152;&#20197;&#20250;&#20808;&#25191;&#34892;&#19968;&#20010;FastTonemap, &#32467;&#26463;&#20043;&#21518;&#22312;&#25191;&#34892;&#19968;&#20010;FastTonemapInvert</span>
    colorLinear = FastTonemap(colorLinear);
    {
        <span style="color: #2aa1ae; background-color: #292e34;">//......</span>
    }
    colorLinear = FastTonemapInvert(colorLinear);

    colorLinear = <span style="color: #4f97d7;">max</span>(0.0, colorLinear);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">RotateToColorGradeOutputSpace</span>(colorLinear);
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgd732ec0"></a>Log C LUT<br />
<div class="outline-text-10" id="text-orgd732ec0">
<p>
前面 GetLutStripValue 生成的颜色值为(0,1)范围内的。为了支持 HDR 颜色，需要扩大该颜色范围。使用 LogCToLinear 函数来将颜色范围扩展到(0, 52.7)<br />
</p>

<p>
下图展示了 LogCToLinear 和 LogCToLinear_Precise 的图像：<br />
<img src="./UnityCatLikeCoding/LogCToLinear.jpg" alt="LogCToLinear.jpg" /><br />
下面文件展示了 LogCToLinear 函数：<br />
<a href="./UnityCatLikeCoding/LogCToLinear.ggb">./UnityCatLikeCoding/LogCToLinear.ggb</a><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> ParamsLogC LogC =
{
    0.011361, <span style="color: #2aa1ae; background-color: #292e34;">// cut</span>
    5.555556, <span style="color: #2aa1ae; background-color: #292e34;">// a</span>
    0.047996, <span style="color: #2aa1ae; background-color: #292e34;">// b</span>
    0.244161, <span style="color: #2aa1ae; background-color: #292e34;">// c</span>
    0.386036, <span style="color: #2aa1ae; background-color: #292e34;">// d</span>
    5.301883, <span style="color: #2aa1ae; background-color: #292e34;">// e</span>
    0.092819  <span style="color: #2aa1ae; background-color: #292e34;">// f</span>
};

real <span style="color: #bc6ec5; font-weight: bold;">LogCToLinear_Precise</span>(real x)
{
    real o;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (x &gt; LogC.e * LogC.cut + LogC.f)
        o = (<span style="color: #4f97d7;">pow</span>(10.0, (x - LogC.d) / LogC.c) - LogC.b) / LogC.a;
    <span style="color: #4f97d7; font-weight: bold;">else</span>
        o = (x - LogC.f) / LogC.e;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #2aa1ae; background-color: #292e34;">// Full float precision to avoid precision artefact when using ACES tonemapping</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">LogCToLinear</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> x)
{
<span style="color: #bc6ec5;">#if</span> USE_PRECISE_LOGC
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">real3</span>(
        LogCToLinear_Precise(x.x),
        LogCToLinear_Precise(x.y),
        LogCToLinear_Precise(x.z)
    );
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #4f97d7;">pow</span>(10.0, (x - LogC.d) / LogC.c) - LogC.b) / LogC.a;
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org52b0121"></a>HDROutput<br />
<div class="outline-text-10" id="text-org52b0121">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ProcessColorForHDR</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> colorLinear)
{
<span style="color: #bc6ec5;">    #ifdef</span> HDR_COLORSPACE_CONVERSION
<span style="color: #bc6ec5;">      #ifdef</span> <span style="color: #7590db;">_TONEMAP_ACES</span>
        <span style="color: #ce537a; font-weight: bold;">float3</span> aces = ACEScg_to_ACES(colorLinear);
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">HDRMappingACES</span>(aces.rgb, PaperWhite, RangeReductionMode, <span style="color: #a45bad;">true</span>);
<span style="color: #bc6ec5;">      #elif</span> <span style="color: #7590db;">_TONEMAP_NEUTRAL</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">HDRMappingFromRec2020</span>(colorLinear.rgb, PaperWhite, MinNits, MaxNits, RangeReductionMode, HueShift, <span style="color: #a45bad;">true</span>);
<span style="color: #bc6ec5;">      #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// Grading finished in Rec2020, converting to the expected color space and [0, 10k] nits range</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">RotateRec2020ToOutputSpace</span>(colorLinear) * PaperWhite;
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> colorLinear;
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org9aeb588"></a>NONE<br />
<div class="outline-text-11" id="text-org9aeb588">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">RotateRec2020ToOutputSpace</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> Rec2020Input)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_HDRColorspace</span> == HDRCOLORSPACE_REC2020)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> Rec2020Input;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #2aa1ae; background-color: #292e34;">// HDRCOLORSPACE_REC709</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">RotateRec2020ToRec709</span>(Rec2020Input);
    }
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">RotateRec2020ToRec709</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> Rec2020Input)
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float3x3</span> Rec2020ToRec709Mat = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
         1.660496, -0.587656, -0.072840,
        -0.124547,  1.132895, -0.008348,
        -0.018154, -0.100597,  1.118751
    );
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">mul</span>(Rec2020ToRec709Mat, Rec2020Input);
}
</pre>
</div>
</div>
</li>
<li><a id="org3c12e5b"></a>ACES<br />
<div class="outline-text-11" id="text-org3c12e5b">
<p>
RRT(Reference Rendering Transform) &#x2013;&gt; ODT(Output Device Transform) &#x2013;&gt; OETF(opto-electronic transfer function)<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">HDRMappingACES</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> aces, <span style="color: #ce537a; font-weight: bold;">float</span> hdrBoost, <span style="color: #ce537a; font-weight: bold;">int</span> reductionMode, <span style="color: #ce537a; font-weight: bold;">bool</span> skipOETF = <span style="color: #a45bad;">false</span>)
{
    aces = (aces * hdrBoost * 0.01f);
    <span style="color: #ce537a; font-weight: bold;">float3</span> oces = RRT(aces);

    <span style="color: #ce537a; font-weight: bold;">float3</span> AP1ODT = 0;

    <span style="color: #2aa1ae; background-color: #292e34;">// This is a static branch.</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (reductionMode == HDRRANGEREDUCTION_ACES1000NITS)
    {
        AP1ODT = ODT_1000nits_ToAP1(oces);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (reductionMode == HDRRANGEREDUCTION_ACES2000NITS)
    {
        AP1ODT = ODT_2000nits_ToAP1(oces);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (reductionMode == HDRRANGEREDUCTION_ACES4000NITS)
    {
        AP1ODT = ODT_4000nits_ToAP1(oces);
    }

    <span style="color: #ce537a; font-weight: bold;">float3</span> linearODT = 0;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_HDRColorspace</span> == HDRCOLORSPACE_REC2020)
    {
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float3x3</span> AP1_2_Rec2020 = <span style="color: #4f97d7;">mul</span>(XYZ_2_REC2020_MAT, <span style="color: #4f97d7;">mul</span>(D60_2_D65_CAT, AP1_2_XYZ_MAT));
        linearODT = <span style="color: #4f97d7;">mul</span>(AP1_2_Rec2020, AP1ODT);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #2aa1ae; background-color: #292e34;">// HDRCOLORSPACE_REC709</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float3x3</span> AP1_2_Rec709 = <span style="color: #4f97d7;">mul</span>(XYZ_2_REC709_MAT, <span style="color: #4f97d7;">mul</span>(D60_2_D65_CAT, AP1_2_XYZ_MAT));
        linearODT = <span style="color: #4f97d7;">mul</span>(AP1_2_Rec709, AP1ODT);
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> (skipOETF) <span style="color: #4f97d7; font-weight: bold;">return</span> linearODT;

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">OETF</span>(linearODT);
}
</pre>
</div>
</div>
</li>

<li><a id="org26998f5"></a>NEUTRAL<br />
<div class="outline-text-11" id="text-org26998f5">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">HDRMappingFromRec2020</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> Rec2020Input, <span style="color: #ce537a; font-weight: bold;">float</span> paperWhite, <span style="color: #ce537a; font-weight: bold;">float</span> minNits, <span style="color: #ce537a; font-weight: bold;">float</span> maxNits, <span style="color: #ce537a; font-weight: bold;">int</span> reductionMode, <span style="color: #ce537a; font-weight: bold;">float</span> hueShift, <span style="color: #ce537a; font-weight: bold;">bool</span> skipOETF = <span style="color: #a45bad;">false</span>)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> outputSpaceInput = RotateRec2020ToOutputSpace(Rec2020Input);
    <span style="color: #ce537a; font-weight: bold;">float3</span> reducedHDR = PerformRangeReduction(outputSpaceInput * paperWhite, minNits, maxNits, reductionMode, hueShift);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (skipOETF) <span style="color: #4f97d7; font-weight: bold;">return</span> reducedHDR;

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">OETF</span>(reducedHDR);
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">PerformRangeReduction</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> input, <span style="color: #ce537a; font-weight: bold;">float</span> minNits, <span style="color: #ce537a; font-weight: bold;">float</span> maxNits, <span style="color: #ce537a; font-weight: bold;">int</span> mode, <span style="color: #ce537a; font-weight: bold;">float</span> hueShift)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> outputValue = input;
    <span style="color: #ce537a; font-weight: bold;">bool</span> reduceLuma = hueShift &lt; 1.0f;
    <span style="color: #ce537a; font-weight: bold;">bool</span> needHueShiftVersion = hueShift &gt; 0.0f;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (mode == HDRRANGEREDUCTION_NONE)
    {
        outputValue = input;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #ce537a; font-weight: bold;">float3</span> huePreserving = reduceLuma ? HuePreservingRangeReduction(input, minNits, maxNits, mode) : 0;
        <span style="color: #ce537a; font-weight: bold;">float3</span> hueShifted = needHueShiftVersion ? HueShiftingRangeReduction(input, minNits, maxNits, mode) : 0;

        <span style="color: #4f97d7; font-weight: bold;">if</span> (reduceLuma &amp;&amp; !needHueShiftVersion)
        {
            outputValue = huePreserving;
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (!reduceLuma &amp;&amp; needHueShiftVersion)
        {
            outputValue = hueShifted;
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// We need to combine the two cases</span>
            outputValue = <span style="color: #4f97d7;">lerp</span>(huePreserving, hueShifted, hueShift);
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> outputValue;
}
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">HuePreservingRangeReduction</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> input, <span style="color: #ce537a; font-weight: bold;">float</span> minNits, <span style="color: #ce537a; font-weight: bold;">float</span> maxNits, <span style="color: #ce537a; font-weight: bold;">int</span> mode)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> ICtCp = RotateOutputSpaceToICtCp(input);

    <span style="color: #ce537a; font-weight: bold;">float</span> lumaPreRed = ICtCp.x;
    <span style="color: #ce537a; font-weight: bold;">float</span> linearLuma = PQToLinear(ICtCp.x, MAX_PQ_VALUE);
    linearLuma = LumaRangeReduction(linearLuma, minNits, maxNits, mode);
    ICtCp.x = LinearToPQ(linearLuma);
    ICtCp = DesaturateReducedICtCp(ICtCp, lumaPreRed, maxNits);

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">RotateICtCpToOutputSpace</span>(ICtCp);
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">HueShiftingRangeReduction</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> input, <span style="color: #ce537a; font-weight: bold;">float</span> minNits, <span style="color: #ce537a; font-weight: bold;">float</span> maxNits, <span style="color: #ce537a; font-weight: bold;">int</span> mode)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> hueShiftedResult = input;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mode == HDRRANGEREDUCTION_REINHARD)
    {
        hueShiftedResult.x = ReinhardTonemap(input.x, maxNits);
        hueShiftedResult.y = ReinhardTonemap(input.y, maxNits);
        hueShiftedResult.z = ReinhardTonemap(input.z, maxNits);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span>(mode == HDRRANGEREDUCTION_BT2390)
    {
        hueShiftedResult.x = BT2390EETF(input.x, minNits, maxNits);
        hueShiftedResult.y = BT2390EETF(input.y, minNits, maxNits);
        hueShiftedResult.z = BT2390EETF(input.z, minNits, maxNits);
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> hueShiftedResult;
}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org68c8516"></a>Final Pass<br />
<ul class="org-ul">
<li><a id="org626811c"></a>如何利用 LUT Texture 计算 ColorGrading？<br />
<div class="outline-text-9" id="text-org626811c">
<p>
将 inputColor 转化为 LUT 的 uv 坐标，采样该点的值就可以得到 inputColor 经过 ColorGrading 后的颜色。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// 2D LUT grading</span>
<span style="color: #2aa1ae; background-color: #292e34;">// uvw &#23601;&#26159; inputColor</span>
<span style="color: #2aa1ae; background-color: #292e34;">// scaleOffset = (1 / lut_width, 1 / lut_height, lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">ApplyLut2D</span>(TEXTURE2D_PARAM(tex, samplerTex), <span style="color: #ce537a; font-weight: bold;">float3</span> uvw, <span style="color: #ce537a; font-weight: bold;">float3</span> scaleOffset)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Strip format where `height = sqrt(width)`</span>
    uvw.z *= scaleOffset.z;
    <span style="color: #ce537a; font-weight: bold;">float</span> shift = <span style="color: #4f97d7;">floor</span>(uvw.z);
    uvw.xy = uvw.xy * scaleOffset.z * scaleOffset.xy + scaleOffset.xy * 0.5;
    uvw.x += shift * scaleOffset.y;
    uvw.xyz = <span style="color: #4f97d7;">lerp</span>(
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy, 0.0).rgb,
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy + <span style="color: #ce537a; font-weight: bold;">float2</span>(scaleOffset.y, 0.0), 0.0).rgb,
        uvw.z - shift
    );
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org7328323"></a>LUT Banding<br />
<div class="outline-text-8" id="text-org7328323">
<p>
因为 LUT 只有有限的分辨率，我们使用双线性插值对 LUT 进行采样将原本平滑的颜色转换为了线性带。通常对于 32 分辨率的 LUT，该问题是不容易被察觉到的，但是，在极其高动态范围的颜色渐变处，该问题就会明显。<br />
将采样器从 sampler_linear_clamp 变为 sampler_point_clamp，带会变得很明显。<br />
</p>
</div>
</li>
<li><a id="org57c9c5e"></a>GPU GEMS2 LUT<br />
<div class="outline-text-8" id="text-org57c9c5e">
<ul class="org-ul">
<li><a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color">https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color</a><br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orgd9c9072"></a>Shader Analysis<br />
<div class="outline-text-9" id="text-orgd9c9072">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float2</span> sUV : <span style="color: #a45bad;">TEXCOORD0</span>,
            <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half4</span> cOut : <span style="color: #a45bad;">COLOR0</span>,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">samplerRECT</span> imagePlane,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">sampler3D</span> lut,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float3</span> lutSize)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// Get the image color</span>
      <span style="color: #ce537a; font-weight: bold;">half3</span> rawColor = <span style="color: #4f97d7;">texRECT</span>(imagePlane, sUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// Compute the 3D LUT lookup scale/offset factor</span>
      <span style="color: #ce537a; font-weight: bold;">half3</span> scale = (lutSize - 1.0) / lutSize;
      <span style="color: #ce537a; font-weight: bold;">half3</span> offset = 1.0 / (2.0 * lutSize);
      <span style="color: #2aa1ae; background-color: #292e34;">// ****** Apply 3D LUT color transform! **************</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// This is our dependent texture read; The 3D texture's</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// lookup coordinates are dependent on the</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// previous texture read's result</span>
      cOut.rgb = <span style="color: #4f97d7;">tex3D</span>(lut, scale * rawColor + offset);
  }
</pre>
</div>

<p>
为什么在上面的代码中要对 UV 进行偏移和缩放？<br />
具体而言，硬件纹理采样算法会从数据集的起始边界采样到结束边界。尽管在对图像数据进行纹理化处理时这是完全合理的，但不适合对数值数据集进行采样，因为它会在纹理边缘附近引入非线性值。因此，我们只在最外层样本的中心区域内进行采样。<br />
<img src="./UnityCatLikeCoding/03_12cg_lut_sampling.png" alt="03_12cg_lut_sampling.png" /><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org655e61b" class="outline-6">
<h6 id="org655e61b">Multiple Cameras</h6>
<div class="outline-text-6" id="text-org655e61b">
</div>
<ul class="org-ul">
<li><a id="orgc05e48a"></a>Combining Cameras<br />
<div class="outline-text-7" id="text-orgc05e48a">
<p>
当两个摄像机叠加在一起，为了移除上面摄像机的天空盒子，可以使用 CameraClearFlags.Color 清除标记。但是，当摄像机使用后期特效后，CameraClearFlags 会被强制设置为 CameraClearFlags.Color，此时上面摄像机显示的内容会包含背景颜色。可以将后期效果 shader 的混合方式改为 Blend SrcAlpha OneMinusSrcAlpha 来去除背景颜色。<br />
</p>

<p>
当 Bloom 效果在天空背景上时，Blend SrcAlpha OneMinusSrcAlpha 模式混合后 Bloom 效果会变弱。需要将混合模式调整为 Blend One OneMinusSrcAlpha。<br />
</p>

<p>
可以使用下面方式，分别控制 RGB 和 Alpha 的混合因子：<br />
Blend SrcFactor DstFactor, AlphaSrcFactor AlphaDstFactor<br />
</p>
</div>
</li>
<li><a id="orgf9fb095"></a>Rendering Layers<br />
<div class="outline-text-7" id="text-orgf9fb095">
<p>
每个物体都属于唯一一个 Layer，每个 Camera 都有一个 CullingMask 属性，其可以包含多个 Layer，用来标识哪些 Layer 对该摄像机可见。<br />
Light 也有 CullingMask，如果物体所在 Layer 没被 Light 包含，则该 Light 对该物体相当于不存在，即 Light 不会照亮物体，也不会让物体投射阴影。但是，方向光是个例外，其 CullingMask 只影响物体的阴影，而依然可以照亮物体。<br />
使用现在的方式无法完整支持 Light 的 CullingMask，HDRP 也不支持。Unity 为 SRPs 提供了 Rendering Layers 作为一种替代方案。使用 Rendering Layers 代替 game-object layers 有两个好处：<br />
</p>
<ol class="org-ol">
<li>renderers 不必限制为只属于单个 layer，这意味着 rendering-layers 更灵活。<br /></li>
<li>rendering-layers 不会被用于做其他事情(默认的 game-object layers 也会被物理模块使用)。<br /></li>
</ol>

<p>
注意： 只有 CullingMask 会被用于 Culling，Rendering-Layers 不会执行 Culling，因此 Renderer 的 RenderingLayer 不被摄像机包含时，依然会渲染该 Renderer 的阴影。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc56108b" class="outline-6">
<h6 id="orgc56108b">Particles</h6>
<div class="outline-text-6" id="text-orgc56108b">
</div>
<ul class="org-ul">
<li><a id="org2908890"></a>Unlit Particles<br />
<ul class="org-ul">
<li><a id="org87a0e70"></a>修改粒子发射器形状<br />
<div class="outline-text-8" id="text-org87a0e70">
<p>
勾选 ParticleSystem/Shape，在该分组下进行修改<br />
</p>
</div>
</li>
<li><a id="org93a342a"></a>粒子帧动画<br />
<div class="outline-text-8" id="text-org93a342a">
<p>
勾选 ParticleSystem/TextureSheetAnimation，在该分组下进行修改<br />
</p>
</div>
</li>
<li><a id="org5838784"></a>粒子渲染模式<br />
<div class="outline-text-8" id="text-org5838784">
<p>
ParticleSystem/Renderer/Render Mode<br />
</p>

<p>
Billboard<br />
StrechedBillboard<br />
HBillboard<br />
VBillboard<br />
Mesh<br />
None<br />
</p>
</div>
</li>
<li><a id="org30052ab"></a>粒子颜色变化<br />
<div class="outline-text-8" id="text-org30052ab">
<p>
ParticleSystem/Color over Lifetime<br />
</p>
</div>
</li>
<li><a id="orgece035e"></a>自定义 Shader Vertex Steam<br />
<div class="outline-text-8" id="text-orgece035e">
<p>
ParticleSystem/Renderer/Custom Vertex Streams<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgaafae72"></a>Fading Near Camera<br />
<div class="outline-text-7" id="text-orgaafae72">
<p>
当摄像机在一个粒子系统中时，粒子会非常靠近摄像机近平面，也会闯过近平面从一侧到达另一侧。Renderer/MaxParticleSize 属性可以避免单独的粒子占据屏幕上很大的空间。当粒子靠近近平面时，一旦其达到可视最大尺寸，该粒子将会停止增大。<br />
另一种处理靠近近平面粒子的方法是，基于粒子的片段深度来淡出(fade out)粒子。这种方式对于通过代表气体效果的粒子系统时效果比较好。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge6d5beb"></a>Fragment Depth<br />
<div class="outline-text-8" id="text-orge6d5beb">
<p>
下面代码用于实现求解视觉空间下的 Depth<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">IsOrthographicCamera</span> ()
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> unity_OrthoParams.w;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">OrhtographicDepthBufferToLinear</span>(<span style="color: #ce537a; font-weight: bold;">float</span> rawDepth)
  {
<span style="color: #bc6ec5;">      #if</span> UNITY_REVERSED_Z
      rawDepth = 1.0 - rawDepth;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y) * rawDepth + <span style="color: #7590db;">_ProjectionParams</span>.y;
  }

  Fragment <span style="color: #bc6ec5; font-weight: bold;">GetFragment</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> positionSS)
  {
      Fragment f;
      f.positionSS = positionSS.xy;
      f.depth = IsOrthographicCamera() ? OrthographicDepthBufferToLinear(positionSS.z) : positionSS.w;
      <span style="color: #4f97d7; font-weight: bold;">return</span> f;
  }
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgd370be6"></a>Soft Particles<br />
<div class="outline-text-7" id="text-orgd370be6">
<p>
当 Billboard 粒子和场景中几何体有交叉时，尖锐的转变会很不和谐而且使得 Billboard 粒子平坦的本质显得很明显。使用 Soft Particles 可以解决该问题，其原理为，当有不透明的物体在粒子后面时，将粒子淡出。可以比较粒子和之前渲染的不透明物体的视觉空间 depth 来实现该功能。<br />
</p>
</div>
</li>
<li><a id="orgaa557dd"></a>Distortion<br />
<div class="outline-text-7" id="text-orgaa557dd">
<p>
实现热气导致的大气折射效果的原理为，根据粒子的 normal 对 uv 进行偏移，使用偏移后的 uv 对 color buffer 进行采样。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6824234" class="outline-6">
<h6 id="org6824234"><span class="todo TODO">TODO</span> FXAA</h6>
</div>
</div>
<div id="outline-container-org1f7a080" class="outline-5">
<h5 id="org1f7a080">CustomSRP 2.0</h5>
<div class="outline-text-5" id="text-org1f7a080">
</div>
<div id="outline-container-orgb2ead2b" class="outline-6">
<h6 id="orgb2ead2b">CustomRenderPipeline 中管理 RenderGraph</h6>
<div class="outline-text-6" id="text-orgb2ead2b">
<p>
所有 Pass 共用一个 RenderGraph，所以在 CustomRenderPipeline 中创建 RenderGraph，清理 RenderGraph<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; RenderGraph</span>
<span style="color: #4f97d7; font-weight: bold;">readonly</span> <span style="color: #ce537a; font-weight: bold;">RenderGraph</span> <span style="color: #7590db;">renderGraph</span> = <span style="color: #4f97d7; font-weight: bold;">new</span>(<span style="color: #2d9574;">"Custom SRP Render Graph"</span>);

<span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Dispose</span>(<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">disposing</span>)
{
    renderGraph.<span style="color: #bc6ec5; font-weight: bold;">Cleanup</span>();
}

<span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Render</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">Camera</span>&gt; <span style="color: #7590db;">cameras</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; cameras.Count; i++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; renderGraph &#20256;&#36882;&#32473; CameraRenderer</span>
        renderer.<span style="color: #bc6ec5; font-weight: bold;">Render</span>(
            renderGraph, context, cameras[i], cameraBufferSettings,
            useDynamicBatching, useGPUInstancing, useLightsPerObject,
            shadowSettings, postFXSettings, colorLUTResolution);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992; renderGraph &#30340; EndFrame &#26041;&#27861;</span>
    renderGraph.<span style="color: #bc6ec5; font-weight: bold;">EndFrame</span>();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org998c8df" class="outline-6">
<h6 id="org998c8df">使用 RenderGraph 方式来录制执行一个渲染 Pass</h6>
<div class="outline-text-6" id="text-org998c8df">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CameraRenderer.Render</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Render</span>(<span style="color: #2aa1ae; background-color: #292e34;">/**/</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #bc6ec5; font-weight: bold;">DrawGizmosAfterFX</span>();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; RenderGraphParameters &#26469;</span>
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">renderGraphParameters</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">RenderGraphParameters</span> {
        <span style="color: #7590db;">commandBuffer</span> = CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Get</span>(),
        <span style="color: #7590db;">currentFrameIndex</span> = Time.frameCount,
        <span style="color: #7590db;">executionName</span> = <span style="color: #2d9574;">"Render Camera"</span>,
        <span style="color: #7590db;">scriptableRenderContext</span> = context
    };
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24405;&#21046;&#24182;&#25191;&#34892;&#19968;&#20010;&#28210;&#26579;Pass</span>
    renderGraph.<span style="color: #bc6ec5; font-weight: bold;">RecordAndExecute</span>(renderGraphParameters)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21521; renderGraph &#20013;&#28155;&#21152;&#19968;&#20010;Pass</span>
        <span style="color: #4f97d7; font-weight: bold;">using</span> RenderGraphBuilder builder = renderGraph.<span style="color: #bc6ec5; font-weight: bold;">AddRenderPass</span>(<span style="color: #2d9574;">"Test Pass"</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">CameraSettings</span> <span style="color: #7590db;">data</span>);
        builder.<span style="color: #bc6ec5; font-weight: bold;">SetRenderFunc</span>((<span style="color: #ce537a; font-weight: bold;">CameraSettings</span> <span style="color: #7590db;">data</span>, <span style="color: #ce537a; font-weight: bold;">RenderGraphContext</span> <span style="color: #7590db;">context</span>) =&gt; { });
    }

    <span style="color: #bc6ec5; font-weight: bold;">Cleanup</span>();
    <span style="color: #bc6ec5; font-weight: bold;">Submit</span>();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463;&#21518;&#38656;&#35201;&#37322;&#25918; commandBuffer</span>
    CommandBufferPool.<span style="color: #bc6ec5; font-weight: bold;">Release</span>(renderGraphParameters.commandBuffer);
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgce7485b" class="outline-2">
<h2 id="orgce7485b">MyTest</h2>
<div class="outline-text-2" id="text-orgce7485b">
</div>
<div id="outline-container-org016aeb6" class="outline-3">
<h3 id="org016aeb6">TestReplaceShader</h3>
<div class="outline-text-3" id="text-org016aeb6">
</div>
<div id="outline-container-orgb6dd4a0" class="outline-4">
<h4 id="orgb6dd4a0">SetReplacementShader VS RenderWithShader</h4>
<div class="outline-text-4" id="text-orgb6dd4a0">
<p>
SetReplacementShader 修改相机渲染物体时对应物体的 shader<br />
RenderWithShader     使用相机进行额外的一次渲染，渲染时修改渲染物体对应的 shader<br />
这两个函数的参数：(Shader shader, string replacementTag)<br />
shader 即将使用的新的 shader.<br />
replacementTag 指定替换条件，具体分如下两种情况：<br />
如果 replacementTag="" 表示直接使用新的 shader。<br />
如果 replacementTag="XX" 表示，假设新 shader 的 Tag 为 Tag{ &#x2026;&#x2026; XX="xx" &#x2026;&#x2026; }，那么旧 shader 中 Tag 有相同的 XX="xx" 键值对则使用新 shader 渲染物体，否则不渲染该物体。<br />
</p>
</div>
</div>

<div id="outline-container-org99d5274" class="outline-4">
<h4 id="org99d5274">Q&amp;A</h4>
<div class="outline-text-4" id="text-org99d5274">
</div>
<div id="outline-container-orgdd0a092" class="outline-5">
<h5 id="orgdd0a092">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</h5>
<div class="outline-text-5" id="text-orgdd0a092">
<p>
在 OnPreRender OnPostRender 中调用 RenderWithShader 时会提示如上警告信息。这是因为引擎对相机的渲染调用还没结束，又对同一相机发出渲染的请求。<br />
在 OnGUI 中调用 RenderWithShader 不会提示如上警告信息。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org95e5019" class="outline-3">
<h3 id="org95e5019">BilinearFiltering</h3>
<div class="outline-text-3" id="text-org95e5019">
<p>
双线性过滤属于 Up-Sampling 操作<br />
<a id="orgfc1eb0b"></a><br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #bc6ec5; font-weight: bold;">BilinearFilter</span>(<span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c00</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c10</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c01</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c11</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">tx</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ty</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #a45bad;">false</span>
      <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">a</span> = c00 * (1 - tx) + c10 * tx;
      <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">b</span> = c10 * (1 - tx) + c11 * tx;
      <span style="color: #4f97d7; font-weight: bold;">return</span> (a * (1 - ty) + b * ty);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span>
          (1 - tx) * (1 - ty) * c00 +
          tx * (1 - ty) * c10 +
          (1 - tx) * ty * c01 +
          tx * ty * c11;
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>

<p>
MipMap 生成利用了将高分辨率映射为低分辨率的 Down-Sampling 操作<br />
<a href="../graphics/PhysicallyBasedRendering.html#org4f01310">../graphics/PhysicallyBasedRendering.html#org4f01310</a><br />
</p>

<p>
Down-Sampling 会消耗更多性能，直接使用高分辨率贴图会导致画面闪烁，因此需要使用 mipmap，通过 Down-Sampling 来生成 mipmaps。<br />
</p>

<ul class="org-ul">
<li>双线性过滤近似高斯模糊 <a href="https://blog.csdn.net/seizeF/article/details/90543797">https://blog.csdn.net/seizeF/article/details/90543797</a><br /></li>
<li>图像的 down-samplig 和 up-sampling <a href="https://www.cnblogs.com/jngwl/articles/image_sampling.html">https://www.cnblogs.com/jngwl/articles/image_sampling.html</a><br /></li>
<li>Mipmap 生成 <a href="https://blog.csdn.net/qjh5606/article/details/89040887">https://blog.csdn.net/qjh5606/article/details/89040887</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga30d3ae" class="outline-3">
<h3 id="orga30d3ae">SphereMapping</h3>
<div class="outline-text-3" id="text-orga30d3ae">
</div>
<div id="outline-container-orgae6644b" class="outline-4">
<h4 id="orgae6644b">参考资料</h4>
<div class="outline-text-4" id="text-orgae6644b">
<ul class="org-ul">
<li>环境贴图 <a href="http://www.twinklingstar.cn/2014/1322/environment-mapping/">http://www.twinklingstar.cn/2014/1322/environment-mapping/</a><br /></li>
<li>详解球面环境映射 <a href="https://zhuanlan.zhihu.com/p/84494845">https://zhuanlan.zhihu.com/p/84494845</a><br /></li>
<li>Unity Shader-Matcap(材质捕获)使用解析 <a href="https://gameinstitute.qq.com/community/detail/128771#commit">https://gameinstitute.qq.com/community/detail/128771#commit</a><br /></li>
<li>详解双抛物面环境映射 <a href="https://zhuanlan.zhihu.com/p/40784734">https://zhuanlan.zhihu.com/p/40784734</a><br /></li>
<li><a href="http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf">http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5aacae4" class="outline-3">
<h3 id="org5aacae4">Unity Universal SRP</h3>
<div class="outline-text-3" id="text-org5aacae4">
<div class="org-src-container">
<pre class="src src-shader">uiSample.rgb = uiSample.rgb / (uiSample.a == 0.0f ? 1.0 : uiSample.a);
uiSample.rgb = RotateRec709ToOutputSpace(uiSample.rgb);
uiSample.rgb *= paperWhite;
<span style="color: #4f97d7; font-weight: bold;">return</span> uiSample.rgb * uiSample.a + sceneColor.rgb * (1.0f - uiSample.a);

</pre>
</div>
</div>
<div id="outline-container-orgbdba2e0" class="outline-4">
<h4 id="orgbdba2e0">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgbdba2e0">
</div>
<div id="outline-container-org3098ba3" class="outline-5">
<h5 id="org3098ba3">为什么 GameView 下摄像机的后处理效果没有生效？</h5>
<div class="outline-text-5" id="text-org3098ba3">
<p>
Camera 上的 PostProcessing 勾选框需要勾选。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgdd745c1" class="outline-4">
<h4 id="orgdd745c1">参考链接</h4>
<div class="outline-text-4" id="text-orgdd745c1">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br /></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org0b303fd" class="outline-2">
<h2 id="org0b303fd">Q&amp;A</h2>
<div class="outline-text-2" id="text-org0b303fd">
</div>
<div id="outline-container-orgb6ca463" class="outline-3">
<h3 id="orgb6ca463">如何判断投影矩阵是否为透视投影？</h3>
<div class="outline-text-3" id="text-orgb6ca463">
<p>
正交投影没有透视除法，所以其最后一行数据为 (0,0,0,1)。因此在游戏引擎中，只要判断投影矩阵是否为正交投影矩阵，如果不是正交投影矩阵，就是透视投影矩阵。<br />
OpenGL API 接受的矩阵需要列主序。<br />
Unity 中矩阵是列主序的，正交投影最后一列数据为(0,0,0,1)。底层使用一个 float matrixData[16] 数组存储。<br />
matrix[0]  matrix[1]  matrix[2]  matrix[3]<br />
matrix[4]  matrix[5]  matrix[6]  matrix[7]<br />
matrix[8]  matrix[9]  matrix[10] matrix[11]<br />
matrix[12] matrix[13] matrix[13] matrix[15]<br />
判断是否为透视投影矩阵的方法为：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isPerspectiveMatrix</span>()
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> matixData[3]!=0 || matrixData[7]!=0 || matrixData[11]!=0 || matrixData[15]!=1;
  }
</pre>
</div>
<p>
FrameDebug 中显示的矩阵是行主序的：<br />
<img src="./UnityCatLikeCoding/00_matix_checker_01.png" alt="00_matix_checker_01.png" /><br />
<img src="./UnityCatLikeCoding/00_matix_checker_02.png" alt="00_matix_checker_02.png" /><br />
</p>

<ul class="org-ul">
<li>OpenGL 中矩阵的行主序与列主序 <a href="https://blog.51cto.com/31329846/2345432">https://blog.51cto.com/31329846/2345432</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3c8f09f" class="outline-3">
<h3 id="org3c8f09f">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</h3>
<div class="outline-text-3" id="text-org3c8f09f">
<p>
因为 unity 就是这样实现的。其实任何光照都可以在顶点着色器中计算，在片段着色器中插值获得片段颜色。<br />
</p>
</div>
</div>
<div id="outline-container-org587610f" class="outline-3">
<h3 id="org587610f">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</h3>
<div class="outline-text-3" id="text-org587610f">
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/8997720.html">https://www.cnblogs.com/murongxiaopifu/p/8997720.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9e63074" class="outline-3">
<h3 id="org9e63074">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</h3>
<div class="outline-text-3" id="text-org9e63074">
<p>
对于物体来说方向光的方向都是相同的，和方向光垂直的同一平面内的点，他们对应的阴影贴图中的值应该相同，使用正交投影按照方向光方向，渲染场景中物体，将深度写入阴影贴图刚好可以满足这个要求。<br />
点光源的情况则刚好和透视投影相对应。<br />
</p>
</div>
</div>
<div id="outline-container-orgef76ff5" class="outline-3">
<h3 id="orgef76ff5">为什么点光源阴影需要绘制场景 6 次？</h3>
<div class="outline-text-3" id="text-orgef76ff5">
<p>
因为点光源各个方向的光照方向都不同，必须从前后左右和上下六个方向分别绘制场景，生成 Cube 阴影贴图。<br />
</p>
</div>
</div>
<div id="outline-container-org82716e8" class="outline-3">
<h3 id="org82716e8">Renderer.receiveShadows 是如何控制关闭接收阴影的？</h3>
<div class="outline-text-3" id="text-org82716e8">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">UnityComputeForwardShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float4</span> screenPos)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//fade value</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(worldPos, zDist);
    <span style="color: #ce537a; font-weight: bold;">half</span>  realtimeToBakedShadowFade = UnityComputeShadowFade(fadeDist);

    <span style="color: #2aa1ae; background-color: #292e34;">//baked occlusion if any</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);

    <span style="color: #2aa1ae; background-color: #292e34;">// &#35828;&#26126;&#65306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Renderer.receiveShadows=false &#26102;&#65292;Unity &#24341;&#25806;&#20250;&#21462;&#28040; SHADOWS_SCREEN Keyword &#30340;&#23450;&#20041;&#65292;&#20174;&#32780;&#35753; shadowAttenuation=1</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation = 1.0f;
    <span style="color: #2aa1ae; background-color: #292e34;">//directional realtime shadow</span>
<span style="color: #bc6ec5;">    #if</span> defined (SHADOWS_SCREEN)
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS) &amp;&amp; !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
            realtimeShadowAttenuation = unitySampleShadow(<span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));
<span style="color: #bc6ec5;">        #else</span>
            <span style="color: #2aa1ae; background-color: #292e34;">//Only reached when LIGHTMAP_ON is NOT defined (and thus we use interpolator for screenPos rather than lightmap UVs). See HANDLE_SHADOWS_BLENDING_IN_GI below.</span>
            realtimeShadowAttenuation = unitySampleShadow(screenPos);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    <span style="color: #2aa1ae; background-color: #292e34;">//avoid expensive shadows fetches in the distance where coherency will be good</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (realtimeToBakedShadowFade &lt; (1.0f - 1e-2f))
    {
<span style="color: #bc6ec5;">    #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//spot realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> (defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT))
<span style="color: #bc6ec5;">            #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
                unityShadowCoord4 spotShadowCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1));
<span style="color: #bc6ec5;">            #else</span>
                unityShadowCoord4 spotShadowCoord = screenPos;
<span style="color: #bc6ec5;">            #endif</span>
            realtimeShadowAttenuation = UnitySampleShadowmap(spotShadowCoord);
<span style="color: #bc6ec5;">        #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//point realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> defined (SHADOWS_CUBE)
            realtimeShadowAttenuation = UnitySampleShadowmap(worldPos - <span style="color: #7590db;">_LightPositionRange</span>.xyz);
<span style="color: #bc6ec5;">        #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    }
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(realtimeShadowAttenuation, shadowMaskAttenuation, realtimeToBakedShadowFade);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2ccf9d4" class="outline-3">
<h3 id="org2ccf9d4">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</h3>
<div class="outline-text-3" id="text-org2ccf9d4">
<ul class="org-ul">
<li>检查是否烘培了当前场景<br /></li>
<li>检查间接光照强度 Lighting/Environment/EnvironmentReflections/IntensityMultiplier<br /></li>
<li>开启 SRP Batcher 后，unity_SpecCube0 会显示为 UnityBlackCube，但实际效果是正确的。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9696108" class="outline-2">
<h2 id="org9696108">参考资料</h2>
<div class="outline-text-2" id="text-org9696108">
<p>
官网<br />
</p>
<ul class="org-ul">
<li><a href="https://catlikecoding.com/">https://catlikecoding.com/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/rendering/">https://catlikecoding.com/unity/tutorials/rendering/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/">https://catlikecoding.com/unity/tutorials/advanced-rendering/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/custom-srp/">https://catlikecoding.com/unity/tutorials/custom-srp/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/noise-derivatives/">https://catlikecoding.com/unity/tutorials/noise-derivatives/</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a><br /></li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br /></li>
<li>DistanceField <a href="https://prideout.net/blog/distance_fields/">https://prideout.net/blog/distance_fields/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'UnityCatLikeCoding',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
