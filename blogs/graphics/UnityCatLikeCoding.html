<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-12-13 周日 15:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UnityCatLikeCoding</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">UnityCatLikeCoding</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org417bbbd">UnityCatLikeCoding</a>
<ul>
<li><a href="#org3218b7c">Rendering</a>
<ul>
<li><a href="#orgd1aaf2d">Shader Fundamentals</a>
<ul>
<li><a href="#org48920c8">基础知识</a>
<ul>
<li><a href="#org9d2eca8">MatrixType</a></li>
<li><a href="#org96947b9">SV 含义</a></li>
<li><a href="#org39163f9">ST 含义</a></li>
<li><a href="#org2fcaa28">贴图坐标系</a></li>
<li><a href="#orgd57e69b">MipMap 和 FilterMode</a></li>
<li><a href="#org4e97d7e">TRANSFORM_TEX</a></li>
<li><a href="#orgfeded0d">tex2Dbias tex2Dlod</a></li>
<li><a href="#orgc61ad21">lerp 函数意义</a></li>
<li><a href="#org6a47ab1">ddx ddy</a></li>
<li><a href="#org2f1e1be">fwidth</a></li>
<li><a href="#orgec78f5e">smoothstep</a></li>
</ul>
</li>
<li><a href="#org67dca4a">Shader Semantics</a>
<ul>
<li><a href="#orgb6a998f">Screen space pixel position: VPOS</a></li>
<li><a href="#orgcb1bae6">Face orientation: VFACE</a></li>
<li><a href="#org18c08b1">参考资料</a></li>
</ul>
</li>
<li><a href="#orge8895c3">Unity 定义的变量</a></li>
<li><a href="#orgc450572">Unity Shader 定义的宏</a></li>
<li><a href="#orgb82e22f">Unity Shader Compiler</a></li>
<li><a href="#orgc490f8a">Unity shader 预编译命令</a></li>
<li><a href="#orgd96cdb4">D3D11 汇编命令</a></li>
</ul>
</li>
<li><a href="#org4de9b93">Combining Textures</a>
<ul>
<li><a href="#org4423698">Linear Color Space</a>
<ul>
<li><a href="#org4c6e310">Linear Color Space 原理</a></li>
<li><a href="#org1e440c1">DetailTex 叠加到 MainTex 上为什么需要乘二？</a></li>
<li><a href="#orgc69b3b8">SetVector SetColor</a></li>
<li><a href="#org64cf57d">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org82d763d">The First Light</a>
<ul>
<li><a href="#org0c47246">normal 从物体空间到世界空间的变换</a></li>
<li><a href="#orga6b64d0">Tags LightMode=ForwardBase</a></li>
<li><a href="#org6d77721">BlinnPhong</a></li>
<li><a href="#org1f5e31e">Energy Conservation</a></li>
<li><a href="#orgc141fc9">Specular / Metallic Workflow</a>
<ul>
<li><a href="#org8659f93">Specular Workflow</a></li>
<li><a href="#org3812239">Metallic Workflow</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc592ae3">Multi Lights</a>
<ul>
<li><a href="#org7568ebd">Light Coord</a></li>
<li><a href="#orgedb9ae1">Light Attenuation</a>
<ul>
<li><a href="#org9b9b8bf">Point Light</a></li>
</ul>
</li>
<li><a href="#org16da472">Mixing Lights</a></li>
<li><a href="#org5c3eadd">Cookies</a></li>
<li><a href="#org3140bde">Vertex Lights</a></li>
<li><a href="#orgd9003e7">Spherical Harmonics</a>
<ul>
<li><a href="#orga923c16">相关数学概念</a></li>
<li><a href="#orgbca80e2">原理概述</a></li>
<li><a href="#org31a4ff2">Spherical Harmonics Bands</a></li>
<li><a href="#org964981a">ShadeSH9</a></li>
<li><a href="#org3853ec5">环境光和 LightProbe</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6a2ced4">Bumpiness</a>
<ul>
<li><a href="#orgc88c7d9">高度图转 normal map 的方法</a>
<ul>
<li><a href="#org78a8ed6">方案 1</a></li>
<li><a href="#org8c9b4c2">方案 2</a></li>
</ul>
</li>
<li><a href="#org7612f09">Normal 向量的插值</a></li>
<li><a href="#org1b97ab4">Normal 贴图存储惯例</a></li>
<li><a href="#org1efe8cd">DXT5nm 存储 normal 贴图</a></li>
<li><a href="#orgd3ad258">缩放 Normal</a></li>
<li><a href="#org7547aee">Blending Normals</a></li>
</ul>
</li>
<li><a href="#orga65a3aa">Shadows</a>
<ul>
<li><a href="#org82a46f3">方向光阴影</a>
<ul>
<li><a href="#org4c9d938">ShadowBias</a></li>
<li><a href="#orgce81016">开启屏幕空间阴影</a></li>
<li><a href="#org871bdce">关闭屏幕空间阴影</a></li>
<li><a href="#orgab2bab7">ShadowQuality</a></li>
<li><a href="#orge071023">ForwardAddPass 阴影支持</a></li>
<li><a href="#org8a0de81">参考资料</a></li>
</ul>
</li>
<li><a href="#org0f169bb">Spot Light Shadow</a></li>
<li><a href="#org13bbcfc">相关宏定义</a></li>
<li><a href="#org888c3f6">参考资料</a></li>
</ul>
</li>
<li><a href="#org4575d98">Reflection</a>
<ul>
<li><a href="#org6f7fa9d">Environment Mapping</a>
<ul>
<li><a href="#org0a7ec2a">缺少 Indirect Specular Lighting</a></li>
<li><a href="#orgdd77cbf">Indirect Specular Lighting 特点</a></li>
</ul>
</li>
<li><a href="#org0751e71">Imperfect Reflections</a>
<ul>
<li><a href="#org901f7dc">Metals VS Nonmetals</a></li>
<li><a href="#org72a2ac0">Mirrors and Shadows</a></li>
</ul>
</li>
<li><a href="#org254a923">Box Projection</a></li>
<li><a href="#org4bcaf4d">Blending Reflection Probes</a></li>
<li><a href="#org7090a0d">Bouncing Reflections</a></li>
</ul>
</li>
<li><a href="#org1a1cc75">ComplexMaterials &amp; More Complexity</a>
<ul>
<li><a href="#org0db62a8">Emission</a></li>
<li><a href="#org035c3f0">Smoothness &amp; Metallic Map</a></li>
<li><a href="#org1b21937">Occlusion</a></li>
</ul>
</li>
<li><a href="#org37740da">Transparency</a>
<ul>
<li><a href="#orgd1874bb">Cutout</a></li>
<li><a href="#org9913539">Semitransparent</a></li>
<li><a href="#org6ed9cea">RenderType tag</a></li>
<li><a href="#orgf575971">Fading vs Transparency</a></li>
</ul>
</li>
<li><a href="#orga9f8067">Semitransparent Shadows</a>
<ul>
<li><a href="#org0b44da0">Cutout Shadow</a></li>
<li><a href="#org14493bd">Transparenct Shadow</a></li>
</ul>
</li>
<li><a href="#org9673cf4">Deferred Shading</a>
<ul>
<li><a href="#org82399de">Forward Path vs Deferred Path</a>
<ul>
<li><a href="#org178ecb2">DrawCall 对比</a></li>
<li><a href="#org16b93bf">GBuffer 内容</a></li>
<li><a href="#org0f8a295">Rendering Lights</a></li>
<li><a href="#orgf888461">Light Range</a></li>
<li><a href="#orge73e04d">Mixing Rendering Modes</a></li>
</ul>
</li>
<li><a href="#org3922b62">Support Deferred Path</a>
<ul>
<li><a href="#org777dcf0">创建 deferred pass</a></li>
<li><a href="#org0a808ef">deferred pass frag output</a></li>
<li><a href="#org7891038">gbufer0123</a></li>
<li><a href="#org4a29015">support LDR</a></li>
</ul>
</li>
<li><a href="#org3013e59">Deferred Reflections</a>
<ul>
<li><a href="#orgdfef112">Unity 内置的屏幕空间反射</a></li>
<li><a href="#orgecb0a21">延迟渲染使用非屏幕空间反射</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdf57673">Fog</a>
<ul>
<li><a href="#orgcdfcc15">Forward Fog</a>
<ul>
<li><a href="#orgaae0d44">Linear Fog</a></li>
<li><a href="#org525b1a4">Exponential Fog</a></li>
<li><a href="#org197745c">Exponential Squared Fog</a></li>
<li><a href="#org7c356da">Depth-Based Fog</a></li>
<li><a href="#org0399548">代码实现</a></li>
</ul>
</li>
<li><a href="#org94f6767">Deferred Fog</a>
<ul>
<li><a href="#orge9b0be8">Shader Source Code</a></li>
<li><a href="#org8a5741e">Depth-Based Fog</a></li>
<li><a href="#orgda0831e">Distance Based Fog</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8c801f8">Deferred Lights</a>
<ul>
<li><a href="#orgada921a">Light Shader</a>
<ul>
<li><a href="#org034b213">两个 Pass</a></li>
<li><a href="#org10c267b">Avoiding the Sky</a></li>
</ul>
</li>
<li><a href="#org99eee7f">Directional Lights</a>
<ul>
<li><a href="#org2f9dfab">读取 G-Buffer 数据使用的 UV</a></li>
<li><a href="#orgfd1107a">像素对应的世界坐标位置</a></li>
<li><a href="#org6f22457">Supporting LDR</a></li>
</ul>
</li>
<li><a href="#orgd942bc0">Spotlights</a>
<ul>
<li><a href="#org0a33c14">像素对应的世界坐标位置</a></li>
</ul>
</li>
<li><a href="#orga0f788e">Q&amp;A</a>
<ul>
<li><a href="#orgb102177">为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？</a></li>
<li><a href="#org9133c43">为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？</a></li>
<li><a href="#org40605e5">为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2f34f09">Static Lighting</a>
<ul>
<li><a href="#org91c7e83">Lightmapping 光照贴图</a>
<ul>
<li><a href="#org2bec968">简介</a></li>
<li><a href="#org52f6f38">Unity 中使用光照贴图的步骤</a></li>
<li><a href="#org7fcf37f">Lightmapping Settings</a></li>
<li><a href="#org2a87e1a">Indirect Light</a></li>
<li><a href="#orgd01ea79">Transparency</a></li>
</ul>
</li>
<li><a href="#orgcf9158a">使用光照贴图</a></li>
<li><a href="#orgc89e1fa">创建光照贴图</a>
<ul>
<li><a href="#org278247c">lightmapper 默认规则</a></li>
<li><a href="#org778818f">通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper</a></li>
</ul>
</li>
<li><a href="#org4768c54">Directional Lightmaps 具有方向的光照贴图</a>
<ul>
<li><a href="#orgc9be0f5">简介</a></li>
<li><a href="#orgd54c253">方向性</a></li>
<li><a href="#orgc8b6437">使用烘培的方向贴图</a></li>
</ul>
</li>
<li><a href="#org4b06785">Light Probes</a>
<ul>
<li><a href="#org739f0f6">为什么 SceneView 中不显示 LightProbe？</a></li>
<li><a href="#orgb2d4119">为什么 LightProb 对于动态物体不生效？</a></li>
</ul>
</li>
<li><a href="#orgda63bea">Q&amp;A</a>
<ul>
<li><a href="#org783b549">使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？</a></li>
<li><a href="#org1b0c282">什么错误导致 lightmap 中不包含 Emission 颜色？</a></li>
<li><a href="#org2db3667">Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9123843">Mixed Lighting</a>
<ul>
<li><a href="#org9c9a75b">烘培光照贴图的优缺点</a>
<ul>
<li><a href="#org1d514f5">缺点</a></li>
<li><a href="#org4498c46">优点</a></li>
</ul>
</li>
<li><a href="#org09522bc">Baking Indirect Light</a></li>
<li><a href="#org13121bc">Using a Shadowmask</a>
<ul>
<li><a href="#orgba02140">Sampling the Shadowmask</a></li>
<li><a href="#org5bdbbd6">Support Deferred Path</a></li>
<li><a href="#orga8c7e3e">Distance Shadowmask Mode</a></li>
<li><a href="#org3c23fcb">Multiple Lights</a></li>
</ul>
</li>
<li><a href="#org514b14c">Subtractive Shadows</a>
<ul>
<li><a href="#orgf416e78">简介</a></li>
<li><a href="#org1f2d775">实现</a></li>
</ul>
</li>
<li><a href="#org2512a35">总结</a></li>
<li><a href="#orgda62ef6">Q&amp;A</a>
<ul>
<li><a href="#orgc848338"><span class="todo TODO">TODO</span> 如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？</a></li>
<li><a href="#org6eb2f09">烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？</a></li>
<li><a href="#org709708f">ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图</a></li>
<li><a href="#org363ffa9">Deferred Path 模式下的间接光照计算是怎样的？</a></li>
<li><a href="#org8c4c5b1">Error: 阴影轮廓处有光晕</a></li>
<li><a href="#org884a03b">Error: Subtractive 模式下动态物体的阴影很淡</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbaff94c">RealtimeGI ProbeVolumes LOD Groups</a>
<ul>
<li><a href="#orgc08c83d">Realtime Globall Illumination</a>
<ul>
<li><a href="#org5f5ecdb">简介</a></li>
<li><a href="#org772dad1">Baking Realtime GI</a></li>
<li><a href="#org8d5300f">Sampling Realtime Lightmaps</a></li>
<li><a href="#org8b99f28">Emissive Light</a></li>
</ul>
</li>
<li><a href="#org3158e6e">Light Probe Proxy Volumes</a></li>
<li><a href="#orgddd45be">LOD Groups</a>
<ul>
<li><a href="#orgea8adde">Baked GI and Lod Group</a></li>
<li><a href="#orge32b234">Realtime GI and Lod Group</a></li>
<li><a href="#org7e37468">Cross-fading Between Lod Levels</a></li>
<li><a href="#org1fb785a">Q&amp;A</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9687987">GPU Instancing</a>
<ul>
<li><a href="#orgfcf9980">Batching Instances</a>
<ul>
<li><a href="#orge690dc6">简介</a></li>
<li><a href="#org098f3e3">Support GPU Instancing</a></li>
<li><a href="#orgb893b29">Batch Size</a></li>
</ul>
</li>
<li><a href="#org3c26ac8">Mixing Material Properties</a></li>
</ul>
</li>
<li><a href="#orgd09c4d8">Parallax</a>
<ul>
<li><a href="#org85217e4">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaa8c2ce">Advanced Rendering</a>
<ul>
<li><a href="#org549c10f">Flat and Wireframe Shading</a>
<ul>
<li><a href="#org57585f1">Barycentric Coordinates</a></li>
<li><a href="#orgd539200">Q&amp;A</a>
<ul>
<li><a href="#orgb141de7">为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org38e28e3">Tessellation</a>
<ul>
<li><a href="#orgedec0cf">Q&amp;A</a>
<ul>
<li><a href="#orgf5126ef">ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;</a></li>
<li><a href="#org5ed69a6">ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga9a287a">Surface Displacement</a></li>
<li><a href="#org2ebda0c">Bloom</a>
<ul>
<li><a href="#org50704ca">利用 Downsampling Upsampling 模糊图片的原理</a></li>
<li><a href="#org104c11b">Q&amp;A</a>
<ul>
<li><a href="#orgd616864"><span class="todo TODO">TODO</span> 自定义的 Bloom 如何放到 Builtin Uber 中一起计算？在 Builtin Uber 中一起计算的好处是什么？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc7e409f">Depth of Field</a>
<ul>
<li><a href="#orgf548f8b">Bokeh</a></li>
<li><a href="#org2054896">Q&amp;A</a>
<ul>
<li><a href="#org2b0cbdd"><span class="todo TODO">TODO</span> 为什么开启 MSAA 的时候，DOF 效果会错误？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9e3b456">FXAA</a>
<ul>
<li><a href="#org199cfd6">SSAA MSAA</a>
<ul>
<li><a href="#orgfd3886b">Q&amp;A</a></li>
<li><a href="#org141f764">参考资料</a></li>
</ul>
</li>
<li><a href="#orgb4d33e7">参考资源</a></li>
</ul>
</li>
<li><a href="#orgcb4f68f">Triplanar Mapping</a>
<ul>
<li><a href="#orga294219">求解 Normal</a>
<ul>
<li><a href="#org28b20cc">TangentNormal</a></li>
<li><a href="#org49faa74">TangentNormalToWorldNormal WorldNormalToTangentNormal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org44c514b">CustomSRP</a>
<ul>
<li><a href="#orgf5f8f1b">Custom Render Pipeline</a>
<ul>
<li><a href="#orgab65585">架构</a></li>
<li><a href="#orgc7bc45d">CommandBuffer BeginSample EndSample</a></li>
<li><a href="#org6b65349">CameraClearFlags</a></li>
</ul>
</li>
<li><a href="#org145e204">Draw Calls</a>
<ul>
<li><a href="#org5e7a862">Write a HLSL Shader</a>
<ul>
<li><a href="#org30d7b8a">shader 中顶点坐标为什么使用 float4 而不是使用 float3？</a></li>
</ul>
</li>
<li><a href="#org5ea63bb">Batching</a>
<ul>
<li><a href="#orgec3dbed">SRP batcher</a></li>
<li><a href="#org7c2d280">GPU Instancing</a></li>
<li><a href="#orgc940785">Dynamic Batching</a></li>
</ul>
</li>
<li><a href="#org8e2b4f9">Transparency</a></li>
</ul>
</li>
<li><a href="#org3054218">Directianl Lights</a>
<ul>
<li><a href="#orgf3d1fd4">Lighting</a>
<ul>
<li><a href="#orgae7667d">如何可视化光栅化对顶点 normal 线性插值后，normal 不再归一化？</a></li>
</ul>
</li>
<li><a href="#orgc967b24">BRDF</a></li>
</ul>
</li>
<li><a href="#org11801db">Directional Shadows</a>
<ul>
<li><a href="#orga73ba21">Rendering Shadows</a></li>
<li><a href="#org4f623d9">Sampling Shadows</a>
<ul>
<li><a href="#org4557aa2">为什么要使用翻转的 ZBuffer（Reversed-ZBuffer）？</a></li>
<li><a href="#org6225798">ConvertToAtlasMatrix 实现</a></li>
</ul>
</li>
<li><a href="#orga161304">Cascaded Shadow Maps</a>
<ul>
<li><a href="#org464a314">Shadow Fade</a></li>
<li><a href="#org52b26c4">Shadow Quality</a></li>
</ul>
</li>
<li><a href="#org8a24739">Transparency</a></li>
<li><a href="#org94993c5">Q&amp;A</a>
<ul>
<li><a href="#org3e74d61">FrameDebug 中有无限多个</a></li>
<li><a href="#org67a3533">ERROR: Dimensions of color surface does not match dimensions of depth surface</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7d880ec">Baked Light</a>
<ul>
<li><a href="#org126a4ab">Baking Static Light</a></li>
<li><a href="#orgf0e36ae">GPU Instancing 和烘培</a></li>
</ul>
</li>
<li><a href="#org302fcd8">Shadow Masks</a></li>
<li><a href="#orga18d96a">LOD and Reflections</a></li>
<li><a href="#orgf3674ef">Complex Maps</a>
<ul>
<li><a href="#org9c367e8">Q&amp;A</a>
<ul>
<li><a href="#orgab5ad91">贴图设置中的 FadeOut Mip Maps 属性是做什么用的？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc107d94">Point and Spot Lights</a>
<ul>
<li><a href="#org7c9cef1">Lights Per Object</a></li>
<li><a href="#org7861cad">Q&amp;A</a>
<ul>
<li><a href="#org9ed1f07"><span class="todo TODO">TODO</span> 灯光的位置、方向为什么可以通过 localToWorldMatrix 矩阵获取？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org98e275f">Point and Spot Shadows</a>
<ul>
<li><a href="#orgef60f9b">Q&amp;A</a>
<ul>
<li><a href="#org56125df"><span class="todo TODO">TODO</span> 解决 Spot Light Shadow Acne 问题的原理？</a></li>
<li><a href="#org0076128">Unity 渲染 Point Light 阴影时会从上往下渲染，导致渲染的物体为背面，如何转化为正面渲染物体？</a></li>
<li><a href="#org1f3d9d1">Fov Bias 如何求解？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org798ef32">Post Processing</a>
<ul>
<li><a href="#org5e7acbf">CommandBuffer.DrawProcedural</a></li>
<li><a href="#orgda3e57d"><span class="todo TODO">TODO</span> 使用双线性过滤优化高斯模糊的原理是什么？</a></li>
<li><a href="#org41d9645">Bloom 流程</a></li>
</ul>
</li>
<li><a href="#orgf3e1181">HDR</a>
<ul>
<li><a href="#orge1856c0">High Dynamic Range</a>
<ul>
<li><a href="#orgc8b55a5">HDR Post Processing</a></li>
<li><a href="#org4065ebe">Fighting Fireflies</a></li>
</ul>
</li>
<li><a href="#orgd9d2e32">Scattering Bloom</a>
<ul>
<li><a href="#orga66ff4f">Scatter Limits</a></li>
<li><a href="#org069c813">Threshold</a></li>
</ul>
</li>
<li><a href="#org593dbc9">Tone Mapping</a>
<ul>
<li><a href="#org82fada1">Reinhard</a></li>
<li><a href="#org85f1393">Neutral</a></li>
<li><a href="#orgda63b95">ACES</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcc6a376">Color Grading</a>
<ul>
<li><a href="#org2d91a70">Color Adjustments</a>
<ul>
<li><a href="#org99e006e">Post Exposure</a></li>
<li><a href="#orgaa817ce">Constrast Saturate</a></li>
<li><a href="#org468a8bd">Color Filter</a></li>
<li><a href="#orgff465e0">Hue Shift</a></li>
<li><a href="#org5099c70">White Balance</a></li>
<li><a href="#org02ad27a">Split Toning</a></li>
<li><a href="#orga145451">Channel Mixer</a></li>
<li><a href="#orgb443ab9">Shadows Midtones Highlights</a></li>
<li><a href="#orgeff4f72">ACES Color Spaces</a></li>
</ul>
</li>
<li><a href="#orgabaff8d">LUT</a>
<ul>
<li><a href="#org8266af1">LUT Color Matrix</a></li>
<li><a href="#orgce8fc0a">Log C LUT</a></li>
<li><a href="#org50ecf94">Final Pass</a></li>
<li><a href="#org6611605">LUT Banding</a></li>
<li><a href="#orgeb9cf1b">GPU GEMS2 LUT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2c55b3e">Multiple Cameras</a>
<ul>
<li><a href="#org2b85e6d">Combining Cameras</a></li>
<li><a href="#org3bd97fe">Rendering Layers</a></li>
</ul>
</li>
<li><a href="#orgc9d3dea">Particles</a>
<ul>
<li><a href="#orgefdb731">Unlit Particles</a>
<ul>
<li><a href="#orga60c9d8">修改粒子发射器形状</a></li>
<li><a href="#orgb145b3e">粒子帧动画</a></li>
<li><a href="#orgcec656a">粒子渲染模式</a></li>
<li><a href="#orgf6ba6c4">粒子颜色变化</a></li>
<li><a href="#org853e959">自定义 Shader Vertex Steam</a></li>
</ul>
</li>
<li><a href="#org5fbcf0a">Fading Near Camera</a>
<ul>
<li><a href="#orgb16b718">Fragment Depth</a></li>
</ul>
</li>
<li><a href="#orga92083a">Soft Particles</a></li>
<li><a href="#org471b61c">Distortion</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org226db06">MyTest</a>
<ul>
<li><a href="#org6e8507d">TestReplaceShader</a>
<ul>
<li><a href="#orgd1801eb">SetReplacementShader VS RenderWithShader</a></li>
<li><a href="#orgb15cfa6">Q&amp;A</a>
<ul>
<li><a href="#org23c72c2">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd1f1951">BilinearFiltering</a></li>
<li><a href="#org282b7bb">SphereMapping</a>
<ul>
<li><a href="#org3d47b83">参考资料</a></li>
</ul>
</li>
<li><a href="#org9472321">Unity Universal SRP</a>
<ul>
<li><a href="#orgdb14636">Q&amp;A</a>
<ul>
<li><a href="#orgec23edf">为什么 GameView 下摄像机的后处理效果没有生效？</a></li>
</ul>
</li>
<li><a href="#org2ec5c1f">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7924a2d">Q&amp;A</a>
<ul>
<li><a href="#org96b820b">如何判断投影矩阵是否为透视投影？</a></li>
<li><a href="#orgcb3aaf5">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</a></li>
<li><a href="#orgf257532">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</a></li>
<li><a href="#orgcf6d11a">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</a></li>
<li><a href="#org582fc04">为什么点光源阴影需要绘制场景 6 次？</a></li>
<li><a href="#orgbae650a">Renderer.receiveShadows 是如何控制关闭接收阴影的？</a></li>
<li><a href="#org29b5b5b">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</a></li>
</ul>
</li>
<li><a href="#org4aefa31">参考资料</a></li>
</ul>
</div>
</div>
<p>
UnityCatLikeCoding note.<br />
</p>
<div class="HTML">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org417bbbd" class="outline-2">
<h2 id="org417bbbd">UnityCatLikeCoding</h2>
<div class="outline-text-2" id="text-org417bbbd">
</div>
<div id="outline-container-org3218b7c" class="outline-3">
<h3 id="org3218b7c">Rendering</h3>
<div class="outline-text-3" id="text-org3218b7c">
</div>
<div id="outline-container-orgd1aaf2d" class="outline-4">
<h4 id="orgd1aaf2d">Shader Fundamentals</h4>
<div class="outline-text-4" id="text-orgd1aaf2d">
</div>
<div id="outline-container-org48920c8" class="outline-5">
<h5 id="org48920c8">基础知识</h5>
<div class="outline-text-5" id="text-org48920c8">
</div>
<div id="outline-container-org9d2eca8" class="outline-6">
<h6 id="org9d2eca8">MatrixType</h6>
<div class="outline-text-6" id="text-org9d2eca8">
<p>
可以参考 unitycatlikecoding\Rendering\Assets\MyTest\03TestShaderMatrix 工程中的展示效果。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Properties</span>
{
    <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
    [Enum(NotDefineM,0,DefineM,1,DefineMWithVect,2)] DefineMatrix(<span style="color: #2d9574;">"DefineMatrix"</span>, <span style="color: #4f97d7; font-weight: bold;">Float</span>) = 0
}
v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    <span style="color: #ce537a; font-weight: bold;">float4</span> translatedVertex = v.vertex + 0.5;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix != 0)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x4</span> translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );
        <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix == 1)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity shader&#20013;&#21521;&#37327;&#20026;&#21015;&#21521;&#37327;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30697;&#38453;&#27599;&#19968;&#21015;&#34920;&#31034;&#21464;&#25442;&#21518;&#26032;&#22352;&#26631;&#31995;&#30340;&#22522;&#22352;&#26631;&#36724;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">xAxis = &#65288;2,1,0)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">yAxis = &#65288;1,1,0)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zAxis = &#65288;0,0,2)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30452;&#25509;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
            translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
                2, 1, 0, 0,
                1, 1, 0, 0,
                0, 0, 2, 0,
                0, 0, 0, 1
            );
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (DefineMatrix == 2)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#21521;&#37327;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
            <span style="color: #ce537a; font-weight: bold;">float4</span> row0 = <span style="color: #ce537a; font-weight: bold;">float4</span>(2, 1, 0, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row1 = <span style="color: #ce537a; font-weight: bold;">float4</span>(1, 1, 0, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 2, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row3 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 0, 1);
            translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(row0,row1,row2,row3);
        }
        translatedVertex = <span style="color: #4f97d7;">mul</span>(translateM, translatedVertex);
    }
    o.wNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
    o.vertex = UnityObjectToClipPos(translatedVertex);
    o.uv = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> col = 1;
    <span style="color: #ce537a; font-weight: bold;">float3x3</span> colM = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
        1, 1, 0,
        0, 1, 0,
        0, 0, 1
    );
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">colM[0]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;0&#34892;&#30340;&#25968;&#25454;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">colM[2]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;2&#34892;&#30340;&#25968;&#25454;</span>
    col.rgb = colM[0];
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightDir = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col*<span style="color: #4f97d7;">dot</span>(lightDir, i.wNormal);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return col;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org96947b9" class="outline-6">
<h6 id="org96947b9">SV 含义</h6>
<div class="outline-text-6" id="text-org96947b9">
<p>
SV_POSITION、SV_TARGET 中 SV 表示 System Value<br />
SV_TARGET 表示 fragment shader 写入最终颜色值的默认目标对象，其实就是帧缓冲区对象<br />
</p>
</div>
</div>
<div id="outline-container-org39163f9" class="outline-6">
<h6 id="org39163f9">ST 含义</h6>
<div class="outline-text-6" id="text-org39163f9">
<p>
贴图附加的 Tiling 和 Offset 属性。ST 表示 Scale 和 Translation.<br />
</p>
</div>
</div>
<div id="outline-container-org2fcaa28" class="outline-6">
<h6 id="org2fcaa28">贴图坐标系</h6>
<div class="outline-text-6" id="text-org2fcaa28">
<p>
OpenGL 坐标原点在左下角<br />
D3D 坐标原点在左上角<br />
</p>
</div>
</div>

<div id="outline-container-orgd57e69b" class="outline-6">
<h6 id="orgd57e69b">MipMap 和 FilterMode</h6>
<div class="outline-text-6" id="text-orgd57e69b">
<p>
MipMap       用于处理贴图图元密度大于像素密度的情况，一个像素对应多个贴图图元时，如果没有 mipmap，在多个贴图图元中采用一个图元而丢弃其他。有 mipmap 时，则使用更低分辨率的贴图让 像素密度和贴图密度相接近。<br />
FilterMode   用于处理贴图图元密度小于像素密度的情况，采样器会对靠近采样点的图元进行采样，然后对这些图元进行插值，来得到最终颜色值。<br />
</p>

<p>
Bilinear texture filtering  会对靠近采样点的四个图元进行加权平均。<br />
</p>

<p>
<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering</a><br />
</p>
</div>
</div>
<div id="outline-container-org4e97d7e" class="outline-6">
<h6 id="org4e97d7e">TRANSFORM_TEX</h6>
<div class="outline-text-6" id="text-org4e97d7e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#26041;&#27861;&#23450;&#20041;&#22312; UnityCG.cginc</span>
<span style="color: #bc6ec5;">#define</span> TRANSFORM_TEX(tex,name) (tex.xy * name##<span style="color: #7590db;">_ST</span>.xy + name##<span style="color: #7590db;">_ST</span>.zw)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfeded0d" class="outline-6">
<h6 id="orgfeded0d">tex2Dbias tex2Dlod</h6>
<div class="outline-text-6" id="text-orgfeded0d">
<p>
tex2Dbias(s, t) : Samples a 2D texture after biasing the mip level by t.w.<br />
tex2Dlod(s, t)  : Samples a 2D texture with mipmaps. The mipmap LOD is specified in t.w.<br />
</p>

<ul class="org-ul">
<li>tex2Dbias <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias</a><br /></li>
<li>tex2Dlod <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod</a><br /></li>
<li><a href="https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/">https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc61ad21" class="outline-6">
<h6 id="orgc61ad21">lerp 函数意义</h6>
<div class="outline-text-6" id="text-orgc61ad21">

<div class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp.png" alt="00_lerp.png" /><br />
</p>
</div>

<p>
x = 0 时，y = p; x = 1 时，y = q;<br />
lerp(p, q, x) lerp(p(1-x), q, x) lerp(p(1-x)^2, q, x) 三个函数，依次减弱 p 的效果。<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp_func.png" alt="00_lerp_func.png" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/00_lerp_func.ggb">./UnityCatLikeCoding/00_lerp_func.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org6a47ab1" class="outline-6">
<h6 id="org6a47ab1">ddx ddy</h6>
<div class="outline-text-6" id="text-org6a47ab1">
<p>
ddx(var_i) 求出 var_i 变量在当前像素块 x 方向的变化量<br />
ddy(var_i) 求出 var_i 变量在当前像素块 y 方向的变化量<br />
</p>

<ul class="org-ul">
<li><a href="http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104">http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2f1e1be" class="outline-6">
<h6 id="org2f1e1be">fwidth</h6>
<div class="outline-text-6" id="text-org2f1e1be">
<p>
fwidth(var_i) = abs(ddx(var_i)) + abs(ddy(var_i))<br />
</p>
</div>
</div>
<div id="outline-container-orgec78f5e" class="outline-6">
<h6 id="orgec78f5e">smoothstep</h6>
<div class="outline-text-6" id="text-orgec78f5e">
<p>
smoothstep(a, b, c) 在 a-b 范围进行插值，c&lt;=a 返回 0，c&gt;=b 返回 1<br />
</p>

<p>
t = (c-a)/(b-a)<br />
t = saturate(t)<br />
result = 3t^2 - 2t^3<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/00_smoothstep.png" alt="00_smoothstep.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org67dca4a" class="outline-5">
<h5 id="org67dca4a">Shader Semantics</h5>
<div class="outline-text-5" id="text-org67dca4a">
</div>
<div id="outline-container-orgb6a998f" class="outline-6">
<h6 id="orgb6a998f">Screen space pixel position: VPOS</h6>
<div class="outline-text-6" id="text-orgb6a998f">
<p>
VPOS 输出的变量中保存的是屏幕像素点坐标，坐标值为整数值。<br />
VPOS 和 SV_POSITION 不能同时出现在 vout 中，需要使用 fin 将两者分离。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Screen Position"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0
<span style="color: #bc6ec5;">            #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
            <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata 
            {
                <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
            };

            <span style="color: #4f97d7; font-weight: bold;">struct</span> vout {
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                <span style="color: #ce537a; font-weight: bold;">float4</span> outpos : <span style="color: #a45bad;">SV_POSITION</span>;
            };

            <span style="color: #4f97d7; font-weight: bold;">struct</span> fin 
            {
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                UNITY_VPOS_TYPE screenPos : <span style="color: #a45bad;">VPOS</span>;
            };

<span style="color: #bc6ec5;">            #define</span> vert_out vout
<span style="color: #bc6ec5;">            #define</span> frag_in fin

            vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata i)
            {
                vert_out o;
                o.uv = i.uv;
                o.outpos = UnityObjectToClipPos(i.vertex);
                <span style="color: #4f97d7; font-weight: bold;">return</span> o;
            }

            <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (frag_in i) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">screenPos.xy will contain pixel integer coordinates.</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return i.screenPos.x &lt; _ScreenParams.x/2 ? 0 : 1;</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use them to implement a checkerboard pattern that skips rendering</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4x4 blocks of pixels</span>

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">checker value will be negative for 4x4 blocks of pixels</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in a checkerboard pattern</span>
                i.screenPos.xy = <span style="color: #4f97d7;">floor</span>(i.screenPos.xy * 0.25) * 0.5;
                <span style="color: #ce537a; font-weight: bold;">float</span> checker = -<span style="color: #4f97d7;">frac</span>(i.screenPos.r + i.screenPos.g);

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">clip HLSL instruction stops rendering a pixel if value is negative</span>
                <span style="color: #4f97d7;">clip</span>(checker);

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">for pixels that were kept, read the texture and output it</span>
                <span style="color: #ce537a; font-weight: bold;">fixed4</span> c = <span style="color: #4f97d7;">tex2D</span> (<span style="color: #7590db;">_MainTex</span>, i.uv);
                <span style="color: #4f97d7; font-weight: bold;">return</span> c;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcb1bae6" class="outline-6">
<h6 id="orgcb1bae6">Face orientation: VFACE</h6>
<div class="outline-text-6" id="text-orgcb1bae6">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Face Orientation"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_ColorFront</span> (<span style="color: #2d9574;">"Front Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (1,0.7,0.7,1)
        <span style="color: #7590db;">_ColorBack</span> (<span style="color: #2d9574;">"Back Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (0.7,1,0.7,1)
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">turn off backface culling</span>

            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0

            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">vert</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>) : <span style="color: #a45bad;">SV_POSITION</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
            }

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorFront</span>;
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorBack</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (<span style="color: #ce537a; font-weight: bold;">fixed</span> facing : <span style="color: #a45bad;">VFACE</span>) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VFACE input positive for frontbaces,</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">negative for backfaces. Output one</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of the two colors depending on that.</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> facing &gt; 0 ? <span style="color: #7590db;">_ColorFront</span> : <span style="color: #7590db;">_ColorBack</span>;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org18c08b1" class="outline-6">
<h6 id="org18c08b1">参考资料</h6>
<div class="outline-text-6" id="text-org18c08b1">
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge8895c3" class="outline-5">
<h5 id="orge8895c3">Unity 定义的变量</h5>
<div class="outline-text-5" id="text-orge8895c3">
<p>
_WorldSpaceLightPos0      世界空间 Light 位置<br />
_LightColor0              Light 颜色<br />
_WorldSpaceCameraPos      世界坐标摄像机位置<br />
_LightTexture0            Light 没有使用 Cookie 时，该变量存储衰减贴图。使用了 Cookie 时，存储 Cookie 贴图。 (Directional Light 没有衰减贴图)<br />
_LightTextureB0           Light 使用了 Cookie 时，该变量存储衰减贴图。 (Directional Light 没有衰减贴图)<br />
</p>

<p>
unity_WorldToShadow       float4x4[4]	用于 spot lights 或 方向光的 4 级级联阴影<br />
</p>

<p>
_LightShadowData          // 参考有道笔记 UnitySourceCode.md<br />
</p>

<p>
_ProjectionParams         <i>/ x=1 or -1  y=near z=far w=1/far<br />
_ScreenParams             /</i> x=widthPixels y=heightPixels z=1.0+1.0/width w=1.0+1.0/height<br />
_ZBufferParams 						<i>/ 用于线性化 ZBuffer 中的值，<br />
                          /</i> x=1-far/near<br />
                          <i>/ y=far/near<br />
                          /</i> z=x/far=(1-far)/(near*far)<br />
                          // w=y/far=(1/near)<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">zc0</span>, <span style="color: #7590db;">zc1</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL would be this:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc0 = (1.0 - m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc1 = (1.0 + m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">D3D is this:</span>
zc0 = 1.0 - m_FarClip / m_NearClip;
zc1 = m_FarClip / m_NearClip;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now set _ZBufferParams with (zc0, zc1, zc0/m_FarClip, zc1/m_FarClip);</span>
</pre>
</div>

<p>
unity_SpecCube0_ProbePosition   第一个反射探针的位置，如果场景中不存在反射探针，则默认传递环境反射(Lighting / Environment Reflections / Source 下可以设置环境反射)的数据，环境反射。<br />
unity_SpecCube0_BoxMin          第一个反射探针对应的 Box 在世界空间中坐标最小值，反射探针为环境反射时，该值为 (Infinity, Infinity, Infinity, 1)<br />
unity_SpecCube0_BoxMax          第一个反射探针对应的 Box 在世界空间中坐标最大值，反射探针为环境反射时，该值为 (-Infinity, -Infinity, -Infinity, 1)<br />
unity_SpecCube0_BoxMin.w        存储了第一个反射探针和第二个反射探针的插值比例，1 表示全部使用第一个反射探针，0 表示全部使用第二个反射探针.(只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合)<br />
unity_SpecCube0_HDR.r           存储了反射探针的强度，对应反射探针的 Runtime setting/Intensity 和 Lighting/Scene/EnvironmentReflections/IntensityMultiplier(IntensityMultiplier 只是 Intensity 的系数，所以 FrameDebug 中看到的值和该值并不同)<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_08re_default_env_reflection_data.png" alt="01_08re_default_env_reflection_data.png" /><br />
</p>
</div>


<p>
<a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a><br />
</p>
<ul class="org-ul">
<li>_ZBufferParams values? <a href="https://forum.unity.com/threads/_zbufferparams-values.39332/">https://forum.unity.com/threads/_zbufferparams-values.39332/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc450572" class="outline-5">
<h5 id="orgc450572">Unity Shader 定义的宏</h5>
<div class="outline-text-5" id="text-orgc450572">
<p>
UNITY_COMPILER_HLSL                            使用 HLSL 编译时，定义该宏(for D3D or GLCore/GLES3/GLES platforms)<br />
UNITY_COMPILER_HLSL2GLSL                       使用 hlsl2glsl 编译时，定义该宏<br />
UNITY_COMPILER_CG                              使用 NVIDIA 的 Cg<br />
</p>

<p>
<a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a><br />
<a href="https://docs.unity3d.com/Manual/SL-ShadingLanguage.html">https://docs.unity3d.com/Manual/SL-ShadingLanguage.html</a><br />
</p>

<p>
UNITY_ENABLE_REFLECTION_BUFFERS                TODO-How?  延迟渲染模式下，延迟渲染反射球时会设置该变量开启。延迟渲染模式下，默认该变量是开启的，在 Graphics Settings 中将 DeferredReflections 选项选为 NoSupport 即可关闭。<br />
<a href="https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html">https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html</a><br />
</p>

<p>
UNITY_USE_NATIVE_HDR                           查看 2019 版本的源代码发现相关代码被注释掉了，UNITY_USE_NATIVE_HDR 应该永远都不会被开启<br />
</p>
<ul class="org-ul">
<li>UNITY_USE_NATIVE_HDR <a href="https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6">https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb82e22f" class="outline-5">
<h5 id="orgb82e22f">Unity Shader Compiler</h5>
<div class="outline-text-5" id="text-orgb82e22f">
<ul class="org-ul">
<li>Windows &amp; Microsoft platforms (DX11, DX12 and Xbox One) all use Microsoft’s HLSL compiler (currently d3dcompiler_47).<br /></li>
<li>OpenGL Core , OpenGL ES 3, OpenGL ES 2.0 and Metal use Microsoft’s HLSL followed by bytecode translation into GLSL or Metal, using HLSLcc.<br /></li>
<li>OpenGL ES 2.0 can use source level translation via hlsl2glslfork and glsl optimizer. This is enabled by adding #pragma prefer_hlsl2glsl gles<br /></li>
<li>Other console platforms use their respective compilers (e.g. PSSL on PS4).<br /></li>
<li>Surface Shaders use Cg 2.2 and MojoShader for code generation analysis step.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc490f8a" class="outline-5">
<h5 id="orgc490f8a">Unity shader 预编译命令</h5>
</div>
<div id="outline-container-orgd96cdb4" class="outline-5">
<h5 id="orgd96cdb4">D3D11 汇编命令</h5>
<div class="outline-text-5" id="text-orgd96cdb4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mul result opt1 opt2</td>
<td class="org-left">opt1 乘 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">add result opt1 opt2</td>
<td class="org-left">opt1 加 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mad result opt1 opt2 opt3</td>
<td class="org-left">opt1 乘 opt2 再加 opt3 保存结果到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mov result opt1</td>
<td class="org-left">将 opt1 数据保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_sampler s0, mode_default</td>
<td class="org-left">创建贴图采样对象 s0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_resource_texture2d(float,float,float,float) t0</td>
<td class="org-left">创建 2D 贴图资源 t0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sample result.xyzw, uv.xyxx, t0.xyzw, s0</td>
<td class="org-left">使用 s0 采样器以 uv 为贴图坐标，对贴图资源 t0 进行采样将结果保存到 result 中</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org4de9b93" class="outline-4">
<h4 id="org4de9b93">Combining Textures</h4>
<div class="outline-text-4" id="text-org4de9b93">
</div>
<div id="outline-container-org4423698" class="outline-5">
<h5 id="org4423698">Linear Color Space</h5>
<div class="outline-text-5" id="text-org4423698">
</div>
<div id="outline-container-org4c6e310" class="outline-6">
<h6 id="org4c6e310">Linear Color Space 原理</h6>
<div class="outline-text-6" id="text-org4c6e310">
<p>
Gamma space 是指经过 gamma 矫正的颜色。gamma 矫正是对光照亮度的调整。最简单的方式是提升原始值某次幂，如 \(originalValue^{gamma}\) 。<br />
gamma=1 表示没有改变。gamma=2 表示对原始值求平方。<br />
</p>

<p>
这种转换原本是为了适应非线性的 CRT 显示器的。一个附加的好处是这种转换刚好和我们眼睛对不同光强度的敏感程度相一致。人眼对不同的暗的颜色要比不同的亮的颜色更加敏感。所以使用更多位数字存储暗颜色是很有意义的，求幂运算可以实现该需求，它会将比较小的值扩展到一个更大的范围，同时将较大的值压缩到一个小的范围。<br />
</p>

<p>
运用最广泛的图片颜色格式是 sRGB.<br />
</p>
<ul class="org-ul">
<li>Encoding with gamma 1/2.2 即 \(originalValue^{\frac{1}{2.2}} = originalValue^{0.45}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear-to-gamma.png" alt="01_03ct_linear-to-gamma.png" /><br /></li>
<li>Decoding with gamma 2.2 即 \(originalValue^{2.2}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma-to-linear.png" alt="01_03ct_gamma-to-linear.png" /><br /></li>
<li>伽马矫正函数图示<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_correct.png" alt="01_03ct_gamma_correct.png" /><br /></li>
</ul>

<p>
横坐标为编码前的颜色值，纵坐标为编码后的颜色值。蓝色的线表示线性编码前后颜色值不变。红色的线表示 Gamma 编码前后颜色值变大。以 0.5 为分界线，Gamma 编码后，[0-0.5] 被扩展到了 [0-0.7297&#x2026;] [0.5-1] 被压缩到了 [0.7297&#x2026; - 1]。Gamma 编码的图片要比 Linear 编码的图片亮度高。<br />
</p>

<p>
下面的 HTML 可用于 GammaToLinear 转换<br />
</p>
<div class="org-src-container">
<pre class="src src-html"><span style="color: #2d9574;">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
    &lt;<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;<span style="font-weight: bold; font-style: italic; text-decoration: underline;">&#39068;&#33394;&#36716;&#25442;</span>&lt;/<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"originColor"</span>&gt;
            TD &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oR"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oG"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oB"</span> value =<span style="color: #2d9574;">"64"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"newColor"</span>&gt;
            Qin &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nR"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nG"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nB"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">button</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"button"</span> <span style="color: #7590db;">onclick</span>=<span style="color: #2d9574;">'convertColor()'</span>&gt;&#36716;&#25442;&lt;/<span style="color: #bc6ec5; font-weight: bold;">button</span>&gt;
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

    &lt;<span style="color: #bc6ec5; font-weight: bold;">script</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text/javascript"</span>&gt;
     function convertColor()
     {
         var r = document.getElementById("oR").value / 255;
         var g = document.getElementById("oG").value / 255;
         var b = document.getElementById("oB").value / 255;

         //window.alert("test = " + r + b + g);
         document.getElementById("nR").value = Math.round(Math.pow(r, 1/2.2) * 255);
         document.getElementById("nG").value = Math.round(Math.pow(g, 1/2.2) * 255);
         document.getElementById("nB").value = Math.round(Math.pow(b, 1/2.2) * 255);
     }
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">script</span>&gt;

&lt;/<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GammaToLinearSpace(col.rgb);  &#19979;&#38754;&#20195;&#30721;&#26159; GammaToLinearSpace &#30340;&#27719;&#32534;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat1.xyz = u_xlat0.xyz * u_xlat1.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LinearToGammaSpace(col.rgb); &#19979;&#38754;&#20195;&#30721;&#26159; LinearToGammaSpace &#30340;&#27719;&#32534;&#20195;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat16_1.xyz = <span style="color: #4f97d7;">max</span>(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat16_2.xyz = <span style="color: #4f97d7;">log2</span>(u_xlat16_1.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat16_2.xyz = <span style="color: #4f97d7;">exp2</span>(u_xlat16_2.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = <span style="color: #4f97d7;">max</span>(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#26159; &#22270;&#29255;Gamma&#21644;Linear&#36716;&#25442;&#24037;&#20855;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">System.Collections</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">System.Collections.Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">UnityEditor</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">LinearGammaConvert</span> : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">_assetPathList</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt;();
    [<span style="color: #ce537a; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageLinearToGamma"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> LinearToGamma()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        GetSelectionPathList(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            ConvertBetweenLinearGamma(path, <span style="color: #a45bad;">true</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }

    [<span style="color: #ce537a; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageGammaToLinear"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> GammaToLinear()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        GetSelectionPathList(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            ConvertBetweenLinearGamma(path, <span style="color: #a45bad;">false</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(<span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">pathList</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(Selection.objects!=<span style="color: #a45bad;">null</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">obj</span> <span style="color: #4f97d7; font-weight: bold;">in</span> Selection.objects)
            {
                <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">GetAssetPath</span>(obj);
                <span style="color: #4f97d7; font-weight: bold;">if</span>(!<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(path))
                {
                    pathList.<span style="color: #bc6ec5; font-weight: bold;">Add</span>(path);
                }
            }
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">imgPath</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isToGamma</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(imgPath)) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">textureImportor</span> = AssetImporter.<span style="color: #bc6ec5; font-weight: bold;">GetAtPath</span>(imgPath) <span style="color: #4f97d7; font-weight: bold;">as</span> <span style="color: #ce537a; font-weight: bold;">TextureImporter</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (textureImportor == <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        textureImportor.isReadable = <span style="color: #a45bad;">true</span>;
        textureImportor.sRGBTexture = !isToGamma;
        textureImportor.textureCompression = TextureImporterCompression.Uncompressed;
        textureImportor.<span style="color: #bc6ec5; font-weight: bold;">SaveAndReimport</span>();

        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">texture</span> = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(imgPath);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">gammaValue</span> = isToGamma ? 0.4545f : 2.2f;
        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">pixels</span> = texture.<span style="color: #bc6ec5; font-weight: bold;">GetPixels</span>();
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">i</span>=0; i&lt;pixels.Length; i++)
        {

            pixels[i].r = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].r, gammaValue);
            pixels[i].g = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].g, gammaValue);
            pixels[i].b = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].b, gammaValue);
        }
        texture.<span style="color: #bc6ec5; font-weight: bold;">SetPixels</span>(pixels);
        texture.<span style="color: #bc6ec5; font-weight: bold;">Apply</span>();
        System.IO.File.<span style="color: #bc6ec5; font-weight: bold;">WriteAllBytes</span>(imgPath, texture.<span style="color: #bc6ec5; font-weight: bold;">EncodeToTGA</span>());
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1e440c1" class="outline-6">
<h6 id="org1e440c1">DetailTex 叠加到 MainTex 上为什么需要乘二？</h6>
<div class="outline-text-6" id="text-org1e440c1">
<p>
MainTex 颜色范围为[0-1] DetailTex 颜色范围也为[0-1], 如果将 DetailTex 制作为灰度图并且颜色值取 0.5，那么 MainTex*DetailTex*2 可以保证图片亮度不会变化。DetailTex 颜色值小于 0.5 的地方就会减低颜色亮度，大于 0.5 的地方就会提高颜色亮度。<br />
但是，当 Unity 引擎切换到线性空间，乘二是不正确的。DetailTex 转化为线性空间时，0.5 的 DetailTex 颜色值会变为 \(0.5^{2.2}=0.2176\) ,乘二后为 0.4352, 所以颜色亮度会减低。最好的解决方案是当 Unity 引擎切换到线性空间时，应该乘 \(frac{1}{0.5^{2.2}}=frac{1}{0.2176}=4.5956\)<br />
Unity 中 unity_ColorSpaceDouble 用来处理不同的颜色空间乘不同的值。<br />
</p>
</div>
</div>
<div id="outline-container-orgc69b3b8" class="outline-6">
<h6 id="orgc69b3b8">SetVector SetColor</h6>
<div class="outline-text-6" id="text-orgc69b3b8">
<p>
GammaSpace 下，SetVector SetColor 效果没有差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_SetValue.png" alt="01_03ct_gamma_SetValue.png" /><br />
LinearSpace 下，SetVector SetColor 效果会有明显差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear_SetValue.png" alt="01_03ct_linear_SetValue.png" /><br />
</p>

<p>
编辑器中设置的值和 Shader Property List 中设置的值是相同的。<br />
线性空间下，通过 SetColor 传入的值被认为是经过 Gamma=1/2.2=0.4545 编码的值，Unity 引擎会对该值进行 Gamma=2.2 的编码(对 Gamma=1/2.2 进行解码)，从而将 Gamma 空间的值转换为线性空间。所以，SetVector(0.5^2.2, 0, 0, 0) 和 SetColor(0.5, 0, 0, 0)的效果是等价的。<br />
</p>

<ul class="org-ul">
<li>官网文档说明 <a href="https://docs.unity3d.com/ScriptReference/Material.SetVector.html">https://docs.unity3d.com/ScriptReference/Material.SetVector.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org64cf57d" class="outline-6">
<h6 id="org64cf57d">参考资料</h6>
<div class="outline-text-6" id="text-org64cf57d">
<ul class="org-ul">
<li>Gamma 空间是什么，为什么我们需要它 <a href="https://blog.csdn.net/qq_18229381/article/details/78053018">https://blog.csdn.net/qq_18229381/article/details/78053018</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org82d763d" class="outline-4">
<h4 id="org82d763d">The First Light</h4>
<div class="outline-text-4" id="text-org82d763d">
</div>
<div id="outline-container-org0c47246" class="outline-5">
<h5 id="org0c47246">normal 从物体空间到世界空间的变换</h5>
<div class="outline-text-5" id="text-org0c47246">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">obj to world</span>
i.normal = <span style="color: #4f97d7;">mul</span>(<span style="color: #4f97d7;">transpose</span>((<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject), v.normal);

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float3</span> UnityObjectToWorldNormal( <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float3</span> norm )
{
<span style="color: #bc6ec5;">#ifdef</span> UNITY_ASSUME_UNIFORM_SCALING
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToWorldDir</span>(norm);
<span style="color: #bc6ec5;">#else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25913;&#21464;&#24038;&#20056; &#21491;&#20056;&#39034;&#24207; &#31561;&#20215;&#20110; &#30697;&#38453;&#36716;&#32622;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mul(IT_M, norm) =&gt; mul(norm, I_M) =&gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)}</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(<span style="color: #4f97d7;">mul</span>(norm, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject));
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga6b64d0" class="outline-5">
<h5 id="orga6b64d0">Tags LightMode=ForwardBase</h5>
<div class="outline-text-5" id="text-orga6b64d0">
<p>
定义该 Tags 才可以在 shader 中访问场景中主方向光的信息。<br />
</p>
</div>
</div>

<div id="outline-container-org6d77721" class="outline-5">
<h5 id="org6d77721">BlinnPhong</h5>
<div class="outline-text-5" id="text-org6d77721">
<p>
视角不逆光时的显示效果如下：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone.png" alt="01_04fl_blinnphone.png" /><br />
</p>

<p>
视角逆光时会有显示错误。错误如下图：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone_error.png" alt="01_04fl_blinnphone_error.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org1f5e31e" class="outline-5">
<h5 id="org1f5e31e">Energy Conservation</h5>
<div class="outline-text-5" id="text-org1f5e31e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Unity &#23454;&#29616;&#30340;&#33021;&#37327;&#23432;&#24658; UnityStandardUtils.cginc</span>

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc141fc9" class="outline-5">
<h5 id="orgc141fc9">Specular / Metallic Workflow</h5>
<div class="outline-text-5" id="text-orgc141fc9">
</div>
<div id="outline-container-org8659f93" class="outline-6">
<h6 id="org8659f93">Specular Workflow</h6>
<div class="outline-text-6" id="text-org8659f93">
<p>
Specular Workflow 中将 Specular Color 的强度提高来实现金属材质。将 Specular Color 的强度减弱来实现非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;&#26159; Specular Workflow</span>
<span style="color: #bc6ec5;">#ifndef</span> UNITY_SETUP_BRDF_INPUT
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT SpecularSetup
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData SpecularSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> specGloss = SpecularGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor = specGloss.rgb;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = specGloss.a;

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = EnergyConservationBetweenDiffuseAndSpecular (Albedo(i_tex), specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524; specColor &#19981;&#26159;&#28784;&#24230;&#22270;&#65292;diffuse &#39068;&#33394;&#20250;&#26174;&#31034;&#24322;&#24120;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3812239" class="outline-6">
<h6 id="org3812239">Metallic Workflow</h6>
<div class="outline-text-6" id="text-org3812239">
<p>
Metallic Workflow 中通过金属度来实现金属和非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#33258;&#24049;&#30340; shader &#20013;&#23450;&#20041; UNITY_SETUP_BRDF_INPUT = MetallicSetup &#26469;&#25351;&#23450;&#20351;&#29992; Metallic &#27969;&#31243;</span>
<span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT MetallicSetup
<span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData MetallicSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half2</span> metallicGloss = MetallicGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half</span> metallic = metallicGloss.x;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = metallicGloss.y; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this is 1 minus the square root of real roughness m.</span>

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = DiffuseAndSpecularFromMetallic (Albedo(i_tex), metallic, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DiffuseAndSpecularFromMetallic (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half</span> metallic, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    specColor = <span style="color: #4f97d7;">lerp</span> (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);
    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24120;&#37327;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.5, 0.5, 0.5, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(2.0, 2.0, 2.0, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.22, 0.707, 0.071, 0.0) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Legacy: alpha is set to 0.0 to specify gamma mode</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear values</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.214041144, 0.214041144, 0.214041144, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(4.59479380, 4.59479380, 4.59479380, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.04, 0.04, 0.04, 1.0 - 0.04) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">standard dielectric reflectivity coef at incident angle (= 4%)</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.0396819152, 0.458021790, 0.00609653955, 1.0) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Legacy: alpha is set to 1.0 to specify linear mode</span>
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> OneMinusReflectivityFromMetallic(<span style="color: #ce537a; font-weight: bold;">half</span> metallic)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">We'll need oneMinusReflectivity, so</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">store (1-dielectricSpec) in unity_ColorSpaceDielectricSpec.a, then</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//                  </span><span style="color: #2aa1ae; background-color: #292e34;">= alpha - metallic * alpha</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusDielectricSpec = unity_ColorSpaceDielectricSpec.a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc592ae3" class="outline-4">
<h4 id="orgc592ae3">Multi Lights</h4>
<div class="outline-text-4" id="text-orgc592ae3">
</div>
<div id="outline-container-org7568ebd" class="outline-5">
<h5 id="org7568ebd">Light Coord</h5>
<div class="outline-text-5" id="text-org7568ebd">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord4 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex));
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    ( (a.<span style="color: #7590db;">_LightCoord</span>.z &gt; 0) * UnitySpotCookie(a.<span style="color: #7590db;">_LightCoord</span>) * UnitySpotAttenuate(a.<span style="color: #7590db;">_LightCoord</span>.xyz) * SHADOW_ATTENUATION(a) )
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx)
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a)
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a)
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord2 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xy;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#define</span> UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2)
<span style="color: #bc6ec5;">#define</span> LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2)
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vertex shader &#20013;&#65292;&#35745;&#31639;_LightCoord</span>
<span style="color: #bc6ec5;">#define</span> UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord)
<span style="color: #bc6ec5;">#define</span> TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgedb9ae1" class="outline-5">
<h5 id="orgedb9ae1">Light Attenuation</h5>
<div class="outline-text-5" id="text-orgedb9ae1">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
    unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \
    <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25353;&#29031;&#36317;&#31163;&#30340;&#24179;&#26041;&#34928;&#20943;</span>
    <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
    <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotCookie(unityShadowCoord4 LightCoord)
    {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679;&#26102;&#20174;&#40784;&#27425;&#22352;&#26631;&#31995;&#36716;&#25442;&#21040;&#27431;&#25289;&#22352;&#26631;&#31995;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20559;&#31227; 0.5 &#36825;&#26679;&#28783;&#20809;&#22352;&#26631;&#31995;&#21407;&#28857;&#23601;&#21644;&#22270;&#29255;&#20013;&#24515;&#28857;&#23545;&#24212;&#20102;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, LightCoord.xy / LightCoord.w + 0.5).w;
    }
    <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotAttenuate(unityShadowCoord3 LightCoord)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(LightCoord, LightCoord).xx).r;
    }
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1))
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = (lightCoord.z &gt; 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = UNITY_SHADOW_ATTENUATION(input, worldPos);
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
    <span style="color: #ce537a; font-weight: bold;">samplerCUBE_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
  <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
  unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">      #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xy
<span style="color: #bc6ec5;">  #else</span>
<span style="color: #bc6ec5;">      #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
      DECLARE_LIGHT_COORD(input, worldPos); \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
<div id="outline-container-org9b9b8bf" class="outline-6">
<h6 id="org9b9b8bf">Point Light</h6>
<div class="outline-text-6" id="text-org9b9b8bf">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> lightVector = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz - i.worldPos;
light.dir = <span style="color: #4f97d7;">normalize</span>(lightVector);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20998;&#27597;&#20013;&#21152; 1 &#26159;&#20026;&#20102;&#36991;&#20813;&#29289;&#20307;&#21040;&#20809;&#28304;&#36317;&#31163;&#23567;&#20110; 1 &#26102;&#65292;&#20809;&#29031;&#24378;&#24230;&#34987;&#25918;&#22823;</span>
<span style="color: #ce537a; font-weight: bold;">half</span> attenuation = 1 / (1 + <span style="color: #4f97d7;">dot</span>(lightVector, lightVector));
light.color = <span style="color: #7590db;">_LightColor0</span>.rgb * attenuation;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org16da472" class="outline-5">
<h5 id="org16da472">Mixing Lights</h5>
<div class="outline-text-5" id="text-org16da472">
<p>
通过增加 shader 变体来实现对混合灯光的支持。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT
</pre>
</div>
</div>
</div>
<div id="outline-container-org5c3eadd" class="outline-5">
<h5 id="org5c3eadd">Cookies</h5>
<div class="outline-text-5" id="text-org5c3eadd">
<p>
Spot Light 默认支持 Cookie，Spot Light 的形状是通过 Cookie 来实现。SpotLight 的 Cookie 贴图的 Wrap 模式采用 Clamp。<br />
Direcional 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图的 Wrap 模式采用 Repeat。<br />
Point 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图是 Cube 贴图，Wrap 模式采用 Clamp。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#31561;&#20215;&#20110;  #pragma multi_compile_fwdadd</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT DIRECTIONAL_COOKIE POINT_COOKIE
</pre>
</div>

<ul class="org-ul">
<li>multi_compile_fwdbase 变体 <a href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3140bde" class="outline-5">
<h5 id="org3140bde">Vertex Lights</h5>
<div class="outline-text-5" id="text-org3140bde">
<p>
灯光数量增加后，drawcall 数量会成倍增加。Unity 可以设置逐像素光照的数量。如果将超出数量限制的光照直接不进行计算，会导致明显的显示错误，可以采用更廉价的顶点光照来代替像素光照。<br />
Unity 在 Base Pass 中实现顶点光照。引擎会寻找包含 VERTEXLIGHT_ON 关键字的 Base Pass 着色器。<br />
顶点光照只支持 点光源，方向光和聚光灯都能在顶点着色器中计算。<br />
在 Light 的 RenderMode 属性中，可以设置重要类型，Important 类型的光照总是逐像素光照，Not Important 类型的光照永远不会被当作逐像素光照，Auto 类型的光照其重要性由引擎来决定。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UnityCG.cginc</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#20989;&#25968;&#36820;&#22238;&#20102;4&#20010;&#28857;&#20809;&#28304;&#23545;&#20110;&#24403;&#21069;&#39030;&#28857;&#30340;&#32508;&#21512;&#20809;&#29031;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#39030;&#28857;&#20013;&#35745;&#31639; 4 &#20010;&#28857;&#20809;&#28304;&#20809;&#29031;&#65292;&#24403;&#20809;&#28304;&#25968;&#30446;&#19981;&#36275; 4 &#20010;&#26102;&#65292;&#35745;&#31639;&#28040;&#32791;&#20381;&#28982;&#26159; 4 &#20010;&#20809;&#29031;&#30340;&#35745;&#31639;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way.</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">Shade4PointLights</span> (
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosX, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosY, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosZ,
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor0, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor1, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor2, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor3,
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightAttenSq,
    <span style="color: #ce537a; font-weight: bold;">float3</span> pos, <span style="color: #ce537a; font-weight: bold;">float3</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to light vectors</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightX = lightPosX - pos.x;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightY = lightPosY - pos.y;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightZ = lightPosZ - pos.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">squared lengths</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> lengthSq = 0;
    lengthSq += toLightX * toLightX;
    lengthSq += toLightY * toLightY;
    lengthSq += toLightZ * toLightZ;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don't produce NaNs if some vertex position overlaps with the light</span>
    lengthSq = <span style="color: #4f97d7;">max</span>(lengthSq, 0.000001);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> ndotl = 0;
    ndotl += toLightX * normal.x;
    ndotl += toLightY * normal.y;
    ndotl += toLightZ * normal.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">correct NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> corr = <span style="color: #4f97d7;">rsqrt</span>(lengthSq);
    ndotl = <span style="color: #4f97d7;">max</span> (<span style="color: #ce537a; font-weight: bold;">float4</span>(0,0,0,0), ndotl * corr);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">attenuation lightAttenSq &#29992;&#20110;&#25913;&#36827;&#39030;&#28857;&#20809;&#29031;&#30340;&#25928;&#26524;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
    <span style="color: #ce537a; font-weight: bold;">float4</span> diff = ndotl * atten;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">final color</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> col = 0;
    col += lightColor0 * diff.x;
    col += lightColor1 * diff.y;
    col += lightColor2 * diff.z;
    col += lightColor3 * diff.w;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd9003e7" class="outline-5">
<h5 id="orgd9003e7">Spherical Harmonics</h5>
<div class="outline-text-5" id="text-orgd9003e7">
</div>
<div id="outline-container-orga923c16" class="outline-6">
<h6 id="orga923c16">相关数学概念</h6>
<div class="outline-text-6" id="text-orga923c16">
<ul class="org-ul">
<li>球谐函数 是拉普拉斯方程的球坐标系形式解的角度部分。拉普拉斯方程在球坐标系中的表达式分离变量之后，角度部分的偏微分方程称为球函数方程。<br /></li>
<li>球坐标系 球坐标系是三维坐标系的一种，用以确定三维空间中点、线、面以及体的位置，它以坐标原点为参考点，由方位角、仰角和距离构成。球坐标系在地理学、天文学中都有着广泛应用。<br /></li>
<li>拉普拉斯方程 拉普拉斯方程为二阶偏微分方程。<br /></li>
<li>勒让德方程<br /></li>
<li>勒让德多项式<br /></li>
<li>偏微分方程 包含未知函数的偏导数(或偏微分)的方程。方程中所出现未知函数偏导数的最高阶数，称为该方程的阶。在数学、物理及工程技术中应用最广泛的，是二阶偏微分方程，习惯上把这些方程称为数学物理方程。<br /></li>
<li>偏导数 在数学中，一个多变量的函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org4192e79"></a>参考资料<br />
<div class="outline-text-7" id="text-org4192e79">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB">https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB</a><br /></li>
<li><a href="https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F">https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E5%81%8F%E5%AF%BC%E6%95%B0">https://baike.baidu.com/item/%E5%81%8F%E5%AF%BC%E6%95%B0</a><br /></li>
<li>球谐函数是什么？<a href="https://www.zhihu.com/question/26405495">https://www.zhihu.com/question/26405495</a><br /></li>
<li>Unity 渲染教程（五）：多个光源 <a href="http://gad.qq.com/program/translateview/7173934">http://gad.qq.com/program/translateview/7173934</a><br /></li>
<li>UnityShader——球谐光照 <a href="https://blog.csdn.net/NotMz/article/details/78339913">https://blog.csdn.net/NotMz/article/details/78339913</a><br /></li>
<li>球谐光照（spherical harmonic lighting）解析 <a href="https://gameinstitute.qq.com/community/detail/123183">https://gameinstitute.qq.com/community/detail/123183</a>  (该篇文章讲解通俗易懂，有道笔记中做了备份)<br /></li>
<li>球谐光照 (一)从拉普拉斯方程到球谐函数 <a href="https://zhuanlan.zhihu.com/p/66989673">https://zhuanlan.zhihu.com/p/66989673</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbca80e2" class="outline-6">
<h6 id="orgbca80e2">原理概述</h6>
<div class="outline-text-6" id="text-orgbca80e2">
<p>
球谐函数背后的思想是你可以只用一个连续函数来描述所有入射光在某个点的效果，这个函数定义在球的表面。<br />
通常来说，这个函数是用球面坐标表示的。但是也可以使用 3D 坐标，这样我们就可以使用物体的 normal 向量对函数进行采样了。<br />
为了创建这样的函数，你必须在所有方向上对光照强度进行采样，然后将结果转换为单个连续的函数。为了达到完美模拟，你必须为表面的每个点做这样的工作。这当然是无法做到的，所以我们只能做到近似效果。<br />
</p>

<p>
首先，我们只从对象本地原点的角度定义函数。光照条件在随物体表面变化不大时效果还是可以的。小物体，或者光照比较弱或光照离物体很远时满足这种情况。幸运的是，这恰好是那些不值得逐像素计算的光照或者顶点光照。<br />
其次，我们必须近似函数自身。你可以将任何连续的函数分解为多个不同频率的函数。这些被称为波段。对于任意一个函数，你可能需要无数个波段来模拟。<br />
</p>

<p>
<a href="../graphics/PhysicallyBasedRendering.html#org2737f56">球谐函数</a><br />
</p>
</div>
</div>
<div id="outline-container-org31a4ff2" class="outline-6">
<h6 id="org31a4ff2">Spherical Harmonics Bands</h6>
<div class="outline-text-6" id="text-org31a4ff2">
<p>
第一个基带：使用一个常量颜色值是最简单近似灯光的方式。光照在各个方向上都是相同的。使用单个子函数表示，这个子函数为一个常量值。<br />
第二个基带：第二个基带引入了线性方向光，对于每一个轴向，其描述了最多的光照来自哪儿。使用三个函数表示，每个函数包含一个我们法线的坐标值，并乘上一个常量。<br />
第三个基带：第三个基带更加复杂，它有 5 个函数组成。这些函数都是二次方的，他们包含了两个法线坐标的乘积。<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">l band NO</th>
<th scope="col" class="org-right">sub func count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
下表为最大阶数 n 下，对应所有基带的子函数的个数<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">n^2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1=1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">1+3=4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">1+3+5=9</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">1+3+5+7=16</td>
</tr>
</tbody>
</table>

<p>
下图列出了各个基带的子函数，每一项都需要再乘上 \(\frac{1}{2\sqrt{\pi}}\)<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_param.png" alt="01_05ml_sh_param.png" /><br />
</p>

<p>
因此我们可以使用 9 个因子来近似表示任何一种光照情况，考虑到颜色有 RGB 三个分量，一共需要使用 3*9=27 个因子。<br />
</p>

<p>
下图为 unity 中传递给 shader 的球谐数据:<br />
</p>
<ul class="org-ul">
<li>unity_SHAr.rgba 存储了光照 r 分量的第一个基带和第二个基带的参数因子，unity_SHBr.rgba + unitySHC.r 存储了光照 r 分量的第三个基带的参数因子<br /></li>
<li>unity_SHAg.rgba 存储了光照 g 分量的第一个基带和第二个基带的参数因子，unity_SHBg.rgba + unitySHC.g 存储了光照 g 分量的第三个基带的参数因子<br /></li>
<li>unity_SHAb.rgba 存储了光照 b 分量的第一个基带和第二个基带的参数因子，unity_SHBb.rgba + unitySHC.b 存储了光照 b 分量的第三个基带的参数因子<br /></li>
</ul>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_05ml_unity_sh_param.png" alt="01_05ml_unity_sh_param.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org964981a" class="outline-6">
<h6 id="org964981a">ShadeSH9</h6>
<div class="outline-text-6" id="text-org964981a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL0L1</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear (L1) + constant (L0) polynomial terms</span>
    x.r = <span style="color: #4f97d7;">dot</span>(unity_SHAr,normal);
    x.g = <span style="color: #4f97d7;">dot</span>(unity_SHAg,normal);
    x.b = <span style="color: #4f97d7;">dot</span>(unity_SHAb,normal);

    <span style="color: #4f97d7; font-weight: bold;">return</span> x;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL2</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x1, x2;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 of the quadratic (L2) polynomials</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> vB = normal.xyzz * normal.yzzx;
    x1.r = <span style="color: #4f97d7;">dot</span>(unity_SHBr,vB);
    x1.g = <span style="color: #4f97d7;">dot</span>(unity_SHBg,vB);
    x1.b = <span style="color: #4f97d7;">dot</span>(unity_SHBb,vB);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Final (5th) quadratic (L2) polynomial</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> vC = normal.x*normal.x - normal.y*normal.y;
    x2 = unity_SHC.rgb * vC;

    <span style="color: #4f97d7; font-weight: bold;">return</span> x1 + x2;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">output in active color space</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSH9</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear + constant polynomial terms</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> res = SHEvalLinearL0L1 (normal);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Quadratic polynomials</span>
    res += SHEvalLinearL2 (normal);

<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        res = LinearToGammaSpace (res);
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3853ec5" class="outline-6">
<h6 id="org3853ec5">环境光和 LightProbe</h6>
<div class="outline-text-6" id="text-org3853ec5">
<p>
环境光和 LightProbe 都使用了球谐光照。在 Unity 中叠加到了间接光照的 diffuse 中。<br />
环境光对应一组球谐系数。每个 LightProbe 也对应存储一组球谐系数。全局照明系统会烘培环境光探针，即使用球谐参数保存环境光参数，但是当几何体使用了光照探针和 Lightmaps 时，并不会应用环境光探针，因为环境光影响在光照探针和 Lightmaps 中已经存在了。只有当不存在光照探针和 Lightmap 时，才会使用环境光探针。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html">https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Should SH (light probe / ambient) calculations be performed?</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#24320;&#21551;&#26102;&#65292;&#19981;&#25191;&#34892;SH&#35745;&#31639;&#12290;When both static and dynamic lightmaps are available, no SH evaluation is performed </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#20851;&#38381;&#26102;&#65292;&#19968;&#23450;&#25191;&#34892;SH&#35745;&#31639;&#12290; When static and dynamic lightmaps are not available, SH evaluation is always performed </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#23545;&#20110;&#20302;&#32423;LOD&#65292;&#38745;&#24577;lightmap&#21644;LightProbe&#23454;&#26102;&#20840;&#23616;&#29031;&#26126;&#21487;&#20197;&#21512;&#24182;&#22312;&#19968;&#36215;&#12290; For low level LODs, static lightmap and real-time GI from light probes can be combined together </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- forwardadd,shdowcaster&#31561;Pass&#19981;&#38656;&#35201;&#25191;&#34892;SH&#35745;&#31639;&#12290;Passes that don't do ambient (additive, shadowcaster etc.) should not do SH either.</span>
<span style="color: #bc6ec5;">#define</span> UNITY_SHOULD_SAMPLE_SH (defined(LIGHTPROBE_SH) &amp;&amp; !defined(UNITY_PASS_FORWARDADD) &amp;&amp; !defined(UNITY_PASS_PREPASSBASE) &amp;&amp; !defined(UNITY_PASS_SHADOWCASTER) &amp;&amp; !defined(UNITY_PASS_META))

<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSHPerPixel</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> ambient, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> ambient_contrib = 0.0;

<span style="color: #bc6ec5;">    #if</span> UNITY_SAMPLE_FULL_SH_PER_PIXEL
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Completely per-pixel</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

            ambient_contrib += SHEvalLinearL2(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));

            ambient += <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient_contrib);

<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace(ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #elif</span> (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Completely per-vertex</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">nothing to do here. Gamma conversion on ambient from SH takes place in the vertex shader, see ShadeSHPerVertex.</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">L2 per-vertex, L0..L1 &amp; gamma-correction per-pixel</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Ambient in this case is expected to be always Linear, see ShadeSHPerVertex()</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

        ambient = <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient+ambient_contrib);     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">include L2 contribution in vertex shader before clamp.</span>
<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace (ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> ambient;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> UnityGI UnityGI_Base(UnityGIInput data, <span style="color: #ce537a; font-weight: bold;">half</span> occlusion, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
    UnityGI o_gi;
    ResetUnityGI(o_gi);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Base pass with Lightmap support is responsible for handling ShadowMask / blending here for performance reason</span>
<span style="color: #bc6ec5;">    #if</span> defined(HANDLE_SHADOWS_BLENDING_IN_GI)
        <span style="color: #ce537a; font-weight: bold;">half</span> bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
        <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - data.worldPos, UNITY_MATRIX_V[2].xyz);
        <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
        data.atten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.light = data.light;
    o_gi.light.color *= data.atten;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#35843;&#29992; ShadeSHPerPixel &#26041;&#27861;&#35745;&#31639;&#29615;&#22659;&#20809; /LightProbe&#30340;&#29699;&#35856;&#20809;&#29031;&#65292;&#23558;&#32467;&#26524;&#23384;&#20648;&#21040;indirectLight.diffuse&#20013;</span>
<span style="color: #bc6ec5;">    #if</span> UNITY_SHOULD_SAMPLE_SH
        o_gi.indirect.diffuse = ShadeSHPerPixel(normalWorld, data.ambient, data.worldPos);
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Baked lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">half4</span> bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);
        <span style="color: #ce537a; font-weight: bold;">half3</span> bakedColor = DecodeLightmap(bakedColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> bakedDirTex = UNITY_SAMPLE_TEX2D_SAMPLER (unity_LightmapInd, unity_Lightmap, data.lightmapUV.xy);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap (o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">not directional lightmap</span>
            o_gi.indirect.diffuse += bakedColor;

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap(o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #ifdef</span> DYNAMICLIGHTMAP_ON
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Dynamic lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> realtimeColorTex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, data.lightmapUV.zw);
        <span style="color: #ce537a; font-weight: bold;">half3</span> realtimeColor = DecodeRealtimeLightmap (realtimeColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">half4</span> realtimeDirTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap, data.lightmapUV.zw);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (realtimeColor, realtimeDirTex, normalWorld);
<span style="color: #bc6ec5;">        #else</span>
            o_gi.indirect.diffuse += realtimeColor;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.indirect.diffuse *= occlusion;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o_gi;
}

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org6a2ced4" class="outline-4">
<h4 id="org6a2ced4">Bumpiness</h4>
<div class="outline-text-4" id="text-org6a2ced4">
</div>
<div id="outline-container-orgc88c7d9" class="outline-5">
<h5 id="orgc88c7d9">高度图转 normal map 的方法</h5>
<div class="outline-text-5" id="text-orgc88c7d9">
</div>
<div id="outline-container-org78a8ed6" class="outline-6">
<h6 id="org78a8ed6">方案 1</h6>
<div class="outline-text-6" id="text-org78a8ed6">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 tangent 绕 z 轴旋转 90 度，就是 normal。<br /></li>
</ol>

<div class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_vector-rotation.png" alt="01_06bu_vector-rotation.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992; u &#26041;&#21521;&#39640;&#24230;&#21464;&#21270;&#26469;&#27714; normal</span>
<span style="color: #ce537a; font-weight: bold;">float2</span> delta = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> h1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv);
<span style="color: #ce537a; font-weight: bold;">float</span> h2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + delta);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scale normal with 1/delta.x &#31532;&#19968;&#31181;&#24418;&#24335;&#28040;&#38500;&#20102;&#38500;&#27861;&#65292;&#32780;&#19988;&#25913;&#21892;&#20102;&#31934;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i.normal = float3(delta.x, h2 - h1, 0); &lt;==&gt; i.normal = float3(1, (h2 - h1)/delta.x, 0);</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(delta.x, h2 - h1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#25442; x &#21644; y &#23558; tangent &#36716;&#21270;&#20026; normal</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, delta.x, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25918;&#22823;y&#20943;&#24369;normal&#25928;&#26524;</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, 1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20063;&#21487;&#20197;&#21033;&#29992; v &#26041;&#21521;&#39640;&#24230;&#26469;&#21464;&#21270;&#27714; normal.&#23454;&#29616;&#26041;&#27861;&#30456;&#21516;</span>
</pre>
</div>

<p>
下图为使用该方式计算 normal 的效果图<br />
<img src="./UnityCatLikeCoding/20_01_08_HMapTangentAsNormal.png" alt="20_01_08_HMapTangentAsNormal.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org8c9b4c2" class="outline-6">
<h6 id="org8c9b4c2">方案 2</h6>
<div class="outline-text-6" id="text-org8c9b4c2">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 u/v 方向的 tangent 进行叉乘生成 normal。<br /></li>
</ol>

<p>
下面是向量叉乘公式:<br />
<img src="./UnityCatLikeCoding/20_01_09_vectorCrossProduct.png" alt="20_01_09_vectorCrossProduct.png" /><br />
</p>

<p>
此处 tangent 向量叉乘优化：<br />
</p>
\begin{equation}  
  \begin{bmatrix}
  0\\ 
  {f_v}'\\ 
  1
  \end{bmatrix} \times 
  \begin{bmatrix}
  1\\ 
  {f_u}'\\ 
  0
  \end{bmatrix} = 
  \begin{bmatrix}
  {f_v}'*0-1*{f_u}'\\ 
  1*1-0*0 \\
  0*{f_u}'-{f_v}'*1
  \end{bmatrix} =
  \begin{bmatrix}
  -{f_u}'\\ 
  1 \\
  -{f_v}'
  \end{bmatrix}
\end{equation}

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> du = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x * 0.5, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> u1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - du);
<span style="color: #ce537a; font-weight: bold;">float</span> u2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + du);
<span style="color: #ce537a; font-weight: bold;">float3</span> tu = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, u2 - u1, 0);

<span style="color: #ce537a; font-weight: bold;">float2</span> dv = <span style="color: #ce537a; font-weight: bold;">float2</span>(0, <span style="color: #7590db;">_HeightMap_TexelSize</span>.y * 0.5);
<span style="color: #ce537a; font-weight: bold;">float</span> v1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - dv);
<span style="color: #ce537a; font-weight: bold;">float</span> v2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + dv);
<span style="color: #ce537a; font-weight: bold;">float3</span> tv = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, v2 - v1, 1);

i.normal = <span style="color: #4f97d7;">cross</span>(tv, tu);
i.normal = <span style="color: #4f97d7;">normalize</span>(i.normal);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7612f09" class="outline-5">
<h5 id="org7612f09">Normal 向量的插值</h5>
<div class="outline-text-5" id="text-org7612f09">
<p>
Normal 贴图的 Filter，以及顶点的 Normal 向量在传递到片段着色器过程中的插值 都会导致 normal 向量不再是单位向量，所以需要重新单位化。<br />
</p>
</div>
</div>
<div id="outline-container-org1b97ab4" class="outline-5">
<h5 id="org1b97ab4">Normal 贴图存储惯例</h5>
<div class="outline-text-5" id="text-org1b97ab4">
<p>
Normal 贴图通用的惯例是将向上的方向存储到 z 分量.所以，在 shader 中采样出来 normal 向量后需要调换 y 分量和 z 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org1efe8cd" class="outline-5">
<h5 id="org1efe8cd">DXT5nm 存储 normal 贴图</h5>
<div class="outline-text-5" id="text-org1efe8cd">
<p>
其只存储了 normal 的 x，y 分量，丢弃掉了 z 分量。z 分量通过计算得到 \(z=\sqrt{1-x^2-y^2}\) .<br />
x 分量存储在 A 通道，y 分量存储在 G 通道。R 通道和 B 通道没有使用。<br />
DXT5 按照 4x4 个像素为一个块进行压缩。R 占用 5 位，B 占用 5 位，G 占用 6 位，A 占用 8 位。RGB 公用一个查找表，A 单独使用一个查找表。所以将 x 分量存储到 A 通道可以保持 x 分量和 y 分量的独立性。<br />
手机平台不支持 DXT5nm 格式，在手机平台 unity 仍然使用通用的 rgb 进行编码。<br />
</p>
</div>
</div>
<div id="outline-container-orgd3ad258" class="outline-5">
<h5 id="orgd3ad258">缩放 Normal</h5>
<div class="outline-text-5" id="text-orgd3ad258">
<p>
只需要在单位化 normal 前，对 normal 的 x 分量和 z 分量进行缩放，就可以强化和弱化 y 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org7547aee" class="outline-5">
<h5 id="org7547aee">Blending Normals</h5>
<div class="outline-text-5" id="text-org7547aee">
<p>
回顾使用高度图生成 normal 贴图的方法，可以知道，如果希望 normal 效果叠加，其实就是将高度叠加，也就是斜率叠加。<br />
normal 贴图中存储的值为:(s 表示单位化过程中，对各个分量的缩放)<br />
</p>
\begin{bmatrix}
-s{f_u}'\\ 
-s{f_v}'\\
s \\
\end{bmatrix}
<p>
所以叠加 MainNormalTex 和 DetailNormalTex 的高度后得到的 normal 为<br />
</p>
\begin{bmatrix}
\frac{M_x}{M_z} + \frac{D_x}{D_z} \\
\frac{M_y}{M_z} + \frac{D_y}{D_z} \\
1 \\
\end{bmatrix}

<p>
Whiteout Blending : 对上面得到的 normal 乘 \(M_zD_z\) ，然后丢弃掉对 x 和 y 分量的缩放、这样可以强化 X 和 Y 分量<br />
</p>
\begin{equation}  
  \begin{bmatrix}
  \frac{M_x}{M_z} + \frac{D_x}{D_z} \\
  \frac{M_y}{M_z} + \frac{D_y}{D_z} \\
  1 \\
  \end{bmatrix} * M_zD_z = 
  \begin{bmatrix}
    M_xD_z + D_xM_z \\
    M_yD_z + D_yM_z \\
    M_zD_z \\
  \end{bmatrix} = 
  \begin{bmatrix}
    M_x + D_x \\
    M_y + D_y \\
    M_zD_z \\
  \end{bmatrix}
\end{equation}
</div>
</div>
</div>
<div id="outline-container-orga65a3aa" class="outline-4">
<h4 id="orga65a3aa">Shadows</h4>
<div class="outline-text-4" id="text-orga65a3aa">
</div>
<div id="outline-container-org82a46f3" class="outline-5">
<h5 id="org82a46f3">方向光阴影</h5>
<div class="outline-text-5" id="text-org82a46f3">
</div>
<div id="outline-container-org4c9d938" class="outline-6">
<h6 id="org4c9d938">ShadowBias</h6>
<div class="outline-text-6" id="text-org4c9d938">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgce81016" class="outline-6">
<h6 id="orgce81016">开启屏幕空间阴影</h6>
<div class="outline-text-6" id="text-orgce81016">
</div>
<ul class="org-ul">
<li><a id="orgc6a8ac8"></a>开启关闭的方法<br />
<div class="outline-text-7" id="text-orgc6a8ac8">
<ul class="org-ul">
<li>关闭 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 No Support，Tier 中取消勾选 Cascaded Shadows 。<br /></li>
<li>开启 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 Built-in shader，Tier 中勾选 Cascaded Shadows 。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf8c1d30"></a>Rendering to Depth Texture<br />
<div class="outline-text-7" id="text-orgf8c1d30">
<p>
Unity 绘制场景中物体将其深度写入到 DepthTexture<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_07sh_depth.png" alt="01_07sh_depth.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="org713d9f5"></a>Rendering To Shadow Maps<br />
<div class="outline-text-7" id="text-org713d9f5">
<p>
Unity 在光源位置对场景进行绘制，将物体深度写入到 Shadowmap<br />
开启 shadow cascades 后，会多次绘制阴影。开启 2 级会绘制两次，开启 4 级会绘制 4 次。<br />
</p>

<p>
下图为第一个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows.png" alt="01_07sh_4cascades_shadows.png" /><br />
</p>

<p>
下图为第二个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_2.png" alt="01_07sh_4cascades_shadows_2.png" /><br />
</p>
</div>
</li>

<li><a id="orgd64a2a5"></a>Collecting Shadows<br />
<div class="outline-text-7" id="text-orgd64a2a5">
<p>
Unity 使用 Hidden/Internal-ScreenSpaceShadows shader 绘制一个全屏的矩形，以前面得到的 DepthTexture 和 Shadowmap 为输入，对于每一个片段通过比较对应的场景摄像机的深度和光照摄像机的深度得出屏幕空间的阴影贴图。<br />
在这个过程中，Unity 通过 Filtering 来实现软阴影。<br />
</p>

<p>
下图为第一个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_1.png" alt="01_07sh_screenspace_shadows_1.png" /><br />
下图为第二个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_2.png" alt="01_07sh_screenspace_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="orgef30819"></a>最终结果<br />
<div class="outline-text-7" id="text-orgef30819">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_drawcall.png" alt="01_07sh_4cascades_drawcall.png" /><br />
</p>

<p>
下图为绘制结果：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_result.png" alt="01_07sh_4cascades_shadows_result.png" /><br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7b6cc2a"></a>为什么 unity 要在渲染 shadowmap 和 collecting 之间切换？<br />
<div class="outline-text-8" id="text-org7b6cc2a">
<p>
因为每个光源需要它自己的屏幕空间阴影贴图，但是从光源视角渲染阴影贴图所用到的 RenderTarget 可以被复用。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org871bdce" class="outline-6">
<h6 id="org871bdce">关闭屏幕空间阴影</h6>
<div class="outline-text-6" id="text-org871bdce">
</div>
<ul class="org-ul">
<li><a id="orgfcf6edd"></a>Rendering To Shadow Maps<br />
<div class="outline-text-7" id="text-orgfcf6edd">
<p>
下图为第一个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_1.png" alt="01_07sh_noss_shadows_1.png" /><br />
下图为第二个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_2.png" alt="01_07sh_noss_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="org43164ee"></a>最终结果<br />
<div class="outline-text-7" id="text-org43164ee">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_3.png" alt="01_07sh_noss_shadows_3.png" /><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgab2bab7" class="outline-6">
<h6 id="orgab2bab7">ShadowQuality</h6>
<div class="outline-text-6" id="text-orgab2bab7">
<p>
减低 ShadowDistance 可以提高阴影精度，但是会缩小阴影范围。<br />
设置投影类型 QualitySettings.shadowProjection = ShadowProjection.CloseFit; 可以提高阴影精度。<br />
开启 Cascade。<br />
</p>
</div>
</div>
<div id="outline-container-orge071023" class="outline-6">
<h6 id="orge071023">ForwardAddPass 阴影支持</h6>
<div class="outline-text-6" id="text-orge071023">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#26696;1 fwd pass &#20013;&#28155;&#21152;&#22914;&#19979;&#21629;&#20196;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile_fwdadd_fullshadows

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#26696;2 </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2.1 fwd pass &#20013;&#20462;&#25913;Tag </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2.2&#28155;&#21152; DIRECTIONAL SHADOWS_SCREEN&#21464;&#20307;</span>
<span style="color: #4f97d7; font-weight: bold;">Tags</span>
{
    <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"ForwardAdd"</span>
    <span style="color: #2d9574;">"SHADOWSUPPORT"</span>=<span style="color: #2d9574;">"true"</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ DIRECTIONAL
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SCREEN
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a0de81" class="outline-6">
<h6 id="org8a0de81">参考资料</h6>
<div class="outline-text-6" id="text-org8a0de81">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0f169bb" class="outline-5">
<h5 id="org0f169bb">Spot Light Shadow</h5>
</div>
<div id="outline-container-org13bbcfc" class="outline-5">
<h5 id="org13bbcfc">相关宏定义</h5>
<div class="outline-text-5" id="text-org13bbcfc">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏定义</th>
<th scope="col" class="org-left">DrawCall</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UNITY_NO_SCREENSPACE_SHADOWS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">开启屏幕空间阴影</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">Directional 和 Spot 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">PointLight 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN</td>
<td class="org-left">RenderForward ForwardBasePass</td>
<td class="org-left">主 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN DIRECTIONAL</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">第二个 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH SPOT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Spot 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE POINT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Point 开启阴影对应的宏定义</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>DIRECTIONAL SPOT POINT 3 个对应 Light 组件上的 LightType 的设置<br /></li>
<li>SHADOWS_SCREEN SHADOWS_DEPTH SHADOWS_CUBE 对应物体 Renderer 组件上的 ReceiveShadow 设置<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org888c3f6" class="outline-5">
<h5 id="org888c3f6">参考资料</h5>
<div class="outline-text-5" id="text-org888c3f6">
<ul class="org-ul">
<li>Signed Distance Field Shadow in Unity <a href="https://zhuanlan.zhihu.com/p/37918356">https://zhuanlan.zhihu.com/p/37918356</a><br /></li>
<li>Unity 平面阴影(王者荣耀阴影实现) <a href="https://zhuanlan.zhihu.com/p/42781261">https://zhuanlan.zhihu.com/p/42781261</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4575d98" class="outline-4">
<h4 id="org4575d98">Reflection</h4>
<div class="outline-text-4" id="text-org4575d98">
</div>
<div id="outline-container-org6f7fa9d" class="outline-5">
<h5 id="org6f7fa9d">Environment Mapping</h5>
<div class="outline-text-5" id="text-org6f7fa9d">
</div>
<div id="outline-container-org0a7ec2a" class="outline-6">
<h6 id="org0a7ec2a">缺少 Indirect Specular Lighting</h6>
<div class="outline-text-6" id="text-org0a7ec2a">
<p>
在 shader 中组合了 diffuse specular ambient 后，感觉应该可以创建出看上去真实的画面了，然而物体表面依然暗淡，闪耀的表面效果看起来不正确。闪耀的表面应该像镜子，特别是表面为金属时。（完美的镜面反射会反射所有光照，所以其不存在 diffuse.光滑度越高、金属度越高，材质越接近完美镜面。）<br />
下图为 Metallic Smoothness 取不同值时的渲染效果:<br />
<img src="./UnityCatLikeCoding/01_08re_no_indirect_spec_lighting1.png" alt="01_08re_no_indirect_spec_lighting1.png" /><br />
上图 metallic=1 时，env ambient 几乎对渲染没有任何影响，这是因为金属度越高反射率越大，反射率越大其漫反射部分就越少(参考 PhysicalTheory.org 中 金属和非金属放射光的差异 的描述)，所以 ambient 对于 metallic=1 的材质几乎没有任何影响。<br />
上图 metallic=1 Smoothness=1 时，几乎是一个黑色的球，只能看到一个很小的高光，这个很小的高光是表面将直接光源反射到了朝向我们的方向(朝向摄像机的方向)。之所以渲染结果是黑球，是因为 shader 中只包含了直接光照和间接光照的 diffuse（也就是 ambient），为了反射环境，需要添加间接光照的高光反射，即 indirectLight.specular。<br />
</p>
</div>
</div>

<div id="outline-container-orgdd77cbf" class="outline-6">
<h6 id="orgdd77cbf">Indirect Specular Lighting 特点</h6>
<div class="outline-text-6" id="text-orgdd77cbf">
<p>
视线和法线夹角越大，Fresnel 反射越强。表面越光滑 Fresnel 反射越强。<br />
<img src="./UnityCatLikeCoding/01_08re_fresnel_smoothness.png" alt="01_08re_fresnel_smoothness.png" /><br />
</p>

<p>
因为 Fresnel 间接反射来源于间接光照(上图中直接光照颜色为白色，间接光照的高光直接设置为了红色)，所以它产生的效果独立于直接光照，因此上图中即使处于阴影部分的边缘处 Fresnel 反射依然很强，其独立于直接光源的阴影。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i) {
  UnityIndirect indirectLight;
  indirectLight.diffuse = 0;
  indirectLight.specular = 0;

<span style="color: #bc6ec5;">  #if</span> defined(VERTEXLIGHT_ON)
    indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS)
    indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38388;&#25509;&#39640;&#20809;&#39068;&#33394;&#35774;&#32622;&#20026;&#20102;&#32418;&#33394;</span>
    indirectLight.specular = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, 0, 0);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0751e71" class="outline-5">
<h5 id="org0751e71">Imperfect Reflections</h5>
<div class="outline-text-5" id="text-org0751e71">
<p>
模糊的反射是通过环境贴图的 mipmap 来实现的。<br />
</p>
</div>

<div id="outline-container-org901f7dc" class="outline-6">
<h6 id="org901f7dc">Metals VS Nonmetals</h6>
<div class="outline-text-6" id="text-org901f7dc">
<p>
金属和非金属表面都可以产生清晰的反射，但是他们看起来是不同的。镜面反射在闪耀的电介质材质(非金属)上效果会很强，但是镜面反射并不会主导电介质材质(非金属)的外观，他们仍然表现出大量的可见的 diffuse 反射。<br />
<img src="./UnityCatLikeCoding/01_08re_dielectric.png" alt="01_08re_dielectric.png" /><br />
</p>

<p>
金属会改变镜面反射的颜色，但是非金属则不会。这对于镜面高光和环境镜面反射都适用。下图中金属的镜面高光颜色为红色，非金属是白色。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_nonmetal.png" alt="01_08re_metal_nonmetal.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org72a2ac0" class="outline-6">
<h6 id="org72a2ac0">Mirrors and Shadows</h6>
<div class="outline-text-6" id="text-org72a2ac0">
<p>
间接反射是独立于表面的直接照明的。这在其阴影区域会更加明显。对于非金属，这会让表面更亮一些，你依然可以看到直接光照导致的阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_nonmetal_with_shadow.png" alt="01_08re_nonmetal_with_shadow.png" /><br />
同样的规则适用于金属。但是，金属的间接反射起主导作用。因此，直接光照和阴影会随着光泽度增加而消失。完美镜面上不存在阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_with_shadow.png" alt="01_08re_metal_with_shadow.png" /><br />
现实世界中很少有完美的镜面。现实世界中的材质都是由金属和非金属混合而成的，可以通过调节金属度来模拟不完美的镜面材质。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org254a923" class="outline-5">
<h5 id="org254a923">Box Projection</h5>
<div class="outline-text-5" id="text-org254a923">
<p>
ReflectionProbe 的 Box 区域是和世界坐标轴对齐的，它不受旋转和缩放影响。<br />
BoxProjection 原理如下图所示：<br />
<img src="./UnityCatLikeCoding/01_08re_box_projection.JPG" alt="01_08re_box_projection.JPG" /><br />
<img src="./UnityCatLikeCoding/01_08re_box_projection_3D.png" alt="01_08re_box_projection_3D.png" /><br />
<a href="./UnityCatLikeCoding/01_08re_box_projection.ggb">./UnityCatLikeCoding/01_08re_box_projection.ggb</a><br />
</p>

<p>
BoxProjection 对应代码实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">BoxProjection</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> dir, <span style="color: #ce537a; font-weight: bold;">half3</span> pos, <span style="color: #ce537a; font-weight: bold;">half4</span> cubemapPos, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMin, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMax)
{
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cubemapPos.w &#25511;&#21046; BoxProjection &#26159;&#21542;&#29983;&#25928;  </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UNITY_BRANCH &#29992;&#20110;&#24320;&#21551;&#30495;&#27491;&#30340;&#20998;&#25903;</span>
  UNITY_BRANCH
  <span style="color: #4f97d7; font-weight: bold;">if</span> (cubemapPos.w &gt; 0)
  {
    <span style="color: #ce537a; font-weight: bold;">half3</span> factors = ((dir &gt; 0 ? boxMax : boxMin) - pos) / dir;
    <span style="color: #ce537a; font-weight: bold;">half</span> realFactor = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(factors.x, factors.y), factors.z);
    <span style="color: #4f97d7; font-weight: bold;">return</span> dir * realFactor + (pos - cubemapPos);
  }
  <span style="color: #4f97d7; font-weight: bold;">return</span> dir;
}
</pre>
</div>

<ul class="org-ul">
<li>关于 UNITY_BRANCH   <a href="https://forum.unity.com/threads/correct-use-of-unity_branch.476804/">https://forum.unity.com/threads/correct-use-of-unity_branch.476804/</a><br /></li>
<li>HLSL branch flatten <a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4bcaf4d" class="outline-5">
<h5 id="org4bcaf4d">Blending Reflection Probes</h5>
<div class="outline-text-5" id="text-org4bcaf4d">
<p>
只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">ReflectionProbeUsage</span>
{
    <span style="color: #7590db;">Off</span> = 0,                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20851;&#38381;&#21453;&#23556;&#25506;&#38024;</span>
    <span style="color: #7590db;">BlendProbes</span> = 1,              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21482;&#21644;&#21453;&#23556;&#25506;&#38024;&#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">BlendProbesAndSkybox</span> = 2,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21487;&#20197;&#21644; skybox &#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">Simple</span> = 3                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20351;&#29992;&#20854;&#20013;&#19968;&#20010;&#21453;&#23556;&#25506;&#38024;&#25110; skybox&#65292;&#19981;&#36827;&#34892;&#28151;&#21512;</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28151;&#21512;&#21453;&#23556;&#25506;&#38024;&#30340;&#36923;&#36753;</span>
UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir)
{
    UnityIndirect indirect;
    indirect.diffuse = 0;
    indirect.specular = 0;
<span style="color: #bc6ec5;">    #if</span> defined(FORWARD_BASE_PASS)
    indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));

    <span style="color: #ce537a; font-weight: bold;">half</span> roughness = 1 - <span style="color: #7590db;">_Smoothness</span>;
    roughness *= 1.7 - 0.7 * roughness;

    <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir = <span style="color: #4f97d7;">reflect</span>(-viewDir, i.worldNormal);
    <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir1 = BoxProjection(reflectDir, i.worldPos,
        unity_SpecCube0_ProbePosition,
        unity_SpecCube0_BoxMin,
        unity_SpecCube0_BoxMax);
    <span style="color: #ce537a; font-weight: bold;">half4</span> envColor = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflectDir1, roughness*UNITY_SPECCUBE_LOD_STEPS);
    envColor.rgb = DecodeHDR(envColor, unity_SpecCube0_HDR);
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_SpecCube0_BoxMin.a &lt; 0.9999)
    {
        <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir2 = BoxProjection(reflectDir, i.worldPos,
            unity_SpecCube1_ProbePosition,
            unity_SpecCube1_BoxMin,
            unity_SpecCube1_BoxMax);
        <span style="color: #ce537a; font-weight: bold;">half4</span> envColor2 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, reflectDir2, roughness*UNITY_SPECCUBE_LOD_STEPS);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DecodeHDR &#20013;&#20195;&#30721;&#22788;&#29702;&#20102; intensity &#36923;&#36753;</span>
        envColor2.rgb = DecodeHDR(envColor2, unity_SpecCube1_HDR);
        envColor = <span style="color: #4f97d7;">lerp</span>(envColor2, envColor, unity_SpecCube0_BoxMin.a);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.specular = half3(1, 0, 0);</span>
    indirect.specular = envColor.rgb;
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7090a0d" class="outline-5">
<h5 id="org7090a0d">Bouncing Reflections</h5>
<div class="outline-text-5" id="text-org7090a0d">
<p>
在 Lighting/Scene/Environment Reflections 下可以设置 Bounces 的次数。<br />
Lighting/Scene 下的数据记录在当前打开的场景文件中，每个场景的数据可以不同。<br />
EnvironmentLighting/IntensityMultiplier  当 EnvironmentLighting/Source 为 Skybox 时，该调节项控制天空球光照亮度.<br />
</p>

<p>
EnvironmentReflections/Source  指定使用天空球作为环境反射源，还是自定义环境反射源。<br />
EnvironmentReflections/IntensityMultiplier 控制反射源在场景中提供反射的因子，值为 1 时符合物理规律。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1a1cc75" class="outline-4">
<h4 id="org1a1cc75">ComplexMaterials &amp; More Complexity</h4>
<div class="outline-text-4" id="text-org1a1cc75">
</div>
<div id="outline-container-org0db62a8" class="outline-5">
<h5 id="org0db62a8">Emission</h5>
<div class="outline-text-5" id="text-org0db62a8">
<div class="org-src-container">
<pre class="src src-csharp">[NoScaleOffset] _EmissionMap (<span style="color: #2d9574;">"Emission"</span>, 2D) = <span style="color: #2d9574;">"black"</span> {}
_Emission (<span style="color: #2d9574;">"Emission"</span>, Color) = (0, 0, 0)

<span style="color: #bc6ec5;">#pragma</span><span style="color: #2d9574;"> shader_feature _EMISSION_MAP</span>

sampler2D _EmissionMap;
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_Emission</span>;

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(_EMISSION_MAP)
      <span style="color: #4f97d7; font-weight: bold;">return</span> tex2D(_EmissionMap, i.uv.xy) * _Emission;
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> _Emission;
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">#else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">MyFragmentProgram</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) : SV_TARGET 
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">color</span> = UNITY_BRDF_PBS(
                                  albedo, specularTint,
                                  oneMinusReflectivity, GetSmoothness(i),
                                  i.normal, viewDir,
                                  CreateLight(i), CreateIndirectLight(i, viewDir)
                                  );
    color.rgb += GetEmission(i);
    <span style="color: #4f97d7; font-weight: bold;">return</span> color;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org035c3f0" class="outline-5">
<h5 id="org035c3f0">Smoothness &amp; Metallic Map</h5>
<div class="outline-text-5" id="text-org035c3f0">
<p>
将 MetallicMap 和 SmoothnessMap 存储到一张 DXT5 格式的贴图中 ，Metallic Map 放到贴图 r 通道, Smoothness Map 放到贴图 a 通道。等价于使用两张 DXT1 格式贴图分别存储。因为 DXT5 分开对 RGB 和 A 通道进行压缩。<br />
</p>
</div>
</div>

<div id="outline-container-org1b21937" class="outline-5">
<h5 id="org1b21937">Occlusion</h5>
<div class="outline-text-5" id="text-org1b21937">
<div class="org-src-container">
<pre class="src src-csharp">[NoScaleOffset] _OcclusionMap (<span style="color: #2d9574;">"Occlusion"</span>, 2D) = <span style="color: #2d9574;">"white"</span> {}
_OcclusionStrength(<span style="color: #2d9574;">"Occlusion Strength"</span>, Range(0, 1)) = 1

<span style="color: #bc6ec5;">#pragma</span><span style="color: #2d9574;"> shader_feature _OCCLUSION_MAP</span>

sampler2D _OcclusionMap;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_OcclusionStrength</span>;

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(_OCCLUSION_MAP)
    <span style="color: #4f97d7; font-weight: bold;">return</span> lerp(1, tex2D(_OcclusionMap, i.uv.xy).g, _OcclusionStrength);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Occlusion &#21516;&#26102;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;&#21644;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;&#26102;&#65292;Occlusion&#25928;&#26524;&#20250;&#36807;&#24378;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;Occlusion&#26159;&#22522;&#20110;&#29289;&#20307;&#24418;&#29366;&#30340;&#32780;&#19981;&#26159;&#29305;&#23450;&#20809;&#29031;&#30340;&#65292;&#20854;&#21482;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#20250;&#26356;&#21512;&#29702;&#19968;&#20123;&#12290;&#20985;&#30165;&#36234;&#28145;&#30340;&#22320;&#26041;&#65292;&#21508;&#20010;&#26041;&#21521;&#30340;&#38388;&#25509;&#20809;&#29031;&#20943;&#24369;&#36234;&#22810;&#65292;&#32780;&#30452;&#25509;&#20809;&#29031;&#29031;&#36827;&#20985;&#30165;&#26102;&#65292;&#36824;&#26159;&#21487;&#20197;&#21152;&#23558;&#20854;&#29031;&#20142;&#12290;</span>
<span style="color: #ce537a; font-weight: bold;">UnityLight</span> <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;atten&#30456;&#20056;&#26469;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
    attenuation *= GetOcclusion(i);
    light.color = _LightColor0.rgb * attenuation;
    light.ndotl = DotClamped(i.normal, light.dir);
    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}

<span style="color: #ce537a; font-weight: bold;">UnityIndirect</span> <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">viewDir</span>) {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">occlusion</span> = GetOcclusion(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;&#38388;&#25509;&#20809;&#29031;&#30340;diffuse&#12289;specular&#30456;&#20056;&#26469;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
    indirectLight.diffuse *= occlusion;
    indirectLight.specular *= occlusion;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org37740da" class="outline-4">
<h4 id="org37740da">Transparency</h4>
<div class="outline-text-4" id="text-org37740da">
</div>
<div id="outline-container-orgd1874bb" class="outline-5">
<h5 id="orgd1874bb">Cutout</h5>
<div class="outline-text-5" id="text-orgd1874bb">
<ul class="org-ul">
<li>clip 操作对于移动平台的 TBDR 来说消耗比较大，通过添加 _RENDERING_CUTOUT ShaderFeature，对于不需要 clip 的材质可以提升渲染性能。<br /></li>
<li>修改 cutout 材质的渲染队列，让其在不透明(Opaque)物体之后绘制，这样如果 cutout 材质对应的物体被不透明物体遮挡了，就可以避免对 cutout 物体的绘制，从而提高性能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9913539" class="outline-5">
<h5 id="org9913539">Semitransparent</h5>
<div class="outline-text-5" id="text-org9913539">
<ul class="org-ul">
<li>半透明物体需要采用 Blend SrcAlpha OneMinusSrcAlpha 的混合方式，这样才能将半透明物体后面的物体透出来。<br /></li>
<li>半透明物体不能写深度缓冲区，否则半透明物体叠加在一起时，深度测试会剔除掉物体的一部分，导致渲染结果不正确。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6ed9cea" class="outline-5">
<h5 id="org6ed9cea">RenderType tag</h5>
<div class="outline-text-5" id="text-org6ed9cea">
<p>
下面是 Unity 内置 shader 的 Shader replacement tags, 在使用替换的 shader 进行渲染时，需要使用为 shader 设置的"RenderType" tag。<br />
</p>
<ul class="org-ul">
<li>Opaque: most of the shaders (Normal , Self Illuminated, Reflective, terrain shaders).<br /></li>
<li>Transparent: most semitransparent shaders (Transparent, Particle, Font, terrain additive pass shaders).<br /></li>
<li>TransparentCutout: masked transparency shaders (Transparent Cutout, two pass vegetation shaders).<br /></li>
<li>Background: Skybox shaders.<br /></li>
<li>Overlay: GUITexture, Halo, Flare shaders.<br /></li>
<li>TreeOpaque: terrain engine tree bark.<br /></li>
<li>TreeTransparentCutout: terrain engine tree leaves.<br /></li>
<li>TreeBillboard: terrain engine billboarded trees.<br /></li>
<li>Grass: terrain engine grass.<br /></li>
<li>GrassBillboard: terrain engine billboarded grass.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf575971" class="outline-5">
<h5 id="orgf575971">Fading vs Transparency</h5>
<div class="outline-text-5" id="text-orgf575971">
<ul class="org-ul">
<li>Fade Mode<br />
Fade Mode 中，使用的混合模式为 Blend SrcAlpha OneMinusSrcAlpha，几何体的颜色会依据 alpha 值降隐，漫反射和高光反射都会降隐。这种效果对于玻璃是不合适的，玻璃是全透明的，但是依然有清晰的高光和反射。<br /></li>
<li><p>
Transparent Mode<br />
Transparent Mode 中，使用的混合模式为 Blend One OneMinusSrcAlpha, albedo 会乘 alpha 值，因此漫反射会根据 alpha 值降隐，高光反射会影响到透明度。这种模式适用于玻璃。<br />
光线被反射后，透过半透明物体的光线会对应减少，如果所有光线都被反射，则不透明度为 1，如果没有光线被反射，则不透明度为原始值。y=kx+b 两个方程两个未知数，即可求出最终的 alpha 值。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_RENDERING_TRANSPARENT</span>)
albedo *= alpha;
alpha = 1 - oneMinusReflectivity + alpha * oneMinusReflectivity;
<span style="color: #bc6ec5;">#endif</span> 
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga9f8067" class="outline-4">
<h4 id="orga9f8067">Semitransparent Shadows</h4>
<div class="outline-text-4" id="text-orga9f8067">
</div>
<div id="outline-container-org0b44da0" class="outline-5">
<h5 id="org0b44da0">Cutout Shadow</h5>
<div class="outline-text-5" id="text-org0b44da0">
<p>
透贴的阴影只需要在 ShadowCaster Pass 的片段着色器中使用 clip(alpha - _Cutoff)指令将对应的片段剔除就可以了。<br />
</p>
</div>
</div>
<div id="outline-container-org14493bd" class="outline-5">
<h5 id="org14493bd">Transparenct Shadow</h5>
<div class="outline-text-5" id="text-org14493bd">
<p>
使用 Dithering 技术来实现半透明阴影。依据 alpha 值 clip 投影表面，从而模拟出半透明阴影。下图为使用这种技术实现的阴影效果：<br />
<img src="./UnityCatLikeCoding/20_01_16_semitransparent_shadow.png" alt="20_01_16_semitransparent_shadow.png" /><br />
</p>

<p>
_DitherMaskLOD Unity 使用的 Dither 贴图的模式如下，其一共包含 16 种模式，每个模式中的小像素块是 4x4 的像素块。开始是一个全空的模式(下图最右边)，依次向左每个模式填充一个像素块，直到模式中有 7 个像素块被填充。然后图案翻转，直到所有像素被填充。<br />
<img src="./UnityCatLikeCoding/20_01_16_dither-patterns.png" alt="20_01_16_dither-patterns.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679; _DitherMaskLOD &#29992;&#21040;&#30340;uv.z&#30340;&#33539;&#22260;&#20026;[0, 1] &#22240;&#20026;&#19968;&#20849;&#26377;16&#31181;&#27169;&#24335;&#65292;&#25152;&#20197;uv.z = 0 &#23545;&#24212;&#31532;&#19968;&#31181;&#27169;&#24335;uv.z = 1.0/16.0 = 0.0625 &#23545;&#24212;&#31532;&#20108;&#31181;&#27169;&#24335; uv.z = 0.9375 &#23545;&#24212;&#31532;15&#20013;&#27169;&#24335;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">alpha*0.9375 &#24403;alpha&#36234;&#23567;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#21491;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;0&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#24403;alpha&#36234;&#22823;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#24038;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;1&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#20174;&#32780;&#27169;&#25311;&#20102;&#21322;&#36879;&#26126;&#30340;&#38452;&#24433;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> uv = <span style="color: #ce537a; font-weight: bold;">float3</span>(i.vpos.xy, alpha*0.9375);
<span style="color: #ce537a; font-weight: bold;">float</span> dither = <span style="color: #4f97d7;">tex3D</span>(<span style="color: #7590db;">_DitherMaskLOD</span>, uv);
<span style="color: #4f97d7;">clip</span>(dither - 0.01);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9673cf4" class="outline-4">
<h4 id="org9673cf4">Deferred Shading</h4>
<div class="outline-text-4" id="text-org9673cf4">
</div>
<div id="outline-container-org82399de" class="outline-5">
<h5 id="org82399de">Forward Path vs Deferred Path</h5>
<div class="outline-text-5" id="text-org82399de">
</div>
<div id="outline-container-org178ecb2" class="outline-6">
<h6 id="org178ecb2">DrawCall 对比</h6>
<div class="outline-text-6" id="text-org178ecb2">
<p>
当场景中只有一个方向光时，Forward Path 和 Deferred Path 的 DrawCall 数目相差不多，Forward Path 因为需要单独生成 DepthTexture，在开始的 DepthPass 中多出了 48 个 DrawCall<br />
场景中有两个方向光时，Forward Path 比 Deferred Path 多出了很多 DrawCall。<br />
</p>

<p>
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall0.png" alt="20_01_16_deferred_renderring_drawcall0.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall1.png" alt="20_01_16_deferred_renderring_drawcall1.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall2.png" alt="20_01_16_deferred_renderring_drawcall2.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall3.png" alt="20_01_16_deferred_renderring_drawcall3.png" /><br />
</p>
</div>

<ul class="org-ul">
<li><a id="org54aee3b"></a>为什么场景中存在多个光照时，Deferred Path 比 Forward Path 的 DrawCall 数目更少？<br />
<div class="outline-text-7" id="text-org54aee3b">
<p>
为了渲染物体，shader 必须抓取物体的 mesh 数据，将其转化到正确的坐标空间中，然后将数据进行插值，最后，获取表面属性，计算光照。<br />
Forward Path 必须为照亮物体的每一个像素光源执行前面提到的步骤，因为 DepthBuffer 已经被填充，所以额外的 Pass 比第一个 Pass 消耗要少一些，而且它们不需要考虑间接光照。但是，他们依然需要重复处理第一个 Pass 已经做过的很多工作。<br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work.png" alt="01_12de_duplicate-work.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work1.png" alt="01_12de_duplicate-work1.png" /><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org16b93bf" class="outline-6">
<h6 id="org16b93bf">GBuffer 内容</h6>
<div class="outline-text-6" id="text-org16b93bf">
<p>
<img src="./UnityCatLikeCoding/01_12de_gbuffer0.png" alt="01_12de_gbuffer0.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer1.png" alt="01_12de_gbuffer1.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer2.png" alt="01_12de_gbuffer2.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer3.png" alt="01_12de_gbuffer3.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org0f8a295" class="outline-6">
<h6 id="org0f8a295">Rendering Lights</h6>
<div class="outline-text-6" id="text-org0f8a295">
</div>
<ul class="org-ul">
<li><a id="org486d56c"></a>Directional Lights<br />
<div class="outline-text-7" id="text-org486d56c">
<p>
因为方向光影响所有物体，通过渲染一个覆盖整个视图的四边形来计算方向光的渲染。Unity 默认使用 Internal-DeferredShading.shader 来渲染这个四边形。(每个方向光使用一个四边形计算一次，多个方向光计算多次)<br />
下图中使用了两个方向光，其中渲染了两次：<br />
<img src="./UnityCatLikeCoding/01_12de_directional_light_rendering.png" alt="01_12de_directional_light_rendering.png" /><br />
</p>
</div>
</li>
<li><a id="orgcabe38b"></a>Spot Lights<br />
<div class="outline-text-7" id="text-orgcabe38b">
<p>
spot light 不会影响所有物体，使用一个棱锥体可以表示 Spot light 照亮的体积，所以通过渲染一个棱锥体来执行 Spot Light 的渲染，这样只有棱锥体可见区域会被渲染。如果棱锥体完全被其他物体遮挡，则不需要渲染该 spot light。如果棱锥体的任何一个片段被渲染，将会执行该 spot light 的光照计算。<br />
只有真的有物体在 spot light 照亮的体积中时，光照计算才是有意义的。在棱锥体后面的几何体是不需要渲染的，因为 spot light 照不到该几何体。<br />
为了避免渲染不必要的片段，首先使用 Internal-StencilWrite.shader 渲染棱锥体，该 Pass 会写入模板缓冲区，用来标识哪些片段需要渲染。不过当棱锥体和摄像机近平面交叉时不能使用该技术，因为此时近平面外的正面被摄像机剔除，只有反面写入了模板值。<br />
<img src="./UnityCatLikeCoding/01_12de_spot_light_rendering.png" alt="01_12de_spot_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="org74d52b6"></a>Point lights<br />
<div class="outline-text-7" id="text-org74d52b6">
<p>
point light 和 spot light 类似，只是使用球体来表示 point light 照亮的体积。<br />
<img src="./UnityCatLikeCoding/01_12de_point_light_rendering.png" alt="01_12de_point_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="org114c3d6"></a>Q&amp;A<br />
<div class="outline-text-7" id="text-org114c3d6">
<ul class="org-ul">
<li>渲染灯光对应的物体时，为什么需要关闭正反面剔除？<br />
<ul class="org-ul">
<li>因为需要利用正反面分两次写入模板缓冲区，详细解释可以参考 <a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf888461" class="outline-6">
<h6 id="orgf888461">Light Range</h6>
<div class="outline-text-6" id="text-orgf888461">
<p>
延迟渲染中，Unity 默认使用 LDR(Low Dynamic Range)渲染场景，此时颜色值被写入到 ARGB32 格式的贴图中，Unity 使用对数运算来编码颜色从而扩大存储的颜色范围。Final Deferred Pass 会将这些颜色值转化为正常范围的颜色值。可以在 Camera 中可以设置是否开启 HDR。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">col.xyz += GetEmissive(i);
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(DEFERRED_PASS)
  output.gBuffer0.rgb = albedo;
  output.gBuffer0.a = GetOcclusion(i);
  output.gBuffer1.rgb = specColor;
  output.gBuffer1.a = smoothness;
  output.gBuffer2 = float4(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">  #if</span> !<span style="color: #bc6ec5;">defined</span>(UNITY_HDR_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#25351;&#25968;-&#23545;&#25968;&#36816;&#31639;&#26469;&#32534;&#30721;&#35299;&#30721;&#39068;&#33394;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exp2(-col.rgb) = 2^{-col.rgb}</span>
    col.rgb = exp2(-col.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  output.gBuffer3 = col;
<span style="color: #bc6ec5;">#else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return indirect.specular.rgbr;</span>
  output.color = col;
<span style="color: #bc6ec5;">#endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DEFFERRED_PASS</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<p>
下图为不开启和开启 HDR 对于的 RenderTarget 贴图格式：<br />
<img src="./UnityCatLikeCoding/01_12de_ldr.png" alt="01_12de_ldr.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_hdr.png" alt="01_12de_hdr.png" /><br />
</p>
</div>
</div>

<div id="outline-container-orge73e04d" class="outline-6">
<h6 id="orge73e04d">Mixing Rendering Modes</h6>
<div class="outline-text-6" id="text-orge73e04d">
<p>
场景中一部分物体使用的 shader 不支持延迟渲染模式时，引擎会先执行延迟渲染，将支持延迟渲染的物体绘制出来，然后再执行前向渲染，将其他不支持延迟渲染的物体绘制出来。<br />
Unity 的延迟渲染不支持半透明物体，半透明物体需要 Forward rendering 阶段来渲染(因为半透明物体意味着需要将半透明物体叠在其后面的物体上，每多一个半透物体重叠就额外需要一整套 GBuffer 来存储对应半透明物体的渲染数据)。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org3922b62" class="outline-5">
<h5 id="org3922b62">Support Deferred Path</h5>
<div class="outline-text-5" id="text-org3922b62">
</div>
<div id="outline-container-org777dcf0" class="outline-6">
<h6 id="org777dcf0">创建 deferred pass</h6>
<div class="outline-text-6" id="text-org777dcf0">
<p>
延迟渲染需要 GPU 支持 MRT(multiple render targets).<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Pass</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Tags</span> {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34920;&#31034;&#35813;Pass&#29992;&#20110;&#24310;&#36831;&#28210;&#26579;</span>
        <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"Deferred"</span>
    }

    <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">    #pragma</span> target 3.0
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;GPU&#19981;&#25903;&#25345;MRT&#21017;&#25490;&#38500;&#24403;&#21069;Pass</span>
<span style="color: #bc6ec5;">    #pragma</span> exclude_renderers nomrt

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24310;&#36831;&#28210;&#26579;&#19981;&#25903;&#25345; _RENDERING_FADE&#21644; _RENDERING_TRANSPARENT</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature _ <span style="color: #7590db;">_RENDERING_CUTOUT</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_METALLIC_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature _ <span style="color: #7590db;">_SMOOTHNESS_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESS_METALLIC</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_NORMAL_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_OCCLUSION_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_MASK</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_ALBEDO_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_NORMAL_MAP</span>

<span style="color: #bc6ec5;">    #pragma</span> vertex MyVertexProgram
<span style="color: #bc6ec5;">    #pragma</span> fragment MyFragmentProgram

<span style="color: #bc6ec5;">    #define</span> DEFERRED_PASS

<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"MyDeferred.cginc"</span>
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a808ef" class="outline-6">
<h6 id="org0a808ef">deferred pass frag output</h6>
<div class="outline-text-6" id="text-org0a808ef">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> FragmentOutput {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24310;&#36831;&#28210;&#26579;&#38656;&#35201;&#23558;&#25968;&#25454;&#20445;&#23384;&#21040;&#22810;&#20010;RenderTarget</span>
<span style="color: #bc6ec5;">    #if</span> defined(DEFERRED_PASS)
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">    #endif</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org7891038" class="outline-6">
<h6 id="org7891038">gbufer0123</h6>
<div class="outline-text-6" id="text-org7891038">
<div class="org-src-container">
<pre class="src src-shader">FragmentOutput output;
<span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HDR_ON)
    color.rgb = <span style="color: #4f97d7;">exp2</span>(-color.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer0.rgb &#35760;&#24405;albedo</span>
  output.gBuffer0.rgb = albedo; 
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer0.a&#35760;&#24405;Occlusion</span>
  output.gBuffer0.a = GetOcclusion(i);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer1.rgb &#35760;&#24405;&#20102; specularColor</span>
  output.gBuffer1.rgb = specularTint;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer1.a &#35760;&#24405;&#20102;Smoothness</span>
  output.gBuffer1.a = GetSmoothness(i);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer2&#20013;&#35760;&#24405;&#20102;normal</span>
  output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal * 0.5 + 0.5, 1);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer3&#20013;&#35760;&#24405;&#20102;Emissive &#21644; environment ambient&#65292;&#21518;&#32493;&#20809;&#29031;&#35745;&#31639;&#24471;&#21040;&#30340;&#39068;&#33394;&#37117;&#20250;&#21472;&#21152;&#21040;GBuffer3&#20013;</span>
  output.gBuffer3 = color;
<span style="color: #bc6ec5;">#else</span>
  output.color = ApplyFog(color, i);
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>为什么自己写的 DeferredPass GBuffer0 中输出了高光颜色，GBuffer1 中颜色比较暗?<br />
FrameDebug 发现 MetallicMap 的贴图使用了 Unity 的默认贴图，进一步检查发现 shader 属性列表中定义的属性名称和 shader 中使用的名称不一致。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4a29015" class="outline-6">
<h6 id="org4a29015">support LDR</h6>
<div class="outline-text-6" id="text-org4a29015">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
  output.gBuffer0.rgb = albedo;
  output.gBuffer0.a = GetOcclusion(i);
  output.gBuffer1.rgb = specColor;
  output.gBuffer1.a = smoothness;
  output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HDR_ON)
  col.rgb = <span style="color: #4f97d7;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  output.gBuffer3 = col;
<span style="color: #bc6ec5;">#else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return indirect.specular.rgbr;</span>
  output.color = col;
<span style="color: #bc6ec5;">#endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DEFFERRED_PASS</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>Tone mapping 进化论 <a href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a><br /></li>
<li>Tone Mapping 与 Gamma Correction <a href="https://zhuanlan.zhihu.com/p/79203830">https://zhuanlan.zhihu.com/p/79203830</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3013e59" class="outline-5">
<h5 id="org3013e59">Deferred Reflections</h5>
<div class="outline-text-5" id="text-org3013e59">
</div>
<div id="outline-container-orgdfef112" class="outline-6">
<h6 id="orgdfef112">Unity 内置的屏幕空间反射</h6>
<div class="outline-text-6" id="text-orgdfef112">
<p>
延迟渲染时，反射球会被渲染，反射球被投影到和反射球体积有交叉的几何体上。因此，反射球的反射不会扩展到反射球体积之外。反射球的渲染类似于灯光的渲染，只是反射球是使用正方体渲染的。<br />
多个反射球按照顺序渲染，首先 skybox 被渲染，会覆盖整个视图。然后，各个反射球被渲染，每个反射球只会覆盖其体积内的表面。多个反射球体积有重叠时，重叠区域内，先绘制的反射球会被后绘制的反射球覆盖。<br />
默认情况下，体积大的反射球会先绘制，这样体积小的反射球就可以覆盖体积大的反射球。你可以通过修改反射球的 Importance 属性值来调整它的绘制顺序。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_probe_params.png" alt="01_12de_reflection_probe_params.png" /><br />
</p>
</div>
</div>

<div id="outline-container-orgecb0a21" class="outline-6">
<h6 id="orgecb0a21">延迟渲染使用非屏幕空间反射</h6>
<div class="outline-text-6" id="text-orgecb0a21">
<p>
关闭延迟渲染的屏幕空间反射后，Unity 会采用前向渲染的方式计算反射，将反射效果写入 GBuffer3 中。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_no_screen_space.png" alt="01_12de_reflection_no_screen_space.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdf57673" class="outline-4">
<h4 id="orgdf57673">Fog</h4>
<div class="outline-text-4" id="text-orgdf57673">
</div>
<div id="outline-container-orgcdfcc15" class="outline-5">
<h5 id="orgcdfcc15">Forward Fog</h5>
<div class="outline-text-5" id="text-orgcdfcc15">
<p>
在 LightSetting 可以设置雾相关的属性。<br />
</p>

<ul class="org-ul">
<li>ForwardPath 中为什么天空盒子不受雾效果的影响？<br />
雾效果是在 Standard Shader 中的片段着色器中，对片段颜色进行修改来实现的。Unity 的天空盒并没有使用 Standard Shader 进行渲染，所以其不受雾影响。<br /></li>
</ul>
</div>
<div id="outline-container-orgaae0d44" class="outline-6">
<h6 id="orgaae0d44">Linear Fog</h6>
<div class="outline-text-6" id="text-orgaae0d44">
<p>
线性模式的雾可以设置雾生效的最小距离和最大距离。离摄像机距离小于最小距离时没有雾的效果，在最小距离到最大距离雾的效果逐渐增加到最大，大于最大距离时显示最大雾的效果（即物体完全呈现雾的颜色）<br />
</p>

<p>
LinearFog 计算公式 \(f = \frac{fogEnd - fogCoor}{fogEnd-fogStart}\) <br />
</p>
</div>
</div>
<div id="outline-container-org525b1a4" class="outline-6">
<h6 id="org525b1a4">Exponential Fog</h6>
<div class="outline-text-6" id="text-org525b1a4">
<p>
一次指数模式的雾。<br />
</p>

<p>
ExponentialFog 计算公式 \(f = 2^{-fogCoor*fogDensity}\) <br />
</p>
</div>
</div>
<div id="outline-container-org197745c" class="outline-6">
<h6 id="org197745c">Exponential Squared Fog</h6>
<div class="outline-text-6" id="text-org197745c">
<p>
二次指数模式的雾。<br />
</p>

<p>
ExponentialSquaredFog 计算公式 \(f = 2^{-(fogCoor*fogDensity)^{2}}\) <br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_14fo_expFog.jpg" alt="01_14fo_expFog.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7c356da" class="outline-6">
<h6 id="org7c356da">Depth-Based Fog</h6>
<div class="outline-text-6" id="text-org7c356da">
<p>
Unity Shader 使用裁剪空间坐标的 w 分量作为 Fog Coordinate，裁剪空间坐标的 w 分量为投影变换前摄像机坐标系下坐标的 z 分量。这种计算雾的方式也称为基于深度的雾计算。<br />
基于深度的雾计算比基于距离的雾计算效率更高。基于距离的雾比基于深度的雾效果要好，基于深度的雾在摄像机旋转视角时，雾效会变化。下图说明了其中的原理：<br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_001.png" alt="01_14fo_depth_vs_distance_001.png" /><br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_002.png" alt="01_14fo_depth_vs_distance_002.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org0399548" class="outline-6">
<h6 id="org0399548">代码实现</h6>
<div class="outline-text-6" id="text-org0399548">
</div>
<ul class="org-ul">
<li><a id="orgd6e2397"></a>ApplyFog<br />
<div class="outline-text-7" id="text-orgd6e2397">
<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv.xy  = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    o.worldNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
    o.worldPos = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22522;&#20110;&#28145;&#24230;&#30340;&#38654;</span>
<span style="color: #bc6ec5;">#if</span> FOG_DEPTH
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL clip space z range = [-near, far]</span>
    o.worldPos.w = o.pos.z;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> tangentWorld = UnityObjectToWorldDir(v.tangent.xyz);
    <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = MCreateTangentToWorldPerVertex(o.worldNormal, tangentWorld, v.tangent.w);
    o.tangentToWorld[0] = tangentToWorld[0];
    o.tangentToWorld[1] = tangentToWorld[1];
    o.tangentToWorld[2] = tangentToWorld[2];
    ComputeVertexLightColor(o);

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS)
    TRANSFER_SHADOW(o);
<span style="color: #bc6ec5;">    #else</span>
    UNITY_TRANSFER_SHADOW(o, 0);
<span style="color: #bc6ec5;">    #endif</span>
    COMPUTE_LIGHT_COORDS(o);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}


<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ApplyFog</span>(<span style="color: #ce537a; font-weight: bold;">float</span> color, v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos);
<span style="color: #bc6ec5;">#if</span> FOG_DEPTH
    viewDistance = UNITY_Z_0_FAR_FROM_CLIPSPACE(i.worldPos.w);
<span style="color: #bc6ec5;">#endif</span>
    UNITY_CALC_FOG_FACTOR_RAW(viewDistance);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22810;&#20809;&#28304;&#25903;&#25345; &#21482;&#38656;&#35201;&#23545;&#31532;&#19968;&#20010;&#20809;&#28304;&#21472;&#21152;&#38654;&#30340;&#39068;&#33394;&#23601;&#21487;&#20197;&#20102;&#65292;&#20854;&#20182;&#20809;&#28304;&#21482;&#26681;&#25454;&#38654;&#30340;&#24378;&#24230;&#36827;&#34892;&#20943;&#24369;&#12290;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> fogColor = 0;
<span style="color: #bc6ec5;">#if</span> defined(FORWARD_BASE_PASS)
    fogColor = unity_FogColor.rgb;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(fogColor, color, unityFogFactor);
}
</pre>
</div>
</div>
</li>
<li><a id="org97b9279"></a>UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) 将 zclip space z value map to [0, far]<br />
<div class="outline-text-7" id="text-org97b9279">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(UNITY_REVERSED_Z)
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z == 1
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">D3d with reversed Z =&gt; z clip range is [near, 0] -&gt; remapping to [0, far]</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(((1.0-(coord)/<span style="color: #7590db;">_ProjectionParams</span>.y)*<span style="color: #7590db;">_ProjectionParams</span>.z),0)
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL with reversed z =&gt; z clip range is [near, -far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(-(coord), 0)
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#elif</span> UNITY_UV_STARTS_AT_TOP
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Opengl =&gt; z clip range is [-near, far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>为什么此处不需要将 Z 值线性化？而从深度缓存区取出的深度值需要线性化？<br />
 ClipSpace 的 Z 值(OpenGL Clip Space Z Range=[-near,far])没有经过透视除法，所以其 Z 值本身就是线性的;<br />
深度缓冲区中的 Z 值（Depth Buffer Z Range=[0, 1]）经过了透视除法，其值不是线性的(10%近处的场景占用了 0-0.9 范围的深度)。<br />
<ul class="org-ul">
<li>Depth Testing <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a><br /></li>
<li>linear Depth Buffer(线性深度缓冲区) <a href="https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html">https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1ced03d"></a>UNITY_CALC_FOG_FACTOR_RAW 实现了前面的计算公式<br />
<div class="outline-text-7" id="text-org1ced03d">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(FOG_LINEAR)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = (end-z)/(end-start) = z * (-1/(end-start))+(end/(end-start))</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    (coord) * unity_FogParams.z + unity_FogParams.w
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = exp(-density*z)</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    unity_FogParams.y * (coord); \
    unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor)
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP2)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = exp(-(density*z)^2)</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    unity_FogParams.x * (coord); \
    unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor*unityFogFactor)
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = 0.0
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = density / sqrt(ln(2)), useful for Exp2 mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">y = density / ln(2), useful for Exp mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">z = -1/(end-start), useful for Linear mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">w = end/(end-start), useful for Linear mode</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> unity_FogParams;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org94f6767" class="outline-5">
<h5 id="org94f6767">Deferred Fog</h5>
<div class="outline-text-5" id="text-org94f6767">
</div>
<div id="outline-container-orge9b0be8" class="outline-6">
<h6 id="orge9b0be8">Shader Source Code</h6>
<div class="outline-text-6" id="text-orge9b0be8">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Custom/DeferredFog"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_CameraDepthTexture</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_FrustumCorners</span>[4];

    <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
        <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    };

    <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
        <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
        <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
        <span style="color: #ce537a; font-weight: bold;">float3</span> ray;
<span style="color: #bc6ec5;">        #endif</span>
    };

    Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
        Interpolators i;
        i.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.vertex.xy, 0.0, 1.0);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30452;&#25509;&#36890;&#36807;&#19977;&#35282;&#24418;&#39030;&#28857;&#22352;&#26631;&#27714;&#30340;uv&#22352;&#26631;</span>
        i.uv = (v.vertex + 1) * 0.5;
<span style="color: #bc6ec5;">        #if</span> UNITY_UV_STARTS_AT_TOP
          i.uv= i.uv * <span style="color: #ce537a; font-weight: bold;">float2</span>(1.0, -1.0) + <span style="color: #ce537a; font-weight: bold;">float2</span>(0.0, 1.0);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; i.uv &#26144;&#23556;&#20026;&#25968;&#32452;&#30340;&#32034;&#24341;&#20540;</span>
          i.ray = <span style="color: #7590db;">_FrustumCorners</span>[i.uv.x+2*i.uv.y]
<span style="color: #bc6ec5;">        #endif</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> i;
    }

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">FragmentProgram</span> (Interpolators i) : <span style="color: #a45bad;">SV_Target</span> {
        <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, i.uv);
        depth = Linear01Depth(depth);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#21644;Forward Path&#20013;&#28145;&#24230;&#38654;&#35745;&#31639;&#19968;&#30452;&#38656;&#35201;&#20943;&#25481;near , &#21442;&#32771; UNITY_Z_0_FAR_FROM_CLIPSPACE &#20989;&#25968;&#20013;&#30340;&#22788;&#29702;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">_ProjectionParams // x=1 or -1  y=near z=far w=1/far</span>
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
        <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(depth * i.ray);
<span style="color: #bc6ec5;">        #else</span>
        <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = depth * <span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y;
<span style="color: #bc6ec5;">        #endif</span>
        UNITY_CALC_FOG_FACTOR_RAW(viewDistance);
        unityFogFactor = <span style="color: #4f97d7;">saturate</span>(unityFogFactor);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22825;&#31354;&#30418;&#28145;&#24230;&#20540;&#20026;1&#65292;&#36890;&#36807;&#19979;&#38754;&#21028;&#26029;&#65292;&#35753;&#38654;&#19981;&#24433;&#21709;&#22825;&#31354;&#30418;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (depth &gt; 0.9999)
        {
            unityFogFactor = 1;
        }
        <span style="color: #ce537a; font-weight: bold;">float3</span> color = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv).rgb;
        <span style="color: #ce537a; font-weight: bold;">float3</span> foggedColor = <span style="color: #4f97d7;">lerp</span>(unity_FogColor.rgb, color, unityFogFactor);
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(foggedColor, 1);
    }
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
        <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">            #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">            #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">            #pragma</span> multi_compile_fog
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">            #define</span> FOG_DISTANCE
<span style="color: #bc6ec5;">            #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">            #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">            #pragma</span> multi_compile_fog
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a5741e" class="outline-6">
<h6 id="org8a5741e">Depth-Based Fog</h6>
</div>
<div id="outline-container-orgda0831e" class="outline-6">
<h6 id="orgda0831e">Distance Based Fog</h6>
<div class="outline-text-6" id="text-orgda0831e">
<p>
从摄像机原点向远平面发射一条射线，如果从原点到远平面之间有物体，这射线最先接触的物体的交点到摄像机原点的距离就是我们要求的距离。<br />
从摄像机原点 O 到远平面交点 F 的射线(向量 OF)和从原点 O 到最先接触物体的交点 I 的射线(向量 OI)之间的关系为 \(OF=depth*OI\) ,其中 depth 为交点 I 对应的深度值。<br />
在 vertex shader 中设置每个顶点对应的 \(ray=\overrightarrow{OF}\) ,在 fragment shader 中就会得到各个像素对应的 OF 向量。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8c801f8" class="outline-4">
<h4 id="org8c801f8">Deferred Lights</h4>
<div class="outline-text-4" id="text-org8c801f8">
</div>
<div id="outline-container-orgada921a" class="outline-5">
<h5 id="orgada921a">Light Shader</h5>
<div class="outline-text-5" id="text-orgada921a">
</div>
<div id="outline-container-org034b213" class="outline-6">
<h6 id="org034b213">两个 Pass</h6>
<div class="outline-text-6" id="text-org034b213">
<p>
DeferredShading 需要两个 Pass。第一个 Pass 执行光照计算，第二个 Pass 处理 LDR 模式下的颜色解码。<br />
当 HDR 没开启时，光照数据是按照指数-对数运算编码解码的，前面的 DeferredShading 使用指数运算进行了编码，此时需要使用对数运算进行解码。<br />
</p>
</div>
</div>
<div id="outline-container-org10c267b" class="outline-6">
<h6 id="org10c267b">Avoiding the Sky</h6>
<div class="outline-text-6" id="text-org10c267b">
<p>
当 HDR 没有开启时，SceneView 中天空盒会显示不正确(Unity 2020.1.4f1 版本)，在第二个 Pass 中使用 StencilBuffer 作为 Mask，从而避免对数运算解码对天空盒对应的像素进行操作。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Pass</span> {
    <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
    <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
    <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off

    <span style="color: #4f97d7; font-weight: bold;">Stencil</span> {
        <span style="color: #4f97d7; font-weight: bold;">Ref</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
        <span style="color: #4f97d7; font-weight: bold;">ReadMask</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
        <span style="color: #4f97d7; font-weight: bold;">CompBack</span> Equal
        <span style="color: #4f97d7; font-weight: bold;">CompFront</span> Equal
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org99eee7f" class="outline-5">
<h5 id="org99eee7f">Directional Lights</h5>
<div class="outline-text-5" id="text-org99eee7f">
<p>
使用正交投影矩阵渲染一个矩形。具体实现参考有道云笔记 Unity Source Code.md<br />
</p>
</div>
<div id="outline-container-org2f9dfab" class="outline-6">
<h6 id="org2f9dfab">读取 G-Buffer 数据使用的 UV</h6>
<div class="outline-text-6" id="text-org2f9dfab">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
};

Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
    Interpolators i;
    i.pos = UnityObjectToClipPos(v.vertex);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35835;&#21462;G-Buffer&#25968;&#25454;&#20351;&#29992;&#30340;UV</span>
    i.uv = ComputeScreenPos(i.pos);
    <span style="color: #4f97d7; font-weight: bold;">return</span> i;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd1107a" class="outline-6">
<h6 id="orgfd1107a">像素对应的世界坐标位置</h6>
<div class="outline-text-6" id="text-orgfd1107a">
<p>
从原始透视摄像机到近平面四个角的射线存储在绘制四边形的 normal 中。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> ray : <span style="color: #a45bad;">TEXCOORD1</span>;
};

Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
    Interpolators i;
    i.pos = UnityObjectToClipPos(v.vertex);
    i.uv = ComputeScreenPos(i.pos);
    i.ray = v.normal;
    <span style="color: #4f97d7; font-weight: bold;">return</span> i;
}
<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv = i.uv.xy / i.uv.w;
    <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, uv);
    depth = Linear01Depth(depth);
    <span style="color: #ce537a; font-weight: bold;">float3</span> rayToFarPlane = i.ray * <span style="color: #7590db;">_ProjectionParams</span>.z / i.ray.z;
    <span style="color: #ce537a; font-weight: bold;">float3</span> viewPos = rayToFarPlane * depth;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#20687;&#32032;&#23545;&#24212;&#30340;&#19990;&#30028;&#22352;&#26631;&#20301;&#32622;&#65292;unity_CameraToWorld&#30697;&#38453;&#20026;&#21407;&#22987;&#36879;&#35270;&#25668;&#20687;&#26426;&#21040;&#19990;&#30028;&#31354;&#38388;&#30340;&#36716;&#25442;&#30697;&#38453;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos = <span style="color: #4f97d7;">mul</span>(unity_CameraToWorld, <span style="color: #ce537a; font-weight: bold;">float4</span>(viewPos, 1)).xyz;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6f22457" class="outline-6">
<h6 id="org6f22457">Supporting LDR</h6>
<div class="outline-text-6" id="text-org6f22457">
<p>
HDR 模式下，DeferredShading 只需要一个 Pass，该 Pass 的 Blend 模式设置为 Blend One One。直接将光照效果叠在之前计算的 Emission 等之上。<br />
LDR 模式下，DeferredShading 需要两个 Pass：<br />
第一个 Pass 执行光照计算，计算所得的颜色为 exp2(-lightingResult)，该值需要和之前 GBuffer 存储的颜色 exp2(-emissionGBuffer)组合起来，因此其 Blend 模式设置为 Blend DstColor Zero。<br />
第二个 Pass 对颜色进行解码，其 Blend 模式设置为 Blend One Zero。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgd942bc0" class="outline-5">
<h5 id="orgd942bc0">Spotlights</h5>
<div class="outline-text-5" id="text-orgd942bc0">
<p>
因为方向光可以影响到所有的物体，因此通过绘制全屏的矩形来实现方向光照明。SpotLight 只会影响其锥形范围内的物体，通常不需要为整个屏幕像素计算 SpotLight，通过绘制一个包含了 SpotLight 的金字塔来实现 SpotLight 照明。<br />
</p>
</div>
<div id="outline-container-org0a33c14" class="outline-6">
<h6 id="org0a33c14">像素对应的世界坐标位置</h6>
<div class="outline-text-6" id="text-org0a33c14">
<div class="org-src-container">
<pre class="src src-shader">unity_v2f_deferred <span style="color: #bc6ec5; font-weight: bold;">vert_deferred</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>)
{
    unity_v2f_deferred o;
    o.pos = UnityObjectToClipPos(vertex);
    o.uv = ComputeScreenPos(o.pos);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174;&#36879;&#35270;&#25668;&#20687;&#26426;&#21407;&#28857;&#21040;&#20687;&#32032;&#23545;&#24212;&#30340;&#39030;&#28857;&#30340;&#23556;&#32447;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">TODO Unity Camera Space&#21644;OpenGL&#24815;&#20363;&#30456;&#21516;&#65292;&#21363;Camera&#30340;forward&#26041;&#21521;&#20026;Z&#36724;&#30340;&#36127;&#26041;&#21521;&#65292;&#22240;&#27492;&#65292;&#27492;&#22788;&#38656;&#35201;&#21453;&#21521;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html</span>
    o.ray = UnityObjectToViewPos(vertex) * <span style="color: #ce537a; font-weight: bold;">float3</span>(-1,-1,1);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal contains a ray pointing from the camera to one of near plane's</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">corners in camera space when we are drawing a full screen quad.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Otherwise, when rendering 3D shapes, use the ray calculated here.</span>
    o.ray = <span style="color: #4f97d7;">lerp</span>(o.ray, normal, <span style="color: #7590db;">_LightAsQuad</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga0f788e" class="outline-5">
<h5 id="orga0f788e">Q&amp;A</h5>
<div class="outline-text-5" id="text-orga0f788e">
</div>
<div id="outline-container-orgb102177" class="outline-6">
<h6 id="orgb102177">为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？</h6>
<div class="outline-text-6" id="text-orgb102177">
<p>
参考有道云笔记 Unity Source Code.md，可以看出 Directional 对应的四边形的顶点 Position 数据为(0,0,nearPlane) (0,1,nearPlane) (1,1,nearPlane) (1,0,nearPlane)。绘制该矩形使用的矩阵为正交矩阵。这四个顶点经过正交矩阵变换后就是屏幕上 4 个角的点，nearPlane 对应 4 个角经过透视投影变换后也为屏幕上 4 个角的点。<br />
</p>
</div>
</div>

<div id="outline-container-org9133c43" class="outline-6">
<h6 id="org9133c43">为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？</h6>
<div class="outline-text-6" id="text-org9133c43">
<p>
DeferredShading 为了不覆盖之前 ColorBuffer 中的内容，其混合模式使用了 Blend One One, 所以当 DeferredShading 返回 0 时，其实显示的是之前绘制的内容。<br />
</p>
</div>
</div>
<div id="outline-container-org40605e5" class="outline-6">
<h6 id="org40605e5">为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？</h6>
<div class="outline-text-6" id="text-org40605e5">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ForwardShading</span>
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySpotCookie</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> lightCoord)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;uv&#38656;&#35201;&#20559;&#31227;0.5</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB</span>, lightCoord.xy / lightCoord.w + 0.5).w;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredShading</span>
<span style="color: #bc6ec5;">#if</span> defined(SPOT)
  <span style="color: #ce537a; font-weight: bold;">float4</span> uvCookie = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #ce537a; font-weight: bold;">float4</span>(worldPos, 1));
  uvCookie.xy /= uvCookie.w;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;uv&#19981;&#38656;&#35201;&#20559;&#31227;0.5 Unity&#22312;&#24341;&#25806;&#23618;&#35745;&#31639;unity_WorldToLight&#26102;&#32771;&#34385;&#20102;uv&#30340;&#20559;&#31227;&#65292;&#27492;&#22788;&#23601;&#19981;&#38656;&#35201;&#36827;&#34892;&#35745;&#31639;&#20102;&#12290;</span>
  atten *= tex2Dbias(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #ce537a; font-weight: bold;">float4</span>(uvCookie.xy, 0, -8)).w;
  atten *= uvCookie.w &lt; 0;
<span style="color: #bc6ec5;">  #if</span> defined(SHADOWS_DEPTH)
    shadowed = <span style="color: #a45bad;">true</span>;
    sAtten = CalcSAtten(sFade, worldPos);
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">#else</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org2f34f09" class="outline-4">
<h4 id="org2f34f09">Static Lighting</h4>
<div class="outline-text-4" id="text-org2f34f09">
</div>
<div id="outline-container-org91c7e83" class="outline-5">
<h5 id="org91c7e83">Lightmapping 光照贴图</h5>
<div class="outline-text-5" id="text-org91c7e83">
</div>
<div id="outline-container-org2bec968" class="outline-6">
<h6 id="org2bec968">简介</h6>
<div class="outline-text-6" id="text-org2bec968">
<p>
计算光照是比较昂贵的开销。虽然延迟渲染允许我们使用很多灯光，但是阴影依然是一个限制因素。如果我们的场景是动态的，我们无法避免这些计算。但是如果灯光和场景不会改变，我们就可以计算一次灯光后重用它。这样我们就可以放置很多灯光在场景中，而不需要在运行时渲染这些灯光。我们也可以使用区域灯光，这种灯光只能在烘培光照贴图的情况下使用。<br />
</p>
</div>
</div>
<div id="outline-container-org52f6f38" class="outline-6">
<h6 id="org52f6f38">Unity 中使用光照贴图的步骤</h6>
<div class="outline-text-6" id="text-org52f6f38">
<ol class="org-ol">
<li>把灯光的模式从 Realtime 切换为 Baked<br />
灯光一共有三种模式<br />
<ul class="org-ul">
<li>Realtime 实时灯光<br /></li>
<li>Baked 烘培灯光<br /></li>
<li>Mixed 混合灯光(既用于实时光照计算，又用于烘培光照计算)<br /></li>
</ul></li>
<li>在 Lighting Setting 中勾选 Baked Global Illumination.设置 Lighting Mode 为 Baked Indirect<br />
Lighting Mode 一共有三种模式<br />
<ul class="org-ul">
<li>Baked Indirect <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html">https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html</a><br /></li>
<li>Shadowmask <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html</a><br /></li>
<li>Subtractive <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html</a><br /></li>
</ul></li>
<li>将场景中固定不变的物体标记为 Lightmap Static<br />
MeshRenderer 组件的 Inspector 窗口中有一个 Lightmap Static 勾选框，其修改的就是 Lightmap Static 标记<br /></li>
</ol>

<p>
当场景中只有 Baked 模式的灯光时，光照贴图提供的光照要比实时光照效果暗一些。这是因为烘培的光照贴图只有 diffuse 光照，没有 specular 光照。specular 光照依赖于视角，即 specular 和摄像机方向相关，通常来说摄像机是可变的，所以无法在光照贴图中包含摄像机相关信息。这种限制意味着，光照贴图适用于微弱的光照和不闪亮(黯淡)的表面，不适用于强烈的光照和闪耀的表面。如果你需要 specular 光照，你必须使用实时光照。所以通常你需要混合使用烘培和实时光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7e5a72c"></a>Light=Baked LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Baked 模式）<br />
<div class="outline-text-7" id="text-org7e5a72c">
<p>
lightmapper 会将直接光和间接光都烘培到光照贴图中。此时，引擎向 shader 中传递的_LightColor0 值为(0,0,0,0)，所以实时调节灯光强度，不会有效果。<br />
这种模式下，无论场景中有多少灯光，运行时，只渲染一次物体。此时场景中没有实时光，此时不需要渲染阴影贴图，观察到的阴影效果是光照贴图中的颜色信息造成的。<br />
</p>
</div>
</li>
<li><a id="orgd44a9d2"></a>Light=Mixed LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Mixed 模式）<br />
<div class="outline-text-7" id="text-orgd44a9d2">
<p>
lightmapper 只会将间接光烘培到光照贴图中，所以该模式下的光照贴图比 Baked 模式下的要暗。此时，引擎会将正确的_LightColor0 传给 shader，所以实时调节灯光强度，会有效果（只会对直接光照有效果）。<br />
此时场景中有实时光，此时需要渲染阴影贴图，并且静态物体和动态物体都需要绘制阴影贴图。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7fcf37f" class="outline-6">
<h6 id="org7fcf37f">Lightmapping Settings</h6>
<div class="outline-text-6" id="text-org7fcf37f">
<p>
Lightmapper 有两种<br />
</p>
<ul class="org-ul">
<li>Enlighten<br /></li>
<li>Progressive 该方式会增量式生成 lightmaps，会优先生成当前 scene view 可见的物体的 lightmap，这对于编辑是比较方便的。<br /></li>
</ul>

<p>
Directional Mode 有两种<br />
</p>
<ul class="org-ul">
<li>Directional Mode<br /></li>
<li>Non-Direction<br /></li>
</ul>

<p>
Ambient Occlusion : 它是间接光照在角落和褶皱处的阴影。它是一种人为增强效果，可以提升深度感。Ambient Occlusion 单单基于表面的隐藏程度，其不会考虑光照的真实路径。所以，和自发光表面结合使用时，会有明显错误。<br />
</p>
</div>
</div>
<div id="outline-container-org2a87e1a" class="outline-6">
<h6 id="org2a87e1a">Indirect Light</h6>
<div class="outline-text-6" id="text-org2a87e1a">
<p>
烘培光照会考虑光照在多个表面的弹射，光子的每次弹射，都会损失一些能量，并且会被交互的材质修改颜色。Unity 在烘培间接光照时，都会考虑这些因素。<br />
</p>
</div>
</div>

<div id="outline-container-orgd01ea79" class="outline-6">
<h6 id="orgd01ea79">Transparency</h6>
<div class="outline-text-6" id="text-orgd01ea79">
<p>
对于单面透明物体，需要创建 Lightmap Parameters，将 IsTransparent 参数指定为 True，将 Lightmap Parameters 指定给单面透明物体。半透明物体会让间接光照通过，而不透明物体会阻挡间接光照。<br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_error.png" alt="01_16sl_transparentObj_bake_error.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_correct.png" alt="01_16sl_transparentObj_bake_correct.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf9158a" class="outline-5">
<h5 id="orgcf9158a">使用光照贴图</h5>
<div class="outline-text-5" id="text-orgcf9158a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#20351;&#29992;lightmaps&#21518;&#65292;unity &#23558;&#19981;&#20250;&#21253;&#21547;&#39030;&#28857;&#20809;&#29031;&#35745;&#31639;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON

<span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmap uv</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> tangentToWorld[3] : <span style="color: #a45bad;">TEXCOORD2</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos : <span style="color: #a45bad;">TEXCOORD5</span>;
    UNITY_SHADOW_COORDS(6)
    DECLARE_LIGHT_COORDS(7)
<span style="color: #bc6ec5;">#ifdef</span> VERTEXLIGHT_ON
    <span style="color: #ce537a; font-weight: bold;">float3</span> vertexLightColor : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">#elif</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmapUV</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">#endif</span>
};

v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

<span style="color: #bc6ec5;">#if</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026; lightmap&#30340;transformation&#27809;&#26377;&#34987;&#23450;&#20041;&#20026;unity_Lightmap_ST&#65292;&#25152;&#20197;&#26080;&#27861;&#20351;&#29992;TRANSFORM_TEX&#23439;</span>
    o.lightmapUV = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir) {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#if</span> defined(VERTEXLIGHT_ON)
    indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmap &#21644;&#39030;&#28857;&#20809;&#29031;&#19981;&#20250;&#21516;&#26102;&#20986;&#29616;</span>
    indirectLight.diffuse = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DecodeLightmap &#20250;&#22788;&#29702;&#20809;&#29031;&#36148;&#22270;&#19981;&#21516;&#26684;&#24335;</span>
    indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">    #else</span>
    indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc89e1fa" class="outline-5">
<h5 id="orgc89e1fa">创建光照贴图</h5>
<div class="outline-text-5" id="text-orgc89e1fa">
</div>
<div id="outline-container-org278247c" class="outline-6">
<h6 id="org278247c">lightmapper 默认规则</h6>
<div class="outline-text-6" id="text-org278247c">
<p>
lightmapper 不会使用实时渲染管线，所以它并不会使用我们的自己的 shader 来渲染 lightmap。<br />
lightmapper 会通过材质的 RenderType 来决定怎样对待物体表面:<br />
</p>
<ul class="org-ul">
<li>RenderType="Opaque" 不透明物体<br /></li>
<li>RenderType="Transparent" 半透明物体<br /></li>
<li>RenderType="TransparentCutout" 透贴型物体<br /></li>
</ul>

<p>
当没有贴图时，lightmapper 会通过材质的_Color 属性值的 a 分量来确定透明度，所以不能使用_MainColor _Tint 等属性名<br />
当有贴图时，lightmapper 会通过材质的_MainTex 贴图的 a 分量来确定透明度，所以不能使用_DiffuseTex _Albedo 等属性名<br />
<img src="./UnityCatLikeCoding/01_16sl_MainTexM_result.png" alt="01_16sl_MainTexM_result.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_MainTex_result.png" alt="01_16sl_MainTex_result.png" /><br />
lightmapper 会通过材质的 _Cutoff 属性值，作为透贴门槛值，所以不能使用_AlphaCutoff 等属性名<br />
</p>
</div>
</div>
<div id="outline-container-org778818f" class="outline-6">
<h6 id="org778818f">通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper</h6>
<div class="outline-text-6" id="text-org778818f">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Pass</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Name</span> <span style="color: #2d9574;">"META-MyLightmapping"</span>
    <span style="color: #4f97d7; font-weight: bold;">Tags</span>
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LightMode &#24517;&#39035;&#20026; Meta</span>
        <span style="color: #2d9574;">"LightMode"</span>=<span style="color: #2d9574;">"Meta"</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
    <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"MyStaticLighting_Lightmapping.cginc"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#include "MyStaticLighting_Lightmapping_Test.cginc"</span>
<span style="color: #bc6ec5;">    #pragma</span> vertex vert
<span style="color: #bc6ec5;">    #pragma</span> fragment frag
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_METALLICMAP_ON</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_ALBEDODETAIL_ON</span>
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
}

<span style="color: #bc6ec5;">#ifndef</span> MY_STATICLIGHTING_LIGHTMAPPING
<span style="color: #bc6ec5;">#define</span> MY_STATICLIGHTING_LIGHTMAPPING

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"UnityPBSLighting.cginc"</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"UnityMetaPass.cginc"</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#define _MainTex _MainTexM</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#define _MainTex_ST _MainTexM_ST</span>

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailTex</span>;
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailTex_ST</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailMask</span>;
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_EmissiveMap</span>;
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MetallicSmoothnessMap</span>;

v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv1.xy, unity_LightmapST, unity_LightmapST); 

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.pos = UnityObjectToClipPos(v.vertex);</span>

    o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(v2f i)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Color</span>.a;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetDetailMask</span>(v2f i)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_DetailMask</span>, i.uv.zw);
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlbedo</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> albedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy);
    albedo *= <span style="color: #7590db;">_Color</span>;
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_ALBEDODETAIL_ON</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> detailAlbedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailTex</span>, i.uv.zw);
    albedo = <span style="color: #4f97d7;">lerp</span>(albedo, albedo*detailAlbedo*unity_ColorSpaceDouble, GetDetailMask(i));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
}
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> emissive = 0;
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_EMISSION</span>)
    emissive = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_EmissiveMap</span>, i.uv);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #4f97d7;">dot</span>(emissive, emissive) &lt; 0.001)
    {
        emissive = <span style="color: #7590db;">_EmissionColor</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        emissive = emissive * <span style="color: #7590db;">_EmissionColor</span>;
    }
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> emissive;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetMetallic</span>(v2f i)
{
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).r * <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(v2f i)
{
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>) &amp;&amp; defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #elif</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span>) 
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : SV_TARGET
{
    UnityMetaInput o;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Emission = float3(0, 0, 1);</span>
    o.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Albedo = float3(1, 0, 0);   </span>
    <span style="color: #ce537a; font-weight: bold;">float</span> oneMinusReflectivity;
    o.Albedo = DiffuseAndSpecularFromMetallic(GetAlbedo(i), GetMetallic(i), o.SpecularColor, oneMinusReflectivity);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#25552;&#20379;&#30340;&#38388;&#25509;&#20809;&#29031;&#20250;&#36234;&#22810;, &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#20250;&#36234;&#22810;&#21453;&#23556;Specular&#20809;&#29031;&#20986;&#21435;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> roughness = SmoothnessToRoughness(GetSmoothness(i)) * 0.5;
    o.Albedo += o.SpecularColor * roughness;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Albedo = GetAlbedo(i);</span>
    o.SpecularColor = 0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(o);
}
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4768c54" class="outline-5">
<h5 id="org4768c54">Directional Lightmaps 具有方向的光照贴图</h5>
<div class="outline-text-5" id="text-org4768c54">
</div>
<div id="outline-container-orgc9be0f5" class="outline-6">
<h6 id="orgc9be0f5">简介</h6>
<div class="outline-text-6" id="text-orgc9be0f5">
<p>
lightmapper 只使用了顶点的几何数据，它没有考虑法线贴图数据。光照贴图的精度太低了，无法捕捉到传统法线贴图提供的细节。这意味着静态光照将会比较平。<br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-realtime.png" alt="01_16sl_normal-maps-realtime.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-lightmapped.png" alt="01_16sl_normal-maps-lightmapped.png" /><br />
上面两张图是，使用法线贴图的情况下，实时光照和烘培光照的效果对比。可以看到在烘培光照中，法线贴图的影响几乎没有，画面中微弱的法线效果来自环境反射。<br />
</p>
</div>
</div>

<div id="outline-container-orgd54c253" class="outline-6">
<h6 id="orgd54c253">方向性</h6>
<div class="outline-text-6" id="text-orgd54c253">
<p>
将 Directional Mode 设置为 Directional，就可以让法线贴图和烘培的光照协同工作。 在 Lighting/Lightmapping Settings/DirecionalMode 中，可以设置 Directional Mode = Directional。<br />
Directional Mode=Directional 时，unity 会生成两张光照贴图，一张就像之前一样的光照强度贴图，用于存储光照强度。新的另一张为光照方向贴图，用于存储最多的烘培光照的来源方向。<br />
</p>

<p>
下图为 NonDirectional 和 Directional 模式的对比：<br />
<img src="./UnityCatLikeCoding/01_16sl_non-directional.jpg" alt="01_16sl_non-directional.jpg" /><br />
<img src="./UnityCatLikeCoding/01_16sl_directional.jpg" alt="01_16sl_directional.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgc8b6437" class="outline-6">
<h6 id="orgc8b6437">使用烘培的方向贴图</h6>
<div class="outline-text-6" id="text-orgc8b6437">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#21551;&#28888;&#22521;&#26041;&#21521;&#36148;&#22270;&#30340;&#23439;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED


  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
<span style="color: #bc6ec5;">      #ifdef</span> VERTEXLIGHT_ON
      indirect.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">      #else</span>
      indirect.diffuse = 0;
<span style="color: #bc6ec5;">      #endif</span>
      indirect.specular = 0;


<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS) || defined(DEFFERRED_PASS)
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
              <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.diffuse = UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV);</span>
              indirect.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">              #if</span> defined(DIRLIGHTMAP_COMBINED)
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679;&#28888;&#22521;&#30340;&#26041;&#21521;&#36148;&#22270;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap,i.lightmapUV);
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;Half Lambert&#35745;&#31639;Diffuse</span>
              indirect.diffuse = DecodeDirectionalLightmap(indirect.diffuse, lightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #else</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeDirectionalLightmap (<span style="color: #ce537a; font-weight: bold;">half3</span> color, <span style="color: #ce537a; font-weight: bold;">fixed4</span> dirTex, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld) 
{
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">In directional (non-specular) mode Enlighten bakes dominant light</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">direction in a way, that using it for half Lambert and then dividing</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">by a "rebalancing coefficient" gives a result close to plain diffuse</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">response lightmaps, but normalmapped.</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Note that dir is not unit length on purpose. Its length is</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">"directionality", like for the directional specular lightmaps.</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> halfLambert = <span style="color: #4f97d7;">dot</span>(normalWorld, dirTex.xyz - 0.5) + 0.5;

    <span style="color: #4f97d7; font-weight: bold;">return</span> color * halfLambert / <span style="color: #4f97d7;">max</span>(1e-4h, dirTex.w);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4b06785" class="outline-5">
<h5 id="org4b06785">Light Probes</h5>
<div class="outline-text-5" id="text-org4b06785">
<p>
Lightmaps 只对静态物体起作用，对动态物体不起作用。这会导致动态物体无法融入烘培光照的场景。Unity 使用 LightProbe 来存储其所在点的烘培光照信息，LightProbe 没有使用贴图存储光照信息，其使用 Spherical Harmonics 存储这些信息。<br />
场景中的动态物体会使用 LightProbe 存储的烘培光照信息来取代全局的环境数据。<br />
</p>
</div>
<div id="outline-container-org739f0f6" class="outline-6">
<h6 id="org739f0f6">为什么 SceneView 中不显示 LightProbe？</h6>
<div class="outline-text-6" id="text-org739f0f6">
<p>
SceneView 下 Gizmos/3D Icon 被缩放到最小了。<br />
</p>
</div>
</div>
<div id="outline-container-orgb2d4119" class="outline-6">
<h6 id="orgb2d4119">为什么 LightProb 对于动态物体不生效？</h6>
<div class="outline-text-6" id="text-orgb2d4119">
<p>
两个 LightProb 是无作用的，需要让 LightProbe 形成网才能生效。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgda63bea" class="outline-5">
<h5 id="orgda63bea">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgda63bea">
</div>
<div id="outline-container-org783b549" class="outline-6">
<h6 id="org783b549">使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？</h6>
<div class="outline-text-6" id="text-org783b549">
<ul class="org-ul">
<li>关于 3D 模型的二套 UV <a href="https://zhuanlan.zhihu.com/p/83322397">https://zhuanlan.zhihu.com/p/83322397</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1b0c282" class="outline-6">
<h6 id="org1b0c282">什么错误导致 lightmap 中不包含 Emission 颜色？</h6>
<div class="outline-text-6" id="text-org1b0c282">
<ul class="org-ul">
<li>缺乏 Meta Pass<br /></li>
<li><p>
Meta Pass 的 Fragment 没有按照如下方式输出<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : SV_TARGET
{
    UnityMetaInput surfaceData;
    surfaceData.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
    surfaceData.Albedo = GetAlbedo(i);
    surfaceData.SpecularColor = 0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(surfaceData);
}
</pre>
</div></li>
<li>材质的 MaterialGlobalIlluminationFlags 没设置为 BakedEmissive<br /></li>
<li><p>
vertex 着色器函数中输出的 SV_POSITION 不正确<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">v2f_meta <span style="color: #bc6ec5; font-weight: bold;">vert_test</span>(VertexInput v)
{
    v2f_meta o;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.pos = UnityObjectToClipPos(v.vertex);  // &#36825;&#26679;&#35745;&#31639;&#24471;&#20986;&#30340;pos&#26159;&#38169;&#35823;&#30340;&#12290;</span>
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST); 
    o.uv = TexCoords(v);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}
</pre>
</div></li>
<li>unity lightmap 数据清除有 bug，清除 lightmap 后，隐藏一个物体，再烘培，检查数据是否正确。<br />
lightmap 缓存极其不稳定，有时候隐藏了烘培依然不可以，需要隐藏一个其他物体再来一次。<br /></li>
<li><del>frag 着色器的 out 标记 SV_TARGET 是否全部使用大写</del> SV_Target 也是可以的<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org7856bb9"></a>参考资料<br />
<div class="outline-text-7" id="text-org7856bb9">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/MetaPass.html">https://docs.unity3d.com/Manual/MetaPass.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-org2db3667" class="outline-6">
<h6 id="org2db3667">Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数</h6>
<div class="outline-text-6" id="text-org2db3667">
<p>
宏定义写错了 DEFERRED_PASS 写成了 DEFFERRED_PASS。导致采样 unity_Lightmap unity_LightmapInd 的代码没有执行到，所以引擎没将图片传给 GPU。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9123843" class="outline-4">
<h4 id="org9123843">Mixed Lighting</h4>
<div class="outline-text-4" id="text-org9123843">
</div>
<div id="outline-container-org9c9a75b" class="outline-5">
<h5 id="org9c9a75b">烘培光照贴图的优缺点</h5>
<div class="outline-text-5" id="text-org9c9a75b">
</div>
<div id="outline-container-org1d514f5" class="outline-6">
<h6 id="org1d514f5">缺点</h6>
<div class="outline-text-6" id="text-org1d514f5">
<ul class="org-ul">
<li>无法烘培高光<br /></li>
<li>烘培光照只能通过 LightProbe 对动态物体产生影响<br /></li>
<li>烘培光照无法生成实时阴影<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4498c46" class="outline-6">
<h6 id="org4498c46">优点</h6>
<div class="outline-text-6" id="text-org4498c46">
<ul class="org-ul">
<li>烘培光照包含间接光照，实时光照不包含间接光照。间接光照可以极大提升场景的真实感。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org09522bc" class="outline-5">
<h5 id="org09522bc">Baking Indirect Light</h5>
<div class="outline-text-5" id="text-org09522bc">
<p>
实时光照和烘培光照各有优缺点，通过下面方式可以将实时光照和烘培光照结合使用。<br />
</p>
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Baked Indirect<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，烘培光照贴图时会发生两个变化：<br />
</p>
<ol class="org-ol">
<li>lightmapper 只会将间接光照存储到光照贴图中，所以此时的光照贴图比之前要暗一些。<br /></li>
<li>lightmap 只用于为静态物体提供间接光照，静态物体的直接光照也由场景中灯光实时提供；动态物体间接光由 light probe 提供，直接光照由场景中灯光实时提供。<br /></li>
</ol>

<p>
注意:<br />
在上面的设置下，静态物体也需要实时画阴影贴图。这种模式相当于实时光照的工作再加上光照贴图实现的间接光照，所以这种模式是比较消耗性能的。<br />
</p>
</div>
</div>
<div id="outline-container-org13121bc" class="outline-5">
<h5 id="org13121bc">Using a Shadowmask</h5>
<div class="outline-text-5" id="text-org13121bc">
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Baked<br /></li>
</ol>
<p>
这样设置时，并不会生产 shadowmask，此时相当于完全烘培 （相当于 Light=Baked LightingMode=BakedIndirect 设置下的烘培）。<br />
</p>

<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，间接光照和 mixed lights 的阴影 attenuation 都会存储到光照贴图中，阴影会存储到单独的一张 shadowmask 贴图中。<br />
如果只有 1 盏灯那么 shadowmask 只会占 r 通道，shadowmask 最多 4 个通道，所以最多可以支持 4 盏灯。<br />
</p>

<p>
这种模式比 MixedLight+BakedIndirect 的优势在于静态物体不需要实时画阴影。<br />
</p>
</div>
<div id="outline-container-orgba02140" class="outline-6">
<h6 id="orgba02140">Sampling the Shadowmask</h6>
<div class="outline-text-6" id="text-orgba02140">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowFade</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">float</span> atten)
{
<span style="color: #bc6ec5;">#if</span> HANDLE_SHADOWS_BLENDING_IN_GI
    <span style="color: #ce537a; font-weight: bold;">float</span> viewZ = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> shadowFadeDistance = UnityComputeShadowFadeDistance(i.worldPos, viewZ);
    <span style="color: #ce537a; font-weight: bold;">float</span> sFade = UnityComputeShadowFade(shadowFadeDistance);
    <span style="color: #ce537a; font-weight: bold;">float</span> bakedAtten = UnitySampleBakedOcclusion(i.lightmapUV, i.worldPos);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(atten, bakedAtten, sFade);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_OcclusionMaskSelector &#35813;&#21521;&#37327;&#21482;&#26377;&#19968;&#20010;&#20998;&#37327;&#20250;&#34987;&#35774;&#32622;&#20026;1&#65292;&#29992;&#20110;&#21305;&#37197;&#24403;&#21069;&#34987;&#28210;&#26579;&#30340;&#28783;&#20809;</span>
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySampleBakedOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos) {
<span style="color: #bc6ec5;">#if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D_SAMPLER(unity_ShadowMask, unity_Lightmap, lightmapUV.xy);
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(<span style="color: #4f97d7;">dot</span>(rawOcclusionMask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> UnityMixRealtimeAndBakedShadows (<span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> bakedShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> fade)
{
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26080;&#23454;&#21160;&#24577;&#38452;&#24433;&#26102;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
<span style="color: #bc6ec5;">#if</span> !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; !defined(SHADOWS_CUBE)
    <span style="color: #4f97d7; font-weight: bold;">return</span> bakedShadowAttenuation;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #if</span> defined (LIGHTMAP_SHADOW_MIXING)
        realtimeShadowAttenuation = <span style="color: #4f97d7;">saturate</span>(realtimeShadowAttenuation + fade);
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">min</span>(realtimeShadowAttenuation, bakedShadowAttenuation);
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">shadowFadeDistance&#33539;&#22260;&#20869;&#65292;&#20351;&#29992;sFadeFactor&#22312;&#23454;&#26102;&#38452;&#24433;&#21644;&#28888;&#22521;&#38452;&#24433;&#20043;&#38388;&#25554;&#20540;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36229;&#20986;shadowFadeDistance&#21518;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(realtimeShadowAttenuation, bakedShadowAttenuation, fade);
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">no shadowmask &#27809;&#26377;&#20351;&#29992;shadowmask&#26102;&#65292;&#20351;&#29992;&#23454;&#26102;&#38452;&#24433;atten+shadowFadeFactor</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(realtimeShadowAttenuation + fade);
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org5bdbbd6" class="outline-6">
<h6 id="org5bdbbd6">Support Deferred Path</h6>
<div class="outline-text-6" id="text-org5bdbbd6">
<p>
DeferredShading 中将 ShadowMask 写入到 GBuffer4 中<br />
DeferredLighting 中读取 GBuffer4 内容，对直接光照进行衰减<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredShading (MixedLighting.shader)</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> frag_output
{
<span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
        <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer4 : <span style="color: #a45bad;">SV_Target4</span>;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">#endif</span>
};

frag_output <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i)
{
    frag_output output;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWSMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
        <span style="color: #ce537a; font-weight: bold;">float2</span> shadowUV = 0;
<span style="color: #bc6ec5;">        #if</span> defined(LIGHTMAP_ON)
        shadowUV = i.lightmapUV;
<span style="color: #bc6ec5;">        #endif</span>
        output.gBuffer4 = UnityGetRawBakedOcclusions(shadowUV, i.worldPos.xyz);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredLighting (MixedLighting_DeferredLighting.shader)</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowMaskAttenuation</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK)
    <span style="color: #ce537a; font-weight: bold;">float4</span> mask = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CameraGBufferTexture4</span>, uv);
    atten = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(mask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
}

UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float</span> viewZ)
{
    UnityLight light;
    <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> sAtten = 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> sFade = GetShadowFade(worldPos, viewZ);
    <span style="color: #ce537a; font-weight: bold;">bool</span> shadowed = <span style="color: #a45bad;">false</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK)
        shadowed = <span style="color: #a45bad;">true</span>;
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (shadowed)
    {
        <span style="color: #ce537a; font-weight: bold;">float</span> smAtten = GetShadowMaskAttenuation(uv);
        sAtten = UnityMixRealtimeAndBakedShadows(sAtten, smAtten, sFade);
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">sAtten = saturate(sAtten + sFade);</span>
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
<span style="color: #bc6ec5;">            #if</span> !defined(SHADOWS_SHADOWMASK)
            UNITY_BRANCH
            <span style="color: #4f97d7; font-weight: bold;">if</span> (sFade &gt; 0.99)
            {
                sAtten = 1;
            }
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #endif</span>
    }
    light.color = <span style="color: #7590db;">_LightColor</span>.rgb * atten * sAtten;
    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8c7e3e" class="outline-6">
<h6 id="orga8c7e3e">Distance Shadowmask Mode</h6>
<div class="outline-text-6" id="text-orga8c7e3e">
<p>
Unity2017 版本之前 Distance Shadowmask 在 Lighting Setting 中设置，Unity2017 版本以及之后版本在 QualitySettings 中设置。<br />
</p>

<p>
注意：<br />
这种模式下，ShadowDistance 外使用 ShadowMask（相当于 ShadowMask 模式），ShadowDistance 内使用实时阴影（相当于 MixedLight+BakedIndirect，静态物体和动态物体都需要绘制阴影贴图，所以这种模式也是比较消耗性能的）。<br />
</p>
</div>
</div>
<div id="outline-container-org3c23fcb" class="outline-6">
<h6 id="org3c23fcb">Multiple Lights</h6>
<div class="outline-text-6" id="text-org3c23fcb">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">ForwardAdd Pass &#28155;&#21152;&#22914;&#19979;&#20195;&#30721;&#65292;UNITY_LIGHT_ATTENUATION &#23601;&#21487;&#20197;&#27491;&#30830;&#24037;&#20316;&#20102;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SHADOWMASK
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org514b14c" class="outline-5">
<h5 id="org514b14c">Subtractive Shadows</h5>
<div class="outline-text-5" id="text-org514b14c">
</div>
<div id="outline-container-orgf416e78" class="outline-6">
<h6 id="orgf416e78">简介</h6>
<div class="outline-text-6" id="text-orgf416e78">
<p>
Subtractive mode 只适用于 forward path。Subtractive Mode 的理念是静态物体依然通过 lightmaps 照亮，并且同时将动态物体的阴影因素考虑进去，这是通过减低阴影区域光照贴图的亮度来实现的。这种方式不生成 Shadow Mask 贴图。<br />
Subtractive mode 只适用于一个方向光，因此只支持主方向光的阴影。<br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的 Lightmap 贴图的对比如下（由烘培 16StaticLighting_Unity 场景生成）：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su.jpg" alt="01_17ml_bi_sm_su.jpg" /><br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的生成阴影贴图的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su_drawcall.jpg" alt="01_17ml_bi_sm_su_drawcall.jpg" /><br />
</p>

<p>
注意： LightMode 为 Mixed，Lighting Mode 为 BakedIndirect 时，静态物体依然会绘制阴影。<br />
</p>
</div>
</div>
<div id="outline-container-org1f2d775" class="outline-6">
<h6 id="org1f2d775">实现</h6>
<div class="outline-text-6" id="text-org1f2d775">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #define</span> SUBTRACTIVE_LIGHTING 1
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>

UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (Interpolators i)
{
    UnityLight light;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Subtractive&#27169;&#24335;&#19979;&#65292;&#38745;&#24577;&#29289;&#20307;&#30340;&#30452;&#25509;&#20809;&#29031;&#37117;&#34987;&#28888;&#22521;&#21040;lightmap&#20013;&#20102;&#65292;&#19981;&#38656;&#35201;&#35745;&#31639;&#30452;&#25509;&#20809;&#29031;</span>
<span style="color: #bc6ec5;">    #if</span> defined(DEFERRED_PASS)  || SUBTRACTIVE_LIGHTING
        light.dir = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
        light.color = 0;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Unity&#23454;&#29616;&#20013;&#23545;&#24212;&#30340;&#20989;&#25968;&#20026;&#65306;SubtractMainLightWithRealtimeAttenuationFromLightmap</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
{
<span style="color: #bc6ec5;">#if</span> SUBTRACTIVE_LIGHTING
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
    attenuation = GetShadowFade(i, attenuation);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = 1;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
    <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
    subtractedLight = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25903;&#25345;ShadowStrength</span>
    subtractedLight = <span style="color: #4f97d7;">lerp</span>(subtractedLight, indirect.diffuse, <span style="color: #7590db;">_LightShadowData</span>.x);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38745;&#24577;&#29289;&#20307;&#19978;&#28888;&#22521;&#30340;&#38452;&#24433;&#20063;&#20250;&#26174;&#31034;unity_ShadowColor.rgb&#39068;&#33394;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.diffuse = indirect.diffuse;</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20462;&#25913;&#21160;&#24577;&#29289;&#20307;&#22312;&#38745;&#24577;&#29289;&#20307;&#19978;&#25237;&#23556;&#30340;&#38452;&#24433;</span>
    indirect.diffuse = <span style="color: #4f97d7;">min</span>(subtractedLight, indirect.diffuse);
<span style="color: #bc6ec5;">#endif</span>
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2512a35" class="outline-5">
<h5 id="org2512a35">总结</h5>
<div class="outline-text-5" id="text-org2512a35">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Realtime</th>
<th scope="col" class="org-left">Baked</th>
<th scope="col" class="org-left">Mixed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BakedIndirect - Dynamic Object</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">BakedIndirect - Static Object</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shadowmask</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">DistanceShadowmask</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Subtractive</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgda62ef6" class="outline-5">
<h5 id="orgda62ef6">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgda62ef6">
</div>
<div id="outline-container-orgc848338" class="outline-6">
<h6 id="orgc848338"><span class="todo TODO">TODO</span> 如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？</h6>
<div class="outline-text-6" id="text-orgc848338">
<p>
这样做是不正确的。<br />
</p>
</div>
</div>
<div id="outline-container-org6eb2f09" class="outline-6">
<h6 id="org6eb2f09">烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？</h6>
<div class="outline-text-6" id="text-org6eb2f09">
<p>
LightMode 为 Mixed，LightingMode 为 BakedIndirect，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 Distance ShadowMask 的情况下，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 ShadowMask 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
LightMode 为 Mixed，LightingMode 为 Substractive 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
</p>
</div>
</div>
<div id="outline-container-org709708f" class="outline-6">
<h6 id="org709708f">ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图</h6>
<div class="outline-text-6" id="text-org709708f">
<p>
关闭 Unity，重新打开，可以解决该问题。<br />
</p>
</div>
</div>
<div id="outline-container-org363ffa9" class="outline-6">
<h6 id="org363ffa9">Deferred Path 模式下的间接光照计算是怎样的？</h6>
<div class="outline-text-6" id="text-org363ffa9">
<p>
indirect.diffuse DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。<br />
indirect.specular 的计算则分是否开启屏幕空间反射，不开启时，DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。开启时，则在屏幕空间反射时计算。<br />
</p>
</div>
</div>
<div id="outline-container-org8c4c5b1" class="outline-6">
<h6 id="org8c4c5b1">Error: 阴影轮廓处有光晕</h6>
<div class="outline-text-6" id="text-org8c4c5b1">
<p>
<img src="./UnityCatLikeCoding/01_17ml_shadow_error.png" alt="01_17ml_shadow_error.png" /><br />
经过检查发现是计算 Normal 时有错误，在下面代码的注释中有具体说明<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetNormal</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_NORMAL_ON</span>)
    normal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_NormalMap</span>, i.uv).wy * 2 - 1;
    normal.xy *= <span style="color: #7590db;">_BumpScale</span>;
    normal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal.xy, normal.xy)));
    normal = normal.xzy;
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_NORMALDETAIL_ON</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> detailNormal;
    detailNormal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailNormal</span>, i.uv).wy * 2 - 1;
    detailNormal.xy *= <span style="color: #7590db;">_BumpScale</span>;
    detailNormal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(detailNormal.xy, detailNormal.xy)));
    detailNormal = <span style="color: #4f97d7;">lerp</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(0,1,0), detailNormal.xzy, GetDetailMask(i));

    normal.x = normal.x + detailNormal.x;
    normal.y = normal.y * detailNormal.y;
    normal.z = normal.z + detailNormal.z;
<span style="color: #bc6ec5;">#endif</span>
    normal = <span style="color: #4f97d7;">normalize</span>(normal);

<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> wTangent = i.tangentToWorld[0];
    <span style="color: #ce537a; font-weight: bold;">float3</span> wBinormal = i.tangentToWorld[1];
    <span style="color: #ce537a; font-weight: bold;">float3</span> wNormal = i.tangentToWorld[2];
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#20195;&#30721;&#24050;&#32463;&#23558;normal&#21521;&#19978;&#30340;&#20998;&#37327;&#20174;z&#25442;&#21040;&#20102;y&#65292;&#25152;&#20197;&#36825;&#37324;&#21644;wNormal&#30456;&#20056;&#30340;&#24212;&#35813;&#26102;normal&#30340;y&#20998;&#37327;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal = normalize(wTangent*normal.x + wBinormal*normal.y + wNormal*normal.z);</span>
    normal = <span style="color: #4f97d7;">normalize</span>(wTangent*normal.x + wNormal*normal.y + wBinormal*normal.z);
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> normal;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org884a03b" class="outline-6">
<h6 id="org884a03b">Error: Subtractive 模式下动态物体的阴影很淡</h6>
<div class="outline-text-6" id="text-org884a03b">

<div class="figure">
<p><img src="./UnityCatLikeCoding/01_17ml_subtractive_dynamicObj_shadow_error.png" alt="01_17ml_subtractive_dynamicObj_shadow_error.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
{
<span style="color: #bc6ec5;">#if</span> SUBTRACTIVE_LIGHTING
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
    attenuation = GetShadowFade(i, attenuation);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
    <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
    indirect.diffuse = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbaff94c" class="outline-4">
<h4 id="orgbaff94c">RealtimeGI ProbeVolumes LOD Groups</h4>
<div class="outline-text-4" id="text-orgbaff94c">
</div>
<div id="outline-container-orgc08c83d" class="outline-5">
<h5 id="orgc08c83d">Realtime Globall Illumination</h5>
<div class="outline-text-5" id="text-orgc08c83d">
</div>
<div id="outline-container-org5f5ecdb" class="outline-6">
<h6 id="org5f5ecdb">简介</h6>
<div class="outline-text-6" id="text-org5f5ecdb">
<p>
烘培光照虽然对静态几何体(通过光照贴图)和动态几何体(通过光照探针)起作用，但是烘培光照无法处理动态光照(Realtime Mode Light)。Mixed Mode Light 可以实时调节一些参数，但是过多的调整会让没有改变的烘培间接光照变得很明显。所以，当你有一个室外的场景时，太阳是不能改变的，它不能像真实生活中一样东升西落在空中穿行，因为这需要不断改变全局照明，所以只能让场景冻结在某个时间点上。<br />
为了让间接光照支持光照方向的实时改变，Unity 使用 Enlighten 系统来计算实时全局照明。其就像烘培间接光一样工作，不同的是 Enlighten 是在运行时计算光照贴图和光照探针的。<br />
计算间接光需要知道光照在静态表面之间是如何弹射的，也就是需要知道哪些表面有可能会被哪些表面在哪些角度上产生影响。计算出这些关系需要很多工作，不可能在运行时完成。所以，这些数据是由编辑器计算并存储起来，运行时 Enlighten 会利用这些数据来计算光照贴图和光照探针。即使如此，实时全局照明也适用于低分辨率的光照贴图。<br />
</p>

<p>
注意：无论是 RealtimeGI 的光照贴图，还是 BakedGI 的光照贴图，只有标记为 Lightmap 静态的物体，才会使用烘培的光照贴图。而动态的物体则使用烘培的 LightProbe 数据。<br />
</p>
</div>
</div>
<div id="outline-container-org772dad1" class="outline-6">
<h6 id="org772dad1">Baking Realtime GI</h6>
<div class="outline-text-6" id="text-org772dad1">
<p>
Realtime GI 使用自己的 lightmap 坐标，Unity 会基于光照贴图和物体的设置自动生成这些 UV 坐标，这些 UV 坐标值被存储到 Mesh 的第三套 UV 通道。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_LightmapST &#26159;&#28888;&#22521;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_DynamicLightmapST&#26159;&#21160;&#24577;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);

    o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaVertexPosition</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex, <span style="color: #ce537a; font-weight: bold;">float2</span> uv1, <span style="color: #ce537a; font-weight: bold;">float2</span> uv2, <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapST, <span style="color: #ce537a; font-weight: bold;">float4</span> dynlightmapST)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;unity_MetaVertexControl&#26469;&#25511;&#21046;&#24403;&#21069;&#25805;&#20316;&#30340;&#26159;&#28888;&#22521;&#20809;&#29031;GI&#36824;&#26159;&#21160;&#24577;&#20809;&#29031;GI</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.x)
    {
        vertex.xy = uv1 * lightmapST.xy + lightmapST.zw;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL right now needs to actually use incoming vertex position,</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">so use it in a very dummy way</span>
        vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
    }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.y)
    {
        vertex.xy = uv2 * dynlightmapST.xy + dynlightmapST.zw;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL right now needs to actually use incoming vertex position,</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">so use it in a very dummy way</span>
        vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
}
</pre>
</div>
<p>
注意：<br />
烘培光照贴图和实时光照贴图都会用到 meta pass。所以当开启实时 GI 时，在打包的时候 meta pass 也会被包含进去。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orgd57d3bd"></a>为什么 Realtime GI 不公用静态光照贴图的模型 UV？<br /></li>
</ul>
</div>
<div id="outline-container-org8d5300f" class="outline-6">
<h6 id="org8d5300f">Sampling Realtime Lightmaps</h6>
<div class="outline-text-6" id="text-org8d5300f">
<p>
所有的实时灯光都会对实时 GI 有贡献。但是，典型的用法是，只将主方向光作用于实时 GI，因为主方向光代表着太阳，其会在天空中移动。实时 GI 的所有功能对方向光都是有效的，实时 GI 不支持点光源和 SpotLight 的阴影。因此，当使用会投影的点光源和 SpotLight 时，最终会得到不正确的间接光照。<br />
如果你想将某个实时光从实时 GI 中排除，只需要将该灯光的 IndirectMultiplier 设置为 0。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
    UnityIndirect indirect;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#if</span> defined(DYNAMICLIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21160;&#24577;Lightmap&#20351;&#29992;&#20102;&#21644;&#38745;&#24577;Lightmap&#19981;&#21516;&#30340;&#39068;&#33394;&#26684;&#24335;&#65292;&#38656;&#35201;&#19981;&#21516;&#30340;&#35299;&#30721;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> dynamicLightDiffuse = DecodeRealtimeLightmap(UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, i.dynamicLightmapUV));
<span style="color: #bc6ec5;">    #if</span> defined(DIRLIGHTMAP_COMBINED)
        <span style="color: #ce537a; font-weight: bold;">float4</span> dynamicLightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap,i.dynamicLightmapUV);
        indirect.diffuse += DecodeDirectionalLightmap(dynamicLightDiffuse, dynamicLightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">    #else</span>
        indirect.diffuse += dynamicLightDiffuse;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809;</span>
    indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b99f28" class="outline-6">
<h6 id="org8b99f28">Emissive Light</h6>
<div class="outline-text-6" id="text-org8b99f28">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> EmissiveOscillator : MonoBehaviour
{
    Renderer r;
    <span style="color: #4f97d7; font-weight: bold;">Material</span> mat;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Start</span>()
    {
        r = GetComponent&lt;Renderer&gt;();
        mat = r.material;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">Color</span> c = <span style="color: #4f97d7; font-weight: bold;">Color</span>.Lerp(<span style="color: #4f97d7; font-weight: bold;">Color</span>.white, <span style="color: #4f97d7; font-weight: bold;">Color</span>.black, Mathf.Sin(Time.time * Mathf.PI) * 0.5f + 0.5f);
        mat.SetColor(<span style="color: #2d9574;">"_EmissionColor"</span>, c);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#23454;&#26102;GI</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#20250;&#35302;&#21457;&#20351;&#29992;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">r.UpdateGIMaterials();</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#19981;&#20250;&#35302;&#21457;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#21482;&#26159;&#30452;&#25509;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
        DynamicGI.SetEmissive(r, c);
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3158e6e" class="outline-5">
<h5 id="org3158e6e">Light Probe Proxy Volumes</h5>
<div class="outline-text-5" id="text-org3158e6e">
<p>
烘培 GI 和实时 GI 都是通过 LightProbe 作用于动态物体的。物体的位置用于插值 LightProbe 数据，插值得到的数据再应用于 GI。这对于小物体来说是可行的，但是对于大物体来说就太粗暴了。<br />
</p>

<p>
LLPV（light probe proxy volume）可以解决该问题。其会传递给 shader 一组经过插值的 LightProbe 数据，而不是一个。这些数据会存储到一张浮点型 3D 贴图中，且该贴图需要支持线性过滤模式，只有现代图形显卡才能支持。<br />
在 Graphics/TierSettings/EnableLightProbeProxyVolume 中开启 LightProbeProxyVolume。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
<span style="color: #bc6ec5;">    #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
        <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Light Probe Proxy Volume &#21482;&#20351;&#29992;&#20102;&#20004;&#20010;&#22522;&#24102;</span>
            indirect.diffuse = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.worldNormal, 1), i.worldPos);
            indirect.diffuse = <span style="color: #4f97d7;">max</span>(0, indirect.diffuse);
<span style="color: #bc6ec5;">            #if</span> defined(UNITY_COLORSPACE_GAMMA)
                indirect.diffuse = LinearToGammaSpace(indirect.diffuse);
<span style="color: #bc6ec5;">            #endif</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809; LightProbe ShadeSH9&#20013;&#24050;&#32463;&#22788;&#29702;&#20102;&#39068;&#33394;&#31354;&#38388;&#30340;&#38382;&#39064;</span>
            indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
        }
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809; LightProbe</span>
        indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgddd45be" class="outline-5">
<h5 id="orgddd45be">LOD Groups</h5>
<div class="outline-text-5" id="text-orgddd45be">
</div>
<div id="outline-container-orgea8adde" class="outline-6">
<h6 id="orgea8adde">Baked GI and Lod Group</h6>
<div class="outline-text-6" id="text-orgea8adde">
<p>
在烘培静态光照贴图时，使用的是 LOD0。即使在运行时显示的是 LOD1 或者是 LOD culled ，此时阴影和间接光照都是使用的烘培 LOD0 所得数据。<br />
<img src="./UnityCatLikeCoding/01_18ml_lod1_01.jpg" alt="01_18ml_lod1_01.jpg" /><br />
但是 LOD1 依然会使用 lightmap，其采样的数据和 LOD0 采样的数据并不同(分布在 lightmap 贴图的不同位置)，Unity 利用烘培的 LightProbe 来计算 LOD1 的间接光照然后写入到 Lightmap 中，所以烘培带有 LOD 的场景时，需要添加 LightProbe，否则 LOD1 的间接光照会变为黑色，从而显得很暗。<br />
下图是，开启 LightProbe 和关闭 LightProbe 烘焙场景得到的不同效果:<br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withoutLightProbe.png" alt="01_18ml_lodGroup_bake_withoutLightProbe.png" /><br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withLightProbe.png" alt="01_18ml_lodGroup_bake_withLightProbe.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orge32b234" class="outline-6">
<h6 id="orge32b234">Realtime GI and Lod Group</h6>
<div class="outline-text-6" id="text-orge32b234">
<p>
当只开启 Realtime GI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且取消勾选 BakedGlobalIllumination），在运行时 Lod0 依然使用实时烘培的光照贴图，而 Lod1 会使用 LightProbe 数据(运行时，选中显示 Lod1 的物体，SceneView 下可以看到其使用的 LightProbe，这里需要强调的是，即使 Lod1 是静态物体其使用的也是 LightProbe)。<br />
</p>

<p>
在同时使用 RealtimeGI 和 BakedGI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且勾选 BakedGlobalIllumination），Lod0 会同时使用 Realtime Lightmap （实时光的贡献）和 Baked Lightmap（烘培光的贡献），而 Lod1 只会使用 Baked Lightmap，因为 lightmap 和球谐光照无法同时使用，Lod1 就不会受到 realtime GI 的影响。<br />
</p>

<p>
注意：烘培和渲染 Lod 是完全独立的，如果实时 GI 比烘培 GI 更重要，可以在运行时设置 LOD1 为非 lightmap-static，这样 LOD1 就会使用 Realtime GI 的 LightProbe。<br />
</p>
</div>
</div>
<div id="outline-container-org7e37468" class="outline-6">
<h6 id="org7e37468">Cross-fading Between Lod Levels</h6>
<div class="outline-text-6" id="text-org7e37468">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile _ LOD_FADE_CROSSFADE

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4*64 &#22823;&#23567;&#36148;&#22270;</span>
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DitherMaskLOD2D</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UnityApplyDitherCrossFade</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> vpos)
{
    vpos /= 4; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the dither mask texture is 4x4</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_LODFade&#21464;&#37327;&#23384;&#20648;&#20102;&#24403;&#21069;fade&#30340;&#24635;&#37327;&#65292;&#25972;&#20010;&#36807;&#31243;&#19968;&#20849;16&#27493;(fade&#19968;&#27493;&#30340;&#20540;&#20026;1/16)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">quantized lod fade by 16 levels</span>
    vpos.y = <span style="color: #4f97d7;">frac</span>(vpos.y) * 0.0625 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">1/16 */</span> + unity_LODFade.y;
    <span style="color: #4f97d7;">clip</span>(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DitherMaskLOD2D</span>, vpos).a - 0.5);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1fb785a" class="outline-6">
<h6 id="org1fb785a">Q&amp;A</h6>
<div class="outline-text-6" id="text-org1fb785a">
</div>
<ul class="org-ul">
<li><a id="orgc332175"></a><span class="todo TODO">TODO</span> 为什么不将 LOD1 像 LOD0 那样处理，再渲染一次 LOD1 得到精确的亮度数据写入光照贴图中？<br /></li>
<li><a id="org366a662"></a><span class="todo TODO">TODO</span> 为什么球谐光照和 lightmap 无法同时使用？<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9687987" class="outline-4">
<h4 id="org9687987">GPU Instancing</h4>
<div class="outline-text-4" id="text-org9687987">
</div>
<div id="outline-container-orgfcf9980" class="outline-5">
<h5 id="orgfcf9980">Batching Instances</h5>
<div class="outline-text-5" id="text-orgfcf9980">
</div>
<div id="outline-container-orge690dc6" class="outline-6">
<h6 id="orge690dc6">简介</h6>
<div class="outline-text-6" id="text-orge690dc6">
<p>
向 GPU 提交绘制命令会花费时间。将数据（mesh 和材质属性）提交给 GPU 也会耗费时间。<br />
Static Batching:  Unity 可以将很多静态的物体合并为一个大的静态物体，这可以减少 DrawCall，但是只有使用相同材质的物体才能以这种方式合并。这样做的代价是需要存储更多的 Mesh 数据。<br />
Dynamic Batching: 运行时 Unity 会对动态物体执行类似于 Static Batching 一样的操作，只是其只会将很多比较小的 mesh 合并为一个大的 mesh(动态合并大物体的消耗太大了)。<br />
GPU Instancing:   运行时通知 GPU 绘制同一个 mesh 多次，GPU Instancing 无法将不同的 mesh 或材质合并，但是其并不要求 mesh 必须为小 mesh。<br />
</p>

<ul class="org-ul">
<li>Draw call batching <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org098f3e3" class="outline-6">
<h6 id="org098f3e3">Support GPU Instancing</h6>
<div class="outline-text-6" id="text-org098f3e3">
</div>
<ul class="org-ul">
<li><a id="org4c070bd"></a>支持 GPU Instancing<br />
<div class="outline-text-7" id="text-org4c070bd">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327;SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;
};

vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    vert_out o;
    UNITY_INITIALIZE_OUTPUT(vert_out, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#35299;&#24403;&#21069;&#23454;&#20363;&#30340; Obj2World World2Obj&#30697;&#38453;</span>
    UNITY_SETUP_INSTANCE_ID(v);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org5ebb099"></a>Unity 对 GPU Instancing 的封装<br />
<div class="outline-text-7" id="text-org5ebb099">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;instanceID</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> uint unity_InstanceID;

CBUFFER_START(UnityDrawCallInfo)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Where the current batch starts within the instanced arrays.</span>
  <span style="color: #ce537a; font-weight: bold;">int</span> unity_BaseInstanceID;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31995;&#32479;&#21464;&#37327;&#21517;&#31216;SV_InstanceID</span>
<span style="color: #bc6ec5;">#define</span> UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;

<span style="color: #bc6ec5;">#define</span> UNITY_SETUP_INSTANCE_ID(input) \
  unity_InstanceID = input.instanceID + unity_BaseInstanceID;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Redefine some of the built-in variables /</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">macros to make them work with instancing.</span>
UNITY_INSTANCING_CBUFFER_START(PerDraw0)
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorldArray[UNITY_INSTANCED_ARRAY_SIZE];
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObjectArray[UNITY_INSTANCED_ARRAY_SIZE];
UNITY_INSTANCING_CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;instance&#25968;&#25454;&#35206;&#30422;&#21407;&#22987;&#23450;&#20041;&#20869;&#23481;</span>
<span style="color: #bc6ec5;">#define</span> unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
<span style="color: #bc6ec5;">#define</span> unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</pre>
</div>

<p>
forward base pass, shadow pass, deferred pass 都支持 GPU Instancing.<br />
forward add pass 不支持 GPU Instancing.<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb893b29" class="outline-6">
<h6 id="orgb893b29">Batch Size</h6>
<div class="outline-text-6" id="text-orgb893b29">
<p>
每个 Batch 都需要自己的矩阵数组。这些数据被发送给 GPU，然后被存储在内存缓冲区(D3D 的 ConstantBuffer,OpenGL 的 UniformBuffer)中。这些缓冲区有最大容量限制，这限制了每个 batch 的实例数量。<br />
假设台式机每个 UniformBuffer 的大小为 64KB，一个矩阵有 16 个浮点数，每个浮点数需要 4 字节存储，每个实例需要 1 个 object-to-world 变换矩阵，如果使用了法线贴图，则还需要 1 个 world-to-object 变换矩阵(用于将法线变换到世界空间)<br />
16*4*2 = 128Byte 64KB/128B=64*1024B/128=512<br />
</p>

<p>
UNITY_INSTANCED_ARRAY_SIZE 默认被定义为 500, 移动平台下被定义为 250.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#19979;&#38754;&#30340;&#25351;&#20196;&#21487;&#20197;&#23558;&#23454;&#20363;&#25968;&#37327;&#20462;&#25913;&#20026;512</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options maxcount:512
</pre>
</div>

<ul class="org-ul">
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3c26ac8" class="outline-5">
<h5 id="org3c26ac8">Mixing Material Properties</h5>
<div class="outline-text-5" id="text-org3c26ac8">
<p>
所有 DrawCall Batching 都需要物体使用相同的材质。<br />
可以通过 MaterialPropertyBlock 来修改材质属性，从而实现使用相同材质的物体可以有不同的外观，但是通过 MaterialPropertyBlock 修改材质属性，依然会导致 GPU Instancing 失败，因为不同的实例使用了不同的材质属性。<br />
只有在 shader 中定义一个被修改属性的 buffer，Unity 才会将存储在 Material Property Block 中的属性当作数组传递到 GPU(和 Unity 在 GPUInstancing 时对变换矩阵数组的操作一样)，此时 GPU Instancing 才会生效。<br />
MaterialPropertyBlock 支持 Color,Float,Matrix,Vector 类型的属性，如果想支持 Texture 类型，可以使用 TextureArray 然后添加一个 Index 属性将 Index 属性放到 InstancingBuffer 中。<br />
多个属性可以组合放在同一个 Buffer 中，需要注意每个 Buffer 有尺寸限制。另外，Buffer 都是 32 位对齐的，也就是说一个 Float 占用的空间和一个 Vector 占用空间相同。可以使用多个 Buffer，但是 Buffer 的数量也是有限制的，而且 Buffer 也是有性能消耗的。当 GPUInstancing 开启后，每个被放入 Buffer 的属性都会变为一个数组，所以应该只将每个实例都不同的属性放入 Buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;

};

<span style="color: #4f97d7; font-weight: bold;">struct</span> vert_out
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> frag_in
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    vert_out o;
    UNITY_INITIALIZE_OUTPUT(vert_out, o);
    UNITY_SETUP_INSTANCE_ID(v);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;InstanceID&#20256;&#36882;&#21040;fragment</span>
    UNITY_TRANSFER_INSTANCE_ID(v, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(frag_in i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;InstanceID&#33719;&#21462;&#24403;&#21069;&#23454;&#20363;&#30340;&#23646;&#24615;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> alpha = UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, <span style="color: #7590db;">_Color</span>).a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * alpha;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#20250;&#23558; unity_LODFade &#25918;&#20837;Buffer&#65292;&#36825;&#26679;&#22312;&#35774;&#32622;LodFadeMode=CrossFade&#26102;&#65292;GPUInstancing&#19981;&#20250;&#22833;&#25928;</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options lodfade
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd09c4d8" class="outline-4">
<h4 id="orgd09c4d8">Parallax</h4>
<div class="outline-text-4" id="text-orgd09c4d8">
</div>
<div id="outline-container-org85217e4" class="outline-5">
<h5 id="org85217e4">参考资料</h5>
<div class="outline-text-5" id="text-org85217e4">
<ul class="org-ul">
<li>Parallax-Mapping <a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">https://learnopengl.com/Advanced-Lighting/Parallax-Mapping</a><br /></li>
<li>Learn about Parallax en <a href="https://github.com/UPBGE/upbge/issues/1009">https://github.com/UPBGE/upbge/issues/1009</a><br /></li>
<li>Learn about Parallax cn <a href="https://zhuanlan.zhihu.com/p/128682162">https://zhuanlan.zhihu.com/p/128682162</a> <br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaa8c2ce" class="outline-3">
<h3 id="orgaa8c2ce">Advanced Rendering</h3>
<div class="outline-text-3" id="text-orgaa8c2ce">
</div>
<div id="outline-container-org549c10f" class="outline-4">
<h4 id="org549c10f">Flat and Wireframe Shading</h4>
<div class="outline-text-4" id="text-org549c10f">
</div>
<div id="outline-container-org57585f1" class="outline-5">
<h5 id="org57585f1">Barycentric Coordinates</h5>
</div>

<div id="outline-container-orgd539200" class="outline-5">
<h5 id="orgd539200">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgd539200">
</div>
<div id="outline-container-orgb141de7" class="outline-6">
<h6 id="orgb141de7">为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？</h6>
<div class="outline-text-6" id="text-orgb141de7">
<p>
cross 操作需要注意向量的正反方向，将所得向量取反就可以了。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org38e28e3" class="outline-4">
<h4 id="org38e28e3">Tessellation</h4>
<div class="outline-text-4" id="text-org38e28e3">
</div>
<div id="outline-container-orgedec0cf" class="outline-5">
<h5 id="orgedec0cf">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgedec0cf">
</div>
<div id="outline-container-orgf5126ef" class="outline-6">
<h6 id="orgf5126ef">ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;</h6>
<div class="outline-text-6" id="text-orgf5126ef">
<p>
Unity_patchconstantfunc 改为 UNITY_patchconstantfunc 就可以了。<br />
</p>
</div>
</div>

<div id="outline-container-org5ed69a6" class="outline-6">
<h6 id="org5ed69a6">ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'</h6>
<div class="outline-text-6" id="text-org5ed69a6">
<p>
TessControlPoint 中成员使用了 float 类型，appdata 中使用的 half 类型。使用同一类型就可以了<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga9a287a" class="outline-4">
<h4 id="orga9a287a">Surface Displacement</h4>
</div>
<div id="outline-container-org2ebda0c" class="outline-4">
<h4 id="org2ebda0c">Bloom</h4>
<div class="outline-text-4" id="text-org2ebda0c">
</div>
<div id="outline-container-org50704ca" class="outline-5">
<h5 id="org50704ca">利用 Downsampling Upsampling 模糊图片的原理</h5>
<div class="outline-text-5" id="text-org50704ca">
<ul class="org-ul">
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering</a><br /></li>
<li><a href="#org2c33e42">No description for this link</a><br /></li>
<li>高斯模糊 <a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html">http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org104c11b" class="outline-5">
<h5 id="org104c11b">Q&amp;A</h5>
<div class="outline-text-5" id="text-org104c11b">
</div>
<div id="outline-container-orgd616864" class="outline-6">
<h6 id="orgd616864"><span class="todo TODO">TODO</span> 自定义的 Bloom 如何放到 Builtin Uber 中一起计算？在 Builtin Uber 中一起计算的好处是什么？</h6>
</div>
</div>
</div>

<div id="outline-container-orgc7e409f" class="outline-4">
<h4 id="orgc7e409f">Depth of Field</h4>
<div class="outline-text-4" id="text-orgc7e409f">
</div>
<div id="outline-container-orgf548f8b" class="outline-5">
<h5 id="orgf548f8b">Bokeh</h5>
<div class="outline-text-5" id="text-orgf548f8b">
<p>
CoC(Circal Of Confusion) 决定了 Bokeh 效果在每个点上的强度，Aperture 决定了 Bokeh 的形状。图片是由很多个 Aperture 形状投影到成像平面得到的。<br />
一种创建 Bokeh 的方法是，使用每个图元的颜色为该图元渲染一个 Sprite，Sprite 的大小和不透明度都基于图元的 CoC（这种方式耗费很大，其需要大量的 Overdraw）。（该方法是将一个片段投影到多个片段上）<br />
另一种方式是，每个片段从所有可能影响该片段的图元累加颜色，这种方法不需要额外的几何体，但是需要进行多次贴图采样。<br />
</p>
</div>
</div>

<div id="outline-container-org2054896" class="outline-5">
<h5 id="org2054896">Q&amp;A</h5>
<div class="outline-text-5" id="text-org2054896">
</div>
<div id="outline-container-org2b0cbdd" class="outline-6">
<h6 id="org2b0cbdd"><span class="todo TODO">TODO</span> 为什么开启 MSAA 的时候，DOF 效果会错误？</h6>
</div>
</div>
</div>
<div id="outline-container-org9e3b456" class="outline-4">
<h4 id="org9e3b456">FXAA</h4>
<div class="outline-text-4" id="text-org9e3b456">
</div>
<div id="outline-container-org199cfd6" class="outline-5">
<h5 id="org199cfd6">SSAA MSAA</h5>
<div class="outline-text-5" id="text-org199cfd6">
<p>
SSAA 通过渲染更大分辨率的画面，通过 Downsampling 来消除锯齿。<br />
MSAA 一个片段中分配多个采样点 N，计算被覆盖的采样点个数 X，从而获得当前片段颜色和片段中原始颜色的混合比例（X/N 为当前片段颜色 N-X/N 为原始颜色）。<br />
</p>

<p>
MSAA 跟 SSAA 不同的地方在于，SSAA 对于所有子采样点着色，而 MSAA 只对当前像素覆盖掩码不为 0 的进行着色，顶点属性在像素的中心进行插值用于在片断程序中着色。这是 MSAA 相对于 SSAA 来说最大的好处。<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA.png" alt="02_06fxaa_SMAA.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLFW FrameBuffer&#24320;&#21551;MSAA</span>
glfwWindowHint(GLFW_SAMPLES, 4);
glEnable(GL_MULTISAMPLE);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Off-Screen MSAA</span>
<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">CONFIG-BUFFER</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure MSAA framebuffer</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">framebuffer</span>;
glGenFramebuffers(1, &amp;framebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a multisampled color attachment texture</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">textureColorBufferMultiSampled</span>;
glGenTextures(1, &amp;textureColorBufferMultiSampled);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled);
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGB, SCR_WIDTH, SCR_HEIGHT, GL_TRUE);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled, 0);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a (also multisampled) renderbuffer object for depth and stencil attachments</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">rbo</span>;
glGenRenderbuffers(1, &amp;rbo);
glBindRenderbuffer(GL_RENDERBUFFER, rbo);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);
glBindRenderbuffer(GL_RENDERBUFFER, 0);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

glBindFramebuffer(GL_FRAMEBUFFER, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure second post-processing framebuffer</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">intermediateFBO</span>;
glGenFramebuffers(1, &amp;intermediateFBO);
glBindFramebuffer(GL_FRAMEBUFFER, intermediateFBO);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a color attachment texture</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">screenTexture</span>;
glGenTextures(1, &amp;screenTexture);
glBindTexture(GL_TEXTURE_2D, screenTexture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, <span style="color: #a45bad;">NULL</span>);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we only need a color buffer</span>

glBindFramebuffer(GL_FRAMEBUFFER, 0);

<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">DRAW-CALL</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">------</span>
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. draw scene as normal in multisampled buffers</span>
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DEPTH_TEST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set transformation matrices    </span>
shader.use();
<span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span> = <span style="color: #a45bad;">glm</span>::perspective(<span style="color: #a45bad;">glm</span>::radians(camera.Zoom), (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_WIDTH / (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_HEIGHT, 0.1f, 1000.0f);
shader.setMat4(<span style="color: #2d9574;">"projection"</span>, projection);
shader.setMat4(<span style="color: #2d9574;">"view"</span>, camera.GetViewMatrix());
shader.setMat4(<span style="color: #2d9574;">"model"</span>, <span style="color: #a45bad;">glm</span>::mat4(1.0f));

glBindVertexArray(cubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. now blit multisampled buffer(s) to normal colorbuffer of intermediate FBO. Image is stored in screenTexture</span>
glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. now render quad with scene's visuals as its texture image</span>
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
glDisable(GL_DEPTH_TEST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">draw Screen quad</span>
screenShader.use();
glBindVertexArray(quadVAO);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, screenTexture); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use the now resolved color attachment as the quad's texture</span>
glDrawArrays(GL_TRIANGLES, 0, 6);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------------------------------------</span>
glfwSwapBuffers(window);
glfwPollEvents();
</pre>
</div>
</div>

<div id="outline-container-orgfd3886b" class="outline-6">
<h6 id="orgfd3886b">Q&amp;A</h6>
<div class="outline-text-6" id="text-orgfd3886b">
</div>
<ul class="org-ul">
<li><a id="orga54c57c"></a>DepthBuffer 和 StencilBuffer 中的内容经过 MSAA 处理会出错，Unity 是怎么做的？<br />
<div class="outline-text-7" id="text-orga54c57c">
<p>
MSAA 中一个像素的多个采样点拥有自己的 Depth\Stencil 值。<br />
</p>
</div>
</li>

<li><a id="org3414b47"></a>为什么 MSAA 每个子采样点需要独立存储颜色和深度？<br />
<div class="outline-text-7" id="text-org3414b47">
<p>
因为不同的物体可能覆盖同一个像素的不同子采样点。此时该像素会执行两次片段着色器。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org141f764" class="outline-6">
<h6 id="org141f764">参考资料</h6>
<div class="outline-text-6" id="text-org141f764">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing</a><br /></li>
<li>深入剖析 MSAA <a href="https://www.cnblogs.com/ghl_carmack/p/8245032.html">https://www.cnblogs.com/ghl_carmack/p/8245032.html</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">https://en.wikipedia.org/wiki/Multisample_anti-aliasing</a><br /></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules</a><br /></li>
<li>对多重采样（MSAA）原理的一些疑问 <a href="https://www.zhihu.com/question/58595055/answer/157756410">https://www.zhihu.com/question/58595055/answer/157756410</a> （如果丢失可以参考有道云笔记备份）<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb4d33e7" class="outline-5">
<h5 id="orgb4d33e7">参考资源</h5>
<div class="outline-text-5" id="text-orgb4d33e7">
<ul class="org-ul">
<li><a href="http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html">http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcb4f68f" class="outline-4">
<h4 id="orgcb4f68f">Triplanar Mapping</h4>
<div class="outline-text-4" id="text-orgcb4f68f">
</div>
<div id="outline-container-orga294219" class="outline-5">
<h5 id="orga294219">求解 Normal</h5>
<div class="outline-text-5" id="text-orga294219">
</div>
<div id="outline-container-org28b20cc" class="outline-6">
<h6 id="org28b20cc">TangentNormal</h6>
<div class="outline-text-6" id="text-org28b20cc">

<div class="figure">
<p><img src="./UnityCatLikeCoding/02_07tm_CalcNormal.jpg" alt="02_07tm_CalcNormal.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org49faa74" class="outline-6">
<h6 id="org49faa74">TangentNormalToWorldNormal WorldNormalToTangentNormal</h6>
<div class="outline-text-6" id="text-org49faa74">
<p>
tangentNormal 向上的方向始终为 z，worldNormal 向上的方向随不同投影面而变化。YZ 平面，worldNormal 向上方向在 x 轴方向；XZ 平面，worldNormal 向上在 y 轴方向；XY 平面，worldNormal 向上在 z 轴方向。<br />
tangentNormalX.xyz = worldNormal.zyx  worldNormal 向上的方向为 x 而不是 z，<br />
worldNormal.xyz = tangentNormalX.zyx  tangentNormalX 向上的方向为 z 而不是 x<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org44c514b" class="outline-3">
<h3 id="org44c514b">CustomSRP</h3>
<div class="outline-text-3" id="text-org44c514b">
</div>
<div id="outline-container-orgf5f8f1b" class="outline-4">
<h4 id="orgf5f8f1b">Custom Render Pipeline</h4>
<div class="outline-text-4" id="text-orgf5f8f1b">
</div>
<div id="outline-container-orgab65585" class="outline-5">
<h5 id="orgab65585">架构</h5>
<div class="outline-text-5" id="text-orgab65585">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipelineAsset.cs &#21019;&#24314;CustomRenderPipeline&#23454;&#20363;&#65292;&#25552;&#20379;&#32473;unity&#24341;&#25806;</span>
  [CreateAssetMenu(menuName = <span style="color: #2d9574;">"Rendering/CustomRenderPipeline"</span>)]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipelineAsset</span> : <span style="color: #ce537a; font-weight: bold;">RenderPipelineAsset</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span> <span style="color: #bc6ec5; font-weight: bold;">CreatePipeline</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span>();
      }
  }

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipeline.cs &#23454;&#29616;CustomRenderPipeline&#31867;&#21151;&#33021;&#12290;&#36845;&#20195;&#28210;&#26579;&#21508;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span> : <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span>
{
    <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span> <span style="color: #7590db;">renderer</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>();
    <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Render</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #ce537a; font-weight: bold;">Camera</span>[] <span style="color: #7590db;">cameras</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">camera</span> <span style="color: #4f97d7; font-weight: bold;">in</span> cameras)
        {
            renderer.<span style="color: #bc6ec5; font-weight: bold;">Render</span>(context, camera);
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CameraRenderer.cs CameraRenderer.Editor.cs &#23454;&#29616;CameraRenderer&#31867;&#21151;&#33021;&#12290;&#28210;&#26579;&#26576;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">partial</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7bc45d" class="outline-5">
<h5 id="orgc7bc45d">CommandBuffer BeginSample EndSample</h5>
<div class="outline-text-5" id="text-orgc7bc45d">
<p>
CommandBuffer 的 BeginSample 和 EndSample 方法也需要调用 context.ExecuteCommandBuffer(buffer);才能生效。<br />
另外 CommandBuffer 的 BeginSample 和 EndSample 需要成对。<br />
</p>
</div>
</div>
<div id="outline-container-org6b65349" class="outline-5">
<h5 id="org6b65349">CameraClearFlags</h5>
<div class="outline-text-5" id="text-org6b65349">
<p>
CameraClearFlags 定义的 4 个枚举不是互相独立的，其表示了一个降量清除。例如，除了 CameraClearFlags.Nothing 以外，其他枚举都需要清除深度缓冲区。<br />
CameraClearFlags.Skybox     ==&gt; Clear Z+Stencil<br />
CameraClearFlags.Color      ==&gt; Clear Color+Z+Stencil<br />
CameraClearFlags.SolidColor<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">CameraClearFlags</span>
{
    <span style="color: #7590db;">Skybox</span> = 1,
    <span style="color: #7590db;">Color</span> = 2,
    <span style="color: #7590db;">SolidColor</span> = 2,
    <span style="color: #7590db;">Depth</span> = 3,
    <span style="color: #7590db;">Nothing</span> = 4
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org145e204" class="outline-4">
<h4 id="org145e204">Draw Calls</h4>
<div class="outline-text-4" id="text-org145e204">
</div>
<div id="outline-container-org5e7a862" class="outline-5">
<h5 id="org5e7a862">Write a HLSL Shader</h5>
<div class="outline-text-5" id="text-org5e7a862">
</div>
<div id="outline-container-org30d7b8a" class="outline-6">
<h6 id="org30d7b8a">shader 中顶点坐标为什么使用 float4 而不是使用 float3？</h6>
<div class="outline-text-6" id="text-org30d7b8a">
<p>
3D 空间的坐标点被定义为 4 维向量，并且 w 分量设置为 1，而 3D 空间的方向向量的 w 分量则被设置为 0。这样可以使用相同的变换矩阵来对点和向量进行变换，因此使用 float4 表示顶点。<br />
假如向量为行向量，矩阵中第 4 行存储的是平移信息，3D 空间中的点变换需要平移，因此其 w 分量为 1，而 3D 空间的向量不需要平移变换，因此其 w 分量为 0。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5ea63bb" class="outline-5">
<h5 id="org5ea63bb">Batching</h5>
<div class="outline-text-5" id="text-org5ea63bb">
<p>
合批是指将 DrawCall 合并，减少 CPU 和 GPU 沟通消耗的时间。<br />
</p>
</div>
<div id="outline-container-orgec3dbed" class="outline-6">
<h6 id="orgec3dbed">SRP batcher</h6>
<div class="outline-text-6" id="text-orgec3dbed">
<p>
最简单的方式是开启 SRP batcher。但是，选中我们的 Unlit.shader 文件，在 Inspector 面板上提示 not compatible。SRP batcher 并没有减少 draw call 的数量，其会将材质的属性缓存在 GPU，从而避免每次 draw call 都需要从 CPU 发送材质属性到 GPU，这样就减少了 CPU 和 GPU 交互的数据量，也减少了 CPU 执行每个 DrawCall 时的工作。<br />
</p>

<p>
注意：<br />
</p>
<ol class="org-ol">
<li>SRP batcher 不会减少 draw call 数量<br /></li>
<li>SRP batcher 支持多个物体使用相同 shader 定义的不同材质，每个材质使用不同的材质属性。<br /></li>
<li>SRP batcher 支持多个物体使用相同的材质。<br /></li>
<li>SRP batcher 不支持每个物体拥有不同的材质属性，即不支持 MaterialPropertyBlock.<br /></li>
</ol>

<p>
通过如下方式支持 SRP batcher：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UnlitPass.hlsl</span>
CBUFFER_START(UnityPerMaterial)
  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseColor</span>;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UnityInput.hlsl</span>
CBUFFER_START(UnityPerDraw)
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorld;
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObject;
  <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LODFade;
  real4 unity_WorldTransformParams;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipeline.cs &#22686;&#21152;&#26500;&#36896;&#20989;&#25968;&#65292;&#35774;&#32622;&#21551;&#29992;SRP Batching</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">CustomRenderPipeline</span> ()
{
    GraphicsSettings.useScriptableRenderPipelineBatching = <span style="color: #a45bad;">true</span>;
}
</pre>
</div>

<ul class="org-ul">
<li>SRPBatcher Doc <a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a><br /></li>
<li>SRPBatcher 加速渲染 <a href="https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran">https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7c2d280" class="outline-6">
<h6 id="org7c2d280">GPU Instancing</h6>
<div class="outline-text-6" id="text-org7c2d280">
</div>
<ul class="org-ul">
<li><a id="org9033fb6"></a>MaterialPropertyBlock 实现多个物体使用同一个材质，而拥有不同材质属性<br />
<div class="outline-text-7" id="text-org9033fb6">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">PerObjectMaterialProperties.cs</span>
  <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">UnityEngine</span>;
  [<span style="color: #ce537a; font-weight: bold;">DisallowMultipleComponent</span>]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">PerObjectMaterialProperties</span> : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">baseColorId</span> = Shader.<span style="color: #bc6ec5; font-weight: bold;">PropertyToID</span>(<span style="color: #2d9574;">"_BaseColor"</span>);
      [<span style="color: #ce537a; font-weight: bold;">SerializeField</span>]
      Color baseColor = Color.white;
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span> <span style="color: #7590db;">block</span>;

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Awake</span>()
      {
          OnValidate();
      }

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnValidate</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">if</span>(block==<span style="color: #a45bad;">null</span>)
          {
              block = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span>();
          }
          block.<span style="color: #bc6ec5; font-weight: bold;">SetColor</span>(baseColorId, baseColor);
          GetComponent&lt;Renderer&gt;().<span style="color: #bc6ec5; font-weight: bold;">SetPropertyBlock</span>(block);
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="orga4cf585"></a>GPU Instancing<br />
<div class="outline-text-7" id="text-orga4cf585">
<p>
GPU instancing 适用于每个物体具有不同材质属性的情况。其只需要为多个物体发布一个 draw call，但是这些物体必须使用相同的 mesh。CPU 会收集每个物体的变换矩阵和材质属性，并将他们放到一个数组中，然后发送给 GPU，GPU 按照数据被提供的顺序遍历进行渲染。<br />
</p>

<p>
注意：GPU instancing 多个物体必须是相同的材质实体。不同的材质实体，就算材质属性完全相同也不能合批。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29992;&#20110;&#24320;&#21551;GPU Instancing</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile_instancing
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc940785" class="outline-6">
<h6 id="orgc940785">Dynamic Batching</h6>
<div class="outline-text-6" id="text-orgc940785">
<p>
Dynamic Batching 会将多个共享相同材质的小 mesh 合并为一个大 mesh（Sphere 的 Mesh 比较大，不支持 DynamicBatching，Cube 支持）。该方法不支持每个物体具有不同材质属性的情况。<br />
通常 GPU Instancing 要比 Dynamic Batching 要更好。Dynamic Batching 会有一些陷阱，例如当物体的 scale 不同时，合成的大 mesh 的 normal 向量不保证是归一化的。<br />
</p>

<p>
事先被标记为 Batching-Static 的物体会执行 Static Batching，其和 Dynamic Batching 工作方式类似，除了需要更多的内存和存储空间外，其没有其他陷阱。<br />
</p>

<p>
按照下面方式开启 Dynamic Batching:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">drawingSettings</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">DrawingSettings</span>(unlitShaderTagId, sortingSettings)
{
    enableDynamicBatching = <span style="color: #a45bad;">true</span>,
    enableInstancing = <span style="color: #a45bad;">false</span>
};
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgbbc7616"></a>Static Batching 会更耗费内存资源？<br />
<div class="outline-text-7" id="text-orgbbc7616">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8e2b4f9" class="outline-5">
<h5 id="org8e2b4f9">Transparency</h5>
</div>
</div>
<div id="outline-container-org3054218" class="outline-4">
<h4 id="org3054218">Directianl Lights</h4>
<div class="outline-text-4" id="text-org3054218">
</div>
<div id="outline-container-orgf3d1fd4" class="outline-5">
<h5 id="orgf3d1fd4">Lighting</h5>
<div class="outline-text-5" id="text-orgf3d1fd4">
</div>
<div id="outline-container-orgae7667d" class="outline-6">
<h6 id="orgae7667d">如何可视化光栅化对顶点 normal 线性插值后，normal 不再归一化？</h6>
<div class="outline-text-6" id="text-orgae7667d">
<div class="org-src-container">
<pre class="src src-shader">base.rgb = <span style="color: #4f97d7;">abs</span>(<span style="color: #4f97d7;">length</span>(input.normalWS) - 1.0) * 10.0;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc967b24" class="outline-5">
<h5 id="orgc967b24">BRDF</h5>
<div class="outline-text-5" id="text-orgc967b24">
<p>
Incoming Light : 光线方向和表面法线没有对齐时，表面接受到的入射光能量会变小。通过为入射光添加 N.L 系数可以实现该规律。<br />
Outgoing Light : 出射光线的分布有三种类型。完美镜面反射（Specular Reflection）、模糊反射（Glossy Reflection）、漫反射（Diffuse）<br />
由于表面光滑，Specular Reflection 会将入射光反射到同一个方向。<br />
由于微表面朝向不同，Glossy Reflection 会将入射光反射到偏离反射方向的方向上。<br />
光线进入物体后，Diffuse 会将入射光向各个方向等概率反射出来。<br />
</p>

<p>
表面对光的反射是各不相同的，通常金属会将光按照 Specular Reflection 全部反射，其没有 Diffuse。电介质(非金属)也会有 Specular Reflection，不同电介质反射不同，其平均值为 0.04。<br />
<a href="../theory/PhysicalTheory.html#orgcb98a73">../theory/PhysicalTheory.html#orgcb98a73</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org11801db" class="outline-4">
<h4 id="org11801db">Directional Shadows</h4>
<div class="outline-text-4" id="text-org11801db">
</div>
<div id="outline-container-orga73ba21" class="outline-5">
<h5 id="orga73ba21">Rendering Shadows</h5>
<div class="outline-text-5" id="text-orga73ba21">
<p>
将 RT 分割为多个 Tile，设置 viewPort 来支持将多个方向光的阴影贴图画到同一个 RT 上。<br />
</p>
</div>
</div>
<div id="outline-container-org4f623d9" class="outline-5">
<h5 id="org4f623d9">Sampling Shadows</h5>
<div class="outline-text-5" id="text-org4f623d9">
</div>
<div id="outline-container-org4557aa2" class="outline-6">
<h6 id="org4557aa2">为什么要使用翻转的 ZBuffer（Reversed-ZBuffer）？</h6>
<div class="outline-text-6" id="text-org4557aa2">
<p>
使用 0 表示深度为 0，使用 1 表示深度为最大，这样很直观。但是，反向 ZBuffer 再加上浮点型深度值可以增加深度位数的利用率，减少 ZFighting。具体原理如下文：<br />
</p>
<ul class="org-ul">
<li>反向 Z(Reversed-Z)的深度缓冲原理 <a href="https://zhuanlan.zhihu.com/p/75517534">https://zhuanlan.zhihu.com/p/75517534</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6225798" class="outline-6">
<h6 id="org6225798">ConvertToAtlasMatrix 实现</h6>
<div class="outline-text-6" id="text-org6225798">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#25191;&#34892;&#23558;[-1,1]&#36716;&#21270;&#20026;[0, 1] &#32553;&#25918;0.5&#20877;&#20559;&#31227;0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">  unity&#20351;&#29992;&#30340;&#21015;&#21521;&#37327;&#65292;&#30697;&#38453;&#38656;&#35201;&#24038;&#20056;</span>
<span style="color: #2aa1ae; background-color: #292e34;">  scaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0.5    0     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0    0.5     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0   0.5    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">  translateM</span>
<span style="color: #2aa1ae; background-color: #292e34;">  1      0     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      1     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     1    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     0    1</span>
<span style="color: #2aa1ae; background-color: #292e34;">*/</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#25191;&#34892; atlas &#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
<span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">  atlasOffsetM</span>
<span style="color: #2aa1ae; background-color: #292e34;">  1      0     0    offsetX</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      1     0    offsetY</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     1    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">  atlasScaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">  scale  0     0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      scale 0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     1     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">  0      0     0     1</span>
<span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#26368;&#32456;&#32452;&#21512;&#20986;&#26469;&#30340;&#21464;&#25442;&#30697;&#38453;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">atlasScaleM * atlasOffsetM * translateM * scaleM * originM</span>
</pre>
</div>
<p>
<a href="../theory/.ComputerGraphicMath.html#org4366a62">../theory/.ComputerGraphicMath.html#org4366a62</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga161304" class="outline-5">
<h5 id="orga161304">Cascaded Shadow Maps</h5>
<div class="outline-text-5" id="text-orga161304">
<p>
绘制方向光的阴影贴图时使用的是正交投影，因此阴影贴图上的一个图元对应了世界空间中固定大小的尺寸，如果该尺寸太大，会导致每个阴影贴图图元都占据多个像素，这会导致阴影边缘有锯齿，以及小的阴影会消失。该问题可以通过增加阴影贴图大小来缓解。<br />
当使用透视投影时，场景中越远的物体会变的越小。在某个可视距离阴影贴图上的一个图元只会对应显示器上的一个像素，这是理论上最优的。越靠近摄像机我们需要越高的阴影贴图分辨率，而远处的地方低分辨率的阴影贴图也足够了。理想的情况是，我们依据阴影接受者距离摄像机的距离，动态改变阴影贴图的精度。<br />
Cascaded Shadows maps 的理念是，将投摄阴影的物体渲染多次，这样每个光照在 atlas 上就对应了多个 Tile，这就被称为多个层级。第一个层级只会覆盖靠近摄像机的一小片区域，随后的层级会逐渐放大覆盖的区域。shader 中会采样最合适的层级。<br />
</p>

<p>
Unity 会创建一个 culling sphere 用于确定每个层级所覆盖的区域。阴影的投影矩阵为正交矩阵，视景体为长方体，其和 Culling Sphere 比较接近，但是还包含了 Sphere 周围的空间。因此 culling 区域外的阴影也可以被看到。光的方向和 Culling Sphere 是无关的（该 CullingSphere 和摄像机位置相关），因此所有的方向光使用相同的 culling spheres。<br />
</p>

<p>
这些 spheres 也用于确定，从哪个层级的阴影贴图进行采样。<br />
</p>
</div>
<div id="outline-container-org464a314" class="outline-6">
<h6 id="org464a314">Shadow Fade</h6>
<div class="outline-text-6" id="text-org464a314">
<p>
阴影渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_fade_shadow.jpg" alt="03_04ds_fade_shadow.jpg" /><br />
Cascade 渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_cascade_fade.jpg" alt="03_04ds_cascade_fade.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org52b26c4" class="outline-6">
<h6 id="org52b26c4">Shadow Quality</h6>
<div class="outline-text-6" id="text-org52b26c4">
</div>
<ul class="org-ul">
<li><a id="org5e45b5b"></a>Depth Bias<br />
<div class="outline-text-7" id="text-org5e45b5b">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-csharp">buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(50000f, 0f);
ExcuteBuffer();
context.<span style="color: #bc6ec5; font-weight: bold;">DrawShadows</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">shadowSettings</span>);
buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(0f, 0f);
</pre>
</div>
</div>
</li>
<li><a id="org4c35318"></a>NormalBias<br />
<div class="outline-text-7" id="text-org4c35318">
<p>
不正确的自阴影是由于投影的深度贴图图元覆盖了多个片段，这导致投影体从其表面伸出来。因此如果将投影体缩小足够大小，该问题将不会出现。但是，缩放投影体会导致阴影比原来要小。<br />
我们也可以从相反的方向来做：在采样阴影贴图时，将物体表面放大。这样我们就会采样远离表面一段距离的深度值，只要足够远就可以避免不正确的自阴影。这会稍微改变阴影的位置，可能会导致边缘的不对其以及错误的阴影，但是这点瑕疵比 Peter-Panning 要小很多。<br />
</p>
</div>
</li>
<li><a id="orgf3d6d93"></a>Shadow Pancaking<br />
<div class="outline-text-7" id="text-orgf3d6d93">
<p>
在为一个方向光渲染阴影投射体时，应该尽量将摄像机近平面往前移，这样可以增加深度精度，但是，这意味着投影体可能会不再摄像机视野内，其可能在近平面之前，这会导致该物体被裁剪，而其本不该被裁剪。<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_01.png" alt="03_04ds_shadow_error_01.png" /><br />
通过下面代码可以处理该问题：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">Varyings <span style="color: #bc6ec5; font-weight: bold;">ShadowCasterPassVertex</span>(Attributes input)
{
    Varyings output;
    UNITY_SETUP_INSTANCE_ID(input);
    UNITY_TRANSFER_INSTANCE_ID(input, output);
    <span style="color: #ce537a; font-weight: bold;">float3</span> positionWS = TransformObjectToWorld(input.positionOS);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Transform World to Homogeneous Clip</span>
    output.positionCS = TransformWorldToHClip(positionWS);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28210;&#26579;&#26041;&#21521;&#20809;&#20351;&#29992;&#30340;&#26159;&#27491;&#20132;&#25237;&#24433;, &#23558;&#36817;&#24179;&#38754;&#21069;&#30340;&#29289;&#20307;&#31227;&#21040;&#36817;&#24179;&#38754;</span>
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z
    output.positionCS.z = <span style="color: #4f97d7;">min</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">    #else</span>
    output.positionCS.z = <span style="color: #4f97d7;">max</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, <span style="color: #7590db;">_BaseMap_ST</span>);
    output.baseUV = input.baseUV * baseST.xy + baseST.zw;
    <span style="color: #4f97d7; font-weight: bold;">return</span> output;
}
</pre>
</div>

<p>
上面的处理方式会导致新的问题，因为对于横穿近平面的物体，其只有部分顶点的数据是正确的，如果物体很大，其阴影会变形。下图展示了这种错误：<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_02.png" alt="03_04ds_shadow_error_02.png" /><br />
</p>

<p>
该问题可以通过支持 light 的 shadowNearPlane 来避免。也可以将大物体划分为小物体。<br />
</p>
<ul class="org-ul">
<li>Shadow pancaking <a href="https://docs.unity3d.com/Manual/ShadowPerformance.html">https://docs.unity3d.com/Manual/ShadowPerformance.html</a><br /></li>
</ul>
</div>
</li>

<li><a id="org8e0925f"></a>PCF Shadow<br />
<div class="outline-text-7" id="text-org8e0925f">
<p>
扩大采样区域后会导致 Shadow Acne 再次出现。需要对应增加 normal biase。<br />
扩大采样区域后意味着，我们可以采样到 cascade culling sphere 外面的区域。通过减小 culling sphere 半径来避免该问题。<br />
</p>
</div>
</li>

<li><a id="org033819e"></a>Blending Cascades<br />
<div class="outline-text-7" id="text-org033819e">

<div class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_blend_cascade_shadow.png" alt="03_04ds_blend_cascade_shadow.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="orgfc265bf"></a>Culling Bias<br />
<div class="outline-text-7" id="text-orgfc265bf">
<p>
使用 Cascaded Shadow Maps 的一个缺点是，对于每个灯光，我们需要渲染相同的投影体多次。如果可以为高层级的 Cascade 剔除一些阴影投射体，并保证其内容总是被低层级的 Cascade 所覆盖，则会节省很多 DrawCall。如下参数可以实现该功能：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">splitData.shadowCascadeBlendCullingFactor = 1f;
</pre>
</div>


<div class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_culling_for_large_cascade.png" alt="03_04ds_culling_for_large_cascade.png" /><br />
</p>
</div>

<p>
shadowCascadeBlendCullingFactor 会被用于和 culling sphere 半径相乘，其值必须为(0,1)范围，值越大，Unity 会剔除越多的物体，值越低，多层级之间共享的渲染对象越多。使用比较低的值，就可以让不同层级之间在重叠区域做混合。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html">https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8a24739" class="outline-5">
<h5 id="org8a24739">Transparency</h5>
</div>
<div id="outline-container-org94993c5" class="outline-5">
<h5 id="org94993c5">Q&amp;A</h5>
<div class="outline-text-5" id="text-org94993c5">
</div>
<div id="outline-container-org3e74d61" class="outline-6">
<h6 id="org3e74d61">FrameDebug 中有无限多个</h6>
<div class="outline-text-6" id="text-org3e74d61">
<p>
CommandBuffer.BeginSample 和 CommandBuffer.EndSample 数量不对称会导致该问题。<br />
</p>
</div>
</div>
<div id="outline-container-org67a3533" class="outline-6">
<h6 id="org67a3533">ERROR: Dimensions of color surface does not match dimensions of depth surface</h6>
<div class="outline-text-6" id="text-org67a3533">
<p>
CameraRenderer.cs 文件中 Render 函数内，先执行 Setup 后执行 lighting.Setup 就会出现该问题。因为 lighting.Setup 执行后，RT 没有切换回摄像机 RT，从 FrameDebug 可以看出该问题。<br />
<img src="./UnityCatLikeCoding/03_04ds_rt_error.jpg" alt="03_04ds_rt_error.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7d880ec" class="outline-4">
<h4 id="org7d880ec">Baked Light</h4>
<div class="outline-text-4" id="text-org7d880ec">
</div>
<div id="outline-container-org126a4ab" class="outline-5">
<h5 id="org126a4ab">Baking Static Light</h5>
<div class="outline-text-5" id="text-org126a4ab">
<p>
光照可以被提前计算，然后将结果保存到光照贴图和 light probes 中。这种方式，有一个好处是，可以添加无法实时计算的间接光照效果。这种间接光照属于全局照明的一部分，间接光照不是直接从光源发出的光照，其为从环境或者发光表面经过间接反射照亮物体的光。<br />
</p>

<p>
Fully-Baked Light（Light 组件的 Mode 选择 Baked，Lighting Setting 的 LightingMode 选择 BakedIndirect） 会将直接光照和间接光照都烘培到光照贴图。<br />
</p>

<p>
环境间接光照 Intensity Multiplier 设置为 0 和 1 的对比：<br />
<img src="./UnityCatLikeCoding/03_05bl_env_indirect_light.png" alt="03_05bl_env_indirect_light.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgf0e36ae" class="outline-5">
<h5 id="orgf0e36ae">GPU Instancing 和烘培</h5>
<div class="outline-text-5" id="text-orgf0e36ae">
<p>
理论上来说，可以使用 TextureArray，让静态烘培物体 lightmap 不同时，依然可以 GPU Instancing。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org302fcd8" class="outline-4">
<h4 id="org302fcd8">Shadow Masks</h4>
<div class="outline-text-4" id="text-org302fcd8">
<p>
Unity 也会将 ShadowMask 数据烘培到 LightProbes 中，通过如下方式可以采样 LightProbes 中的 ShadowMask 数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">SampleBakedShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightMapUV, Surface surfaceWS)
{
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SAMPLE_TEXTURE2D</span>(unity_ShadowMask, samplerunity_ShadowMask, lightMapUV);
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SampleProbeOcclusion</span>(
            TEXTURE3D_ARGS(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH),
            surfaceWS.position, unity_ProbeVolumeWorldToObject,
            unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z,
            unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz
        );
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> unity_ProbesOcclusion;
    }
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga18d96a" class="outline-4">
<h4 id="orga18d96a">LOD and Reflections</h4>
</div>
<div id="outline-container-orgf3674ef" class="outline-4">
<h4 id="orgf3674ef">Complex Maps</h4>
<div class="outline-text-4" id="text-orgf3674ef">
</div>
<div id="outline-container-org9c367e8" class="outline-5">
<h5 id="org9c367e8">Q&amp;A</h5>
<div class="outline-text-5" id="text-org9c367e8">
</div>
<div id="outline-container-orgab5ad91" class="outline-6">
<h6 id="orgab5ad91">贴图设置中的 FadeOut Mip Maps 属性是做什么用的？</h6>
<div class="outline-text-6" id="text-orgab5ad91">
<p>
FadeOut Mip Maps 主要用于避免远处 DetailMap 有明显的 tiling 模式。<br />
</p>

<ul class="org-ul">
<li>FadeOut Mip Maps <a href="https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/">https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc107d94" class="outline-4">
<h4 id="orgc107d94">Point and Spot Lights</h4>
<div class="outline-text-4" id="text-orgc107d94">
</div>
<div id="outline-container-org7c9cef1" class="outline-5">
<h5 id="org7c9cef1">Lights Per Object</h5>
<div class="outline-text-5" id="text-org7c9cef1">
<p>
Unity 确定每个物体会由哪些光照所影响，并将该信息发送给 GPU。这样在渲染每个物体时，只需要计算影响该物体的光照，而忽略不影响该物体的光照。这种方案对于很多小物体组成的场景来说是很适用的，而对于大物体来说则不适用，因为如果光照只影响大物体的一小部分区域，在渲染该大物体时，依然需要对其整个表面执行光照计算。<br />
</p>

<p>
需要注意的是，当开启 LightsPerObject 后，GPU instancing 可能会失效，因为只有受光照印象数量相同，并且索引列表匹配的物体才会被分为一组。SRP batcher 则不受影响。<br />
</p>
</div>
</div>
<div id="outline-container-org7861cad" class="outline-5">
<h5 id="org7861cad">Q&amp;A</h5>
<div class="outline-text-5" id="text-org7861cad">
</div>
<div id="outline-container-org9ed1f07" class="outline-6">
<h6 id="org9ed1f07"><span class="todo TODO">TODO</span> 灯光的位置、方向为什么可以通过 localToWorldMatrix 矩阵获取？</h6>
<div class="outline-text-6" id="text-org9ed1f07">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">spot light</span>
<span style="color: #ce537a; font-weight: bold;">Vector4</span> <span style="color: #7590db;">position</span> = visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(3);
otherLightDirections[index] = -visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(2);
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org98e275f" class="outline-4">
<h4 id="org98e275f">Point and Spot Shadows</h4>
<div class="outline-text-4" id="text-org98e275f">
</div>
<div id="outline-container-orgef60f9b" class="outline-5">
<h5 id="orgef60f9b">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgef60f9b">
</div>
<div id="outline-container-org56125df" class="outline-6">
<h6 id="org56125df"><span class="todo TODO">TODO</span> 解决 Spot Light Shadow Acne 问题的原理？</h6>
</div>
<div id="outline-container-org0076128" class="outline-6">
<h6 id="org0076128">Unity 渲染 Point Light 阴影时会从上往下渲染，导致渲染的物体为背面，如何转化为正面渲染物体？</h6>
<div class="outline-text-6" id="text-org0076128">
<div class="org-src-container">
<pre class="src src-csharp">cullingResults.<span style="color: #bc6ec5; font-weight: bold;">ComputePointShadowMatricesAndCullingPrimitives</span>(
        light.<span style="color: #ce537a; font-weight: bold;">visibleLightIndex</span>, (CubemapFace)i, fovBias*0,
        <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">viewMatrix</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">projectionMatrix</span>,
        <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">ShadowSplitData</span> <span style="color: #7590db;">splitData</span>
      );
viewMatrix.m11 = -viewMatrix.m11;
viewMatrix.m12 = -viewMatrix.m12;
viewMatrix.m13 = -viewMatrix.m13;
</pre>
</div>
</div>
</div>
<div id="outline-container-org1f3d9d1" class="outline-6">
<h6 id="org1f3d9d1">Fov Bias 如何求解？</h6>
<div class="outline-text-6" id="text-org1f3d9d1">
<p>
Fov Bias 计算原理如下：<br />
<img src="./UnityCatLikeCoding/03_10pss_point_light_fovBias.png" alt="03_10pss_point_light_fovBias.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">fovBias</span> = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Atan</span>(1f + bias + filterSize) * Mathf.Rad2Deg * 2f - 90f;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org798ef32" class="outline-4">
<h4 id="org798ef32">Post Processing</h4>
<div class="outline-text-4" id="text-org798ef32">
</div>
<div id="outline-container-org5e7acbf" class="outline-5">
<h5 id="org5e7acbf">CommandBuffer.DrawProcedural</h5>
<div class="outline-text-5" id="text-org5e7acbf">
<p>
CommandBuffer.DrawProcedural 该函数会在 GPU 上执行一个 DrawCall，但是没有任何 vertex 或 index buffer。通常在 vertex shader 中，通过使用 SV_VertexID 和 SV_InstanceID 来从某些 buffer 中获取数据。<br />
SV_VertexID 为顶点编号。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgda3e57d" class="outline-5">
<h5 id="orgda3e57d"><span class="todo TODO">TODO</span> 使用双线性过滤优化高斯模糊的原理是什么？</h5>
<div class="outline-text-5" id="text-orgda3e57d">
<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/58182228">https://zhuanlan.zhihu.com/p/58182228</a><br /></li>
<li><a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a><br /></li>
<li><a href="https://cloud.tencent.com/developer/article/1035559">https://cloud.tencent.com/developer/article/1035559</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org41d9645" class="outline-5">
<h5 id="org41d9645">Bloom 流程</h5>
<div class="outline-text-5" id="text-org41d9645">
<p>
下图为迭代三次的 Boom 流程图：<br />
<img src="./UnityCatLikeCoding/03_11pp_bloom.png" alt="03_11pp_bloom.png" /><br />
</p>

<p>
Pre-FilterPass 中将大于 Threshold 的颜色筛选出来。<br />
BlurHorizontalPass BlurVerticalPass 对上一步筛选出来的像素进行高斯模糊，BlurHorizontalPass 还执行 Downsampling 操作。<br />
CombinePass 将模糊后的和模糊前的图片进行合并。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf3e1181" class="outline-4">
<h4 id="orgf3e1181">HDR</h4>
<div class="outline-text-4" id="text-orgf3e1181">
</div>
<div id="outline-container-orge1856c0" class="outline-5">
<h5 id="orge1856c0">High Dynamic Range</h5>
<div class="outline-text-5" id="text-orge1856c0">
</div>
<div id="outline-container-orgc8b55a5" class="outline-6">
<h6 id="orgc8b55a5">HDR Post Processing</h6>
<div class="outline-text-6" id="text-orgc8b55a5">
<p>
HDR 和 LDR bloom 的区别可能是非常大，也可能非常小，这取决于场景的亮度。通常 bloom 的 threshold 被设置为 1，因此只有 HDR 颜色会对 bloom 效果产生贡献。这样画面上闪耀的颜色表示其对于显示器来说太亮了。<br />
因为 bloom 效果的原理是平均颜色，因此即使一个非常亮的像素最终可能影响一大片区域。例如，当 2x2 块的颜色值分别为 0,0,0,1 时，由于 downsampling 的平均，最终的颜色值为 0.25。但是如果是 HDR 版本的平均 0,0,0 和 10，则最终的颜色值为 2.5。<br />
</p>
</div>
</div>
<div id="outline-container-org4065ebe" class="outline-6">
<h6 id="org4065ebe">Fighting Fireflies</h6>
<div class="outline-text-6" id="text-org4065ebe">
<p>
HDR 的一个缺点是，其会导致图片上一小片区域的亮度比其周围大很多。当这些区域的大小为一个像素或者更小时，其可以极大地改变相对大小，并在运动过程中突然出现或消失，这会导致闪烁。这些区域被称为萤火虫。当应用 bloom 时，这些区域会出现频闪。<br />
完全消除该问题需要无限大的分辨率，这是不可能的。我们可以在 Pre-Filtering 阶段更激进地对图片进行模糊，将 fireflies 淡出。<br />
在 PreFiltering 阶段，对周围 9 个像素点进行采样，每个采样点的颜色按照 1/(l+1)分配权重，l为该颜色的亮度(luminance)。其原理如下图所示：<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies.png" alt="03_11hdr_bloom_fireflies.png" /><br />
</p>
</div>

<p>
因为在 Pre-Filtering 后会执行 GaussianBlur，因此前面对 9 个像素的采样可以优化为对 5 个像素的采样：<br />
<img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies02.png" alt="03_11hdr_bloom_fireflies02.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd9d2e32" class="outline-5">
<h5 id="orgd9d2e32">Scattering Bloom</h5>
<div class="outline-text-5" id="text-orgd9d2e32">
<p>
摄像机不是完美的，其镜头无法正确聚焦所有的光。一部分光会散射到更大的区域，就如目前我们实现的 bloom 效果一样。越好的摄像机会散射越少的光。摄像机镜头对光的散射和目前实现的 additive bloom 效果的最大区别为，摄像机镜头对光的散射不会增加光照，其只会将光照 diffuse 化。人眼也不是完美的，进入人眼的光也会被散射。<br />
</p>
</div>
<div id="outline-container-orga66ff4f" class="outline-6">
<h6 id="orga66ff4f">Scatter Limits</h6>
<div class="outline-text-6" id="text-orga66ff4f">
<p>
在 BloomSettings 中添加 scatter 变量来控制被散射的光的量。当 scatter=0，表示完全不散射。当 scatter=1，表示完全散射。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomCombineScatterPassFragment</span>(Varyings input) : SV_TARGET
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>)
    {
        lowRes = GetSourceBicubic(input.fxUV).rgb;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        lowRes = GetSource(input.fxUV).rgb;
    }
    <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scatter = 0 &#21017;&#19981;&#25955;&#23556; scatter=1&#21017;&#23436;&#20840;&#25955;&#23556;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org069c813" class="outline-6">
<h6 id="org069c813">Threshold</h6>
<div class="outline-text-6" id="text-org069c813">
<p>
Scattering Bloom 在最终 Combine 阶段需要对 lowRes 进行补偿，因为 lowRes 中只包含了需要 Bloom 的部分(即超过 Threshold 值的颜色)。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomScatterFinalPassFragment</span> (Varyings input) : SV_TARGET {
    <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>) {
        lowRes = GetSourceBicubic(input.fxUV).rgb;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> {
        lowRes = GetSource(input.fxUV).rgb;
    }
    <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;lowRes&#36827;&#34892;&#34917;&#20607;</span>
    lowRes += highRes - ApplyBloomThreshold(highRes);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org593dbc9" class="outline-5">
<h5 id="org593dbc9">Tone Mapping</h5>
<div class="outline-text-5" id="text-org593dbc9">
<p>
尽管我们可以在 HDR 模式下进行渲染，但是对于常规的摄像机，其最终的 frameBuffer 总是 LDR 格式的。这使得颜色通道被裁剪为 1，实际上最终图片上的白点的值为 1。特别量的颜色最终和完全饱和的颜色看起来是没有差别的。下图的场景中，包含了多个等级的光照，以及多个发光的物体。其中最强的发光体的亮度为 8，最亮的光源光照强度为 200.<br />
</p>

<p>
<img src="./UnityCatLikeCoding/03_11pp_non_fx_001.png" alt="03_11pp_non_fx_001.png" /><br />
没有使用后期效果，很难看出那个物体或者那个光源是亮度最强的。下图为使用了 Bloom 后期特效后的效果：<br />
<img src="./UnityCatLikeCoding/03_11pp_use_fx_001.png" alt="03_11pp_use_fx_001.png" /><br />
上图中发光的物体明显是比较亮的，但是依然无法确定其相对于场景中剩余物体有多亮。调整图片的亮度使得最亮的颜色不要超过 1，这样就可以确定物体之间的相对亮度关系了。我们可以统一将整个图片变暗，但是这会导致图片中的大部分颜色变得太暗，以至于无法清晰看到。理想的情况是，我们对于很亮的颜色调节很多，而对于暗的颜色调节很少。因此，我们需要非统一的颜色调节方案。这样的颜色调节并不是光源自身的物理属性改变，而是光源被人感知的变化。例如，我们的眼睛对于暗的色调比亮的色调更加敏感。<br />
</p>

<p>
将 HDR 转换为 LDR 的操作被称为 Tone Mapping，其源于摄影和电影的发展。传统的照片和电影也是只具有有限的亮度范围，以及非统一的光照敏感度，因此很多技术被开发出来用于执行 ToneMapping。没有唯一正确的 ToneMapping。<br />
</p>
</div>
<div id="outline-container-org82fada1" class="outline-6">
<h6 id="org82fada1">Reinhard</h6>
<div class="outline-text-6" id="text-org82fada1">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ToneMappingReinhardPassFragment</span> (Varyings input) : SV_TARGET 
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> color = GetSource(input.fxUV);
    color.rgb /= color.rgb + 1.0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> color;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org85f1393" class="outline-6">
<h6 id="org85f1393">Neutral</h6>
<div class="outline-text-6" id="text-org85f1393">
<p>
Reinhard tone mapping 的 white point 理论上为无穷大。下图中对 Reinhard Tone Mapping 进行改进，可以支持配置 white point 的值。<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_reinhard01.png" alt="03_11pp_tonemapping_reinhard01.png" /><br />
下图为 Uncharted2 中使用的 ToneMapping：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_uncharted2.png" alt="03_11pp_tonemapping_uncharted2.png" /><br />
下图为 Unity 中的 NeutralToneMap：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_neutral.png" alt="03_11pp_tonemapping_neutral.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgda63b95" class="outline-6">
<h6 id="orgda63b95">ACES</h6>
<div class="outline-text-6" id="text-orgda63b95">
<p>
ACES Tonemapping 和其他模式的最大区别在于，ACES 对于特别亮的颜色会执行色域偏移，将其推向白色。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcc6a376" class="outline-4">
<h4 id="orgcc6a376">Color Grading</h4>
<div class="outline-text-4" id="text-orgcc6a376">
</div>
<div id="outline-container-org2d91a70" class="outline-5">
<h5 id="org2d91a70">Color Adjustments</h5>
<div class="outline-text-5" id="text-org2d91a70">
<p>
粗略来算，调节视频、照片和数字图片的颜色分三个步骤:<br />
首先是颜色矫正，其目的是为了让图像匹配我们所观察到的场景，以补偿媒介的局限性。<br />
其次是色彩分级(color grading)，其为了得到期望的外观和感觉，这种结果和原始场景不匹配，而且也不需要逼真。这两个步骤通常被合并到同一个 color grading 步骤中。<br />
最后是色调映射（Tone Mapping），其将 HDR 颜色映射到显示器的显示范围。<br />
</p>

<p>
对图像只使用 tone mapping，会让图像趋向更加缺乏色彩，除非图像非常明亮。ACES 稍微增加了暗颜色的对比，但是其无法代替 color grading。<br />
</p>
</div>
<div id="outline-container-org99e006e" class="outline-6">
<h6 id="org99e006e">Post Exposure</h6>
<div class="outline-text-6" id="text-org99e006e">
<p>
Post Exposure 用于模拟摄像机的曝光，但是其被用于其他后期效果之后，并在其他 color grading 效果之前。其是一个非真实感的美术工具，可用于微调曝光而不影响其他效果，例如 bloom。<br />
</p>
</div>
</div>
<div id="outline-container-orgaa817ce" class="outline-6">
<h6 id="orgaa817ce">Constrast Saturate</h6>
<div class="outline-text-6" id="text-orgaa817ce">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradingContrast</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color) {
    color = LinearToLogC(color);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#33410;&#23545;&#27604;&#24230;&#30340;&#31639;&#27861;</span>
    color = (color - ACEScc_MIDGRAY) * <span style="color: #7590db;">_ColorAdjustments</span>.y + ACEScc_MIDGRAY;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">LogCToLinear</span>(color);
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeSaturation</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> color)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> luminance = Luminance(color);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#33410;&#39281;&#21644;&#24230;&#30340;&#31639;&#27861;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> (color - luminance) * <span style="color: #7590db;">_ColorAdjustments</span>.w + luminance;
}
</pre>
</div>

<p>
调节对比度和饱和度的公式类似，saturate 为直线的斜率，saturate 的范围为(0-2)，(1-saturate)*luminance 为直线 y 轴截距。<br />
saturate 为 0 时，最终颜色为 luminance，最终颜色只有明暗没有色彩。<br />
saturate 为 1 时，最终颜色为 color，饱和度和明度都没有变化。<br />
saturate 为 2 时，最终颜色为 color*2 - luminance，最终颜色的明度没有改变，色彩值翻倍。<br />
<img src="./UnityCatLikeCoding/03_12cg_saturate.png" alt="03_12cg_saturate.png" /><br />
<a href="./UnityCatLikeCoding/03_12cg_saturate.ggb">./UnityCatLikeCoding/03_12cg_saturate.ggb</a><br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org468a8bd" class="outline-6">
<h6 id="org468a8bd">Color Filter</h6>
<div class="outline-text-6" id="text-org468a8bd">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeColorFilter</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color) 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ColorFilter &#30340;&#31639;&#27861;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> color * <span style="color: #7590db;">_ColorFilter</span>.rgb;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff465e0" class="outline-6">
<h6 id="orgff465e0">Hue Shift</h6>
</div>
<div id="outline-container-org5099c70" class="outline-6">
<h6 id="org5099c70">White Balance</h6>
<div class="outline-text-6" id="text-org5099c70">
<p>
白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；<br />
白平衡本质上是调节两个参数：色温和色调，色温调节蓝-黄偏色，色调调节绿-品红偏色。通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换；<br />
</p>

<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/27165715">https://zhuanlan.zhihu.com/p/27165715</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org02ad27a" class="outline-6">
<h6 id="org02ad27a">Split Toning</h6>
<div class="outline-text-6" id="text-org02ad27a">
<p>
TODO 原理<br />
</p>
</div>
</div>
<div id="outline-container-orga145451" class="outline-6">
<h6 id="orga145451">Channel Mixer</h6>
<div class="outline-text-6" id="text-orga145451">
<p>
TODO 原理<br />
</p>
</div>
</div>
<div id="outline-container-orgb443ab9" class="outline-6">
<h6 id="orgb443ab9">Shadows Midtones Highlights</h6>
<div class="outline-text-6" id="text-orgb443ab9">
<p>
TODO 原理<br />
</p>
</div>
</div>
<div id="outline-container-orgeff4f72" class="outline-6">
<h6 id="orgeff4f72">ACES Color Spaces</h6>
<div class="outline-text-6" id="text-orgeff4f72">
<p>
当使用 ACES tone mapping 时，为了得到更好的结果，Unity 在 ACES 颜色空间下执行大多数 color grading。<br />
Post exposure 和 white balance 总是在线性空间下被应用。从 Constrast 开始，将 linear color 转化为 ACEScc 颜色空间。<br />
</p>

<p>
ACEScc 使用对数颜色编码，并具有使颜色分级工具感觉更像在许多配色师喜欢的对数空间中工作时的感觉的优势。<br />
ACEScct 类似于 ACEScc，但是在编码中添加了 “趾”，因此在使用提升操作时，响应感觉与传统的原木胶片扫描更加相似。这种准对数行为被描述为更“乳白色” 或“起雾”。ACEScct 是在 ACES 1.03 规范中添加的，它是基于许多配色师的反馈而替代 ACEScc 的。<br />
ACEScg 利用线性颜色编码，是为 VFX / CGI 艺术家设计的，因此他们的工具表现得更传统。<br />
</p>

<p>
unity_to_ACES  可以从 linear color 转化为 ACES 颜色空间<br />
ACES_to_ACEScc 可以从 ACES 转化为 ACEScc 颜色空间<br />
ACEScc_to_ACES 可以从 ACEScc 颜色空间转化为 ACES 颜色空间<br />
ACES_to_ACEScg 可以从 ACES 颜色空间转化为 ACEScg 颜色空间<br />
</p>

<ul class="org-ul">
<li>ACES <a href="https://www.bilibili.com/read/cv5492119/">https://www.bilibili.com/read/cv5492119/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgabaff8d" class="outline-5">
<h5 id="orgabaff8d">LUT</h5>
<div class="outline-text-5" id="text-orgabaff8d">
<p>
为每个像素执行所有的 color grading 步骤需要很多工作量。我们可以定义一些变体，从而只应用对内容有修改的 color grading，但是这需要很多 Keywords 或 Passes。我们可以将 color grading 烘培到一个 loopup table(LUT)中，通过对该 LUT 进行采样来执行颜色转换。这样的 LUT 为一个 3D 贴图，通常大小为 32x32x32。填充该贴图，运行时对该贴图采样比直接对整张图片执行 color grading 计算要少很多工作量。<br />
</p>
</div>

<div id="outline-container-org8266af1" class="outline-6">
<h6 id="org8266af1">LUT Color Matrix</h6>
<div class="outline-text-6" id="text-org8266af1">
<ul class="org-ul">
<li>TODO LUT Texture 生成时，传入的颜色如何计算？<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Returns the default value for a given position on a 2D strip-format color lookup table</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">params = (lut_height, 0.5 / lut_width, 0.5 / lut_height, lut_height / lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">GetLutStripValue</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float4</span> params)
{
    uv -= params.yz;
    real3 color;
    color.r = <span style="color: #4f97d7;">frac</span>(uv.x * params.x);
    color.b = uv.x - color.r / params.x;
    color.g = uv.y;
    <span style="color: #4f97d7; font-weight: bold;">return</span> color * params.w;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgce8fc0a" class="outline-6">
<h6 id="orgce8fc0a">Log C LUT</h6>
<div class="outline-text-6" id="text-orgce8fc0a">
<p>
前面 GetLutStripValue 生成的颜色值为(0,1)范围内的。为了支持 HDR，需要扩大该颜色范围。使用 LogCToLinear 函数来将颜色范围扩展到(0,59)<br />
</p>
</div>
</div>
<div id="outline-container-org50ecf94" class="outline-6">
<h6 id="org50ecf94">Final Pass</h6>
<div class="outline-text-6" id="text-org50ecf94">
<ul class="org-ul">
<li>TODO 如何利用 LUT Texture 计算 ColorGrading？<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2D LUT grading</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scaleOffset = (1 / lut_width, 1 / lut_height, lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">ApplyLut2D</span>(TEXTURE2D_PARAM(tex, samplerTex), <span style="color: #ce537a; font-weight: bold;">float3</span> uvw, <span style="color: #ce537a; font-weight: bold;">float3</span> scaleOffset)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Strip format where `height = sqrt(width)`</span>
    uvw.z *= scaleOffset.z;
    <span style="color: #ce537a; font-weight: bold;">float</span> shift = <span style="color: #4f97d7;">floor</span>(uvw.z);
    uvw.xy = uvw.xy * scaleOffset.z * scaleOffset.xy + scaleOffset.xy * 0.5;
    uvw.x += shift * scaleOffset.y;
    uvw.xyz = <span style="color: #4f97d7;">lerp</span>(
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy, 0.0).rgb,
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy + <span style="color: #ce537a; font-weight: bold;">float2</span>(scaleOffset.y, 0.0), 0.0).rgb,
        uvw.z - shift
    );
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6611605" class="outline-6">
<h6 id="org6611605">LUT Banding</h6>
<div class="outline-text-6" id="text-org6611605">
<p>
因为 LUT 只有有限的分辨率，我们使用双线性插值对 LUT 进行采样将原本平滑的颜色转换为了线性带。通常对于 32 分辨率的 LUT，该问题是不容易被察觉到的，但是，在极其高动态范围的颜色渐变处，该问题就会明显。<br />
将采样器从 sampler_linear_clamp 变为 sampler_point_clamp，带会变得很明显。<br />
</p>
</div>
</div>
<div id="outline-container-orgeb9cf1b" class="outline-6">
<h6 id="orgeb9cf1b">GPU GEMS2 LUT</h6>
<div class="outline-text-6" id="text-orgeb9cf1b">
<ul class="org-ul">
<li><a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color">https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color</a><br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org8fab114"></a>Shader Analysis<br />
<div class="outline-text-7" id="text-org8fab114">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float2</span> sUV : <span style="color: #a45bad;">TEXCOORD0</span>,    
          <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half4</span> cOut : <span style="color: #a45bad;">COLOR0</span>,    
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">samplerRECT</span> imagePlane,    
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">sampler3D</span> lut,    
          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float3</span> lutSize)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Get the image color</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> rawColor = <span style="color: #4f97d7;">texRECT</span>(imagePlane, sUV).rgb;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute the 3D LUT lookup scale/offset factor</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> scale = (lutSize - 1.0) / lutSize;
    <span style="color: #ce537a; font-weight: bold;">half3</span> offset = 1.0 / (2.0 * lutSize);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">****** Apply 3D LUT color transform! **************</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">This is our dependent texture read; The 3D texture's</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lookup coordinates are dependent on the</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">previous texture read's result</span>
    cOut.rgb = <span style="color: #4f97d7;">tex3D</span>(lut, scale * rawColor + offset);
}
</pre>
</div>

<p>
为什么在上面的代码中要对 UV 进行偏移和缩放？<br />
具体而言，硬件纹理采样算法会从数据集的起始边界采样到结束边界。尽管在对图像数据进行纹理化处理时这是完全合理的，但不适合对数值数据集进行采样，因为它会在纹理边缘附近引入非线性值。因此，我们只在最外层样本的中心区域内进行采样。<br />
<img src="./UnityCatLikeCoding/03_12cg_lut_sampling.png" alt="03_12cg_lut_sampling.png" /><br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2c55b3e" class="outline-4">
<h4 id="org2c55b3e">Multiple Cameras</h4>
<div class="outline-text-4" id="text-org2c55b3e">
</div>
<div id="outline-container-org2b85e6d" class="outline-5">
<h5 id="org2b85e6d">Combining Cameras</h5>
<div class="outline-text-5" id="text-org2b85e6d">
<p>
当两个摄像机叠加在一起，为了移除上面摄像机的天空盒子，可以使用 CameraClearFlags.Color 清除标记。但是，当摄像机使用后期特效后，CameraClearFlags 会被强制设置为 CameraClearFlags.Color，此时上面摄像机显示的内容会包含背景颜色。可以将后期效果 shader 的混合方式改为 Blend SrcAlpha OneMinusSrcAlpha 来去除背景颜色。<br />
</p>

<p>
当 Bloom 效果在天空背景上时，Blend SrcAlpha OneMinusSrcAlpha 模式混合后 Bloom 效果会变弱。需要将混合模式调整为 Blend One OneMinusSrcAlpha。<br />
</p>

<p>
可以使用下面方式，分别控制 RGB 和 Alpha 的混合因子：<br />
Blend SrcFactor DstFactor, AlphaSrcFactor AlphaDstFactor<br />
</p>
</div>
</div>
<div id="outline-container-org3bd97fe" class="outline-5">
<h5 id="org3bd97fe">Rendering Layers</h5>
<div class="outline-text-5" id="text-org3bd97fe">
<p>
每个物体都属于唯一一个 Layer，每个 Camera 都有一个 CullingMask 属性，其可以包含多个 Layer，用来标识哪些 Layer 对该摄像机可见。<br />
Light 也有 CullingMask，如果物体所在 Layer 没被 Light 包含，则该 Light 对该物体相当于不存在，即 Light 不会照亮物体，也不会让物体投射阴影。但是，方向光是个例外，其 CullingMask 只影响物体的阴影，而依然可以照亮物体。<br />
使用现在的方式无法完整支持 Light 的 CullingMask，HDRP 也不支持。Unity 为 SRPs 提供了 Rendering Layers 作为一种替代方案。使用 Rendering Layers 代替 game-object layers 有两个好处：<br />
</p>
<ol class="org-ol">
<li>renderers 不必限制为只属于单个 layer，这意味着 rendering-layers 更灵活。<br /></li>
<li>rendering-layers 不会被用于做其他事情(默认的 game-object layers 也会被物理模块使用)。<br /></li>
</ol>

<p>
注意： 只有 CullingMask 会被用于 Culling，Rendering-Layers 不会执行 Culling，因此 Renderer 的 RenderingLayer 不被摄像机包含时，依然会渲染该 Renderer 的阴影。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc9d3dea" class="outline-4">
<h4 id="orgc9d3dea">Particles</h4>
<div class="outline-text-4" id="text-orgc9d3dea">
</div>
<div id="outline-container-orgefdb731" class="outline-5">
<h5 id="orgefdb731">Unlit Particles</h5>
<div class="outline-text-5" id="text-orgefdb731">
</div>
<div id="outline-container-orga60c9d8" class="outline-6">
<h6 id="orga60c9d8">修改粒子发射器形状</h6>
<div class="outline-text-6" id="text-orga60c9d8">
<p>
勾选 ParticleSystem/Shape，在该分组下进行修改<br />
</p>
</div>
</div>
<div id="outline-container-orgb145b3e" class="outline-6">
<h6 id="orgb145b3e">粒子帧动画</h6>
<div class="outline-text-6" id="text-orgb145b3e">
<p>
勾选 ParticleSystem/TextureSheetAnimation，在该分组下进行修改<br />
</p>
</div>
</div>
<div id="outline-container-orgcec656a" class="outline-6">
<h6 id="orgcec656a">粒子渲染模式</h6>
<div class="outline-text-6" id="text-orgcec656a">
<p>
ParticleSystem/Renderer/Render Mode<br />
</p>

<p>
Billboard<br />
StrechedBillboard<br />
HBillboard<br />
VBillboard<br />
Mesh<br />
None<br />
</p>
</div>
</div>
<div id="outline-container-orgf6ba6c4" class="outline-6">
<h6 id="orgf6ba6c4">粒子颜色变化</h6>
<div class="outline-text-6" id="text-orgf6ba6c4">
<p>
ParticleSystem/Color over Lifetime<br />
</p>
</div>
</div>
<div id="outline-container-org853e959" class="outline-6">
<h6 id="org853e959">自定义 Shader Vertex Steam</h6>
<div class="outline-text-6" id="text-org853e959">
<p>
ParticleSystem/Renderer/Custom Vertex Streams<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5fbcf0a" class="outline-5">
<h5 id="org5fbcf0a">Fading Near Camera</h5>
<div class="outline-text-5" id="text-org5fbcf0a">
<p>
当摄像机在一个粒子系统中时，粒子会非常靠近摄像机近平面，也会闯过近平面从一侧到达另一侧。Renderer/MaxParticleSize 属性可以避免单独的粒子占据屏幕上很大的空间。当粒子靠近近平面时，一旦其达到可视最大尺寸，该粒子将会停止增大。<br />
另一种处理靠近近平面粒子的方法是，基于粒子的片段深度来淡出(fade out)粒子。这种方式对于通过代表气体效果的粒子系统时效果比较好。<br />
</p>
</div>
<div id="outline-container-orgb16b718" class="outline-6">
<h6 id="orgb16b718">Fragment Depth</h6>
<div class="outline-text-6" id="text-orgb16b718">
<p>
下面代码用于实现求解视觉空间下的 Depth<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">IsOrthographicCamera</span> () 
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> unity_OrthoParams.w;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">OrhtographicDepthBufferToLinear</span>(<span style="color: #ce537a; font-weight: bold;">float</span> rawDepth)
{
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z
    rawDepth = 1.0 - rawDepth;
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y) * rawDepth + <span style="color: #7590db;">_ProjectionParams</span>.y;
}

Fragment <span style="color: #bc6ec5; font-weight: bold;">GetFragment</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> positionSS)
{
    Fragment f;
    f.positionSS = positionSS.xy;
    f.depth = IsOrthographicCamera() ? OrthographicDepthBufferToLinear(positionSS.z) : positionSS.w;
    <span style="color: #4f97d7; font-weight: bold;">return</span> f;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga92083a" class="outline-5">
<h5 id="orga92083a">Soft Particles</h5>
<div class="outline-text-5" id="text-orga92083a">
<p>
当 Billboard 粒子和场景中几何体有交叉时，尖锐的转变会很不和谐而且使得 Billboard 粒子平坦的本质显得很明显。使用 Soft Particles 可以解决该问题，其原理为，当有不透明的物体在粒子后面时，将粒子淡出。可以比较粒子和之前渲染的不透明物体的视觉空间 depth 来实现该功能。<br />
</p>
</div>
</div>
<div id="outline-container-org471b61c" class="outline-5">
<h5 id="org471b61c">Distortion</h5>
<div class="outline-text-5" id="text-org471b61c">
<p>
实现热气导致的大气折射效果的原理为，根据粒子的 normal 对 uv 进行偏移，使用偏移后的 uv 对 color buffer 进行采样。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org226db06" class="outline-2">
<h2 id="org226db06">MyTest</h2>
<div class="outline-text-2" id="text-org226db06">
</div>
<div id="outline-container-org6e8507d" class="outline-3">
<h3 id="org6e8507d">TestReplaceShader</h3>
<div class="outline-text-3" id="text-org6e8507d">
</div>
<div id="outline-container-orgd1801eb" class="outline-4">
<h4 id="orgd1801eb">SetReplacementShader VS RenderWithShader</h4>
<div class="outline-text-4" id="text-orgd1801eb">
<p>
SetReplacementShader 修改相机渲染物体时对应物体的 shader<br />
RenderWithShader     使用相机进行额外的一次渲染，渲染时修改渲染物体对应的 shader<br />
这两个函数的参数：(Shader shader, string replacementTag)<br />
shader 即将使用的新的 shader.<br />
replacementTag 指定替换条件，具体分如下两种情况：<br />
如果 replacementTag="" 表示直接使用新的 shader。<br />
如果 replacementTag="XX" 表示，假设新 shader 的 Tag 为 Tag{ &#x2026;&#x2026; XX="xx" &#x2026;&#x2026; }，那么旧 shader 中 Tag 有相同的 XX="xx" 键值对则使用新 shader 渲染物体，否则不渲染该物体。<br />
</p>
</div>
</div>

<div id="outline-container-orgb15cfa6" class="outline-4">
<h4 id="orgb15cfa6">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgb15cfa6">
</div>
<div id="outline-container-org23c72c2" class="outline-5">
<h5 id="org23c72c2">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</h5>
<div class="outline-text-5" id="text-org23c72c2">
<p>
在 OnPreRender OnPostRender 中调用 RenderWithShader 时会提示如上警告信息。这是因为引擎对相机的渲染调用还没结束，又对同一相机发出渲染的请求。<br />
在 OnGUI 中调用 RenderWithShader 不会提示如上警告信息。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd1f1951" class="outline-3">
<h3 id="orgd1f1951">BilinearFiltering</h3>
<div class="outline-text-3" id="text-orgd1f1951">
<p>
双线性过滤属于 Up-Sampling 操作<br />
<a id="org2c33e42"></a><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #bc6ec5; font-weight: bold;">BilinearFilter</span>(<span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c00</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c10</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c01</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c11</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">tx</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ty</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #a45bad;">false</span>
    <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">a</span> = c00 * (1 - tx) + c10 * tx;
    <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">b</span> = c10 * (1 - tx) + c11 * tx;
    <span style="color: #4f97d7; font-weight: bold;">return</span> (a * (1 - ty) + b * ty);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 
        (1 - tx) * (1 - ty) * c00 +
        tx * (1 - ty) * c10 +
        (1 - tx) * ty * c01 +
        tx * ty * c11;
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>

<p>
MipMap 生成利用了将高分辨率映射为低分辨率的 Down-Sampling 操作<br />
<a href="../graphics/PhysicallyBasedRendering.html#org2a629c9">../graphics/PhysicallyBasedRendering.html#org2a629c9</a><br />
</p>

<p>
Down-Sampling 会消耗更多性能，而且还会导致画面闪烁，因此需要使用 mipmap。<br />
</p>

<ul class="org-ul">
<li>双线性过滤近似高斯模糊 <a href="https://blog.csdn.net/seizeF/article/details/90543797">https://blog.csdn.net/seizeF/article/details/90543797</a><br /></li>
<li>图像的 down-samplig 和 up-sampling <a href="https://www.cnblogs.com/jngwl/articles/image_sampling.html">https://www.cnblogs.com/jngwl/articles/image_sampling.html</a><br /></li>
<li>Mipmap 生成 <a href="https://blog.csdn.net/qjh5606/article/details/89040887">https://blog.csdn.net/qjh5606/article/details/89040887</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org282b7bb" class="outline-3">
<h3 id="org282b7bb">SphereMapping</h3>
<div class="outline-text-3" id="text-org282b7bb">
</div>
<div id="outline-container-org3d47b83" class="outline-4">
<h4 id="org3d47b83">参考资料</h4>
<div class="outline-text-4" id="text-org3d47b83">
<ul class="org-ul">
<li>环境贴图 <a href="http://www.twinklingstar.cn/2014/1322/environment-mapping/">http://www.twinklingstar.cn/2014/1322/environment-mapping/</a><br /></li>
<li>详解球面环境映射 <a href="https://zhuanlan.zhihu.com/p/84494845">https://zhuanlan.zhihu.com/p/84494845</a><br /></li>
<li>Unity Shader-Matcap(材质捕获)使用解析 <a href="https://gameinstitute.qq.com/community/detail/128771#commit">https://gameinstitute.qq.com/community/detail/128771#commit</a><br /></li>
<li>详解双抛物面环境映射 <a href="https://zhuanlan.zhihu.com/p/40784734">https://zhuanlan.zhihu.com/p/40784734</a><br /></li>
<li><a href="http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf">http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9472321" class="outline-3">
<h3 id="org9472321">Unity Universal SRP</h3>
<div class="outline-text-3" id="text-org9472321">
</div>
<div id="outline-container-orgdb14636" class="outline-4">
<h4 id="orgdb14636">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgdb14636">
</div>
<div id="outline-container-orgec23edf" class="outline-5">
<h5 id="orgec23edf">为什么 GameView 下摄像机的后处理效果没有生效？</h5>
<div class="outline-text-5" id="text-orgec23edf">
<p>
Camera 上的 PostProcessing 勾选框需要勾选。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2ec5c1f" class="outline-4">
<h4 id="org2ec5c1f">参考链接</h4>
<div class="outline-text-4" id="text-org2ec5c1f">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7924a2d" class="outline-2">
<h2 id="org7924a2d">Q&amp;A</h2>
<div class="outline-text-2" id="text-org7924a2d">
</div>
<div id="outline-container-org96b820b" class="outline-3">
<h3 id="org96b820b">如何判断投影矩阵是否为透视投影？</h3>
<div class="outline-text-3" id="text-org96b820b">
<p>
正交投影没有透视除法，所以其最后一行数据为 (0,0,0,1)。因此在游戏引擎中，只要判断投影矩阵是否为正交投影矩阵，如果不是正交投影矩阵，就是透视投影矩阵。<br />
OpenGL API 接受的矩阵需要列主序。<br />
Unity 中矩阵是列主序的，正交投影最后一列数据为(0,0,0,1)。底层使用一个 float matrixData[16] 数组存储。<br />
matrix[0]  matrix[1]  matrix[2]  matrix[3]<br />
matrix[4]  matrix[5]  matrix[6]  matrix[7]<br />
matrix[8]  matrix[9]  matrix[10] matrix[11]<br />
matrix[12] matrix[13] matrix[13] matrix[15]<br />
判断是否为透视投影矩阵的方法为：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isPerspectiveMatrix</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> matixData[3]!=0 || matrixData[7]!=0 || matrixData[11]!=0 || matrixData[15]!=1;
}
</pre>
</div>
<p>
FrameDebug 中显示的矩阵是行主序的：<br />
<img src="./UnityCatLikeCoding/00_matix_checker_01.png" alt="00_matix_checker_01.png" /><br />
<img src="./UnityCatLikeCoding/00_matix_checker_02.png" alt="00_matix_checker_02.png" /><br />
</p>

<ul class="org-ul">
<li>OpenGL 中矩阵的行主序与列主序 <a href="https://blog.51cto.com/31329846/2345432">https://blog.51cto.com/31329846/2345432</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb3aaf5" class="outline-3">
<h3 id="orgcb3aaf5">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</h3>
<div class="outline-text-3" id="text-orgcb3aaf5">
<p>
因为 unity 就是这样实现的。其实任何光照都可以在顶点着色器中计算，在片段着色器中插值获得片段颜色。<br />
</p>
</div>
</div>
<div id="outline-container-orgf257532" class="outline-3">
<h3 id="orgf257532">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</h3>
<div class="outline-text-3" id="text-orgf257532">
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/8997720.html">https://www.cnblogs.com/murongxiaopifu/p/8997720.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcf6d11a" class="outline-3">
<h3 id="orgcf6d11a">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</h3>
<div class="outline-text-3" id="text-orgcf6d11a">
<p>
对于物体来说方向光的方向都是相同的，和方向光垂直的同一平面内的点，他们对应的阴影贴图中的值应该相同，使用正交投影按照方向光方向，渲染场景中物体，将深度写入阴影贴图刚好可以满足这个要求。<br />
点光源的情况则刚好和透视投影相对应。<br />
</p>
</div>
</div>
<div id="outline-container-org582fc04" class="outline-3">
<h3 id="org582fc04">为什么点光源阴影需要绘制场景 6 次？</h3>
<div class="outline-text-3" id="text-org582fc04">
<p>
因为点光源各个方向的光照方向都不同，必须从前后左右和上下六个方向分别绘制场景，生成 Cube 阴影贴图。<br />
</p>
</div>
</div>
<div id="outline-container-orgbae650a" class="outline-3">
<h3 id="orgbae650a">Renderer.receiveShadows 是如何控制关闭接收阴影的？</h3>
<div class="outline-text-3" id="text-orgbae650a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">UnityComputeForwardShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float4</span> screenPos)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">fade value</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(worldPos, zDist);
    <span style="color: #ce537a; font-weight: bold;">half</span>  realtimeToBakedShadowFade = UnityComputeShadowFade(fadeDist);

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">baked occlusion if any</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35828;&#26126;&#65306;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Renderer.receiveShadows=false &#26102;&#65292;Unity &#24341;&#25806;&#20250;&#21462;&#28040; SHADOWS_SCREEN Keyword &#30340;&#23450;&#20041;&#65292;&#20174;&#32780;&#35753; shadowAttenuation=1</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation = 1.0f;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">directional realtime shadow</span>
<span style="color: #bc6ec5;">    #if</span> defined (SHADOWS_SCREEN)
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS) &amp;&amp; !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
            realtimeShadowAttenuation = unitySampleShadow(<span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));
<span style="color: #bc6ec5;">        #else</span>
            <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Only reached when LIGHTMAP_ON is NOT defined (and thus we use interpolator for screenPos rather than lightmap UVs). See HANDLE_SHADOWS_BLENDING_IN_GI below.</span>
            realtimeShadowAttenuation = unitySampleShadow(screenPos);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">avoid expensive shadows fetches in the distance where coherency will be good</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (realtimeToBakedShadowFade &lt; (1.0f - 1e-2f))
    {
<span style="color: #bc6ec5;">    #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">spot realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> (defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT))
<span style="color: #bc6ec5;">            #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
                unityShadowCoord4 spotShadowCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1));
<span style="color: #bc6ec5;">            #else</span>
                unityShadowCoord4 spotShadowCoord = screenPos;
<span style="color: #bc6ec5;">            #endif</span>
            realtimeShadowAttenuation = UnitySampleShadowmap(spotShadowCoord);
<span style="color: #bc6ec5;">        #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">point realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> defined (SHADOWS_CUBE)
            realtimeShadowAttenuation = UnitySampleShadowmap(worldPos - <span style="color: #7590db;">_LightPositionRange</span>.xyz);
<span style="color: #bc6ec5;">        #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    }
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(realtimeShadowAttenuation, shadowMaskAttenuation, realtimeToBakedShadowFade);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org29b5b5b" class="outline-3">
<h3 id="org29b5b5b">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</h3>
<div class="outline-text-3" id="text-org29b5b5b">
<ul class="org-ul">
<li>检查是否烘培了当前场景<br /></li>
<li>检查间接光照强度<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4aefa31" class="outline-2">
<h2 id="org4aefa31">参考资料</h2>
<div class="outline-text-2" id="text-org4aefa31">
<p>
官网<br />
<a href="https://catlikecoding.com/">https://catlikecoding.com/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/rendering/">https://catlikecoding.com/unity/tutorials/rendering/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/">https://catlikecoding.com/unity/tutorials/advanced-rendering/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/custom-srp/">https://catlikecoding.com/unity/tutorials/custom-srp/</a><br />
<a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a><br />
<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br />
</p>
</div>
</div>
</div>
</body>
</html>
