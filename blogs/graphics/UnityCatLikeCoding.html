<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-10-08 Sat 23:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UnityCatLikeCoding</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">UnityCatLikeCoding</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6b53662">UnityCatLikeCoding</a>
<ul>
<li><a href="#orgabd6d16">Basics</a>
<ul>
<li><a href="#org32ab6e1">Building a Graph</a></li>
<li><a href="#org389eb9c">Mathematical Surfaces</a>
<ul>
<li><a href="#org8197808">Ripple</a></li>
<li><a href="#org3b61af2">Sphere</a></li>
<li><a href="#org0d278f8">Torus</a></li>
</ul>
</li>
<li><a href="#org1f162af">Compute Shaders</a></li>
<li><a href="#org715c8b8">Jobs</a>
<ul>
<li><a href="#orgeed9596">Burst</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgba7f358">Pseudorandom Noise</a>
<ul>
<li><a href="#org5c25906">Unity4 Noise</a>
<ul>
<li><a href="#org7d9dae4">Noise Derivatives</a></li>
</ul>
</li>
<li><a href="#org34d06bd">Unity2010 Noise</a>
<ul>
<li><a href="#org6ce7fce">Hashing</a></li>
<li><a href="#org9ec7171">Hashing Space</a>
<ul>
<li><a href="#org6b0377e">Sample Shapes</a></li>
<li><a href="#orgf48c684">Manual Vectorization</a></li>
<li><a href="#org256b050">Octaheron and Octaheron Sphere</a></li>
</ul>
</li>
<li><a href="#org8be7ec3">Value Noise</a>
<ul>
<li><a href="#org1390c90">1D Noise</a></li>
<li><a href="#org57a04a4">2D Noise</a></li>
<li><a href="#org1bf8c0f">Smooth Noise</a></li>
</ul>
</li>
<li><a href="#org21b8fed">Perlin Noise</a>
<ul>
<li><a href="#org92216ea">Perlin Noise</a></li>
<li><a href="#orgfb14057">1D Gradients</a></li>
<li><a href="#org547b151">Variable Gradients</a></li>
<li><a href="#org520857b">2D Gradients</a></li>
<li><a href="#orga956f9a">Normalized 2D Noise</a></li>
<li><a href="#org592d857">3D Gradients</a></li>
</ul>
</li>
<li><a href="#orgca4b9d7">Noise Variants</a>
<ul>
<li><a href="#org2781de5">Fractal Noise</a></li>
<li><a href="#orga65d2bc">Turbulence</a></li>
<li><a href="#orgffd7a3d">Tiling</a></li>
</ul>
</li>
<li><a href="#orgd6f2932">Voronoi Noise</a>
<ul>
<li><a href="#org57ed92a">Distance to Nearest Point</a></li>
<li><a href="#org0f4d321">Distance to Second-Nearest Point</a></li>
<li><a href="#org1873dca">Distance Metrics</a></li>
</ul>
</li>
<li><a href="#orgbbb9abd">Simplex Noise</a>
<ul>
<li><a href="#org7c8849b">Simplex Value Noise</a></li>
<li><a href="#org640460a">Simplex Gradient Noise</a></li>
<li><a href="#orgf28fc54">参考资料</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8eee350">Mesh Basics &amp; Procedural Meshes</a>
<ul>
<li><a href="#org6f5c973">Mesh Basics</a></li>
<li><a href="#org0a9c9cb">Procedural Meshes</a></li>
</ul>
</li>
<li><a href="#orgad1991a">Rendering &amp; Advanced Rendering &amp; CustomSRP</a>
<ul>
<li><a href="#orgeb4cd15">Rendering</a>
<ul>
<li><a href="#org0f83c53">Shader Fundamentals</a>
<ul>
<li><a href="#orgdd485c6">基础知识</a></li>
<li><a href="#org1cd141f">Shader Semantics</a></li>
<li><a href="#org537ff11">Shader Commands</a></li>
<li><a href="#org6f8c1ba">Unity 定义的变量</a></li>
<li><a href="#org48e6e7b">Unity Shader 定义的宏</a></li>
<li><a href="#org675b1a1">Unity Shader Compiler</a></li>
<li><a href="#org8cf6263">Unity shader 预编译命令</a></li>
<li><a href="#org81ce66d">Shader 汇编指令</a></li>
<li><a href="#org5039137">GPU 性能</a></li>
</ul>
</li>
<li><a href="#org946d4a5">Combining Textures</a>
<ul>
<li><a href="#orge6f6450">Linear Color Space</a></li>
</ul>
</li>
<li><a href="#orga8714de">The First Light</a>
<ul>
<li><a href="#org104239b">normal 从物体空间到世界空间的变换</a></li>
<li><a href="#orgcdc82af">Tags LightMode=ForwardBase</a></li>
<li><a href="#org10910ec">BlinnPhong</a></li>
<li><a href="#orgaf6736a">Energy Conservation</a></li>
<li><a href="#org2a71f11">Specular / Metallic Workflow</a></li>
</ul>
</li>
<li><a href="#orga185b3d">Multi Lights</a>
<ul>
<li><a href="#org2db7837">Light Coord</a></li>
<li><a href="#org7f1eb6c">Light Attenuation</a></li>
<li><a href="#orgca20662">Mixing Lights</a></li>
<li><a href="#orge8649f1">Cookies</a></li>
<li><a href="#org184e266">Vertex Lights</a></li>
<li><a href="#org1fe776f">Spherical Harmonics</a></li>
</ul>
</li>
<li><a href="#org80bd00a">Bumpiness</a>
<ul>
<li><a href="#org69a5c73">高度图转 normal map 的方法</a></li>
<li><a href="#org07cc931">Normal 向量的插值</a></li>
<li><a href="#orgea6e010">Normal 贴图存储惯例</a></li>
<li><a href="#orga76f4d4">DXT5nm 存储 normal 贴图</a></li>
<li><a href="#org0516c62">缩放 Normal</a></li>
<li><a href="#org6787c5d">Blending Normals</a></li>
<li><a href="#org114f136">Tangent Space And Tangent Space To World Space</a></li>
</ul>
</li>
<li><a href="#orga067e47">Shadows</a>
<ul>
<li><a href="#orgfa74c0f">方向光阴影</a></li>
<li><a href="#org6fa4753">Spot Light Shadow</a></li>
<li><a href="#org74875da">相关宏定义</a></li>
<li><a href="#org726bc66">参考资料</a></li>
</ul>
</li>
<li><a href="#org710a16d">Reflection</a>
<ul>
<li><a href="#org7422227">Environment Mapping</a></li>
<li><a href="#org911ae96">Imperfect Reflections</a></li>
<li><a href="#orgab72b24">Box Projection</a></li>
<li><a href="#orgc8d36c7">Blending Reflection Probes</a></li>
<li><a href="#orgee11c0c">Bouncing Reflections</a></li>
</ul>
</li>
<li><a href="#orgb70f09b">ComplexMaterials &amp; More Complexity</a>
<ul>
<li><a href="#org683b209">Emission</a></li>
<li><a href="#org1e3e027">Smoothness &amp; Metallic Map</a></li>
<li><a href="#org62b8c54">Occlusion</a></li>
</ul>
</li>
<li><a href="#org94cb224">Transparency</a>
<ul>
<li><a href="#org39af979">Cutout</a></li>
<li><a href="#org53ab85b">Semitransparent</a></li>
<li><a href="#org5d4fc74">RenderType tag</a></li>
<li><a href="#org221262c">Fading vs Transparency</a></li>
</ul>
</li>
<li><a href="#org16593a4">Semitransparent Shadows</a>
<ul>
<li><a href="#org2d1a0a8">Cutout Shadow</a></li>
<li><a href="#org7e8cc89">Transparenct Shadow</a></li>
</ul>
</li>
<li><a href="#orgf6ff8f7">Deferred Shading</a>
<ul>
<li><a href="#org27b46ea">Forward Path vs Deferred Path</a></li>
<li><a href="#org8ee4255">Support Deferred Path</a></li>
<li><a href="#org494fdae">Deferred Reflections</a></li>
</ul>
</li>
<li><a href="#orgfe008a9">Fog</a>
<ul>
<li><a href="#org3f50d43">Forward Fog</a></li>
<li><a href="#orgd0a74ce">Deferred Fog</a></li>
</ul>
</li>
<li><a href="#org7bccbef">Deferred Lights</a>
<ul>
<li><a href="#org2b631c4">Light Shader</a></li>
<li><a href="#org33c6331">Directional Lights</a></li>
<li><a href="#orgb0e3b8d">Point Lights</a></li>
<li><a href="#org1d96940">Spotlights</a></li>
<li><a href="#orga61f9dc">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgc37a62e">Static Lighting</a>
<ul>
<li><a href="#org6b7ad23">Lightmapping 光照贴图</a></li>
<li><a href="#orgaf7c875">使用光照贴图</a></li>
<li><a href="#org384601f">生成光照贴图</a></li>
<li><a href="#org5e6b790">Directional Lightmaps 具有方向的光照贴图</a></li>
<li><a href="#orgc5cc1b3">Light Probes</a></li>
<li><a href="#org9cd159e">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org80c0588">Mixed Lighting</a>
<ul>
<li><a href="#org38a9f1d">烘培光照贴图的优缺点</a></li>
<li><a href="#orgff7809f">Baking Indirect Light</a></li>
<li><a href="#org80600cf">Using a Shadowmask</a></li>
<li><a href="#org0017b90">Subtractive Shadows</a></li>
<li><a href="#org35c0989">总结</a></li>
<li><a href="#orgd0f4c60">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgf922edf">RealtimeGI ProbeVolumes LOD Groups</a>
<ul>
<li><a href="#org7a6417e">Realtime Globall Illumination</a></li>
<li><a href="#org07b67d0">Light Probe Proxy Volumes</a></li>
<li><a href="#org4c516d3">LOD Groups</a></li>
</ul>
</li>
<li><a href="#org907f381">GPU Instancing</a>
<ul>
<li><a href="#orga02ddc6">Batching Instances</a></li>
<li><a href="#orge4bdfc7">Mixing Material Properties</a></li>
</ul>
</li>
<li><a href="#orgb9715cc">Parallax</a>
<ul>
<li><a href="#orgcc9752f">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7b8677b">Advanced Rendering</a>
<ul>
<li><a href="#orgfbf25a9">Flat and Wireframe Shading</a>
<ul>
<li><a href="#org20c616f">Barycentric Coordinates</a></li>
<li><a href="#org50bc1ff">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org8b1e4a8">Tessellation</a>
<ul>
<li><a href="#org8b765a5">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org413f155">Surface Displacement</a></li>
<li><a href="#orgf33dbfa">Bloom</a>
<ul>
<li><a href="#org62681fe">利用 Downsampling Upsampling 模糊图片的原理</a></li>
</ul>
</li>
<li><a href="#orgc5bbd9c">Depth of Field</a>
<ul>
<li><a href="#org736aa9b">光学原理</a></li>
<li><a href="#orgdb349b4">实现原理</a></li>
<li><a href="#orga4a7fc4">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org13452c4">FXAA</a>
<ul>
<li><a href="#orgce2d491">SSAA MSAA</a></li>
<li><a href="#orgb35728f">参考资源</a></li>
</ul>
</li>
<li><a href="#org186ad6a">Triplanar Mapping</a>
<ul>
<li><a href="#org5427e9c">求解 Normal</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9802873">CustomSRP</a>
<ul>
<li><a href="#orgc646041">Custom Render Pipeline</a>
<ul>
<li><a href="#orgdcd5687">架构</a></li>
<li><a href="#org6e3a849">CommandBuffer BeginSample EndSample</a></li>
<li><a href="#org11356bd">CameraClearFlags</a></li>
</ul>
</li>
<li><a href="#org9dd90e4">Draw Calls</a>
<ul>
<li><a href="#org61f79a6">Write a HLSL Shader</a></li>
<li><a href="#org5e827e3">Batching</a></li>
<li><a href="#org5bd688b">Transparency</a></li>
</ul>
</li>
<li><a href="#org899c6a0">Directianl Lights</a>
<ul>
<li><a href="#orgdc55eb3">Lighting</a></li>
<li><a href="#orge94f50a">BRDF</a></li>
</ul>
</li>
<li><a href="#org90376bd">Directional Shadows</a>
<ul>
<li><a href="#org2c79118">Rendering Shadows</a></li>
<li><a href="#orgedb0821">Sampling Shadows</a></li>
<li><a href="#org78b2cc7">Cascaded Shadow Maps</a></li>
<li><a href="#orgb9fa095">Transparency</a></li>
<li><a href="#org0128895">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#org9df27b8">Baked Light</a>
<ul>
<li><a href="#org796c76b">Baking Static Light</a></li>
<li><a href="#orgf01b2fd">GPU Instancing 和烘培</a></li>
</ul>
</li>
<li><a href="#org5dbcdaf">Shadow Masks</a></li>
<li><a href="#org3e17f04">LOD and Reflections</a></li>
<li><a href="#org525fd35">Complex Maps</a>
<ul>
<li><a href="#org83df8ad">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgf57f68c">Point and Spot Lights</a>
<ul>
<li><a href="#orgc9190ec">Lights Per Object</a></li>
<li><a href="#orge61c59f">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgd54e260">Point and Spot Shadows</a>
<ul>
<li><a href="#org7dfba89">Q&amp;A</a></li>
</ul>
</li>
<li><a href="#orgb4ff71b">Post Processing</a>
<ul>
<li><a href="#orgbe31189">CommandBuffer.DrawProcedural</a></li>
<li><a href="#org5cc3a57">使用双线性过滤优化高斯模糊的原理是什么？</a></li>
</ul>
</li>
<li><a href="#org83e72f4">HDR</a>
<ul>
<li><a href="#org4fcf2e0">High Dynamic Range</a></li>
<li><a href="#orgf58ff34">Scattering Bloom</a></li>
<li><a href="#org42289e6">Tone Mapping</a></li>
</ul>
</li>
<li><a href="#orgc61f735">Color Grading</a>
<ul>
<li><a href="#org95bea1a">Color Adjustments</a></li>
<li><a href="#orge653981">LUT</a></li>
</ul>
</li>
<li><a href="#org877ad45">Multiple Cameras</a>
<ul>
<li><a href="#org01b21b8">Combining Cameras</a></li>
<li><a href="#org3fb4f58">Rendering Layers</a></li>
</ul>
</li>
<li><a href="#org006219a">Particles</a>
<ul>
<li><a href="#orga14beb9">Unlit Particles</a></li>
<li><a href="#orga47076c">Fading Near Camera</a></li>
<li><a href="#org652ca45">Soft Particles</a></li>
<li><a href="#orgda176ec">Distortion</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org221dc5a">Flow</a>
<ul>
<li><a href="#org7d401a9">Texture Distortion</a>
<ul>
<li><a href="#org97884da">Animating UV</a>
<ul>
<li><a href="#orgac88ebc">直接沿着特定方向移动 UV</a></li>
<li><a href="#orgdce3114">使用 FlowMap 表示液体流动方向</a></li>
</ul>
</li>
<li><a href="#orgfbfcb84">Seamless Looping</a>
<ul>
<li><a href="#org8c73994">Blend Weight &amp; Seesaw</a></li>
<li><a href="#orgff14cf1">Time Offset</a></li>
<li><a href="#orgfbab3fd">Combining Two Distortions</a></li>
<li><a href="#org4f5023c">Jumping UV</a></li>
<li><a href="#org5acd17a">Analyzing Jumps</a></li>
</ul>
</li>
<li><a href="#orga499dd1">Animation Tweaks</a>
<ul>
<li><a href="#orgce2b0a7">Tiling</a></li>
<li><a href="#org6cdb739">支持 FlowStrength FlowOffset</a></li>
</ul>
</li>
<li><a href="#org8cb7b5b">Texturing</a>
<ul>
<li><a href="#orgcfcc5dc">Abstract Water</a></li>
<li><a href="#orgb89225f">Normal Map</a></li>
<li><a href="#orgff9b325">Derivative Map</a></li>
<li><a href="#org121c4ac">Height Scale</a></li>
<li><a href="#orgb12b903">Flow Plus Speed</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org47cb806">Directional Flow</a>
<ul>
<li><a href="#orge3255a6">Anisotropic Patterns</a>
<ul>
<li><a href="#org58ee1d2">Rippling Water</a></li>
</ul>
</li>
<li><a href="#org02727fa">Aligning With the Flow</a>
<ul>
<li><a href="#orgae833ba">UV for Directional Flow</a></li>
<li><a href="#orgde27f4b">Texture Rotation</a></li>
<li><a href="#org2f5a858">Rotating Derivatives</a></li>
<li><a href="#orgaec48b3">Sampling the Flow</a></li>
</ul>
</li>
<li><a href="#orgd26d3c4">Tiled Flow</a>
<ul>
<li><a href="#orgd842296">Flow Grid</a></li>
<li><a href="#org651339a">Blending Cells</a></li>
<li><a href="#org788255f">Overlapping Cells</a></li>
<li><a href="#orgc4f4a03">Sampling At Cell Centers</a></li>
<li><a href="#org1f2d4c6">Scaling the Waves</a></li>
</ul>
</li>
<li><a href="#org7c69e22">Hiding Artifacts</a>
<ul>
<li><a href="#orgb33637c">Nearly Uniform Flow</a></li>
<li><a href="#org0f122b3">Spotting the Grid</a></li>
<li><a href="#org4e9fdeb">Mixing Grids</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb8cf5c8">Waves</a></li>
<li><a href="#org62029ff">Looking Through Water</a></li>
<li><a href="#org5ca3434">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge317d4e">MyTest</a>
<ul>
<li><a href="#org831d730">TestReplaceShader</a>
<ul>
<li><a href="#orga5350f4">SetReplacementShader VS RenderWithShader</a></li>
<li><a href="#orgce9097e">Q&amp;A</a>
<ul>
<li><a href="#orga27d51e">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge25c918">BilinearFiltering</a></li>
<li><a href="#org91fbf95">SphereMapping</a>
<ul>
<li><a href="#orgf6b4423">参考资料</a></li>
</ul>
</li>
<li><a href="#org4b6c437">Unity Universal SRP</a>
<ul>
<li><a href="#org93e047d">Q&amp;A</a>
<ul>
<li><a href="#org841e8a2">为什么 GameView 下摄像机的后处理效果没有生效？</a></li>
</ul>
</li>
<li><a href="#org30ac2a7">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcdfe221">Q&amp;A</a>
<ul>
<li><a href="#org0940ed3">如何判断投影矩阵是否为透视投影？</a></li>
<li><a href="#org0a13816">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</a></li>
<li><a href="#orgd80d05c">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</a></li>
<li><a href="#org0c9c185">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</a></li>
<li><a href="#org1106aff">为什么点光源阴影需要绘制场景 6 次？</a></li>
<li><a href="#orga5465ce">Renderer.receiveShadows 是如何控制关闭接收阴影的？</a></li>
<li><a href="#org11b3117">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</a></li>
</ul>
</li>
<li><a href="#org127f805">参考资料</a></li>
</ul>
</div>
</div>
<p>
UnityCatLikeCoding note.<br />
</p>
<div class="HTML" id="orgbfcf6f9">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org6b53662" class="outline-2">
<h2 id="org6b53662">UnityCatLikeCoding</h2>
<div class="outline-text-2" id="text-org6b53662">
</div>
<div id="outline-container-orgabd6d16" class="outline-3">
<h3 id="orgabd6d16">Basics</h3>
<div class="outline-text-3" id="text-orgabd6d16">
</div>
<div id="outline-container-org32ab6e1" class="outline-4">
<h4 id="org32ab6e1">Building a Graph</h4>
<div class="outline-text-4" id="text-org32ab6e1">
<ul class="org-ul">
<li>Heart Function <a href="https://zhidao.baidu.com/question/760898001022081444.html">https://zhidao.baidu.com/question/760898001022081444.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org389eb9c" class="outline-4">
<h4 id="org389eb9c">Mathematical Surfaces</h4>
<div class="outline-text-4" id="text-org389eb9c">
</div>
<div id="outline-container-org8197808" class="outline-5">
<h5 id="org8197808">Ripple</h5>
<div class="outline-text-5" id="text-org8197808">

<div id="org91c7f04" class="figure">
<p><img src="./UnityCatLikeCoding/00_ripple_func.png" alt="00_ripple_func.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org3b61af2" class="outline-5">
<h5 id="org3b61af2">Sphere</h5>
<div class="outline-text-5" id="text-org3b61af2">
<p>
u-&gt;[-1, 1]<br />
v-&gt;[-1, 1]<br />
[cos(pi*u), v, sin(pi*u)]            可以绘制出一个圆<br />
</p>

<p>
r = cos(0.5*pi*v)<br />
[r * sin(pi*u), v, r*cos(pi*u)]      可以绘制出一个球<br />
</p>

<p>
将球的函数变换为如下形式，可以方便地对球的 r 进行变化：<br />
<img src="./UnityCatLikeCoding/00_sphere_func.png" alt="00_sphere_func.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org0d278f8" class="outline-5">
<h5 id="org0d278f8">Torus</h5>
<div class="outline-text-5" id="text-org0d278f8">

<div id="orgd6504fc" class="figure">
<p><img src="./UnityCatLikeCoding/00_torus_func1.jpeg" alt="00_torus_func1.jpeg" /><br />
</p>
</div>


<div id="orgab8d62a" class="figure">
<p><img src="./UnityCatLikeCoding/00_torus_func.png" alt="00_torus_func.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f162af" class="outline-4">
<h4 id="org1f162af">Compute Shaders</h4>
<div class="outline-text-4" id="text-org1f162af">
<p>
GPU 执行 compute shader 时，会将其工作划分为多个组，然后对这些组进行调度，使得这些组独立地并行运行。每个组又由多个 threads 组成，这些 threads 执行相同的计算，但是输入数据不同。我们需要在 computer shader 中使用 numthreads 属性来指定每个组包含多少个 threads，其需要 3 个整数参数。最简单的方式是将三个参数都指定为 1，表示每个组都只包含 1 个 thread。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">[numthreads(1,1,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FunctionKernel</span>() {}
</pre>
</div>

<p>
GPU 硬件包含的计算单元始终以 lockstep 方式运行特定固定数量的 thread。这些被称为 warps 或 wavefronts。 如果一个组的 threads 数量小于 warp 包含的 threads 大小，一些 threads 将空闲运行，浪费时间。如果线程的数量反而超过了 warp 包含的 threads 大小，那么 GPU 将在每组中使用更多的 warp。 一般来说，64 个线程是一个很好的默认值，因为它与 AMD GPU 的 warp 大小相匹配，而 NVidia GPU warp 的大小为 32 个，因此后者每组将使用两个 warps。实际上，硬件更复杂，可以用线程组做更多的事情，在本节中，我们实现的 Graph 不会用到。<br />
</p>

<p>
numthreads 的三个参数可用于在一、二或三个维度上组织线程。 例如，(64, 1, 1) 在一个维度上给了我们 64 个线程，而 (8, 8, 1) 给了我们相同的数量，但呈现为 2D 8×8 方形网格。实现 GPUGraph 时，我们基于 2D UV 坐标定义我们的点，所以我们使用 [numthreads(8,8,1)]，Z 维度为 1。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">[numthreads(8,8,1)]
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">FunctionKernel</span>(uint3 id:SV_DispatchThreadID) <span style="color: #2aa1ae; background-color: #292e34;">// &#27599;&#20010;thread&#36890;&#36807;&#19968;&#20010;3&#32500;&#25972;&#22411;&#21521;&#37327;&#21807;&#19968;&#34920;&#31034;</span>
{
}
</pre>
</div>

<p>
我们使用 computeShader.Dispatch 函数来发布 GPU compute shader 计算请求。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">groups</span> = Mathf.<span style="color: #bc6ec5; font-weight: bold;">CeilToInt</span>(resolution / 8f);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">kernelIdx</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsX</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsY</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">threadGroupsZ</span>
computeShader.<span style="color: #bc6ec5; font-weight: bold;">Dispatch</span>(0, groups, groups, 1);
</pre>
</div>


<div id="orga10dd30" class="figure">
<p><img src="./UnityCatLikeCoding/computer_shader_terminology.jpg" alt="computer_shader_terminology.jpg" width="700px" /><br />
</p>
</div>


<div id="org1c786a0" class="figure">
<p><img src="./UnityCatLikeCoding/00_computer_shader_terminology01.png" alt="00_computer_shader_terminology01.png" width="700px" /><br />
</p>
</div>

<p>
Tips:<br />
</p>
<ol class="org-ol">
<li>上图展示的不是 unity 中的 Dispatch, 而是 d3d 中的 ID3D11DeviceContext::Dispatch 函数<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Dispatch</span>([in] UINT ThreadGroupCountX, [in] UINT ThreadGroupCountY, [in] UINT ThreadGroupCountZ);
</pre>
</div>

<ol class="org-ol">
<li>SV_GroupIndex<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">dim.x dim.y &#20026; numthreads &#20013;&#25351;&#23450;&#30340;x&#65292;y&#30340;&#32500;&#24230;</span>
SV_GroupIndex = SV_GroupThreadID.z * dimx * dimy + SV_GroupThreadID.y * dimx + SV_GroupThreadID.x
</pre>
</div>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch">https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org715c8b8" class="outline-4">
<h4 id="org715c8b8">Jobs</h4>
<div class="outline-text-4" id="text-org715c8b8">
<p>
一般来说，分形（Fractal）是具有自相似性的东西，简单来说，这意味着它的较小部分看起来与较大部分相似。 例如海岸线和大量植物。 例如，一棵树的树枝可能看起来像树干，只是更小。数学和几何上也有分形。 例如：Mandelbrot 和 Julia 集、Koch 雪花、Menger 海绵和 Sierpiński 三角形。<br />
</p>

<p>
可以通过从初始形状开始构建几何分形，然后将其较小的副本附加到自身，然后生成较小的自身版本，依此类推。这在理论上可以永远持续下去，创造出无限数量的形状，但仍占据有限的空间。 我们可以在 Unity 中创建类似的东西，但在性能下降太多之前只能达到几个层次。<br />
</p>
</div>

<div id="outline-container-orgeed9596" class="outline-5">
<h5 id="orgeed9596">Burst</h5>
<div class="outline-text-5" id="text-orgeed9596">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Job adding two floating point values together</span>
[<span style="color: #bc6ec5; font-weight: bold;">BurstCompile</span>(FloatPrecision.Standard, FloatMode.Fast, CompileSynchronously=<span style="color: #a45bad;">true</span>)]
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> MyJob : <span style="color: #ce537a; font-weight: bold;">IJob</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">a</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">b</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;<span style="color: #ce537a; font-weight: bold;">float</span>&gt; <span style="color: #7590db;">result</span>;

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>()
    {
        result[0] = a + b;
    }
}
</pre>
</div>

<ul class="org-ul">
<li>BurstCompile  显式指定 unity 使用 Burst 来编译我们的 MyJob job 结构体。当 job 第一次被执行时，其会被 Burst 在后台进行编译，此时会使用常规的 C#编译版本。当 Burst 编译完成后，才会切换到 Burst 编译版本。<br /></li>
<li>CompileSynchronously=true 表示强制 editor 立即编译 job 的 Burst 版本，unity 会卡住，直到编译完成。<br /></li>
<li>FloatMode.Fast FastMode 允许 Burst 对数学操作重新排序，例如 a+b*c 变为 b*c+a, 这样可以使用一条 madd 指令执行计算。通常对操作顺序进行重拍不会导致逻辑错误，但是由于浮点数限制，重拍可能导致结果有稍微变化。如果这些小的差异无关紧要，就可以开启 FastMode。<br /></li>
<li>FloatPrecision.Standard 浮点数精度会控制 sin, cos 这些函数的精度。虽然，本节中没有直接使用这些函数。但是创建 quaternions 会间接使用。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgba7f358" class="outline-3">
<h3 id="orgba7f358">Pseudorandom Noise</h3>
<div class="outline-text-3" id="text-orgba7f358">
</div>
<div id="outline-container-org5c25906" class="outline-4">
<h4 id="org5c25906">Unity4 Noise</h4>
<div class="outline-text-4" id="text-org5c25906">
</div>
<div id="outline-container-org7d9dae4" class="outline-5">
<h5 id="org7d9dae4">Noise Derivatives</h5>
<div class="outline-text-5" id="text-org7d9dae4">
<iframe src="https://player.bilibili.com/player.html?aid=814779136&bvid=BV1YG4y1r7f7&cid=812366825&page=1" width="640" height="360" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul class="org-ul">
<li>Curl Noise <a href="https://www.cnblogs.com/idovelemon/p/12775127.html">https://www.cnblogs.com/idovelemon/p/12775127.html</a><br /></li>
<li>Noise Derivatives <a href="https://catlikecoding.com/unity/tutorials/noise-derivatives/">https://catlikecoding.com/unity/tutorials/noise-derivatives/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org34d06bd" class="outline-4">
<h4 id="org34d06bd">Unity2010 Noise</h4>
<div class="outline-text-4" id="text-org34d06bd">
</div>
<div id="outline-container-org6ce7fce" class="outline-5">
<h5 id="org6ce7fce">Hashing</h5>
<div class="outline-text-5" id="text-org6ce7fce">
<p>
需要随机性才能使事物变得不可预测、变化多端并显得自然。感知到的现象是真正随机的还是只是看起来随机并不重要。因此，我们可以使用完全确定性的东西，只要其不是显而易见的。软件本质上是确定性的, 设计不良的多线程代码可能会导致竞争条件，从而导致不可预测的结果，但这并不是随机性的可靠来源。真正可靠的随机性只能来源于外部（例如对大气噪声进行采样的硬件），而这些来源通常是不可用的。<br />
</p>

<p>
通常不需要真正的随机性。真随机产生的任何东西都是一次性事件，无法重现。每次结果都会不同。理想的情况是，有一个过程，对于任何特定的输入，都会产生一个独特且固定的明显随机的输出。哈希函数可以做到。<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">resolution = 32</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">invResolution = 1.0/32.0</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = 32 y = 32</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">index = [0, 32*32-1]</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">index</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">v = [0, resolution-1] = [0, 31] &#24403;&#21069;&#30340;&#34892;&#21495;</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">v</span> = (<span style="color: #ce537a; font-weight: bold;">int</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(invResolution * index + 0.00001f);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">u = [0, resolution-1] &#24403;&#21069;&#21015;&#21495;</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">u</span> = index - resolution * v;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;uv&#22352;&#26631;&#36827;&#34892;Hash&#36816;&#31639;</span>
    hashes[index] = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(u).<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(v);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ec7171" class="outline-5">
<h5 id="org9ec7171">Hashing Space</h5>
<div class="outline-text-5" id="text-org9ec7171">
<p>
在之前的教程中，我们在 HashJob 中将 index 值转化为整数 UV 坐标，然后对整数 UV 进行 Hash 运算, 得到平面上对应点的 Hash 值。在本教程中，我们直接将空间位置传递给 HashJob，直接使用 index 获取对应的空间位置。这样就可以将空间位置和 Hash 值生成分离开，让 Hash 值生成适用于任意的形状和分辨率。<br />
</p>
</div>

<div id="outline-container-org6b0377e" class="outline-6">
<h6 id="org6b0377e">Sample Shapes</h6>
<div class="outline-text-6" id="text-org6b0377e">
<p>
下面代码表示一个平面形状, 执行 Job 会生成一系列 position 和 normal, 这些 position 都在同一个平面上， normal 为对应点的法线。当然，所有点的法线都相同，就是平面的法线。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Shapes</span>
{
    [<span style="color: #bc6ec5; font-weight: bold;">BurstCompile</span>(FloatPrecision.<span style="color: #ce537a; font-weight: bold;">Standard</span>, FloatMode.<span style="color: #ce537a; font-weight: bold;">Fast</span>, CompileSynchronously = <span style="color: #a45bad;">true</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> Job : <span style="color: #ce537a; font-weight: bold;">IJobFor</span> {

        [<span style="color: #7590db;">WriteOnly</span>]
        <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float3&gt; positions;
        [<span style="color: #7590db;">WriteOnly</span>]
        <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float3&gt; normals;

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">resolution</span>, <span style="color: #7590db;">invResolution</span>;

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">positionTRS</span>;

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #7590db;">uv</span>;
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">y = [0, resolution-1] &#34892;&#21495;</span>
            uv.y = <span style="color: #bc6ec5; font-weight: bold;">floor</span>(invResolution * i + 0.00001f);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i - resolution * uv.y &#21015;&#21495;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = [-0.5, 0.5]</span>
            uv.x = invResolution * (i - resolution * uv.y + 0.5f) - 0.5f;
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">y = [-0.5, 0.5]</span>
            uv.y = invResolution * (uv.y + 0.5f) - 0.5f;

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545; position &#36827;&#34892;&#21464;&#25442;</span>
            positions[i] = <span style="color: #bc6ec5; font-weight: bold;">mul</span>(<span style="color: #ce537a; font-weight: bold;">positionTRS</span>, <span style="color: #bc6ec5; font-weight: bold;">float4</span>(uv.<span style="color: #ce537a; font-weight: bold;">x</span>, 0f, uv.<span style="color: #ce537a; font-weight: bold;">y</span>, 1f));
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545; normal &#36827;&#34892;&#21464;&#25442;</span>
            normals[i] = <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(<span style="color: #bc6ec5; font-weight: bold;">mul</span>(<span style="color: #ce537a; font-weight: bold;">positionTRS</span>, <span style="color: #bc6ec5; font-weight: bold;">float4</span>(0f, 1f, 0f, 1f)));
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf48c684" class="outline-6">
<h6 id="orgf48c684">Manual Vectorization</h6>
<div class="outline-text-6" id="text-orgf48c684">
<p>
如前所述，在我们引入向量类型后，我们的 Job 自动向量化失败了。典型的自动向量化工作是将对 float、int 和其他此类原始值执行的操作替换为对 float4、int4 等执行的相同操作。然后，利用 SIMD 指令并行执行四次迭代。 不幸的是，这不再适用于我们的 Job，因为我们使用 float3 值作为位置和法线向量。但是通过一些工作进行手动向量化是可行的。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="orgd3c6312"></a>向量化 SmallXXHash<br />
<div class="outline-text-7" id="text-orgd3c6312">
<p>
实现 SmallXXHash4，其支持包含 4 个分量的向量数据。<br />
</p>
</div>
</li>

<li><a id="orgf06b7bf"></a>向量化 HashJob<br />
<div class="outline-text-7" id="text-orgf06b7bf">
<div class="org-src-container">
<pre class="src src-csharp">[<span style="color: #bc6ec5; font-weight: bold;">BurstCompile</span>(FloatPrecision.Standard, FloatMode.Fast, CompileSynchronously = <span style="color: #a45bad;">true</span>)]
<span style="color: #4f97d7; font-weight: bold;">struct</span> HashJob : <span style="color: #ce537a; font-weight: bold;">IJobFor</span>
{
    [<span style="color: #7590db;">ReadOnly</span>]
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36755;&#20837;&#25968;&#25454;&#20174; float3 &#21464;&#20026; float3x4</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float3x4&gt; positions;
    [<span style="color: #7590db;">WriteOnly</span>]
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36755;&#20986;&#25968;&#25454;&#20174; uint &#21464;&#20026; uint4</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;uint4&gt; hashes;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">domainTRS</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25903;&#25345;4x3 &#39030;&#28857;&#30340;&#21464;&#25442;</span>
    <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #bc6ec5; font-weight: bold;">TransformPositions</span>(<span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">trs</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">p</span>) =&gt; <span style="color: #bc6ec5; font-weight: bold;">float4x3</span>(
        trs.c0.x * p.c0 + trs.c1.x * p.c1 + trs.c2.x * p.c2 + trs.c3.x,
        trs.c0.y * p.c0 + trs.c1.y * p.c1 + trs.c2.y * p.c2 + trs.c3.y,
        trs.c0.z * p.c0 + trs.c1.z * p.c1 + trs.c2.z * p.c2 + trs.c3.z
    );

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">index</span>)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;3x4 &#30340;&#25968;&#25454;&#21464;&#20026; 4x3 &#30340;&#25968;&#25454;</span>
        <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">p</span> = <span style="color: #bc6ec5; font-weight: bold;">transpose</span>(positions[index]);
        p = <span style="color: #bc6ec5; font-weight: bold;">TransformPositions</span>(domainTRS, p);

        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">u</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(p.c0);
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">v</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(p.c1);
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">w</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(p.c2);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992;&#21521;&#37327;&#21270;&#21518;&#30340;SmallXXHash4 &#35745;&#31639; hash &#20540;</span>
        hashes[index] = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(u).<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(v).<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(w);
    }
}
</pre>
</div>


<div id="org83a2dae" class="figure">
<p><img src="./UnityCatLikeCoding/05_vectorization_01.png" alt="05_vectorization_01.png" width="300px" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">HashJob</span>{
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; NativeArray&lt;uint&gt; &#35299;&#37322;&#20026;NativeArray&lt;uint4&gt;</span>
        <span style="color: #7590db;">hashes</span> = hashes.<span style="color: #bc6ec5; font-weight: bold;">Reinterpret</span>&lt;uint4&gt;(4),
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; NativeArray&lt;float3&gt; &#35299;&#37322;&#20026; NativeArray&lt;float3x4&gt;</span>
        <span style="color: #7590db;">positions</span> = positions.<span style="color: #bc6ec5; font-weight: bold;">Reinterpret</span>&lt;float3x4&gt;(3*4),
        <span style="color: #7590db;">hash</span> = SmallXXHashX.<span style="color: #bc6ec5; font-weight: bold;">Seed</span>(seed),
        <span style="color: #7590db;">domainTRS</span> = domain.Matrix
    }.<span style="color: #bc6ec5; font-weight: bold;">ScheduleParallel</span>(hashes.Length / 4, resolution, handle).<span style="color: #bc6ec5; font-weight: bold;">Complete</span>();
}
</pre>
</div>
</div>
</li>

<li><a id="orge3aa05d"></a>向量化 ShapeJob<br />
<div class="outline-text-7" id="text-orge3aa05d">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Shapes</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Job</span> : <span style="color: #ce537a; font-weight: bold;">IJobFor</span>
    {
        [<span style="color: #7590db;">WriteOnly</span>]
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36755;&#20837;&#25968;&#25454;&#20174; float3 &#21464;&#20026; float3x4</span>
            <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float3x4&gt; positions;

        [<span style="color: #7590db;">WriteOnly</span>]
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36755;&#20837;&#25968;&#25454;&#20174; float3 &#21464;&#20026; float3x4</span>
            <span style="color: #ce537a; font-weight: bold;">NativeArray</span>&lt;float3x4&gt; normals;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">resolution</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">invResolution</span>;
        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">positionTRS</span>;

        <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Execute</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">index</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">uv</span>;
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">index = [0, resolution/4]</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19968;&#27425;&#22788;&#29702;&#30456;&#37051;&#30340;4&#20010;&#28857;</span>
            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">i4</span> = 4f * index + <span style="color: #bc6ec5; font-weight: bold;">float4</span>(0f, 1f, 2f, 3f);
            uv.c1 = <span style="color: #bc6ec5; font-weight: bold;">floor</span>(invResolution * i4 + 0.00001f);
            uv.c0 = invResolution * (i4 - resolution * uv.c1 + 0.5f) - 0.5f;
            uv.c1 = invResolution * (uv.c1 + 0.5f) - 0.5f;

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;4&#32452;&#20301;&#32622;&#36827;&#34892;&#21464;&#25442;</span>
            positions[index] = <span style="color: #bc6ec5; font-weight: bold;">transpose</span>(<span style="color: #bc6ec5; font-weight: bold;">TransformVectors</span>(<span style="color: #ce537a; font-weight: bold;">positionTRS</span>, <span style="color: #bc6ec5; font-weight: bold;">float4x3</span>(uv.<span style="color: #ce537a; font-weight: bold;">c0</span>, 0f, uv.<span style="color: #ce537a; font-weight: bold;">c1</span>)));
            <span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">n</span> = <span style="color: #bc6ec5; font-weight: bold;">transpose</span>(<span style="color: #bc6ec5; font-weight: bold;">TransformVectors</span>(<span style="color: #ce537a; font-weight: bold;">positionTRS</span>, <span style="color: #bc6ec5; font-weight: bold;">float4x3</span>(0f, 1f, 0f), 0f));
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;4&#32452;normal&#36827;&#34892;&#21464;&#25442;</span>
            normals[index] = <span style="color: #bc6ec5; font-weight: bold;">float3x4</span>(<span style="color: #bc6ec5; font-weight: bold;">normalize</span>(n.<span style="color: #ce537a; font-weight: bold;">c0</span>), <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(n.<span style="color: #ce537a; font-weight: bold;">c1</span>), <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(n.<span style="color: #ce537a; font-weight: bold;">c2</span>), <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(n.<span style="color: #ce537a; font-weight: bold;">c3</span>));
        }

        <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #bc6ec5; font-weight: bold;">TransformVectors</span>(<span style="color: #ce537a; font-weight: bold;">float3x4</span> <span style="color: #7590db;">trs</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">p</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">w</span> = 1f) =&gt; <span style="color: #bc6ec5; font-weight: bold;">float4x3</span>(
            trs.c0.x * p.c0 + trs.c1.x * p.c1 + trs.c2.x * p.c2 + trs.c3.x * w,
            trs.c0.y * p.c0 + trs.c1.y * p.c1 + trs.c2.y * p.c2 + trs.c3.y * w,
            trs.c0.z * p.c0 + trs.c1.z * p.c1 + trs.c2.z * p.c2 + trs.c3.z * w
            );
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org17e8510"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="orga44b3e5"></a>向量化后数据都是以 4 个分量一组，若 resolution*resolution 不是 4 的倍数，如何处理?<br />
<div class="outline-text-8" id="text-orga44b3e5">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">length</span> = resolution * resolution;
length = length / 4 + (length &amp; 1);
</pre>
</div>
<p>
假设 resolution = 3 则 length = 9, 9/4+(9&amp;1)=2+1=3，一次调用处理 4 个一共处理 12 个，有 3 个是无意义的。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org256b050" class="outline-6">
<h6 id="org256b050">Octaheron and Octaheron Sphere</h6>
<div class="outline-text-6" id="text-org256b050">
<p>
通过对平面进行变形可以得到 Octaheron, 由 Octaheron 可以得到 Octaheron Sphere。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">Point4</span> <span style="color: #7590db;">p</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#28857;p &#32452;&#25104;&#19968;&#20010;&#24179;&#38754;</span>
p.positions.c0 = uv.c0 - 0.5f;
p.positions.c1 = uv.c1 - 0.5f;
p.positions.c2 = 0f;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;c2 &#36827;&#34892;&#35843;&#25972;&#65292;&#21363;&#21487;&#24471;&#21040;&#21322;&#23553;&#38381;&#30340; &#27491;&#20843;&#38754;&#20307;</span>
p.positions.c2 = 0.5f - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(p.positions.c0) - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(p.positions.c1);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20877;&#36827;&#34892;&#35843;&#25972;&#65292;&#24471;&#21040; &#23553;&#38381;&#30340;&#27491;&#20843;&#38754;&#20307;</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">offset</span> = <span style="color: #bc6ec5; font-weight: bold;">max</span>(-p.positions.c2, 0f);
p.positions.c0 += <span style="color: #4f97d7; font-weight: bold;">select</span>(-offset, offset, p.positions.c0&lt;0f);
p.positions.c1 += <span style="color: #4f97d7; font-weight: bold;">select</span>(-offset, offset, p.positions.c1&lt;0f);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#27491;&#20843;&#38754;&#20307;&#36716;&#25442;&#20026;&#29699;</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">scale</span> = 0.5f * <span style="color: #bc6ec5; font-weight: bold;">rsqrt</span>(
    p.positions.c0 * p.positions.c0 +
    p.positions.c1 * p.positions.c1 +
    p.positions.c2 * p.positions.c2
    );
p.positions.c0 *= scale;
p.positions.c1 *= scale;
p.positions.c2 *= scale;
p.normals = p.positions;
<span style="color: #4f97d7; font-weight: bold;">return</span> p;
</pre>
</div>

<p>
Tips:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">c &#20026; true &#36820;&#22238; b&#65292;&#21542;&#21017;&#36820;&#22238; a</span>
int4 <span style="color: #4f97d7; font-weight: bold;">select</span>(<span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">a</span>, <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">b</span>, <span style="color: #ce537a; font-weight: bold;">bool4</span> <span style="color: #7590db;">c</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8be7ec3" class="outline-5">
<h5 id="org8be7ec3">Value Noise</h5>
<div class="outline-text-5" id="text-org8be7ec3">
</div>
<div id="outline-container-org1390c90" class="outline-6">
<h6 id="org1390c90">1D Noise</h6>
<div class="outline-text-6" id="text-org1390c90">
<p>
前面我们使用 Hashing 可以为整数坐标生成独立的 hash 值。为了让 noise 平滑并且连续，我们需要在整数坐标之间混合 hash 值。<br />
</p>

<div id="org2b799a4" class="figure">
<p><img src="./UnityCatLikeCoding/noise_1d-lattice.png" alt="noise_1d-lattice.png" width="256px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org57a04a4" class="outline-6">
<h6 id="org57a04a4">2D Noise</h6>
<div class="outline-text-6" id="text-org57a04a4">

<div id="orgca85d92" class="figure">
<p><img src="./UnityCatLikeCoding/noise_2d-lattice.png" alt="noise_2d-lattice.png" width="256px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1bf8c0f" class="outline-6">
<h6 id="org1bf8c0f">Smooth Noise</h6>
<div class="outline-text-6" id="text-org1bf8c0f">
<p>
虽然我们有一个连续的 2D 图案，但它还不平滑。格子之间的过渡是线性插值，因此沿着格子正方形的边缘会发生突然变化。为了使这个平滑，我们需要考虑噪声的变化率。如果我们有一个函数，那么它的一阶导函数描述了它的变化率。由于线性插值产生一条直线，它的导数是一个常数值。二阶导函数是一阶导数的导数。可以将其视为曲率的变化率，或噪声的加速度。线性插值的二阶导数始终为零。<br />
</p>

<p>
例如，在下图中,两个一维的 Spans 在-1，0，1 之间，一维噪声值显示为黑色实线，其一阶导数为橙色虚线，其二阶导数为紫色虚线。导数除以 6 以按比例缩小，以便更容易看到。请注意，中间格点处的橙色线存在不连续性，噪声突然改变方向。<br />
</p>

<div id="orge679aab" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_linear-graph.png" alt="noise03_linear-graph.png" width="400px" /><br />
</p>
</div>

<p>
对插值系数使用 smoothstep (smoothstep 对应的函数为 \(3t^2 - 2t^3\) )可以保证一阶导数连续（一阶导数为 \(6t-6t^2\) ），但是二阶导数依然不连续(二阶导数为 \(6-12t\) )：<br />
</p>

<div id="orgccd0880" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_smoothstep-graph.png" alt="noise03_smoothstep-graph.png" width="400px" /><br />
</p>
</div>

<p>
使用 \(6t^5 - 15t^4 + 10t^3\) 可以保证一阶导数连续( \(30t^4-60t^3 + 30t^2\) )，同时二阶导数也连续( \(120t^3-180t^2+60t\) )。对于输入值 0 和 1，一阶导数和二阶导数的值都为 0。<br />
</p>


<div id="orgf69402b" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_c2-continuous-graph.png" alt="noise03_c2-continuous-graph.png" width="400px" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org21b8fed" class="outline-5">
<h5 id="org21b8fed">Perlin Noise</h5>
<div class="outline-text-5" id="text-org21b8fed">
<p>
Value Noise 属于 Lattice Noise，在 Lattice 点处定义的都是常数值。在这些常数值之间进行插值，从而得到平滑的模式，这种噪声 Lattice (格子) 依然很明显。<br />
另一种方法是在函数之间进行插值，而不是在常量值之间进行插值。 这意味着每个格子点处都有自己的函数。 为了保持简单和统一，所有点都应该使用相同的函数，只是参数有所不同。 最简单的函数是一个常数值，这就是 Value Noise(值噪声)。更复杂一点的是一个线性函数，该函数线性依赖于相对于格子点的样本的坐标。最简单直接的函数是 f(x)=x，其中 x 是相对格子点的坐标。 这将产生以格子点为中心的线性梯度。因此，这种类型的噪声被称为梯度噪声。<br />
</p>

<p>
在下图中，插值方式采用 smoothstep，让 Value.Evaluate(SmallXXHash4 hash, float4 x) 直接返回 x (即，Value.Evaluate 变为了简单的梯度函数 f(x) = x), 黑色线为对梯度进行插值得到的值，红绿蓝三条线为梯度。在 Lattice 点处的梯度都为 0，在 Lattice 点之间的 Span 的中点，梯度也为 0。<br />
</p>

<div id="orga2d3d34" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_gradients-graph.png" alt="noise03_gradients-graph.png" width="400px" /><br />
</p>
</div>

<p>
看下面文件，会更加直观一些（其实上面，红线为[-1,0]区间内的点对应的-1 晶格点的梯度值，蓝线为[0,1]区间内的点对应的 1 晶格点的梯度值, 绿线为[-1,1]区间内的点对应的 0 晶格点的梯度值）。<br />
</p>
<p width="400px">
<img src="./UnityCatLikeCoding/noise03_gradient-graph1.png" alt="noise03_gradient-graph1.png" width="400px" /><br />
<a href="./UnityCatLikeCoding/noise03_gradient_graph.ggb">./UnityCatLikeCoding/noise03_gradient_graph.ggb</a><br />
</p>

<p>
值噪声可以被认为是梯度噪声的简单情况（值噪声的梯度函数为固定的值，不会随样本点位置而变化）。<br />
</p>
</div>
<div id="outline-container-org92216ea" class="outline-6">
<h6 id="org92216ea">Perlin Noise</h6>
<div class="outline-text-6" id="text-org92216ea">
<p>
Ken Perlin 提出了梯度噪声的第一个版本，因此这种经典版本的噪声被称为 Perlin 噪声。 前面我们提到的梯度噪声相比，Perlin 噪声增加了梯度向量可以有不同方向的想法。这些不同梯度的插值产生了比值噪声更多样化和更少块状的图案。<br />
</p>

<p>
Perlin noise 是基于 permutation table 来为每个格子生成随机值的。permutation table (排列表) 并不是生成伪随机值的唯一方法。这种方法适用于简单的硬件，但是域小, 不支持 seed，也无法矢量化（其需要多个数组查询，该操作没有对应的 SIMD 指令）。因此，本节我们基于 SmallXXHash4 来为每个格子生成随机值。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a><br /></li>
<li>Understanding Perlin Noise <a href="http://adrianb.io/2014/08/09/perlinnoise.html">http://adrianb.io/2014/08/09/perlinnoise.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgfb14057" class="outline-6">
<h6 id="orgfb14057">1D Gradients</h6>
<div class="outline-text-6" id="text-orgfb14057">
<p>
Ken Perlin 并没有创造一个 1D Noise 变体，因为，1D Noise 并没有什么用，但是，1维的 Noise 可以帮助我们更容易地理解高维度 Noise。前面我们使用了固定的梯度函数 f(x) = x。按照 Perlin Noise 的思想，lattice points 的梯度可以是不同的。1维的情况下，很显然另一个不同的简单的梯度为：f(x) = -x.<br />
</p>

<p>
让 Perlin.Evaluate(SmallXXHash4 hash, float4 x) 的返回值为 select(-x, x, ((uint4)hash &amp; 1) == 0), 这样格子点之间的每个 Span 就会有 4 种插值可能性：positive-positive, negative-negative, positive-negative, 以及 negative-positive。因为，positive 和 negative 互为镜像，所以，只有两种情况：梯度相同和梯度不同。<br />
</p>

<p>
下图为 (-1, 0) 区间为 negative-positive, (0, 1)区间为 positive-negative:<br />
</p>

<div id="org4a260db" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_n-p-n-graph.png" alt="noise03_n-p-n-graph.png" width="400px" /><br />
</p>
</div>

<p>
下图为 (-1, 0) 区间为 positive-positive, (0, 1)区间为 positive-negative:<br />
</p>

<div id="org00919b9" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_p-p-n-graph.png" alt="noise03_p-p-n-graph.png" width="400px" /><br />
</p>
</div>

<p>
最终我们得到的 1D 的 binary Perlin noise 如下图（domains scale 16，resolution 256）：<br />
</p>

<div id="orgc8cf9dd" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_1d-binary.png" alt="noise03_1d-binary.png" width="400px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; 2f * <span style="color: #4f97d7; font-weight: bold;">select</span>(-x, x, ((<span style="color: #ce537a; font-weight: bold;">uint4</span>)hash &amp; 1) == 0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org547b151" class="outline-6">
<h6 id="org547b151">Variable Gradients</h6>
<div class="outline-text-6" id="text-org547b151">
<p>
我之所以将上面得到的 Perlin Noise 称为 Binary Perlin Noise, 是因为其梯度只有两种状态。因此，噪声由所有指向同一方向的梯度序列组成，除非存在符号翻转。 翻转处显示为最大振幅波，而图案的其余部分由相同的小波组成。 这看起来很死板。<br />
</p>

<p>
将 Perlin.Evaluate 修改如下, 不再是执行一个 binary 选择，我们使用 hash 来缩放相对坐标并使其在(-1,1)范围内 (Tips: ，x的范围为[0, 1])：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; 2f * (hash.Floats01A * 2f - 1f) * x;
</pre>
</div>


<div id="org6cee637" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_1d-variable.png" alt="noise03_1d-variable.png" width="400px" /><br />
</p>
</div>

<p>
经过上面的修改，图中包含了变化很大的梯度，且振幅也不同。使得只有很少的波能达到最大振幅，因此 Noise 整体的振幅减弱了。我们可以将 variable 和 binary 方式结合起来，使用第一位来选择符号并且使用 hash 来缩放选择结果,将 Perlin.Evaluate 修改如下:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; 2f * hash.Floats01A * <span style="color: #4f97d7; font-weight: bold;">select</span>(-x, x, ((<span style="color: #ce537a; font-weight: bold;">uint4</span>)hash &amp; 1) == 0);
</pre>
</div>
<p>
但是，上面在两次选择中都使用了第一位数据(hash.Floats01A 会使用第一位数据)，这引入了一些相关性。为了使两次选择更加独立，我们使用第 9 位来确定符号：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; 2f * hash.Floats01A * <span style="color: #4f97d7; font-weight: bold;">select</span>(-x, x, ((<span style="color: #ce537a; font-weight: bold;">uint4</span>)hash &amp; 1 &lt;&lt; 8) == 0);
</pre>
</div>

<div id="org47106e6" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_1d-variable-different.png" alt="noise03_1d-variable-different.png" width="400px" /><br />
</p>
</div>

<p>
这种方法的优点是我们可以引入最小振幅，而不用管梯度方向如何。通过这种方式，我们可以防止出现退化区域，在退化区域多个连续格点处的值被缩放后最终接近于零，这会产生一个平坦区域。最简单的方法是将最小振幅设置为 1 并将 hash 浮点值叠加到最小振幅上。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; (1f + hash.Floats01A) * <span style="color: #4f97d7; font-weight: bold;">select</span>(-x, x, ((<span style="color: #ce537a; font-weight: bold;">uint4</span>)hash &amp; 1 &lt;&lt; 8) == 0);
</pre>
</div>

<p>
整体的逻辑如下图所示<br />
</p>

<div id="org52a54ee" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_1d-perlin-noise.png" alt="noise03_1d-perlin-noise.png" width="800px" /><br />
</p>
</div>

<p>
下面文件中展示了多种版本的 1d perlin noise 的生成过程：<br />
<a href="./UnityCatLikeCoding/noise03_1d-perlin.ggb">./UnityCatLikeCoding/noise03_1d-perlin.ggb</a><br />
</p>


<div id="org6a3d0dc" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_1d-mix.png" alt="noise03_1d-mix.png" width="400px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org520857b" class="outline-6">
<h6 id="org520857b">2D Gradients</h6>
<div class="outline-text-6" id="text-org520857b">
<p>
2D 的情况下，梯度不再只是轴对齐的了，梯度向量可以旋转 360 度。为了生成这样的一个向量，我们可以使用我们在生成 octahedron-sphere 形状时，类似的方法。下图展示了创建 Cube 的过程：<br />
</p>
<p width="400px">
<img src="./UnityCatLikeCoding/noise03_create-cube.png" alt="noise03_create-cube.png" width="400px" /><br />
Tips: 图中注释错误，应该为 x[-1, -0.5] 被映射为 [0, 0.5]。（注释中少了一个负号）<br />
</p>

<p>
最终 2D 的 Perlin Noise 为:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Evaluate</span> (<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992;SmallXXHash4&#29983;&#25104;2D&#26799;&#24230;&#21521;&#37327; (gx, gy)</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">gx</span> = hash.Floats01A * 2f - 1f;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">gy</span> = 0.5f - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(gx);
    gx -= <span style="color: #bc6ec5; font-weight: bold;">floor</span>(gx + 0.5f);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#26799;&#24230;&#21521;&#37327;&#21644;&#20301;&#32622;&#21521;&#37327;&#30340;&#28857;&#31215;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> (gx * x + gy * y) * 2f;
}
</pre>
</div>
<p>
整体的逻辑如下图所示<br />
</p>

<div id="org97b8f81" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_2d-perlin-noise.png" alt="noise03_2d-perlin-noise.png" width="800px" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orga956f9a" class="outline-6">
<h6 id="orga956f9a">Normalized 2D Noise</h6>
<div class="outline-text-6" id="text-orga956f9a">
<p>
为了标准化噪声，我们需要确定其当前的最大振幅。如果一个格子正方形有四个梯度都指向它的中心，那么它的最大值将在中间达到。 因为这将是四个相等梯度的平均值，所以我们只需要计算那个点的单个梯度的值。 完美的对角梯度是 f(x,y)=(x+y)/2，所以中间的振幅是 f(0.5,0.5)=1/2。 然而，这并不是整个噪声的最大振幅。 还有另一种具有更大振幅的梯度配置。<br />
</p>

<p>
下面文件展示了归一化 2D Noise 的流程：<br />
</p>
<p width="400px">
<img src="./UnityCatLikeCoding/noise03_2d-perlin-noise-norm.png" alt="noise03_2d-perlin-noise-norm.png" width="400px" /><br />
<a href="./UnityCatLikeCoding/noise03_2d-perlin-normalize.ggb">./UnityCatLikeCoding/noise03_2d-perlin-normalize.ggb</a><br />
</p>
</div>
</div>

<div id="outline-container-org592d857" class="outline-6">
<h6 id="org592d857">3D Gradients</h6>
<div class="outline-text-6" id="text-org592d857">
<p>
使用生成八面体的方式来生成 3D 梯度向量，如下图：<br />
</p>

<div id="org19740d6" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_3d-perlin-noise-gradients-create.png" alt="noise03_3d-perlin-noise-gradients-create.png" width="300px" /><br />
</p>
</div>

<p>
同样也要进行归一化，原理和 2D Noise 一样。最终 3D Perlin Noise 为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">public</span> float4 Evaluate(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span>)
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">gx</span> = hash.Floats01A * 2f - 1f;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">gy</span> = hash.Floats01D * 2f - 1f;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">gz</span> = 1.0f - abs(gx) - abs(gy);
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">offset</span> = max(-gz, 0f);
    gx += select(-offset, offset, gx &lt; 0f);
    gy += select(-offset, offset, gy &lt; 0f);
    <span style="color: #4f97d7; font-weight: bold;">return</span> (gx * x + gy * y + gz * z) * (1f / 0.56290f);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgca4b9d7" class="outline-5">
<h5 id="orgca4b9d7">Noise Variants</h5>
<div class="outline-text-5" id="text-orgca4b9d7">
</div>
<div id="outline-container-org2781de5" class="outline-6">
<h6 id="org2781de5">Fractal Noise</h6>
<div class="outline-text-6" id="text-org2781de5">
<p>
Frequency   : 原来默认的周期为 1（每个格子之间的间隔为 1），使用 frequency 对位置进行缩放，就可以支持不同频率。<br />
Octaves     : 音乐简谱的音符 1 2 3 4 5 6 7 i 第一个 1 就是最后一个 1 的低八度, 最后一个 1 就是第一个 1 的高八度。<br />
Lacunarity  : 间隙。Octaves 之间，频率变化的比例。<br />
Persistence : 余辉。Octaves 之间，振幅变化的比例。<br />
</p>
</div>
</div>
<div id="outline-container-orga65d2bc" class="outline-6">
<h6 id="orga65d2bc">Turbulence</h6>
<div class="outline-text-6" id="text-orga65d2bc">
<p>
分形 Perlin 噪声的一个常见变体是对每个 octave 得到的值的绝对值求和。这会导致 Octave 在它们在通过零的地方反弹，从而产生折痕。将多个这样的 Octaves 分层会产生 Turbulence Pattern，因此也将这种噪声称为 Perlin 噪声的 Turbulence 变体。当然，值噪声也支持这种 Turbulence 变体。<br />
</p>
</div>
</div>
<div id="outline-container-orgffd7a3d" class="outline-6">
<h6 id="orgffd7a3d">Tiling</h6>
<div class="outline-text-6" id="text-orgffd7a3d">
<p>
原本 Lattices 的间隔为 1，经过 Fractal 后，[0, 1] 范围变为[0, frequency-1], 因此将 coordinates 变换到 [0, frequency-1] 范围, 就可以实现 Tiling。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">coordinates</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
{
    coordinates *= frequency;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">points</span> = <span style="color: #bc6ec5; font-weight: bold;">floor</span>(coordinates);
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">span</span>;
    span.p0 = (<span style="color: #ce537a; font-weight: bold;">int4</span>)points;
    span.p1 = span.p0 + 1;
    span.g0 = coordinates - span.p0;
    span.g1 = span.g0 - 1f;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#21462;&#20313;&#35745;&#31639;&#19981;&#25903;&#25345;&#30690;&#37327;&#21270;</span>
    span.p0 %= frequency;
    span.p0 = <span style="color: #4f97d7; font-weight: bold;">select</span>(span.p0, span.p0 + frequency, span.p0&lt;0);
    span.p1 = (span.p0 + 1) % frequency;

    span.t = coordinates - points;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">span.t = smoothstep(0, 1, span.t);</span>
    span.t = span.t * span.t * span.t * (span.t * (span.t * 6f - 15f) + 10f);
    <span style="color: #4f97d7; font-weight: bold;">return</span> span;
}
</pre>
</div>
<p>
上面代码中，整数余数的计算是通过整数除法完成的，其不支持矢量化。我们可以使用浮点数除法来代替取余操作，浮点数除法是支持矢量化的，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">coordinates</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
{
    coordinates *= frequency;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">points</span> = <span style="color: #bc6ec5; font-weight: bold;">floor</span>(coordinates);
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">span</span>;
    span.p0 = (<span style="color: #ce537a; font-weight: bold;">int4</span>)points;
    span.p1 = span.p0 + 1;
    span.g0 = coordinates - span.p0;
    span.g1 = span.g0 - 1f;

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">span.p0 %= frequency;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#28014;&#28857;&#25968;&#38500;&#27861;&#26469;&#20195;&#26367;&#25972;&#25968;&#21462;&#20313;&#25805;&#20316;</span>
    span.p0 -= (<span style="color: #ce537a; font-weight: bold;">int4</span>)(points / frequency) * frequency;
    span.p0 = <span style="color: #4f97d7; font-weight: bold;">select</span>(span.p0, span.p0 + frequency, span.p0&lt;0);
    span.p1 = span.p0 + 1;
    span.p1 = <span style="color: #4f97d7; font-weight: bold;">select</span>(span.p1, 0, span.p1==frequency);

    span.t = coordinates - points;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">span.t = smoothstep(0, 1, span.t);</span>
    span.t = span.t * span.t * span.t * (span.t * (span.t * 6f - 15f) + 10f);
    <span style="color: #4f97d7; font-weight: bold;">return</span> span;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#36827;&#19968;&#27493;&#65292;&#20351;&#29992;ceil&#26041;&#27861;&#26469;&#36991;&#20813;&#28014;&#28857;&#25968;&#31934;&#24230;&#38382;&#39064;&#21644;&#33293;&#20837;&#38382;&#39064;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">coordinates</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
{
    coordinates *= frequency;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">points</span> = <span style="color: #bc6ec5; font-weight: bold;">floor</span>(coordinates);
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">span</span>;
    span.p0 = (<span style="color: #ce537a; font-weight: bold;">int4</span>)points;
    span.p1 = span.p0 + 1;
    span.g0 = coordinates - span.p0;
    span.g1 = span.g0 - 1f;

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">span.p0 %= frequency;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#28014;&#28857;&#25968;&#38500;&#27861;&#26469;&#20195;&#26367;&#25972;&#25968;&#21462;&#20313;&#25805;&#20316;</span>
    span.p0 -= (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">ceil</span>(points / frequency) * frequency;
    span.p0 = <span style="color: #4f97d7; font-weight: bold;">select</span>(span.p0, span.p0 + frequency, span.p0&lt;0);
    span.p1 = span.p0 + 1;
    span.p1 = <span style="color: #4f97d7; font-weight: bold;">select</span>(span.p1, 0, span.p1==frequency);

    span.t = coordinates - points;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">span.t = smoothstep(0, 1, span.t);</span>
    span.t = span.t * span.t * span.t * (span.t * (span.t * 6f - 15f) + 10f);
    <span style="color: #4f97d7; font-weight: bold;">return</span> span;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">points = 15.0f frequency = 4</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15 % 4 = 3                            // version0 &#25972;&#25968;&#21462;&#20313;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15-(int)(15.0f/4)*4 = 15-12 = 3       // version1 &#28014;&#28857;&#25968;&#38500;&#27861;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15-(int)ceil(15.0f/4)*4 = 15-16 = -1  // version2 &#28014;&#28857;&#25968;&#38500;&#27861; + ceil</span>
</pre>
</div>

<p>
下图为未矢量化和矢量化后的对比：<br />
</p>

<div id="orgb30d55b" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_unvectorizor-int-divide.png" alt="noise03_unvectorizor-int-divide.png" width="600px" /><br />
</p>
</div>

<ul class="org-ul">
<li>编程语言中，取余和取模的区别到底是什么？ <a href="https://www.zhihu.com/question/30526656">https://www.zhihu.com/question/30526656</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd6f2932" class="outline-5">
<h5 id="orgd6f2932">Voronoi Noise</h5>
<div class="outline-text-5" id="text-orgd6f2932">
</div>
<div id="outline-container-org57ed92a" class="outline-6">
<h6 id="org57ed92a">Distance to Nearest Point</h6>
<div class="outline-text-6" id="text-org57ed92a">
<p>
除了值噪声和梯度噪声之外，还有第三种常见类型的噪声。其基本思想为，用任意点填充空间，然后寻找和当前点距离最近的填充点，将他们之间的距离作为当前点的噪声值。其生成的图案看起来像一个 Voronoi 图，因此它被称为 Voronoi 噪声或细胞噪声（Cell Noise）。 这种类型的噪声最早是由 Steven Worley 提出的，因此也被称为 Worley 噪声。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfb1da16"></a>Incoporating Adjacent Spans<br />
<div class="outline-text-7" id="text-orgfb1da16">
<p>
之前的噪声只考虑当前格子。Voronoi 噪声值是当前点到最近的填充点的距离，如果不考虑相邻的格子，噪声就会不连续。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetNoise4</span> (<span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>, <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
{
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">x</span> = <span style="color: #4f97d7; font-weight: bold;">default</span>(L).<span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(positions.c0, frequency);

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">minima</span> = 2f;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32771;&#34385;&#30456;&#37051;&#30340;&#26684;&#23376;</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">u</span> = -1; u &lt;= 1; u++) {
        <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">h</span> = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(x.p0 + u);
        minima = <span style="color: #bc6ec5; font-weight: bold;">UpdateVoronoiMinima</span>(minima, <span style="color: #bc6ec5; font-weight: bold;">abs</span>(h.Floats01A + u - x.g0));
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> minima;
}
</pre>
</div>
</div>
</li>
<li><a id="org63c7bdd"></a>Tiling<br />
<div class="outline-text-7" id="text-org63c7bdd">
<p>
由于计算噪声值时会考虑相邻的格子，因此按照 frequency 进行 Tiling 可能会导致边界上不连续，这种不连续的情况分为两种：<br />
</p>
<ol class="org-ol">
<li>相邻的格子位置小于 0<br /></li>
<li>相邻的格子位置大于(freqency-1)，即等于 freqency<br /></li>
</ol>

<p>
小于 0 时，将坐标设置为 freqency-1 即可。<br />
等于 freqency 时，只需要将坐标重置为 0 即可。<br />
</p>
</div>
</li>
<li><a id="orgdc45d5f"></a>Two points per Lattice Square<br />
<div class="outline-text-7" id="text-orgdc45d5f">
<p>
当前我们生成噪声值的方式，会产生超过 1 的噪声值（当前生成的最大噪声值为√2）。<br />
</p>
<p width="200px">
<img src="./UnityCatLikeCoding/noise03_voronoi-distance-max.png" alt="noise03_voronoi-distance-max.png" width="200px" /><br />
不过超过 1 的噪声占比并不大，将超 1 的噪声值设置为 1，没超过 1 的噪声值设置为 0，可以直观地看到超过 1 的噪声所占比例：<br />
</p>

<div id="orgef11e12" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-select01.png" alt="noise03_voronoi-select01.png" width="200px" /><br />
</p>
</div>

<p>
允许噪声值超过 1，意味着距离当前点的最近填充点可能在相邻的格子之外，如下图所示(中心的格子是当前处理的点所在的格子)，为了求出最近点，需要便利 21 个格子。<br />
</p>
<p width="400px">
<img src="./UnityCatLikeCoding/noise03_voronoi-dis-exceed-1-01.png" alt="noise03_voronoi-dis-exceed-1-01.png" width="400px" /><br />
遍历 21 个格子消耗太大了，不太现实。我们可以将计算得到的距离 Clamp 到 [0, 1] 范围。此时在距离超过 1 的区域，噪声值都会为 1。下图展示了，限制最大距离后，最近填充点所占区域范围:<br />
</p>

<div id="org5c67340" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-dis-exceed-1-02.png" alt="noise03_voronoi-dis-exceed-1-02.png" width="400px" /><br />
</p>
</div>

<p>
虽然，无法完全避免这种情况，但是我们可以通过增加每个格子内填充点的数量来减少这种情况。SmallXXHash4 一次会生成 4 个 0-1 范围的随机值，因此我们可以通过下面方法，增加一个填充点：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetNoise4</span>(<span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>, <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
{
    <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">l</span> = <span style="color: #4f97d7; font-weight: bold;">default</span>(L);
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">x</span> = l.<span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(positions.c0, frequency);
    <span style="color: #ce537a; font-weight: bold;">LatticeSpan4</span> <span style="color: #7590db;">z</span> = l.<span style="color: #bc6ec5; font-weight: bold;">GetLatticeSpan4</span>(positions.c2, frequency);
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">minima</span> = 2f;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">u</span>=-1; u&lt;=1; u++)
    {
        <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hx</span> = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(l.<span style="color: #bc6ec5; font-weight: bold;">ValidateSingleStep</span>(x.p0 + u, frequency));
        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">xOffset</span> = u - x.g0;
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">v</span>=-1; v&lt;=1; v++)
        {
            <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">h</span> = hx.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(l.<span style="color: #bc6ec5; font-weight: bold;">ValidateSingleStep</span>(z.p0 + v, frequency));
            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">zOffset</span> = v - z.g0;
            minima = <span style="color: #bc6ec5; font-weight: bold;">UpdateVoronoiMinima</span>(minima, <span style="color: #bc6ec5; font-weight: bold;">GetDistance</span>(h.Floats01A + xOffset, h.Floats01B + zOffset));
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22686;&#21152;&#19968;&#20010;&#22635;&#20805;&#28857;</span>
            minima = <span style="color: #bc6ec5; font-weight: bold;">UpdateVoronoiMinima</span>(minima, <span style="color: #bc6ec5; font-weight: bold;">GetDistance</span>(h.Floats01C + xOffset, h.Floats01D + zOffset));
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">min</span>(minima, 1f);
}
}
</pre>
</div>


<div id="org3011cdb" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-two-points.png" alt="noise03_voronoi-two-points.png" width="300px" /><br />
</p>
</div>

<p>
每个格子中随机填充两个点，噪声值为当前点到最近填充点的距离。因此上图中每个格子内有两个黑点, 每两个黑点之间的中垂线是白色亮线，黑点到白色亮线亮度逐渐增加。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0f4d321" class="outline-6">
<h6 id="org0f4d321">Distance to Second-Nearest Point</h6>
<div class="outline-text-6" id="text-org0f4d321">
<p width="600px">
<img src="./UnityCatLikeCoding/noise03_voronoi-two-points-second-nearest01.png" alt="noise03_voronoi-two-points-second-nearest01.png" width="600px" /><br />
上面右图中，噪声值为当前点到第二最近填充点的距离。填充点中垂线上的值最小(这里的颜色值虽然看起来暗，却和左边相同位置看起来亮的颜色值相同)，白色的亮线经过填充点。<br />
</p>

<p width="900px">
<img src="./UnityCatLikeCoding/noise03_voronoi-two-points-second-nearest02.png" alt="noise03_voronoi-two-points-second-nearest02.png" width="900px" /><br />
上面右图为中间图减去左边图的效果。左边图和中间图中填充点中垂线上的值相同，中垂线是左边图噪声值最大的地方，确实中间图噪声值最小的地方，所以中间图减去左边图，就会让中垂线更加暗。<br />
</p>
</div>
</div>
<div id="outline-container-org1873dca" class="outline-6">
<h6 id="org1873dca">Distance Metrics</h6>
<div class="outline-text-6" id="text-org1873dca">
<p>
前面度量距离的方式是欧几里得距离的平方。还可以使用其他方式度量距离。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2653e4a"></a>Chebyshev<br />
<div class="outline-text-7" id="text-org2653e4a">

<div id="orgaf4db68" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-chebychev-dis.png" alt="noise03_voronoi-chebychev-dis.png" width="300px" /><br />
</p>
</div>

<p>
Chebyshev 距离为国际象棋中，国王的棋盘距离，其描述了一个国王需要多少步才能达到棋盘上的目的地（对于国王来说对角线运动与轴对齐运动相同，即一个回合只能在轴对齐和对角线方向移动一格），Chebyshev 距离等于各个维度的欧几里得距离中最大的欧几里得距离，这意味着 Chebyshev 距离在所有维度上都是相同的。由于该性质，我们不需要限制最小值（格子范围为[0, 1]，在任意维度上，距离都不会超过 1，因此不需要在噪声值和 1 之间去最小值）。<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Chebyshev</span> : <span style="color: #ce537a; font-weight: bold;">IVoronoiDistance</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetDistance</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>) =&gt; <span style="color: #bc6ec5; font-weight: bold;">abs</span>(x);

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetDistance</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>) =&gt; <span style="color: #bc6ec5; font-weight: bold;">max</span>(<span style="color: #bc6ec5; font-weight: bold;">abs</span>(x), <span style="color: #bc6ec5; font-weight: bold;">abs</span>(y));

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetDistance</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span>) =&gt; <span style="color: #bc6ec5; font-weight: bold;">max</span>(<span style="color: #bc6ec5; font-weight: bold;">max</span>(<span style="color: #bc6ec5; font-weight: bold;">abs</span>(x), <span style="color: #bc6ec5; font-weight: bold;">abs</span>(y)), <span style="color: #bc6ec5; font-weight: bold;">abs</span>(z));

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19981;&#38656;&#35201;&#25191;&#34892; min(minima.c0, 1) min(minima.c1, 1)</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #bc6ec5; font-weight: bold;">Finalize1D</span> (<span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">minima</span>) =&gt; minima;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #bc6ec5; font-weight: bold;">Finalize2D</span> (<span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">minima</span>) =&gt; minima;
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #bc6ec5; font-weight: bold;">Finalize3D</span> (<span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">minima</span>) =&gt; minima;
}
</pre>
</div>

<p>
下图为 3D Chebyshev Voronoi 噪声，从左到右依次为 VoronoiChebychevF1 VoronoiChebychevF2 VoronoiChebychevF2MinusF1:<br />
</p>

<div id="org09e66c8" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-chebychev.png" alt="noise03_voronoi-chebychev.png" width="900px" /><br />
</p>
</div>

<p>
Chebyshev Voronoi 噪声的 Cell 具有对角线或轴对齐的边缘，它们的内部梯度形成方形图案。 与 Worley 噪声更 organic 的外观相比，其具有人工化的外观。 此外，轴对齐平面采样 3D 噪声会产生颜色均匀的方形区域(上图就是 3D Chebyshev Voronoi 噪声)，此时最大的距离在第 3 个维度上，所以上图方形区域内的噪声值都相同。<br />
</p>

<p>
下图为 2D Chebyshev Voronoi 噪声，从左到右依次为 VoronoiChebychevF1 VoronoiChebychevF2 VoronoiChebychevF2MinusF1:<br />
</p>
<p width="900px">
<img src="./UnityCatLikeCoding/noise03_voronoi-chebychev-2d.png" alt="noise03_voronoi-chebychev-2d.png" width="900px" /><br />
上面左图中最黑的十字中心为填充点。可以看到每个格子内有两个填充点。由于 Chebyshev 距离是各个维度中，最大的距离。与 x 轴平行的线上在 y 方向上距离某个填充点的距离是相同的，与 y 轴平行的线上在 x 方向上距离某个填充点的距离是相同的，因此形成了轴对齐的边缘和方形的图案。过填充点的十字线上的点，到填充点的 x 方向距离和 y 方向距离相同，并且距离填充点越远，Chebyshev 值越大，因此形成了渐变增量的十字黑线。如下图所示：<br />
</p>
<p width="300px">
<img src="./UnityCatLikeCoding/noise03_voronoi-chebychev-2d-analysis.png" alt="noise03_voronoi-chebychev-2d-analysis.png" width="300px" /><br />
白色的 45 度或 135 度斜线，则是由于到两个填充点的 x 距离和 y 距离相同形成的，如下图所示(黄色线表示当前点到右边填充点的 y 方向距离，橙色线表示当前点到左边填充点的 x 方向距离)：<br />
</p>

<div id="org3083a43" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-chebychev-2d-analysis02.png" alt="noise03_voronoi-chebychev-2d-analysis02.png" width="300px" /><br />
</p>
</div>
</div>
</li>

<li><a id="org99274f7"></a>Other Metrics<br />
<ul class="org-ul">
<li><a id="orga22db40"></a>Worley Squared<br />
<div class="outline-text-8" id="text-orga22db40">
<p>
使用欧几里得距离的平方来度量距离，可以得到类似 Worley 的噪声，其平均振幅更小。这种距离度量方式计算消耗更小。<br />
</p>


<div id="org8b9e775" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-worley-squared.png" alt="noise03_voronoi-worley-squared.png" width="600px" /><br />
</p>
</div>
</div>
</li>
<li><a id="org90a514a"></a>Manhattan Distance<br />
<div class="outline-text-8" id="text-org90a514a">
<p>
这种距离度量方式对应于国际象棋中的车移动方式(和中国象棋中的车一样，只能左右上下移动，不能斜着移动)<br />
</p>


<div id="orgf72f15f" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-manhattan.png" alt="noise03_voronoi-manhattan.png" width="600px" /><br />
</p>
</div>
</div>
</li>
<li><a id="org4c4aebb"></a>Cell Hash<br />
<div class="outline-text-8" id="text-org4c4aebb">
<p>
为每个 Cell 生成一个唯一的值，来显示 Cell。<br />
2D noise 中，从 Hash 中取 4 位数据做 Cell 颜色值，还剩下 28(32-4=28) 位数据，28 位数据分配给两个填充点，一个填充点 14 位，每个填充点对应一个 2D 的坐标，因此每个坐标分量需要 7 位(14/2)。<br />
3D noise 中，从 Hash 中取 4 位数据做 Cell 颜色值，还剩下 28(32-4=28) 位数据，28 位数据分配给两个填充点，一个填充点 14 位，每个填充点对应一个 3D 的坐标，因此每个坐标分量需要 4 位(14/3)。<br />
</p>


<div id="org95975dc" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_voronoi-hash.png" alt="noise03_voronoi-hash.png" width="600px" /><br />
</p>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbbb9abd" class="outline-5">
<h5 id="orgbbb9abd">Simplex Noise</h5>
<div class="outline-text-5" id="text-orgbbb9abd">
<p>
Ken Perlin 创建了 Perlin Noise 之后，又开发出了另一种形式的 Noise，他将这种 Noise 命名为 Simplex Noise。这种 Noise 使用 kernel summation 来代替插值，使用 simplex grid 来代替 hypercube grid。这里 kernel 可以被认为是一个 stamp 或一个 mask 来限制一个 pattern 的影响。将多个 kernel 样本(每个样本的中心在不同的位置)加在一起生成最终的噪声值。<br />
</p>

<p>
Simplex 是最简单的多胞形（多胞形是一类由平的边界构成的几何对象。多胞形可以存在于任意维中。多边形为二维多胞形，多面体为三维多胞形，也可以延伸到三维以上的空间，如多胞体（英语：polyhedron）即为四维多胞形。），它占据所有可用维度的空间。 直线段是一维 Simplex。 三角形是二维 Simplex。 正方形不是 2D Simplex，因为它比三角形多一个角和一个边，因此不是最简单的形状。 直线段也不是 2D Simplex，因为，无论它在 2D 空间中朝向如何，都只有一个维度。四面体是 3D Simplex。<br />
</p>

<p>
Simplex Noise 是梯度类型的噪声，但是我们也可以为其创建 Value 类型的变体。下面我们会先实现 Simplex Value Noise，因为其比梯度类型的变体更容易。<br />
</p>
</div>

<div id="outline-container-org7c8849b" class="outline-6">
<h6 id="org7c8849b">Simplex Value Noise</h6>
<div class="outline-text-6" id="text-org7c8849b">
</div>
<ul class="org-ul">
<li><a id="org87197ce"></a>1D Simplex Value Noise<br />
<div class="outline-text-7" id="text-org87197ce">
<p>
1D Simplex noise 和常规的值噪声一样，使用相同的线段空间分区。没有 ILattice 类型用来生成所需的数据，因此，我们直接在 Simplex1D.GetNoise4 中来生成 lattice point。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Simplex1D</span>&lt;<span style="color: #ce537a; font-weight: bold;">G</span>&gt; : <span style="color: #ce537a; font-weight: bold;">INoise</span> <span style="color: #4f97d7; font-weight: bold;">where</span> G : <span style="color: #4f97d7; font-weight: bold;">struct</span>, IGradient
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetNoise4</span>(<span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>, <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
    {
        positions *= frequency;
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">x0</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(positions.c0);
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">x1</span> = x0 + 1;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">default</span>(G).<span style="color: #bc6ec5; font-weight: bold;">EvaluateAfterInterpolation</span>(
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">simplex noise sums kernels</span>
            <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(x0), x0, positions) + <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(x1), x1, positions)
        );
    }

    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lx</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span> = positions.c0 - lx;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">default</span>(G).<span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(hash, x);
    }
}
</pre>
</div>


<div id="org713c13d" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d-01.png" alt="noise03_simplex_1d-01.png" width="600px" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgcfe944b"></a>Radially-symmetrical Falloff<br />
<div class="outline-text-7" id="text-orgcfe944b">
<p>
上面方式生成的噪声是不连续的，为了将其变为连续的形式，我们需要在一个 lattice point 到下一个 lattice point 的过程中引入平滑变换。常规的 Lattice Noise 通过插值来在 lattice points 之间进行混合，Simplex Noise 则是通过限制每个 Lattice Point 的影响来实现的。实施这样的限制是 Kernel 的职责，其定义了一个衰减函数，在当前 lattice point 上时，函数值为 1，到达相邻的 Lattice Point 时，函数值减少为 0 (从左右两个方向都是如此)。因此，该 Kernel 为对称的 Kernel。<br />
</p>

<p>
最简单的衰减函数为 f(x) = 1 - |x|, 该函数从 1 开始，在相邻的 Lattice Point 时衰减为 0. 用其缩放生成的梯度得到最终的 Kernel 样本。这样得到的 1D 噪声图如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lx</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>)
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span> = positions.c0 - lx;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">f</span> = 1f - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(x);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use f scale gradient</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> f * <span style="color: #4f97d7; font-weight: bold;">default</span>(G).<span style="color: #bc6ec5; font-weight: bold;">Evaluate</span>(hash, x);
}
</pre>
</div>

<div id="org7439255" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d-02.png" alt="noise03_simplex_1d-02.png" width="600px" /><br />
</p>
</div>

<p>
上面的噪声是连续的，其等价于简单的线性插值，因此其不平滑(smooth)。为了得到平滑的常规的值噪声，我们需要使用二阶连续的插值方法。同样地，我们可以使用二阶连续的衰减函数，从而使得 Simplex Noise 平滑。<br />
</p>

<p>
将函数 \(f(x) = 1 - x^2\) 作为衰减函数，可以引入引入弯曲，其一阶导数为 \(f'(x)=-2x\) ，二阶导数为 \(f"(x)=-2\) ，这两个函数在 x=1 和 x=-1 两个端点都不为 0。因此，该衰减函数在两个端点处依然是不连续的。另外，在 lattice point 中间位置，f(1/2) = 1-0.25 = 0.75，噪声值为两个 Kernel 样本叠加，因此，噪声值此时可能会超过 1。函数 \(f(x) = 1 - x^2\) 作为衰减函数对应的噪声图如下：<br />
</p>

<div id="org48fb6d7" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d-03.png" alt="noise03_simplex_1d-03.png" width="600px" /><br />
</p>
</div>

<p>
将函数 \(f(x) = (1 - x^2)^2\) 作为衰减函数，其一阶导数为 \(f'(x)=4x^3-4x\) ，二阶导数为 \(f"(x)=12x^2-4\) ，f'(1)=0 f'(-1)=0 f"(1)=8 f"(-1)=8，因此，该衰减函数在 -1，1 处一阶连续，但是二阶不连续。其对应的噪声图如下：<br />
</p>

<div id="orgd6981e9" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d-04.png" alt="noise03_simplex_1d-04.png" width="600px" /><br />
</p>
</div>

<p>
将函数 \(f(x) = (1 - x^2)^3\) 作为衰减函数，其一阶导数为 \(f'(x)=-6x^5+12x^3-6x\) ，二阶导数为 \(f"(x)=-30x^4+36x^2-6\) ，f'(1)=0 f'(-1)=0 f'(0)=0 f"(1)=0 f"(-1)=0 f"(0)=-6，因此，该衰减函数在 0，-1，1 处一阶连续，在-1，1 处二阶连续，但在 0 处二阶不连续。在 Lattice Point 处二阶导数不为 0 没关系，这是 Kernel 衰减函数切换方向的地方，Kernel 影响 Lattice Point 的两边，只需要在 Kernel 边缘达到 0 即可。其对应的噪声图如下：<br />
</p>


<div id="orgbb7661d" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d-05.png" alt="noise03_simplex_1d-05.png" width="600px" /><br />
</p>
</div>
</div>
</li>
<li><a id="orge34d820"></a>2D Kernels<br />
<div class="outline-text-7" id="text-orge34d820">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Simplex2D</span>&lt;<span style="color: #ce537a; font-weight: bold;">G</span>&gt; : <span style="color: #ce537a; font-weight: bold;">INoise</span> <span style="color: #4f97d7; font-weight: bold;">where</span> G : <span style="color: #4f97d7; font-weight: bold;">struct</span>, IGradient
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">GetNoise4</span>(<span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>, <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">frequency</span>)
    {
        positions *= frequency;
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">x0</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(positions.c0);
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">x1</span> = x0 + 1;
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">z0</span> = (<span style="color: #ce537a; font-weight: bold;">int4</span>)<span style="color: #bc6ec5; font-weight: bold;">floor</span>(positions.c2);
        <span style="color: #ce537a; font-weight: bold;">int4</span> <span style="color: #7590db;">z1</span> = z0 + 1;

        <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">h0</span> = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(x0);
        <span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">h1</span> = hash.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(x1);

        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">default</span>(G).<span style="color: #bc6ec5; font-weight: bold;">EvaluateCombined</span>(
            <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(h0.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(z0), x0, z0, positions) +
            <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(h0.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(z1), x0, z1, positions) +
            <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(h1.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(z0), x1, z0, positions) +
            <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(h1.<span style="color: #bc6ec5; font-weight: bold;">Eat</span>(z1), x1, z1, positions)
        );
    }

    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lx</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lz</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span> = positions.c0 - lx;
        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span> = positions.c2 - lz;

        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">f</span> = 1 - x * x - z * z;
        f = f * f * f;
        <span style="color: #4f97d7; font-weight: bold;">return</span> f;
    }
}
</pre>
</div>

<p>
使用上面 Kernel 函数得到的图形如下:<br />
</p>

<div id="orge9fdba3" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-kernel01.png" alt="noise03_simplex_2d-kernel01.png" width="400px" /><br />
</p>
</div>

<p>
上图边界点上是黑色，是由于 f(0,0)=(1-0-0)^3=1 f(1,0)=(1-1-0)^3=0 f(0,1)=(1-0-1)^3=0 f(1,1)=(1-1-1)^3=-1 因此，f(0,0)+f(1,0)+f(0,1)+f(1,1)=0 ，通过对 Kernel 做 Clamp 可以修复该问题，此时得到的图形如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Kernel</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lx</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">lz</span>, <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">positions</span>)
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span> = positions.c0 - lx;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span> = positions.c2 - lz;

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">f</span> = 1 - x * x - z * z;
    f = f * f * f;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span>(0f, f);
}
</pre>
</div>

<div id="org88be0bf" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-kernel02.png" alt="noise03_simplex_2d-kernel02.png" width="400px" /><br />
</p>
</div>
</div>
</li>
<li><a id="org8e75a88"></a>2D Simplexes<br />
<div class="outline-text-7" id="text-org8e75a88">
<p>
2D Simplexes 是三角形。使用等边三角形网格可以平铺（tile）二维空间。我们可以将基于方块的方式转化为三角形 lattice 的方式。首先，将一个方块沿着 XZ 对角线进行缩放（这种变形操作被称为切变），得到一个菱形。再将该菱形沿着 XZ 对角线分割，得到两个朝向相反的三角形。下图展示了从正方形切变为菱形：<br />
</p>

<div id="org19611a1" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-skew01.png" alt="noise03_simplex_2d-skew01.png" width="250px" /><br />
</p>
</div>

<p>
上面切变将所有点沿着 XZ 对角线方向移动，并且移动的距离和被移动点的 XZ 坐标和有关系，假设移动距离为 v(x+z)。<br />
</p>

<p>
从正方形切变为菱形：<br />
</p>

<div id="orga9a0f1f" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-skewMatrix0.png" alt="noise03_simplex_2d-skewMatrix0.png" width="450px" /><br />
</p>
</div>

<p>
从菱形切变为正方形：<br />
</p>

<div id="org8dce1c9" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-skewMatrix1.png" alt="noise03_simplex_2d-skewMatrix1.png" width="450px" /><br />
</p>
</div>
</div>

<ul class="org-ul">
<li><a id="org87f1cc4"></a>另一种切变<br />
<div class="outline-text-8" id="text-org87f1cc4">
<p>
下面文件可视化展示了另一种切变矩阵(切变后的菱形和正方形面积相等)：<br />
</p>
<p width="250px">
<img src="./UnityCatLikeCoding/noise03_simplex_2d-skewMatrix.png" alt="noise03_simplex_2d-skewMatrix.png" width="250px" /><br />
<a href="./UnityCatLikeCoding/noise03_simplex_2d-skewMatrix.ggb">./UnityCatLikeCoding/noise03_simplex_2d-skewMatrix.ggb</a><br />
下图展示了从正方形切变为菱形的切变矩阵推导：<br />
</p>

<div id="orgf24158a" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d-skew02.png" alt="noise03_simplex_2d-skew02.png" width="450px" /><br />
</p>
</div>
</div>
</li>

<li><a id="orgc1b1cdd"></a>三角形 lattice<br />
<div class="outline-text-8" id="text-orgc1b1cdd">
<p>
Simplex2D 使用三角形 lattice，我们需要利用前面得出的 skew 变换将菱形变换为正方形，来构建三角形格子。这样可得到如下 2D Kernel 图形：<br />
</p>

<div id="org217791a" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_01.png" alt="noise03_simplex_2d_01.png" width="250px" /><br />
</p>
</div>

<p>
上面虽然构建出正确的菱形格子了，但是计算 Kernel 时使用的是切变为正方形的坐标，因此噪声值不连续。将坐标再变换回菱形后，得到如下 2D Kernel 图形:<br />
</p>

<div id="orgf9c71d6" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_02.png" alt="noise03_simplex_2d_02.png" width="250px" /><br />
</p>
</div>

<p>
从上图可以看出，Kernel 的影响范围过大了，这是因为三角形区域比正方形区域小很多。对于某个晶格点来说，衰减值应该该晶格点所对的边的中点处变为零。我们可以通过将 Kernel 的起始强度降低到 0.5 来做到这一点（因为，三角形的高的平方为 0.5，具体推导如下）。得到如下 2D Kernel 图形：<br />
</p>

<div id="orge8fbb87" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_03.png" alt="noise03_simplex_2d_03.png" width="650px" /><br />
</p>
</div>

<p>
上面将 Kernel 的起始强度降低为 0.5，导致最终计算出的 Kernel 值被减弱了 8 倍( f(0,0)=0.5^3=1/8 )。对最终 Kernel 值进行放大 8 被后得到如下 2D Kernal 图形：<br />
</p>

<div id="org4fc625d" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_04.png" alt="noise03_simplex_2d_04.png" width="250px" /><br />
</p>
</div>

<p>
由于 Simplex 2D 的三角形晶格比正方形面积小，Simplex 2D 噪声频率显得比基于正方形晶格的噪声要高。菱形面积比正方形面积缩小√3，因此将频率缩小 1/√3，可以使两者频率看起来近似。<br />
</p>

<div id="org4656c43" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_05.png" alt="noise03_simplex_2d_05.png" width="250px" /><br />
</p>
</div>

<p>
下面使 Simplex 2D 噪声和常规值噪声的对比：<br />
</p>

<div id="org834d44c" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_compare01.png" alt="noise03_simplex_2d_compare01.png" width="500px" /><br />
</p>
</div>


<div id="orga6f5602" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_compare02.png" alt="noise03_simplex_2d_compare02.png" width="500px" /><br />
</p>
</div>

<p>
Simplex 2D 噪声将噪声模式变形为类似蜂巢格子的形状，并且 Simplex 2D 噪声整体更弱一些。模式上的差别在 Turbulence 变体中更加明显。<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgc7a0369"></a>Only Three Kernels<br />
<div class="outline-text-7" id="text-orgc7a0369">
<p>
上面计算 Simplex 2D 噪声时，使用了 4 个 Kernels，实际上每个三角形只需要 3 个 Kernels 就够了。Kernel00 Kernel11 是组成菱形的两个三角形都使用的 Kernel，Kernel01 和 Kernel10，则只被用于其中一个三角形。<br />
</p>


<div id="orgaae86e2" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_kernel-select.png" alt="noise03_simplex_2d_kernel-select.png" width="250px" /><br />
</p>
</div>
</div>
</li>
<li><a id="org95ade93"></a>3D Simplexes<br />
<div class="outline-text-7" id="text-org95ade93">
<p>
生成 3D Simplex lattice 的方式和生成 2D Simplex lattice 类似。对比如下:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">2D Simplex</th>
<th scope="col" class="org-left">3D Simplex</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">将正方形变为菱形(rhombohedron)</td>
<td class="org-left">将立方体变为菱面体(rhombohedron)</td>
</tr>

<tr>
<td class="org-left">将 1 个正方形划分为 2 个三角形</td>
<td class="org-left">将 1 个正方体划分为 6 个四面体(tetrahedra)</td>
</tr>
</tbody>
</table>


<div id="org4460d8c" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_skew.png" alt="noise03_simplex_3d_skew.png" width="550px" /><br />
</p>
</div>

<p>
从立方体变为菱面体：<br />
</p>

<div id="orgd949029" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_skew01.png" alt="noise03_simplex_3d_skew01.png" width="550px" /><br />
</p>
</div>

<p>
从菱面体变为立方体：<br />
</p>

<div id="orga6095d4" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_skew02.png" alt="noise03_simplex_3d_skew02.png" width="550px" /><br />
</p>
</div>

<p>
菱面体体积比正方体体积缩小 1/2。下面文件展示了菱面体体积求解过程。需要注意的是原文中是通过计算 XZ 直线上两个晶格点的距离来推算缩放系数的，其计算的缩放系数为 0.6，这可以保证 2D 形状下，Simplexes2D 和 Simplexes3D 的频率一致。<br />
<a href="./UnityCatLikeCoding/noise03_simplex_3d_tetrahedraVolume.ggb">./UnityCatLikeCoding/noise03_simplex_3d_tetrahedraVolume.ggb</a><br />
</p>
</div>
</li>
<li><a id="org224b7e3"></a>Four Kernels<br />
<div class="outline-text-7" id="text-org224b7e3">
<p>
立方体有 8 个顶点，对应 8 个 Kernels，而四面体只有 4 个顶点，因此只需要在 8 个 Kernels 中选择 4 个 Kernels 即可。其中(0,0,0) 和 (1,1,1) 这两个顶点 6 个四面体都会用到，只需要根据当前点坐标来选择另外两个顶点就可以了。下图展示了，选择另外两个顶点的方法：<br />
</p>

<div id="org1db3bb4" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_kernels-select.png" alt="noise03_simplex_3d_kernels-select.png" width="550px" /><br />
</p>
</div>

<p>
Simplexes 3D Kernels 有明显的对角线模式（Pattern），如下图。这是由于 3D 切变导致的，平面上样本点到晶格点的 Y 维度距离在不断变化。<br />
</p>
<p width="250px">
<img src="./UnityCatLikeCoding/noise03_simplex_3d_kernel-pattern.png" alt="noise03_simplex_3d_kernel-pattern.png" width="250px" /><br />
Pattern 的形状依赖于 2D 切片的朝向，如下分别展示了绕 XYZ 旋转 45 度得到的 Kernels 的 Pattern：<br />
</p>
<p width="550px">
<img src="./UnityCatLikeCoding/noise03_simplex_3d_kernel-pattern1.png" alt="noise03_simplex_3d_kernel-pattern1.png" width="550px" /><br />
下图为同时绕 XY 旋转 45 度得到的 Kernels 的 Pattern：<br />
</p>

<div id="org73f72b5" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_kernel-pattern2.png" alt="noise03_simplex_3d_kernel-pattern2.png" width="250px" /><br />
</p>
</div>

<p>
下图为 3D Simplex value Noise：<br />
</p>

<div id="org98ffd73" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_noise01.png" alt="noise03_simplex_3d_noise01.png" width="500px" /><br />
</p>
</div>

<p>
下图为 3D Simplex Value Noise 和 Value Noise 的对比：<br />
</p>

<div id="org713b2c6" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_noise02.png" alt="noise03_simplex_3d_noise02.png" width="500px" /><br />
</p>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org640460a" class="outline-6">
<h6 id="org640460a">Simplex Gradient Noise</h6>
<div class="outline-text-6" id="text-org640460a">
</div>
<ul class="org-ul">
<li><a id="org4f1b224"></a>Base Gradients<br />
<div class="outline-text-7" id="text-org4f1b224">
<p>
在 Perlin 噪声中，我们是基于正方形和八面体来生成梯度向量的，这种方式适用于正方形和立方体的格子空间。对于单形噪声来说，其格子空间是非轴对齐的，因此需要使用圆形和球体来生成梯度向量。<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">BaseGradients</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;1&#32500;&#20540;</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Line</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> (1 + hash.Floats01A) * <span style="color: #4f97d7; font-weight: bold;">select</span>(-x, <span style="color: #ce537a; font-weight: bold;">x</span>, ((<span style="color: #ce537a; font-weight: bold;">uint4</span>)hash&amp;1 &lt;&lt; 8) == 0);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;2&#32500;&#21521;&#37327;</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #bc6ec5; font-weight: bold;">SquareVectors</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">v</span>;
        v.c0 = hash.Floats01A * 2f - 1f;
        v.c1 = 0.5f - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(v.<span style="color: #ce537a; font-weight: bold;">c0</span>);
        v.c0 -= <span style="color: #bc6ec5; font-weight: bold;">floor</span>(v.c0 + 0.5f);
        <span style="color: #4f97d7; font-weight: bold;">return</span> v;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104;3&#32500;&#21521;&#37327;</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #bc6ec5; font-weight: bold;">OctahedronVectors</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">g</span>;
        g.c0 = hash.Floats01A * 2f - 1f;
        g.c1 = hash.Floats01D * 2f - 1f;
        g.c2 = 1f - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(g.<span style="color: #ce537a; font-weight: bold;">c0</span>) - <span style="color: #bc6ec5; font-weight: bold;">abs</span>(g.<span style="color: #ce537a; font-weight: bold;">c1</span>);
        <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">offset</span> = <span style="color: #bc6ec5; font-weight: bold;">max</span>(-g.c2, 0f);
        g.c0 += <span style="color: #4f97d7; font-weight: bold;">select</span>(-offset, <span style="color: #ce537a; font-weight: bold;">offset</span>, g.c0 &lt; 0f);
        g.c1 += <span style="color: #4f97d7; font-weight: bold;">select</span>(-offset, <span style="color: #ce537a; font-weight: bold;">offset</span>, g.c1 &lt; 0f);
        <span style="color: #4f97d7; font-weight: bold;">return</span> g;
    }

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Square</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">v</span> = <span style="color: #bc6ec5; font-weight: bold;">SquareVectors</span>(<span style="color: #ce537a; font-weight: bold;">hash</span>);
        <span style="color: #4f97d7; font-weight: bold;">return</span> v.c0 * x + v.c1 * y;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x, y &#36755;&#20837;&#21487;&#20197;&#26159;&#20219;&#20309;&#24418;&#29366;&#30340;&#26684;&#23376;&#65292;&#22240;&#20026;&#36825;&#37324;&#23545;&#26799;&#24230;&#21521;&#37327;&#36827;&#34892;&#20102;&#24402;&#19968;&#21270;</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Circle</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x2</span> <span style="color: #7590db;">v</span> = <span style="color: #bc6ec5; font-weight: bold;">SquareVectors</span>(<span style="color: #ce537a; font-weight: bold;">hash</span>);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">* rsqrt(v.c0 * v.c0 + v.c1 * v.c1) &#23601;&#26159;&#23545;2&#32500;&#21521;&#37327;&#36827;&#34892;&#24402;&#19968;&#21270;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> (v.c0 * x + v.c1 * y) * <span style="color: #bc6ec5; font-weight: bold;">rsqrt</span>(v.c0 * v.c0 + v.c1 * v.c1);
    }

    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Octahedron</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">v</span> = <span style="color: #bc6ec5; font-weight: bold;">OctahedronVectors</span>(<span style="color: #ce537a; font-weight: bold;">hash</span>);
        <span style="color: #4f97d7; font-weight: bold;">return</span> v.c0 * x + v.c1 * y + v.c2 * z;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x, y, z &#36755;&#20837;&#21487;&#20197;&#26159;&#20219;&#20309;&#24418;&#29366;&#30340;&#26684;&#23376;&#65292;&#22240;&#20026;&#36825;&#37324;&#23545;&#26799;&#24230;&#21521;&#37327;&#36827;&#34892;&#20102;&#24402;&#19968;&#21270;</span>
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">Sphere</span>(<span style="color: #ce537a; font-weight: bold;">SmallXXHash4</span> <span style="color: #7590db;">hash</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">x</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">y</span>, <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">z</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x3</span> <span style="color: #7590db;">v</span> = <span style="color: #bc6ec5; font-weight: bold;">OctahedronVectors</span>(<span style="color: #ce537a; font-weight: bold;">hash</span>);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">* rsqrt(v.c0 * v.c0 + v.c1 * v.c1 + v.c2 * v.c2) &#23601;&#26159;&#23545;3&#32500;&#21521;&#37327;&#36827;&#34892;&#24402;&#19968;&#21270;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> (v.c0 * x + v.c1 * y + v.c2 * z) * <span style="color: #bc6ec5; font-weight: bold;">rsqrt</span>(v.c0 * v.c0 + v.c1 * v.c1 + v.c2 * v.c2);
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org073ad85"></a>1D Simplex Noise<br />
<div class="outline-text-7" id="text-org073ad85">
<p>
1D Simplex Noise 值归一化：<br />
</p>

<div id="orgef82ac1" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_1d_noise_normalize.png" alt="noise03_simplex_1d_noise_normalize.png" width="450px" /><br />
</p>
</div>
</div>
</li>

<li><a id="org0ebcae3"></a>2D Simplex Noise<br />
<div class="outline-text-7" id="text-org0ebcae3">
<p>
2D 情况下，有两个最大值候选: 边的中点和三角形的中心<br />
</p>


<div id="org344e06d" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_2d_noise_normalize.png" alt="noise03_simplex_2d_noise_normalize.png" width="450px" /><br />
</p>
</div>
</div>
</li>

<li><a id="org02e8be5"></a>3D Simplex Noise<br />
<div class="outline-text-7" id="text-org02e8be5">

<div id="org1e14fb9" class="figure">
<p><img src="./UnityCatLikeCoding/noise03_simplex_3d_noise_normalize.png" alt="noise03_simplex_3d_noise_normalize.png" width="450px" /><br />
</p>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgf28fc54" class="outline-6">
<h6 id="orgf28fc54">参考资料</h6>
<div class="outline-text-6" id="text-orgf28fc54">
<ul class="org-ul">
<li>单形 <a href="https://zhuanlan.zhihu.com/p/360696236">https://zhuanlan.zhihu.com/p/360696236</a> 有道云笔记备份<br /></li>
<li>多胞形 polytope <a href="https://baike.baidu.com/item/%E5%A4%9A%E8%83%9E%E5%BD%A2">https://baike.baidu.com/item/%E5%A4%9A%E8%83%9E%E5%BD%A2</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8eee350" class="outline-3">
<h3 id="org8eee350">Mesh Basics &amp; Procedural Meshes</h3>
<div class="outline-text-3" id="text-org8eee350">
</div>
<div id="outline-container-org6f5c973" class="outline-4">
<h4 id="org6f5c973">Mesh Basics</h4>
</div>
<div id="outline-container-org0a9c9cb" class="outline-4">
<h4 id="org0a9c9cb">Procedural Meshes</h4>
</div>
</div>
<div id="outline-container-orgad1991a" class="outline-3">
<h3 id="orgad1991a">Rendering &amp; Advanced Rendering &amp; CustomSRP</h3>
<div class="outline-text-3" id="text-orgad1991a">
</div>
<div id="outline-container-orgeb4cd15" class="outline-4">
<h4 id="orgeb4cd15">Rendering</h4>
<div class="outline-text-4" id="text-orgeb4cd15">
</div>
<div id="outline-container-org0f83c53" class="outline-5">
<h5 id="org0f83c53">Shader Fundamentals</h5>
<div class="outline-text-5" id="text-org0f83c53">
</div>
<div id="outline-container-orgdd485c6" class="outline-6">
<h6 id="orgdd485c6">基础知识</h6>
<div class="outline-text-6" id="text-orgdd485c6">
</div>
<ul class="org-ul">
<li><a id="orgc3ed81a"></a>MatrixType<br />
<div class="outline-text-7" id="text-orgc3ed81a">
<p>
可以参考 unitycatlikecoding\Rendering\Assets\MyTest\03TestShaderMatrix 工程中的展示效果。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Properties</span>
  {
      <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
      [Enum(NotDefineM,0,DefineM,1,DefineMWithVect,2)] DefineMatrix(<span style="color: #2d9574;">"DefineMatrix"</span>, <span style="color: #4f97d7; font-weight: bold;">Float</span>) = 0
  }
  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      <span style="color: #ce537a; font-weight: bold;">float4</span> translatedVertex = v.vertex + 0.5;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix != 0)
      {
          <span style="color: #ce537a; font-weight: bold;">float4x4</span> translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
              1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1
          );
          <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix == 1)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// unity shader&#20013;&#21521;&#37327;&#20026;&#21015;&#21521;&#37327;</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#30697;&#38453;&#27599;&#19968;&#21015;&#34920;&#31034;&#21464;&#25442;&#21518;&#26032;&#22352;&#26631;&#31995;&#30340;&#22522;&#22352;&#26631;&#36724;</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// xAxis = &#65288;2,1,0)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// yAxis = &#65288;0,1,0)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// zAxis = &#65288;0,0,2)</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#30452;&#25509;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
              translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
                  2, 0, 0, 0,
                  1, 1, 0, 0,
                  0, 0, 2, 0,
                  0, 0, 0, 1
              );
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (DefineMatrix == 2)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;&#21521;&#37327;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> row0 = <span style="color: #ce537a; font-weight: bold;">float4</span>(2, 0, 0, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row1 = <span style="color: #ce537a; font-weight: bold;">float4</span>(1, 1, 0, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 2, 0);
              <span style="color: #ce537a; font-weight: bold;">float4</span> row3 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 0, 1);
              translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(row0,row1,row2,row3);
          }
          translatedVertex = <span style="color: #4f97d7;">mul</span>(translateM, translatedVertex);
      }
      o.wNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
      o.vertex = UnityObjectToClipPos(translatedVertex);
      o.uv = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
  {
      <span style="color: #ce537a; font-weight: bold;">fixed4</span> col = 1;
      <span style="color: #ce537a; font-weight: bold;">float3x3</span> colM = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
          1, 1, 0,
          0, 1, 0,
          0, 0, 1
      );
      <span style="color: #2aa1ae; background-color: #292e34;">// colM[0]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;0&#34892;&#30340;&#25968;&#25454;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// colM[2]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;2&#34892;&#30340;&#25968;&#25454;</span>
      col.rgb = colM[0];
      <span style="color: #ce537a; font-weight: bold;">float3</span> lightDir = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz;
      <span style="color: #4f97d7; font-weight: bold;">return</span> col*<span style="color: #4f97d7;">dot</span>(lightDir, i.wNormal);
      <span style="color: #2aa1ae; background-color: #292e34;">//return col;</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="orgd9d1930"></a>Array<br />
<div class="outline-text-7" id="text-orgd9d1930">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#22312;shader&#20013;&#20351;&#29992;&#25968;&#32452;&#24120;&#37327;</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> gaussianFilter3x3[9] =
{
    0.02487913, 0.10797294, 0.02487913,
    0.10797294, 0.46859173, 0.10797294,
    0.02487913, 0.10797294, 0.02487913,
};

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">float</span> gaussianFilter5x5[25] =
{
    0.00120229, 0.00828598, 0.01569749, 0.00828598, 0.00120229,
    0.00828598, 0.05710569, 0.10818462, 0.05710569, 0.00828598,
    0.01569749, 0.10818462, 0.20495178, 0.10818462, 0.01569749,
    0.00828598, 0.05710569, 0.10818462, 0.05710569, 0.00828598,
    0.00120229, 0.00828598, 0.01569749, 0.00828598, 0.00120229,
};
</pre>
</div>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/55409085/correct-way-for-declaring-a-unity-shader-array">https://stackoverflow.com/questions/55409085/correct-way-for-declaring-a-unity-shader-array</a><br /></li>
</ul>
</div>
</li>
<li><a id="orga12b388"></a>SV 含义<br />
<div class="outline-text-7" id="text-orga12b388">
<p>
SV_POSITION、SV_TARGET 中 SV 表示 System Value<br />
SV_TARGET 表示 fragment shader 写入最终颜色值的默认目标对象，其实就是帧缓冲区对象<br />
</p>
</div>
</li>
<li><a id="orgb72f785"></a>ST 含义<br />
<div class="outline-text-7" id="text-orgb72f785">
<p>
贴图附加的 Tiling 和 Offset 属性。ST 表示 Scale 和 Translation.<br />
</p>
</div>
</li>
<li><a id="org139702a"></a>贴图坐标系<br />
<div class="outline-text-7" id="text-org139702a">
<p>
OpenGL 坐标原点在左下角<br />
D3D 坐标原点在左上角<br />
</p>
</div>
</li>

<li><a id="orga7fe0ae"></a>MipMap 和 FilterMode<br />
<div class="outline-text-7" id="text-orga7fe0ae">
<p>
MipMap       用于处理贴图图元密度大于像素密度的情况，一个像素对应多个贴图图元时，如果没有 mipmap，在多个贴图图元中采用一个图元而丢弃其他。有 mipmap 时，则使用更低分辨率的贴图让 像素密度和贴图密度相接近。<br />
FilterMode   用于处理贴图图元密度小于像素密度的情况，采样器会对靠近采样点的图元进行采样，然后对这些图元进行插值，来得到最终颜色值。<br />
</p>

<p>
Bilinear texture filtering  会对靠近采样点的四个图元进行加权平均。<br />
</p>

<p>
<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering</a><br />
</p>
</div>
</li>
<li><a id="org278fcea"></a>TRANSFORM_TEX<br />
<div class="outline-text-7" id="text-org278fcea">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#26041;&#27861;&#23450;&#20041;&#22312; UnityCG.cginc</span>
<span style="color: #bc6ec5;">#define</span> TRANSFORM_TEX(tex,name) (tex.xy * name##<span style="color: #7590db;">_ST</span>.xy + name##<span style="color: #7590db;">_ST</span>.zw)
</pre>
</div>
</div>
</li>
<li><a id="org9b4460a"></a>tex2Dbias tex2Dlod<br />
<div class="outline-text-7" id="text-org9b4460a">
<p>
tex2Dbias(s, t) : Samples a 2D texture after biasing the mip level by t.w.<br />
tex2Dlod(s, t)  : Samples a 2D texture with mipmaps. The mipmap LOD is specified in t.w.<br />
</p>

<ul class="org-ul">
<li>tex2Dbias <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias</a><br /></li>
<li>tex2Dlod <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod</a><br /></li>
<li><a href="https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/">https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/</a><br /></li>
</ul>
</div>
</li>
<li><a id="org0d84d26"></a>lerp 函数意义<br />
<div class="outline-text-7" id="text-org0d84d26">

<div id="orga492ca0" class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp.png" alt="00_lerp.png" /><br />
</p>
</div>

<p>
x = 0 时，y = p; x = 1 时，y = q;<br />
lerp(p, q, x) lerp(p(1-x), q, x) lerp(p(1-x)^2, q, x) 三个函数，依次减弱 p 的效果。<br />
</p>


<div id="org8b5cb49" class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp_func.png" alt="00_lerp_func.png" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/00_lerp_func.ggb">./UnityCatLikeCoding/00_lerp_func.ggb</a><br />
</p>
</div>
</li>
<li><a id="org03db7b3"></a>ddx ddy<br />
<div class="outline-text-7" id="text-org03db7b3">
<p>
ddx(var_i) 求出 var_i 变量在当前像素块 x 方向的变化量<br />
ddy(var_i) 求出 var_i 变量在当前像素块 y 方向的变化量<br />
</p>

<ul class="org-ul">
<li><a href="http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104">http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104</a><br /></li>
</ul>
</div>
</li>
<li><a id="org49bda8f"></a>fwidth<br />
<div class="outline-text-7" id="text-org49bda8f">
<p>
fwidth(var_i) = abs(ddx(var_i)) + abs(ddy(var_i))<br />
</p>
</div>
</li>
<li><a id="org68ef6d9"></a>smoothstep<br />
<div class="outline-text-7" id="text-org68ef6d9">
<p>
smoothstep(a, b, c) 在 a-b 范围进行插值，c&lt;=a 返回 0，c&gt;=b 返回 1<br />
</p>

<p>
t = (c-a)/(b-a)<br />
t = saturate(t)<br />
result = 3t^2 - 2t^3<br />
</p>


<div id="org05702b4" class="figure">
<p><img src="./UnityCatLikeCoding/00_smoothstep.png" alt="00_smoothstep.png" /><br />
</p>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1cd141f" class="outline-6">
<h6 id="org1cd141f">Shader Semantics</h6>
<div class="outline-text-6" id="text-org1cd141f">
</div>
<ul class="org-ul">
<li><a id="org40ff065"></a>Screen space pixel position: VPOS<br />
<div class="outline-text-7" id="text-org40ff065">
<p>
VPOS 输出的变量中保存的是屏幕像素点坐标，坐标值为整数值。<br />
VPOS 和 SV_POSITION 不能同时出现在 vout 中，需要使用 fin 将两者分离。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Screen Position"</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Properties</span>
      {
          <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
      }
      <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">Pass</span>
          {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">              #pragma</span> vertex vert
<span style="color: #bc6ec5;">              #pragma</span> fragment frag
<span style="color: #bc6ec5;">              #pragma</span> target 3.0
<span style="color: #bc6ec5;">              #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
              <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
              {
                  <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
              };

              <span style="color: #4f97d7; font-weight: bold;">struct</span> vout {
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                  <span style="color: #ce537a; font-weight: bold;">float4</span> outpos : <span style="color: #a45bad;">SV_POSITION</span>;
              };

              <span style="color: #4f97d7; font-weight: bold;">struct</span> fin
              {
                  <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                  UNITY_VPOS_TYPE screenPos : <span style="color: #a45bad;">VPOS</span>;
              };

<span style="color: #bc6ec5;">              #define</span> vert_out vout
<span style="color: #bc6ec5;">              #define</span> frag_in fin

              vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata i)
              {
                  vert_out o;
                  o.uv = i.uv;
                  o.outpos = UnityObjectToClipPos(i.vertex);
                  <span style="color: #4f97d7; font-weight: bold;">return</span> o;
              }

              <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;

              <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (frag_in i) : <span style="color: #a45bad;">SV_Target</span>
              {
                  <span style="color: #2aa1ae; background-color: #292e34;">// screenPos.xy will contain pixel integer coordinates.</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// return i.screenPos.x &lt; _ScreenParams.x/2 ? 0 : 1;</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// use them to implement a checkerboard pattern that skips rendering</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// 4x4 blocks of pixels</span>

                  <span style="color: #2aa1ae; background-color: #292e34;">// checker value will be negative for 4x4 blocks of pixels</span>
                  <span style="color: #2aa1ae; background-color: #292e34;">// in a checkerboard pattern</span>
                  i.screenPos.xy = <span style="color: #4f97d7;">floor</span>(i.screenPos.xy * 0.25) * 0.5;
                  <span style="color: #ce537a; font-weight: bold;">float</span> checker = -<span style="color: #4f97d7;">frac</span>(i.screenPos.r + i.screenPos.g);

                  <span style="color: #2aa1ae; background-color: #292e34;">// clip HLSL instruction stops rendering a pixel if value is negative</span>
                  <span style="color: #4f97d7;">clip</span>(checker);

                  <span style="color: #2aa1ae; background-color: #292e34;">// for pixels that were kept, read the texture and output it</span>
                  <span style="color: #ce537a; font-weight: bold;">fixed4</span> c = <span style="color: #4f97d7;">tex2D</span> (<span style="color: #7590db;">_MainTex</span>, i.uv);
                  <span style="color: #4f97d7; font-weight: bold;">return</span> c;
              }
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="orgbe46fa1"></a>Face orientation: VFACE<br />
<div class="outline-text-7" id="text-orgbe46fa1">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Face Orientation"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_ColorFront</span> (<span style="color: #2d9574;">"Front Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (1,0.7,0.7,1)
        <span style="color: #7590db;">_ColorBack</span> (<span style="color: #2d9574;">"Back Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (0.7,1,0.7,1)
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #2aa1ae; background-color: #292e34;">// turn off backface culling</span>

            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0

            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">vert</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>) : <span style="color: #a45bad;">SV_POSITION</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
            }

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorFront</span>;
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorBack</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (<span style="color: #ce537a; font-weight: bold;">fixed</span> facing : <span style="color: #a45bad;">VFACE</span>) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// VFACE input positive for frontbaces,</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// negative for backfaces. Output one</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// of the two colors depending on that.</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> facing &gt; 0 ? <span style="color: #7590db;">_ColorFront</span> : <span style="color: #7590db;">_ColorBack</span>;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// or</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace = 1;
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    vFace = i.vFace &gt; 0 ? 1 : -1;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> vFace*2-1;
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orged67216"></a>error Shader error in 'Custom/MyEffect/GNoiseBall': Non system-generated input signature parameter () cannot appear after a system generated value. at line 98 (on d3d11)<br />
<div class="outline-text-8" id="text-orged67216">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> wPos : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">fixed3</span> wNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
};
<span style="color: #2aa1ae; background-color: #292e34;">// &#23558;&#19978;&#38754;&#32467;&#26500;&#20307;&#22768;&#26126;&#25913;&#20026;&#19979;&#38754;&#26041;&#24335;&#65292;&#23601;&#21487;&#20197;&#36991;&#20813;&#35813;&#38169;&#35823;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> wPos : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">fixed3</span> wNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    UNITY_VERTEX_INPUT_INSTANCE_ID            <span style="color: #2aa1ae; background-color: #292e34;">// &#24320;&#21551;GPU Instance&#21518;&#65292;UNITY_VERTEX_INPUT_INSTANCE_ID&#38656;&#35201;&#25918;&#32622;&#22312;VFACE&#21069;&#38754;</span>
<span style="color: #bc6ec5;">#if</span> defined(SHADER_STAGE_FRAGMENT)
    <span style="color: #ce537a; font-weight: bold;">fixed</span> vFace : <span style="color: #a45bad;">VFACE</span>;
<span style="color: #bc6ec5;">#endif</span>
};
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org9f384a5"></a>参考资料<br />
<div class="outline-text-7" id="text-org9f384a5">
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org537ff11" class="outline-6">
<h6 id="org537ff11">Shader Commands</h6>
<div class="outline-text-6" id="text-org537ff11">
</div>
<ul class="org-ul">
<li><a id="orgeae6e9d"></a>AlphaToMask<br />
<div class="outline-text-7" id="text-orgeae6e9d">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/SL-AlphaToMask.html">https://docs.unity3d.com/Manual/SL-AlphaToMask.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6f8c1ba" class="outline-6">
<h6 id="org6f8c1ba">Unity 定义的变量</h6>
<div class="outline-text-6" id="text-org6f8c1ba">
<p>
_WorldSpaceLightPos0      世界空间 Light 位置<br />
_LightColor0              Light 颜色<br />
_WorldSpaceCameraPos      世界坐标摄像机位置<br />
_LightTexture0            Light 没有使用 Cookie 时，该变量存储衰减贴图。使用了 Cookie 时，存储 Cookie 贴图。 (Directional Light 没有衰减贴图)<br />
_LightTextureB0           Light 使用了 Cookie 时，该变量存储衰减贴图。 (Directional Light 没有衰减贴图)<br />
</p>

<p>
unity_WorldToShadow       float4x4[4]	用于 spot lights 或 方向光的 4 级级联阴影<br />
</p>

<p>
_LightShadowData          // 参考有道笔记 UnitySourceCode.md<br />
</p>

<p>
_ProjectionParams         <i>/ x=1 or -1  y=near z=far w=1/far<br />
_ScreenParams             /</i> x=widthPixels y=heightPixels z=1.0+1.0/width w=1.0+1.0/height<br />
_ZBufferParams 						<i>/ 用于线性化 ZBuffer 中的值，<br />
                          /</i> x=1-far/near<br />
                          <i>/ y=far/near<br />
                          /</i> z=x/far=(1-far/near)/far=(near-far)/(near*far)<br />
                          // w=y/far=(1/near)<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">zc0</span>, <span style="color: #7590db;">zc1</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL would be this:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc0 = (1.0 - m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc1 = (1.0 + m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">D3D is this:</span>
zc0 = 1.0 - m_FarClip / m_NearClip;
zc1 = m_FarClip / m_NearClip;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now set _ZBufferParams with (zc0, zc1, zc0/m_FarClip, zc1/m_FarClip);</span>
</pre>
</div>

<p>
unity_SpecCube0_ProbePosition   第一个反射探针的位置，如果场景中不存在反射探针，则默认传递环境反射(Lighting / Environment Reflections / Source 下可以设置环境反射)的数据，环境反射。<br />
unity_SpecCube0_BoxMin          第一个反射探针对应的 Box 在世界空间中坐标最小值，反射探针为环境反射时，该值为 (Infinity, Infinity, Infinity, 1)<br />
unity_SpecCube0_BoxMax          第一个反射探针对应的 Box 在世界空间中坐标最大值，反射探针为环境反射时，该值为 (-Infinity, -Infinity, -Infinity, 1)<br />
unity_SpecCube0_BoxMin.w        存储了第一个反射探针和第二个反射探针的插值比例，1 表示全部使用第一个反射探针，0 表示全部使用第二个反射探针.(只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合)<br />
unity_SpecCube0_HDR.r           存储了反射探针的强度，对应反射探针的 Runtime setting/Intensity 和 Lighting/Scene/EnvironmentReflections/IntensityMultiplier(IntensityMultiplier 只是 Intensity 的系数，所以 FrameDebug 中看到的值和该值并不同)<br />
</p>


<div id="org9fde958" class="figure">
<p><img src="./UnityCatLikeCoding/01_08re_default_env_reflection_data.png" alt="01_08re_default_env_reflection_data.png" /><br />
</p>
</div>


<p>
<a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a><br />
</p>
<ul class="org-ul">
<li>_ZBufferParams values? <a href="https://forum.unity.com/threads/_zbufferparams-values.39332/">https://forum.unity.com/threads/_zbufferparams-values.39332/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org48e6e7b" class="outline-6">
<h6 id="org48e6e7b">Unity Shader 定义的宏</h6>
<div class="outline-text-6" id="text-org48e6e7b">
<p>
shader 各个阶段对应的预处理器宏<br />
SHADER_STAGE_VERTEX<br />
SHADER_STAGE_FRAGMENT<br />
SHADER_STAGE_DOMAIN<br />
SHADER_STAGE_HULL<br />
SHADER_STAGE_GEOMETRY<br />
SHADER_STAGE_COMPUTE<br />
</p>

<p>
UNITY_COMPILER_HLSL                            使用 HLSL 编译时，定义该宏(for D3D or GLCore/GLES3/GLES platforms)<br />
UNITY_COMPILER_HLSL2GLSL                       使用 hlsl2glsl 编译时，定义该宏<br />
UNITY_COMPILER_CG                              使用 NVIDIA 的 Cg<br />
</p>

<p>
<a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a><br />
<a href="https://docs.unity3d.com/Manual/SL-ShadingLanguage.html">https://docs.unity3d.com/Manual/SL-ShadingLanguage.html</a><br />
</p>

<p>
UNITY_ENABLE_REFLECTION_BUFFERS                TODO-How?  延迟渲染模式下，延迟渲染反射球时会设置该变量开启。延迟渲染模式下，默认该变量是开启的，在 Graphics Settings 中将 DeferredReflections 选项选为 NoSupport 即可关闭。<br />
<a href="https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html">https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html</a><br />
</p>

<p>
UNITY_USE_NATIVE_HDR                           查看 2019 版本的源代码发现相关代码被注释掉了，UNITY_USE_NATIVE_HDR 应该永远都不会被开启<br />
</p>
<ul class="org-ul">
<li>UNITY_USE_NATIVE_HDR <a href="https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6">https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org675b1a1" class="outline-6">
<h6 id="org675b1a1">Unity Shader Compiler</h6>
<div class="outline-text-6" id="text-org675b1a1">
<ul class="org-ul">
<li>Windows &amp; Microsoft platforms (DX11, DX12 and Xbox One) all use Microsoft’s HLSL compiler (currently d3dcompiler_47).<br /></li>
<li>OpenGL Core , OpenGL ES 3, OpenGL ES 2.0 and Metal use Microsoft’s HLSL followed by bytecode translation into GLSL or Metal, using HLSLcc.<br /></li>
<li>OpenGL ES 2.0 can use source level translation via hlsl2glslfork and glsl optimizer. This is enabled by adding #pragma prefer_hlsl2glsl gles<br /></li>
<li>Other console platforms use their respective compilers (e.g. PSSL on PS4).<br /></li>
<li>Surface Shaders use Cg 2.2 and MojoShader for code generation analysis step.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8cf6263" class="outline-6">
<h6 id="org8cf6263">Unity shader 预编译命令</h6>
<div class="outline-text-6" id="text-org8cf6263">
<div class="org-src-container">
<pre class="src src-shader">multi_compile_local   <span style="color: #2aa1ae; background-color: #292e34;">// &#20026;&#26412;&#22320;&#21464;&#20307;&#65292;&#21482;&#21457;&#29983;&#22312;&#26412;Shader&#65292;&#38750;&#20840;&#23616;&#25511;&#21046;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org81ce66d" class="outline-6">
<h6 id="org81ce66d">Shader 汇编指令</h6>
<div class="outline-text-6" id="text-org81ce66d">
</div>
<ul class="org-ul">
<li><a id="org8c0419f"></a>D3D11 汇编指令<br />
<div class="outline-text-7" id="text-org8c0419f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mul result opt1 opt2</td>
<td class="org-left">opt1 乘 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">add result opt1 opt2</td>
<td class="org-left">opt1 加 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mad result opt1 opt2 opt3</td>
<td class="org-left">opt1 乘 opt2 再加 opt3 保存结果到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mov result opt1</td>
<td class="org-left">将 opt1 数据保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_sampler s0, mode_default</td>
<td class="org-left">创建贴图采样对象 s0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_resource_texture2d(float,float,float,float) t0</td>
<td class="org-left">创建 2D 贴图资源 t0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sample result.xyzw, uv.xyxx, t0.xyzw, s0</td>
<td class="org-left">使用 s0 采样器以 uv 为贴图坐标，对贴图资源 t0 进行采样将结果保存到 result 中</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org6cdb05a"></a>Misc<br />
<div class="outline-text-7" id="text-org6cdb05a">
<p>
rcp 求倒数<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5039137" class="outline-6">
<h6 id="org5039137">GPU 性能</h6>
<div class="outline-text-6" id="text-org5039137">
<ul class="org-ul">
<li>GPU GFLOPS <a href="https://gflops.surge.sh/">https://gflops.surge.sh/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org946d4a5" class="outline-5">
<h5 id="org946d4a5">Combining Textures</h5>
<div class="outline-text-5" id="text-org946d4a5">
</div>
<div id="outline-container-orge6f6450" class="outline-6">
<h6 id="orge6f6450">Linear Color Space</h6>
<div class="outline-text-6" id="text-orge6f6450">
</div>
<ul class="org-ul">
<li><a id="org9463740"></a>Linear Color Space 原理<br />
<div class="outline-text-7" id="text-org9463740">
<p>
Gamma space 是指经过 gamma 矫正的颜色。gamma 矫正是对光照亮度的调整。最简单的方式是提升原始值某次幂，如 \(originalValue^{gamma}\) 。<br />
gamma=1 表示没有改变。gamma=2 表示对原始值求平方。<br />
</p>

<p>
这种转换原本是为了适应非线性的 CRT 显示器的。一个附加的好处是这种转换刚好和我们眼睛对不同光强度的敏感程度相一致。人眼对不同的暗的颜色要比不同的亮的颜色更加敏感。所以使用更多位数字存储暗颜色是很有意义的，求幂运算可以实现该需求，它会将比较小的值扩展到一个更大的范围，同时将较大的值压缩到一个小的范围。<br />
</p>

<p>
运用最广泛的图片颜色格式是 sRGB.<br />
</p>
<ul class="org-ul">
<li>Encoding with gamma 1/2.2 即 \(originalValue^{\frac{1}{2.2}} = originalValue^{0.45}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear-to-gamma.png" alt="01_03ct_linear-to-gamma.png" /><br /></li>
<li>Decoding with gamma 2.2 即 \(originalValue^{2.2}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma-to-linear.png" alt="01_03ct_gamma-to-linear.png" /><br /></li>
<li>伽马矫正函数图示<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_correct.png" alt="01_03ct_gamma_correct.png" /><br /></li>
</ul>

<p>
横坐标为编码前的颜色值，纵坐标为编码后的颜色值。蓝色的线表示线性编码前后颜色值不变。红色的线表示 Gamma 编码前后颜色值变大。以 0.5 为分界线，Gamma 编码后，[0-0.5] 被扩展到了 [0-0.7297&#x2026;] [0.5-1] 被压缩到了 [0.7297&#x2026; - 1]。Gamma 编码的图片要比 Linear 编码的图片亮度高。<br />
</p>

<p>
下面的 HTML 可用于 GammaToLinear 转换<br />
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #4f97d7; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
    &lt;<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;<span style="font-weight: bold; font-style: italic; text-decoration: underline;">&#39068;&#33394;&#36716;&#25442;</span>&lt;/<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"originColor"</span>&gt;
            TD &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oR"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oG"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oB"</span> value =<span style="color: #2d9574;">"64"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"newColor"</span>&gt;
            Qin &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nR"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nG"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nB"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">button</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"button"</span> <span style="color: #7590db;">onclick</span>=<span style="color: #2d9574;">'convertColor()'</span>&gt;&#36716;&#25442;&lt;/<span style="color: #bc6ec5; font-weight: bold;">button</span>&gt;
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

    &lt;<span style="color: #bc6ec5; font-weight: bold;">script</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text/javascript"</span>&gt;
     function convertColor()
     {
         var r = document.getElementById("oR").value / 255;
         var g = document.getElementById("oG").value / 255;
         var b = document.getElementById("oB").value / 255;

         //window.alert("test = " + r + b + g);
         document.getElementById("nR").value = Math.round(Math.pow(r, 1/2.2) * 255);
         document.getElementById("nG").value = Math.round(Math.pow(g, 1/2.2) * 255);
         document.getElementById("nB").value = Math.round(Math.pow(b, 1/2.2) * 255);
     }
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">script</span>&gt;

&lt;/<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// GammaToLinearSpace(col.rgb);  &#19979;&#38754;&#20195;&#30721;&#26159; GammaToLinearSpace &#30340;&#27719;&#32534;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat1.xyz = u_xlat0.xyz * u_xlat1.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}

<span style="color: #2aa1ae; background-color: #292e34;">// LinearToGammaSpace(col.rgb); &#19979;&#38754;&#20195;&#30721;&#26159; LinearToGammaSpace &#30340;&#27719;&#32534;&#20195;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat16_1.xyz = <span style="color: #4f97d7;">max</span>(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat16_2.xyz = <span style="color: #4f97d7;">log2</span>(u_xlat16_1.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat16_2.xyz = <span style="color: #4f97d7;">exp2</span>(u_xlat16_2.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = <span style="color: #4f97d7;">max</span>(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#26159; &#22270;&#29255;Gamma&#21644;Linear&#36716;&#25442;&#24037;&#20855;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">System</span>.<span style="color: #7590db;">Collections</span>.<span style="color: #7590db;">Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #7590db;">UnityEditor</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">LinearGammaConvert</span> : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">_assetPathList</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt;();
    [<span style="color: #bc6ec5; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageLinearToGamma"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">LinearToGamma</span>()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(path, <span style="color: #a45bad;">true</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }

    [<span style="color: #bc6ec5; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageGammaToLinear"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GammaToLinear</span>()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(path, <span style="color: #a45bad;">false</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(<span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">pathList</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(Selection.objects!=<span style="color: #a45bad;">null</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">obj</span> <span style="color: #4f97d7; font-weight: bold;">in</span> Selection.objects)
            {
                <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">GetAssetPath</span>(obj);
                <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span><span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(path))
                {
                    pathList.<span style="color: #bc6ec5; font-weight: bold;">Add</span>(path);
                }
            }
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">imgPath</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isToGamma</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(imgPath)) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">textureImportor</span> = AssetImporter.<span style="color: #bc6ec5; font-weight: bold;">GetAtPath</span>(imgPath) <span style="color: #4f97d7; font-weight: bold;">as</span> TextureImporter;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (textureImportor == <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        textureImportor.isReadable = <span style="color: #a45bad;">true</span>;
        textureImportor.sRGBTexture = <span style="color: #a45bad;">!</span>isToGamma;
        textureImportor.textureCompression = TextureImporterCompression.Uncompressed;
        textureImportor.<span style="color: #bc6ec5; font-weight: bold;">SaveAndReimport</span>();

        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">texture</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">LoadAssetAtPath</span>&lt;<span style="color: #ce537a; font-weight: bold;">Texture2D</span>&gt;(imgPath);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">gammaValue</span> = isToGamma ? 0.4545f : 2.2f;
        <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">pixels</span> = texture.<span style="color: #bc6ec5; font-weight: bold;">GetPixels</span>();
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">i</span>=0; i&lt;pixels.Length; i++)
        {

            pixels[i].r = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].r, gammaValue);
            pixels[i].g = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].g, gammaValue);
            pixels[i].b = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].b, gammaValue);
        }
        texture.<span style="color: #bc6ec5; font-weight: bold;">SetPixels</span>(pixels);
        texture.<span style="color: #bc6ec5; font-weight: bold;">Apply</span>();
        System.IO.File.<span style="color: #bc6ec5; font-weight: bold;">WriteAllBytes</span>(imgPath, texture.<span style="color: #bc6ec5; font-weight: bold;">EncodeToTGA</span>());
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org8815afa"></a>DetailTex 叠加到 MainTex 上为什么需要乘二？<br />
<div class="outline-text-7" id="text-org8815afa">
<p>
MainTex 颜色范围为[0-1] DetailTex 颜色范围也为[0-1], 如果将 DetailTex 制作为灰度图并且颜色值取 0.5，那么 MainTex*DetailTex*2 可以保证图片亮度不会变化。DetailTex 颜色值小于 0.5 的地方就会减低颜色亮度，大于 0.5 的地方就会提高颜色亮度。<br />
但是，当 Unity 引擎切换到线性空间，乘二是不正确的。DetailTex 转化为线性空间时，0.5 的 DetailTex 颜色值会变为 \(0.5^{2.2}=0.2176\) ,乘二后为 0.4352, 所以颜色亮度会减低。最好的解决方案是当 Unity 引擎切换到线性空间时，应该乘 \(frac{1}{0.5^{2.2}}=frac{1}{0.2176}=4.5956\)<br />
Unity 中 unity_ColorSpaceDouble 用来处理不同的颜色空间乘不同的值。<br />
</p>
</div>
</li>
<li><a id="org2a11f38"></a>SetVector SetColor<br />
<div class="outline-text-7" id="text-org2a11f38">
<p>
GammaSpace 下，SetVector SetColor 效果没有差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_SetValue.png" alt="01_03ct_gamma_SetValue.png" /><br />
LinearSpace 下，SetVector SetColor 效果会有明显差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear_SetValue.png" alt="01_03ct_linear_SetValue.png" /><br />
</p>

<p>
编辑器中设置的值和 Shader Property List 中设置的值是相同的。<br />
线性空间下，通过 SetColor 传入的值被认为是经过 Gamma=1/2.2=0.4545 编码的值，Unity 引擎会对该值进行 Gamma=2.2 的编码(对 Gamma=1/2.2 进行解码)，从而将 Gamma 空间的值转换为线性空间。所以，SetVector(0.5^2.2, 0, 0, 0) 和 SetColor(0.5, 0, 0, 0)的效果是等价的。<br />
</p>

<ul class="org-ul">
<li>官网文档说明 <a href="https://docs.unity3d.com/ScriptReference/Material.SetVector.html">https://docs.unity3d.com/ScriptReference/Material.SetVector.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgd8272ff"></a>参考资料<br />
<div class="outline-text-7" id="text-orgd8272ff">
<ul class="org-ul">
<li>Gamma 空间是什么，为什么我们需要它 <a href="https://blog.csdn.net/qq_18229381/article/details/78053018">https://blog.csdn.net/qq_18229381/article/details/78053018</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga8714de" class="outline-5">
<h5 id="orga8714de">The First Light</h5>
<div class="outline-text-5" id="text-orga8714de">
</div>
<div id="outline-container-org104239b" class="outline-6">
<h6 id="org104239b">normal 从物体空间到世界空间的变换</h6>
<div class="outline-text-6" id="text-org104239b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// obj to world</span>
i.normal = <span style="color: #4f97d7;">mul</span>(<span style="color: #4f97d7;">transpose</span>((<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject), v.normal);

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float3</span> UnityObjectToWorldNormal( <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float3</span> norm )
{
<span style="color: #bc6ec5;">#ifdef</span> UNITY_ASSUME_UNIFORM_SCALING
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToWorldDir</span>(norm);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &#25913;&#21464;&#24038;&#20056; &#21491;&#20056;&#39034;&#24207; &#31561;&#20215;&#20110; &#30697;&#38453;&#36716;&#32622;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// mul(IT_M, norm) =&gt; mul(norm, I_M) =&gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)}</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(<span style="color: #4f97d7;">mul</span>(norm, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject));
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcdc82af" class="outline-6">
<h6 id="orgcdc82af">Tags LightMode=ForwardBase</h6>
<div class="outline-text-6" id="text-orgcdc82af">
<p>
定义该 Tags 才可以在 shader 中访问场景中主方向光的信息。<br />
</p>
</div>
</div>

<div id="outline-container-org10910ec" class="outline-6">
<h6 id="org10910ec">BlinnPhong</h6>
<div class="outline-text-6" id="text-org10910ec">
<p>
视角不逆光时的显示效果如下：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone.png" alt="01_04fl_blinnphone.png" /><br />
</p>

<p>
视角逆光时会有显示错误。错误如下图：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone_error.png" alt="01_04fl_blinnphone_error.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgaf6736a" class="outline-6">
<h6 id="orgaf6736a">Energy Conservation</h6>
<div class="outline-text-6" id="text-orgaf6736a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Unity &#23454;&#29616;&#30340;&#33021;&#37327;&#23432;&#24658; UnityStandardUtils.cginc</span>

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2a71f11" class="outline-6">
<h6 id="org2a71f11">Specular / Metallic Workflow</h6>
<div class="outline-text-6" id="text-org2a71f11">
</div>
<ul class="org-ul">
<li><a id="org73f25dd"></a>Specular Workflow<br />
<div class="outline-text-7" id="text-org73f25dd">
<p>
Specular Workflow 中将 Specular Color 的强度提高来实现金属材质。将 Specular Color 的强度减弱来实现非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#40664;&#35748;&#26159; Specular Workflow</span>
<span style="color: #bc6ec5;">#ifndef</span> UNITY_SETUP_BRDF_INPUT
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT SpecularSetup
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData SpecularSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> specGloss = SpecularGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor = specGloss.rgb;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = specGloss.a;

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = EnergyConservationBetweenDiffuseAndSpecular (Albedo(i_tex), specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #2aa1ae; background-color: #292e34;">// Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524; specColor &#19981;&#26159;&#28784;&#24230;&#22270;&#65292;diffuse &#39068;&#33394;&#20250;&#26174;&#31034;&#24322;&#24120;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org57ec7ef"></a>Metallic Workflow<br />
<div class="outline-text-7" id="text-org57ec7ef">
<p>
Metallic Workflow 中通过金属度来实现金属和非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#33258;&#24049;&#30340; shader &#20013;&#23450;&#20041; UNITY_SETUP_BRDF_INPUT = MetallicSetup &#26469;&#25351;&#23450;&#20351;&#29992; Metallic &#27969;&#31243;</span>
<span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT MetallicSetup
<span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData MetallicSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half2</span> metallicGloss = MetallicGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half</span> metallic = metallicGloss.x;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = metallicGloss.y; <span style="color: #2aa1ae; background-color: #292e34;">// this is 1 minus the square root of real roughness m.</span>

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = DiffuseAndSpecularFromMetallic (Albedo(i_tex), metallic, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DiffuseAndSpecularFromMetallic (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half</span> metallic, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    specColor = <span style="color: #4f97d7;">lerp</span> (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);
    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
}

<span style="color: #2aa1ae; background-color: #292e34;">// &#24120;&#37327;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.5, 0.5, 0.5, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(2.0, 2.0, 2.0, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.22, 0.707, 0.071, 0.0) <span style="color: #2aa1ae; background-color: #292e34;">// Legacy: alpha is set to 0.0 to specify gamma mode</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">// Linear values</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.214041144, 0.214041144, 0.214041144, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(4.59479380, 4.59479380, 4.59479380, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.04, 0.04, 0.04, 1.0 - 0.04) <span style="color: #2aa1ae; background-color: #292e34;">// standard dielectric reflectivity coef at incident angle (= 4%)</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.0396819152, 0.458021790, 0.00609653955, 1.0) <span style="color: #2aa1ae; background-color: #292e34;">// Legacy: alpha is set to 1.0 to specify linear mode</span>
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> OneMinusReflectivityFromMetallic(<span style="color: #ce537a; font-weight: bold;">half</span> metallic)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// We'll need oneMinusReflectivity, so</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// store (1-dielectricSpec) in unity_ColorSpaceDielectricSpec.a, then</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//                  = alpha - metallic * alpha</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusDielectricSpec = unity_ColorSpaceDielectricSpec.a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga185b3d" class="outline-5">
<h5 id="orga185b3d">Multi Lights</h5>
<div class="outline-text-5" id="text-orga185b3d">
</div>
<div id="outline-container-org2db7837" class="outline-6">
<h6 id="org2db7837">Light Coord</h6>
<div class="outline-text-6" id="text-org2db7837">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord4 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex));
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    ( (a.<span style="color: #7590db;">_LightCoord</span>.z &gt; 0) * UnitySpotCookie(a.<span style="color: #7590db;">_LightCoord</span>) * UnitySpotAttenuate(a.<span style="color: #7590db;">_LightCoord</span>.xyz) * SHADOW_ATTENUATION(a) )
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx)
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a)
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a)
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord2 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xy;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#define</span> UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2)
<span style="color: #bc6ec5;">#define</span> LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2)
<span style="color: #2aa1ae; background-color: #292e34;">// vertex shader &#20013;&#65292;&#35745;&#31639;_LightCoord</span>
<span style="color: #bc6ec5;">#define</span> UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord)
<span style="color: #bc6ec5;">#define</span> TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org7f1eb6c" class="outline-6">
<h6 id="org7f1eb6c">Light Attenuation</h6>
<div class="outline-text-6" id="text-org7f1eb6c">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #ifdef</span> POINT
  <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
  unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
      unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
            <span style="color: #2aa1ae; background-color: #292e34;">// &#25353;&#29031;&#36317;&#31163;&#30340;&#24179;&#26041;&#34928;&#20943;</span>
      <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> SPOT
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
      unityShadowCoord4x4 unity_WorldToLight;
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotCookie(unityShadowCoord4 LightCoord)
      {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679;&#26102;&#20174;&#40784;&#27425;&#22352;&#26631;&#31995;&#36716;&#25442;&#21040;&#27431;&#25289;&#22352;&#26631;&#31995;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20559;&#31227; 0.5 &#36825;&#26679;&#28783;&#20809;&#22352;&#26631;&#31995;&#21407;&#28857;&#23601;&#21644;&#22270;&#29255;&#20013;&#24515;&#28857;&#23545;&#24212;&#20102;</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, LightCoord.xy / LightCoord.w + 0.5).w;
      }
      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotAttenuate(unityShadowCoord3 LightCoord)
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(LightCoord, LightCoord).xx).r;
      }
<span style="color: #bc6ec5;">      #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1))
<span style="color: #bc6ec5;">      #else</span>
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
          DECLARE_LIGHT_COORD(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = (lightCoord.z &gt; 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = UNITY_SHADOW_ATTENUATION(input, worldPos);
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> POINT_COOKIE
      <span style="color: #ce537a; font-weight: bold;">samplerCUBE_float</span> <span style="color: #7590db;">_LightTexture0</span>;
      unityShadowCoord4x4 unity_WorldToLight;
      <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
<span style="color: #bc6ec5;">      #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz
<span style="color: #bc6ec5;">      #else</span>
<span style="color: #bc6ec5;">          #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">      #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
          DECLARE_LIGHT_COORD(input, worldPos); \
          <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
          <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #ifdef</span> DIRECTIONAL_COOKIE
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xy
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org043af65"></a>Point Light<br />
<div class="outline-text-7" id="text-org043af65">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> lightVector = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz - i.worldPos;
light.dir = <span style="color: #4f97d7;">normalize</span>(lightVector);
<span style="color: #2aa1ae; background-color: #292e34;">// &#20998;&#27597;&#20013;&#21152; 1 &#26159;&#20026;&#20102;&#36991;&#20813;&#29289;&#20307;&#21040;&#20809;&#28304;&#36317;&#31163;&#23567;&#20110; 1 &#26102;&#65292;&#20809;&#29031;&#24378;&#24230;&#34987;&#25918;&#22823;</span>
<span style="color: #ce537a; font-weight: bold;">half</span> attenuation = 1 / (1 + <span style="color: #4f97d7;">dot</span>(lightVector, lightVector));
light.color = <span style="color: #7590db;">_LightColor0</span>.rgb * attenuation;
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgca20662" class="outline-6">
<h6 id="orgca20662">Mixing Lights</h6>
<div class="outline-text-6" id="text-orgca20662">
<p>
通过增加 shader 变体来实现对混合灯光的支持。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT
</pre>
</div>
</div>
</div>
<div id="outline-container-orge8649f1" class="outline-6">
<h6 id="orge8649f1">Cookies</h6>
<div class="outline-text-6" id="text-orge8649f1">
<p>
Spot Light 默认支持 Cookie，Spot Light 的形状是通过 Cookie 来实现。SpotLight 的 Cookie 贴图的 Wrap 模式采用 Clamp。<br />
Direcional 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图的 Wrap 模式采用 Repeat。<br />
Point 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图是 Cube 贴图，Wrap 模式采用 Clamp。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#31561;&#20215;&#20110;  #pragma multi_compile_fwdadd</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT DIRECTIONAL_COOKIE POINT_COOKIE
</pre>
</div>

<ul class="org-ul">
<li>multi_compile_fwdbase 变体 <a href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org184e266" class="outline-6">
<h6 id="org184e266">Vertex Lights</h6>
<div class="outline-text-6" id="text-org184e266">
<p>
灯光数量增加后，drawcall 数量会成倍增加。Unity 可以设置逐像素光照的数量。如果将超出数量限制的光照直接不进行计算，会导致明显的显示错误，可以采用更廉价的顶点光照来代替像素光照。<br />
Unity 在 Base Pass 中实现顶点光照。引擎会寻找包含 VERTEXLIGHT_ON 关键字的 Base Pass 着色器。<br />
顶点光照只支持 点光源，方向光和聚光灯都能在顶点着色器中计算。<br />
在 Light 的 RenderMode 属性中，可以设置重要类型，Important 类型的光照总是逐像素光照，Not Important 类型的光照永远不会被当作逐像素光照，Auto 类型的光照其重要性由引擎来决定。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// UnityCG.cginc</span>
<span style="color: #2aa1ae; background-color: #292e34;">// &#35813;&#20989;&#25968;&#36820;&#22238;&#20102;4&#20010;&#28857;&#20809;&#28304;&#23545;&#20110;&#24403;&#21069;&#39030;&#28857;&#30340;&#32508;&#21512;&#20809;&#29031;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#39030;&#28857;&#20013;&#35745;&#31639; 4 &#20010;&#28857;&#20809;&#28304;&#20809;&#29031;&#65292;&#24403;&#20809;&#28304;&#25968;&#30446;&#19981;&#36275; 4 &#20010;&#26102;&#65292;&#35745;&#31639;&#28040;&#32791;&#20381;&#28982;&#26159; 4 &#20010;&#20809;&#29031;&#30340;&#35745;&#31639;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way.</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">Shade4PointLights</span> (
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosX, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosY, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosZ,
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor0, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor1, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor2, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor3,
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightAttenSq,
    <span style="color: #ce537a; font-weight: bold;">float3</span> pos, <span style="color: #ce537a; font-weight: bold;">float3</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// to light vectors</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightX = lightPosX - pos.x;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightY = lightPosY - pos.y;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightZ = lightPosZ - pos.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// squared lengths</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> lengthSq = 0;
    lengthSq += toLightX * toLightX;
    lengthSq += toLightY * toLightY;
    lengthSq += toLightZ * toLightZ;
    <span style="color: #2aa1ae; background-color: #292e34;">// don't produce NaNs if some vertex position overlaps with the light</span>
    lengthSq = <span style="color: #4f97d7;">max</span>(lengthSq, 0.000001);

    <span style="color: #2aa1ae; background-color: #292e34;">// NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> ndotl = 0;
    ndotl += toLightX * normal.x;
    ndotl += toLightY * normal.y;
    ndotl += toLightZ * normal.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// correct NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> corr = <span style="color: #4f97d7;">rsqrt</span>(lengthSq);
    ndotl = <span style="color: #4f97d7;">max</span> (<span style="color: #ce537a; font-weight: bold;">float4</span>(0,0,0,0), ndotl * corr);
    <span style="color: #2aa1ae; background-color: #292e34;">// attenuation lightAttenSq &#29992;&#20110;&#25913;&#36827;&#39030;&#28857;&#20809;&#29031;&#30340;&#25928;&#26524;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
    <span style="color: #ce537a; font-weight: bold;">float4</span> diff = ndotl * atten;
    <span style="color: #2aa1ae; background-color: #292e34;">// final color</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> col = 0;
    col += lightColor0 * diff.x;
    col += lightColor1 * diff.y;
    col += lightColor2 * diff.z;
    col += lightColor3 * diff.w;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1fe776f" class="outline-6">
<h6 id="org1fe776f">Spherical Harmonics</h6>
<div class="outline-text-6" id="text-org1fe776f">
</div>
<ul class="org-ul">
<li><a id="org8455aa8"></a>原理概述<br />
<div class="outline-text-7" id="text-org8455aa8">
<p>
球谐函数背后的思想是你可以只用一个连续函数来描述所有入射光在某个点的效果，这个函数定义在球的表面。<br />
通常来说，这个函数是用球面坐标表示的。但是也可以使用 3D 坐标，这样我们就可以使用物体的 normal 向量对函数进行采样了。<br />
为了创建这样的函数，你必须在所有方向上对光照强度进行采样，然后将结果转换为单个连续的函数。为了达到完美模拟，你必须为表面的每个点做这样的工作。这当然是无法做到的，所以我们只能做到近似效果。<br />
</p>

<p>
首先，我们只从对象本地原点的角度定义函数。光照条件在随物体表面变化不大时效果还是可以的。小物体，或者光照比较弱或光照离物体很远时满足这种情况。幸运的是，这恰好是那些不值得逐像素计算的光照或者顶点光照。<br />
其次，我们必须近似函数自身。你可以将任何连续的函数分解为多个不同频率的函数。这些被称为波段。对于任意一个函数，你可能需要无数个波段来模拟。<br />
</p>

<p>
<a href="../graphics/PhysicallyBasedRendering.html#org3b0f065">球谐函数</a><br />
</p>
</div>
</li>
<li><a id="orgee3e0a7"></a>Spherical Harmonics Bands<br />
<div class="outline-text-7" id="text-orgee3e0a7">
<p>
第一个基带：使用一个常量颜色值是最简单近似灯光的方式。光照在各个方向上都是相同的。使用单个子函数表示，这个子函数为一个常量值。<br />
第二个基带：第二个基带引入了线性方向光，对于每一个轴向，其描述了最多的光照来自哪儿。使用三个函数表示，每个函数包含一个我们法线的坐标值，并乘上一个常量。<br />
第三个基带：第三个基带更加复杂，它有 5 个函数组成。这些函数都是二次方的，他们包含了两个法线坐标的乘积。<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">l band NO</th>
<th scope="col" class="org-right">sub func count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
下表为最大阶数 n 下，对应所有基带的子函数的个数<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">n^2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">1=1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">1+3=4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">1+3+5=9</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">1+3+5+7=16</td>
</tr>
</tbody>
</table>

<p>
下图列出了各个基带的子函数，每一项都需要再乘上 \(\frac{1}{2\sqrt{\pi}}\)<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_param.png" alt="01_05ml_sh_param.png" /><br />
</p>

<p>
完整的归一化之后的(复)球谐函数如下：<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_base_func.jpg" alt="01_05ml_sh_base_func.jpg" /><br />
</p>

<p>
因此我们可以使用 9 个因子来近似表示任何一种光照情况，考虑到颜色有 RGB 三个分量，一共需要使用 3*9=27 个因子。<br />
</p>

<p>
下图为 unity 中传递给 shader 的球谐数据:<br />
</p>
<ul class="org-ul">
<li>unity_SHAr.rgba 存储了光照 r 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBr.rgba + unitySHC.r 存储了光照 r 分量的第 2 个基带的参数因子<br /></li>
<li>unity_SHAg.rgba 存储了光照 g 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBg.rgba + unitySHC.g 存储了光照 g 分量的第 2 个基带的参数因子<br /></li>
<li>unity_SHAb.rgba 存储了光照 b 分量的第 1 个基带和第 0 个基带的参数因子，unity_SHBb.rgba + unitySHC.b 存储了光照 b 分量的第 2 个基带的参数因子<br /></li>
</ul>


<div id="org15cab3c" class="figure">
<p><img src="./UnityCatLikeCoding/01_05ml_unity_sh_param.png" alt="01_05ml_unity_sh_param.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgf175323"></a>ShadeSH9<br />
<div class="outline-text-7" id="text-orgf175323">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL0L1</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x;

    <span style="color: #2aa1ae; background-color: #292e34;">// Linear (L1) + constant (L0) polynomial terms</span>
    x.r = <span style="color: #4f97d7;">dot</span>(unity_SHAr,normal);
    x.g = <span style="color: #4f97d7;">dot</span>(unity_SHAg,normal);
    x.b = <span style="color: #4f97d7;">dot</span>(unity_SHAb,normal);

    <span style="color: #4f97d7; font-weight: bold;">return</span> x;
}

<span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL2</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x1, x2;
    <span style="color: #2aa1ae; background-color: #292e34;">// 4 of the quadratic (L2) polynomials</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> vB = normal.xyzz * normal.yzzx;
    x1.r = <span style="color: #4f97d7;">dot</span>(unity_SHBr,vB);
    x1.g = <span style="color: #4f97d7;">dot</span>(unity_SHBg,vB);
    x1.b = <span style="color: #4f97d7;">dot</span>(unity_SHBb,vB);

    <span style="color: #2aa1ae; background-color: #292e34;">// Final (5th) quadratic (L2) polynomial</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> vC = normal.x*normal.x - normal.y*normal.y;
    x2 = unity_SHC.rgb * vC;

    <span style="color: #4f97d7; font-weight: bold;">return</span> x1 + x2;
}

<span style="color: #2aa1ae; background-color: #292e34;">// normal should be normalized, w=1.0</span>
<span style="color: #2aa1ae; background-color: #292e34;">// output in active color space</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSH9</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Linear + constant polynomial terms</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> res = SHEvalLinearL0L1 (normal);

    <span style="color: #2aa1ae; background-color: #292e34;">// Quadratic polynomials</span>
    res += SHEvalLinearL2 (normal);

<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        res = LinearToGammaSpace (res);
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>
</div>
</li>
<li><a id="org1342fdc"></a>环境光和 LightProbe<br />
<div class="outline-text-7" id="text-org1342fdc">
<p>
环境光和 LightProbe 都使用了球谐光照。在 Unity 中叠加到了间接光照的 diffuse 中。<br />
环境光对应一组球谐系数。每个 LightProbe 也对应存储一组球谐系数。全局照明系统会烘培环境光探针，即使用球谐参数保存环境光参数，但是当几何体使用了光照探针和 Lightmaps 时，并不会应用环境光探针，因为环境光影响在光照探针和 Lightmaps 中已经存在了。只有当不存在光照探针和 Lightmap 时，才会使用环境光探针。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html">https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Should SH (light probe / ambient) calculations be performed?</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#24320;&#21551;&#26102;&#65292;&#19981;&#25191;&#34892;SH&#35745;&#31639;&#12290;When both static and dynamic lightmaps are available, no SH evaluation is performed</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#20851;&#38381;&#26102;&#65292;&#19968;&#23450;&#25191;&#34892;SH&#35745;&#31639;&#12290; When static and dynamic lightmaps are not available, SH evaluation is always performed</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - &#23545;&#20110;&#20302;&#32423;LOD&#65292;&#38745;&#24577;lightmap&#21644;LightProbe&#23454;&#26102;&#20840;&#23616;&#29031;&#26126;&#21487;&#20197;&#21512;&#24182;&#22312;&#19968;&#36215;&#12290; For low level LODs, static lightmap and real-time GI from light probes can be combined together</span>
<span style="color: #2aa1ae; background-color: #292e34;">// - forwardadd,shdowcaster&#31561;Pass&#19981;&#38656;&#35201;&#25191;&#34892;SH&#35745;&#31639;&#12290;Passes that don't do ambient (additive, shadowcaster etc.) should not do SH either.</span>
<span style="color: #bc6ec5;">#define</span> UNITY_SHOULD_SAMPLE_SH (defined(LIGHTPROBE_SH) &amp;&amp; !defined(UNITY_PASS_FORWARDADD) &amp;&amp; !defined(UNITY_PASS_PREPASSBASE) &amp;&amp; !defined(UNITY_PASS_SHADOWCASTER) &amp;&amp; !defined(UNITY_PASS_META))

<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSHPerPixel</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> ambient, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> ambient_contrib = 0.0;

<span style="color: #bc6ec5;">    #if</span> UNITY_SAMPLE_FULL_SH_PER_PIXEL
        <span style="color: #2aa1ae; background-color: #292e34;">// Completely per-pixel</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

            ambient_contrib += SHEvalLinearL2(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));

            ambient += <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient_contrib);

<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace(ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #elif</span> (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE
        <span style="color: #2aa1ae; background-color: #292e34;">// Completely per-vertex</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// nothing to do here. Gamma conversion on ambient from SH takes place in the vertex shader, see ShadeSHPerVertex.</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// L2 per-vertex, L0..L1 &amp; gamma-correction per-pixel</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// Ambient in this case is expected to be always Linear, see ShadeSHPerVertex()</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

        ambient = <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient+ambient_contrib);     <span style="color: #2aa1ae; background-color: #292e34;">// include L2 contribution in vertex shader before clamp.</span>
<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace (ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> ambient;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> UnityGI UnityGI_Base(UnityGIInput data, <span style="color: #ce537a; font-weight: bold;">half</span> occlusion, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
    UnityGI o_gi;
    ResetUnityGI(o_gi);

    <span style="color: #2aa1ae; background-color: #292e34;">// Base pass with Lightmap support is responsible for handling ShadowMask / blending here for performance reason</span>
<span style="color: #bc6ec5;">    #if</span> defined(HANDLE_SHADOWS_BLENDING_IN_GI)
        <span style="color: #ce537a; font-weight: bold;">half</span> bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
        <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - data.worldPos, UNITY_MATRIX_V[2].xyz);
        <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
        data.atten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.light = data.light;
    o_gi.light.color *= data.atten;

    <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;&#35843;&#29992; ShadeSHPerPixel &#26041;&#27861;&#35745;&#31639;&#29615;&#22659;&#20809; /LightProbe&#30340;&#29699;&#35856;&#20809;&#29031;&#65292;&#23558;&#32467;&#26524;&#23384;&#20648;&#21040;indirectLight.diffuse&#20013;</span>
<span style="color: #bc6ec5;">    #if</span> UNITY_SHOULD_SAMPLE_SH
        o_gi.indirect.diffuse = ShadeSHPerPixel(normalWorld, data.ambient, data.worldPos);
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #2aa1ae; background-color: #292e34;">// Baked lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">half4</span> bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);
        <span style="color: #ce537a; font-weight: bold;">half3</span> bakedColor = DecodeLightmap(bakedColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> bakedDirTex = UNITY_SAMPLE_TEX2D_SAMPLER (unity_LightmapInd, unity_Lightmap, data.lightmapUV.xy);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap (o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// not directional lightmap</span>
            o_gi.indirect.diffuse += bakedColor;

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap(o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #ifdef</span> DYNAMICLIGHTMAP_ON
        <span style="color: #2aa1ae; background-color: #292e34;">// Dynamic lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> realtimeColorTex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, data.lightmapUV.zw);
        <span style="color: #ce537a; font-weight: bold;">half3</span> realtimeColor = DecodeRealtimeLightmap (realtimeColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">half4</span> realtimeDirTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap, data.lightmapUV.zw);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (realtimeColor, realtimeDirTex, normalWorld);
<span style="color: #bc6ec5;">        #else</span>
            o_gi.indirect.diffuse += realtimeColor;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.indirect.diffuse *= occlusion;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o_gi;
}

</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org80bd00a" class="outline-5">
<h5 id="org80bd00a">Bumpiness</h5>
<div class="outline-text-5" id="text-org80bd00a">
</div>
<div id="outline-container-org69a5c73" class="outline-6">
<h6 id="org69a5c73">高度图转 normal map 的方法</h6>
<div class="outline-text-6" id="text-org69a5c73">
</div>
<ul class="org-ul">
<li><a id="org79b5768"></a>方案 1<br />
<div class="outline-text-7" id="text-org79b5768">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。求出 u 或 v 方向的 tangent。<br /></li>
<li>将 tangent 绕 z 轴旋转 90 度，就是 normal。<br /></li>
</ol>

<div id="org09e27ec" class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_vector-rotation.png" alt="01_06bu_vector-rotation.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#21033;&#29992; u &#26041;&#21521;&#39640;&#24230;&#21464;&#21270;&#26469;&#27714; normal</span>
<span style="color: #ce537a; font-weight: bold;">float2</span> delta = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> h1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv);
<span style="color: #ce537a; font-weight: bold;">float</span> h2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + delta);

<span style="color: #2aa1ae; background-color: #292e34;">// scale normal with 1/delta.x &#31532;&#19968;&#31181;&#24418;&#24335;&#28040;&#38500;&#20102;&#38500;&#27861;&#65292;&#32780;&#19988;&#25913;&#21892;&#20102;&#31934;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// i.normal = float3(delta.x, h2 - h1, 0); &lt;==&gt; i.normal = float3(1, (h2 - h1)/delta.x, 0);</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(delta.x, h2 - h1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#25442; x &#21644; y &#23558; tangent &#36716;&#21270;&#20026; normal</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, delta.x, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#25918;&#22823;y&#20943;&#24369;normal&#25928;&#26524;</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, 1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// &#20063;&#21487;&#20197;&#21033;&#29992; v &#26041;&#21521;&#39640;&#24230;&#26469;&#21464;&#21270;&#27714; normal.&#23454;&#29616;&#26041;&#27861;&#30456;&#21516;</span>
</pre>
</div>

<p>
下图为使用该方式计算 normal 的效果图<br />
<img src="./UnityCatLikeCoding/20_01_08_HMapTangentAsNormal.png" alt="20_01_08_HMapTangentAsNormal.png" /><br />
</p>
</div>
</li>
<li><a id="org56ba8b7"></a>方案 2<br />
<div class="outline-text-7" id="text-org56ba8b7">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 u/v 方向的 tangent 进行叉乘生成 normal。<br /></li>
</ol>

<p>
下面是向量叉乘公式:<br />
<img src="./UnityCatLikeCoding/20_01_09_vectorCrossProduct.png" alt="20_01_09_vectorCrossProduct.png" /><br />
</p>

<p>
此处 tangent 向量叉乘计算结果为：<br />
</p>
\begin{equation}
  \begin{bmatrix}
  0\\
  {f_v}'\\
  1
  \end{bmatrix} \times
  \begin{bmatrix}
  1\\
  {f_u}'\\
  0
  \end{bmatrix} =
  \begin{bmatrix}
  {f_v}'*0-1*{f_u}'\\
  1*1-0*0 \\
  0*{f_u}'-{f_v}'*1
  \end{bmatrix} =
  \begin{bmatrix}
  -{f_u}'\\
  1 \\
  -{f_v}'
  \end{bmatrix}
\end{equation}

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> du = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x * 0.5, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> u1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - du);
<span style="color: #ce537a; font-weight: bold;">float</span> u2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + du);
<span style="color: #ce537a; font-weight: bold;">float3</span> tu = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, u2 - u1, 0);

<span style="color: #ce537a; font-weight: bold;">float2</span> dv = <span style="color: #ce537a; font-weight: bold;">float2</span>(0, <span style="color: #7590db;">_HeightMap_TexelSize</span>.y * 0.5);
<span style="color: #ce537a; font-weight: bold;">float</span> v1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - dv);
<span style="color: #ce537a; font-weight: bold;">float</span> v2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + dv);
<span style="color: #ce537a; font-weight: bold;">float3</span> tv = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, v2 - v1, 1);

i.normal = <span style="color: #4f97d7;">cross</span>(tv, tu);
i.normal = <span style="color: #4f97d7;">normalize</span>(i.normal);
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org07cc931" class="outline-6">
<h6 id="org07cc931">Normal 向量的插值</h6>
<div class="outline-text-6" id="text-org07cc931">
<p>
Normal 贴图的 Filter，以及顶点的 Normal 向量在传递到片段着色器过程中的插值 都会导致 normal 向量不再是单位向量，所以需要重新单位化。<br />
</p>
</div>
</div>
<div id="outline-container-orgea6e010" class="outline-6">
<h6 id="orgea6e010">Normal 贴图存储惯例</h6>
<div class="outline-text-6" id="text-orgea6e010">
<p>
Normal 贴图通用的惯例是将向上的方向存储到 z 分量.所以，在 shader 中采样出来 normal 向量后需要调换 y 分量和 z 分量。<br />
</p>
</div>
</div>
<div id="outline-container-orga76f4d4" class="outline-6">
<h6 id="orga76f4d4">DXT5nm 存储 normal 贴图</h6>
<div class="outline-text-6" id="text-orga76f4d4">
<p>
其只存储了 normal 的 x，y 分量，丢弃掉了 z 分量。z 分量通过计算得到 \(z=\sqrt{1-x^2-y^2}\) .<br />
x 分量存储在 A 通道，y 分量存储在 G 通道。R 通道和 B 通道没有使用。<br />
DXT5 按照 4x4 个像素为一个块进行压缩。R 占用 5 位，B 占用 5 位，G 占用 6 位，A 占用 8 位。RGB 公用一个查找表，A 单独使用一个查找表。所以将 x 分量存储到 A 通道可以保持 x 分量和 y 分量的独立性。<br />
手机平台不支持 DXT5nm 格式，在手机平台 unity 仍然使用通用的 rgb 进行编码。<br />
</p>
</div>
</div>
<div id="outline-container-org0516c62" class="outline-6">
<h6 id="org0516c62">缩放 Normal</h6>
<div class="outline-text-6" id="text-org0516c62">
<p>
只需要在单位化 normal 前，对 normal 的 x 分量和 z 分量进行缩放，就可以强化和弱化 y 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org6787c5d" class="outline-6">
<h6 id="org6787c5d">Blending Normals</h6>
<div class="outline-text-6" id="text-org6787c5d">
<p>
回顾使用高度图生成 normal 贴图的方法，可以知道，如果希望 normal 效果叠加，其实就是将高度叠加，也就是斜率叠加（斜率为 h/x, 贴图各个地方 x 都相同，因此高度相当于斜率）。<br />
normal 贴图中存储的值为:(s 表示单位化过程中，对各个分量的缩放)<br />
</p>
\begin{bmatrix}
-s{f_u}'\\
-s{f_v}'\\
s \\
\end{bmatrix}
<p>
所以叠加 MainNormalTex 和 DetailNormalTex 的高度后得到的 normal 为<br />
</p>
\begin{bmatrix}
\frac{M_x}{M_z} + \frac{D_x}{D_z} \\
\frac{M_y}{M_z} + \frac{D_y}{D_z} \\
1 \\
\end{bmatrix}

<p>
Whiteout Blending : 对上面得到的 normal 乘 \(M_zD_z\) ，然后丢弃掉对 x 和 y 分量的缩放、这样可以强化 X 和 Y 分量<br />
</p>
\begin{equation}
  \begin{bmatrix}
  \frac{M_x}{M_z} + \frac{D_x}{D_z} \\
  \frac{M_y}{M_z} + \frac{D_y}{D_z} \\
  1 \\
  \end{bmatrix} * M_zD_z =
  \begin{bmatrix}
    M_xD_z + D_xM_z \\
    M_yD_z + D_yM_z \\
    M_zD_z \\
  \end{bmatrix} =
  \begin{bmatrix}
    M_x + D_x \\
    M_y + D_y \\
    M_zD_z \\
  \end{bmatrix}
\end{equation}

<p>
下面这段文字翻译自 Blending in Detial 文章：<br />
在开发 Reoriented Normal Mapping 方法时，我们希望新的方法满足下面的属性，从而能让艺术家从直观上理解其行为：<br />
属性 1：符合逻辑，方法有清晰的数学理论基础。（如：有清晰的几何解释）<br />
属性 2：处理恒等情况，如果其中一个 normal map 是平的，则输出和另外一个 normal map 一样。<br />
属性 3：不会变平，两个 normal map 的强度都会被保持。<br />
</p>

<p>
尽管 Whiteout 方法看似可行，但是其并不完全具备上面的第一和第三条属性。为了满足这些属性，我们的策略是对 detail normal 进行旋转使其跟随 base normal 对应的表面，就像切空间的 normal 会被变换以跟随几何表面的法线。<br />
</p>

<p>
Unity 中 base normal 和 detail normal 的混合使用了类似的思路，但是，其构造的 detail normal 旋转矩阵使用的三个向量并不是正交的。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> n1 = <span style="color: #4f97d7;">tex2D</span>(texBase,   uv).xyz*2 - 1;
<span style="color: #ce537a; font-weight: bold;">float3</span> n2 = <span style="color: #4f97d7;">tex2D</span>(texDetail, uv).xyz*2 - 1;

<span style="color: #ce537a; font-weight: bold;">float3x3</span> nBasis = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.z, n1.y, -n1.x), <span style="color: #2aa1ae; background-color: #292e34;">// +90 degree rotation around y axis</span>
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.x, n1.z, -n1.y), <span style="color: #2aa1ae; background-color: #292e34;">// -90 degree rotation around x axis</span>
     <span style="color: #ce537a; font-weight: bold;">float3</span>(n1.x, n1.y,  n1.z));

<span style="color: #ce537a; font-weight: bold;">float3</span> r = <span style="color: #4f97d7;">normalize</span>(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);
<span style="color: #4f97d7; font-weight: bold;">return</span> r*0.5 + 0.5;
</pre>
</div>

<ul class="org-ul">
<li>Blending in Detail <a href="https://blog.selfshadow.com/publications/blending-in-detail/index.html">https://blog.selfshadow.com/publications/blending-in-detail/index.html</a><br /></li>
<li>Normal Blend 方法总结 <a href="https://zhuanlan.zhihu.com/p/364821684">https://zhuanlan.zhihu.com/p/364821684</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org114f136" class="outline-6">
<h6 id="org114f136">Tangent Space And Tangent Space To World Space</h6>
<div class="outline-text-6" id="text-org114f136">
<p>
TangentSpace 基向量如下：(假设左手坐标系，Tangent 对应 x 轴，Normal 对应 y 轴，Binormal 对应 z 轴)<br />
</p>
<ul class="org-ul">
<li>Tangent 向量对应 U axis<br /></li>
<li>Normal 向量对应表面法线<br /></li>
<li>Binormal（或 Bitangent）向量对应 V axis。Binormal = Tangent x Normal = -(Normal x Tangent)。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgddc6323"></a>为什么要在 tangent vector 的 w 分量中存储-1 或 1？<br />
<div class="outline-text-7" id="text-orgddc6323">
<p>
创建左右对称的 3D 模型(例如：人类，动物)时，通常会对 mesh 进行作于镜像。这样就只需要编辑半部分模型，而且也只需要一半的贴图数据。在进行模型镜像的时候，顶点的 normal,tangent,向量也需要进行镜像，但是 binormal 向量则不需要。可以通过在 tangent 的 w 分量中存储-1 来表示 binormal 为非镜像的，tangent 的 w 分量中存储 1 来表示 binormal 为镜像的。<br />
</p>
</div>
</li>
<li><a id="org1af2aea"></a>为什么不需要对 worldTangent 和 worldBinormal 进行 normalize?<br />
<div class="outline-text-7" id="text-org1af2aea">
<p>
worldTangent worldBinormal 只用于得到 TangentToWorld 变换矩阵，从而将 tangentNormal 转换为 worldNormal。不会直接使用 worldTangent worldBinormal 用于光照计算，所以不需要 normalize。<br />
</p>
</div>
</li>
<li><a id="org259aeb3"></a>为什么 Unity 中没有对法线 y、z 分量进行调换？<br />
<div class="outline-text-7" id="text-org259aeb3">

<div id="org917010a" class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_tangent_normal_to_world_normal.png" alt="01_06bu_tangent_normal_to_world_normal.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// Unity &#23454;&#29616;</span>
  <span style="color: #ce537a; font-weight: bold;">half3x3</span> <span style="color: #bc6ec5; font-weight: bold;">CreateTangentToWorldPerVertex</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> tangent, <span style="color: #ce537a; font-weight: bold;">half</span> tangentSign)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// For odd-negative scale transforms we need to flip the sign</span>
      <span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #4f97d7;">sign</span> = tangentSign * unity_WorldTransformParams.w;
      <span style="color: #ce537a; font-weight: bold;">half3</span> binormal = <span style="color: #4f97d7;">cross</span>(normal, tangent) * <span style="color: #4f97d7;">sign</span>;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">half3x3</span>(tangent, binormal, normal);
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// vertex shader</span>
  <span style="color: #ce537a; font-weight: bold;">float4</span> tangentWorld = <span style="color: #ce537a; font-weight: bold;">float4</span>(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);
  <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);

  <span style="color: #2aa1ae; background-color: #292e34;">// fragment shader</span>
  <span style="color: #ce537a; font-weight: bold;">half3</span> tangent = tangentToWorld[0].xyz;
  <span style="color: #ce537a; font-weight: bold;">half3</span> binormal = tangentToWorld[1].xyz;
  <span style="color: #ce537a; font-weight: bold;">half3</span> normal = tangentToWorld[2].xyz;
  <span style="color: #ce537a; font-weight: bold;">float3</span> normalWorld = tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga067e47" class="outline-5">
<h5 id="orga067e47">Shadows</h5>
<div class="outline-text-5" id="text-orga067e47">
</div>
<div id="outline-container-orgfa74c0f" class="outline-6">
<h6 id="orgfa74c0f">方向光阴影</h6>
<div class="outline-text-6" id="text-orgfa74c0f">
</div>
<ul class="org-ul">
<li><a id="orgb6e0b11"></a>ShadowBias<br />
<div class="outline-text-7" id="text-orgb6e0b11">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgf144afb"></a>开启屏幕空间阴影<br />
<ul class="org-ul">
<li><a id="org6bbcad9"></a>开启关闭的方法<br />
<div class="outline-text-8" id="text-org6bbcad9">
<ul class="org-ul">
<li>关闭 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 No Support，Tier 中取消勾选 Cascaded Shadows 。<br /></li>
<li>开启 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 Built-in shader，Tier 中勾选 Cascaded Shadows 。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf4d8a3e"></a>Rendering to Depth Texture<br />
<div class="outline-text-8" id="text-orgf4d8a3e">
<p>
Unity 绘制场景中物体将其深度写入到 DepthTexture<br />
</p>


<div id="orgcaf8bf7" class="figure">
<p><img src="./UnityCatLikeCoding/01_07sh_depth.png" alt="01_07sh_depth.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="orge315494"></a>Rendering To Shadow Maps<br />
<div class="outline-text-8" id="text-orge315494">
<p>
Unity 在光源位置对场景进行绘制，将物体深度写入到 Shadowmap<br />
开启 shadow cascades 后，会多次绘制阴影。开启 2 级会绘制两次，开启 4 级会绘制 4 次。<br />
</p>

<p>
下图为第一个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows.png" alt="01_07sh_4cascades_shadows.png" /><br />
</p>

<p>
下图为第二个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_2.png" alt="01_07sh_4cascades_shadows_2.png" /><br />
</p>
</div>
</li>

<li><a id="orgae1c95c"></a>Collecting Shadows<br />
<div class="outline-text-8" id="text-orgae1c95c">
<p>
Unity 使用 Hidden/Internal-ScreenSpaceShadows shader 绘制一个全屏的矩形，以前面得到的 DepthTexture 和 Shadowmap 为输入，对于每一个片段通过比较对应的场景摄像机的深度和光照摄像机的深度得出屏幕空间的阴影贴图。<br />
在这个过程中，Unity 通过 Filtering 来实现软阴影。<br />
</p>

<p>
下图为第一个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_1.png" alt="01_07sh_screenspace_shadows_1.png" /><br />
下图为第二个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_2.png" alt="01_07sh_screenspace_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="org3ce0316"></a>最终结果<br />
<div class="outline-text-8" id="text-org3ce0316">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_drawcall.png" alt="01_07sh_4cascades_drawcall.png" /><br />
</p>

<p>
下图为绘制结果：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_result.png" alt="01_07sh_4cascades_shadows_result.png" /><br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgdb4fb6e"></a>为什么 unity 要在渲染 shadowmap 和 collecting 之间切换？<br />
<div class="outline-text-9" id="text-orgdb4fb6e">
<p>
因为每个光源需要它自己的屏幕空间阴影贴图，但是从光源视角渲染阴影贴图所用到的 RenderTarget 可以被复用。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org5a60bfe"></a>关闭屏幕空间阴影<br />
<ul class="org-ul">
<li><a id="orgea3b047"></a>Rendering To Shadow Maps<br />
<div class="outline-text-8" id="text-orgea3b047">
<p>
下图为第一个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_1.png" alt="01_07sh_noss_shadows_1.png" /><br />
下图为第二个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_2.png" alt="01_07sh_noss_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="orge6394d7"></a>最终结果<br />
<div class="outline-text-8" id="text-orge6394d7">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_3.png" alt="01_07sh_noss_shadows_3.png" /><br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org053f3ef"></a>ShadowQuality<br />
<div class="outline-text-7" id="text-org053f3ef">
<p>
减低 ShadowDistance 可以提高阴影精度，但是会缩小阴影范围。<br />
设置投影类型 QualitySettings.shadowProjection = ShadowProjection.CloseFit; 可以提高阴影精度。<br />
开启 Cascade。<br />
</p>
</div>
</li>
<li><a id="org564a199"></a>ForwardAddPass 阴影支持<br />
<div class="outline-text-7" id="text-org564a199">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#26041;&#26696;1 fwd pass &#20013;&#28155;&#21152;&#22914;&#19979;&#21629;&#20196;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile_fwdadd_fullshadows

  <span style="color: #2aa1ae; background-color: #292e34;">// &#26041;&#26696;2</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// 2.1 fwd pass &#20013;&#20462;&#25913;Tag</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// 2.2&#28155;&#21152; DIRECTIONAL SHADOWS_SCREEN&#21464;&#20307;</span>
  <span style="color: #4f97d7; font-weight: bold;">Tags</span>
  {
      <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"ForwardAdd"</span>
      <span style="color: #2d9574;">"SHADOWSUPPORT"</span>=<span style="color: #2d9574;">"true"</span>
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// ...</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRECTIONAL
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ SHADOWS_SCREEN
</pre>
</div>
</div>
</li>
<li><a id="org36d42f1"></a>参考资料<br />
<div class="outline-text-7" id="text-org36d42f1">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6fa4753" class="outline-6">
<h6 id="org6fa4753">Spot Light Shadow</h6>
</div>
<div id="outline-container-org74875da" class="outline-6">
<h6 id="org74875da">相关宏定义</h6>
<div class="outline-text-6" id="text-org74875da">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏定义</th>
<th scope="col" class="org-left">DrawCall</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UNITY_NO_SCREENSPACE_SHADOWS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">开启屏幕空间阴影</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">Directional 和 Spot 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">PointLight 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN</td>
<td class="org-left">RenderForward ForwardBasePass</td>
<td class="org-left">主 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN DIRECTIONAL</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">第二个 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH SPOT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Spot 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE POINT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Point 开启阴影对应的宏定义</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>DIRECTIONAL SPOT POINT 3 个对应 Light 组件上的 LightType 的设置<br /></li>
<li>SHADOWS_SCREEN SHADOWS_DEPTH SHADOWS_CUBE 对应物体 Renderer 组件上的 ReceiveShadow 设置<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org726bc66" class="outline-6">
<h6 id="org726bc66">参考资料</h6>
<div class="outline-text-6" id="text-org726bc66">
<ul class="org-ul">
<li>Signed Distance Field Shadow in Unity <a href="https://zhuanlan.zhihu.com/p/37918356">https://zhuanlan.zhihu.com/p/37918356</a><br /></li>
<li>Unity 平面阴影(王者荣耀阴影实现) <a href="https://zhuanlan.zhihu.com/p/42781261">https://zhuanlan.zhihu.com/p/42781261</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org710a16d" class="outline-5">
<h5 id="org710a16d">Reflection</h5>
<div class="outline-text-5" id="text-org710a16d">
</div>
<div id="outline-container-org7422227" class="outline-6">
<h6 id="org7422227">Environment Mapping</h6>
<div class="outline-text-6" id="text-org7422227">
</div>
<ul class="org-ul">
<li><a id="org37d5a8c"></a>缺少 Indirect Specular Lighting<br />
<div class="outline-text-7" id="text-org37d5a8c">
<p>
在 shader 中组合了 diffuse specular ambient 后，感觉应该可以创建出看上去真实的画面了，然而物体表面依然暗淡，闪耀的表面效果看起来不正确。闪耀的表面应该像镜子，特别是表面为金属时。（完美的镜面反射会反射所有光照，所以其不存在 diffuse.光滑度越高、金属度越高，材质越接近完美镜面。）<br />
下图为 Metallic Smoothness 取不同值时的渲染效果:<br />
<img src="./UnityCatLikeCoding/01_08re_no_indirect_spec_lighting1.png" alt="01_08re_no_indirect_spec_lighting1.png" /><br />
上图 metallic=1 时，env ambient 几乎对渲染没有任何影响，这是因为金属度越高反射率越大，反射率越大其漫反射部分就越少(参考 PhysicalTheory.org 中 金属和非金属放射光的差异 的描述)，所以 ambient 对于 metallic=1 的材质几乎没有任何影响。<br />
上图 metallic=1 Smoothness=1 时，几乎是一个黑色的球，只能看到一个很小的高光，这个很小的高光是表面将直接光源反射到了朝向我们的方向(朝向摄像机的方向)。之所以渲染结果是黑球，是因为 shader 中只包含了直接光照和间接光照的 diffuse（也就是 ambient），为了反射环境，需要添加间接光照的高光反射，即 indirectLight.specular。<br />
</p>
</div>
</li>

<li><a id="org37895ca"></a>Indirect Specular Lighting 特点<br />
<div class="outline-text-7" id="text-org37895ca">
<p>
视线和法线夹角越大，Fresnel 反射越强。表面越光滑 Fresnel 反射越强。<br />
<img src="./UnityCatLikeCoding/01_08re_fresnel_smoothness.png" alt="01_08re_fresnel_smoothness.png" /><br />
</p>

<p>
因为 Fresnel 间接反射来源于间接光照(上图中直接光照颜色为白色，间接光照的高光直接设置为了红色)，所以它产生的效果独立于直接光照，因此上图中即使处于阴影部分的边缘处 Fresnel 反射依然很强，其独立于直接光源的阴影。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i) {
    UnityIndirect indirectLight;
    indirectLight.diffuse = 0;
    indirectLight.specular = 0;

<span style="color: #bc6ec5;">    #if</span> defined(VERTEXLIGHT_ON)
        indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(FORWARD_BASE_PASS)
        indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
        <span style="color: #2aa1ae; background-color: #292e34;">// &#38388;&#25509;&#39640;&#20809;&#39068;&#33394;&#35774;&#32622;&#20026;&#20102;&#32418;&#33394;</span>
        indirectLight.specular = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, 0, 0);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org911ae96" class="outline-6">
<h6 id="org911ae96">Imperfect Reflections</h6>
<div class="outline-text-6" id="text-org911ae96">
<p>
模糊的反射是通过环境贴图的 mipmap 来实现的。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org6a5fd4a"></a>Metals VS Nonmetals<br />
<div class="outline-text-7" id="text-org6a5fd4a">
<p>
金属和非金属表面都可以产生清晰的反射，但是他们看起来是不同的。镜面反射在闪耀的电介质材质(非金属)上效果会很强，但是镜面反射并不会主导电介质材质(非金属)的外观，他们仍然表现出大量的可见的 diffuse 反射。<br />
<img src="./UnityCatLikeCoding/01_08re_dielectric.png" alt="01_08re_dielectric.png" /><br />
</p>

<p>
金属会改变镜面反射的颜色，但是非金属则不会。这对于镜面高光和环境镜面反射都适用。下图中金属的镜面高光颜色为红色，非金属是白色。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_nonmetal.png" alt="01_08re_metal_nonmetal.png" /><br />
</p>
</div>
</li>

<li><a id="orgc387de0"></a>Mirrors and Shadows<br />
<div class="outline-text-7" id="text-orgc387de0">
<p>
间接反射是独立于表面的直接照明的。这在其阴影区域会更加明显。对于非金属，这会让表面更亮一些，你依然可以看到直接光照导致的阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_nonmetal_with_shadow.png" alt="01_08re_nonmetal_with_shadow.png" /><br />
同样的规则适用于金属。但是，金属的间接反射起主导作用。因此，直接光照和阴影会随着光泽度增加而消失。完美镜面上不存在阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_with_shadow.png" alt="01_08re_metal_with_shadow.png" /><br />
现实世界中很少有完美的镜面。现实世界中的材质都是由金属和非金属混合而成的，可以通过调节金属度来模拟不完美的镜面材质。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgab72b24" class="outline-6">
<h6 id="orgab72b24">Box Projection</h6>
<div class="outline-text-6" id="text-orgab72b24">
<p>
ReflectionProbe 的 Box 区域是和世界坐标轴对齐的，它不受旋转和缩放影响。<br />
BoxProjection 原理如下图所示：<br />
<img src="./UnityCatLikeCoding/01_08re_box_projection.JPG" alt="01_08re_box_projection.JPG" /><br />
<img src="./UnityCatLikeCoding/01_08re_box_projection_3D.png" alt="01_08re_box_projection_3D.png" /><br />
<a href="./UnityCatLikeCoding/01_08re_box_projection.ggb">./UnityCatLikeCoding/01_08re_box_projection.ggb</a><br />
</p>

<p>
BoxProjection 对应代码实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">BoxProjection</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> dir, <span style="color: #ce537a; font-weight: bold;">half3</span> pos, <span style="color: #ce537a; font-weight: bold;">half4</span> cubemapPos, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMin, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMax)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// cubemapPos.w &#25511;&#21046; BoxProjection &#26159;&#21542;&#29983;&#25928;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// UNITY_BRANCH &#29992;&#20110;&#24320;&#21551;&#30495;&#27491;&#30340;&#20998;&#25903;</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (cubemapPos.w &gt; 0)
    {
        <span style="color: #ce537a; font-weight: bold;">half3</span> factors = ((dir &gt; 0 ? boxMax : boxMin) - pos) / dir;
        <span style="color: #ce537a; font-weight: bold;">half</span> realFactor = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(factors.x, factors.y), factors.z);
        <span style="color: #4f97d7; font-weight: bold;">return</span> dir * realFactor + (pos - cubemapPos);
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> dir;
}
</pre>
</div>

<ul class="org-ul">
<li>关于 UNITY_BRANCH   <a href="https://forum.unity.com/threads/correct-use-of-unity_branch.476804/">https://forum.unity.com/threads/correct-use-of-unity_branch.476804/</a><br /></li>
<li>HLSL branch flatten <a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc8d36c7" class="outline-6">
<h6 id="orgc8d36c7">Blending Reflection Probes</h6>
<div class="outline-text-6" id="text-orgc8d36c7">
<p>
只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">ReflectionProbeUsage</span>
{
    <span style="color: #7590db;">Off</span> = 0,                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20851;&#38381;&#21453;&#23556;&#25506;&#38024;</span>
    <span style="color: #7590db;">BlendProbes</span> = 1,              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21482;&#21644;&#21453;&#23556;&#25506;&#38024;&#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">BlendProbesAndSkybox</span> = 2,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21487;&#20197;&#21644; skybox &#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">Simple</span> = 3                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20351;&#29992;&#20854;&#20013;&#19968;&#20010;&#21453;&#23556;&#25506;&#38024;&#25110; skybox&#65292;&#19981;&#36827;&#34892;&#28151;&#21512;</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#28151;&#21512;&#21453;&#23556;&#25506;&#38024;&#30340;&#36923;&#36753;</span>
  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir)
  {
      UnityIndirect indirect;
      indirect.diffuse = 0;
      indirect.specular = 0;
<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS)
      indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));

      <span style="color: #ce537a; font-weight: bold;">half</span> roughness = 1 - <span style="color: #7590db;">_Smoothness</span>;
      roughness *= 1.7 - 0.7 * roughness;

      <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir = <span style="color: #4f97d7;">reflect</span>(-viewDir, i.worldNormal);
      <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir1 = BoxProjection(reflectDir, i.worldPos,
          unity_SpecCube0_ProbePosition,
          unity_SpecCube0_BoxMin,
          unity_SpecCube0_BoxMax);
      <span style="color: #ce537a; font-weight: bold;">half4</span> envColor = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflectDir1, roughness*UNITY_SPECCUBE_LOD_STEPS);
      envColor.rgb = DecodeHDR(envColor, unity_SpecCube0_HDR);
      UNITY_BRANCH
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_SpecCube0_BoxMin.a &lt; 0.9999)
      {
          <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir2 = BoxProjection(reflectDir, i.worldPos,
              unity_SpecCube1_ProbePosition,
              unity_SpecCube1_BoxMin,
              unity_SpecCube1_BoxMax);
          <span style="color: #ce537a; font-weight: bold;">half4</span> envColor2 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, reflectDir2, roughness*UNITY_SPECCUBE_LOD_STEPS);
          <span style="color: #2aa1ae; background-color: #292e34;">// DecodeHDR &#20013;&#20195;&#30721;&#22788;&#29702;&#20102; intensity &#36923;&#36753;</span>
          envColor2.rgb = DecodeHDR(envColor2, unity_SpecCube1_HDR);
          envColor = <span style="color: #4f97d7;">lerp</span>(envColor2, envColor, unity_SpecCube0_BoxMin.a);
      }
      <span style="color: #2aa1ae; background-color: #292e34;">//indirect.specular = half3(1, 0, 0);</span>
      indirect.specular = envColor.rgb;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee11c0c" class="outline-6">
<h6 id="orgee11c0c">Bouncing Reflections</h6>
<div class="outline-text-6" id="text-orgee11c0c">
<p>
在 Lighting/Scene/Environment Reflections 下可以设置 Bounces 的次数。<br />
Lighting/Scene 下的数据记录在当前打开的场景文件中，每个场景的数据可以不同。<br />
EnvironmentLighting/IntensityMultiplier  当 EnvironmentLighting/Source 为 Skybox 时，该调节项控制天空球光照亮度.<br />
</p>

<p>
EnvironmentReflections/Source  指定使用天空球作为环境反射源，还是自定义环境反射源。<br />
EnvironmentReflections/IntensityMultiplier 控制反射源在场景中提供反射的因子，值为 1 时符合物理规律。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb70f09b" class="outline-5">
<h5 id="orgb70f09b">ComplexMaterials &amp; More Complexity</h5>
<div class="outline-text-5" id="text-orgb70f09b">
</div>
<div id="outline-container-org683b209" class="outline-6">
<h6 id="org683b209">Emission</h6>
<div class="outline-text-6" id="text-org683b209">
<div class="org-src-container">
<pre class="src src-csharp">  [<span style="color: #7590db;">NoScaleOffset</span>] _EmissionMap (<span style="color: #2d9574;">"Emission"</span>, 2D) = <span style="color: #2d9574;">"black"</span> {}
  _Emission (<span style="color: #2d9574;">"Emission"</span>, Color) = (0, 0, 0)

<span style="color: #bc6ec5;">  #pragma</span> shader_feature _EMISSION_MAP

  sampler2D _EmissionMap;
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_Emission</span>;

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
<span style="color: #bc6ec5;">    #if</span> <span style="color: #bc6ec5;">defined</span>(_EMISSION_MAP)
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(_EmissionMap, i.uv.xy) * _Emission;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> _Emission;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">  #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">MyFragmentProgram</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) : SV_TARGET
  {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>

      <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">color</span> = <span style="color: #bc6ec5; font-weight: bold;">UNITY_BRDF_PBS</span>(
                                    albedo, specularTint,
                                    oneMinusReflectivity, <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(i),
                                    i.normal, viewDir,
                                    <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(i), <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span>(i, viewDir)
                                    );
      color.rgb += <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span>(i);
      <span style="color: #4f97d7; font-weight: bold;">return</span> color;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org1e3e027" class="outline-6">
<h6 id="org1e3e027">Smoothness &amp; Metallic Map</h6>
<div class="outline-text-6" id="text-org1e3e027">
<p>
将 MetallicMap 和 SmoothnessMap 存储到一张 DXT5 格式的贴图中 ，Metallic Map 放到贴图 r 通道, Smoothness Map 放到贴图 a 通道。等价于使用两张 DXT1 格式贴图分别存储。因为 DXT5 分开对 RGB 和 A 通道进行压缩。<br />
</p>
</div>
</div>

<div id="outline-container-org62b8c54" class="outline-6">
<h6 id="org62b8c54">Occlusion</h6>
<div class="outline-text-6" id="text-org62b8c54">
<div class="org-src-container">
<pre class="src src-csharp">  [<span style="color: #7590db;">NoScaleOffset</span>] _OcclusionMap (<span style="color: #2d9574;">"Occlusion"</span>, 2D) = <span style="color: #2d9574;">"white"</span> {}
  <span style="color: #bc6ec5; font-weight: bold;">_OcclusionStrength</span>(<span style="color: #2d9574;">"Occlusion Strength"</span>, <span style="color: #bc6ec5; font-weight: bold;">Range</span>(0, 1)) = 1

<span style="color: #bc6ec5;">  #pragma</span> shader_feature _OCCLUSION_MAP

  sampler2D _OcclusionMap;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_OcclusionStrength</span>;

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(_OCCLUSION_MAP)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(1, <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(_OcclusionMap, i.uv.xy).g, _OcclusionStrength);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Occlusion &#21516;&#26102;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;&#21644;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;&#26102;&#65292;Occlusion&#25928;&#26524;&#20250;&#36807;&#24378;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;Occlusion&#26159;&#22522;&#20110;&#29289;&#20307;&#24418;&#29366;&#30340;&#32780;&#19981;&#26159;&#29305;&#23450;&#20809;&#29031;&#30340;&#65292;&#20854;&#21482;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#20250;&#26356;&#21512;&#29702;&#19968;&#20123;&#12290;&#20985;&#30165;&#36234;&#28145;&#30340;&#22320;&#26041;&#65292;&#21508;&#20010;&#26041;&#21521;&#30340;&#38388;&#25509;&#20809;&#29031;&#20943;&#24369;&#36234;&#22810;&#65292;&#32780;&#30452;&#25509;&#20809;&#29031;&#29031;&#36827;&#20985;&#30165;&#26102;&#65292;&#36824;&#26159;&#21487;&#20197;&#21152;&#23558;&#20854;&#29031;&#20142;&#12290;</span>
  <span style="color: #ce537a; font-weight: bold;">UnityLight</span> <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
      <span style="color: #bc6ec5; font-weight: bold;">UNITY_LIGHT_ATTENUATION</span>(attenuation, i, i.worldPos);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;atten&#30456;&#20056;&#26469;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
      attenuation *= <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
      light.color = _LightColor0.rgb * attenuation;
      light.ndotl = <span style="color: #bc6ec5; font-weight: bold;">DotClamped</span>(i.normal, light.dir);
      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }

  <span style="color: #ce537a; font-weight: bold;">UnityIndirect</span> <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">viewDir</span>) {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">occlusion</span> = <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;&#38388;&#25509;&#20809;&#29031;&#30340;diffuse&#12289;specular&#30456;&#20056;&#26469;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
      indirectLight.diffuse *= occlusion;
      indirectLight.specular *= occlusion;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org94cb224" class="outline-5">
<h5 id="org94cb224">Transparency</h5>
<div class="outline-text-5" id="text-org94cb224">
</div>
<div id="outline-container-org39af979" class="outline-6">
<h6 id="org39af979">Cutout</h6>
<div class="outline-text-6" id="text-org39af979">
<ul class="org-ul">
<li>clip 操作对于移动平台的 TBDR 来说消耗比较大，通过添加 _RENDERING_CUTOUT ShaderFeature，对于不需要 clip 的材质可以提升渲染性能。<br /></li>
<li>修改 cutout 材质的渲染队列，让其在不透明(Opaque)物体之后绘制，这样如果 cutout 材质对应的物体被不透明物体遮挡了，就可以避免对 cutout 物体的绘制，从而提高性能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org53ab85b" class="outline-6">
<h6 id="org53ab85b">Semitransparent</h6>
<div class="outline-text-6" id="text-org53ab85b">
<ul class="org-ul">
<li>半透明物体需要采用 Blend SrcAlpha OneMinusSrcAlpha 的混合方式，这样才能将半透明物体后面的物体透出来。<br /></li>
<li>半透明物体不能写深度缓冲区，否则半透明物体叠加在一起时，深度测试会剔除掉物体的一部分，导致渲染结果不正确。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5d4fc74" class="outline-6">
<h6 id="org5d4fc74">RenderType tag</h6>
<div class="outline-text-6" id="text-org5d4fc74">
<p>
下面是 Unity 内置 shader 的 Shader replacement tags, 在使用替换的 shader 进行渲染时，需要使用为 shader 设置的"RenderType" tag。<br />
</p>
<ul class="org-ul">
<li>Opaque: most of the shaders (Normal , Self Illuminated, Reflective, terrain shaders).<br /></li>
<li>Transparent: most semitransparent shaders (Transparent, Particle, Font, terrain additive pass shaders).<br /></li>
<li>TransparentCutout: masked transparency shaders (Transparent Cutout, two pass vegetation shaders).<br /></li>
<li>Background: Skybox shaders.<br /></li>
<li>Overlay: GUITexture, Halo, Flare shaders.<br /></li>
<li>TreeOpaque: terrain engine tree bark.<br /></li>
<li>TreeTransparentCutout: terrain engine tree leaves.<br /></li>
<li>TreeBillboard: terrain engine billboarded trees.<br /></li>
<li>Grass: terrain engine grass.<br /></li>
<li>GrassBillboard: terrain engine billboarded grass.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org221262c" class="outline-6">
<h6 id="org221262c">Fading vs Transparency</h6>
<div class="outline-text-6" id="text-org221262c">
<ul class="org-ul">
<li>Fade Mode<br />
Fade Mode 中，使用的混合模式为 Blend SrcAlpha OneMinusSrcAlpha，几何体的颜色会依据 alpha 值降隐，漫反射和高光反射都会降隐。这种效果对于玻璃是不合适的，玻璃是全透明的，但是依然有清晰的高光和反射。<br /></li>
<li><p>
Transparent Mode<br />
Transparent Mode 中，使用的混合模式为 Blend One OneMinusSrcAlpha, albedo 会乘 alpha 值，因此漫反射会根据 alpha 值降隐，高光反射会影响到透明度。这种模式适用于玻璃。<br />
光线被反射后，透过半透明物体的光线会对应减少，如果所有光线都被反射，则不透明度为 1，如果没有光线被反射，则不透明度为原始值。y=kx+b 两个方程两个未知数，即可求出最终的 alpha 值。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_RENDERING_TRANSPARENT</span>)
    albedo *= alpha;
    alpha = 1 - oneMinusReflectivity + alpha * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #endif</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org16593a4" class="outline-5">
<h5 id="org16593a4">Semitransparent Shadows</h5>
<div class="outline-text-5" id="text-org16593a4">
</div>
<div id="outline-container-org2d1a0a8" class="outline-6">
<h6 id="org2d1a0a8">Cutout Shadow</h6>
<div class="outline-text-6" id="text-org2d1a0a8">
<p>
透贴的阴影只需要在 ShadowCaster Pass 的片段着色器中使用 clip(alpha - _Cutoff)指令将对应的片段剔除就可以了。<br />
</p>
</div>
</div>
<div id="outline-container-org7e8cc89" class="outline-6">
<h6 id="org7e8cc89">Transparenct Shadow</h6>
<div class="outline-text-6" id="text-org7e8cc89">
<p>
使用 Dithering 技术来实现半透明阴影。依据 alpha 值 clip 投影表面，从而模拟出半透明阴影。下图为使用这种技术实现的阴影效果：<br />
<img src="./UnityCatLikeCoding/20_01_16_semitransparent_shadow.png" alt="20_01_16_semitransparent_shadow.png" /><br />
</p>

<p>
_DitherMaskLOD Unity 使用的 Dither 贴图的模式如下，其一共包含 16 种模式，每个模式中的小像素块是 4x4 的像素块。开始是一个全空的模式(下图最右边)，依次向左每个模式填充一个像素块，直到模式中有 7 个像素块被填充。然后图案翻转，直到所有像素被填充。<br />
<img src="./UnityCatLikeCoding/20_01_16_dither-patterns.png" alt="20_01_16_dither-patterns.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679; _DitherMaskLOD &#29992;&#21040;&#30340;uv.z&#30340;&#33539;&#22260;&#20026;[0, 1] &#22240;&#20026;&#19968;&#20849;&#26377;16&#31181;&#27169;&#24335;&#65292;&#25152;&#20197;uv.z = 0 &#23545;&#24212;&#31532;&#19968;&#31181;&#27169;&#24335;uv.z = 1.0/16.0 = 0.0625 &#23545;&#24212;&#31532;&#20108;&#31181;&#27169;&#24335; uv.z = 0.9375 &#23545;&#24212;&#31532;15&#20013;&#27169;&#24335;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// alpha*0.9375 &#24403;alpha&#36234;&#23567;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#21491;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;0&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#24403;alpha&#36234;&#22823;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#24038;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;1&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#20174;&#32780;&#27169;&#25311;&#20102;&#21322;&#36879;&#26126;&#30340;&#38452;&#24433;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> uv = <span style="color: #ce537a; font-weight: bold;">float3</span>(i.vpos.xy, alpha*0.9375);
<span style="color: #ce537a; font-weight: bold;">float</span> dither = <span style="color: #4f97d7;">tex3D</span>(<span style="color: #7590db;">_DitherMaskLOD</span>, uv);
<span style="color: #4f97d7;">clip</span>(dither - 0.01);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf6ff8f7" class="outline-5">
<h5 id="orgf6ff8f7">Deferred Shading</h5>
<div class="outline-text-5" id="text-orgf6ff8f7">
</div>
<div id="outline-container-org27b46ea" class="outline-6">
<h6 id="org27b46ea">Forward Path vs Deferred Path</h6>
<div class="outline-text-6" id="text-org27b46ea">
</div>
<ul class="org-ul">
<li><a id="org8e34736"></a>DrawCall 对比<br />
<div class="outline-text-7" id="text-org8e34736">
<p>
当场景中只有一个方向光时，Forward Path 和 Deferred Path 的 DrawCall 数目相差不多，Forward Path 因为需要单独生成 DepthTexture，在开始的 DepthPass 中多出了 48 个 DrawCall<br />
场景中有两个方向光时，Forward Path 比 Deferred Path 多出了很多 DrawCall。<br />
</p>

<p>
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall0.png" alt="20_01_16_deferred_renderring_drawcall0.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall1.png" alt="20_01_16_deferred_renderring_drawcall1.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall2.png" alt="20_01_16_deferred_renderring_drawcall2.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall3.png" alt="20_01_16_deferred_renderring_drawcall3.png" /><br />
</p>
</div>

<ul class="org-ul">
<li><a id="org021e010"></a>为什么场景中存在多个光照时，Deferred Path 比 Forward Path 的 DrawCall 数目更少？<br />
<div class="outline-text-8" id="text-org021e010">
<p>
为了渲染物体，shader 必须抓取物体的 mesh 数据，将其转化到正确的坐标空间中，然后将数据进行插值，最后，获取表面属性，计算光照。<br />
Forward Path 必须为照亮物体的每一个像素光源执行前面提到的步骤，因为 DepthBuffer 已经被填充，所以额外的 Pass 比第一个 Pass 消耗要少一些，而且它们不需要考虑间接光照。但是，他们依然需要重复处理第一个 Pass 已经做过的很多工作。<br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work.png" alt="01_12de_duplicate-work.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work1.png" alt="01_12de_duplicate-work1.png" /><br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org3ed11f8"></a>GBuffer 内容<br />
<div class="outline-text-7" id="text-org3ed11f8">
<p>
<img src="./UnityCatLikeCoding/01_12de_gbuffer0.png" alt="01_12de_gbuffer0.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer1.png" alt="01_12de_gbuffer1.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer2.png" alt="01_12de_gbuffer2.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer3.png" alt="01_12de_gbuffer3.png" /><br />
</p>
</div>
</li>
<li><a id="orgb14e96e"></a>Rendering Lights<br />
<ul class="org-ul">
<li><a id="orgc69a1d1"></a>Directional Lights<br />
<div class="outline-text-8" id="text-orgc69a1d1">
<p>
因为方向光影响所有物体，通过渲染一个覆盖整个视图的四边形来计算方向光的渲染。Unity 默认使用 Internal-DeferredShading.shader 来渲染这个四边形。(每个方向光使用一个四边形计算一次，多个方向光计算多次)<br />
下图中使用了两个方向光，其中渲染了两次：<br />
<img src="./UnityCatLikeCoding/01_12de_directional_light_rendering.png" alt="01_12de_directional_light_rendering.png" /><br />
</p>
</div>
</li>
<li><a id="org60ed037"></a>Spot Lights<br />
<div class="outline-text-8" id="text-org60ed037">
<p>
spot light 不会影响所有物体，使用一个棱锥体可以表示 Spot light 照亮的体积，所以通过渲染一个棱锥体来执行 Spot Light 的渲染，这样只有棱锥体可见区域会被渲染。如果棱锥体完全被其他物体遮挡，则不需要渲染该 spot light。如果棱锥体的任何一个片段被渲染，将会执行该 spot light 的光照计算。<br />
只有真的有物体在 spot light 照亮的体积中时，光照计算才是有意义的。在棱锥体后面的几何体是不需要渲染的，因为 spot light 照不到该几何体。<br />
  为了避免渲染不必要的片段，首先使用 Internal-StencilWrite.shader 渲染棱锥体，该 Pass 会写入模板缓冲区，用来标识哪些片段需要渲染。不过当棱锥体和摄像机近平面交叉时不能使用该技术，因为此时近平面外的正面被摄像机剔除，只有反面写入了模板值。<br />
<img src="./UnityCatLikeCoding/01_12de_spot_light_rendering.png" alt="01_12de_spot_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="orgd99d327"></a>Point lights<br />
<div class="outline-text-8" id="text-orgd99d327">
<p>
point light 和 spot light 类似，只是使用球体来表示 point light 照亮的体积。<br />
<img src="./UnityCatLikeCoding/01_12de_point_light_rendering.png" alt="01_12de_point_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="org406adc3"></a>Q&amp;A<br />
<div class="outline-text-8" id="text-org406adc3">
<ul class="org-ul">
<li>渲染灯光对应的物体时，为什么需要关闭正反面剔除？<br />
<ul class="org-ul">
<li>因为需要利用正反面分两次写入模板缓冲区，详细解释可以参考 <a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org8b8535c"></a>Light Range<br />
<div class="outline-text-7" id="text-org8b8535c">
<p>
延迟渲染中，Unity 默认使用 LDR(Low Dynamic Range)渲染场景，此时颜色值被写入到 ARGB32 格式的贴图中，Unity 使用对数运算来编码颜色从而扩大存储的颜色范围。Final Deferred Pass 会将这些颜色值转化为正常范围的颜色值。可以在 Camera 中可以设置是否开启 HDR。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  col.xyz += <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(i);
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(DEFERRED_PASS)
    output.gBuffer0.rgb = albedo;
    output.gBuffer0.a = <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span>(i);
    output.gBuffer1.rgb = specColor;
    output.gBuffer1.a = smoothness;
    output.gBuffer2 = <span style="color: #bc6ec5; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">    #if</span> <span style="color: #a45bad;">!</span><span style="color: #bc6ec5;">defined</span>(UNITY_HDR_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#25351;&#25968;-&#23545;&#25968;&#36816;&#31639;&#26469;&#32534;&#30721;&#35299;&#30721;&#39068;&#33394;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exp2(-col.rgb) = 2^{-col.rgb}</span>
      col.rgb = <span style="color: #bc6ec5; font-weight: bold;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    output.gBuffer3 = col;
<span style="color: #bc6ec5;">  #else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return indirect.specular.rgbr;</span>
    output.color = col;
<span style="color: #bc6ec5;">  #endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DEFFERRED_PASS</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<p>
下图为不开启和开启 HDR 对于的 RenderTarget 贴图格式：<br />
<img src="./UnityCatLikeCoding/01_12de_ldr.png" alt="01_12de_ldr.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_hdr.png" alt="01_12de_hdr.png" /><br />
</p>
</div>
</li>

<li><a id="org33f9ae9"></a>Mixing Rendering Modes<br />
<div class="outline-text-7" id="text-org33f9ae9">
<p>
场景中一部分物体使用的 shader 不支持延迟渲染模式时，引擎会先执行延迟渲染，将支持延迟渲染的物体绘制出来，然后再执行前向渲染，将其他不支持延迟渲染的物体绘制出来。<br />
Unity 的延迟渲染不支持半透明物体，半透明物体需要 Forward rendering 阶段来渲染(因为半透明物体意味着需要将半透明物体叠在其后面的物体上，每多一个半透物体重叠就额外需要一整套 GBuffer 来存储对应半透明物体的渲染数据)。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org8ee4255" class="outline-6">
<h6 id="org8ee4255">Support Deferred Path</h6>
<div class="outline-text-6" id="text-org8ee4255">
</div>
<ul class="org-ul">
<li><a id="org92bdf28"></a>创建 deferred pass<br />
<div class="outline-text-7" id="text-org92bdf28">
<p>
延迟渲染需要 GPU 支持 MRT(multiple render targets).<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Tags</span> {
          <span style="color: #2aa1ae; background-color: #292e34;">// &#34920;&#31034;&#35813;Pass&#29992;&#20110;&#24310;&#36831;&#28210;&#26579;</span>
          <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"Deferred"</span>
      }

      <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">      #pragma</span> target 3.0
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22914;&#26524;GPU&#19981;&#25903;&#25345;MRT&#21017;&#25490;&#38500;&#24403;&#21069;Pass</span>
<span style="color: #bc6ec5;">      #pragma</span> exclude_renderers nomrt

      <span style="color: #2aa1ae; background-color: #292e34;">// &#24310;&#36831;&#28210;&#26579;&#19981;&#25903;&#25345; _RENDERING_FADE&#21644; _RENDERING_TRANSPARENT</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature _ <span style="color: #7590db;">_RENDERING_CUTOUT</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_METALLIC_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature _ <span style="color: #7590db;">_SMOOTHNESS_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESS_METALLIC</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_NORMAL_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_OCCLUSION_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_MASK</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_ALBEDO_MAP</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_NORMAL_MAP</span>

<span style="color: #bc6ec5;">      #pragma</span> vertex MyVertexProgram
<span style="color: #bc6ec5;">      #pragma</span> fragment MyFragmentProgram

<span style="color: #bc6ec5;">      #define</span> DEFERRED_PASS

<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"MyDeferred.cginc"</span>
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
  }
</pre>
</div>
</div>
</li>

<li><a id="orgdcf549e"></a>deferred pass frag output<br />
<div class="outline-text-7" id="text-orgdcf549e">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> FragmentOutput {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#24310;&#36831;&#28210;&#26579;&#38656;&#35201;&#23558;&#25968;&#25454;&#20445;&#23384;&#21040;&#22810;&#20010;RenderTarget</span>
<span style="color: #bc6ec5;">      #if</span> defined(DEFERRED_PASS)
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">      #endif</span>
  };
</pre>
</div>
</div>
</li>
<li><a id="org2186ebc"></a>gbufer0123<br />
<div class="outline-text-7" id="text-org2186ebc">
<div class="org-src-container">
<pre class="src src-shader">  FragmentOutput output;
<span style="color: #bc6ec5;">  #if</span> defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HDR_ON)
      color.rgb = <span style="color: #4f97d7;">exp2</span>(-color.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer0.rgb &#35760;&#24405;albedo</span>
    output.gBuffer0.rgb = albedo;
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer0.a&#35760;&#24405;Occlusion</span>
    output.gBuffer0.a = GetOcclusion(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer1.rgb &#35760;&#24405;&#20102; specularColor</span>
    output.gBuffer1.rgb = specularTint;
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer1.a &#35760;&#24405;&#20102;Smoothness</span>
    output.gBuffer1.a = GetSmoothness(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer2&#20013;&#35760;&#24405;&#20102;normal</span>
    output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal * 0.5 + 0.5, 1);
    <span style="color: #2aa1ae; background-color: #292e34;">// GBuffer3&#20013;&#35760;&#24405;&#20102;Emissive &#21644; environment ambient&#65292;&#21518;&#32493;&#20809;&#29031;&#35745;&#31639;&#24471;&#21040;&#30340;&#39068;&#33394;&#37117;&#20250;&#21472;&#21152;&#21040;GBuffer3&#20013;</span>
    output.gBuffer3 = color;
<span style="color: #bc6ec5;">  #else</span>
    output.color = ApplyFog(color, i);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>为什么自己写的 DeferredPass GBuffer0 中输出了高光颜色，GBuffer1 中颜色比较暗?<br />
FrameDebug 发现 MetallicMap 的贴图使用了 Unity 的默认贴图，进一步检查发现 shader 属性列表中定义的属性名称和 shader 中使用的名称不一致。<br /></li>
</ul>
</div>
</li>
<li><a id="org12591e7"></a>support LDR<br />
<div class="outline-text-7" id="text-org12591e7">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
    output.gBuffer0.rgb = albedo;
    output.gBuffer0.a = GetOcclusion(i);
    output.gBuffer1.rgb = specColor;
    output.gBuffer1.a = smoothness;
    output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HDR_ON)
    col.rgb = <span style="color: #4f97d7;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">    #endif</span>
    output.gBuffer3 = col;
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//return indirect.specular.rgbr;</span>
    output.color = col;
<span style="color: #bc6ec5;">#endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// DEFFERRED_PASS</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>Tone mapping 进化论 <a href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a><br /></li>
<li>Tone Mapping 与 Gamma Correction <a href="https://zhuanlan.zhihu.com/p/79203830">https://zhuanlan.zhihu.com/p/79203830</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org494fdae" class="outline-6">
<h6 id="org494fdae">Deferred Reflections</h6>
<div class="outline-text-6" id="text-org494fdae">
</div>
<ul class="org-ul">
<li><a id="org2e36baf"></a>Unity 内置的屏幕空间反射<br />
<div class="outline-text-7" id="text-org2e36baf">
<p>
延迟渲染时，反射球会被渲染，反射球被投影到和反射球体积有交叉的几何体上。因此，反射球的反射不会扩展到反射球体积之外。反射球的渲染类似于灯光的渲染，只是反射球是使用正方体渲染的。<br />
多个反射球按照顺序渲染，首先 skybox 被渲染，会覆盖整个视图。然后，各个反射球被渲染，每个反射球只会覆盖其体积内的表面。多个反射球体积有重叠时，重叠区域内，先绘制的反射球会被后绘制的反射球覆盖。<br />
默认情况下，体积大的反射球会先绘制，这样体积小的反射球就可以覆盖体积大的反射球。你可以通过修改反射球的 Importance 属性值来调整它的绘制顺序。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_probe_params.png" alt="01_12de_reflection_probe_params.png" /><br />
</p>
</div>
</li>

<li><a id="orga5d6f09"></a>延迟渲染使用非屏幕空间反射<br />
<div class="outline-text-7" id="text-orga5d6f09">
<p>
关闭延迟渲染的屏幕空间反射后，Unity 会采用前向渲染的方式计算反射，将反射效果写入 GBuffer3 中。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_no_screen_space.png" alt="01_12de_reflection_no_screen_space.png" /><br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgfe008a9" class="outline-5">
<h5 id="orgfe008a9">Fog</h5>
<div class="outline-text-5" id="text-orgfe008a9">
</div>
<div id="outline-container-org3f50d43" class="outline-6">
<h6 id="org3f50d43">Forward Fog</h6>
<div class="outline-text-6" id="text-org3f50d43">
<p>
在 LightSetting 可以设置雾相关的属性。<br />
</p>

<ul class="org-ul">
<li>ForwardPath 中为什么天空盒子不受雾效果的影响？<br />
雾效果是在 Standard Shader 中的片段着色器中，对片段颜色进行修改来实现的。Unity 的天空盒并没有使用 Standard Shader 进行渲染，所以其不受雾影响。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org65491d0"></a>Linear Fog<br />
<div class="outline-text-7" id="text-org65491d0">
<p>
线性模式的雾可以设置雾生效的最小距离和最大距离。离摄像机距离小于最小距离时没有雾的效果，在最小距离到最大距离雾的效果逐渐增加到最大，大于最大距离时显示最大雾的效果（即物体完全呈现雾的颜色）<br />
</p>

<p>
LinearFog 计算公式 \(f = \frac{fogEnd - fogCoor}{fogEnd-fogStart}\)<br />
</p>
</div>
</li>
<li><a id="orgfe333f4"></a>Exponential Fog<br />
<div class="outline-text-7" id="text-orgfe333f4">
<p>
一次指数模式的雾。<br />
</p>

<p>
ExponentialFog 计算公式 \(f = 2^{-fogCoor*fogDensity}\)<br />
</p>
</div>
</li>
<li><a id="org04f1fd2"></a>Exponential Squared Fog<br />
<div class="outline-text-7" id="text-org04f1fd2">
<p>
二次指数模式的雾。<br />
</p>

<p>
ExponentialSquaredFog 计算公式 \(f = 2^{-(fogCoor*fogDensity)^{2}}\)<br />
</p>


<div id="org9ed477d" class="figure">
<p><img src="./UnityCatLikeCoding/01_14fo_expFog.jpg" alt="01_14fo_expFog.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="org83fe937"></a>Depth-Based Fog<br />
<div class="outline-text-7" id="text-org83fe937">
<p>
Unity Shader 使用裁剪空间坐标的 w 分量作为 Fog Coordinate，裁剪空间坐标的 w 分量为投影变换前摄像机坐标系下坐标的 z 分量。这种计算雾的方式也称为基于深度的雾计算。<br />
基于深度的雾计算比基于距离的雾计算效率更高。基于距离的雾比基于深度的雾效果要好，基于深度的雾在摄像机旋转视角时，雾效会变化。下图说明了其中的原理：<br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_001.png" alt="01_14fo_depth_vs_distance_001.png" /><br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_002.png" alt="01_14fo_depth_vs_distance_002.png" /><br />
</p>
</div>
</li>

<li><a id="org3d6af71"></a>代码实现<br />
<ul class="org-ul">
<li><a id="org91effb5"></a>ApplyFog<br />
<div class="outline-text-8" id="text-org91effb5">
<div class="org-src-container">
<pre class="src src-shader">  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      o.pos = UnityObjectToClipPos(v.vertex);
      o.uv.xy  = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      o.worldNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
      o.worldPos = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22522;&#20110;&#28145;&#24230;&#30340;&#38654;</span>
<span style="color: #bc6ec5;">  #if</span> FOG_DEPTH
      <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL clip space z range = [-near, far]</span>
      o.worldPos.w = o.pos.z;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> tangentWorld = UnityObjectToWorldDir(v.tangent.xyz);
      <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = MCreateTangentToWorldPerVertex(o.worldNormal, tangentWorld, v.tangent.w);
      o.tangentToWorld[0] = tangentToWorld[0];
      o.tangentToWorld[1] = tangentToWorld[1];
      o.tangentToWorld[2] = tangentToWorld[2];
      ComputeVertexLightColor(o);

<span style="color: #bc6ec5;">      #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS)
      TRANSFER_SHADOW(o);
<span style="color: #bc6ec5;">      #else</span>
      UNITY_TRANSFER_SHADOW(o, 0);
<span style="color: #bc6ec5;">      #endif</span>
      COMPUTE_LIGHT_COORDS(o);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }


  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ApplyFog</span>(<span style="color: #ce537a; font-weight: bold;">float</span> color, v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos);
<span style="color: #bc6ec5;">  #if</span> FOG_DEPTH
      viewDistance = UNITY_Z_0_FAR_FROM_CLIPSPACE(i.worldPos.w);
<span style="color: #bc6ec5;">  #endif</span>
      UNITY_CALC_FOG_FACTOR_RAW(viewDistance);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#22810;&#20809;&#28304;&#25903;&#25345; &#21482;&#38656;&#35201;&#23545;&#31532;&#19968;&#20010;&#20809;&#28304;&#21472;&#21152;&#38654;&#30340;&#39068;&#33394;&#23601;&#21487;&#20197;&#20102;&#65292;&#20854;&#20182;&#20809;&#28304;&#21482;&#26681;&#25454;&#38654;&#30340;&#24378;&#24230;&#36827;&#34892;&#20943;&#24369;&#12290;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> fogColor = 0;
<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS)
      fogColor = unity_FogColor.rgb;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(fogColor, color, unityFogFactor);
  }
</pre>
</div>
</div>
</li>
<li><a id="org1785cd5"></a>UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) 将 zclip space z value map to [0, far]<br />
<div class="outline-text-8" id="text-org1785cd5">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(UNITY_REVERSED_Z)
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z == 1
        <span style="color: #2aa1ae; background-color: #292e34;">//D3d with reversed Z =&gt; z clip range is [near, 0] -&gt; remapping to [0, far]</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(((1.0-(coord)/<span style="color: #7590db;">_ProjectionParams</span>.y)*<span style="color: #7590db;">_ProjectionParams</span>.z),0)
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//GL with reversed z =&gt; z clip range is [near, -far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(-(coord), 0)
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#elif</span> UNITY_UV_STARTS_AT_TOP
    <span style="color: #2aa1ae; background-color: #292e34;">//D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//Opengl =&gt; z clip range is [-near, far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>为什么此处不需要将 Z 值线性化？而从深度缓存区取出的深度值需要线性化？<br />
 ClipSpace 的 Z 值(OpenGL Clip Space Z Range=[-near,far])没有经过透视除法，所以其 Z 值本身就是线性的;<br />
深度缓冲区中的 Z 值（Depth Buffer Z Range=[0, 1]）经过了透视除法，其值不是线性的(10%近处的场景占用了 0-0.9 范围的深度)。<br />
<ul class="org-ul">
<li>Depth Testing <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a><br /></li>
<li>linear Depth Buffer(线性深度缓冲区) <a href="https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html">https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org8bf9f7f"></a>UNITY_CALC_FOG_FACTOR_RAW 实现了前面的计算公式<br />
<div class="outline-text-8" id="text-org8bf9f7f">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(FOG_LINEAR)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = (end-z)/(end-start) = z * (-1/(end-start))+(end/(end-start))</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        (coord) * unity_FogParams.z + unity_FogParams.w
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = exp(-density*z)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        unity_FogParams.y * (coord); \
        unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor)
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP2)
    <span style="color: #2aa1ae; background-color: #292e34;">// factor = exp(-(density*z)^2)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
        unity_FogParams.x * (coord); \
        unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor*unityFogFactor)
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = 0.0
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// x = density / sqrt(ln(2)), useful for Exp2 mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// y = density / ln(2), useful for Exp mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// z = -1/(end-start), useful for Linear mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// w = end/(end-start), useful for Linear mode</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> unity_FogParams;
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgd0a74ce" class="outline-6">
<h6 id="orgd0a74ce">Deferred Fog</h6>
<div class="outline-text-6" id="text-orgd0a74ce">
</div>
<ul class="org-ul">
<li><a id="orgf296706"></a>Shader Source Code<br />
<div class="outline-text-7" id="text-orgf296706">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Custom/DeferredFog"</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
      <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
      <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_CameraDepthTexture</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_FrustumCorners</span>[4];

      <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
          <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      };

      <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
          <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
          <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
          <span style="color: #ce537a; font-weight: bold;">float3</span> ray;
<span style="color: #bc6ec5;">          #endif</span>
      };

      Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
          Interpolators i;
          i.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.vertex.xy, 0.0, 1.0);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#30452;&#25509;&#36890;&#36807;&#19977;&#35282;&#24418;&#39030;&#28857;&#22352;&#26631;&#27714;&#30340;uv&#22352;&#26631;</span>
          i.uv = (v.vertex + 1) * 0.5;
<span style="color: #bc6ec5;">          #if</span> UNITY_UV_STARTS_AT_TOP
            i.uv= i.uv * <span style="color: #ce537a; font-weight: bold;">float2</span>(1.0, -1.0) + <span style="color: #ce537a; font-weight: bold;">float2</span>(0.0, 1.0);
<span style="color: #bc6ec5;">          #endif</span>
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
            <span style="color: #2aa1ae; background-color: #292e34;">// &#23558; i.uv &#26144;&#23556;&#20026;&#25968;&#32452;&#30340;&#32034;&#24341;&#20540;</span>
            i.ray = <span style="color: #7590db;">_FrustumCorners</span>[i.uv.x+2*i.uv.y]
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> i;
      }

      <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">FragmentProgram</span> (Interpolators i) : <span style="color: #a45bad;">SV_Target</span> {
          <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, i.uv);
          depth = Linear01Depth(depth);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#20026;&#20102;&#21644;Forward Path&#20013;&#28145;&#24230;&#38654;&#35745;&#31639;&#19968;&#30452;&#38656;&#35201;&#20943;&#25481;near , &#21442;&#32771; UNITY_Z_0_FAR_FROM_CLIPSPACE &#20989;&#25968;&#20013;&#30340;&#22788;&#29702;</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// _ProjectionParams // x=1 or -1  y=near z=far w=1/far</span>
<span style="color: #bc6ec5;">          #if</span> defined(FOG_DISTANCE)
          <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(depth * i.ray);
<span style="color: #bc6ec5;">          #else</span>
          <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = depth * <span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y;
<span style="color: #bc6ec5;">          #endif</span>
          UNITY_CALC_FOG_FACTOR_RAW(viewDistance);
          unityFogFactor = <span style="color: #4f97d7;">saturate</span>(unityFogFactor);
          <span style="color: #2aa1ae; background-color: #292e34;">// &#22825;&#31354;&#30418;&#28145;&#24230;&#20540;&#20026;1&#65292;&#36890;&#36807;&#19979;&#38754;&#21028;&#26029;&#65292;&#35753;&#38654;&#19981;&#24433;&#21709;&#22825;&#31354;&#30418;</span>
          <span style="color: #4f97d7; font-weight: bold;">if</span> (depth &gt; 0.9999)
          {
              unityFogFactor = 1;
          }
          <span style="color: #ce537a; font-weight: bold;">float3</span> color = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv).rgb;
          <span style="color: #ce537a; font-weight: bold;">float3</span> foggedColor = <span style="color: #4f97d7;">lerp</span>(unity_FogColor.rgb, color, unityFogFactor);
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(foggedColor, 1);
      }
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

      <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
          <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">              #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">              #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">              #pragma</span> multi_compile_fog
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
          <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
              <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">              #define</span> FOG_DISTANCE
<span style="color: #bc6ec5;">              #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">              #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">              #pragma</span> multi_compile_fog
              <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
          }
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="org30c5a74"></a>Depth-Based Fog<br /></li>
<li><a id="org556f17f"></a>Distance Based Fog<br />
<div class="outline-text-7" id="text-org556f17f">
<p>
从摄像机原点向远平面发射一条射线，如果从原点到远平面之间有物体，这射线最先接触的物体的交点到摄像机原点的距离就是我们要求的距离。<br />
从摄像机原点 O 到远平面交点 F 的射线(向量 OF)和从原点 O 到最先接触物体的交点 I 的射线(向量 OI)之间的关系为 \(OF=depth*OI\) ,其中 depth 为交点 I 对应的深度值。<br />
在 vertex shader 中设置每个顶点对应的 \(ray=\overrightarrow{OF}\) ,在 fragment shader 中就会得到各个像素对应的 OF 向量。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7bccbef" class="outline-5">
<h5 id="org7bccbef">Deferred Lights</h5>
<div class="outline-text-5" id="text-org7bccbef">
</div>
<div id="outline-container-org2b631c4" class="outline-6">
<h6 id="org2b631c4">Light Shader</h6>
<div class="outline-text-6" id="text-org2b631c4">
</div>
<ul class="org-ul">
<li><a id="org8bad6d9"></a>两个 Pass<br />
<div class="outline-text-7" id="text-org8bad6d9">
<p>
DeferredShading 需要两个 Pass。第一个 Pass 执行光照计算，第二个 Pass 处理 LDR 模式下的颜色解码。<br />
当 HDR 没开启时，光照数据是按照指数-对数运算编码解码的，前面的 DeferredShading 使用指数运算进行了编码，此时需要使用对数运算进行解码。<br />
</p>
</div>
</li>
<li><a id="org63ca6b9"></a>Avoiding the Sky<br />
<div class="outline-text-7" id="text-org63ca6b9">
<p>
当 HDR 没有开启时，SceneView 中天空盒会显示不正确(Unity 2020.1.4f1 版本)，在第二个 Pass 中使用 StencilBuffer 作为 Mask，从而避免对数运算解码对天空盒对应的像素进行操作。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
      <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
      <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
      <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off

      <span style="color: #4f97d7; font-weight: bold;">Stencil</span> {
          <span style="color: #4f97d7; font-weight: bold;">Ref</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
          <span style="color: #4f97d7; font-weight: bold;">ReadMask</span> [<span style="color: #7590db;">_StencilNonBackground</span>]
          <span style="color: #4f97d7; font-weight: bold;">CompBack</span> Equal
          <span style="color: #4f97d7; font-weight: bold;">CompFront</span> Equal
      }
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org33c6331" class="outline-6">
<h6 id="org33c6331">Directional Lights</h6>
<div class="outline-text-6" id="text-org33c6331">
<p>
使用正交投影矩阵渲染一个矩形。具体实现参考有道云笔记 Unity Source Code.md<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6b580b9"></a>读取 G-Buffer 数据使用的 UV<br />
<div class="outline-text-7" id="text-org6b580b9">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
  };

  Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
      Interpolators i;
      i.pos = UnityObjectToClipPos(v.vertex);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35835;&#21462;G-Buffer&#25968;&#25454;&#20351;&#29992;&#30340;UV</span>
      i.uv = ComputeScreenPos(i.pos);
      <span style="color: #4f97d7; font-weight: bold;">return</span> i;
  }
</pre>
</div>
</div>
</li>
<li><a id="orga29a67c"></a>像素对应的世界坐标位置<br />
<div class="outline-text-7" id="text-orga29a67c">
<p>
从原始透视摄像机到近平面四个角的射线存储在绘制四边形的 normal 中。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> ray : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
      Interpolators i;
      i.pos = UnityObjectToClipPos(v.vertex);
      i.uv = ComputeScreenPos(i.pos);
      i.ray = v.normal;
      <span style="color: #4f97d7; font-weight: bold;">return</span> i;
  }
  <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
  {
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv = i.uv.xy / i.uv.w;
      <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, uv);
      depth = Linear01Depth(depth);
      <span style="color: #ce537a; font-weight: bold;">float3</span> rayToFarPlane = i.ray * <span style="color: #7590db;">_ProjectionParams</span>.z / i.ray.z;
      <span style="color: #ce537a; font-weight: bold;">float3</span> viewPos = rayToFarPlane * depth;
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27714;&#20687;&#32032;&#23545;&#24212;&#30340;&#19990;&#30028;&#22352;&#26631;&#20301;&#32622;&#65292;unity_CameraToWorld&#30697;&#38453;&#20026;&#21407;&#22987;&#36879;&#35270;&#25668;&#20687;&#26426;&#21040;&#19990;&#30028;&#31354;&#38388;&#30340;&#36716;&#25442;&#30697;&#38453;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos = <span style="color: #4f97d7;">mul</span>(unity_CameraToWorld, <span style="color: #ce537a; font-weight: bold;">float4</span>(viewPos, 1)).xyz;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="org754cbbd"></a>Supporting LDR<br />
<div class="outline-text-7" id="text-org754cbbd">
<p>
HDR 模式下，DeferredShading 只需要一个 Pass，该 Pass 的 Blend 模式设置为 Blend One One。直接将光照效果叠在之前计算的 Emission 等之上。<br />
LDR 模式下，DeferredShading 需要两个 Pass：<br />
第一个 Pass 执行光照计算，计算所得的颜色为 exp2(-lightingResult)，该值需要和之前 GBuffer 存储的颜色 exp2(-emissionGBuffer)组合起来，因此其 Blend 模式设置为 Blend DstColor Zero。<br />
第二个 Pass 对颜色进行解码，其 Blend 模式设置为 Blend One Zero。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb0e3b8d" class="outline-6">
<h6 id="orgb0e3b8d">Point Lights</h6>
<div class="outline-text-6" id="text-orgb0e3b8d">
<p>
将点光源当作一个球来进行渲染。具体渲染流程如下：<br />
</p>
<ol class="org-ol">
<li>按照下面方法，使用模板标记出处于球体内的对象：<br />
<ol class="org-ol">
<li><p>
Write Depth Off, DepthTest LEqual, Cull Front; 渲染点光源对应的球，未通过深度测试的像素，Stencil 值加 1。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">        <span style="color: #4f97d7; font-weight: bold;">Stencil</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">ReadMask</span>  8
            <span style="color: #4f97d7; font-weight: bold;">WriteMask</span> 8
            <span style="color: #4f97d7; font-weight: bold;">Comp</span>  always
            <span style="color: #4f97d7; font-weight: bold;">Pass</span>  keep
            <span style="color: #4f97d7; font-weight: bold;">Fail</span>  keep
            <span style="color: #4f97d7; font-weight: bold;">ZFail</span> IncrementSaturate
        }
</pre>
</div></li>
<li>Write Depth Off, DepthTest LEqual, Cull Back;  渲染点光源对应的球，未通过深度测试的像素，Stencil 值减 1。<br /></li>
</ol></li>
<li><p>
Depth Aways, Cull Front; Stencil 如下; 渲染点光源对应的球。<br />
Tips: 此处 Cull Front 来处理摄像机在点光源球内的情况。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">     <span style="color: #4f97d7; font-weight: bold;">Stencil</span>
     {
         <span style="color: #4f97d7; font-weight: bold;">Ref</span>       0
         <span style="color: #4f97d7; font-weight: bold;">ReadMask</span>  8
         <span style="color: #4f97d7; font-weight: bold;">WriteMask</span> 8
         <span style="color: #4f97d7; font-weight: bold;">Comp</span>  Greater
         <span style="color: #4f97d7; font-weight: bold;">Pass</span>  keep
         <span style="color: #4f97d7; font-weight: bold;">Fail</span>  keep
         <span style="color: #4f97d7; font-weight: bold;">ZFail</span> keep
     }
</pre>
</div></li>
</ol>

<p>
详细的原理解释可以参考下面的链接：<br />
</p>
<ul class="org-ul">
<li><a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
</ul>

<p>
Unity Stencil 对 8 位模板值每位的分配如下：<br />
</p>
<ol class="org-ol">
<li>Bit #7 标记非背景的对象<br /></li>
<li>Bit #6 标记非 lightmapped 对象<br /></li>
<li>Bit #5 Unity 未使用<br /></li>
<li>Bit #4 用于光照体的 Culling<br /></li>
<li>Bit #1-3 用于 light layer culling mask<br /></li>

<li><a href="https://docs.unity3d.com/Manual/SL-Stencil.html">https://docs.unity3d.com/Manual/SL-Stencil.html</a><br /></li>
</ol>
</div>
</div>
<div id="outline-container-org1d96940" class="outline-6">
<h6 id="org1d96940">Spotlights</h6>
<div class="outline-text-6" id="text-org1d96940">
<p>
因为方向光可以影响到所有的物体，因此通过绘制全屏的矩形来实现方向光照明。SpotLight 只会影响其锥形范围内的物体，通常不需要为整个屏幕像素计算 SpotLight，通过绘制一个包含了 SpotLight 的金字塔来实现 SpotLight 照明。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org461675e"></a>像素对应的世界坐标位置<br />
<div class="outline-text-7" id="text-org461675e">
<div class="org-src-container">
<pre class="src src-shader">  unity_v2f_deferred <span style="color: #bc6ec5; font-weight: bold;">vert_deferred</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>)
  {
      unity_v2f_deferred o;
      o.pos = UnityObjectToClipPos(vertex);
      o.uv = ComputeScreenPos(o.pos);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#20174;&#36879;&#35270;&#25668;&#20687;&#26426;&#21407;&#28857;&#21040;&#20687;&#32032;&#23545;&#24212;&#30340;&#39030;&#28857;&#30340;&#23556;&#32447;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// TODO Unity Camera Space&#21644;OpenGL&#24815;&#20363;&#30456;&#21516;&#65292;&#21363;Camera&#30340;forward&#26041;&#21521;&#20026;Z&#36724;&#30340;&#36127;&#26041;&#21521;&#65292;&#22240;&#27492;&#65292;&#27492;&#22788;&#38656;&#35201;&#21453;&#21521;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html</span>
      o.ray = UnityObjectToViewPos(vertex) * <span style="color: #ce537a; font-weight: bold;">float3</span>(-1,-1,1);

      <span style="color: #2aa1ae; background-color: #292e34;">// normal contains a ray pointing from the camera to one of near plane's</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// corners in camera space when we are drawing a full screen quad.</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// Otherwise, when rendering 3D shapes, use the ray calculated here.</span>
      o.ray = <span style="color: #4f97d7;">lerp</span>(o.ray, normal, <span style="color: #7590db;">_LightAsQuad</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga61f9dc" class="outline-6">
<h6 id="orga61f9dc">Q&amp;A</h6>
<div class="outline-text-6" id="text-orga61f9dc">
</div>
<ul class="org-ul">
<li><a id="orgc156395"></a>为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？<br />
<div class="outline-text-7" id="text-orgc156395">
<p>
参考有道云笔记 Unity Source Code.md，可以看出 Directional 对应的四边形的顶点 Position 数据为(0,0,nearPlane) (0,1,nearPlane) (1,1,nearPlane) (1,0,nearPlane)。绘制该矩形使用的矩阵为正交矩阵。这四个顶点经过正交矩阵变换后就是屏幕上 4 个角的点，nearPlane 对应 4 个角经过透视投影变换后也为屏幕上 4 个角的点。<br />
</p>
</div>
</li>

<li><a id="org2cde6f0"></a>为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？<br />
<div class="outline-text-7" id="text-org2cde6f0">
<p>
DeferredShading 为了不覆盖之前 ColorBuffer 中的内容，其混合模式使用了 Blend One One, 所以当 DeferredShading 返回 0 时，其实显示的是之前绘制的内容。<br />
</p>
</div>
</li>
<li><a id="org64e5aa0"></a>为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？<br />
<div class="outline-text-7" id="text-org64e5aa0">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// ForwardShading</span>
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySpotCookie</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> lightCoord)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;uv&#38656;&#35201;&#20559;&#31227;0.5</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB</span>, lightCoord.xy / lightCoord.w + 0.5).w;
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredShading</span>
<span style="color: #bc6ec5;">  #if</span> defined(SPOT)
    <span style="color: #ce537a; font-weight: bold;">float4</span> uvCookie = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #ce537a; font-weight: bold;">float4</span>(worldPos, 1));
    uvCookie.xy /= uvCookie.w;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#27492;&#22788;uv&#19981;&#38656;&#35201;&#20559;&#31227;0.5 Unity&#22312;&#24341;&#25806;&#23618;&#35745;&#31639;unity_WorldToLight&#26102;&#32771;&#34385;&#20102;uv&#30340;&#20559;&#31227;&#65292;&#27492;&#22788;&#23601;&#19981;&#38656;&#35201;&#36827;&#34892;&#35745;&#31639;&#20102;&#12290;</span>
    atten *= tex2Dbias(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #ce537a; font-weight: bold;">float4</span>(uvCookie.xy, 0, -8)).w;
    atten *= uvCookie.w &lt; 0;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_DEPTH)
      shadowed = <span style="color: #a45bad;">true</span>;
      sAtten = CalcSAtten(sFade, worldPos);
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">  #else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc37a62e" class="outline-5">
<h5 id="orgc37a62e">Static Lighting</h5>
<div class="outline-text-5" id="text-orgc37a62e">
</div>
<div id="outline-container-org6b7ad23" class="outline-6">
<h6 id="org6b7ad23">Lightmapping 光照贴图</h6>
<div class="outline-text-6" id="text-org6b7ad23">
</div>
<ul class="org-ul">
<li><a id="orga9799d3"></a>简介<br />
<div class="outline-text-7" id="text-orga9799d3">
<p>
计算光照是比较昂贵的开销。虽然延迟渲染允许我们使用很多灯光，但是阴影依然是一个限制因素。如果我们的场景是动态的，我们无法避免这些计算。但是如果灯光和场景不会改变，我们就可以计算一次灯光后重用它。这样我们就可以放置很多灯光在场景中，而不需要在运行时渲染这些灯光。我们也可以使用区域灯光，这种灯光只能在烘培光照贴图的情况下使用。<br />
</p>
</div>
</li>
<li><a id="org2553123"></a>Unity 中使用光照贴图的步骤<br />
<div class="outline-text-7" id="text-org2553123">
<ol class="org-ol">
<li>把灯光的模式从 Realtime 切换为 Baked<br />
灯光一共有三种模式<br />
<ul class="org-ul">
<li>Realtime 实时灯光<br /></li>
<li>Baked 烘培灯光<br /></li>
<li>Mixed 混合灯光(既用于实时光照计算，又用于烘培光照计算)<br /></li>
</ul></li>
<li>在 Lighting Setting 中勾选 Baked Global Illumination.设置 Lighting Mode 为 Baked Indirect<br />
Lighting Mode 一共有三种模式<br />
<ul class="org-ul">
<li>Baked Indirect <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html">https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html</a><br /></li>
<li>Shadowmask <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html</a><br /></li>
<li>Subtractive <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html</a><br /></li>
</ul></li>
<li>将场景中固定不变的物体标记为 Lightmap Static<br />
MeshRenderer 组件的 Inspector 窗口中有一个 Lightmap Static 勾选框，其修改的就是 Lightmap Static 标记<br /></li>
</ol>

<p>
当场景中只有 Baked 模式的灯光时，光照贴图提供的光照要比实时光照效果暗一些。这是因为烘培的光照贴图只有 diffuse 光照，没有 specular 光照。specular 光照依赖于视角，即 specular 和摄像机方向相关，通常来说摄像机是可变的，所以无法在光照贴图中包含摄像机相关信息。这种限制意味着，光照贴图适用于微弱的光照和不闪亮(黯淡)的表面，不适用于强烈的光照和闪耀的表面。如果你需要 specular 光照，你必须使用实时光照。所以通常你需要混合使用烘培和实时光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org21c4514"></a>Light=Baked LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Baked 模式）<br />
<div class="outline-text-8" id="text-org21c4514">
<p>
lightmapper 会将直接光和间接光都烘培到光照贴图中。此时，引擎向 shader 中传递的_LightColor0 值为(0,0,0,0)，所以实时调节灯光强度，不会有效果。<br />
这种模式下，无论场景中有多少灯光，运行时，只渲染一次物体。此时场景中没有实时光，此时不需要渲染阴影贴图，观察到的阴影效果是光照贴图中的颜色信息造成的。<br />
</p>
</div>
</li>
<li><a id="org28e9d03"></a>Light=Mixed LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Mixed 模式）<br />
<div class="outline-text-8" id="text-org28e9d03">
<p>
lightmapper 只会将间接光烘培到光照贴图中，所以该模式下的光照贴图比 Baked 模式下的要暗。此时，引擎会将正确的_LightColor0 传给 shader，所以实时调节灯光强度，会有效果（只会对直接光照有效果）。<br />
此时场景中有实时光，此时需要渲染阴影贴图，并且静态物体和动态物体都需要绘制阴影贴图。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgea258a8"></a>Lightmapping Settings<br />
<div class="outline-text-7" id="text-orgea258a8">
<p>
Lightmapper 有两种<br />
</p>
<ul class="org-ul">
<li>Enlighten<br /></li>
<li>Progressive 该方式会增量式生成 lightmaps，会优先生成当前 scene view 可见的物体的 lightmap，这对于编辑是比较方便的。<br /></li>
</ul>

<p>
Directional Mode 有两种<br />
</p>
<ul class="org-ul">
<li>Directional Mode 生成两张 lightmap 贴图，一张存储物体接收到的光亮度和颜色。另一张存储主要光照的方向，以及主要光照在所有光照中占的比例。<br /></li>
<li>Non-Direction<br /></li>
<li><a href="https://docs.unity3d.com/Manual/LightmappingDirectional.html">https://docs.unity3d.com/Manual/LightmappingDirectional.html</a><br /></li>
</ul>

<p>
Ambient Occlusion : 它是间接光照在角落和褶皱处的阴影。它是一种人为增强效果，可以提升深度感。Ambient Occlusion 单单基于表面的隐藏程度，其不会考虑光照的真实路径。所以，和自发光表面结合使用时，会有明显错误。<br />
</p>
</div>
</li>
<li><a id="org22955bc"></a>Indirect Light<br />
<div class="outline-text-7" id="text-org22955bc">
<p>
烘培光照会考虑光照在多个表面的弹射，光子的每次弹射，都会损失一些能量，并且会被交互的材质修改颜色。Unity 在烘培间接光照时，都会考虑这些因素。<br />
</p>
</div>
</li>

<li><a id="org046d6e5"></a>Transparency<br />
<div class="outline-text-7" id="text-org046d6e5">
<p>
对于单面透明物体，需要创建 Lightmap Parameters，将 IsTransparent 参数指定为 True，将 Lightmap Parameters 指定给单面透明物体。半透明物体会让间接光照通过，而不透明物体会阻挡间接光照。<br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_error.png" alt="01_16sl_transparentObj_bake_error.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_correct.png" alt="01_16sl_transparentObj_bake_correct.png" /><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgaf7c875" class="outline-6">
<h6 id="orgaf7c875">使用光照贴图</h6>
<div class="outline-text-6" id="text-orgaf7c875">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#24403;&#20351;&#29992;lightmaps&#21518;&#65292;unity &#23558;&#19981;&#20250;&#21253;&#21547;&#39030;&#28857;&#20809;&#29031;&#35745;&#31639;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON

  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmap uv</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> tangentToWorld[3] : <span style="color: #a45bad;">TEXCOORD2</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos : <span style="color: #a45bad;">TEXCOORD5</span>;
      UNITY_SHADOW_COORDS(6)
      DECLARE_LIGHT_COORDS(7)
<span style="color: #bc6ec5;">  #ifdef</span> VERTEXLIGHT_ON
      <span style="color: #ce537a; font-weight: bold;">float3</span> vertexLightColor : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">  #elif</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmapUV</span>
      <span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">  #endif</span>
  };

  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>

<span style="color: #bc6ec5;">  #if</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#22240;&#20026; lightmap&#30340;transformation&#27809;&#26377;&#34987;&#23450;&#20041;&#20026;unity_Lightmap_ST&#65292;&#25152;&#20197;&#26080;&#27861;&#20351;&#29992;TRANSFORM_TEX&#23439;</span>
      o.lightmapUV = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir) {
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #if</span> defined(VERTEXLIGHT_ON)
      indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// lightmap &#21644;&#39030;&#28857;&#20809;&#29031;&#19981;&#20250;&#21516;&#26102;&#20986;&#29616;</span>
      indirectLight.diffuse = 0;
      <span style="color: #2aa1ae; background-color: #292e34;">// DecodeLightmap &#20250;&#22788;&#29702;&#20809;&#29031;&#36148;&#22270;&#19981;&#21516;&#26684;&#24335;</span>
      indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">      #else</span>
      indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #endif</span>

      <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org384601f" class="outline-6">
<h6 id="org384601f">生成光照贴图</h6>
<div class="outline-text-6" id="text-org384601f">
</div>
<ul class="org-ul">
<li><a id="orgabab4e8"></a>lightmapper 默认规则<br />
<div class="outline-text-7" id="text-orgabab4e8">
<p>
lightmapper 不会使用实时渲染管线，所以它并不会使用我们的自己的 shader 来渲染 lightmap。<br />
lightmapper 会通过材质的 RenderType 来决定怎样对待物体表面:<br />
</p>
<ul class="org-ul">
<li>RenderType="Opaque" 不透明物体<br /></li>
<li>RenderType="Transparent" 半透明物体<br /></li>
<li>RenderType="TransparentCutout" 透贴型物体<br /></li>
</ul>
</div>
</li>

<li><a id="org2138bd1"></a>通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper<br />
<div class="outline-text-7" id="text-org2138bd1">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">Pass</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">Name</span> <span style="color: #2d9574;">"META-MyLightmapping"</span>
      <span style="color: #4f97d7; font-weight: bold;">Tags</span>
      {
          <span style="color: #2aa1ae; background-color: #292e34;">// LightMode &#24517;&#39035;&#20026; Meta</span>
          <span style="color: #2d9574;">"LightMode"</span>=<span style="color: #2d9574;">"Meta"</span>
      }
      <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
      <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">      #include</span> <span style="color: #2d9574;">"MyStaticLighting_Lightmapping.cginc"</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//#include "MyStaticLighting_Lightmapping_Test.cginc"</span>
<span style="color: #bc6ec5;">      #pragma</span> vertex vert
<span style="color: #bc6ec5;">      #pragma</span> fragment frag
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_METALLICMAP_ON</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>
<span style="color: #bc6ec5;">      #pragma</span> shader_feature <span style="color: #7590db;">_ALBEDODETAIL_ON</span>
      <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
  }

<span style="color: #bc6ec5;">  #ifndef</span> MY_STATICLIGHTING_LIGHTMAPPING
<span style="color: #bc6ec5;">  #define</span> MY_STATICLIGHTING_LIGHTMAPPING

<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">"UnityPBSLighting.cginc"</span>
<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">"UnityMetaPass.cginc"</span>

  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
  };

  <span style="color: #2aa1ae; background-color: #292e34;">//#define _MainTex _MainTexM</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//#define _MainTex_ST _MainTexM_ST</span>

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailTex</span>;
  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailTex_ST</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailMask</span>;
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_EmissiveMap</span>;
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Smoothness</span>;
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Metallic</span>;
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MetallicSmoothnessMap</span>;

  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv1.xy, unity_LightmapST, unity_LightmapST);

      <span style="color: #2aa1ae; background-color: #292e34;">//v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//o.pos = UnityObjectToClipPos(v.vertex);</span>

      o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(v2f i)
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Color</span>.a;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetDetailMask</span>(v2f i)
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_DetailMask</span>, i.uv.zw);
  }

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlbedo</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> albedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy);
      albedo *= <span style="color: #7590db;">_Color</span>;
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_ALBEDODETAIL_ON</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> detailAlbedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailTex</span>, i.uv.zw);
      albedo = <span style="color: #4f97d7;">lerp</span>(albedo, albedo*detailAlbedo*unity_ColorSpaceDouble, GetDetailMask(i));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
  }
  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> emissive = 0;
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_EMISSION</span>)
      emissive = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_EmissiveMap</span>, i.uv);
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #4f97d7;">dot</span>(emissive, emissive) &lt; 0.001)
      {
          emissive = <span style="color: #7590db;">_EmissionColor</span>;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          emissive = emissive * <span style="color: #7590db;">_EmissionColor</span>;
      }
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> emissive;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetMetallic</span>(v2f i)
  {
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).r * <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(v2f i)
  {
<span style="color: #bc6ec5;">      #if</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>) &amp;&amp; defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #elif</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span>)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : SV_TARGET
  {
      UnityMetaInput o;
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Emission = float3(0, 0, 1);</span>
      o.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Albedo = float3(1, 0, 0);</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> oneMinusReflectivity;
      o.Albedo = DiffuseAndSpecularFromMetallic(GetAlbedo(i), GetMetallic(i), o.SpecularColor, oneMinusReflectivity);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#25552;&#20379;&#30340;&#38388;&#25509;&#20809;&#29031;&#20250;&#36234;&#22810;, &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#20250;&#36234;&#22810;&#21453;&#23556;Specular&#20809;&#29031;&#20986;&#21435;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> roughness = SmoothnessToRoughness(GetSmoothness(i)) * 0.5;
      o.Albedo += o.SpecularColor * roughness;
      <span style="color: #2aa1ae; background-color: #292e34;">//o.Albedo = GetAlbedo(i);</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// Specular&#21644;&#35270;&#35282;&#30456;&#20851;&#65292;&#26080;&#27861;&#28888;&#22521;SpecularColor</span>
      o.SpecularColor = 0;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(o);
  }

  <span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span> (UnityMetaInput IN)
  {
      <span style="color: #ce537a; font-weight: bold;">half4</span> res = 0;
<span style="color: #bc6ec5;">      #if</span> !defined(EDITOR_VISUALIZATION)
      <span style="color: #2aa1ae; background-color: #292e34;">// MetaPass &#20250;&#34987;&#35843;&#29992;&#22810;&#27425;, &#20351;&#29992;unity_MetaFragmentControl &#26469;&#25511;&#21046;&#36820;&#22238;Albedo&#36824;&#26159;Emission</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaFragmentControl.x)
      {
          res = <span style="color: #ce537a; font-weight: bold;">half4</span>(IN.Albedo,1);
          <span style="color: #2aa1ae; background-color: #292e34;">// d3d9 shader compiler doesn't like NaNs and infinity.</span>
          unity_OneOverOutputBoost = <span style="color: #4f97d7;">saturate</span>(unity_OneOverOutputBoost);
          <span style="color: #2aa1ae; background-color: #292e34;">// Apply Albedo Boost from LightmapSettings.</span>
          res.rgb = <span style="color: #4f97d7;">clamp</span>(<span style="color: #4f97d7;">pow</span>(res.rgb, unity_OneOverOutputBoost), 0, unity_MaxOutputValue);
      }
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaFragmentControl.y)
      {
          <span style="color: #ce537a; font-weight: bold;">half3</span> emission;
          <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_UseLinearSpace)
          emission = IN.<span style="color: #4f97d7; font-weight: bold;">Emission</span>;
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          emission = GammaToLinearSpace(IN.<span style="color: #4f97d7; font-weight: bold;">Emission</span>);

          res = <span style="color: #ce537a; font-weight: bold;">half4</span>(emission, 1.0);
      }
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> res;
  }
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</li>
<li><a id="orga55b5d4"></a>半透明物体烘培<br />
<div class="outline-text-7" id="text-orga55b5d4">
<p>
对于透明物体，lightmapper 会通过材质的_Color 属性值的 a 分量，以及_MainTex 贴图的 a 分量来确定透明度，所以不能使用_MainColor _Tint 等代替_Color，也不能使用_DiffuseTex _Albedo 等代替_MainTex。lightmapper 会通过材质的 _Cutoff 属性值，作为透贴门槛值， 所以不能使用_AlphaCutoff 等属性代替_Cutoff。<br />
</p>

<p>
Tips:<br />
</p>
<ul class="org-ul">
<li>lightmapper 不会调用 shader 中的函数来获取 Alpha 值。<br /></li>
<li>Blend Mode 不会影响烘培结果<br /></li>
<li>RenderQueue 不会影响烘培结果<br /></li>
<li>2020.3.17 版本中，[MainTexture] [MainColor] 对于不透明烘培是没作用的。但是，影响半透明物体的烘培。<br /></li>
<li>使用 [MainTexture] [MainColor]， 此时贴图名称可以为 _BaseMap 以外的其他名称。但是，SceneView 中 Baked Global Illumination/Albedo, 依然会依赖 _BaseMap, _BaseColor 名字。<br /></li>
<li>2020.3.17 版本中，[HideInInspector] _Color("Base Color", Color) = (1, 1, 1, 1) 对于烘培也是没作用的。但是，烘培系统会读取这些数据，如果不存在会有错误日志。(不透明物体不会报错)<br /></li>
</ul>

<p>
Rendering/16StaticLighting/16StaticLighting_My_Baked_Transparent 该场景可以测试透明物体的烘培。将 MyStaticLighting.shader 中 Property 中的_Color 用_ColorM 代替，开启 TEST_META_PROP_NAME 宏定义，就可以测试上面规则。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(TEST_META_PROP_NAME)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ColorM</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_Color</span> <span style="color: #7590db;">_ColorM</span>
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTexM</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTexM_ST</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_MainTex</span> <span style="color: #7590db;">_MainTexM</span>
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_MainTex_ST</span> <span style="color: #7590db;">_MainTexM_ST</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColorM</span>;
<span style="color: #bc6ec5;">    #define</span> <span style="color: #7590db;">_EmissionColor</span> <span style="color: #7590db;">_EmissionColorM</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<p>
<img src="./UnityCatLikeCoding/01_16sl_MainTexM_result.png" alt="01_16sl_MainTexM_result.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_MainTex_result.png" alt="01_16sl_MainTex_result.png" /><br />
</p>

<ul class="org-ul">
<li>Baked Transparency <a href="https://catlikecoding.com/unity/tutorials/custom-srp/baked-light/">https://catlikecoding.com/unity/tutorials/custom-srp/baked-light/</a><br /></li>
</ul>
</div>
</li>
<li><a id="org95a5fb5"></a>烘培参数<br />
<div class="outline-text-7" id="text-org95a5fb5">
<p>
Lightmapper/Max Bounces 设置为 0 可以只烘培直接光照<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5e6b790" class="outline-6">
<h6 id="org5e6b790">Directional Lightmaps 具有方向的光照贴图</h6>
<div class="outline-text-6" id="text-org5e6b790">
</div>
<ul class="org-ul">
<li><a id="orge69ea05"></a>简介<br />
<div class="outline-text-7" id="text-orge69ea05">
<p>
lightmapper 只使用了顶点的几何数据，它没有考虑法线贴图数据。光照贴图的精度太低了，无法捕捉到传统法线贴图提供的细节。这意味着静态光照将会比较平。<br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-realtime.png" alt="01_16sl_normal-maps-realtime.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-lightmapped.png" alt="01_16sl_normal-maps-lightmapped.png" /><br />
上面两张图是，使用法线贴图的情况下，实时光照和烘培光照的效果对比。可以看到在烘培光照中，法线贴图的影响几乎没有，画面中微弱的法线效果来自环境反射。<br />
</p>
</div>
</li>

<li><a id="orgf1fa910"></a>方向性<br />
<div class="outline-text-7" id="text-orgf1fa910">
<p>
将 Directional Mode 设置为 Directional，就可以让法线贴图和烘培的光照协同工作。 在 Lighting/Lightmapping Settings/DirecionalMode 中，可以设置 Directional Mode = Directional。<br />
Directional Mode=Directional 时，unity 会生成两张光照贴图，一张就像之前一样的光照强度贴图，用于存储光照强度。新的另一张为光照方向贴图，用于存储最多的烘培光照的来源方向。<br />
</p>

<p>
下图为 NonDirectional 和 Directional 模式的对比：<br />
<img src="./UnityCatLikeCoding/01_16sl_non-directional.jpg" alt="01_16sl_non-directional.jpg" /><br />
<img src="./UnityCatLikeCoding/01_16sl_directional.jpg" alt="01_16sl_directional.jpg" /><br />
</p>
</div>
</li>

<li><a id="orgd0a6c54"></a>使用烘培的方向贴图<br />
<div class="outline-text-7" id="text-orgd0a6c54">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// &#24320;&#21551;&#28888;&#22521;&#26041;&#21521;&#36148;&#22270;&#30340;&#23439;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED


  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
<span style="color: #bc6ec5;">      #ifdef</span> VERTEXLIGHT_ON
      indirect.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">      #else</span>
      indirect.diffuse = 0;
<span style="color: #bc6ec5;">      #endif</span>
      indirect.specular = 0;


<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS) || defined(DEFFERRED_PASS)
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
              <span style="color: #2aa1ae; background-color: #292e34;">//indirect.diffuse = UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV);</span>
              indirect.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">              #if</span> defined(DIRLIGHTMAP_COMBINED)
              <span style="color: #2aa1ae; background-color: #292e34;">// &#37319;&#26679;&#28888;&#22521;&#30340;&#26041;&#21521;&#36148;&#22270;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap,i.lightmapUV);
              <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;Half Lambert&#35745;&#31639;Diffuse</span>
              indirect.diffuse = DecodeDirectionalLightmap(indirect.diffuse, lightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #else</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeDirectionalLightmap (<span style="color: #ce537a; font-weight: bold;">half3</span> color, <span style="color: #ce537a; font-weight: bold;">fixed4</span> dirTex, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
  <span style="color: #2aa1ae; background-color: #292e34;">// In directional (non-specular) mode Enlighten bakes dominant light</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// direction in a way, that using it for half Lambert and then dividing</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// by a "rebalancing coefficient" gives a result close to plain diffuse</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// response lightmaps, but normalmapped.</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// Note that dir is not unit length on purpose. Its length is</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// "directionality", like for the directional specular lightmaps.</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> halfLambert = <span style="color: #4f97d7;">dot</span>(normalWorld, dirTex.xyz - 0.5) + 0.5;

    <span style="color: #4f97d7; font-weight: bold;">return</span> color * halfLambert / <span style="color: #4f97d7;">max</span>(1e-4h, dirTex.w);
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc5cc1b3" class="outline-6">
<h6 id="orgc5cc1b3">Light Probes</h6>
<div class="outline-text-6" id="text-orgc5cc1b3">
<p>
Lightmaps 只对静态物体起作用，对动态物体不起作用。这会导致动态物体无法融入烘培光照的场景。Unity 使用 LightProbe 来存储其所在点的烘培光照信息，LightProbe 没有使用贴图存储光照信息，其使用 Spherical Harmonics 存储这些信息。<br />
场景中的动态物体会使用 LightProbe 存储的烘培光照信息来取代全局的环境数据。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd4f3ea6"></a>为什么 SceneView 中不显示 LightProbe？<br />
<div class="outline-text-7" id="text-orgd4f3ea6">
<p>
SceneView 下 Gizmos/3D Icon 被缩放到最小了。<br />
</p>
</div>
</li>
<li><a id="org524c0c7"></a>为什么 LightProb 对于动态物体不生效？<br />
<div class="outline-text-7" id="text-org524c0c7">
<p>
两个 LightProb 是无作用的，需要让 LightProbe 形成网才能生效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9cd159e" class="outline-6">
<h6 id="org9cd159e">Q&amp;A</h6>
<div class="outline-text-6" id="text-org9cd159e">
</div>
<ul class="org-ul">
<li><a id="orgbaf04b5"></a>使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？<br />
<div class="outline-text-7" id="text-orgbaf04b5">
<ul class="org-ul">
<li>关于 3D 模型的二套 UV <a href="https://zhuanlan.zhihu.com/p/83322397">https://zhuanlan.zhihu.com/p/83322397</a><br /></li>
</ul>
</div>
</li>
<li><a id="org56503a8"></a>什么错误导致 lightmap 中不包含 Emission 颜色？<br />
<div class="outline-text-7" id="text-org56503a8">
<ul class="org-ul">
<li>缺乏 Meta Pass<br /></li>
<li><p>
Meta Pass 的 Fragment 没有按照如下方式输出<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : SV_TARGET
    {
        UnityMetaInput surfaceData;
        surfaceData.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
        surfaceData.Albedo = GetAlbedo(i);
        surfaceData.SpecularColor = 0;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(surfaceData);
    }
</pre>
</div></li>
<li>材质的 MaterialGlobalIlluminationFlags 没设置为 BakedEmissive<br /></li>
<li><p>
vertex 着色器函数中输出的 SV_POSITION 不正确<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    v2f_meta <span style="color: #bc6ec5; font-weight: bold;">vert_test</span>(VertexInput v)
    {
        v2f_meta o;
        <span style="color: #2aa1ae; background-color: #292e34;">//o.pos = UnityObjectToClipPos(v.vertex);  // &#36825;&#26679;&#35745;&#31639;&#24471;&#20986;&#30340;pos&#26159;&#38169;&#35823;&#30340;&#12290;</span>
        o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
        o.uv = TexCoords(v);
        <span style="color: #4f97d7; font-weight: bold;">return</span> o;
    }
</pre>
</div></li>
<li>unity lightmap 数据清除有 bug，清除 lightmap 后，隐藏一个物体，再烘培，检查数据是否正确。<br />
lightmap 缓存极其不稳定，有时候隐藏了烘培依然不可以，需要隐藏一个其他物体再来一次。<br /></li>
<li><del>frag 着色器的 out 标记 SV_TARGET 是否全部使用大写</del> SV_Target 也是可以的<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6e496a9"></a>参考资料<br />
<div class="outline-text-8" id="text-org6e496a9">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/MetaPass.html">https://docs.unity3d.com/Manual/MetaPass.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>

<li><a id="org3e85989"></a>Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数<br />
<div class="outline-text-7" id="text-org3e85989">
<p>
宏定义写错了 DEFERRED_PASS 写成了 DEFFERRED_PASS。导致采样 unity_Lightmap unity_LightmapInd 的代码没有执行到，所以引擎没将图片传给 GPU。<br />
</p>
</div>
</li>
<li><a id="org0aa2170"></a>烘培点光源，光穿过了不透明物体<br />
<div class="outline-text-7" id="text-org0aa2170">
<p>
光源阴影为 None 导致该问题，需要将点光源的阴影类型设置为 Hard 或 Soft。<br />
方向光把阴影设置为 NoneShaodws 也会穿过不透明物体。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org80c0588" class="outline-5">
<h5 id="org80c0588">Mixed Lighting</h5>
<div class="outline-text-5" id="text-org80c0588">
</div>
<div id="outline-container-org38a9f1d" class="outline-6">
<h6 id="org38a9f1d">烘培光照贴图的优缺点</h6>
<div class="outline-text-6" id="text-org38a9f1d">
</div>
<ul class="org-ul">
<li><a id="orgbc6c1be"></a>缺点<br />
<div class="outline-text-7" id="text-orgbc6c1be">
<ul class="org-ul">
<li>无法烘培高光<br /></li>
<li>烘培光照只能通过 LightProbe 对动态物体产生影响<br /></li>
<li>烘培光照无法生成实时阴影<br /></li>
</ul>
</div>
</li>
<li><a id="org42f0f22"></a>优点<br />
<div class="outline-text-7" id="text-org42f0f22">
<ul class="org-ul">
<li>烘培光照包含间接光照，实时光照不包含间接光照。间接光照可以极大提升场景的真实感。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgff7809f" class="outline-6">
<h6 id="orgff7809f">Baking Indirect Light</h6>
<div class="outline-text-6" id="text-orgff7809f">
<p>
实时光照和烘培光照各有优缺点，通过下面方式可以将实时光照和烘培光照结合使用。<br />
</p>
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Baked Indirect<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，烘培光照贴图时会发生两个变化：<br />
</p>
<ol class="org-ol">
<li>lightmapper 只会将间接光照存储到光照贴图中，所以此时的光照贴图比之前要暗一些。<br /></li>
<li>lightmap 只用于为静态物体提供间接光照，静态物体的直接光照也由场景中灯光实时提供；动态物体间接光由 light probe 提供，直接光照由场景中灯光实时提供。<br /></li>
</ol>

<p>
注意:<br />
在上面的设置下，静态物体也需要实时画阴影贴图。这种模式相当于实时光照的工作再加上光照贴图实现的间接光照，所以这种模式是比较消耗性能的。<br />
</p>
</div>
</div>
<div id="outline-container-org80600cf" class="outline-6">
<h6 id="org80600cf">Using a Shadowmask</h6>
<div class="outline-text-6" id="text-org80600cf">
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Baked<br /></li>
</ol>
<p>
这样设置时，并不会生产 shadowmask，此时相当于完全烘培 （相当于 Light=Baked LightingMode=BakedIndirect 设置下的烘培）。<br />
</p>

<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，间接光照和 mixed lights 的阴影 attenuation 都会存储到光照贴图中，阴影会存储到单独的一张 shadowmask 贴图中。<br />
如果只有 1 盏灯那么 shadowmask 只会占 r 通道，shadowmask 最多 4 个通道，所以最多可以支持 4 盏灯。<br />
</p>

<p>
这种模式比 MixedLight+BakedIndirect 的优势在于静态物体不需要实时画阴影。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4c7651c"></a>Sampling the Shadowmask<br />
<div class="outline-text-7" id="text-org4c7651c">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowFade</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">float</span> atten)
  {
<span style="color: #bc6ec5;">  #if</span> HANDLE_SHADOWS_BLENDING_IN_GI
      <span style="color: #ce537a; font-weight: bold;">float</span> viewZ = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos, UNITY_MATRIX_V[2].xyz);
      <span style="color: #ce537a; font-weight: bold;">float</span> shadowFadeDistance = UnityComputeShadowFadeDistance(i.worldPos, viewZ);
      <span style="color: #ce537a; font-weight: bold;">float</span> sFade = UnityComputeShadowFade(shadowFadeDistance);
      <span style="color: #ce537a; font-weight: bold;">float</span> bakedAtten = UnitySampleBakedOcclusion(i.lightmapUV, i.worldPos);
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(atten, bakedAtten, sFade);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// unity_OcclusionMaskSelector &#35813;&#21521;&#37327;&#21482;&#26377;&#19968;&#20010;&#20998;&#37327;&#20250;&#34987;&#35774;&#32622;&#20026;1&#65292;&#29992;&#20110;&#21305;&#37197;&#24403;&#21069;&#34987;&#28210;&#26579;&#30340;&#28783;&#20809;</span>
  <span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySampleBakedOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos) {
<span style="color: #bc6ec5;">  #if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
          <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D_SAMPLER(unity_ShadowMask, unity_Lightmap, lightmapUV.xy);
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(<span style="color: #4f97d7;">dot</span>(rawOcclusionMask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0;
<span style="color: #bc6ec5;">  #endif</span>
  }

  <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> UnityMixRealtimeAndBakedShadows (<span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> bakedShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> fade)
  {
  <span style="color: #2aa1ae; background-color: #292e34;">// &#26080;&#23454;&#21160;&#24577;&#38452;&#24433;&#26102;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
<span style="color: #bc6ec5;">  #if</span> !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; !defined(SHADOWS_CUBE)
      <span style="color: #4f97d7; font-weight: bold;">return</span> bakedShadowAttenuation;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #if</span> defined (LIGHTMAP_SHADOW_MIXING)
          realtimeShadowAttenuation = <span style="color: #4f97d7;">saturate</span>(realtimeShadowAttenuation + fade);
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">min</span>(realtimeShadowAttenuation, bakedShadowAttenuation);
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// shadowFadeDistance&#33539;&#22260;&#20869;&#65292;&#20351;&#29992;sFadeFactor&#22312;&#23454;&#26102;&#38452;&#24433;&#21644;&#28888;&#22521;&#38452;&#24433;&#20043;&#38388;&#25554;&#20540;</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// &#36229;&#20986;shadowFadeDistance&#21518;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(realtimeShadowAttenuation, bakedShadowAttenuation, fade);
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #else</span> <span style="color: #2aa1ae; background-color: #292e34;">//no shadowmask &#27809;&#26377;&#20351;&#29992;shadowmask&#26102;&#65292;&#20351;&#29992;&#23454;&#26102;&#38452;&#24433;atten+shadowFadeFactor</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(realtimeShadowAttenuation + fade);
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="orgecaec76"></a>Support Deferred Path<br />
<div class="outline-text-7" id="text-orgecaec76">
<p>
DeferredShading 中将 ShadowMask 写入到 GBuffer4 中<br />
DeferredLighting 中读取 GBuffer4 内容，对直接光照进行衰减<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredShading (MixedLighting.shader)</span>

  <span style="color: #4f97d7; font-weight: bold;">struct</span> frag_output
  {
<span style="color: #bc6ec5;">  #if</span> defined(DEFERRED_PASS)
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
          <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer4 : <span style="color: #a45bad;">SV_Target4</span>;
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">  #endif</span>
  };

  frag_output <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i)
  {
      frag_output output;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWSMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
          <span style="color: #ce537a; font-weight: bold;">float2</span> shadowUV = 0;
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
          shadowUV = i.lightmapUV;
<span style="color: #bc6ec5;">          #endif</span>
          output.gBuffer4 = UnityGetRawBakedOcclusions(shadowUV, i.worldPos.xyz);
<span style="color: #bc6ec5;">      #endif</span>
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// DeferredLighting (MixedLighting_DeferredLighting.shader)</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowMaskAttenuation</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK)
      <span style="color: #ce537a; font-weight: bold;">float4</span> mask = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CameraGBufferTexture4</span>, uv);
      atten = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(mask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
  }

  UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float</span> viewZ)
  {
      UnityLight light;
      <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
      <span style="color: #ce537a; font-weight: bold;">float</span> sAtten = 1;
      <span style="color: #ce537a; font-weight: bold;">float</span> sFade = GetShadowFade(worldPos, viewZ);
      <span style="color: #ce537a; font-weight: bold;">bool</span> shadowed = <span style="color: #a45bad;">false</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #if</span> defined(SHADOWS_SHADOWMASK)
          shadowed = <span style="color: #a45bad;">true</span>;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (shadowed)
      {
          <span style="color: #ce537a; font-weight: bold;">float</span> smAtten = GetShadowMaskAttenuation(uv);
          sAtten = UnityMixRealtimeAndBakedShadows(sAtten, smAtten, sFade);
          <span style="color: #2aa1ae; background-color: #292e34;">//sAtten = saturate(sAtten + sFade);</span>
<span style="color: #bc6ec5;">          #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
<span style="color: #bc6ec5;">              #if</span> !defined(SHADOWS_SHADOWMASK)
              UNITY_BRANCH
              <span style="color: #4f97d7; font-weight: bold;">if</span> (sFade &gt; 0.99)
              {
                  sAtten = 1;
              }
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #endif</span>
      }
      light.color = <span style="color: #7590db;">_LightColor</span>.rgb * atten * sAtten;
      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }
</pre>
</div>
</div>
</li>
<li><a id="org34b4d0f"></a>Distance Shadowmask Mode<br />
<div class="outline-text-7" id="text-org34b4d0f">
<p>
Unity2017 版本之前 Distance Shadowmask 在 Lighting Setting 中设置，Unity2017 版本以及之后版本在 QualitySettings 中设置。<br />
</p>

<p>
注意：<br />
这种模式下，ShadowDistance 外使用 ShadowMask（相当于 ShadowMask 模式），ShadowDistance 内使用实时阴影（相当于 MixedLight+BakedIndirect，静态物体和动态物体都需要绘制阴影贴图，所以这种模式也是比较消耗性能的）。<br />
</p>
</div>
</li>
<li><a id="org7b9736b"></a>Multiple Lights<br />
<div class="outline-text-7" id="text-org7b9736b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">//ForwardAdd Pass &#28155;&#21152;&#22914;&#19979;&#20195;&#30721;&#65292;UNITY_LIGHT_ATTENUATION &#23601;&#21487;&#20197;&#27491;&#30830;&#24037;&#20316;&#20102;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SHADOWMASK
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0017b90" class="outline-6">
<h6 id="org0017b90">Subtractive Shadows</h6>
<div class="outline-text-6" id="text-org0017b90">
</div>
<ul class="org-ul">
<li><a id="org90bbefc"></a>简介<br />
<div class="outline-text-7" id="text-org90bbefc">
<p>
Subtractive mode 只适用于 forward path。Subtractive Mode 的理念是静态物体依然通过 lightmaps 照亮，并且同时将动态物体的阴影因素考虑进去，这是通过减低阴影区域光照贴图的亮度来实现的。这种方式不生成 Shadow Mask 贴图。<br />
Subtractive mode 只适用于一个方向光，因此只支持主方向光的阴影。<br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的 Lightmap 贴图的对比如下（由烘培 16StaticLighting_Unity 场景生成）：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su.jpg" alt="01_17ml_bi_sm_su.jpg" /><br />
</p>

<p>
Light Mode 为 Mixed，三种 Lighting Mode（BakedIndirect ShadowMask Subtractive）对应的生成阴影贴图的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_17ml_bi_sm_su_drawcall.jpg" alt="01_17ml_bi_sm_su_drawcall.jpg" /><br />
</p>

<p>
注意： LightMode 为 Mixed，Lighting Mode 为 BakedIndirect 时，静态物体依然会绘制阴影。<br />
</p>
</div>
</li>
<li><a id="orgace6736"></a>实现<br />
<div class="outline-text-7" id="text-orgace6736">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #if</span> defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">      #define</span> SUBTRACTIVE_LIGHTING 1
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>

  UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (Interpolators i)
  {
      UnityLight light;
      <span style="color: #2aa1ae; background-color: #292e34;">// Subtractive&#27169;&#24335;&#19979;&#65292;&#38745;&#24577;&#29289;&#20307;&#30340;&#30452;&#25509;&#20809;&#29031;&#37117;&#34987;&#28888;&#22521;&#21040;lightmap&#20013;&#20102;&#65292;&#19981;&#38656;&#35201;&#35745;&#31639;&#30452;&#25509;&#20809;&#29031;</span>
<span style="color: #bc6ec5;">      #if</span> defined(DEFERRED_PASS)  || SUBTRACTIVE_LIGHTING
          light.dir = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
          light.color = 0;
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">      #endif</span>

      <span style="color: #4f97d7; font-weight: bold;">return</span> light;
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// Unity&#23454;&#29616;&#20013;&#23545;&#24212;&#30340;&#20989;&#25968;&#20026;&#65306;SubtractMainLightWithRealtimeAttenuationFromLightmap</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
  {
<span style="color: #bc6ec5;">  #if</span> SUBTRACTIVE_LIGHTING
      UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
      attenuation = GetShadowFade(i, attenuation);
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = 1;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
      <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
      <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
      subtractedLight = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#25903;&#25345;ShadowStrength</span>
      subtractedLight = <span style="color: #4f97d7;">lerp</span>(subtractedLight, indirect.diffuse, <span style="color: #7590db;">_LightShadowData</span>.x);

      <span style="color: #2aa1ae; background-color: #292e34;">// &#38745;&#24577;&#29289;&#20307;&#19978;&#28888;&#22521;&#30340;&#38452;&#24433;&#20063;&#20250;&#26174;&#31034;unity_ShadowColor.rgb&#39068;&#33394;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//indirect.diffuse = indirect.diffuse;</span>

      <span style="color: #2aa1ae; background-color: #292e34;">// &#21482;&#20462;&#25913;&#21160;&#24577;&#29289;&#20307;&#22312;&#38745;&#24577;&#29289;&#20307;&#19978;&#25237;&#23556;&#30340;&#38452;&#24433;</span>
      indirect.diffuse = <span style="color: #4f97d7;">min</span>(subtractedLight, indirect.diffuse);
<span style="color: #bc6ec5;">  #endif</span>
  }

</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org35c0989" class="outline-6">
<h6 id="org35c0989">总结</h6>
<div class="outline-text-6" id="text-org35c0989">
<p>
Lighting Setting 中选中 Mixed Lighting/Baked Global Illumination 勾选框，开启离线烘培。<br />
</p>

<p>
离线烘培结果由以下 4 个配置决定：<br />
</p>
<ul class="org-ul">
<li>Lighting/Scene/LightingSetting/Mixed Lighting/Lighting Mode (BakedIndirect, Shadowmask, Subtractive)<br /></li>
<li>Lighting/Scene/LightingSetting/Lightmapping Settings/Directional Mode (Directional, Non-Directional)<br /></li>
<li>场景中 Light 的 Mode (Realtime, Baked, Mixed)<br /></li>
<li>场景中 GameObject 的 Static Mark 是否包含 Contribute GI(unity 2020 版本) | Lightmap Static(unity 2017 版本)<br /></li>
</ul>

<p>
场景中元素对烘培的贡献：<br />
</p>
<ul class="org-ul">
<li>Light:  被标记为 Realtime 的 Light 对离线烘培系统不产生任何影响。<br /></li>
<li>Object:<br />
<ul class="org-ul">
<li>动态物体不会对离线烘培系统产生任何影响。例如，烘培场景时，动态的发绿色光的球不会导致 lightmap 贴图变绿。<br /></li>
<li>离线烘培的 LightProbe 会为动态物体提供间接光照。离线烘培的 lightmap 会为静物体提供间接光照（某些情况下，还包含直接光照）。<br /></li>
</ul></li>
</ul>

<p>
使用离线烘培对渲染的影响包括一下方面：<br />
</p>
<ul class="org-ul">
<li>直接光间接光如何计算<br />
<ul class="org-ul">
<li>diffuse 如何计算<br /></li>
<li>specular 如何计算<br /></li>
</ul></li>
<li>阴影如何计算<br /></li>
</ul>

<p>
Light 对象的 Mode 为 Baked 时，Lighting Mode 任意：<br />
</p>
<ul class="org-ul">
<li>直接光和间接光都烘培，两者都在 lightmap 中。运行时，Baked Light 对动态物体不起任何作用。烘培的 LightProbe 为动态物体提供间接光照。<br /></li>
<li>无 specular。<br /></li>
<li>阴影包含在 lightmap 中。动态物体对静态物体不投影。静态物体对动态物体不投影。<br /></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mixed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BakedIndirect</td>
<td class="org-left">只烘培间接光，直接光实时计算</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">静态物体也需要实时生成阴影贴图。</td>
</tr>

<tr>
<td class="org-left">Shadowmask</td>
<td class="org-left">只烘培间接光，直接光实时计算。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">烘培 ShadowMask。静态物体不需要实时生成阴影贴图。静态物体无法在动态物体上投影</td>
</tr>

<tr>
<td class="org-left">DistanceShadowmask</td>
<td class="org-left">只烘培间接光，直接光实时计算。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">有 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">烘培 ShadowMask。远处的静态物体不需实时生成阴影贴图。近处的静态物体需实时生成阴影贴图，近处的静态物体可在动态物体上投影</td>
</tr>

<tr>
<td class="org-left">Subtractive</td>
<td class="org-left">直接光和间接光都烘培，两者都在 lightmap 中。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">无 specular。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">阴影包含在 lightmap 中。动态物体对静态物体投影，静态物体对动态物体不投影</td>
</tr>
</tbody>
</table>

<p>
Tips:<br />
烘培时设置灯光 Mode 为 Baked. 运行起来后修改 Light 的 Mode 不起作用。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Light-lightmapBakeType.html">https://docs.unity3d.com/ScriptReference/Light-lightmapBakeType.html</a><br /></li>
</ul>

<p>
下图是 Light Mode Baked VS Mixed 的对比，从图可以看出：<br />
</p>
<ul class="org-ul">
<li>Light Mode 为 Baked 时，不同 Lighting Mode 设置并不会起作用，此时 Lighting Mode 相当于 BakedIndirect。<br /></li>
<li>Light Mode 为 Mixed 时，烘培的光照贴图会变暗，因为此时只烘焙了间接光照。<br /></li>
</ul>

<div id="org5b9d877" class="figure">
<p><img src="./UnityCatLikeCoding/light_mode_baked_vs_mixed.png" alt="light_mode_baked_vs_mixed.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd0f4c60" class="outline-6">
<h6 id="orgd0f4c60">Q&amp;A</h6>
<div class="outline-text-6" id="text-orgd0f4c60">
</div>
<ul class="org-ul">
<li><a id="orga174997"></a><span class="todo TODO">TODO</span> 如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？<br />
<div class="outline-text-7" id="text-orga174997">
<p>
这样做是不正确的。<br />
</p>
</div>
</li>
<li><a id="org89f76ba"></a>烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？<br />
<div class="outline-text-7" id="text-org89f76ba">
<p>
LightMode 为 Mixed，LightingMode 为 BakedIndirect，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 Distance ShadowMask 的情况下，ShadowDistance 范围内的静态物体也会绘制阴影贴图，从而可以解决该问题。<br />
LightMode 为 Mixed，LightingMode 为 ShadowMask，ShadowMask Mode 为 ShadowMask 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
LightMode 为 Mixed，LightingMode 为 Substractive 的情况下，静态物体不会绘制阴影贴图，因此静态物体不会在动态物体上投影。<br />
</p>
</div>
</li>
<li><a id="org82874ed"></a>ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图<br />
<div class="outline-text-7" id="text-org82874ed">
<p>
关闭 Unity，重新打开，可以解决该问题。<br />
</p>
</div>
</li>
<li><a id="org17996aa"></a>Deferred Path 模式下的间接光照计算是怎样的？<br />
<div class="outline-text-7" id="text-org17996aa">
<p>
indirect.diffuse DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。<br />
indirect.specular 的计算则分是否开启屏幕空间反射，不开启时，DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。开启时，则在屏幕空间反射时计算。<br />
</p>
</div>
</li>
<li><a id="orgbb82aae"></a>Error: 阴影轮廓处有光晕<br />
<div class="outline-text-7" id="text-orgbb82aae">
<p>
<img src="./UnityCatLikeCoding/01_17ml_shadow_error.png" alt="01_17ml_shadow_error.png" /><br />
经过检查发现是计算 Normal 时有错误，在下面代码的注释中有具体说明<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetNormal</span>(v2f i)
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">_NORMAL_ON</span>)
      normal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_NormalMap</span>, i.uv).wy * 2 - 1;
      normal.xy *= <span style="color: #7590db;">_BumpScale</span>;
      normal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal.xy, normal.xy)));
      normal = normal.xzy;
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">_NORMALDETAIL_ON</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> detailNormal;
      detailNormal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailNormal</span>, i.uv).wy * 2 - 1;
      detailNormal.xy *= <span style="color: #7590db;">_BumpScale</span>;
      detailNormal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(detailNormal.xy, detailNormal.xy)));
      detailNormal = <span style="color: #4f97d7;">lerp</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(0,1,0), detailNormal.xzy, GetDetailMask(i));

      normal.x = normal.x + detailNormal.x;
      normal.y = normal.y * detailNormal.y;
      normal.z = normal.z + detailNormal.z;
<span style="color: #bc6ec5;">  #endif</span>
      normal = <span style="color: #4f97d7;">normalize</span>(normal);

<span style="color: #bc6ec5;">  #define</span> <span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>
<span style="color: #bc6ec5;">  #if</span> defined(<span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>)
      <span style="color: #ce537a; font-weight: bold;">float3</span> wTangent = i.tangentToWorld[0];
      <span style="color: #ce537a; font-weight: bold;">float3</span> wBinormal = i.tangentToWorld[1];
      <span style="color: #ce537a; font-weight: bold;">float3</span> wNormal = i.tangentToWorld[2];
      <span style="color: #2aa1ae; background-color: #292e34;">// &#19978;&#38754;&#20195;&#30721;&#24050;&#32463;&#23558;normal&#21521;&#19978;&#30340;&#20998;&#37327;&#20174;z&#25442;&#21040;&#20102;y&#65292;&#25152;&#20197;&#36825;&#37324;&#21644;wNormal&#30456;&#20056;&#30340;&#24212;&#35813;&#26102;normal&#30340;y&#20998;&#37327;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// normal = normalize(wTangent*normal.x + wBinormal*normal.y + wNormal*normal.z);</span>
      normal = <span style="color: #4f97d7;">normalize</span>(wTangent*normal.x + wNormal*normal.y + wBinormal*normal.z);
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> normal;
  }
</pre>
</div>
</div>
</li>
<li><a id="org197f62b"></a>Error: Subtractive 模式下动态物体的阴影很淡<br />
<div class="outline-text-7" id="text-org197f62b">

<div id="org4406122" class="figure">
<p><img src="./UnityCatLikeCoding/01_17ml_subtractive_dynamicObj_shadow_error.png" alt="01_17ml_subtractive_dynamicObj_shadow_error.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
  {
<span style="color: #bc6ec5;">  #if</span> SUBTRACTIVE_LIGHTING
      UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
      attenuation = GetShadowFade(i, attenuation);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
      <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
      <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
      indirect.diffuse = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf922edf" class="outline-5">
<h5 id="orgf922edf">RealtimeGI ProbeVolumes LOD Groups</h5>
<div class="outline-text-5" id="text-orgf922edf">
</div>
<div id="outline-container-org7a6417e" class="outline-6">
<h6 id="org7a6417e">Realtime Globall Illumination</h6>
<div class="outline-text-6" id="text-org7a6417e">
</div>
<ul class="org-ul">
<li><a id="org0d92886"></a>简介<br />
<div class="outline-text-7" id="text-org0d92886">
<p>
烘培光照虽然对静态几何体(通过光照贴图)和动态几何体(通过光照探针)起作用，但是烘培光照无法处理动态光照(Realtime Mode Light)。Mixed Mode Light 可以实时调节一些参数，但是过多的调整会让没有改变的烘培间接光照变得很明显。所以，当你有一个室外的场景时，太阳是不能改变的，它不能像真实生活中一样东升西落在空中穿行，因为这需要不断改变全局照明，所以只能让场景冻结在某个时间点上。<br />
为了让间接光照支持光照方向的实时改变，Unity 使用 Enlighten 系统来计算实时全局照明。其就像烘培间接光一样工作，不同的是 Enlighten 是在运行时计算光照贴图和光照探针的。<br />
计算间接光需要知道光照在静态表面之间是如何弹射的，也就是需要知道哪些表面有可能会被哪些表面在哪些角度上产生影响。计算出这些关系需要很多工作，不可能在运行时完成。所以，这些数据是由编辑器计算并存储起来，运行时 Enlighten 会利用这些数据来计算光照贴图和光照探针。即使如此，实时全局照明也只适用于低分辨率的光照贴图。<br />
</p>

<p>
注意：无论是 RealtimeGI 的光照贴图，还是 BakedGI 的光照贴图，只有标记为 Lightmap 静态的物体，才会使用烘培的光照贴图。而动态的物体则使用烘培的 LightProbe 数据。<br />
</p>
</div>
</li>
<li><a id="orgdd39cc5"></a>Baking Realtime GI<br />
<div class="outline-text-7" id="text-orgdd39cc5">
<p>
Realtime GI 使用自己的 lightmap 坐标，Unity 会基于光照贴图和物体的设置自动生成这些 UV 坐标，这些 UV 坐标值被存储到 Mesh 的第三套 UV 通道。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
  {
      v2f o;
      UNITY_INITIALIZE_OUTPUT(v2f, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// unity_LightmapST &#26159;&#28888;&#22521;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// unity_DynamicLightmapST&#26159;&#21160;&#24577;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
      o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);

      o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
      o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaVertexPosition</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex, <span style="color: #ce537a; font-weight: bold;">float2</span> uv1, <span style="color: #ce537a; font-weight: bold;">float2</span> uv2, <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapST, <span style="color: #ce537a; font-weight: bold;">float4</span> dynlightmapST)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#36890;&#36807;unity_MetaVertexControl&#26469;&#25511;&#21046;&#24403;&#21069;&#25805;&#20316;&#30340;&#26159;&#28888;&#22521;&#20809;&#29031;GI&#36824;&#26159;&#21160;&#24577;&#20809;&#29031;GI</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.x)
      {
          vertex.xy = uv1 * lightmapST.xy + lightmapST.zw;
          <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL right now needs to actually use incoming vertex position,</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// so use it in a very dummy way</span>
          vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
      }
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.y)
      {
          vertex.xy = uv2 * dynlightmapST.xy + dynlightmapST.zw;
          <span style="color: #2aa1ae; background-color: #292e34;">// OpenGL right now needs to actually use incoming vertex position,</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// so use it in a very dummy way</span>
          vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
      }
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
  }
</pre>
</div>
<p>
注意：<br />
烘培光照贴图和实时光照贴图都会用到 meta pass。所以当开启实时 GI 时，在打包的时候 meta pass 也会被包含进去。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org9678418"></a><span class="todo TODO">TODO</span> 为什么 Realtime GI 不公用静态光照贴图的模型 UV？<br /></li>
</ul>
</li>
<li><a id="orgcb1ca7c"></a>Sampling Realtime Lightmaps<br />
<div class="outline-text-7" id="text-orgcb1ca7c">
<p>
所有的实时灯光都会对实时 GI 有贡献。但是，典型的用法是，只将主方向光作用于实时 GI，因为主方向光代表着太阳，其会在天空中移动。实时 GI 的所有功能对方向光都是有效的，实时 GI 不支持点光源和 SpotLight 的阴影。因此，当使用会投影的点光源和 SpotLight 时，最终会得到不正确的间接光照。<br />
如果你想将某个实时光从实时 GI 中排除，只需要将该灯光的 IndirectMultiplier 设置为 0。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader">  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
<span style="color: #bc6ec5;">  #if</span> defined(DYNAMICLIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#21160;&#24577;Lightmap&#20351;&#29992;&#20102;&#21644;&#38745;&#24577;Lightmap&#19981;&#21516;&#30340;&#39068;&#33394;&#26684;&#24335;&#65292;&#38656;&#35201;&#19981;&#21516;&#30340;&#35299;&#30721;</span>
      <span style="color: #ce537a; font-weight: bold;">float3</span> dynamicLightDiffuse = DecodeRealtimeLightmap(UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, i.dynamicLightmapUV));
<span style="color: #bc6ec5;">      #if</span> defined(DIRLIGHTMAP_COMBINED)
          <span style="color: #ce537a; font-weight: bold;">float4</span> dynamicLightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap,i.dynamicLightmapUV);
          indirect.diffuse += DecodeDirectionalLightmap(dynamicLightDiffuse, dynamicLightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">      #else</span>
          indirect.diffuse += dynamicLightDiffuse;
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
      <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809;</span>
      indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">  #endif</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="org8d5c1c3"></a>Emissive Light<br />
<div class="outline-text-7" id="text-org8d5c1c3">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> EmissiveOscillator : MonoBehaviour
  {
      Renderer r;
      <span style="color: #4f97d7; font-weight: bold;">Material</span> mat;
      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Start</span>()
      {
          r = GetComponent&lt;Renderer&gt;();
          mat = r.material;
      }

      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">Color</span> c = <span style="color: #4f97d7; font-weight: bold;">Color</span>.Lerp(<span style="color: #4f97d7; font-weight: bold;">Color</span>.white, <span style="color: #4f97d7; font-weight: bold;">Color</span>.black, Mathf.Sin(Time.time * Mathf.PI) * 0.5f + 0.5f);
          mat.SetColor(<span style="color: #2d9574;">"_EmissionColor"</span>, c);

          <span style="color: #2aa1ae; background-color: #292e34;">// &#26356;&#26032;&#23454;&#26102;GI</span>

          <span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#20250;&#35302;&#21457;&#20351;&#29992;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
          <span style="color: #2aa1ae; background-color: #292e34;">//r.UpdateGIMaterials();</span>

          <span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#19981;&#20250;&#35302;&#21457;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#21482;&#26159;&#30452;&#25509;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
          DynamicGI.SetEmissive(r, c);
      }
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org07b67d0" class="outline-6">
<h6 id="org07b67d0">Light Probe Proxy Volumes</h6>
<div class="outline-text-6" id="text-org07b67d0">
<p>
烘培 GI 和实时 GI 都是通过 LightProbe 作用于动态物体的。物体的位置用于插值 LightProbe 数据，插值得到的数据再应用于 GI。这对于小物体来说是可行的，但是对于大物体来说就太粗暴了。<br />
</p>

<p>
LLPV（light probe proxy volume）可以解决该问题。其会传递给 shader 一组经过插值的 LightProbe 数据，而不是一个。这些数据会存储到一张浮点型 3D 贴图中，且该贴图需要支持线性过滤模式，只有现代图形显卡才能支持。<br />
在 Graphics/TierSettings/EnableLightProbeProxyVolume 中开启 LightProbeProxyVolume。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
<span style="color: #bc6ec5;">      #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
          <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1)
          {
                <span style="color: #2aa1ae; background-color: #292e34;">// Light Probe Proxy Volume &#21482;&#20351;&#29992;&#20102;&#20004;&#20010;&#22522;&#24102;</span>
              indirect.diffuse = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.worldNormal, 1), i.worldPos);
              indirect.diffuse = <span style="color: #4f97d7;">max</span>(0, indirect.diffuse);
<span style="color: #bc6ec5;">              #if</span> defined(UNITY_COLORSPACE_GAMMA)
                  indirect.diffuse = LinearToGammaSpace(indirect.diffuse);
<span style="color: #bc6ec5;">              #endif</span>
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809; LightProbe ShadeSH9&#20013;&#24050;&#32463;&#22788;&#29702;&#20102;&#39068;&#33394;&#31354;&#38388;&#30340;&#38382;&#39064;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
          }
<span style="color: #bc6ec5;">      #else</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// &#21472;&#21152;&#29615;&#22659;&#20809; LightProbe</span>
          indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">      #endif</span>
<span style="color: #bc6ec5;">  #endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org4c516d3" class="outline-6">
<h6 id="org4c516d3">LOD Groups</h6>
<div class="outline-text-6" id="text-org4c516d3">
</div>
<ul class="org-ul">
<li><a id="org2e26070"></a>Baked GI and Lod Group<br />
<div class="outline-text-7" id="text-org2e26070">
<p>
在烘培静态光照贴图时，使用的是 LOD0。即使在运行时显示的是 LOD1 或者是 LOD culled ，此时阴影和间接光照都是使用的烘培 LOD0 所得数据。<br />
<img src="./UnityCatLikeCoding/01_18ml_lod1_01.jpg" alt="01_18ml_lod1_01.jpg" /><br />
但是 LOD1 依然会使用 lightmap，其采样的数据和 LOD0 采样的数据并不同(分布在 lightmap 贴图的不同位置)，Unity 利用烘培的 LightProbe 来计算 LOD1 的间接光照然后写入到 Lightmap 中，所以烘培带有 LOD 的场景时，需要添加 LightProbe，否则 LOD1 的间接光照会变为黑色，从而显得很暗。<br />
下图是，开启 LightProbe 和关闭 LightProbe 烘焙场景得到的不同效果:<br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withoutLightProbe.png" alt="01_18ml_lodGroup_bake_withoutLightProbe.png" /><br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withLightProbe.png" alt="01_18ml_lodGroup_bake_withLightProbe.png" /><br />
</p>
</div>
</li>
<li><a id="orgd87289a"></a>Realtime GI and Lod Group<br />
<div class="outline-text-7" id="text-orgd87289a">
<p>
当只开启 Realtime GI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且取消勾选 BakedGlobalIllumination），在运行时 Lod0 依然使用实时烘培的光照贴图，而 Lod1 会使用 LightProbe 数据(运行时，选中显示 Lod1 的物体，SceneView 下可以看到其使用的 LightProbe，这里需要强调的是，即使 Lod1 是静态物体其使用的也是 LightProbe)。<br />
</p>

<p>
在同时使用 RealtimeGI 和 BakedGI 时（LightingSeting 中，勾选 RealtimeGlobalIllumination，并且勾选 BakedGlobalIllumination），Lod0 会同时使用 Realtime Lightmap （实时光的贡献）和 Baked Lightmap（烘培光的贡献），而 Lod1 只会使用 Baked Lightmap，因为 lightmap 和球谐光照无法同时使用，Lod1 就不会受到 realtime GI 的影响。<br />
</p>

<p>
注意：烘培和渲染 Lod 是完全独立的，如果实时 GI 比烘培 GI 更重要，可以在运行时设置 LOD1 为非 lightmap-static，这样 LOD1 就会使用 Realtime GI 的 LightProbe。<br />
</p>
</div>
</li>
<li><a id="orgb65b852"></a>Cross-fading Between Lod Levels<br />
<div class="outline-text-7" id="text-orgb65b852">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">  #pragma</span> multi_compile _ LOD_FADE_CROSSFADE

  <span style="color: #2aa1ae; background-color: #292e34;">// 4*64 &#22823;&#23567;&#36148;&#22270;</span>
  <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DitherMaskLOD2D</span>;

  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UnityApplyDitherCrossFade</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> vpos)
  {
      vpos /= 4; <span style="color: #2aa1ae; background-color: #292e34;">// the dither mask texture is 4x4</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// unity_LODFade&#21464;&#37327;&#23384;&#20648;&#20102;&#24403;&#21069;fade&#30340;&#24635;&#37327;&#65292;&#25972;&#20010;&#36807;&#31243;&#19968;&#20849;16&#27493;(fade&#19968;&#27493;&#30340;&#20540;&#20026;1/16)</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// quantized lod fade by 16 levels</span>
      vpos.y = <span style="color: #4f97d7;">frac</span>(vpos.y) * 0.0625 <span style="color: #2aa1ae; background-color: #292e34;">/* 1/16 */</span> + unity_LODFade.y;
      <span style="color: #4f97d7;">clip</span>(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DitherMaskLOD2D</span>, vpos).a - 0.5);
  }
</pre>
</div>
</div>
</li>
<li><a id="org9b924d2"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org7142e19"></a><span class="todo TODO">TODO</span> 为什么不将 LOD1 像 LOD0 那样处理，再渲染一次 LOD1 得到精确的亮度数据写入光照贴图中？<br /></li>
<li><a id="orge92a4b7"></a><span class="todo TODO">TODO</span> 为什么球谐光照和 lightmap 无法同时使用？<br /></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org907f381" class="outline-5">
<h5 id="org907f381">GPU Instancing</h5>
<div class="outline-text-5" id="text-org907f381">
</div>
<div id="outline-container-orga02ddc6" class="outline-6">
<h6 id="orga02ddc6">Batching Instances</h6>
<div class="outline-text-6" id="text-orga02ddc6">
</div>
<ul class="org-ul">
<li><a id="org6e3e375"></a>Baching 简介<br />
<div class="outline-text-7" id="text-org6e3e375">
<p>
向 GPU 提交绘制命令会花费时间。将数据（mesh 和材质属性）提交给 GPU 也会耗费时间。<br />
Static Batching:  Unity 可以将很多静态的物体合并为一个大的静态物体（可以减少 SetPassCall 但无法减少 DrawCall），只有使用相同材质的物体才能以这种方式合并。这样做的代价是需要存储更多的 Mesh 数据（单个的 mesh 加上合并后的大 mesh）。<br />
Dynamic Batching:<br />
    Dynamic Batching for meshes: 对于足够小的一系列 Mesh，运行时 Unity 在 CPU 端会将他们变换到世界空间，将他们合并为一个大的 mesh(动态合并大物体的消耗太大了)。(可以减少 DrawCall)<br />
    Dynamic batching for dynamically generated geometries: 对于 Build-in Particle Systems, Line Renderers, Trail Renderers。动态合批的工作方式如下：(不能减少 DrawCall)<br />
</p>
<ol class="org-ol">
<li>对于每个 Renderer，Unity 会将所有可以动态合批的内容构建到一个大的顶点缓存区中。<br /></li>
<li>renderer 会设置该 batch 的材质状态<br /></li>
<li>Unity 将顶点缓冲区绑定到 GPU<br /></li>
<li>对于 batch 内的每个 renderer，Unity 会更新顶点缓冲区的偏移量，然后提交一个新的 draw call<br /></li>
</ol>

<p>
GPU Instancing:   运行时通知 GPU 绘制同一个 mesh 多次，GPU Instancing 无法将不同的 mesh 或材质合并，但是其并不要求 mesh 必须为小 mesh。<br />
</p>

<ul class="org-ul">
<li>Baching Compare <a href="#org888e790">Batching Compare</a><br /></li>
</ul>
</div>
</li>
<li><a id="org31dd7ab"></a>Support GPU Instancing<br />
<ul class="org-ul">
<li><a id="org6ab3d9d"></a>支持 GPU Instancing<br />
<div class="outline-text-8" id="text-org6ab3d9d">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327;SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;
  };

  vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      vert_out o;
      UNITY_INITIALIZE_OUTPUT(vert_out, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#27714;&#35299;&#24403;&#21069;&#23454;&#20363;&#30340; Obj2World World2Obj&#30697;&#38453;</span>
      UNITY_SETUP_INSTANCE_ID(v);
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  }
</pre>
</div>
</div>
</li>
<li><a id="orgb14b6a0"></a>Unity 对 GPU Instancing 的封装<br />
<div class="outline-text-8" id="text-orgb14b6a0">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;instanceID</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> uint unity_InstanceID;

CBUFFER_START(UnityDrawCallInfo)
    <span style="color: #2aa1ae; background-color: #292e34;">// Where the current batch starts within the instanced arrays.</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> unity_BaseInstanceID;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// &#31995;&#32479;&#21464;&#37327;&#21517;&#31216;SV_InstanceID</span>
<span style="color: #bc6ec5;">#define</span> UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;

<span style="color: #bc6ec5;">#define</span> UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;

<span style="color: #2aa1ae; background-color: #292e34;">// Redefine some of the built-in variables /</span>
<span style="color: #2aa1ae; background-color: #292e34;">// macros to make them work with instancing.</span>
UNITY_INSTANCING_CBUFFER_START(PerDraw0)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorldArray[UNITY_INSTANCED_ARRAY_SIZE];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObjectArray[UNITY_INSTANCED_ARRAY_SIZE];
UNITY_INSTANCING_CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;instance&#25968;&#25454;&#35206;&#30422;&#21407;&#22987;&#23450;&#20041;&#20869;&#23481;</span>
<span style="color: #bc6ec5;">#define</span> unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
<span style="color: #bc6ec5;">#define</span> unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</pre>
</div>

<p>
forward base pass, shadow pass, deferred pass 都支持 GPU Instancing.<br />
forward add pass 不支持 GPU Instancing.<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgc8bef6e"></a>Batch Size<br />
<div class="outline-text-7" id="text-orgc8bef6e">
<p>
每个 Batch 都需要自己的矩阵数组。这些数据被发送给 GPU，然后被存储在内存缓冲区(D3D 的 ConstantBuffer,OpenGL 的 UniformBuffer)中。这些缓冲区有最大容量限制，这限制了每个 batch 的实例数量。<br />
假设台式机每个 UniformBuffer 的大小为 64KB，一个矩阵有 16 个浮点数，每个浮点数需要 4 字节存储，每个实例需要 1 个 object-to-world 变换矩阵，如果使用了法线贴图，则还需要 1 个 world-to-object 变换矩阵(用于将法线变换到世界空间)<br />
16*4*2 = 128Byte 64KB/128B=64*1024B/128=512<br />
</p>

<p>
UNITY_INSTANCED_ARRAY_SIZE 默认被定义为 500, 移动平台下被定义为 250.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#36890;&#36807;&#19979;&#38754;&#30340;&#25351;&#20196;&#21487;&#20197;&#23558;&#23454;&#20363;&#25968;&#37327;&#20462;&#25913;&#20026;512</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options maxcount:512
</pre>
</div>
<ul class="org-ul">
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge4bdfc7" class="outline-6">
<h6 id="orge4bdfc7">Mixing Material Properties</h6>
<div class="outline-text-6" id="text-orge4bdfc7">
<p>
所有 DrawCall Batching 都需要物体使用相同的材质。<br />
可以通过 MaterialPropertyBlock 来修改材质属性，从而实现使用相同材质的物体可以有不同的外观，但是通过 MaterialPropertyBlock 修改材质属性，依然会导致 GPU Instancing 失败，因为不同的实例使用了不同的材质属性。<br />
只有在 shader 中定义一个被修改属性的 buffer，Unity 才会将存储在 Material Property Block 中的属性当作数组传递到 GPU(和 Unity 在 GPUInstancing 时对变换矩阵数组的操作一样)，此时 GPU Instancing 才会生效。<br />
MaterialPropertyBlock 支持 Color,Float,Matrix,Vector 类型的属性，如果想支持 Texture 类型，可以使用 TextureArray 然后添加一个 Index 属性将 Index 属性放到 InstancingBuffer 中。<br />
多个属性可以组合放在同一个 Buffer 中，需要注意每个 Buffer 有尺寸限制。另外，Buffer 都是 32 位对齐的，也就是说一个 Float 占用的空间和一个 Vector 占用空间相同。可以使用多个 Buffer，但是 Buffer 的数量也是有限制的，而且 Buffer 也是有性能消耗的。当 GPUInstancing 开启后，每个被放入 Buffer 的属性都会变为一个数组，所以应该只将每个实例都不同的属性放入 Buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">    <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
      <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;

  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> vert_out
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
      <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  };

  <span style="color: #4f97d7; font-weight: bold;">struct</span> frag_in
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
      UNITY_VERTEX_INPUT_INSTANCE_ID
      <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
  };

  vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
  {
      vert_out o;
      UNITY_INITIALIZE_OUTPUT(vert_out, o);
      UNITY_SETUP_INSTANCE_ID(v);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23558;InstanceID&#20256;&#36882;&#21040;fragment</span>
      UNITY_TRANSFER_INSTANCE_ID(v, o);
      <span style="color: #2aa1ae; background-color: #292e34;">// .......</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> o;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(frag_in i)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992;InstanceID&#33719;&#21462;&#24403;&#21069;&#23454;&#20363;&#30340;&#23646;&#24615;</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> alpha = UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, <span style="color: #7590db;">_Color</span>).a;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * alpha;
  }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#19979;&#38754;&#20195;&#30721;&#20250;&#23558; unity_LODFade &#25918;&#20837;Buffer&#65292;&#36825;&#26679;&#22312;&#35774;&#32622;LodFadeMode=CrossFade&#26102;&#65292;GPUInstancing&#19981;&#20250;&#22833;&#25928;</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options lodfade
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb9715cc" class="outline-5">
<h5 id="orgb9715cc">Parallax</h5>
<div class="outline-text-5" id="text-orgb9715cc">
</div>
<div id="outline-container-orgcc9752f" class="outline-6">
<h6 id="orgcc9752f">参考资料</h6>
<div class="outline-text-6" id="text-orgcc9752f">
<ul class="org-ul">
<li>Parallax-Mapping <a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">https://learnopengl.com/Advanced-Lighting/Parallax-Mapping</a><br /></li>
<li>Learn about Parallax en <a href="https://github.com/UPBGE/upbge/issues/1009">https://github.com/UPBGE/upbge/issues/1009</a><br /></li>
<li>Learn about Parallax cn <a href="https://zhuanlan.zhihu.com/p/128682162">https://zhuanlan.zhihu.com/p/128682162</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7b8677b" class="outline-4">
<h4 id="org7b8677b">Advanced Rendering</h4>
<div class="outline-text-4" id="text-org7b8677b">
</div>
<div id="outline-container-orgfbf25a9" class="outline-5">
<h5 id="orgfbf25a9">Flat and Wireframe Shading</h5>
<div class="outline-text-5" id="text-orgfbf25a9">
</div>
<div id="outline-container-org20c616f" class="outline-6">
<h6 id="org20c616f">Barycentric Coordinates</h6>
</div>

<div id="outline-container-org50bc1ff" class="outline-6">
<h6 id="org50bc1ff">Q&amp;A</h6>
<div class="outline-text-6" id="text-org50bc1ff">
</div>
<ul class="org-ul">
<li><a id="org2742c15"></a>为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？<br />
<div class="outline-text-7" id="text-org2742c15">
<p>
cross 操作需要注意向量的正反方向，将所得向量取反就可以了。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8b1e4a8" class="outline-5">
<h5 id="org8b1e4a8">Tessellation</h5>
<div class="outline-text-5" id="text-org8b1e4a8">
</div>
<div id="outline-container-org8b765a5" class="outline-6">
<h6 id="org8b765a5">Q&amp;A</h6>
<div class="outline-text-6" id="text-org8b765a5">
</div>
<ul class="org-ul">
<li><a id="orgf1292c5"></a>ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;<br />
<div class="outline-text-7" id="text-orgf1292c5">
<p>
Unity_patchconstantfunc 改为 UNITY_patchconstantfunc 就可以了。<br />
</p>
</div>
</li>

<li><a id="orgb7d7374"></a>ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'<br />
<div class="outline-text-7" id="text-orgb7d7374">
<p>
TessControlPoint 中成员使用了 float 类型，appdata 中使用的 half 类型。使用同一类型就可以了<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org413f155" class="outline-5">
<h5 id="org413f155">Surface Displacement</h5>
</div>
<div id="outline-container-orgf33dbfa" class="outline-5">
<h5 id="orgf33dbfa">Bloom</h5>
<div class="outline-text-5" id="text-orgf33dbfa">
</div>
<div id="outline-container-org62681fe" class="outline-6">
<h6 id="org62681fe">利用 Downsampling Upsampling 模糊图片的原理</h6>
<div class="outline-text-6" id="text-org62681fe">
<ul class="org-ul">
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering</a><br /></li>
<li><a href="#org5505841">No description for this link</a><br /></li>
<li>高斯模糊 <a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html">http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc5bbd9c" class="outline-5">
<h5 id="orgc5bbd9c">Depth of Field</h5>
<div class="outline-text-5" id="text-orgc5bbd9c">
</div>
<div id="outline-container-org736aa9b" class="outline-6">
<h6 id="org736aa9b">光学原理</h6>
<div class="outline-text-6" id="text-org736aa9b">
<ul class="org-ul">
<li>光学成像原理之景深 <a href="https://blog.csdn.net/mingjinliu/article/details/103648118">https://blog.csdn.net/mingjinliu/article/details/103648118</a> 有道笔记有备份<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdb349b4" class="outline-6">
<h6 id="orgdb349b4">实现原理</h6>
<div class="outline-text-6" id="text-orgdb349b4">
</div>
<ul class="org-ul">
<li><a id="orgfff55e6"></a>COC Pass (CircleOfConfusionPass)<br />
<div class="outline-text-7" id="text-orgfff55e6">
<p>
采样摄像机深度贴图，转化为摄像机空间中的深度，计算 COC，将 COC 的值写入 RT。<br />
</p>

<p>
计算 COC 公式如下：<br />
COC = (EyeDepth - _FocusDistance)/_FocusRange;<br />
</p>

<p>
Circle of confusion 是物体上一个点在胶片上对应的一个圆圈<br />
</p>
</div>
</li>
<li><a id="org728b288"></a>PreFilterPass<br />
<div class="outline-text-7" id="text-org728b288">
<p>
对原来的 RenderTarget 进行 DownSampling，同时将 COC 的值写入到 A 通道。<br />
</p>

<p>
Tips：<br />
降采样，为了保证图片不变暗颜色的权重计算使用下面方法：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">ColorWeight</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> c)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1 / (1 + <span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(c.r, c.g),c.b));
}
</pre>
</div>

<p>
降采样，为了保证 coc 值正确，写入的 coc 做如下取舍：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> coc0 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.xy).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.zy).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.xw).r;
<span style="color: #ce537a; font-weight: bold;">half</span> coc3 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CoCTex</span>,i.uv + o.zw).r;
<span style="color: #ce537a; font-weight: bold;">half</span> cocMin = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(coc0, coc1), coc2), coc3);
<span style="color: #ce537a; font-weight: bold;">half</span> cocMax = <span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(<span style="color: #4f97d7;">max</span>(coc0, coc1), coc2), coc3);
<span style="color: #ce537a; font-weight: bold;">half</span> coc = cocMax &gt;= -cocMin ? cocMax : cocMin;
</pre>
</div>
</div>
</li>
<li><a id="org6314f98"></a>Bokeh<br />
<div class="outline-text-7" id="text-org6314f98">
<p>
Bokeh Pass 主要模拟了 DOF 模糊的圆圈效果。<br />
</p>

<p>
CoC(Circle Of Confusion) 决定了 Bokeh 效果在每个点上的强度，Aperture 决定了 Bokeh 的形状。图片是由很多个 Aperture 形状投影到成像平面得到的。<br />
一种创建 Bokeh 的方法是，使用每个图元的颜色为该图元渲染一个 Sprite，Sprite 的大小和不透明度都基于图元的 CoC（这种方式耗费很大，其需要大量的 Overdraw）。（该方法是将一个片段投影到多个片段上）<br />
另一种方式是，每个片段从所有可能影响该片段的图元累加颜色，这种方法不需要额外的几何体，但是需要进行多次贴图采样。<br />
</p>

<p>
使用 DiskKernels 来对上一步生成的贴图进行采样(以当前像素点为中心采样一个圆盘)，每个样本的权重按照如下方式来计算：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">Weight</span>(<span style="color: #ce537a; font-weight: bold;">half</span> coc, <span style="color: #ce537a; font-weight: bold;">half</span> radius)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//return coc &gt;= radius;  // &#22914;&#26524;coc&#22823;&#20110;radius&#21017;&#26435;&#37325;&#20026;1&#65292;&#21542;&#21017;&#20026;0</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>((coc - radius + 2) / 2);
}
</pre>
</div>
<p>
实现中可以利用 COC 的正负来分离开 DOF 的前景和背景，coc 为负的部分为前景，正的部分为背景。<br />
</p>
</div>
</li>
<li><a id="org7bbc5dd"></a>PostFilterPass<br />
<div class="outline-text-7" id="text-org7bbc5dd">
<p>
使用 Tent Filter 进一步将 DOF 的结果模糊，减弱 Bokeh 圆圈上很多个小圆点的 Artifact。<br />
</p>
</div>
</li>
<li><a id="org66e7264"></a>CombinePass<br />
<div class="outline-text-7" id="text-org66e7264">
<p>
使用 CoC Texture 来指导 DOF 贴图和原始未模糊的贴图.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> dofStrength = <span style="color: #4f97d7;">smoothstep</span>(0.1, 1, <span style="color: #4f97d7;">abs</span>(coc));
<span style="color: #ce537a; font-weight: bold;">half3</span> color = <span style="color: #4f97d7;">lerp</span>(source.rgb, dof.rgb, dofStrength);
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga4a7fc4" class="outline-6">
<h6 id="orga4a7fc4">Q&amp;A</h6>
<div class="outline-text-6" id="text-orga4a7fc4">
</div>
<ul class="org-ul">
<li><a id="org72cc6ed"></a>为什么开启 MSAA 的时候，DOF 效果会错误？<br /></li>
<li><a id="org97e6b2e"></a>为什么 DOF 效果要么覆盖全屏，要么没有？<br />
<div class="outline-text-7" id="text-org97e6b2e">
<p>
检查 DOF 中使用的 depth 贴图，发现 depth 贴图是 unity 默认的灰色贴图。设置摄像机 depthTextureMode 为 Depth。即可解决该问题。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org13452c4" class="outline-5">
<h5 id="org13452c4">FXAA</h5>
<div class="outline-text-5" id="text-org13452c4">
</div>
<div id="outline-container-orgce2d491" class="outline-6">
<h6 id="orgce2d491">SSAA MSAA</h6>
<div class="outline-text-6" id="text-orgce2d491">
<p>
SSAA 通过渲染更大分辨率的画面，通过 Downsampling 来消除锯齿。<br />
MSAA 一个片段中分配多个采样点 N，计算被覆盖的采样点个数 X，从而获得当前片段颜色和片段中原始颜色的混合比例（X/N 为当前片段颜色 N-X/N 为原始颜色）。<br />
</p>

<p>
MSAA 跟 SSAA 不同的地方在于，SSAA 对于所有子采样点着色，而 MSAA 只使用当前像素中心点对应的属性进行着色。这是 MSAA 相对于 SSAA 来说最大的好处。<br />
MSAA 样本位置和重建函数都依赖于硬件实现(新的 GPU 和图形 API 支持在着色器中自定义重建过程)。<br />
</p>

<p>
开启 MSAA 时，光栅化阶段执行的操作：<br />
</p>
<ol class="org-ol">
<li>光栅化插值顶点属性时，取像素中心点对应的位置（因为，pixel shader 调用的位置就是在像素中心点），来生成该像素对应的属性。<br /></li>
<li><p>
对于每个样本都会执行覆盖测试(样本位置依赖于硬件实现)，而不再对像素中心点执行覆盖测试。如果样本在三角形内（或者样本通过了 top-left rule），则其对应的 mask[sampleIdx]被设置为 1.<br />
</p>
<ul class="org-ul">
<li>Tips: 如果像素内没有样本被覆盖，就算像素中心点被覆盖了，该像素依然不会被渲染。如下图最左边从上往下第二个三角形。<br /></li>
</ul>

<div id="org00f63ee" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA_raster_rule.png" alt="02_06fxaa_SMAA_raster_rule.png" width="500px" /><br />
</p>
</div></li>
<li>如果 Early-Per-Fragment Test 开启，则对于被覆盖的每个样本（mask 为 1 的样本）都会执行 Scissor Test、 Stencil Test、Depth Buffer Test。（每个样本可能由不同的三角形覆盖）。<br /></li>
</ol>

<p>
开启 MSAA 时，Pixel Shader 执行的操作：<br />
</p>
<ol class="org-ol">
<li>Pixel Shader 使用像素中心点对应的属性执行 Pixel Shader 中的计算。<br /></li>
</ol>

<p>
开启 MSAA 时，Per-Fragment Operations 阶段：<br />
</p>
<ol class="org-ol">
<li>将 Pixel Shader 中计算的结果，copy 到有效样本（对于 mask 为 1 切通过 depth-stencil 测试的样本）对应的 multisample buffer 中。<br /></li>
<li>如果 Early-Per-Fragment Test 没有开启，则对于被覆盖的每个样本（mask 为 1 的样本）都会执行 Scissor Test、 Stencil Test、Depth Buffer Test。<br /></li>
<li>对每个有效样本执行 blending dithering 以及 logical operations。此时，修改的都是 multisample buffer 中的内容，而不是 color buffer 中的内容。<br />
<ul class="org-ul">
<li>有效样本 是指 mask 为 1 且通过了之前各种 Test 的样本。<br /></li>
</ul></li>
<li>使用重建函数利用 multisample buffer 中的内容构建出最终的颜色和深度，并写入到 color buffer 和 depth buffer 中。<br />
<ul class="org-ul">
<li>不同平台使用不同方式，新的 GPU 和图形 API 支持在着色器中自定义重建过程。<br /></li>
<li>参考资料：MSAA depth resolve <a href="http://aicdg.com/ue4-msaa-depth/">http://aicdg.com/ue4-msaa-depth/</a><br /></li>
</ul></li>
</ol>
<p>
下图展示了 Pixel Shader 之后执行的操作：<br />
</p>

<div id="org1fbe018" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA_after_pixel_shader.png" alt="02_06fxaa_SMAA_after_pixel_shader.png" width="500px" /><br />
</p>
</div>

<p>
下图展示了 MSAA 的实现原理：<br />
</p>

<div id="org1221d52" class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA.png" alt="02_06fxaa_SMAA.png" width="500px" /><br />
</p>
</div>

<p>
在 OpenGL 中使用 MSAA 时，需要为一个像素存储多个样本值，因此，需要使用 multisample buffer 来代替默认的 buffer。大多数窗口系统可以为我们提供一个 multisample buffer 来代替 default buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLFW &#31383;&#21475;&#31995;&#32479;&#36890;&#36807;&#19979;&#38754;&#25509;&#21475;&#26469;&#25351;&#23450;&#20351;&#29992;multisample buffer</span>
  glfwWindowHint(GLFW_SAMPLES, 4);
  glEnable(GL_MULTISAMPLE);
</pre>
</div>

<p>
当我们自己离屏渲染时，如果需要开启 MSAA，则需要自己创建 multisample buffer<br />
</p>
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Off-Screen MSAA</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">CONFIG-BUFFER</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure MSAA framebuffer</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">framebuffer</span>;
  glGenFramebuffers(1, &amp;framebuffer);
  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a multisampled color attachment texture</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">textureColorBufferMultiSampled</span>;
  glGenTextures(1, &amp;textureColorBufferMultiSampled);
  glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled);
  glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGB, SCR_WIDTH, SCR_HEIGHT, GL_TRUE);
  glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a (also multisampled) renderbuffer object for depth and stencil attachments</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">rbo</span>;
  glGenRenderbuffers(1, &amp;rbo);
  glBindRenderbuffer(GL_RENDERBUFFER, rbo);
  glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);
  glBindRenderbuffer(GL_RENDERBUFFER, 0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure second post-processing framebuffer</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">intermediateFBO</span>;
  glGenFramebuffers(1, &amp;intermediateFBO);
  glBindFramebuffer(GL_FRAMEBUFFER, intermediateFBO);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a color attachment texture</span>
  <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">screenTexture</span>;
  glGenTextures(1, &amp;screenTexture);
  glBindTexture(GL_TEXTURE_2D, screenTexture);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, <span style="color: #a45bad;">NULL</span>);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we only need a color buffer</span>

  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  <span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">DRAW-CALL</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">------</span>
  glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. draw scene as normal in multisampled buffers</span>
  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
  glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glEnable(GL_DEPTH_TEST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set transformation matrices</span>
  shader.use();
  <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span> = <span style="color: #a45bad;">glm</span>::perspective(<span style="color: #a45bad;">glm</span>::radians(camera.Zoom), (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_WIDTH / (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_HEIGHT, 0.1f, 1000.0f);
  shader.setMat4(<span style="color: #2d9574;">"projection"</span>, projection);
  shader.setMat4(<span style="color: #2d9574;">"view"</span>, camera.GetViewMatrix());
  shader.setMat4(<span style="color: #2d9574;">"model"</span>, <span style="color: #a45bad;">glm</span>::mat4(1.0f));

  glBindVertexArray(cubeVAO);
  glDrawArrays(GL_TRIANGLES, 0, 36);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. now blit multisampled buffer(s) to normal colorbuffer of intermediate FBO. Image is stored in screenTexture</span>
  glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);
  glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
  glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. now render quad with scene's visuals as its texture image</span>
  glBindFramebuffer(GL_FRAMEBUFFER, 0);
  glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT);
  glDisable(GL_DEPTH_TEST);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">draw Screen quad</span>
  screenShader.use();
  glBindVertexArray(quadVAO);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, screenTexture); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use the now resolved color attachment as the quad's texture</span>
  glDrawArrays(GL_TRIANGLES, 0, 6);

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------------------------------------</span>
  glfwSwapBuffers(window);
  glfwPollEvents();
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgc94ffe2"></a>Q&amp;A<br />
<ul class="org-ul">
<li><a id="org2483ca8"></a>Unity 中开启了 MSAA 后，如何生成后处理 DOF 中需要的 DepthTexture 的？<br />
<div class="outline-text-8" id="text-org2483ca8">
<p>
Unity 2021.3.1 , URP 12.1.6, Editor 下修改 Graphic API，开启 MSAA 4x ，FrameDebug 得到如下信息：<br />
</p>

<div id="org1aec211" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-unity-msaa-depth.jpg" alt="advanced-rendering_05_fxaa-unity-msaa-depth.jpg" width="1000px" /><br />
</p>
</div>

<ul class="org-ul">
<li>Unity 里，如果开启了 MSAA，怎么直接读取渲染场景时的深度？ <a href="https://www.zhihu.com/question/449384579">https://www.zhihu.com/question/449384579</a><br /></li>
</ul>
</div>
</li>
<li><a id="org5596bdb"></a><span class="todo TODO">TODO</span> Unity 开启 MSAA 后的性能消耗如何？<br />
<div class="outline-text-8" id="text-org5596bdb">

<div id="org34de9ce" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-unity-msaa-depth.jpg" alt="advanced-rendering_05_fxaa-unity-msaa-depth.jpg" width="1000px" /><br />
</p>
</div>

<p>
从上图可以看到，OpenGL ES 3.2 平台下，开启 MSAA 时，Unity 会开启 PreDepthPass，通过该 Pass 来生成深度图。<br />
</p>

<ul class="org-ul">
<li><a href="https://forum.unity.com/threads/msaa-performance-on-mobile.825450/">https://forum.unity.com/threads/msaa-performance-on-mobile.825450/</a><br /></li>
</ul>
</div>
</li>
<li><a id="org9c2d26d"></a>开启 MSAA 后 DepthBuffer 和 StencilBuffer 的分辨率会提高，Resolve depth stencil 时，直接对 Depth 值和 Stencil 值进行平均显然是错误的，那么，Resolve 是如何处理 Depth 和 Stencil 的呢？<br />
<div class="outline-text-8" id="text-org9c2d26d">
<p>
游戏引擎随笔 0x15：现代图形 API 的 MSAA 文章中详细表述了该问题。Depth 和 Stencil 不会使用平均的方式，而是使用 Min(使用最小的值),Max(使用最大的值),Sample0(使用第 0 个样本存储的值)。<br />
具体执行 Resolve 的方式，则分为两类：硬件 Resolving 和利用 Shader 来实现 Resolving。另外，不同图形 API，处理 Resolve 方式也不同。<br />
</p>

<ul class="org-ul">
<li>游戏引擎随笔 0x15：现代图形 API 的 MSAA <a href="https://zhuanlan.zhihu.com/p/263101710">https://zhuanlan.zhihu.com/p/263101710</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgf675b89"></a>为什么 MSAA 每个子采样点需要独立存储颜色和深度？<br />
<div class="outline-text-8" id="text-orgf675b89">
<p>
因为不同的三角形可能覆盖同一个像素的不同子采样点。此时该像素会执行多次片段着色器，需要将不同的颜色值 copy 到 multisample color buffer 和 multisample depth buffer。<br />
</p>


<div id="org1ce8093" class="figure">
<p><img src="./UnityCatLikeCoding/advanced-rendering_05_fxaa-msaa-detail.jpg" alt="advanced-rendering_05_fxaa-msaa-detail.jpg" width="800px" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgc838302"></a>延迟渲染为什么不支持 MSAA？<br />
<div class="outline-text-8" id="text-orgc838302">
<p>
技术上来说是可行的，只需要分配 Multisample Buffer 给 MRT 就可以了。但是开启 MSAA 后，GBuffer 的尺寸会成倍增加，带宽消耗成倍增加。另外，开启 MSAA 后，延迟渲染不做任何修改的话，渲染结果是错误的。延迟渲染第一节阶段生成 GBuffer 内容是没问题的，第二个阶段，读取 GBuffer 内容时，此时样本覆盖值都是 1，所以 color，normal，depth 读出来是 4 个样本的平均值，对于颜色来说没问题，normal 和 depth 就是错误的。<br />
</p>

<p>
一种可行的方法是，延迟渲染第一阶段开启 MSAA，然后将 GBuffer Resolve 为正常尺寸的 RT，第二个阶段拿 Resolve 出来的 GBuffer 做光照渲染。<br />
</p>

<ul class="org-ul">
<li>延迟渲染与 MSAA 的那些事 <a href="https://zhuanlan.zhihu.com/p/135444145">https://zhuanlan.zhihu.com/p/135444145</a><br /></li>
<li>延迟渲染为什么不支持 MSAA？ <a href="https://www.zhihu.com/question/366668747">https://www.zhihu.com/question/366668747</a><br /></li>
</ul>
</div>
</li>
<li><a id="org934281c"></a>MSAA 为什么会影响 HDR 开启后的效果？<br />
<div class="outline-text-8" id="text-org934281c">
<p>
MSAA Resolve 阶段会平均样本颜色，在 ToneMapping 之前 Resolve 样本颜色，得到的颜色值会偏向颜色值更大的样本颜色，从而会导致锯齿很明显。下面文章中都提到了该问题。<br />
</p>

<ul class="org-ul">
<li>MSAA 基础 <a href="http://aicdg.com/aa/">http://aicdg.com/aa/</a> (有道备份)<br /></li>
<li>移动端高性能图形开发 - 详解 MSAA <a href="https://zhuanlan.zhihu.com/p/382063141">https://zhuanlan.zhihu.com/p/382063141</a><br /></li>
<li>HDR inverse tone mapping MSAA resolve <a href="https://theagentd.blogspot.com/2013/01/hdr-inverse-tone-mapping-msaa-resolve.html">https://theagentd.blogspot.com/2013/01/hdr-inverse-tone-mapping-msaa-resolve.html</a>  (有道备份)<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgbb2a6f2"></a>参考资料<br />
<div class="outline-text-7" id="text-orgbb2a6f2">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing</a><br /></li>
<li>深入剖析 MSAA <a href="https://www.cnblogs.com/ghl_carmack/p/8245032.html">https://www.cnblogs.com/ghl_carmack/p/8245032.html</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">https://en.wikipedia.org/wiki/Multisample_anti-aliasing</a><br /></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules</a><br /></li>
<li>对多重采样（MSAA）原理的一些疑问 <a href="https://www.zhihu.com/question/58595055/answer/157756410">https://www.zhihu.com/question/58595055/answer/157756410</a> （如果丢失可以参考有道云笔记备份）<br /></li>
<li>OpenGL ES 3.0 Specification <a href="https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf">https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf</a><br /></li>
<li>OpenGL ES 3.1 Specification <a href="https://registry.khronos.org/OpenGL/specs/es/3.1/es_spec_3.1.pdf">https://registry.khronos.org/OpenGL/specs/es/3.1/es_spec_3.1.pdf</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb35728f" class="outline-6">
<h6 id="orgb35728f">参考资源</h6>
<div class="outline-text-6" id="text-orgb35728f">
<ul class="org-ul">
<li><a href="http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html">http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org186ad6a" class="outline-5">
<h5 id="org186ad6a">Triplanar Mapping</h5>
<div class="outline-text-5" id="text-org186ad6a">
</div>
<div id="outline-container-org5427e9c" class="outline-6">
<h6 id="org5427e9c">求解 Normal</h6>
<div class="outline-text-6" id="text-org5427e9c">
</div>
<ul class="org-ul">
<li><a id="orgb94e290"></a>TangentNormal<br />
<div class="outline-text-7" id="text-orgb94e290">

<div id="orgc040bd6" class="figure">
<p><img src="./UnityCatLikeCoding/02_07tm_CalcNormal.jpg" alt="02_07tm_CalcNormal.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgc68942a"></a>TangentNormalToWorldNormal WorldNormalToTangentNormal<br />
<div class="outline-text-7" id="text-orgc68942a">
<p>
tangentNormal 向上的方向始终为 z，worldNormal 向上的方向随不同投影面而变化。YZ 平面，worldNormal 向上方向在 x 轴方向；XZ 平面，worldNormal 向上在 y 轴方向；XY 平面，worldNormal 向上在 z 轴方向。<br />
tangentNormalX.xyz = worldNormal.zyx  worldNormal 向上的方向为 x 而不是 z，<br />
worldNormal.xyz = tangentNormalX.zyx  tangentNormalX 向上的方向为 z 而不是 x<br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9802873" class="outline-4">
<h4 id="org9802873">CustomSRP</h4>
<div class="outline-text-4" id="text-org9802873">
</div>
<div id="outline-container-orgc646041" class="outline-5">
<h5 id="orgc646041">Custom Render Pipeline</h5>
<div class="outline-text-5" id="text-orgc646041">
</div>
<div id="outline-container-orgdcd5687" class="outline-6">
<h6 id="orgdcd5687">架构</h6>
<div class="outline-text-6" id="text-orgdcd5687">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipelineAsset.cs &#21019;&#24314;CustomRenderPipeline&#23454;&#20363;&#65292;&#25552;&#20379;&#32473;unity&#24341;&#25806;</span>
  [<span style="color: #bc6ec5; font-weight: bold;">CreateAssetMenu</span>(menuName = <span style="color: #2d9574;">"Rendering/CustomRenderPipeline"</span>)]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> CustomRenderPipelineAsset : <span style="color: #ce537a; font-weight: bold;">RenderPipelineAsset</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span> <span style="color: #bc6ec5; font-weight: bold;">CreatePipeline</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span>();
      }
  }

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CustomRenderPipeline.cs &#23454;&#29616;CustomRenderPipeline&#31867;&#21151;&#33021;&#12290;&#36845;&#20195;&#28210;&#26579;&#21508;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CustomRenderPipeline</span> : <span style="color: #ce537a; font-weight: bold;">RenderPipeline</span>
{
    <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span> <span style="color: #7590db;">renderer</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>();
    <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Render</span>(<span style="color: #ce537a; font-weight: bold;">ScriptableRenderContext</span> <span style="color: #7590db;">context</span>, <span style="color: #ce537a; font-weight: bold;">Camera</span>[] <span style="color: #7590db;">cameras</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">camera</span> <span style="color: #4f97d7; font-weight: bold;">in</span> cameras)
        {
            renderer.<span style="color: #bc6ec5; font-weight: bold;">Render</span>(context, camera);
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">CameraRenderer.cs CameraRenderer.Editor.cs &#23454;&#29616;CameraRenderer&#31867;&#21151;&#33021;&#12290;&#28210;&#26579;&#26576;&#20010;&#25668;&#20687;&#26426;&#30475;&#21040;&#30340;&#20869;&#23481;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">partial</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">CameraRenderer</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6e3a849" class="outline-6">
<h6 id="org6e3a849">CommandBuffer BeginSample EndSample</h6>
<div class="outline-text-6" id="text-org6e3a849">
<p>
CommandBuffer 的 BeginSample 和 EndSample 方法也需要调用 context.ExecuteCommandBuffer(buffer);才能生效。<br />
另外 CommandBuffer 的 BeginSample 和 EndSample 需要成对。<br />
</p>
</div>
</div>
<div id="outline-container-org11356bd" class="outline-6">
<h6 id="org11356bd">CameraClearFlags</h6>
<div class="outline-text-6" id="text-org11356bd">
<p>
CameraClearFlags 定义的 4 个枚举不是互相独立的，其表示了一个降量清除。例如，除了 CameraClearFlags.Nothing 以外，其他枚举都需要清除深度缓冲区。<br />
CameraClearFlags.Skybox     ==&gt; Clear Z+Stencil<br />
CameraClearFlags.Color      ==&gt; Clear Color+Z+Stencil<br />
CameraClearFlags.SolidColor<br />
</p>

<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">CameraClearFlags</span>
  {
      <span style="color: #7590db;">Skybox</span> = 1,
      <span style="color: #7590db;">Color</span> = 2,
      <span style="color: #7590db;">SolidColor</span> = 2,
      <span style="color: #7590db;">Depth</span> = 3,
      <span style="color: #7590db;">Nothing</span> = 4
  }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9dd90e4" class="outline-5">
<h5 id="org9dd90e4">Draw Calls</h5>
<div class="outline-text-5" id="text-org9dd90e4">
</div>
<div id="outline-container-org61f79a6" class="outline-6">
<h6 id="org61f79a6">Write a HLSL Shader</h6>
<div class="outline-text-6" id="text-org61f79a6">
</div>
<ul class="org-ul">
<li><a id="org4931487"></a>shader 中顶点坐标为什么使用 float4 而不是使用 float3？<br />
<div class="outline-text-7" id="text-org4931487">
<p>
3D 空间的坐标点被定义为 4 维向量，并且 w 分量设置为 1，而 3D 空间的方向向量的 w 分量则被设置为 0。这样可以使用相同的变换矩阵来对点和向量进行变换，因此使用 float4 表示顶点。<br />
假如向量为行向量，矩阵中第 4 行存储的是平移信息，3D 空间中的点变换需要平移，因此其 w 分量为 1，而 3D 空间的向量不需要平移变换，因此其 w 分量为 0。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5e827e3" class="outline-6">
<h6 id="org5e827e3">Batching</h6>
<div class="outline-text-6" id="text-org5e827e3">
<p>
合批是指将 DrawCall 合并，减少 CPU 和 GPU 沟通消耗的时间。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7bae5a0"></a>SRP batcher<br />
<div class="outline-text-7" id="text-org7bae5a0">
<p>
最简单的方式是开启 SRP batcher。但是，选中我们的 Unlit.shader 文件，在 Inspector 面板上提示 not compatible。SRP batcher 并没有减少 draw call 的数量，其会将材质的属性缓存在 GPU，从而避免每次 draw call 都需要从 CPU 发送材质属性到 GPU，这样就减少了 CPU 和 GPU 交互的数据量，也减少了 CPU 执行每个 DrawCall 时的工作。<br />
</p>

<p>
注意：<br />
</p>
<ol class="org-ol">
<li>SRP batcher 不会减少 draw call 数量<br /></li>
<li>SRP batcher 支持多个物体使用相同 shader 定义的不同材质，每个材质使用不同的材质属性。<br /></li>
<li>SRP batcher 支持多个物体使用相同的材质。<br /></li>
<li>SRP batcher 不支持每个物体使用相同材质而拥有不同的材质属性，即不支持 MaterialPropertyBlock.<br /></li>
</ol>

<p>
通过如下方式支持 SRP batcher：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// UnlitPass.hlsl</span>
  CBUFFER_START(UnityPerMaterial)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseColor</span>;
  CBUFFER_END

  <span style="color: #2aa1ae; background-color: #292e34;">// UnityInput.hlsl</span>
  CBUFFER_START(UnityPerDraw)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorld;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LODFade;
    real4 unity_WorldTransformParams;
  CBUFFER_END

  <span style="color: #2aa1ae; background-color: #292e34;">// CustomRenderPipeline.cs &#22686;&#21152;&#26500;&#36896;&#20989;&#25968;&#65292;&#35774;&#32622;&#21551;&#29992;SRP Batching</span>
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #bc6ec5; font-weight: bold;">CustomRenderPipeline</span> ()
  {
      GraphicsSettings.useScriptableRenderPipelineBatching = <span style="color: #a45bad;">true</span>;
  }
</pre>
</div>

<p>
在 CustomURP 实现中，使用的 CBUFFER 如下：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgefd25f9"></a>LitInput.hlsl<br />
<div class="outline-text-8" id="text-orgefd25f9">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// LitInput.hlsl</span>
CBUFFER_START(UnityPerMaterial)
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseMap_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_BaseColor</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_EmissionColor</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_ZWrite</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Metallic</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Smoothness</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Occlusion</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Fresnel</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailMap_ST</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailAlbedo</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailSmoothness</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_NormalScale</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DetailNormalScale</span>;
CBUFFER_END(UnityPerMaterial)
</pre>
</div>
</div>
</li>
<li><a id="orgfdcac31"></a>UnityInput.hlsl<br />
<div class="outline-text-8" id="text-orgfdcac31">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// UnityInput.hlsl</span>
CBUFFER_START(UnityPerDraw)
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorld;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LODFade;
    real4 unity_WorldTransformParams;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_RenderingLayer;

    real4 unity_LightData;
    real4 unity_LightIndices[2];

    <span style="color: #2aa1ae; background-color: #292e34;">// Unity&#20063;&#20250;&#23558;ShadowMask&#25968;&#25454;&#28888;&#22521;&#21040;LightProbes&#20013;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbesOcclusion;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#21453;&#23556;&#29699;&#30456;&#20851;&#23646;&#24615;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SpecCube0_HDR;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_LightmapST;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_DynamicLightmapST;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAr;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAg;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHAb;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBr;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBg;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHBb;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_SHC;

    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeParams;
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ProbeVolumeWorldToObject;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeSizeInv;
    <span style="color: #ce537a; font-weight: bold;">float4</span> unity_ProbeVolumeMin;
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="org79ede1b"></a>Shadow.hlsl<br />
<div class="outline-text-8" id="text-org79ede1b">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Shadow.hlsl</span>
CBUFFER_START(<span style="color: #7590db;">_CustomShadows</span>)
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">_CascadeCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_CascadeCullingSpheres</span>[MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_CascadeData</span>[MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> <span style="color: #7590db;">_DirectionalShadowMatrices</span>[MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT*MAX_CASCADE_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4x4</span> <span style="color: #7590db;">_OtherShadowMatrices</span>[MAX_SHADOWED_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherShadowTiles</span>[MAX_SHADOWED_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ShadowDistanceFade</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ShadowAtlasSize</span>;
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="org4ebf284"></a>Light.hlsl<br />
<div class="outline-text-8" id="text-org4ebf284">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Light.hlsl</span>
CBUFFER_START(<span style="color: #7590db;">_CustomLight</span>)
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_DirectionalLightCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightColors</span>[MAX_DIRECTIONAL_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightDirectionsAndMasks</span>[MAX_DIRECTIONAL_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DirectionalLightShadowData</span>[MAX_DIRECTIONAL_LIGHT_COUNT];

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">_OtherLightCount</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightColors</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightPositions</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightDirectionsAndMasks</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightSpotAngles</span>[MAX_OTHER_LIGHT_COUNT];
    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_OtherLightShadowData</span>[MAX_OTHER_LIGHT_COUNT];
CBUFFER_END
</pre>
</div>
</div>
</li>
<li><a id="orgf005aef"></a>参考资料<br />
<div class="outline-text-8" id="text-orgf005aef">
<ul class="org-ul">
<li>SRPBatcher Doc <a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a><br /></li>
<li>SRPBatcher 加速渲染 <a href="https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran">https://connect.unity.com/p/srp-batcher-jia-su-xuan-ran</a><br /></li>
<li>从 DX 角度看 SRPBatcher <a href="https://zhuanlan.zhihu.com/p/508206639">https://zhuanlan.zhihu.com/p/508206639</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org5b0600a"></a>GPU Instancing<br />
<ul class="org-ul">
<li><a id="orgb6716cf"></a>MaterialPropertyBlock 实现多个物体使用同一个材质，而拥有不同材质属性<br />
<div class="outline-text-8" id="text-orgb6716cf">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">PerObjectMaterialProperties.cs</span>
  <span style="color: #4f97d7; font-weight: bold;">using</span> UnityEngine;
  [<span style="color: #7590db;">DisallowMultipleComponent</span>]
  <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> PerObjectMaterialProperties : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
  {
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">baseColorId</span> = Shader.<span style="color: #bc6ec5; font-weight: bold;">PropertyToID</span>(<span style="color: #2d9574;">"_BaseColor"</span>);
      [<span style="color: #7590db;">SerializeField</span>]
      Color baseColor = Color.white;
      <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span> <span style="color: #7590db;">block</span>;

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Awake</span>()
      {
          <span style="color: #bc6ec5; font-weight: bold;">OnValidate</span>();
      }

      <span style="color: #4f97d7; font-weight: bold;">private</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnValidate</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">if</span>(block==<span style="color: #a45bad;">null</span>)
          {
              block = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">MaterialPropertyBlock</span>();
          }
          block.<span style="color: #bc6ec5; font-weight: bold;">SetColor</span>(baseColorId, baseColor);
          <span style="color: #bc6ec5; font-weight: bold;">GetComponent</span>&lt;<span style="color: #ce537a; font-weight: bold;">Renderer</span>&gt;().<span style="color: #bc6ec5; font-weight: bold;">SetPropertyBlock</span>(block);
      }
  }
</pre>
</div>
</div>
</li>
<li><a id="org8a3c548"></a>GPU Instancing<br />
<div class="outline-text-8" id="text-org8a3c548">
<p>
GPU instancing 适用于每个物体具有不同材质属性的情况。其只需要为多个物体发布一个 draw call，但是这些物体必须使用相同的 mesh。CPU 会收集每个物体的变换矩阵和材质属性，并将他们放到一个数组中，然后发送给 GPU，GPU 按照数据被提供的顺序遍历进行渲染。<br />
</p>

<p>
注意：GPU instancing 多个物体必须是相同的材质实体。不同的材质实体，就算材质属性完全相同也不能合批。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// &#29992;&#20110;&#24320;&#21551;GPU Instancing</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile_instancing
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org8093491"></a>Dynamic Batching<br />
<div class="outline-text-7" id="text-org8093491">
<p>
Dynamic Batching 会将多个共享相同材质的小 mesh 合并为一个大 mesh（Sphere 的 Mesh 比较大，不支持 DynamicBatching，Cube 支持）。该方法不支持每个物体具有不同材质属性的情况。<br />
通常 GPU Instancing 要比 Dynamic Batching 要更好。Dynamic Batching 会有一些陷阱，例如当物体的 scale 不同时，合成的大 mesh 的 normal 向量不保证是归一化的。<br />
</p>

<p>
事先被标记为 Batching-Static 的物体会执行 Static Batching，其和 Dynamic Batching 工作方式类似，除了需要更多的内存和存储空间外，其没有其他陷阱。<br />
</p>

<p>
按照下面方式开启 Dynamic Batching:<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #ce537a; font-weight: bold;">var</span> <span style="color: #7590db;">drawingSettings</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">DrawingSettings</span>(unlitShaderTagId, sortingSettings)
  {
      enableDynamicBatching = <span style="color: #a45bad;">true</span>,
      enableInstancing = <span style="color: #a45bad;">false</span>
  };
</pre>
</div>
</div>
</li>
<li><a id="org888e790"></a>Batching Compare<br />
<div class="outline-text-7" id="text-org888e790">
<ul class="org-ul">
<li>Static Batching <a href="#org6e3e375">Baching 简介</a><br /></li>
<li>Dynamic Batching <a href="#org6e3e375">Baching 简介</a><br /></li>
<li>GPU Instancing <a href="#org6e3e375">Baching 简介</a><br /></li>
<li>SRP Batching <a href="#org5e827e3">Batching</a><br /></li>

<li>Draw call batching <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br /></li>
<li>Static Batching <a href="https://docs.unity3d.com/Documentation/Manual/static-batching.html">https://docs.unity3d.com/Documentation/Manual/static-batching.html</a><br /></li>
<li>Dynamic Batching <a href="https://docs.unity3d.com/Manual/dynamic-batching.html">https://docs.unity3d.com/Manual/dynamic-batching.html</a><br /></li>
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
<li>SRPBatcher <a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5bd688b" class="outline-6">
<h6 id="org5bd688b">Transparency</h6>
</div>
</div>
<div id="outline-container-org899c6a0" class="outline-5">
<h5 id="org899c6a0">Directianl Lights</h5>
<div class="outline-text-5" id="text-org899c6a0">
</div>
<div id="outline-container-orgdc55eb3" class="outline-6">
<h6 id="orgdc55eb3">Lighting</h6>
<div class="outline-text-6" id="text-orgdc55eb3">
</div>
<ul class="org-ul">
<li><a id="orgd0b5c99"></a>如何可视化光栅化对顶点 normal 线性插值后，normal 不再归一化？<br />
<div class="outline-text-7" id="text-orgd0b5c99">
<div class="org-src-container">
<pre class="src src-shader">base.rgb = <span style="color: #4f97d7;">abs</span>(<span style="color: #4f97d7;">length</span>(input.normalWS) - 1.0) * 10.0;
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge94f50a" class="outline-6">
<h6 id="orge94f50a">BRDF</h6>
<div class="outline-text-6" id="text-orge94f50a">
<p>
Incoming Light : 光线方向和表面法线没有对齐时，表面接受到的入射光能量会变小。通过为入射光添加 N.L 系数可以实现该规律。<br />
Outgoing Light : 出射光线的分布有三种类型。完美镜面反射（Specular Reflection）、模糊反射（Glossy Reflection）、漫反射（Diffuse）<br />
由于表面光滑，Specular Reflection 会将入射光反射到同一个方向。<br />
由于微表面朝向不同，Glossy Reflection 会将入射光反射到偏离反射方向的方向上。<br />
光线进入物体后，Diffuse 会将入射光向各个方向等概率反射出来。<br />
</p>

<p>
表面对光的反射是各不相同的，通常金属会将光按照 Specular Reflection 全部反射，其没有 Diffuse。电介质(非金属)也会有 Specular Reflection，不同电介质反射不同，其平均值为 0.04。<br />
<a href="../theory/PhysicalTheory.html#org5196ca9">../theory/PhysicalTheory.html#org5196ca9</a><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org90376bd" class="outline-5">
<h5 id="org90376bd">Directional Shadows</h5>
<div class="outline-text-5" id="text-org90376bd">
</div>
<div id="outline-container-org2c79118" class="outline-6">
<h6 id="org2c79118">Rendering Shadows</h6>
<div class="outline-text-6" id="text-org2c79118">
<p>
将 RT 分割为多个 Tile，设置 viewPort 来支持将多个方向光的阴影贴图画到同一个 RT 上。<br />
</p>
</div>
</div>
<div id="outline-container-orgedb0821" class="outline-6">
<h6 id="orgedb0821">Sampling Shadows</h6>
<div class="outline-text-6" id="text-orgedb0821">
</div>
<ul class="org-ul">
<li><a id="org816be30"></a>为什么要使用翻转的 ZBuffer（Reversed-ZBuffer）？<br />
<div class="outline-text-7" id="text-org816be30">
<p>
使用 0 表示深度为 0，使用 1 表示深度为最大，这样很直观。但是，反向 ZBuffer 再加上浮点型深度值可以增加深度位数的利用率，减少 ZFighting。具体原理如下文：<br />
</p>
<ul class="org-ul">
<li>反向 Z(Reversed-Z)的深度缓冲原理 <a href="https://zhuanlan.zhihu.com/p/75517534">https://zhuanlan.zhihu.com/p/75517534</a><br /></li>
</ul>
</div>
</li>
<li><a id="org3555933"></a>ConvertToAtlasMatrix 实现<br />
<div class="outline-text-7" id="text-org3555933">
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#25191;&#34892;&#23558;[-1,1]&#36716;&#21270;&#20026;[0, 1] &#32553;&#25918;0.5&#20877;&#20559;&#31227;0.5</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">    unity&#20351;&#29992;&#30340;&#21015;&#21521;&#37327;&#65292;&#30697;&#38453;&#38656;&#35201;&#24038;&#20056;</span>
<span style="color: #2aa1ae; background-color: #292e34;">    scaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0.5    0     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0    0.5     0    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0   0.5    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">    translateM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    1      0     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      1     0    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1    0.5</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>
<span style="color: #2aa1ae; background-color: #292e34;">  */</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#25191;&#34892; atlas &#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">    atlasOffsetM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    1      0     0    offsetX</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      1     0    offsetY</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1    0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0    1</span>

<span style="color: #2aa1ae; background-color: #292e34;">    atlasScaleM</span>
<span style="color: #2aa1ae; background-color: #292e34;">    scale  0     0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      scale 0     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     1     0</span>
<span style="color: #2aa1ae; background-color: #292e34;">    0      0     0     1</span>
<span style="color: #2aa1ae; background-color: #292e34;">  */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#26368;&#32456;&#32452;&#21512;&#20986;&#26469;&#30340;&#21464;&#25442;&#30697;&#38453;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">atlasScaleM * atlasOffsetM * translateM * scaleM * originM</span>
</pre>
</div>
<ul class="org-ul">
<li>行向量和列向量对比 <a href="../theory/ComputerGraphicMath.html#org0426ee5">../theory/ComputerGraphicMath.html#org0426ee5</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org78b2cc7" class="outline-6">
<h6 id="org78b2cc7">Cascaded Shadow Maps</h6>
<div class="outline-text-6" id="text-org78b2cc7">
<p>
绘制方向光的阴影贴图时使用的是正交投影，因此阴影贴图上的一个图元对应了世界空间中固定大小的尺寸，如果该尺寸太大，会导致每个阴影贴图图元都占据多个像素，这会导致阴影边缘有锯齿，以及小的阴影会消失。该问题可以通过增加阴影贴图大小来缓解。<br />
当使用透视投影时，场景中越远的物体会变的越小。在某个可视距离阴影贴图上的一个图元只会对应显示器上的一个像素，这是理论上最优的。越靠近摄像机我们需要越高的阴影贴图分辨率，而远处的地方低分辨率的阴影贴图也足够了。理想的情况是，我们依据阴影接受者距离摄像机的距离，动态改变阴影贴图的精度。<br />
Cascaded Shadows maps 的理念是，将投摄阴影的物体渲染多次，这样每个光照在 atlas 上就对应了多个 Tile，这就被称为多个层级。第一个层级只会覆盖靠近摄像机的一小片区域，随后的层级会逐渐放大覆盖的区域。shader 中会采样最合适的层级。<br />
</p>

<p>
Unity 会创建一个 culling sphere 用于确定每个层级所覆盖的区域。阴影的投影矩阵为正交矩阵，视景体为长方体，其和 Culling Sphere 比较接近，但是还包含了 Sphere 周围的空间。因此 culling 区域外的阴影也可以被看到。光的方向和 Culling Sphere 是无关的（该 CullingSphere 和摄像机位置相关），因此所有的方向光使用相同的 culling spheres。<br />
</p>

<p>
这些 spheres 也用于确定，从哪个层级的阴影贴图进行采样。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3fe0cd0"></a>Shadow Fade<br />
<div class="outline-text-7" id="text-org3fe0cd0">
<p>
阴影渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_fade_shadow.jpg" alt="03_04ds_fade_shadow.jpg" /><br />
Cascade 渐变原理如下：<br />
<img src="./UnityCatLikeCoding/03_04ds_cascade_fade.jpg" alt="03_04ds_cascade_fade.jpg" /><br />
</p>
</div>
</li>
<li><a id="org472868d"></a>Shadow Quality<br />
<ul class="org-ul">
<li><a id="orgf5ce89d"></a>Depth Bias<br />
<div class="outline-text-8" id="text-orgf5ce89d">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalDepthBias.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-csharp">buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(50000f, 0f);
<span style="color: #bc6ec5; font-weight: bold;">ExcuteBuffer</span>();
context.<span style="color: #bc6ec5; font-weight: bold;">DrawShadows</span>(<span style="color: #4f97d7; font-weight: bold;">ref</span> <span style="color: #ce537a; font-weight: bold;">shadowSettings</span>);
buffer.<span style="color: #bc6ec5; font-weight: bold;">SetGlobalDepthBias</span>(0f, 0f);
</pre>
</div>
</div>
</li>
<li><a id="org405ef42"></a>NormalBias<br />
<div class="outline-text-8" id="text-org405ef42">
<p>
不正确的自阴影是由于投影的深度贴图图元覆盖了多个片段，这导致投影体从其表面伸出来。因此如果将投影体缩小足够大小，该问题将不会出现。但是，缩放投影体会导致阴影比原来要小。<br />
我们也可以从相反的方向来做：在采样阴影贴图时，将物体表面放大。这样我们就会采样远离表面一段距离的深度值，只要足够远就可以避免不正确的自阴影。这会稍微改变阴影的位置，可能会导致边缘的不对其以及错误的阴影，但是这点瑕疵比 Peter-Panning 要小很多。<br />
</p>
</div>
</li>
<li><a id="org76fa121"></a>Shadow Pancaking<br />
<div class="outline-text-8" id="text-org76fa121">
<p>
在为一个方向光渲染阴影投射体时，应该尽量将摄像机近平面往前移，这样可以增加深度精度，但是，这意味着投影体可能会不再摄像机视野内，其可能在近平面之前，这会导致该物体被裁剪，而其本不该被裁剪。<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_01.png" alt="03_04ds_shadow_error_01.png" /><br />
通过下面代码可以处理该问题：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  Varyings <span style="color: #bc6ec5; font-weight: bold;">ShadowCasterPassVertex</span>(Attributes input)
  {
      Varyings output;
      UNITY_SETUP_INSTANCE_ID(input);
      UNITY_TRANSFER_INSTANCE_ID(input, output);
      <span style="color: #ce537a; font-weight: bold;">float3</span> positionWS = TransformObjectToWorld(input.positionOS);
      <span style="color: #2aa1ae; background-color: #292e34;">// Transform World to Homogeneous Clip</span>
      output.positionCS = TransformWorldToHClip(positionWS);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#28210;&#26579;&#26041;&#21521;&#20809;&#20351;&#29992;&#30340;&#26159;&#27491;&#20132;&#25237;&#24433;, &#23558;&#36817;&#24179;&#38754;&#21069;&#30340;&#29289;&#20307;&#31227;&#21040;&#36817;&#24179;&#38754;</span>
<span style="color: #bc6ec5;">      #if</span> UNITY_REVERSED_Z
      output.positionCS.z = <span style="color: #4f97d7;">min</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">      #else</span>
      output.positionCS.z = <span style="color: #4f97d7;">max</span>(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #ce537a; font-weight: bold;">float4</span> baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, <span style="color: #7590db;">_BaseMap_ST</span>);
      output.baseUV = input.baseUV * baseST.xy + baseST.zw;
      <span style="color: #4f97d7; font-weight: bold;">return</span> output;
  }
</pre>
</div>

<p>
上面的处理方式会导致新的问题，因为对于横穿近平面的物体，其只有部分顶点的数据是正确的，如果物体很大，其阴影会变形。下图展示了这种错误：<br />
<img src="./UnityCatLikeCoding/03_04ds_shadow_error_02.png" alt="03_04ds_shadow_error_02.png" /><br />
</p>

<p>
该问题可以通过支持 light 的 shadowNearPlane 来避免。也可以将大物体划分为小物体。<br />
</p>
<ul class="org-ul">
<li>Shadow pancaking <a href="https://docs.unity3d.com/Manual/ShadowPerformance.html">https://docs.unity3d.com/Manual/ShadowPerformance.html</a><br /></li>
</ul>
</div>
</li>

<li><a id="org16e8f3e"></a>PCF Shadow<br />
<div class="outline-text-8" id="text-org16e8f3e">
<p>
扩大采样区域后会导致 Shadow Acne 再次出现。需要对应增加 normal biase。<br />
扩大采样区域后意味着，我们可以采样到 cascade culling sphere 外面的区域。通过减小 culling sphere 半径来避免该问题。<br />
</p>
</div>
</li>

<li><a id="org6f8b79a"></a>Blending Cascades<br />
<div class="outline-text-8" id="text-org6f8b79a">

<div id="orgcc431dc" class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_blend_cascade_shadow.png" alt="03_04ds_blend_cascade_shadow.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="org5973237"></a>Culling Bias<br />
<div class="outline-text-8" id="text-org5973237">
<p>
使用 Cascaded Shadow Maps 的一个缺点是，对于每个灯光，我们需要渲染相同的投影体多次。如果可以为高层级的 Cascade 剔除一些阴影投射体，并保证其内容总是被低层级的 Cascade 所覆盖，则会节省很多 DrawCall。如下参数可以实现该功能：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">splitData.shadowCascadeBlendCullingFactor = 1f;
</pre>
</div>


<div id="org38a519d" class="figure">
<p><img src="./UnityCatLikeCoding/03_04ds_culling_for_large_cascade.png" alt="03_04ds_culling_for_large_cascade.png" /><br />
</p>
</div>

<p>
shadowCascadeBlendCullingFactor 会被用于和 culling sphere 半径相乘，其值必须为(0,1)范围，值越大，Unity 会剔除越多的物体，值越低，多层级之间共享的渲染对象越多。使用比较低的值，就可以让不同层级之间在重叠区域做混合。<br />
</p>
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html">https://docs.unity3d.com/ScriptReference/Rendering.ShadowSplitData.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgb9fa095" class="outline-6">
<h6 id="orgb9fa095">Transparency</h6>
</div>
<div id="outline-container-org0128895" class="outline-6">
<h6 id="org0128895">Q&amp;A</h6>
<div class="outline-text-6" id="text-org0128895">
</div>
<ul class="org-ul">
<li><a id="org36970c6"></a>FrameDebug 中有无限多个<br />
<div class="outline-text-7" id="text-org36970c6">
<p>
CommandBuffer.BeginSample 和 CommandBuffer.EndSample 数量不对称会导致该问题。<br />
</p>
</div>
</li>
<li><a id="org0f6726f"></a>ERROR: Dimensions of color surface does not match dimensions of depth surface<br />
<div class="outline-text-7" id="text-org0f6726f">
<p>
CameraRenderer.cs 文件中 Render 函数内，先执行 Setup 后执行 lighting.Setup 就会出现该问题。因为 lighting.Setup 执行后，RT 没有切换回摄像机 RT，从 FrameDebug 可以看出该问题。<br />
<img src="./UnityCatLikeCoding/03_04ds_rt_error.jpg" alt="03_04ds_rt_error.jpg" /><br />
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org9df27b8" class="outline-5">
<h5 id="org9df27b8">Baked Light</h5>
<div class="outline-text-5" id="text-org9df27b8">
</div>
<div id="outline-container-org796c76b" class="outline-6">
<h6 id="org796c76b">Baking Static Light</h6>
<div class="outline-text-6" id="text-org796c76b">
<p>
光照可以被提前计算，然后将结果保存到光照贴图和 light probes 中。这种方式，有一个好处是，可以添加无法实时计算的间接光照效果。这种间接光照属于全局照明的一部分，间接光照不是直接从光源发出的光照，其为从环境或者发光表面经过间接反射照亮物体的光。<br />
</p>

<p>
Fully-Baked Light（Light 组件的 Mode 选择 Baked，Lighting Setting 的 LightingMode 选择 BakedIndirect） 会将直接光照和间接光照都烘培到光照贴图。<br />
</p>

<p>
环境间接光照 Intensity Multiplier 设置为 0 和 1 的对比：<br />
<img src="./UnityCatLikeCoding/03_05bl_env_indirect_light.png" alt="03_05bl_env_indirect_light.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgf01b2fd" class="outline-6">
<h6 id="orgf01b2fd">GPU Instancing 和烘培</h6>
<div class="outline-text-6" id="text-orgf01b2fd">
<p>
理论上来说，可以使用 TextureArray，让静态烘培物体 lightmap 不同时，依然可以 GPU Instancing。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5dbcdaf" class="outline-5">
<h5 id="org5dbcdaf">Shadow Masks</h5>
<div class="outline-text-5" id="text-org5dbcdaf">
<p>
Unity 也会将 ShadowMask 数据烘培到 LightProbes 中，通过如下方式可以采样 LightProbes 中的 ShadowMask 数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">SampleBakedShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightMapUV, Surface surfaceWS)
  {
<span style="color: #bc6ec5;">      #if</span> defined(LIGHTMAP_ON)
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SAMPLE_TEXTURE2D</span>(unity_ShadowMask, samplerunity_ShadowMask, lightMapUV);
<span style="color: #bc6ec5;">      #else</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x)
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">SampleProbeOcclusion</span>(
              TEXTURE3D_ARGS(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH),
              surfaceWS.position, unity_ProbeVolumeWorldToObject,
              unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z,
              unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz
          );
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          <span style="color: #4f97d7; font-weight: bold;">return</span> unity_ProbesOcclusion;
      }
<span style="color: #bc6ec5;">      #endif</span>
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org3e17f04" class="outline-5">
<h5 id="org3e17f04">LOD and Reflections</h5>
</div>
<div id="outline-container-org525fd35" class="outline-5">
<h5 id="org525fd35">Complex Maps</h5>
<div class="outline-text-5" id="text-org525fd35">
</div>
<div id="outline-container-org83df8ad" class="outline-6">
<h6 id="org83df8ad">Q&amp;A</h6>
<div class="outline-text-6" id="text-org83df8ad">
</div>
<ul class="org-ul">
<li><a id="orgc418753"></a>贴图设置中的 FadeOut Mip Maps 属性是做什么用的？<br />
<div class="outline-text-7" id="text-orgc418753">
<p>
FadeOut Mip Maps 主要用于避免远处 DetailMap 有明显的 tiling 模式。<br />
</p>

<ul class="org-ul">
<li>FadeOut Mip Maps <a href="https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/">https://forum.unity.com/threads/what-is-the-fadeout-mip-maps-for.83268/</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf57f68c" class="outline-5">
<h5 id="orgf57f68c">Point and Spot Lights</h5>
<div class="outline-text-5" id="text-orgf57f68c">
</div>
<div id="outline-container-orgc9190ec" class="outline-6">
<h6 id="orgc9190ec">Lights Per Object</h6>
<div class="outline-text-6" id="text-orgc9190ec">
<p>
Unity 确定每个物体会由哪些光照所影响，并将该信息发送给 GPU。这样在渲染每个物体时，只需要计算影响该物体的光照，而忽略不影响该物体的光照。这种方案对于很多小物体组成的场景来说是很适用的，而对于大物体来说则不适用，因为如果光照只影响大物体的一小部分区域，在渲染该大物体时，依然需要对其整个表面执行光照计算。<br />
</p>

<p>
需要注意的是，当开启 LightsPerObject 后，GPU instancing 可能会失效，因为只有受光照印象数量相同，并且索引列表匹配的物体才会被分为一组。SRP batcher 则不受影响。<br />
</p>
</div>
</div>
<div id="outline-container-orge61c59f" class="outline-6">
<h6 id="orge61c59f">Q&amp;A</h6>
<div class="outline-text-6" id="text-orge61c59f">
</div>
<ul class="org-ul">
<li><a id="orgef6d3bf"></a><span class="todo TODO">TODO</span> 灯光的位置、方向为什么可以通过 localToWorldMatrix 矩阵获取？<br />
<div class="outline-text-7" id="text-orgef6d3bf">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">spot light</span>
<span style="color: #ce537a; font-weight: bold;">Vector4</span> <span style="color: #7590db;">position</span> = visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(3);
otherLightDirections[index] = -visibleLight.localToWorldMatrix.<span style="color: #bc6ec5; font-weight: bold;">GetColumn</span>(2);
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgd54e260" class="outline-5">
<h5 id="orgd54e260">Point and Spot Shadows</h5>
<div class="outline-text-5" id="text-orgd54e260">
</div>
<div id="outline-container-org7dfba89" class="outline-6">
<h6 id="org7dfba89">Q&amp;A</h6>
<div class="outline-text-6" id="text-org7dfba89">
</div>
<ul class="org-ul">
<li><a id="org477e38b"></a><span class="todo TODO">TODO</span> 解决 Spot Light Shadow Acne 问题的原理？<br /></li>
<li><a id="org340a081"></a>Unity 渲染 Point Light 阴影时会从上往下渲染，导致渲染的物体为背面，如何转化为正面渲染物体？<br />
<div class="outline-text-7" id="text-org340a081">
<div class="org-src-container">
<pre class="src src-csharp">cullingResults.<span style="color: #bc6ec5; font-weight: bold;">ComputePointShadowMatricesAndCullingPrimitives</span>(
                light.<span style="color: #ce537a; font-weight: bold;">visibleLightIndex</span>, (<span style="color: #ce537a; font-weight: bold;">CubemapFace</span>)i, fovBias*0,
                <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">viewMatrix</span>, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">Matrix4x4</span> <span style="color: #7590db;">projectionMatrix</span>,
                <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">ShadowSplitData</span> <span style="color: #7590db;">splitData</span>
            );
viewMatrix.m11 = -viewMatrix.m11;
viewMatrix.m12 = -viewMatrix.m12;
viewMatrix.m13 = -viewMatrix.m13;
</pre>
</div>
</div>
</li>
<li><a id="org55f2bcc"></a>Fov Bias 如何求解？<br />
<div class="outline-text-7" id="text-org55f2bcc">
<p>
Fov Bias 计算原理如下：<br />
<img src="./UnityCatLikeCoding/03_10pss_point_light_fovBias.png" alt="03_10pss_point_light_fovBias.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">fovBias</span> = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Atan</span>(1f + bias + filterSize) * Mathf.Rad2Deg * 2f - 90f;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb4ff71b" class="outline-5">
<h5 id="orgb4ff71b">Post Processing</h5>
<div class="outline-text-5" id="text-orgb4ff71b">
</div>
<div id="outline-container-orgbe31189" class="outline-6">
<h6 id="orgbe31189">CommandBuffer.DrawProcedural</h6>
<div class="outline-text-6" id="text-orgbe31189">
<p>
CommandBuffer.DrawProcedural 该函数会在 GPU 上执行一个 DrawCall，但是没有任何 vertex 或 index buffer。通常在 vertex shader 中，通过使用 SV_VertexID 和 SV_InstanceID 来从某些 buffer 中获取数据。<br />
SV_VertexID 为顶点编号。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html">https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5cc3a57" class="outline-6">
<h6 id="org5cc3a57">使用双线性过滤优化高斯模糊的原理是什么？</h6>
<div class="outline-text-6" id="text-org5cc3a57">
<p>
GPU 对贴图的双线性过滤通过硬件实现，性能非常高。使用双线性过滤，一次采样可以获得 4 个样本点的值，利用 GPU 的双线性过滤，通过对采样点位置进行调整可以实现和高斯 Filter 等价的权重。<br />
</p>

<ul class="org-ul">
<li>基于线性采样的高效高斯模糊实现 cn <a href="https://zhuanlan.zhihu.com/p/58182228">https://zhuanlan.zhihu.com/p/58182228</a><br /></li>
<li>基于线性采样的高效高斯模糊实现 en <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a><br /></li>
<li>高斯模糊的几种优化方法 <a href="https://cloud.tencent.com/developer/article/1035559">https://cloud.tencent.com/developer/article/1035559</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org83e72f4" class="outline-5">
<h5 id="org83e72f4">HDR</h5>
<div class="outline-text-5" id="text-org83e72f4">
</div>
<div id="outline-container-org4fcf2e0" class="outline-6">
<h6 id="org4fcf2e0">High Dynamic Range</h6>
<div class="outline-text-6" id="text-org4fcf2e0">
</div>
<ul class="org-ul">
<li><a id="org971705f"></a>HDR Post Processing<br />
<div class="outline-text-7" id="text-org971705f">
<p>
HDR 和 LDR bloom 的区别可能是非常大，也可能非常小，这取决于场景的亮度。通常 bloom 的 threshold 被设置为 1，因此只有 HDR 颜色会对 bloom 效果产生贡献。这样画面上闪耀的颜色表示其对于显示器来说太亮了。<br />
因为 bloom 效果的原理是平均颜色，因此即使一个非常亮的像素最终可能影响一大片区域。例如，当 2x2 块的颜色值分别为 0,0,0,1 时，由于 downsampling 的平均，最终的颜色值为 0.25。但是如果是 HDR 版本的平均 0,0,0 和 10，则最终的颜色值为 2.5。<br />
</p>
</div>
</li>
<li><a id="orge746911"></a>Fighting Fireflies<br />
<div class="outline-text-7" id="text-orge746911">
<p>
HDR 的一个缺点是，其会导致图片上一小片区域的亮度比其周围大很多。当这些区域的大小为一个像素或者更小时，其可以极大地改变相对大小，并在运动过程中突然出现或消失，这会导致闪烁。这些区域被称为萤火虫。当应用 bloom 时，这些区域会出现频闪。<br />
完全消除该问题需要无限大的分辨率，这是不可能的。我们可以在 Pre-Filtering 阶段更激进地对图片进行模糊，将 fireflies 淡出。<br />
在 PreFiltering 阶段，对周围 9 个像素点进行采样，每个采样点的颜色按照 1/(l+1)分配权重，l为该颜色的亮度(luminance)。其原理如下图所示：<br />
</p>


<div id="org58f52db" class="figure">
<p><img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies.png" alt="03_11hdr_bloom_fireflies.png" /><br />
</p>
</div>

<p>
因为在 Pre-Filtering 后会执行 GaussianBlur，因此前面对 9 个像素的采样可以优化为对 5 个像素的采样：<br />
<img src="./UnityCatLikeCoding/03_11hdr_bloom_fireflies02.png" alt="03_11hdr_bloom_fireflies02.png" /><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf58ff34" class="outline-6">
<h6 id="orgf58ff34">Scattering Bloom</h6>
<div class="outline-text-6" id="text-orgf58ff34">
<p>
摄像机不是完美的，其镜头无法正确聚焦所有的光。一部分光会散射到更大的区域，就如目前我们实现的 bloom 效果一样。越好的摄像机会散射越少的光。摄像机镜头对光的散射和目前实现的 additive bloom 效果的最大区别为，摄像机镜头对光的散射不会增加光照，其只会将光照 diffuse 化。人眼也不是完美的，进入人眼的光也会被散射。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8ee507f"></a>Bloom 流程<br />
<div class="outline-text-7" id="text-org8ee507f">
<p>
下图为迭代三次的 Boom 流程图：<br />
<img src="./UnityCatLikeCoding/03_11pp_bloom.png" alt="03_11pp_bloom.png" /><br />
</p>

<p>
Pre-FilterPass 中将大于 Threshold 的颜色筛选出来。<br />
BlurHorizontalPass BlurVerticalPass 对上一步筛选出来的像素进行高斯模糊，BlurHorizontalPass 还执行 Downsampling 操作。<br />
CombinePass 将模糊后的和模糊前的图片进行合并。<br />
</p>
</div>
</li>
<li><a id="orge844c61"></a>Scatter Limits<br />
<div class="outline-text-7" id="text-orge844c61">
<p>
在 BloomSettings 中添加 scatter 变量来控制被散射的光的量。当 scatter=0，表示完全不散射。当 scatter=1，表示完全散射。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomCombineScatterPassFragment</span>(Varyings input) : SV_TARGET
  {
      <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>)
      {
          lowRes = GetSourceBicubic(input.fxUV).rgb;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          lowRes = GetSource(input.fxUV).rgb;
      }
      <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// scatter = 0 &#21017;&#19981;&#25955;&#23556; scatter=1&#21017;&#23436;&#20840;&#25955;&#23556;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
  }
</pre>
</div>
</div>
</li>
<li><a id="orgcf0acea"></a>Threshold<br />
<div class="outline-text-7" id="text-orgcf0acea">
<p>
Scattering Bloom 在最终 Combine 阶段需要对 lowRes 进行补偿，因为 lowRes 中只包含了需要 Bloom 的部分(即超过 Threshold 值的颜色)。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">BloomScatterFinalPassFragment</span> (Varyings input) : SV_TARGET {
      <span style="color: #ce537a; font-weight: bold;">float3</span> lowRes;
      <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #7590db;">_BloomBicubicUpsampling</span>) {
          lowRes = GetSourceBicubic(input.fxUV).rgb;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span> {
          lowRes = GetSource(input.fxUV).rgb;
      }
      <span style="color: #ce537a; font-weight: bold;">float3</span> highRes = GetSource2(input.fxUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// &#23545;lowRes&#36827;&#34892;&#34917;&#20607;</span>
      lowRes += highRes - ApplyBloomThreshold(highRes);
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(<span style="color: #4f97d7;">lerp</span>(highRes, lowRes, <span style="color: #7590db;">_BloomIntensity</span>), 1.0);
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org42289e6" class="outline-6">
<h6 id="org42289e6">Tone Mapping</h6>
<div class="outline-text-6" id="text-org42289e6">
<p>
尽管我们可以在 HDR 模式下进行渲染，但是对于常规的摄像机，其最终的 frameBuffer 总是 LDR 格式的。这使得颜色通道被裁剪为 1，实际上最终图片上的白点的值为 1。特别量的颜色最终和完全饱和的颜色看起来是没有差别的。下图的场景中，包含了多个等级的光照，以及多个发光的物体。其中最强的发光体的亮度为 8，最亮的光源光照强度为 200.<br />
</p>

<p>
<img src="./UnityCatLikeCoding/03_11pp_non_fx_001.png" alt="03_11pp_non_fx_001.png" /><br />
没有使用后期效果，很难看出那个物体或者那个光源是亮度最强的。下图为使用了 Bloom 后期特效后的效果：<br />
<img src="./UnityCatLikeCoding/03_11pp_use_fx_001.png" alt="03_11pp_use_fx_001.png" /><br />
上图中发光的物体明显是比较亮的，但是依然无法确定其相对于场景中剩余物体有多亮。调整图片的亮度使得最亮的颜色不要超过 1，这样就可以确定物体之间的相对亮度关系了。我们可以统一将整个图片变暗，但是这会导致图片中的大部分颜色变得太暗，以至于无法清晰看到。理想的情况是，我们对于很亮的颜色调节很多，而对于暗的颜色调节很少。因此，我们需要非统一的颜色调节方案。这样的颜色调节并不是光源自身的物理属性改变，而是光源被人感知的变化。例如，我们的眼睛对于暗的色调比亮的色调更加敏感。<br />
</p>

<p>
将 HDR 转换为 LDR 的操作被称为 Tone Mapping，其源于摄影和电影的发展。传统的照片和电影也是只具有有限的亮度范围，以及非统一的光照敏感度，因此很多技术被开发出来用于执行 ToneMapping。没有唯一正确的 ToneMapping。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8801788"></a>Reinhard<br />
<div class="outline-text-7" id="text-org8801788">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ToneMappingReinhardPassFragment</span> (Varyings input) : SV_TARGET
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> color = GetSource(input.fxUV);
      color.rgb /= color.rgb + 1.0;
      <span style="color: #4f97d7; font-weight: bold;">return</span> color;
  }
</pre>
</div>
</div>
</li>
<li><a id="org5a5fbcb"></a>Neutral<br />
<div class="outline-text-7" id="text-org5a5fbcb">
<p>
Reinhard tone mapping 的 white point 理论上为无穷大。下图中对 Reinhard Tone Mapping 进行改进，可以支持配置 white point 的值。<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_reinhard01.png" alt="03_11pp_tonemapping_reinhard01.png" /><br />
下图为 Uncharted2 中使用的 ToneMapping：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_uncharted2.png" alt="03_11pp_tonemapping_uncharted2.png" /><br />
下图为 Unity 中的 NeutralToneMap：<br />
<img src="./UnityCatLikeCoding/03_11pp_tonemapping_neutral.png" alt="03_11pp_tonemapping_neutral.png" /><br />
</p>
</div>
</li>
<li><a id="org581a900"></a>ACES<br />
<div class="outline-text-7" id="text-org581a900">
<p>
ACES Tonemapping 和其他模式的最大区别在于，ACES 对于特别亮的颜色会执行色域偏移，将其推向白色。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc61f735" class="outline-5">
<h5 id="orgc61f735">Color Grading</h5>
<div class="outline-text-5" id="text-orgc61f735">
</div>
<div id="outline-container-org95bea1a" class="outline-6">
<h6 id="org95bea1a">Color Adjustments</h6>
<div class="outline-text-6" id="text-org95bea1a">
<p>
粗略来算，调节视频、照片和数字图片的颜色分三个步骤:<br />
首先是颜色矫正，其目的是为了让图像匹配我们所观察到的场景，以补偿媒介的局限性。<br />
其次是色彩分级(color grading)，其为了得到期望的外观和感觉，这种结果和原始场景不匹配，而且也不需要逼真。这两个步骤通常被合并到同一个 color grading 步骤中。<br />
最后是色调映射（Tone Mapping），其将 HDR 颜色映射到显示器的显示范围。<br />
</p>

<p>
对图像只使用 tone mapping，会让图像趋向更加缺乏色彩，除非图像非常明亮。ACES 稍微增加了暗颜色的对比，但是其无法代替 color grading。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgf5fd5f1"></a>Post Exposure<br />
<div class="outline-text-7" id="text-orgf5fd5f1">
<p>
Post Exposure 用于模拟摄像机的曝光，但是其被用于其他后期效果之后，并在其他 color grading 效果之前。其是一个非真实感的美术工具，可用于微调曝光而不影响其他效果，例如 bloom。<br />
</p>
</div>
</li>
<li><a id="org121888a"></a>Constrast Saturate<br />
<div class="outline-text-7" id="text-org121888a">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradingContrast</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color) {
      color = LinearToLogC(color);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#33410;&#23545;&#27604;&#24230;&#30340;&#31639;&#27861;</span>
      color = (color - ACEScc_MIDGRAY) * <span style="color: #7590db;">_ColorAdjustments</span>.y + ACEScc_MIDGRAY;
      <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">LogCToLinear</span>(color);
  }

  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeSaturation</span>(<span style="color: #ce537a; font-weight: bold;">float3</span> color)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> luminance = Luminance(color);
      <span style="color: #2aa1ae; background-color: #292e34;">// &#35843;&#33410;&#39281;&#21644;&#24230;&#30340;&#31639;&#27861;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> (color - luminance) * <span style="color: #7590db;">_ColorAdjustments</span>.w + luminance;
  }
</pre>
</div>

<p>
调节对比度和饱和度的公式类似，saturate 为直线的斜率，saturate 的范围为(0-2)，(1-saturate)*luminance 为直线 y 轴截距。<br />
saturate 为 0 时，最终颜色为 luminance，最终颜色只有明暗没有色彩。<br />
saturate 为 1 时，最终颜色为 color，饱和度和明度都没有变化。<br />
saturate 为 2 时，最终颜色为 color*2 - luminance，最终颜色的明度没有改变，色彩值翻倍。<br />
<img src="./UnityCatLikeCoding/03_12cg_saturate.png" alt="03_12cg_saturate.png" /><br />
<a href="./UnityCatLikeCoding/03_12cg_saturate.ggb">./UnityCatLikeCoding/03_12cg_saturate.ggb</a><br />
</p>

<ul class="org-ul">
<li><a href="https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0</a><br /></li>
</ul>
</div>
</li>
<li><a id="orge919ffb"></a>Color Filter<br />
<div class="outline-text-7" id="text-orge919ffb">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">ColorGradeColorFilter</span> (<span style="color: #ce537a; font-weight: bold;">float3</span> color)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// ColorFilter &#30340;&#31639;&#27861;</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> color * <span style="color: #7590db;">_ColorFilter</span>.rgb;
  }
</pre>
</div>
</div>
</li>
<li><a id="orge7ce6fb"></a>Hue Shift<br /></li>
<li><a id="org1b7eb79"></a>White Balance<br />
<div class="outline-text-7" id="text-org1b7eb79">
<p>
白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；<br />
白平衡本质上是调节两个参数：色温和色调，色温调节蓝-黄偏色，色调调节绿-品红偏色。通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换；<br />
</p>

<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/27165715">https://zhuanlan.zhihu.com/p/27165715</a><br /></li>
</ul>
</div>
</li>
<li><a id="org83a328c"></a>Split Toning<br />
<div class="outline-text-7" id="text-org83a328c">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="orgeb63cfe"></a>Channel Mixer<br />
<div class="outline-text-7" id="text-orgeb63cfe">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="orgc8d7ff0"></a>Shadows Midtones Highlights<br />
<div class="outline-text-7" id="text-orgc8d7ff0">
<p>
TODO 原理<br />
</p>
</div>
</li>
<li><a id="orgb9e8086"></a>ACES Color Spaces<br />
<div class="outline-text-7" id="text-orgb9e8086">
<p>
当使用 ACES tone mapping 时，为了得到更好的结果，Unity 在 ACES 颜色空间下执行大多数 color grading。<br />
Post exposure 和 white balance 总是在线性空间下被应用。从 Constrast 开始，将 linear color 转化为 ACEScc 颜色空间。<br />
</p>

<p>
ACEScc 使用对数颜色编码，并具有使颜色分级工具感觉更像在许多配色师喜欢的对数空间中工作时的感觉的优势。<br />
ACEScct 类似于 ACEScc，但是在编码中添加了 “趾”，因此在使用提升操作时，响应感觉与传统的原木胶片扫描更加相似。这种准对数行为被描述为更“乳白色” 或“起雾”。ACEScct 是在 ACES 1.03 规范中添加的，它是基于许多配色师的反馈而替代 ACEScc 的。<br />
ACEScg 利用线性颜色编码，是为 VFX / CGI 艺术家设计的，因此他们的工具表现得更传统。<br />
</p>

<p>
unity_to_ACES  可以从 linear color 转化为 ACES 颜色空间<br />
ACES_to_ACEScc 可以从 ACES 转化为 ACEScc 颜色空间<br />
ACEScc_to_ACES 可以从 ACEScc 颜色空间转化为 ACES 颜色空间<br />
ACES_to_ACEScg 可以从 ACES 颜色空间转化为 ACEScg 颜色空间<br />
</p>

<ul class="org-ul">
<li>ACES <a href="https://www.bilibili.com/read/cv5492119/">https://www.bilibili.com/read/cv5492119/</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge653981" class="outline-6">
<h6 id="orge653981">LUT</h6>
<div class="outline-text-6" id="text-orge653981">
<p>
为每个像素执行所有的 color grading 步骤需要很多工作量。我们可以定义一些变体，从而只应用对内容有修改的 color grading，但是这需要很多 Keywords 或 Passes。我们可以将 color grading 烘培到一个 loopup table(LUT)中，通过对该 LUT 进行采样来执行颜色转换。这样的 LUT 为一个 3D 贴图，通常大小为 32x32x32。填充该贴图，运行时对该贴图采样比直接对整张图片执行 color grading 计算要少很多工作量。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org2bbdaa4"></a>LUT Color Matrix<br />
<div class="outline-text-7" id="text-org2bbdaa4">
<ul class="org-ul">
<li>TODO LUT Texture 生成时，传入的颜色如何计算？<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// Returns the default value for a given position on a 2D strip-format color lookup table</span>
<span style="color: #2aa1ae; background-color: #292e34;">// params = (lut_height, 0.5 / lut_width, 0.5 / lut_height, lut_height / lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">GetLutStripValue</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float4</span> params)
{
    uv -= params.yz;
    real3 color;
    color.r = <span style="color: #4f97d7;">frac</span>(uv.x * params.x);
    color.b = uv.x - color.r / params.x;
    color.g = uv.y;
    <span style="color: #4f97d7; font-weight: bold;">return</span> color * params.w;
}
</pre>
</div>
</div>
</li>
<li><a id="org95ff881"></a>Log C LUT<br />
<div class="outline-text-7" id="text-org95ff881">
<p>
前面 GetLutStripValue 生成的颜色值为(0,1)范围内的。为了支持 HDR，需要扩大该颜色范围。使用 LogCToLinear 函数来将颜色范围扩展到(0,59)<br />
</p>
</div>
</li>
<li><a id="orgb110eae"></a>Final Pass<br />
<div class="outline-text-7" id="text-orgb110eae">
<ul class="org-ul">
<li>TODO 如何利用 LUT Texture 计算 ColorGrading？<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// 2D LUT grading</span>
<span style="color: #2aa1ae; background-color: #292e34;">// scaleOffset = (1 / lut_width, 1 / lut_height, lut_height - 1)</span>
real3 <span style="color: #bc6ec5; font-weight: bold;">ApplyLut2D</span>(TEXTURE2D_PARAM(tex, samplerTex), <span style="color: #ce537a; font-weight: bold;">float3</span> uvw, <span style="color: #ce537a; font-weight: bold;">float3</span> scaleOffset)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// Strip format where `height = sqrt(width)`</span>
    uvw.z *= scaleOffset.z;
    <span style="color: #ce537a; font-weight: bold;">float</span> shift = <span style="color: #4f97d7;">floor</span>(uvw.z);
    uvw.xy = uvw.xy * scaleOffset.z * scaleOffset.xy + scaleOffset.xy * 0.5;
    uvw.x += shift * scaleOffset.y;
    uvw.xyz = <span style="color: #4f97d7;">lerp</span>(
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy, 0.0).rgb,
        SAMPLE_TEXTURE2D_LOD(tex, samplerTex, uvw.xy + <span style="color: #ce537a; font-weight: bold;">float2</span>(scaleOffset.y, 0.0), 0.0).rgb,
        uvw.z - shift
    );
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}
</pre>
</div>
</div>
</li>
<li><a id="orgeee78ff"></a>LUT Banding<br />
<div class="outline-text-7" id="text-orgeee78ff">
<p>
因为 LUT 只有有限的分辨率，我们使用双线性插值对 LUT 进行采样将原本平滑的颜色转换为了线性带。通常对于 32 分辨率的 LUT，该问题是不容易被察觉到的，但是，在极其高动态范围的颜色渐变处，该问题就会明显。<br />
将采样器从 sampler_linear_clamp 变为 sampler_point_clamp，带会变得很明显。<br />
</p>
</div>
</li>
<li><a id="org1c8f706"></a>GPU GEMS2 LUT<br />
<div class="outline-text-7" id="text-org1c8f706">
<ul class="org-ul">
<li><a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color">https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color</a><br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org1d427e4"></a>Shader Analysis<br />
<div class="outline-text-8" id="text-org1d427e4">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>(<span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float2</span> sUV : <span style="color: #a45bad;">TEXCOORD0</span>,
            <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half4</span> cOut : <span style="color: #a45bad;">COLOR0</span>,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">samplerRECT</span> imagePlane,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">sampler3D</span> lut,
            <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">uniform</span> <span style="color: #ce537a; font-weight: bold;">float3</span> lutSize)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// Get the image color</span>
      <span style="color: #ce537a; font-weight: bold;">half3</span> rawColor = <span style="color: #4f97d7;">texRECT</span>(imagePlane, sUV).rgb;
      <span style="color: #2aa1ae; background-color: #292e34;">// Compute the 3D LUT lookup scale/offset factor</span>
      <span style="color: #ce537a; font-weight: bold;">half3</span> scale = (lutSize - 1.0) / lutSize;
      <span style="color: #ce537a; font-weight: bold;">half3</span> offset = 1.0 / (2.0 * lutSize);
      <span style="color: #2aa1ae; background-color: #292e34;">// ****** Apply 3D LUT color transform! **************</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// This is our dependent texture read; The 3D texture's</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// lookup coordinates are dependent on the</span>
      <span style="color: #2aa1ae; background-color: #292e34;">// previous texture read's result</span>
      cOut.rgb = <span style="color: #4f97d7;">tex3D</span>(lut, scale * rawColor + offset);
  }
</pre>
</div>

<p>
为什么在上面的代码中要对 UV 进行偏移和缩放？<br />
具体而言，硬件纹理采样算法会从数据集的起始边界采样到结束边界。尽管在对图像数据进行纹理化处理时这是完全合理的，但不适合对数值数据集进行采样，因为它会在纹理边缘附近引入非线性值。因此，我们只在最外层样本的中心区域内进行采样。<br />
<img src="./UnityCatLikeCoding/03_12cg_lut_sampling.png" alt="03_12cg_lut_sampling.png" /><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org877ad45" class="outline-5">
<h5 id="org877ad45">Multiple Cameras</h5>
<div class="outline-text-5" id="text-org877ad45">
</div>
<div id="outline-container-org01b21b8" class="outline-6">
<h6 id="org01b21b8">Combining Cameras</h6>
<div class="outline-text-6" id="text-org01b21b8">
<p>
当两个摄像机叠加在一起，为了移除上面摄像机的天空盒子，可以使用 CameraClearFlags.Color 清除标记。但是，当摄像机使用后期特效后，CameraClearFlags 会被强制设置为 CameraClearFlags.Color，此时上面摄像机显示的内容会包含背景颜色。可以将后期效果 shader 的混合方式改为 Blend SrcAlpha OneMinusSrcAlpha 来去除背景颜色。<br />
</p>

<p>
当 Bloom 效果在天空背景上时，Blend SrcAlpha OneMinusSrcAlpha 模式混合后 Bloom 效果会变弱。需要将混合模式调整为 Blend One OneMinusSrcAlpha。<br />
</p>

<p>
可以使用下面方式，分别控制 RGB 和 Alpha 的混合因子：<br />
Blend SrcFactor DstFactor, AlphaSrcFactor AlphaDstFactor<br />
</p>
</div>
</div>
<div id="outline-container-org3fb4f58" class="outline-6">
<h6 id="org3fb4f58">Rendering Layers</h6>
<div class="outline-text-6" id="text-org3fb4f58">
<p>
每个物体都属于唯一一个 Layer，每个 Camera 都有一个 CullingMask 属性，其可以包含多个 Layer，用来标识哪些 Layer 对该摄像机可见。<br />
Light 也有 CullingMask，如果物体所在 Layer 没被 Light 包含，则该 Light 对该物体相当于不存在，即 Light 不会照亮物体，也不会让物体投射阴影。但是，方向光是个例外，其 CullingMask 只影响物体的阴影，而依然可以照亮物体。<br />
使用现在的方式无法完整支持 Light 的 CullingMask，HDRP 也不支持。Unity 为 SRPs 提供了 Rendering Layers 作为一种替代方案。使用 Rendering Layers 代替 game-object layers 有两个好处：<br />
</p>
<ol class="org-ol">
<li>renderers 不必限制为只属于单个 layer，这意味着 rendering-layers 更灵活。<br /></li>
<li>rendering-layers 不会被用于做其他事情(默认的 game-object layers 也会被物理模块使用)。<br /></li>
</ol>

<p>
注意： 只有 CullingMask 会被用于 Culling，Rendering-Layers 不会执行 Culling，因此 Renderer 的 RenderingLayer 不被摄像机包含时，依然会渲染该 Renderer 的阴影。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org006219a" class="outline-5">
<h5 id="org006219a">Particles</h5>
<div class="outline-text-5" id="text-org006219a">
</div>
<div id="outline-container-orga14beb9" class="outline-6">
<h6 id="orga14beb9">Unlit Particles</h6>
<div class="outline-text-6" id="text-orga14beb9">
</div>
<ul class="org-ul">
<li><a id="org94e3c13"></a>修改粒子发射器形状<br />
<div class="outline-text-7" id="text-org94e3c13">
<p>
勾选 ParticleSystem/Shape，在该分组下进行修改<br />
</p>
</div>
</li>
<li><a id="org8c7fcb9"></a>粒子帧动画<br />
<div class="outline-text-7" id="text-org8c7fcb9">
<p>
勾选 ParticleSystem/TextureSheetAnimation，在该分组下进行修改<br />
</p>
</div>
</li>
<li><a id="orgb398207"></a>粒子渲染模式<br />
<div class="outline-text-7" id="text-orgb398207">
<p>
ParticleSystem/Renderer/Render Mode<br />
</p>

<p>
Billboard<br />
StrechedBillboard<br />
HBillboard<br />
VBillboard<br />
Mesh<br />
None<br />
</p>
</div>
</li>
<li><a id="org48902f7"></a>粒子颜色变化<br />
<div class="outline-text-7" id="text-org48902f7">
<p>
ParticleSystem/Color over Lifetime<br />
</p>
</div>
</li>
<li><a id="org47395a4"></a>自定义 Shader Vertex Steam<br />
<div class="outline-text-7" id="text-org47395a4">
<p>
ParticleSystem/Renderer/Custom Vertex Streams<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga47076c" class="outline-6">
<h6 id="orga47076c">Fading Near Camera</h6>
<div class="outline-text-6" id="text-orga47076c">
<p>
当摄像机在一个粒子系统中时，粒子会非常靠近摄像机近平面，也会闯过近平面从一侧到达另一侧。Renderer/MaxParticleSize 属性可以避免单独的粒子占据屏幕上很大的空间。当粒子靠近近平面时，一旦其达到可视最大尺寸，该粒子将会停止增大。<br />
另一种处理靠近近平面粒子的方法是，基于粒子的片段深度来淡出(fade out)粒子。这种方式对于通过代表气体效果的粒子系统时效果比较好。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org95c6895"></a>Fragment Depth<br />
<div class="outline-text-7" id="text-org95c6895">
<p>
下面代码用于实现求解视觉空间下的 Depth<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">IsOrthographicCamera</span> ()
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> unity_OrthoParams.w;
  }

  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">OrhtographicDepthBufferToLinear</span>(<span style="color: #ce537a; font-weight: bold;">float</span> rawDepth)
  {
<span style="color: #bc6ec5;">      #if</span> UNITY_REVERSED_Z
      rawDepth = 1.0 - rawDepth;
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y) * rawDepth + <span style="color: #7590db;">_ProjectionParams</span>.y;
  }

  Fragment <span style="color: #bc6ec5; font-weight: bold;">GetFragment</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> positionSS)
  {
      Fragment f;
      f.positionSS = positionSS.xy;
      f.depth = IsOrthographicCamera() ? OrthographicDepthBufferToLinear(positionSS.z) : positionSS.w;
      <span style="color: #4f97d7; font-weight: bold;">return</span> f;
  }
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org652ca45" class="outline-6">
<h6 id="org652ca45">Soft Particles</h6>
<div class="outline-text-6" id="text-org652ca45">
<p>
当 Billboard 粒子和场景中几何体有交叉时，尖锐的转变会很不和谐而且使得 Billboard 粒子平坦的本质显得很明显。使用 Soft Particles 可以解决该问题，其原理为，当有不透明的物体在粒子后面时，将粒子淡出。可以比较粒子和之前渲染的不透明物体的视觉空间 depth 来实现该功能。<br />
</p>
</div>
</div>
<div id="outline-container-orgda176ec" class="outline-6">
<h6 id="orgda176ec">Distortion</h6>
<div class="outline-text-6" id="text-orgda176ec">
<p>
实现热气导致的大气折射效果的原理为，根据粒子的 normal 对 uv 进行偏移，使用偏移后的 uv 对 color buffer 进行采样。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org221dc5a" class="outline-3">
<h3 id="org221dc5a">Flow</h3>
<div class="outline-text-3" id="text-org221dc5a">
</div>
<div id="outline-container-org7d401a9" class="outline-4">
<h4 id="org7d401a9">Texture Distortion</h4>
<div class="outline-text-4" id="text-org7d401a9">
</div>
<div id="outline-container-org97884da" class="outline-5">
<h5 id="org97884da">Animating UV</h5>
<div class="outline-text-5" id="text-org97884da">
<p>
当液体不动时，其看起来和固体没差别。你在看的是水、果冻还是玻璃？ 游泳池是否结冰？ 为了确定这些问题，你可以扰乱你观察的物质，看其是否会变形，如果变形，其是如何变形的。只是创建一个材质，使其看起来像流动的水是不够的，其必须真的流动起来。否则，其看起来会像是像水的玻璃雕塑，或是时间暂停下的水。<br />
</p>

<p>
大多数时候我们只是希望表面看起来像液体，其是由水或泥浆或者熔浆组成的。这样的液体表面不需要有交互，只需要在漫不经心地观察时看起来真实就可以了。因此，我们不需要进行复杂的物理模拟。我只需要在常规的材质上添加移动性就够了，可以通过对 uv 坐标添加动画来实现这种移动性。<br />
</p>
</div>
<div id="outline-container-orgac88ebc" class="outline-6">
<h6 id="orgac88ebc">直接沿着特定方向移动 UV</h6>
<div class="outline-text-6" id="text-orgac88ebc">
<p>
shader 实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv + flowDir * time * <span style="color: #7590db;">_FlowStrength</span>;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = <span style="color: #ce537a; font-weight: bold;">half2</span>(0, 1);

    <span style="color: #ce537a; font-weight: bold;">float2</span> uv = FlowUV(i.uv, flowDir, <span style="color: #7590db;">_Time</span>.y * <span style="color: #7590db;">_TimeSpeed</span>);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uv) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
可以得到如下效果：<br />
</p>
<iframe src="https://player.bilibili.com/player.html?aid=729833431&bvid=BV1BD4y1z7YZ&cid=813070935&page=1" width="640" height="360" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</div>
</div>
<div id="outline-container-orgdce3114" class="outline-6">
<h6 id="orgdce3114">使用 FlowMap 表示液体流动方向</h6>
<div class="outline-text-6" id="text-orgdce3114">
<p>
shader 实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv + flowDir * time * <span style="color: #7590db;">_FlowStrength</span>;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;

    <span style="color: #ce537a; font-weight: bold;">float2</span> uv = FlowUV(i.uv, flowDir, <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uv) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
<p>
可以得到如下效果:<br />
</p>
<iframe src="https://player.bilibili.com/player.html?aid=899857895&bvid=BV1VN4y1c7ep&cid=813133736&page=1" width="640" height="360" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>
上面视频展示了，使用 FlowMap 来控制 uv 移动方向得到的效果，一开始_CustomTime.y 会被重置为 0，之后逐步增加。由于每个位置上 flowDir 方向各不相同，随着时间的推移图像拉伸和挤压越严重。为了避免图像最终乱作一团，我们可以每隔一段时间就重置一次时间，最简单的方法是只取时间的小数部分来做动画。这样，整个画面就会重复播放，每次播放的持续时间为 1 秒。<br />
</p>


<div id="org9d45bc0" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_sawtooth_progress.png" alt="flow01_sawtooth_progress.png" width="300px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv + flowDir * progress * <span style="color: #7590db;">_FlowStrength</span>;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;

    <span style="color: #ce537a; font-weight: bold;">float2</span> uv = FlowUV(i.uv, flowDir, <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uv) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfbfcb84" class="outline-5">
<h5 id="orgfbfcb84">Seamless Looping</h5>
<div class="outline-text-5" id="text-orgfbfcb84">
<p>
上面我们实现了非统一流向的流体的流动，但是每秒都会重置流动效果。为了让流动效果可以循环不中断，开始下一次流动之前，我们必须通过某种方式让 UV 恢复为原始值。当然不能将扭曲倒回去，这样看起来只会是来回流动，而不是有一致的流动方向。<br />
</p>
</div>
<div id="outline-container-org8c73994" class="outline-6">
<h6 id="org8c73994">Blend Weight &amp; Seesaw</h6>
<div class="outline-text-6" id="text-org8c73994">
<p>
一个流动周期内，我们可以从 black 渐变为扭曲最大，然后再从扭曲最大渐变为 black。<br />
</p>


<div id="orgea52748" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_sawtooth_progress01.png" alt="flow01_sawtooth_progress01.png" width="300px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * progress * <span style="color: #7590db;">_FlowStrength</span>;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;

    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw = FlowUVW(i.uv, flowDir, <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvw.xy) * uvw.z * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff14cf1" class="outline-6">
<h6 id="orgff14cf1">Time Offset</h6>
<div class="outline-text-6" id="text-orgff14cf1">
<p>
虽然从技术上讲，我们消除了视觉上的不连续性，但我们引入了黑色脉冲效果。脉动非常明显，因为它同时发生在画面每个地方。如果我们可以将不同位置的黑色脉冲散布在不同时间点上，它可能就不那么明显了。 我们可以通过在表面上以不同的时间偏移来做到这一点。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    <span style="color: #2aa1ae; background-color: #292e34;">// a&#36890;&#36947;&#23384;&#20648; Perlin Noise&#65292;&#29992;&#20110;timeOffset</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw = FlowUVW(i.uv, flowDir, (<span style="color: #7590db;">_CustomTime</span>.y+timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvw.xy) * uvw.z * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
<p>
黑色脉冲仍然存在，但它已经变成了一种波浪，以一种自然的方式在表面蔓延。 时间偏移也使扭曲更多样化。<br />
</p>
</div>
</div>
<div id="outline-container-orgfbab3fd" class="outline-6">
<h6 id="orgfbab3fd">Combining Two Distortions</h6>
<div class="outline-text-6" id="text-orgfbab3fd">
<p>
除了和 black 进行混合外，我们还可以和其他的内容进行混合。例如，我们可以和原始未扭曲的贴图进行混合，这样的我们会看到一个固定的贴图渐隐渐显，这会破坏流动的视觉效果。我们可以和另外的扭曲贴图混合，来避免该问题。我们可以使用两个脉冲模式，A和 B。当 A 的权重为 0 时，B的权重为 1；当 A 的权重为 1 时，B的权重为 0。其原理如下：<br />
</p>

<div id="org86d0b69" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_blend_two_tex.png" alt="flow01_blend_two_tex.png" width="400px" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/flow01_blend_two_tex.ggb">./UnityCatLikeCoding/flow01_blend_two_tex.ggb</a><br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #ce537a; font-weight: bold;">bool</span> flowB)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> phaseOffset = flowB ? 0.5 : 0;
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time + phaseOffset);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * progress * <span style="color: #7590db;">_FlowStrength</span>;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, (<span style="color: #7590db;">_CustomTime</span>.y+timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, (<span style="color: #7590db;">_CustomTime</span>.y+timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>, <span style="color: #a45bad;">true</span>);

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
在两个模式之间进行混合，使得动画的持续时间减少了一半。它现在每秒循环两次(A 一次，B一次)。但是我们不必两次都使用相同的模式。我们可以将 B 的 UV 坐标偏移半个单位, 这使得模式不同(虽然使用的是同一张贴图)，但不会引入任何方向偏差。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #ce537a; font-weight: bold;">bool</span> flowB)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> phaseOffset = flowB ? 0.5 : 0;
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time + phaseOffset);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * progress * <span style="color: #7590db;">_FlowStrength</span> + phaseOffset;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f5023c" class="outline-6">
<h6 id="org4f5023c">Jumping UV</h6>
<div class="outline-text-6" id="text-org4f5023c">
<p>
除了将 B 的 UV 偏移半个单位外，还可以按相位偏移 UV。 这会加长动画持续时间，循环回到完全相同的状态需要更长的时间。<br />
</p>

<p>
我们可以简单地根据时间滑动 UV 坐标，但这会导致整个动画滑动，从而引入方向偏差。 我们可以通过在每个阶段保持 UV 偏移不变，并在阶段之间跳转到新的偏移来避免视觉滑动。 换句话说，每次权重为零时，我们都会进行 UV 跳跃。 通过向 UV 添加一些跳跃偏移量乘以时间的整数部分可以达到这种目的。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float2</span> jump, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #ce537a; font-weight: bold;">bool</span> flowB)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> phaseOffset = flowB ? 0.5 : 0;
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time + phaseOffset);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * progress * <span style="color: #7590db;">_FlowStrength</span> + phaseOffset;
    uvw.xy += (time - progress) * jump;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
设置 jump 为不同的值时，最终 uv 的偏移量变化如下表所示：<br />
</p>

<div id="orgd20d9a7" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_jumpuv.png" alt="flow01_jumpuv.png" width="600px" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5acd17a" class="outline-6">
<h6 id="org5acd17a">Analyzing Jumps</h6>
<div class="outline-text-6" id="text-org5acd17a">
<figure>
  <iframe src='https://gfycat.com/ifr/TightRelievedGoa' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
  <figcaption>Jump 0, duration 1s.</figcaption>
</figure>
<p>
上面视频中，将 FlowSpeed 设置为 0，Jump 也设置为 0。此时，可以看到每个正方形在两种颜色之间交替。还可以看到，B将相同的纹理偏移了一半，但这并不是很明显，另外，色彩方块没有表现出方向性移动。<br />
</p>

<figure>
  <iframe src='https://gfycat.com/ifr/FakeUnknownDassierat' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
  <figcaption>Jump 0.25, duration 4s.</figcaption>
</figure>
<p>
上面视频中，将 FlowSpeed 设置为 0，Jump 设置为 1/4。Jump 为 1/4 会使的纹理的网格线移动，在正方形和十字之间交替。 白线仍然没有显示方向性移动，但彩色方块现在显示了方向性移动。 彩色方块图案沿对角线移动，但不是以一种立即明显的方式移动。它需要向前半步，然后向后退四分之一步，重复。 如果我们 Jump 使用 -1/4，那么它将向前走半步，然后向前走四分之一步，重复。使用不对称的跳跃，可使方向性移动更加明显，例如 0.2。<br />
</p>

<figure>
  <iframe src='https://gfycat.com/ifr/RequiredIckyEnglishsetter' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
  <figcaption>Jump 0.2, duration 2.5s.</figcaption>
</figure>
<p>
上面视频中，将 FlowSpeed 设置为 0，Jump 设置为 0.2。在这种情况下，白色网格线也会出现移动。但是因为我们仍在使用相当接近对称的大跳跃，所以可以将运动解释为向多个方向进行，具体取决于您对图像的关注方式。如果你改变你的焦点，你很容易忘记你认为它正在流动的方向。<br />
因为我们使用了 0.2 的 Jump，所以动画在五个阶段后会重复，也就持续时间有 5 秒。但是，因为我们在两个偏移阶段之间进行混合，所以每个阶段的中间都有一个潜在的交叉点。如果动画将在奇数个阶段后循环，它实际上会在阶段中途交叉时循环两次。所以在这种情况下，持续时间只有 2.5 秒。<br />
</p>

<p>
U 和 V 方向的 Jump 可以是不相同的量。除了改变移动方向外，每个维度使用不同的跳跃值也会影响循环持续时间。例如，考虑 0.25 的 U 跳跃和 0.1 的 V 跳跃。 U 每四个循环循环一次，而 V 每十循环循环一次。所以在四个周期后，U 已经循环了，但 V 还没有，所以动画也没有完成一个循环。只有当 U 和 V 在同一阶段结束时都完成一个循环时，我们才能到达动画的结尾。当使用有理数进行跳转时，循环持续时间等于其分母的最小公倍数。在 0.25 和 0.1 的情况下，即 4 和 10，其最小公倍数是 20。<br />
</p>

<p>
没有明显的方法来选择一个跳转向量，使得你最终会得到一个很长的循环持续时间。例如，如果我们使用 0.25 和 0.2 而不是 0.25 和 0.1，我们会得到更长还是更短的持续时间？由于 4 和 5 的最小公倍数也是 20，因此持续时间相同。此外，虽然理论上可以提出可以单词循环需要很长时间甚至永远不循环的值，但大多数实际上并没有用。我们无法感知太小的变化，再加上数值精度的限制，这可能导致理论上好的跳跃值在随意观察下看起来没有变化，或者循环速度比预期的快得多。<br />
</p>

<p>
6/25 = 0.24 和 5/24 是一对不错的 Jump 值。第一个值完成 6 次循环需要 25 个 phase，第二个值完成 5 次循环需要 24 个 phase。理论上循环一次需要 600 个 phase（25 和 24 的最小公倍数为 600），如果 1 个 phase 1 秒的话，循环一次需要 10 分钟。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga499dd1" class="outline-5">
<h5 id="orga499dd1">Animation Tweaks</h5>
<div class="outline-text-5" id="text-orga499dd1">
</div>
<div id="outline-container-orgce2b0a7" class="outline-6">
<h6 id="orgce2b0a7">Tiling</h6>
<div class="outline-text-6" id="text-orgce2b0a7">
<p>
对扭曲的纹理进行 tiling。 不能通过_MainTex 的 tiling 来实现，因为其也会影响 FlowMap。 我们只需要额外的 Tiling 属性，因为只有扭曲方形纹理才有意义，所以我们只需要一个 Tiling 值。<br />
为了保证 tiling 不影响流动效果，我们需要在流动之后，在叠加 phaseOffset 之前，应用 tiling。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float2</span> jump, <span style="color: #ce537a; font-weight: bold;">float</span> tiling, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #ce537a; font-weight: bold;">bool</span> flowB)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> phaseOffset = flowB ? 0.5 : 0;
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time + phaseOffset);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * progress * <span style="color: #7590db;">_FlowStrength</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#27969;&#21160;&#20043;&#21518;&#20877;&#24212;&#29992;tiling</span>
    uvw.xy *= tiling;
    uvw.xy += phaseOffset;
    uvw.xy += (time - progress) * jump;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6cdb739" class="outline-6">
<h6 id="org6cdb739">支持 FlowStrength FlowOffset</h6>
<div class="outline-text-6" id="text-org6cdb739">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowUVW</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float2</span> jump, <span style="color: #ce537a; font-weight: bold;">float</span> flowOffset, <span style="color: #ce537a; font-weight: bold;">float</span> tiling, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #ce537a; font-weight: bold;">bool</span> flowB)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> phaseOffset = flowB ? 0.5 : 0;
    <span style="color: #ce537a; font-weight: bold;">float</span> progress = <span style="color: #4f97d7;">frac</span>(time + phaseOffset);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvw;
    uvw.xy = uv - flowDir * (progress + flowOffset);
    uvw.xy *= tiling;
    uvw.xy += phaseOffset;
    uvw.xy += (time - progress) * jump;
    uvw.z = 1 - <span style="color: #4f97d7;">abs</span>(1 - 2 * progress);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uvw;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    <span style="color: #2aa1ae; background-color: #292e34;">// FlowStrength &#30452;&#25509;&#20316;&#29992;&#22312; flowDir &#19978;&#12290;</span>
    flowDir = flowDir * <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;
    <span style="color: #2aa1ae; background-color: #292e34;">//float timeOffset = 0;</span>

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #ce537a; font-weight: bold;">half3</span>(0, 1, 0);
    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8cb7b5b" class="outline-5">
<h5 id="org8cb7b5b">Texturing</h5>
<div class="outline-text-5" id="text-org8cb7b5b">
</div>
<div id="outline-container-orgcfcc5dc" class="outline-6">
<h6 id="orgcfcc5dc">Abstract Water</h6>
<div class="outline-text-6" id="text-orgcfcc5dc">
<p>
扭曲效果的最常见用途是用于模拟水面。但是因为扭曲可以在任何方向，因此，我们不能使用特定暗含流动方向的纹理。不包含流动方向就不可能做出真实正确的波浪，不过我们不需要真实。当纹理被扭曲和混合时，它只需要看起来像水就可以。 下面的是一个简单的噪声纹理，它结合了一个八度的低频 Perlin 和 Voronoi 噪声。 它是水的抽象灰度表示，深色表示底部，浅色表示顶部。<br />
</p>


<div id="org7e64903" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_water.png" alt="flow01_water.png" width="256px" /><br />
</p>
</div>

<p>
将 MainTex 换为上图，调整参数可以得到如下效果。尽管噪声贴图本身看起来不像水，扭曲运动起来后，开始看起来像水了。<br />
</p>
<figure>
  <iframe src='https://gfycat.com/ifr/CaringWideeyedGoa' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
  <figcaption>Flowing Water</figcaption>
</figure>
<p>
将 FlowStrength 设置为 0，这移除了扭曲效果，可以表示静止的水，如下面视频所示，看起来确实像静态的水。<br />
</p>
<figure>
  <iframe src='https://gfycat.com/ifr/WigglyOrganicDogwoodtwigborer' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
  <figcaption>Stationary Water</figcaption>
</figure>
</div>
</div>
<div id="outline-container-orgb89225f" class="outline-6">
<h6 id="orgb89225f">Normal Map</h6>
<div class="outline-text-6" id="text-orgb89225f">
<p>
Albedo 贴图只是一个预览，主要是通过水的表面在垂直方向上变化的情况来定义流动的水，垂直方向上的变化会改变水表面与光的交互。为此，我们需要一张法线贴图。下图通过将反照率纹理解释为高度图，并将高度按 0.1 缩放（避免法线效果太强），生成了法线贴图。<br />
</p>


<div id="orge883ecc" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_water-normal.png" alt="flow01_water-normal.png" width="256px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    flowDir = flowDir * <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #2aa1ae; background-color: #292e34;">// &#28155;&#21152;Normal Map</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalA = UnpackNormal(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_NormalMap</span>, sampler_NormalMap, uvwA.xy)) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalB = UnpackNormal(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_NormalMap</span>, sampler_NormalMap, uvwB.xy)) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(normalA + normalB);

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
将 Color 修改为黑色，调整方向光方向，使得有足够多的镜面反射光到达摄像机（当镜面反射光很少时，表面的法线效果就会很弱，所以，很多游戏会增加摄像机点光源来增强法线效果）。这样可以得到如下的画面：<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/TimelyMajorArchaeopteryx' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Color Black, Flowing Water</figcaption>
</figure>

<p>
再将 FlowStrength 设置为 0，得到静态的水：<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/SomeCornyIriomotecat' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Color Black, Stationary Water</figcaption>
</figure>

<p>
乍一看，它可能看起来不错，但如果你专注于特定的高光，很快就会发现高光是在两种状态之间交替出现。 幸运的是，这可以通过使用非零的跳跃值来解决。如下：<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/SomeCornyIriomotecat' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Color Black, Stationary Water, Jump 0.25</figcaption>
</figure>
</div>
</div>
<div id="outline-container-orgff9b325" class="outline-6">
<h6 id="orgff9b325">Derivative Map</h6>
<div class="outline-text-6" id="text-orgff9b325">
<p>
直接平均法线是不合理的。 <a href="#org80bd00a">Bumpiness</a> 一节中解释过，正确的方法是将法线向量转换为高度（也就是斜率），将斜率相加，然后再转换回法线向量。对于经过表面的波尤其需要如此操作。<br />
</p>

<p>
由于我们通常使用 DXT5nm 格式来压缩法线贴图，因此我们首先必须重建两条法线的 Z 分量，然后转换为斜率(高度的导数就是斜率)、再叠加，最后归一化。由于我们不需要原始的法线向量，因此我们也可以通过将斜率(导数)存储在贴图中，这样就可以省去从法线转换为导数的步骤。<br />
导数贴图存储了 X 方向和 Y 方向上高度的导数，如果不对其中存储的值进行缩放，其支持的表面倾斜的最大角度为 45 度，此时对应的导数为 1。不过通常不会用到如此陡的波，这个限制还是可以接受的。下图将 X 方向导数存储在 A 通道，Y方向导数存储在 G 通道，同时将原始高度存储在 B 通道，导数是将高度缩放了 0.1 倍之后计算的来的。<br />
</p>


<div id="orge09311d" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_water-derivative-height.png" alt="flow01_water-derivative-height.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 1: </span>water derivative &amp; height</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">UnpackDerivativeHeight</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> textureData)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = textureData.agb;
    dh.xy = dh.xy * 2 - 1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}

<span style="color: #2aa1ae; background-color: #292e34;">// .......</span>

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">//float2 flowDir = half2(0, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    flowDir = flowDir * <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #ce537a; font-weight: bold;">float3</span> dhA = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_DerivHeightMap</span>, sampler_DerivHeightMap, uvwA.xy)) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhB = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_DerivHeightMap</span>, sampler_DerivHeightMap, uvwB.xy)) * uvwB.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// half3 normalTS = half3(0, 0, 1);</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// &#26012;&#29575;(&#39640;&#24230;&#30340;&#23548;&#25968;) &#21472;&#21152;&#24471;&#21040;&#21472;&#21152;&#21518;&#30340; normal</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(-(dhA.xy + dhB.xy), 1));

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoA = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwA.xy) * uvwA.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedoB = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvwB.xy) * uvwB.z;
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = (albedoA + albedoB) * <span style="color: #7590db;">_Color</span>;

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #2aa1ae; background-color: #292e34;">//return half4((inputData.normalWS + 1) / 2, 1);</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
我们也可以使用存储的高度来为表面着色。这对于调试很有用，所以让暂时使用高度替换原来的反照率。表面看起来比使用反照率纹理时更亮，即使两者都包含相同的高度数据。这是不同的，因为我们现在使用线性数据，而反照率纹理被解释为 sRGB 数据。为了获得相同的结果，我们必须手动将高度数据从伽马转换为线性颜色空间。 我们可以通过简单的平方来近似它。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">o.Albedo = c.rgb;
<span style="color: #2aa1ae; background-color: #292e34;">//o.Albedo = dhA.z + dhB.z;</span>
o.Albedo = <span style="color: #4f97d7;">pow</span>(dhA.z + dhB.z, 2);
</pre>
</div>

<ul class="org-ul">
<li><a href="https://computergraphics.stackexchange.com/questions/4937/derivative-maps-vs-tangent-space-normal-maps">https://computergraphics.stackexchange.com/questions/4937/derivative-maps-vs-tangent-space-normal-maps</a><br /></li>
<li>Derivative Maps <a href="https://www.rorydriscoll.com/2012/01/11/derivative-maps/">https://www.rorydriscoll.com/2012/01/11/derivative-maps/</a>  有道笔记<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org121c4ac" class="outline-6">
<h6 id="org121c4ac">Height Scale</h6>
<div class="outline-text-6" id="text-org121c4ac">
<p>
使用导数而不是法线向量的另一个好处是它们可以轻松缩放。从缩放后的导数推导出的法线会匹配调整后的表面，这样就可以正确地缩放波浪的高度了。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #7590db;">_HeightScale</span> (<span style="color: #2d9574;">"Height Scale"</span>, <span style="color: #4f97d7; font-weight: bold;">Float</span>) = 1

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) :<span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhA = UnpackDerivativeHeight(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DerivHeightMap</span>, uvwA.xy)) * (uvwA.z * <span style="color: #7590db;">_HeightScale</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhB = UnpackDerivativeHeight(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DerivHeightMap</span>, uvwB.xy)) * (uvwB.z * <span style="color: #7590db;">_HeightScale</span>);
}
</pre>
</div>

<p>
更进一步，我们可以根据流速使高度缩放是可变的。当流速大时，你会得到更高的波，而当流速小时，你会得到更低的波。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).rg * 2 - 1;
    flowDir = flowDir * <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float</span> timeOffset = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv).a;

    <span style="color: #ce537a; font-weight: bold;">float</span> time = (<span style="color: #7590db;">_CustomTime</span>.y + timeOffset) * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> jump = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_UJump</span>, <span style="color: #7590db;">_VJump</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwA = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">false</span>);
    <span style="color: #ce537a; font-weight: bold;">float3</span> uvwB = FlowUVW(i.uv, flowDir, jump, <span style="color: #7590db;">_FlowOffset</span>, <span style="color: #7590db;">_Tiling</span>, time, <span style="color: #a45bad;">true</span>);

    <span style="color: #2aa1ae; background-color: #292e34;">// &#32771;&#34385;&#27969;&#21160;&#36895;&#24230;, flowDir&#27169;&#38271;&#36234;&#22823;&#65292;&#34920;&#31034;&#27969;&#21160;&#36895;&#24230;&#36234;&#22823;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> finalHeightScale = <span style="color: #4f97d7;">length</span>(flowDir) * <span style="color: #7590db;">_HeightScaleModulated</span> + <span style="color: #7590db;">_HeightScale</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhA = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_DerivHeightMap</span>, sampler_DerivHeightMap, uvwA.xy)) * (uvwA.z * finalHeightScale);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhB = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_DerivHeightMap</span>, sampler_DerivHeightMap, uvwB.xy)) * (uvwB.z * finalHeightScale);

    <span style="color: #2aa1ae; background-color: #292e34;">// ......</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
虽然可以将高度缩放纯粹基于流速，但最好使用至少一个小的恒定缩放，这样在没有流动的地方表面就不会变平。 例如，使用 0.1 的恒定缩放和 9 的调制缩放。它们不需要加起来为 1。<br />
</p>
</div>
</div>
<div id="outline-container-orgb12b903" class="outline-6">
<h6 id="orgb12b903">Flow Plus Speed</h6>
<div class="outline-text-6" id="text-orgb12b903">
<p>
我们可以将流动速度存储在 FlowMap 中，而不需要在 shader 中实时计算。虽然采样期间的滤波可以非线性地改变向量的长度，但这种差异只有在插值两个非常不同的向量时才会变得显著。只有在 FlowMap 中出现突然的方向变化时才会出现这种情况。只要我们没有这些情况，将流动速度存储在贴图中和实时计算相比几乎得到相同的结果。 另外，在调制高度比例时获得精确匹配并不是必需的。<br />
</p>

<p>
下图将流动速度存储在 FlowMap 的 B 通道：<br />
</p>

<div id="orge6bd7cb" class="figure">
<p><img src="./UnityCatLikeCoding/flow01_flow-speed-noise.png" alt="flow01_flow-speed-noise.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 2: </span>Flow map with speed in B channel.</p>
</div>

<p>
真实水效果的最重要品质是其水面法线的动画有多好。在此基础上可以添加更高级的反射、透明度和折射等效果。但即使没有这些附加特性，表面也会像水。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org47cb806" class="outline-4">
<h4 id="org47cb806">Directional Flow</h4>
<div class="outline-text-4" id="text-org47cb806">
</div>
<div id="outline-container-orge3255a6" class="outline-5">
<h5 id="orge3255a6">Anisotropic Patterns</h5>
<div class="outline-text-5" id="text-orge3255a6">
<p>
当扭曲纹理以模拟流动时，最终纹理可能会在任何方向上被拉伸或挤压。 这意味着无论纹理如何变形，它都必须看起来不错。 这仅适用于各向同性的模式。 各向同性意味着图像在所有方向上看起来都相似。 在上一个教程中使用的水纹理就是这样的。<br />
</p>
</div>
<div id="outline-container-org58ee1d2" class="outline-6">
<h6 id="org58ee1d2">Rippling Water</h6>
<div class="outline-text-6" id="text-org58ee1d2">
<p>
虽然流动的视觉效果令人信服，但通过扭曲各向同性图案而产生的图案看起来并不像真正的水。观察静止的图片而不是运动的画面时最为明显。 如下图，你无法说出水流方向应该是什么。那是因为波浪和涟漪的排列是错误的。它们沿流动方向拉长，而不是垂直于流动方向。<br />
</p>

<div id="orgd58ca8e" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_still_water.png" alt="flow02_still_water.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 3: </span>Distorting an isotropic pattern</p>
</div>

<p>
扭曲效果对于非常湍流或非常缓慢流动的情况都很适合。它不适用于表现出清晰波纹图案的更平静的流动，因为这些波纹有明确的方向，它们是各向异性的。下图是是包含此类波纹的水的高度纹理。它的制作方式与前一节用的纹理相同，但图案不同，另外其导数数据是对高度数据缩放了 0.025 倍计算得到的。<br />
</p>

<div id="org2fdf962" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_ripples-derivative-height.png" alt="flow02_ripples-derivative-height.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 4: </span>Derivative plus height map for ripples.</p>
</div>

<p>
将上面贴图应用与现在的水面得到如下画面，现在即使画面没有动起来，也可以看出有一个明确的流动方向。 但是，图案与流动没有对齐，因此隐含的方向是不正确。如果我们想展示正确的涟漪，我们必须使用不同的方法。<br />
</p>

<div id="orgff13a3a" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_still_water_01.png" alt="flow02_still_water_01.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 5: </span>Distorting an anisotropic pattern.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org02727fa" class="outline-5">
<h5 id="org02727fa">Aligning With the Flow</h5>
<div class="outline-text-5" id="text-org02727fa">
<p>
现在我们有一个各项异性的图案了，我们需要找到一种方式，使得它和流动方向能对齐。我们先使用一个固定的可控的流动方向来进行试验，一旦可行，再过度到使用 FlowMap 来指定流动方向。<br />
</p>
</div>
<div id="outline-container-orgae833ba" class="outline-6">
<h6 id="orgae833ba">UV for Directional Flow</h6>
<div class="outline-text-6" id="text-orgae833ba">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">UnpackDerivativeHeight</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> textureData)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = textureData.agb;
    dh.xy = dh.xy * 2 - 1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}

<span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">DirectionalFlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> tiling, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    uv += time * flowDir;
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv * tiling;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float</span> time = <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(i.uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(0, 1), <span style="color: #7590db;">_Tiling</span>, time);

    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = dh.z * dh.z * <span style="color: #7590db;">_Color</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(-dh.xy, 1));

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
<p>
使用 float2(0,1) 作为流动方向，来控制图案移动得到如下画面：<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/EqualLankyBrahmanbull' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>caption for video</figcaption>
</figure>
</div>
</div>
<div id="outline-container-orgde27f4b" class="outline-6">
<h6 id="orgde27f4b">Texture Rotation</h6>
<div class="outline-text-6" id="text-orgde27f4b">
<p>
贴图是 2D 的，因此只需要一个 2x2 矩阵就可以对贴图进行旋转。假设旋转角度为θ，则旋转矩阵如下：<br />
</p>
<pre class="example" id="orgb144ab9">
| cos(θ)  -sin(θ) |
| sin(θ)   cos(θ) |
</pre>
<p>
上一节中，flowDir = float2(0, 1)，刚好匹配不旋转的贴图，也就是说 flowDir 和贴图的 v 方向一致。因此，改变 flowDir，我们需要对应地旋转贴图。如下图所示，假设 flowDir 从(0, 1)变为（x, y），归一化后为 normalizeFlowDir (x',y')，对应的贴图旋转角度为 φ, 则 (-sin(φ), cos(φ)) = (x', y')，从而可以得出我们需要对贴图进行旋转的矩阵为:<br />
</p>
<pre class="example" id="orgb6810c4">
| cos(φ)  -sin(φ)| = |y'  x'|
| sin(φ)   cos(φ)|   |-x' y'|
</pre>

<div id="org58ff442" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_rot_matrix.png" alt="flow02_rot_matrix.png" width="300px" /><br />
</p>
<p><span class="figure-number">Figure 6: </span>rot img matrix</p>
</div>

<p>
在代码中我们旋转的是 uv 而不是图案，因此我们需要反向旋转的矩阵，因此最终用于旋转 uv 的矩阵为：<br />
</p>
<pre class="example" id="org5fd1a95">
| cos(φ)   sin(φ)| = |y'  -x'|
| -sin(φ)  cos(φ)|   |x'   y'|
</pre>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">UnpackDerivativeHeight</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> textureData)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = textureData.agb;
    dh.xy = dh.xy * 2 - 1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}

<span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">DirectionalFlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> flowDir, <span style="color: #ce537a; font-weight: bold;">float</span> tiling, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> dir = <span style="color: #4f97d7;">normalize</span>(flowDir);
    <span style="color: #2aa1ae; background-color: #292e34;">// &#22240;&#20026;&#31227;&#21160;&#30340;&#26159;uv&#65292;&#25152;&#20197;&#35201;&#21453;&#36716;&#26041;&#21521;</span>
    uv -= time * flowDir;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#22240;&#20026;&#26059;&#36716;&#30340;&#26159;uv&#65292;&#25152;&#20197;&#35201;&#21453;&#21521;&#26059;&#36716;&#30697;&#38453;</span>
    uv = <span style="color: #4f97d7;">mul</span>(<span style="color: #ce537a; font-weight: bold;">float2x2</span>(dir.y, -dir.x, dir.x, dir.y), uv);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv * tiling;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float</span> time = <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(i.uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(1, 1), <span style="color: #7590db;">_Tiling</span>, time);

    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = dh.z * dh.z * <span style="color: #7590db;">_Color</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(-dh.xy, 1));

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
将 uv 移动去掉（即注释掉： uv-=time*flowDir），只保留旋转，可以得到如下画面：<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/WarlikeRecentGuernseycow' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Rotating clockwise.</figcaption>
</figure>
</div>
</div>
<div id="outline-container-org2f5a858" class="outline-6">
<h6 id="org2f5a858">Rotating Derivatives</h6>
<div class="outline-text-6" id="text-org2f5a858">
<p>
尽管图案旋转是正确的，但是 normal 向量不正确。由于图案的显示，无法明显观察到该问题。将代码修改如下进行观察。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
<span style="color: #2aa1ae; background-color: #292e34;">//half4 albedo = dh.z * dh.z * _Color;</span>
<span style="color: #ce537a; font-weight: bold;">half4</span> albedo = <span style="color: #ce537a; font-weight: bold;">half4</span>(dh.rg, 0 , 0);
</pre>
</div>

<figure>
<iframe
    src="https://player.bilibili.com/player.html?aid=857378530&bvid=BV1aV4y1W7Ec&cid=815363384&page=1"
    scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width='640' height='328'>
</iframe><figcaption>rotate derivation map</figcaption>
</figure>

<p>
从上面视频可以看出，旋转过程中，导数贴图内容是没有改变的。导数贴图中存储的是高度的变化量，旋转 90 度后，x方向高度变化量和 y 方向高度变化量刚好会交换。导数贴图内容的旋转矩阵和 uv 旋转矩阵相同。修改后画面如下:<br />
</p>
<figure>
<iframe
    src="https://player.bilibili.com/player.html?aid=302436423&bvid=BV1wP411L7ZG&cid=815388934&page=1"
    scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width='640' height='328'>
</iframe><figcaption>rotate derivation map</figcaption>
</figure>
</div>
</div>

<div id="outline-container-orgaec48b3" class="outline-6">
<h6 id="orgaec48b3">Sampling the Flow</h6>
<div class="outline-text-6" id="text-orgaec48b3">
<p>
前面使用的都是固定可控的流动方向，下面代码使用 FlowMap 来控制流动方向。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">UnpackDerivativeHeight</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> textureData)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = textureData.agb;
    dh.xy = dh.xy * 2 - 1;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}

<span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #bc6ec5; font-weight: bold;">DirectionalFlowUV</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed, <span style="color: #ce537a; font-weight: bold;">float</span> tiling, <span style="color: #ce537a; font-weight: bold;">float</span> time, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">float2x2</span> rotation)
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> dir = <span style="color: #4f97d7;">normalize</span>(flowDirAndSpeed.xy);
    uv -= time * flowDirAndSpeed.xy * flowDirAndSpeed.z;
    rotation = <span style="color: #ce537a; font-weight: bold;">float2x2</span>(dir.y, -dir.x, dir.x, dir.y);
    uv = <span style="color: #4f97d7;">mul</span>(rotation, uv);
    <span style="color: #4f97d7; font-weight: bold;">return</span> uv * tiling;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float</span> time = <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992; flowmap &#25511;&#21046;&#27969;&#21521;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, i.uv);
    flowDirAndSpeed.xy = flowDirAndSpeed.rg * 2 - 1;
    flowDirAndSpeed.z *= <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float2x2</span> derivRotation;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(i.uv, flowDirAndSpeed, <span style="color: #7590db;">_Tiling</span>, time, derivRotation);

    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    dh.xy = <span style="color: #4f97d7;">mul</span>(derivRotation, dh.xy);
    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = dh.z * dh.z * <span style="color: #7590db;">_Color</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">//half4 albedo = half4(dh.rg, 0 , 0);</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(-dh.xy, 1));

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>

<p>
和前一节（Texture Distortion）一样，随着时间的推移图像拉伸和挤压越严重。并且独立旋转每个片段会将图案撕开。当我们使用统一方向时，不会有该问题。 我们必须想出一个解决方案。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd26d3c4" class="outline-5">
<h5 id="orgd26d3c4">Tiled Flow</h5>
<div class="outline-text-5" id="text-orgd26d3c4">
<p>
扭曲图案方法有时域问题，为了保证图案不乱作一团，我们不得不在某个时候重置扭曲的图案。 我们通过跨时间混合两个不同阶段的扭曲图案来隐藏这种重置操作。 定向流动方法也有这个问题，但性质不同。虽然随着时间的推移图案会更多地分解，但对于定向流动方法来说，在零时间点，还没任何动画时，图案已经被破坏了。 所以重置时间无济于事。<br />
</p>

<p>
定向流动方法中，在方向不同的地方存在不连续性。这是一个空间问题，而不是时间问题。 解决方案是再次通过混合来隐藏该问题。但现在我们必须在空间上进行混合，而不是时间。 我们处理的是 2D 表面，而不是 1D 时间，所以它更复杂。<br />
</p>

<p>
我们要做的是尝试在均匀流动的完美结果和每个片段使用不同流动方向的期望结果之间找到折衷。 该折衷方案是将表面划分为多个区域。 我们将简单地使用方形 tiling 网格。 每个 tile 都有一个均匀的流动，所以不会受到任何扭曲。 然后我们将每块 tile 与它的邻居混合，以隐藏它们之间的不连续性。 这种方法首先由 Frans van Hoesel 在 2010 年公开描述为 Tiled Directional Flow 算法。 我们将创建它的一个变体。<br />
</p>

<ul class="org-ul">
<li><a href="https://github.com/Scrawk/Tiled-Directional-Flow">https://github.com/Scrawk/Tiled-Directional-Flow</a><br /></li>
</ul>
</div>
<div id="outline-container-orgd842296" class="outline-6">
<h6 id="orgd842296">Flow Grid</h6>
<div class="outline-text-6" id="text-orgd842296">
<p>
可以按照下面公式来将 FlowMap 划分指定分辨率的块，并且每个块内，对应的 uv 相同。此时就可以保证每个 tiling 内流动方向是相同的。<br />
</p>

<div id="org0c14ef3" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_tiling_flowmap.png" alt="flow2_tiling_flowmap.png" width="512px" /><br />
</p>
<p><span class="figure-number">Figure 7: </span>tiling flowmap, resolution=4.</p>
</div>

<p>
<a href="./UnityCatLikeCoding/flow2_tile_flowmap.ggb">./UnityCatLikeCoding/flow2_tile_flowmap.ggb</a><br />
</p>
</div>
</div>

<div id="outline-container-org651339a" class="outline-6">
<h6 id="org651339a">Blending Cells</h6>
<div class="outline-text-6" id="text-org651339a">
<p>
现在我们可以得到清晰可辨的网格单元了，每个网格单元都包含一个不会扭曲的图案。下一步就是进行混合。我们需要在每个片段中采样多个单元。通过对 uv 进行偏移可以找到不同的 cell。例如，下面代码是在水平方向上对两个 cell 进行混合，每个 cell 的权重为 0.5。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowCell</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> offset, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float2x2</span> derivRotation;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvTiled = <span style="color: #4f97d7;">floor</span>(uv * <span style="color: #7590db;">_GridResolution</span> + offset) / <span style="color: #7590db;">_GridResolution</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, uvTiled);
    flowDirAndSpeed.xy = flowDirAndSpeed.rg * 2 - 1;
    flowDirAndSpeed.z *= <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(uv, flowDirAndSpeed, <span style="color: #7590db;">_Tiling</span>, time, derivRotation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    dh.xy = <span style="color: #4f97d7;">mul</span>(derivRotation, dh.xy);
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">float</span> time = <span style="color: #7590db;">_CustomTime</span>.y * <span style="color: #7590db;">_TimeSpeed</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#22312;&#27700;&#24179;&#26041;&#21521;&#19978;&#28151;&#21512;&#20004;&#20010;&#30456;&#37051;&#30340;cell</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhA = FlowCell(i.uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(0, 0), time);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dhB = FlowCell(i.uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(1, 0), time);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = dhA * 0.5 + dhB * 0.5;

    <span style="color: #ce537a; font-weight: bold;">half4</span> albedo = dh.z * dh.z * <span style="color: #7590db;">_Color</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normalTS = <span style="color: #4f97d7;">normalize</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(-dh.xy, 1));

    InputData inputData;
    InitializeInputData(i, normalTS, inputData);
    <span style="color: #ce537a; font-weight: bold;">half4</span> col = UniversalFragmentPBR(inputData, albedo, <span style="color: #7590db;">_Metallic</span>, 0, <span style="color: #7590db;">_Smoothness</span>, 0, 0, 1);
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
<p>
我们可以使用更加合理的混合权重，根据 uv 来计算混合权重，离 cell B 越远的地方 cellA 的权重越大 cellB 权重越小，离 cell B 越近的地方 cellA 权重越小，cellB 权重越大，如下代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> dhA = FlowCell(uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(0, 0), time);
<span style="color: #ce537a; font-weight: bold;">float3</span> dhB = FlowCell(uv, <span style="color: #ce537a; font-weight: bold;">float2</span>(1, 0), time);

<span style="color: #ce537a; font-weight: bold;">float</span> t = <span style="color: #4f97d7;">frac</span>(uv.x * <span style="color: #7590db;">_GridResolution</span>);
<span style="color: #ce537a; font-weight: bold;">float</span> wA = 1 - t;
<span style="color: #ce537a; font-weight: bold;">float</span> wB = t;

<span style="color: #ce537a; font-weight: bold;">float3</span> dh = dhA * wA + dhB * wB;
<span style="color: #ce537a; font-weight: bold;">fixed4</span> c = dh.z * dh.z * <span style="color: #7590db;">_Color</span>;
o.Albedo = c.rgb;
</pre>
</div>
<p>
这样我们就可以使得 cell 之间在水平方向上是连续的了，但是在水平方向上 cell 之间有明显的一条线，该问题下小节进行分析。<br />
</p>
</div>
</div>
<div id="outline-container-org788255f" class="outline-6">
<h6 id="org788255f">Overlapping Cells</h6>
<div class="outline-text-6" id="text-org788255f">
<p>
尽管单元格之间的插值应该消除水平不连续性，但我们仍然可以看到使网格明显的线条。 这些线条是用于采样 FlowMap 的 UV 坐标突然跳跃造成的 artifacts。突然变大的 UV 增量会触发 GPU 沿网格线选择不同的 mipmap 级别(采样 FlowMap 使用的 uv 有跳变，每个 cell 内 uv 是固定的，相邻 cell 的边界处会跳变)，从而破坏 flow 数据。 虽然我们可以通过消除 mipmap 来消除这些 artifacts，但这是不可取的。如果我们能以其他方式隐藏它们会更好。（Tips: 经过测试，禁用 mipmap 并不会消除该问题，我猜测可能由于精度问题，导致无法确定交界处到底属于哪个 cell 也会导致 artifact 线条）<br />
我们可以通过确保单元格的权重在其边缘为零来隐藏线条，单元格边缘就是 artifacts 线条所在的位置。 但是权重函数 t 会重置每个图块，所以我们在边缘有 0 和 1 的锯齿波，如下图所示。 因此，尽管一侧总是很好，但另一侧却受到 artifacts 线条的影响。<br />
</p>

<div id="org5a35890" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_weight_func.png" alt="flow02_weight_func.png" width="400px" /><br />
</p>
<p><span class="figure-number">Figure 8: </span>Sawtooth waves are both 0 and 1 at grid lines.</p>
</div>

<p>
为了解决这个问题，我们必须使得单元格之间有重叠。 这样我们就可以在它们之间交替，并使用一个 cell 来隐藏另一个 cell 的 artifacts 线条。<br />
首先，将第二个单元格的偏移量减半。这样 cells 在水平方向上就会有重叠。得到如下画面：<br />
</p>

<div id="orgad30ee5" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_offset-compare.png" alt="flow2_offset-compare.png" width="900px" /><br />
</p>
<p><span class="figure-number">Figure 9: </span>Offset(1,0) vs Offset(0.5,0)</p>
</div>

<p>
然后，我们必须再次正确混合单元格。 这是通过将 t 替换为 |2t - 1| 来完成的，将其变成三角波，该三角波在图块的两侧为零，在中间为 1。如下图。这样 A 的权重现在在每个图块的两侧都为零, 它权重在中间达到最大。 B 则相反，它在每个图块中间的权重为零。 而且因为我们现在只将 B 偏移了半个格子，这正是它的 artifacts 线条出现的地方。<br />
</p>

<div id="orgbe94c79" class="figure">
<p><img src="./UnityCatLikeCoding/flow02_weight_func01.png" alt="flow02_weight_func01.png" width="400px" /><br />
</p>
</div>

<p>
利用双线性插值的原理，加入竖直方向的混合。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> t = <span style="color: #4f97d7;">abs</span>(2 * <span style="color: #4f97d7;">frac</span>(i.uv * <span style="color: #7590db;">_GridResolution</span>) - 1);
<span style="color: #ce537a; font-weight: bold;">float</span> wA = 1 - t.x;
<span style="color: #ce537a; font-weight: bold;">float</span> wB = t.x;
<span style="color: #ce537a; font-weight: bold;">float</span> wC = 1 - t.x;
<span style="color: #ce537a; font-weight: bold;">float</span> wD = t.x;

<span style="color: #ce537a; font-weight: bold;">float3</span> dh = (dhA * wA + dhB * wB)*(1-t.y) + (dhC * wC + dhD * wD)*t.y;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4f4a03" class="outline-6">
<h6 id="orgc4f4a03">Sampling At Cell Centers</h6>
<div class="outline-text-6" id="text-orgc4f4a03">
<p>
目前，我们在每个 cell 的左下角对 Flowmap 进行采样。 但这与我们混合 cell 的方式不一致。 Flow 数据和 cell 混合未对齐，这会使网格更明显。 我们应该在每个单元格的中心对 FlowMap 进行采样，该处 Cell 的权重为 1。对于单元格 A 来说，采样位置应该是中心点，因此 U 方向和 V 方向都需要偏移 0.5。 对于 B 来说，在 U 方向上已经偏移了一半，因此只需要在 V 维度上偏移 0.5。 类似地，C 在 V 维度已经偏移了一半，C 只需要水平偏移，D 已经在 U 方向和 V 方向偏移过了，因此不需要任何偏移。<br />
</p>


<div id="org6ca59e6" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_sample_cell_pos.png" alt="flow2_sample_cell_pos.png" width="400px" /><br />
</p>
</div>

<p>
_GridResolution 越高，流动的曲线越平滑。 但是不能将分辨率设置得太高，因为这样就没有空间让波纹图案显示出来了。增加 tiling 可以使_GridResolution 设置的更高，但也会使波纹更小。 必须找到最适合每种情况的平衡点。 例如，5 的平铺加上 30 的网格分辨率适用于本教程中的图像。这使得可以看到流动，并且没有让波纹变得很小而无法看到。<br />
</p>


<div id="org51d0035" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_tiling_resolution.png" alt="flow2_tiling_resolution.png" width="800px" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org1f2d4c6" class="outline-6">
<h6 id="org1f2d4c6">Scaling the Waves</h6>
<div class="outline-text-6" id="text-org1f2d4c6">
<p>
和扭曲效果一样，我们可以缩放导数贴图读取出来的导数数据和高度数据（速度越大波浪高度越大 <a href="#org121c4ac">Wave Height Scale</a> ）。由于 Tiled Flow 是基于时域的方法，我们还可以依据流动速度来缩放图案的尺寸。水流速度越大的区域涟漪会越小，而速度越小的区域涟漪会越大。tiling 中将速度因素考虑进去就可以模拟这种现象。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowCell</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> offset, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> shift = 1 - offset;
    shift *= 0.5;
    offset *= 0.5;
    <span style="color: #ce537a; font-weight: bold;">float2x2</span> derivRotation;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvTiled = (<span style="color: #4f97d7;">floor</span>(uv * <span style="color: #7590db;">_GridResolution</span> + offset) + shift) / <span style="color: #7590db;">_GridResolution</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, uvTiled);
    flowDirAndSpeed.xy = flowDirAndSpeed.rg * 2 - 1;
    flowDirAndSpeed.z *= <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// &#26681;&#25454;&#36895;&#24230;&#26469;&#32553;&#25918; tiling</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> tiling = flowDirAndSpeed.z * <span style="color: #7590db;">_TilingModulated</span> + <span style="color: #7590db;">_Tiling</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(uv, flowDirAndSpeed, tiling, time, derivRotation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    dh.xy = <span style="color: #4f97d7;">mul</span>(derivRotation, dh.xy);
    <span style="color: #2aa1ae; background-color: #292e34;">// &#26681;&#25454;&#36895;&#24230;&#26469;&#32553;&#25918; &#39640;&#24230;&#23548;&#25968;&#21644;&#39640;&#24230;</span>
    dh *= flowDirAndSpeed.z * <span style="color: #7590db;">_HeightScaleModulated</span> + <span style="color: #7590db;">_HeightScale</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}
</pre>
</div>

<p>
得到如下画面:<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/SociableSkeletalBlackbuck' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Constant(3) and modulated tiling(50).</figcaption>
</figure>
</div>
</div>
</div>
<div id="outline-container-org7c69e22" class="outline-5">
<h5 id="org7c69e22">Hiding Artifacts</h5>
<div class="outline-text-5" id="text-org7c69e22">
<p>
到目前为止，我们的 directional flow shader 功能已经完整了，但是依然存在一些 artifacts。虽然它们并不总是很明显，但它们仍然值得关注。<br />
</p>

<p>
最明显的 artifacts 是，在流动方向变化相当快的地方，tiling 是可见的。我们使用的 FlowMap 有很多方向变化，因此非常明显。可以通过增加网格分辨率来解决该问题，但也需要增加 tiling。<br />
</p>
</div>
<div id="outline-container-orgb33637c" class="outline-6">
<h6 id="orgb33637c">Nearly Uniform Flow</h6>
<div class="outline-text-6" id="text-orgb33637c">
<p>
真正有问题的 artifacts 出现在流动没有太大变化的区域。 如果流动真的是均匀的，那么图案的平铺就无法隐藏。要看到这一点，将 tiling 的 UV 坐标强制设置为零，这样在任何地方都会使用相同的 FlowMap 数据。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, uvTiled*0);
</pre>
</div>
<p>
如下面画面，tiling 非常明显：<br />
</p>

<div id="org11cd167" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_uniform-flow-artifact.png" alt="flow2_uniform-flow-artifact.png" width="800px" /><br />
</p>
</div>

<p>
使用一个大一些的涟漪图案，就可以移除可见的 tiling，但这样做有其自身的局限性。真正防止这种问题的唯一方法是确保至少有一些变化，可能在生成流程图时添加噪音，是一个很好的方法，因为液体很少能完全均匀地流动，通常都会存在一些隐藏或淹没的物体会以某种方式影响流动。我们考虑一个基本均匀的流动，比如一个缓慢弯曲的水流。 我们可以通过将 uvTiled 临时缩放 0.1 来模拟这种情况。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, uvTiled*0.1);
</pre>
</div>


<div id="orged38b12" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_uniform-flow-artifact1.png" alt="flow2_uniform-flow-artifact1.png" width="800px" /><br />
</p>
<p><span class="figure-number">Figure 10: </span>uvTiled scale 0.1</p>
</div>

<p>
画面动起来时，可以观察到和流动相匹配的脉冲模式，但是只是很快地瞥一眼是很难法线的。将速度设置为零时会出现此问题的更明显表现，突然，我们可以看到条纹出现，和涟漪图案几乎相同区域，并且轻微偏移、旋转和缩放后重复。flowmap 的压缩和纹理过滤可以在一定程度上帮助掩盖这些 artifacts。 使用未压缩的 flow map 时，artifacts 会发生变化，并且会变得更加明显。<br />
</p>

<div id="orgd2a0433" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_uniform-flow-artifact2.png" alt="flow2_uniform-flow-artifact2.png" width="600px" /><br />
</p>
</div>

<figure>
<iframe src="https://player.bilibili.com/player.html?aid=260039276&bvid=BV1ia411R7m6&cid=820369635&page=1" frameborder='0' scrolling='no' allowfullscreen width='640' height='328'> </iframe>
<figcaption>flow artifacts</figcaption>
</figure>

<p>
这些问题是由快速的图案重复引起的。 虽然降低网格分辨率有助于减少这种情况，但它也会使流动不那么顺畅。 幸运的是，我们可以通过在对每个单元格的图案进行采样时抖动 UV 坐标来混淆重复。只需在 uv 上添加单元格偏移量抖动效果就足够了。由于这增加了单元格图案之间的差异，它还增加了更明显的运动效果。这使涟漪更加生动。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">FlowCell</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float2</span> offset, <span style="color: #ce537a; font-weight: bold;">float</span> time)
{
    <span style="color: #ce537a; font-weight: bold;">float2</span> shift = 1 - offset;
    shift *= 0.5;
    offset *= 0.5;
    <span style="color: #ce537a; font-weight: bold;">float2x2</span> derivRotation;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvTiled = (<span style="color: #4f97d7;">floor</span>(uv * <span style="color: #7590db;">_GridResolution</span> + offset) + shift) / <span style="color: #7590db;">_GridResolution</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> flowDirAndSpeed = SAMPLE_TEXTURE2D(<span style="color: #7590db;">_FlowMap</span>, sampler_FlowMap, uvTiled*0.1);
    flowDirAndSpeed.xy = flowDirAndSpeed.rg * 2 - 1;
    flowDirAndSpeed.z *= <span style="color: #7590db;">_FlowStrength</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// &#26681;&#25454;&#36895;&#24230;&#26469;&#32553;&#25918; tiling</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> tiling = flowDirAndSpeed.z * <span style="color: #7590db;">_TilingModulated</span> + <span style="color: #7590db;">_Tiling</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// &#20351;&#29992; offset &#25238;&#21160; uv, &#28151;&#28102;&#28063;&#28458;&#22270;&#26696;&#30340;&#37325;&#22797;</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> uvFlow = DirectionalFlowUV(uv+offset, flowDirAndSpeed, tiling, time, derivRotation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> dh = UnpackDerivativeHeight(SAMPLE_TEXTURE2D(<span style="color: #7590db;">_MainTex</span>, sampler_MainTex, uvFlow));
    dh.xy = <span style="color: #4f97d7;">mul</span>(derivRotation, dh.xy);
    <span style="color: #2aa1ae; background-color: #292e34;">// &#26681;&#25454;&#36895;&#24230;&#26469;&#32553;&#25918; &#39640;&#24230;&#23548;&#25968;&#21644;&#39640;&#24230;</span>
    dh *= flowDirAndSpeed.z * <span style="color: #7590db;">_HeightScaleModulated</span> + <span style="color: #7590db;">_HeightScale</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> dh;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0f122b3" class="outline-6">
<h6 id="org0f122b3">Spotting the Grid</h6>
<div class="outline-text-6" id="text-org0f122b3">
<p>
还存在另外一种 artifact，其是由于 cell 之间的混合引起的。如果方向或速度的差异足够大，tiling 就会变得明显。例如，将网格分辨率设置为 3，仍然放大 FlowMap（即依然对 uvTiled 临时缩放 0.1）。现在有明显可区分的更暗或更亮的 tile。 这是由每块 tile 的流速不同造成的。 但这还不是最成问题的部分。 我们可以通过使用黑色来消除这种情况。如下：<br />
</p>

<div id="org0255c7f" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_tiling_artifact.png" alt="flow2_tiling_artifact.png" width="1000px" /><br />
</p>
</div>

<p>
当注意镜面反射时，仍然可以看到网格。 这是因为 cell 混合的区域比由单个 cell 控制的区域更平坦。 从而导致镜面反射在网格图案中变化。由于这种模式是静态的，因此当涟漪动起来时它会更加突出。<br />
</p>
<figure>
<iframe src='https://gfycat.com/ifr/RewardingLastFinnishspitz' frameborder='0' scrolling='no' allowfullscreen width='640' height='328'></iframe>
<figcaption>Watch the highlights.</figcaption>
</figure>
</div>
</div>
<div id="outline-container-org4e9fdeb" class="outline-6">
<h6 id="org4e9fdeb">Mixing Grids</h6>
<div class="outline-text-6" id="text-org4e9fdeb">
<p>
就像我们无法完全消除扭曲效果的相位混合 artifacts 一样，没有简单的方法可以消除镜面高光 artifacts，只能用噪声对其进行模糊处理。 在当前情况下，用噪声扰乱网格不会缓解镜面高光的 artifacts。 使用平滑的混合函数也不会消除它们，实际上任何更改都会使它们更加明显。<br />
</p>

<p>
消除这种 artifacts 的唯一方法是消除均匀区域和混合区域之间的过渡，但这是不可能的。退而求其次，只能是模糊均匀区域和混合区域之间的差异。我们可以对一个网格进行两次采样，如果我们第二次采样网格时偏移四分之一个 cell，则其最清晰的区域对应于另一个网格的最模糊区域，反之亦然。 然后，平均这两个网格，我们最终就会得到更均匀的混合。其原理如下图所示：<br />
</p>


<div id="orga3d75c3" class="figure">
<p><img src="./UnityCatLikeCoding/flow2_two-grid.png" alt="flow2_two-grid.png" width="1000px" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/flow2_cell-blend-alg.ggb">./UnityCatLikeCoding/flow2_cell-blend-alg.ggb</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb8cf5c8" class="outline-4">
<h4 id="orgb8cf5c8">Waves</h4>
</div>

<div id="outline-container-org62029ff" class="outline-4">
<h4 id="org62029ff">Looking Through Water</h4>
</div>
<div id="outline-container-org5ca3434" class="outline-4">
<h4 id="org5ca3434">参考资料</h4>
<div class="outline-text-4" id="text-org5ca3434">
<ul class="org-ul">
<li>Flow <a href="https://catlikecoding.com/unity/tutorials/flow/">https://catlikecoding.com/unity/tutorials/flow/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge317d4e" class="outline-2">
<h2 id="orge317d4e">MyTest</h2>
<div class="outline-text-2" id="text-orge317d4e">
</div>
<div id="outline-container-org831d730" class="outline-3">
<h3 id="org831d730">TestReplaceShader</h3>
<div class="outline-text-3" id="text-org831d730">
</div>
<div id="outline-container-orga5350f4" class="outline-4">
<h4 id="orga5350f4">SetReplacementShader VS RenderWithShader</h4>
<div class="outline-text-4" id="text-orga5350f4">
<p>
SetReplacementShader 修改相机渲染物体时对应物体的 shader<br />
RenderWithShader     使用相机进行额外的一次渲染，渲染时修改渲染物体对应的 shader<br />
这两个函数的参数：(Shader shader, string replacementTag)<br />
shader 即将使用的新的 shader.<br />
replacementTag 指定替换条件，具体分如下两种情况：<br />
如果 replacementTag="" 表示直接使用新的 shader。<br />
如果 replacementTag="XX" 表示，假设新 shader 的 Tag 为 Tag{ &#x2026;&#x2026; XX="xx" &#x2026;&#x2026; }，那么旧 shader 中 Tag 有相同的 XX="xx" 键值对则使用新 shader 渲染物体，否则不渲染该物体。<br />
</p>
</div>
</div>

<div id="outline-container-orgce9097e" class="outline-4">
<h4 id="orgce9097e">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgce9097e">
</div>
<div id="outline-container-orga27d51e" class="outline-5">
<h5 id="orga27d51e">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</h5>
<div class="outline-text-5" id="text-orga27d51e">
<p>
在 OnPreRender OnPostRender 中调用 RenderWithShader 时会提示如上警告信息。这是因为引擎对相机的渲染调用还没结束，又对同一相机发出渲染的请求。<br />
在 OnGUI 中调用 RenderWithShader 不会提示如上警告信息。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge25c918" class="outline-3">
<h3 id="orge25c918">BilinearFiltering</h3>
<div class="outline-text-3" id="text-orge25c918">
<p>
双线性过滤属于 Up-Sampling 操作<br />
<a id="org5505841"></a><br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #bc6ec5; font-weight: bold;">BilinearFilter</span>(<span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c00</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c10</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c01</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c11</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">tx</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ty</span>)
  {
<span style="color: #bc6ec5;">  #if</span> <span style="color: #a45bad;">false</span>
      <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">a</span> = c00 * (1 - tx) + c10 * tx;
      <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">b</span> = c10 * (1 - tx) + c11 * tx;
      <span style="color: #4f97d7; font-weight: bold;">return</span> (a * (1 - ty) + b * ty);
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span>
          (1 - tx) * (1 - ty) * c00 +
          tx * (1 - ty) * c10 +
          (1 - tx) * ty * c01 +
          tx * ty * c11;
<span style="color: #bc6ec5;">  #endif</span>
  }
</pre>
</div>

<p>
MipMap 生成利用了将高分辨率映射为低分辨率的 Down-Sampling 操作<br />
<a href="../graphics/PhysicallyBasedRendering.html#org034cce7">../graphics/PhysicallyBasedRendering.html#org034cce7</a><br />
</p>

<p>
Down-Sampling 会消耗更多性能，而且还会导致画面闪烁，因此需要使用 mipmap。<br />
</p>

<ul class="org-ul">
<li>双线性过滤近似高斯模糊 <a href="https://blog.csdn.net/seizeF/article/details/90543797">https://blog.csdn.net/seizeF/article/details/90543797</a><br /></li>
<li>图像的 down-samplig 和 up-sampling <a href="https://www.cnblogs.com/jngwl/articles/image_sampling.html">https://www.cnblogs.com/jngwl/articles/image_sampling.html</a><br /></li>
<li>Mipmap 生成 <a href="https://blog.csdn.net/qjh5606/article/details/89040887">https://blog.csdn.net/qjh5606/article/details/89040887</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org91fbf95" class="outline-3">
<h3 id="org91fbf95">SphereMapping</h3>
<div class="outline-text-3" id="text-org91fbf95">
</div>
<div id="outline-container-orgf6b4423" class="outline-4">
<h4 id="orgf6b4423">参考资料</h4>
<div class="outline-text-4" id="text-orgf6b4423">
<ul class="org-ul">
<li>环境贴图 <a href="http://www.twinklingstar.cn/2014/1322/environment-mapping/">http://www.twinklingstar.cn/2014/1322/environment-mapping/</a><br /></li>
<li>详解球面环境映射 <a href="https://zhuanlan.zhihu.com/p/84494845">https://zhuanlan.zhihu.com/p/84494845</a><br /></li>
<li>Unity Shader-Matcap(材质捕获)使用解析 <a href="https://gameinstitute.qq.com/community/detail/128771#commit">https://gameinstitute.qq.com/community/detail/128771#commit</a><br /></li>
<li>详解双抛物面环境映射 <a href="https://zhuanlan.zhihu.com/p/40784734">https://zhuanlan.zhihu.com/p/40784734</a><br /></li>
<li><a href="http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf">http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4b6c437" class="outline-3">
<h3 id="org4b6c437">Unity Universal SRP</h3>
<div class="outline-text-3" id="text-org4b6c437">
</div>
<div id="outline-container-org93e047d" class="outline-4">
<h4 id="org93e047d">Q&amp;A</h4>
<div class="outline-text-4" id="text-org93e047d">
</div>
<div id="outline-container-org841e8a2" class="outline-5">
<h5 id="org841e8a2">为什么 GameView 下摄像机的后处理效果没有生效？</h5>
<div class="outline-text-5" id="text-org841e8a2">
<p>
Camera 上的 PostProcessing 勾选框需要勾选。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org30ac2a7" class="outline-4">
<h4 id="org30ac2a7">参考链接</h4>
<div class="outline-text-4" id="text-org30ac2a7">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br /></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcdfe221" class="outline-2">
<h2 id="orgcdfe221">Q&amp;A</h2>
<div class="outline-text-2" id="text-orgcdfe221">
</div>
<div id="outline-container-org0940ed3" class="outline-3">
<h3 id="org0940ed3">如何判断投影矩阵是否为透视投影？</h3>
<div class="outline-text-3" id="text-org0940ed3">
<p>
正交投影没有透视除法，所以其最后一行数据为 (0,0,0,1)。因此在游戏引擎中，只要判断投影矩阵是否为正交投影矩阵，如果不是正交投影矩阵，就是透视投影矩阵。<br />
OpenGL API 接受的矩阵需要列主序。<br />
Unity 中矩阵是列主序的，正交投影最后一列数据为(0,0,0,1)。底层使用一个 float matrixData[16] 数组存储。<br />
matrix[0]  matrix[1]  matrix[2]  matrix[3]<br />
matrix[4]  matrix[5]  matrix[6]  matrix[7]<br />
matrix[8]  matrix[9]  matrix[10] matrix[11]<br />
matrix[12] matrix[13] matrix[13] matrix[15]<br />
判断是否为透视投影矩阵的方法为：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">  <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isPerspectiveMatrix</span>()
  {
      <span style="color: #4f97d7; font-weight: bold;">return</span> matixData[3]!=0 || matrixData[7]!=0 || matrixData[11]!=0 || matrixData[15]!=1;
  }
</pre>
</div>
<p>
FrameDebug 中显示的矩阵是行主序的：<br />
<img src="./UnityCatLikeCoding/00_matix_checker_01.png" alt="00_matix_checker_01.png" /><br />
<img src="./UnityCatLikeCoding/00_matix_checker_02.png" alt="00_matix_checker_02.png" /><br />
</p>

<ul class="org-ul">
<li>OpenGL 中矩阵的行主序与列主序 <a href="https://blog.51cto.com/31329846/2345432">https://blog.51cto.com/31329846/2345432</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0a13816" class="outline-3">
<h3 id="org0a13816">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</h3>
<div class="outline-text-3" id="text-org0a13816">
<p>
因为 unity 就是这样实现的。其实任何光照都可以在顶点着色器中计算，在片段着色器中插值获得片段颜色。<br />
</p>
</div>
</div>
<div id="outline-container-orgd80d05c" class="outline-3">
<h3 id="orgd80d05c">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</h3>
<div class="outline-text-3" id="text-orgd80d05c">
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/8997720.html">https://www.cnblogs.com/murongxiaopifu/p/8997720.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0c9c185" class="outline-3">
<h3 id="org0c9c185">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</h3>
<div class="outline-text-3" id="text-org0c9c185">
<p>
对于物体来说方向光的方向都是相同的，和方向光垂直的同一平面内的点，他们对应的阴影贴图中的值应该相同，使用正交投影按照方向光方向，渲染场景中物体，将深度写入阴影贴图刚好可以满足这个要求。<br />
点光源的情况则刚好和透视投影相对应。<br />
</p>
</div>
</div>
<div id="outline-container-org1106aff" class="outline-3">
<h3 id="org1106aff">为什么点光源阴影需要绘制场景 6 次？</h3>
<div class="outline-text-3" id="text-org1106aff">
<p>
因为点光源各个方向的光照方向都不同，必须从前后左右和上下六个方向分别绘制场景，生成 Cube 阴影贴图。<br />
</p>
</div>
</div>
<div id="outline-container-orga5465ce" class="outline-3">
<h3 id="orga5465ce">Renderer.receiveShadows 是如何控制关闭接收阴影的？</h3>
<div class="outline-text-3" id="text-orga5465ce">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">UnityComputeForwardShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float4</span> screenPos)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//fade value</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(worldPos, zDist);
    <span style="color: #ce537a; font-weight: bold;">half</span>  realtimeToBakedShadowFade = UnityComputeShadowFade(fadeDist);

    <span style="color: #2aa1ae; background-color: #292e34;">//baked occlusion if any</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);

    <span style="color: #2aa1ae; background-color: #292e34;">// &#35828;&#26126;&#65306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// Renderer.receiveShadows=false &#26102;&#65292;Unity &#24341;&#25806;&#20250;&#21462;&#28040; SHADOWS_SCREEN Keyword &#30340;&#23450;&#20041;&#65292;&#20174;&#32780;&#35753; shadowAttenuation=1</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation = 1.0f;
    <span style="color: #2aa1ae; background-color: #292e34;">//directional realtime shadow</span>
<span style="color: #bc6ec5;">    #if</span> defined (SHADOWS_SCREEN)
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS) &amp;&amp; !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
            realtimeShadowAttenuation = unitySampleShadow(<span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));
<span style="color: #bc6ec5;">        #else</span>
            <span style="color: #2aa1ae; background-color: #292e34;">//Only reached when LIGHTMAP_ON is NOT defined (and thus we use interpolator for screenPos rather than lightmap UVs). See HANDLE_SHADOWS_BLENDING_IN_GI below.</span>
            realtimeShadowAttenuation = unitySampleShadow(screenPos);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    <span style="color: #2aa1ae; background-color: #292e34;">//avoid expensive shadows fetches in the distance where coherency will be good</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (realtimeToBakedShadowFade &lt; (1.0f - 1e-2f))
    {
<span style="color: #bc6ec5;">    #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//spot realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> (defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT))
<span style="color: #bc6ec5;">            #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
                unityShadowCoord4 spotShadowCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1));
<span style="color: #bc6ec5;">            #else</span>
                unityShadowCoord4 spotShadowCoord = screenPos;
<span style="color: #bc6ec5;">            #endif</span>
            realtimeShadowAttenuation = UnitySampleShadowmap(spotShadowCoord);
<span style="color: #bc6ec5;">        #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//point realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> defined (SHADOWS_CUBE)
            realtimeShadowAttenuation = UnitySampleShadowmap(worldPos - <span style="color: #7590db;">_LightPositionRange</span>.xyz);
<span style="color: #bc6ec5;">        #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    }
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(realtimeShadowAttenuation, shadowMaskAttenuation, realtimeToBakedShadowFade);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org11b3117" class="outline-3">
<h3 id="org11b3117">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</h3>
<div class="outline-text-3" id="text-org11b3117">
<ul class="org-ul">
<li>检查是否烘培了当前场景<br /></li>
<li>检查间接光照强度 Lighting/Environment/EnvironmentReflections/IntensityMultiplier<br /></li>
<li>开启 SRP Batcher 后，unity_SpecCube0 会显示为 UnityBlackCube，但实际效果是正确的。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org127f805" class="outline-2">
<h2 id="org127f805">参考资料</h2>
<div class="outline-text-2" id="text-org127f805">
<p>
官网<br />
</p>
<ul class="org-ul">
<li><a href="https://catlikecoding.com/">https://catlikecoding.com/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/rendering/">https://catlikecoding.com/unity/tutorials/rendering/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/">https://catlikecoding.com/unity/tutorials/advanced-rendering/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/custom-srp/">https://catlikecoding.com/unity/tutorials/custom-srp/</a><br /></li>
<li><a href="https://catlikecoding.com/unity/tutorials/noise-derivatives/">https://catlikecoding.com/unity/tutorials/noise-derivatives/</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a><br /></li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest</a><br /></li>
<li>DistanceField <a href="https://prideout.net/blog/distance_fields/">https://prideout.net/blog/distance_fields/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'UnityCatLikeCoding',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
