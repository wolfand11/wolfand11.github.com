<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-12 Sat 13:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vulkan</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Vulkan</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org623fa9a">Vulkan Tutorial</a>
<ul>
<li><a href="#org5c2cfdc">Introduction (8)</a>
<ul>
<li><a href="#orgbd93b00">About (8)</a></li>
<li><a href="#orgfad2239">Tutorial structure (9)</a></li>
</ul>
</li>
<li><a href="#org3f05ad7">Overview (11)</a>
<ul>
<li><a href="#orgaa232a2">Origin of Vulkan (11)</a></li>
<li><a href="#org68e9ea7">What it takes to draw a triangle (12)</a>
<ul>
<li><a href="#orgdd73e94">Step 1 - Instance and physical device selection</a></li>
<li><a href="#orgc5ba72b">Step 2 - Logical device and queue families</a></li>
<li><a href="#org7654692">Step 3 - Window surface and swap chain</a></li>
<li><a href="#orgfccf8b2">Step 4 - Image views and framebuffers</a></li>
<li><a href="#orgf9b415d">Step 5 - Render passes</a></li>
<li><a href="#org802e777">Step 6 - Graphics pipeline</a></li>
<li><a href="#orge2125f4">Step 7 - Command pools and command buffers</a></li>
<li><a href="#orgf3df3e7">Step 8 - Main loop</a></li>
<li><a href="#orgaa0616c">Summary</a></li>
</ul>
</li>
<li><a href="#orgff42f5f">API concepts</a>
<ul>
<li><a href="#orge242799">Coding Conventions</a></li>
<li><a href="#org1faaad7">Validation layers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd3600ac">Development environment (18)</a>
<ul>
<li><a href="#orgbcf6ab0">Windows (18)</a></li>
<li><a href="#org71b1238">Linux (28)</a></li>
<li><a href="#org56cf847">MacOS (34)</a></li>
</ul>
</li>
<li><a href="#orgf52c96f">Drawing a triangle</a>
<ul>
<li><a href="#org71aefaf">Setup</a>
<ul>
<li><a href="#orgb1d8bf1">Base code (41)</a></li>
<li><a href="#org261b3a0">Instance (46)</a>
<ul>
<li><a href="#org4b12d5d">创建一个 VkInstance</a></li>
<li><a href="#org4334b94">检查支持的扩展</a></li>
<li><a href="#org42501cd">Cleaning up</a></li>
</ul>
</li>
<li><a href="#orgde24025">Validation layers (50)</a>
<ul>
<li><a href="#org26988f3">What are validation layers?</a></li>
<li><a href="#orga24f93b">Using validation layers</a></li>
<li><a href="#org1100e75">Message callback</a></li>
<li><a href="#org91e6c6b">Debugging instance creation and destruction</a></li>
<li><a href="#orgf8b3c63">Configuration</a></li>
</ul>
</li>
<li><a href="#orgde60f4f">Physical devices and queue families (62)</a>
<ul>
<li><a href="#org23e73b5">Selecting a physical device</a></li>
<li><a href="#org6cd17d2">Queue families</a></li>
</ul>
</li>
<li><a href="#orgadb2634">Logical device and queues (70)</a></li>
</ul>
</li>
<li><a href="#orgbe0c625">Presentation</a>
<ul>
<li><a href="#orgb22542b">Window surface (74)</a>
<ul>
<li><a href="#orgdd5e10c">Window surface creation (74)</a></li>
<li><a href="#orgff37061">Querying for presentation support (76)</a></li>
<li><a href="#org2354977">Creating the presentation queue (77)</a></li>
</ul>
</li>
<li><a href="#orge2dba9e">Swap chain (79)</a>
<ul>
<li><a href="#orgee3f836">Checking for swap chain support (79)</a></li>
<li><a href="#orgf346f5b">Querying details of swap chain support (81)</a></li>
<li><a href="#org9a5949e">Choosing the right settings for the swap chain (83)</a></li>
<li><a href="#org7c03180">Creating the swap chain (86)</a></li>
</ul>
</li>
<li><a href="#org468b3d0">Image views (92)</a></li>
</ul>
</li>
<li><a href="#org9aa8643">Graphics pipeline basics</a>
<ul>
<li><a href="#org3b59c37">Introduction (95)</a></li>
<li><a href="#org17e5ffa">Shader modules (99)</a>
<ul>
<li><a href="#org95ec40c">Vertex shader (100)</a></li>
<li><a href="#org9a51240">Fragment shader (102)</a></li>
<li><a href="#orgda58211">Compiling the shaders (104)</a></li>
<li><a href="#org31ded9e">Loading a shader (105)</a></li>
<li><a href="#org03dcb05">Creating shader modules (107)</a></li>
<li><a href="#org30b1389">Shader stage creation (108)</a></li>
</ul>
</li>
<li><a href="#orgdbe8575">Fixed functions (110)</a>
<ul>
<li><a href="#orgabbc5f3">Vertex input (110)</a></li>
<li><a href="#org0002027">Input assembly (111)</a></li>
<li><a href="#org62ade11">Viewports and scissors (111)</a></li>
<li><a href="#orgec6ed6d">Rasterizer (113)</a></li>
<li><a href="#org0c1d0ea">Multisampling (114)</a></li>
<li><a href="#org38e121d">Depth and stencil testing (114)</a></li>
<li><a href="#org7e849de">Color blending (115)</a></li>
<li><a href="#org79e5456">Dynamic state (117)</a></li>
<li><a href="#orgc5a9cef">Pipeline layout (117)</a></li>
</ul>
</li>
<li><a href="#org2ed7f21">Render passes (119)</a>
<ul>
<li><a href="#org9e52f2d">Attachment description (119)</a></li>
<li><a href="#org2faf36a">Subpasses and attachment references (121)</a></li>
<li><a href="#orgd7d8f3d">Render pass (122)</a></li>
</ul>
</li>
<li><a href="#org95189f1">Conclusion: Create Graphics Pipeline</a></li>
</ul>
</li>
<li><a href="#orgbd7017e">Drawing</a>
<ul>
<li><a href="#orgb6ca066">Framebuffers (127)</a></li>
<li><a href="#org55a855f">Command buffers (130)</a>
<ul>
<li><a href="#orgb9f1b7f">Command pools (130)</a></li>
<li><a href="#orgf4e1f22">Command buffer allocation (132)</a></li>
<li><a href="#org039bf64">Starting command buffer recording (133)</a></li>
<li><a href="#orgbedc8b8">Starting a render pass (134)</a></li>
<li><a href="#org13f25b8">Basic drawing commands (135)</a></li>
<li><a href="#orgaf769ea">Finishing up (135)</a></li>
</ul>
</li>
<li><a href="#org51d67e7">Rendering and presentation (137)</a>
<ul>
<li><a href="#orgb1d0ad9">Semaphores (138)</a></li>
<li><a href="#orgb359cdf">Acquiring an image from the swap chain (139)</a></li>
<li><a href="#org1605099">Submitting the command buffer (140)</a></li>
<li><a href="#org29bf864">Subpass dependencies (141)</a></li>
<li><a href="#org1fea19e">Presentation (142)</a></li>
<li><a href="#orge68621b">Frames in flight (144)</a></li>
</ul>
</li>
<li><a href="#orgf0eb82a">Swap chain recreation (152)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd259258">Vertex buffers</a>
<ul>
<li><a href="#org376ce6f">Vertex input description (159)</a></li>
<li><a href="#orgb72212c">Vertex buffer creation (164)</a>
<ul>
<li><a href="#orgd9d02d6">创建 buffer</a></li>
<li><a href="#org13c2842">获取 buffer 的内存需求</a></li>
<li><a href="#orgf5a66f6">为 buffer 分配内存</a></li>
<li><a href="#orgeb8e89a">为 buffer 填充数据</a></li>
<li><a href="#orgd43cffa">绑定 commandBuffer 和 vertexBuffer</a></li>
</ul>
</li>
<li><a href="#orgfcb3723">Staging buffer (173)</a>
<ul>
<li><a href="#org978e282">Transfer queue (173)</a></li>
<li><a href="#org3e3c766">Using a staging buffer (175)</a></li>
<li><a href="#org45bca08">Conclusion (178)</a></li>
</ul>
</li>
<li><a href="#org90d9e15">Index buffer (179)</a></li>
</ul>
</li>
<li><a href="#orgf5611a4">Uniform Buffers</a>
<ul>
<li><a href="#org870fd2a">Descriptor layout and buffer (184)</a>
<ul>
<li><a href="#orga551380">Vertex shader (185)</a></li>
<li><a href="#orgd427a2a">Descriptor set layout (186)</a></li>
<li><a href="#orgcc2a684">Uniform buffer (188)</a></li>
<li><a href="#org85d1b9d">Updating uniform data (190)</a></li>
</ul>
</li>
<li><a href="#org4184e7e">Descriptor pool and sets (193)</a>
<ul>
<li><a href="#org0229bde">Descriptor pool (193)</a></li>
<li><a href="#orgbd6b174">Descriptor set (195)</a></li>
<li><a href="#orgc64a6e4">Using descriptor sets (197)</a></li>
<li><a href="#org196d419">Alignment requirements (199)</a></li>
<li><a href="#orga69e178">Multiple descriptor sets (201)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2277157">Texture mapping</a>
<ul>
<li><a href="#org8c2f47e">Create texture image</a>
<ul>
<li><a href="#org7bcaef9">Image library (203)</a></li>
<li><a href="#org35453a2">create Image (206)</a></li>
<li><a href="#orgb554b78">Layout transitions (211)</a></li>
<li><a href="#org3e2c207">Copying buffer to image (214)</a></li>
<li><a href="#orgb579905">Preparing the texture image (215)</a></li>
</ul>
</li>
<li><a href="#orga1204c3">Image view and sampler (219)</a>
<ul>
<li><a href="#org2f55540">Texture image view (219)</a></li>
<li><a href="#orgf4e7e80">Samplers (221)</a></li>
</ul>
</li>
<li><a href="#orgef04c32">Combined image sampler (227)</a>
<ul>
<li><a href="#org7aaa272">Updating the descriptors (227)</a></li>
<li><a href="#org0c6c26c">Texture coordinates and Shaders (231)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org989d292">Depth buffering (236)</a>
<ul>
<li><a href="#orga9fc45a">Depth image and view (239)</a></li>
<li><a href="#org0436317">Explicitly transitioning the depth image</a></li>
<li><a href="#orgc8cc3ba">Render pass (244)</a></li>
<li><a href="#org39c159a">Framebuffer (245)</a></li>
<li><a href="#org79e97cf">Clear values (246)</a></li>
<li><a href="#org211c48c">Depth and stencil state (246)</a></li>
</ul>
</li>
<li><a href="#org23ffc59">Loading models (250)</a>
<ul>
<li><a href="#org97852a8">Library (250)</a></li>
<li><a href="#orgc0ad779">Loading vertices and indices (252)</a></li>
<li><a href="#org1b62567">Vertex deduplication (256)</a></li>
</ul>
</li>
<li><a href="#org42d4517">Generating Mipmaps (259)</a>
<ul>
<li><a href="#orga87a76f">Generating Mipmaps (261)</a></li>
<li><a href="#orgb65feb9">Sampler (267)</a></li>
</ul>
</li>
<li><a href="#org88053b0">Multisampling (271)</a>
<ul>
<li><a href="#org107deab">Adding new attachments (276)</a></li>
<li><a href="#orgcb0953b">Quality improvements (279)</a></li>
</ul>
</li>
<li><a href="#org34654db">Summary</a></li>
<li><a href="#org9572030">Q&amp;A</a>
<ul>
<li><a href="#org6876f49">VkAllocationCallbacks 的使用示例</a></li>
<li><a href="#org463ef08">为什么 depthImageView 可以被多个 command buffer 复用，而 swapChainImageView 不能？</a></li>
<li><a href="#org2636407">secondary command buffer 的使用示例</a></li>
<li><a href="#org8acb433">使用惯例</a></li>
</ul>
</li>
<li><a href="#org7096fd2">参考资料</a></li>
</ul>
</li>
<li><a href="#org5a8fdac">Vulkan Guide</a>
<ul>
<li><a href="#orgb41f758">Vulkan Base</a>
<ul>
<li><a href="#org5bb9598">Initial Setup</a></li>
<li><a href="#org353f85d">Push Constants</a></li>
<li><a href="#org343e1f6">Dynamic Descriptor sets</a></li>
<li><a href="#org8d2a7a3">Storage buffers (shader storage buffer object)</a></li>
<li><a href="#org65ab860">ERROR</a>
<ul>
<li><a href="#orgb87b550">ERROR CMake Error: The source "VulkanGuide/base/CMakeLists.txt" does not match the source "VulkanGuide/CMakeLists.txt" used to generate cache.  Re-run cmake with a different source directory.</a></li>
<li><a href="#orga86548a">ERROR Error C3646 'm_Lock': unknown override specifier</a></li>
<li><a href="#orgfb259a7">ERROR SDL2.dll 不存在</a></li>
<li><a href="#org470e0bc">ERROR Validation Error: [ VUID-VkPipelineShaderStageCreateInfo-module-parameter ] Object 0: handle = 0x19ae7186ec0, type = VK_OBJECT_TYPE_INSTANCE; | MessageID = 0xfd71dc70 | Invalid VkShaderModule Object 0xcccccccccccccccc. The Vulkan spec states: module must be a valid VkShaderModule handle</a></li>
<li><a href="#orgc086fb4">ERROR LNK2019	unresolved external symbol "public: static struct VertexInputDescription __cdecl Vertex::get_vertex_description(void)" (?get_vertex_description@Vertex@@SA?AUVertexInputDescription@@XZ) referenced in function "private: void __cdecl VulkanEngine::init_pipelines(void)" (?init_pipelines@VulkanEngine@@AEAAXXZ)</a></li>
<li><a href="#orga3c0db1">ERROR gl_BaseInstance undeclared identifier</a></li>
<li><a href="#org70433bb">ERROR Validation Error: [ VUID-VkShaderModuleCreateInfo-pCode-01091 ]</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org27e3729">GPU Driven Rendering</a>
<ul>
<li><a href="#org326a53d">Init Setup</a>
<ul>
<li><a href="#org1f4300d">编译 assimp</a></li>
<li><a href="#orgbf193f0">导出 asset</a></li>
</ul>
</li>
<li><a href="#org2deba3d">GPU Driven Rendering Overview</a>
<ul>
<li><a href="#org7d450b3">Introduction</a></li>
<li><a href="#org0aa70c9">Draw Indirect</a></li>
<li><a href="#org183bf79">Bindless Design</a></li>
<li><a href="#org6562b2d">Overview of Vkguide engine architecture for compute rendering.</a></li>
</ul>
</li>
<li><a href="#orge141ecf">Engine architecture overview</a>
<ul>
<li><a href="#org524d82c">Asset System</a>
<ul>
<li><a href="#orgd39aea6">Asset Format</a></li>
<li><a href="#org0bf4692">Texture Asset</a></li>
<li><a href="#orge13a578">Mesh Asset</a></li>
<li><a href="#org15a96b9">Material Asset</a></li>
<li><a href="#orga91e328">Prefab Asset</a></li>
</ul>
</li>
<li><a href="#org02de1fc">Abstraction for descritpor sets</a></li>
<li><a href="#org7e86169">Configurable options through a CVAR System</a></li>
<li><a href="#orgb0eadb9">Multithreading for game engines</a>
<ul>
<li><a href="#org6835a15">Ways of using multithreading in game engines</a></li>
<li><a href="#org4a5eb83">In practive</a></li>
<li><a href="#org9a5e4be">Identifying tasks</a></li>
<li><a href="#org6b15b4f">Multithreading Vulkan</a></li>
</ul>
</li>
<li><a href="#orgd62336b">Render Flow</a></li>
</ul>
</li>
<li><a href="#orgd442326">Draw Indirect</a></li>
<li><a href="#org95ae95b">Compute Shaders</a></li>
<li><a href="#org09ba57e">Material System</a></li>
<li><a href="#org9336472">Mesh Rendering</a></li>
<li><a href="#org26bbf50">Compute based Culling</a></li>
</ul>
</li>
<li><a href="#orgef7d388">参考资料</a></li>
</ul>
</li>
<li><a href="#orgfbd166c">Vulkan vs OpenGL vs OpenGLES vs D3D</a>
<ul>
<li><a href="#org8ed9f95">Version</a>
<ul>
<li><a href="#org81c90ca">OpenGL version</a></li>
<li><a href="#org2694eb2">Open GLES</a></li>
<li><a href="#orge9b6a20">GLSL Version</a></li>
</ul>
</li>
<li><a href="#orgbe3b66a">Compare</a>
<ul>
<li><a href="#org631e62b">EGL DX11 对比</a>
<ul>
<li><a href="#org86ec29f">EGL and DXGI</a></li>
<li><a href="#org04f1975">buffer, uniforms, vertices, texture</a></li>
<li><a href="#org90fe6a0">pipeline</a></li>
</ul>
</li>
<li><a href="#org0569634">Vulkan DX12 概念对比</a>
<ul>
<li><a href="#org618b572">基本的 API 方面</a></li>
<li><a href="#orgd362649">Command Buffer and Pool</a></li>
<li><a href="#org376138e">Descriptors</a></li>
<li><a href="#orgd55cec5">Pipeline</a></li>
<li><a href="#org52d0061">Images and Buffers</a></li>
<li><a href="#org9fd1a48">RenderPasses/RenderTargets</a></li>
</ul>
</li>
<li><a href="#orge7d7f83">GLSL vs HLSL</a>
<ul>
<li><a href="#org638bf18">System values &amp; built-in inputs</a></li>
<li><a href="#org3689661">Atomic operations</a></li>
<li><a href="#org4cbca7b">Shared/local memory</a></li>
<li><a href="#orga50ceaa">Barriers</a></li>
<li><a href="#org8f61a01">Texture access</a></li>
<li><a href="#org9dd1fdd">General math</a></li>
<li><a href="#orgf0a8fae">Various functions</a></li>
<li><a href="#org01749f8">参考资料</a></li>
</ul>
</li>
<li><a href="#orgb7af179">参考资料</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Vulkan note.<br />
</p>
<div class="HTML" id="org623bdde">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org623fa9a" class="outline-2">
<h2 id="org623fa9a">Vulkan Tutorial</h2>
<div class="outline-text-2" id="text-org623fa9a">
</div>
<div id="outline-container-org5c2cfdc" class="outline-3">
<h3 id="org5c2cfdc">Introduction (8)</h3>
<div class="outline-text-3" id="text-org5c2cfdc">
</div>
<div id="outline-container-orgbd93b00" class="outline-4">
<h4 id="orgbd93b00">About (8)</h4>
<div class="outline-text-4" id="text-orgbd93b00">
<p>
Vulkan 是一个新的 API，其为现代显卡提供了更好的抽象。这套新接口允许你更好地描述你的应用程序想做的事情，因此它拥有比现有的图形 API，比如 OpenGL 和 Direct3D ，更好的性能以及更少的意外行为。Vulkan 背后的思想比较接近 Direct3D 12 和 Metal ，但是 Vulkan 拥有完全跨平台的优点，也就是说，你可以同时为 Windows, Linux 和 Android 平台开发应用程序。<br />
</p>
</div>
</div>
<div id="outline-container-orgfad2239" class="outline-4">
<h4 id="orgfad2239">Tutorial structure (9)</h4>
<div class="outline-text-4" id="text-orgfad2239">
<p>
该教程每章的结构大致如下：<br />
</p>
<ul class="org-ul">
<li>引入新的概念以及引入该概念的目的<br /></li>
<li>使用所有相关的 API，将新的概念集成到你的程序中<br /></li>
<li>将一部分功能抽象为公用的 helper 函数<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3f05ad7" class="outline-3">
<h3 id="org3f05ad7">Overview (11)</h3>
<div class="outline-text-3" id="text-org3f05ad7">
</div>
<div id="outline-container-orgaa232a2" class="outline-4">
<h4 id="orgaa232a2">Origin of Vulkan (11)</h4>
<div class="outline-text-4" id="text-orgaa232a2">
<p>
和之前的图形 API 一样，Vulkan 被设计为 GPUs 的跨平台的抽象。大多数这些 API 的问题在于，它们设计的时代，主打图形硬件几乎只限于可配置的固定功能。程序员必须按照标准的格式提供顶点数据，并且在 lighting 和 shading 选项上也受 GPU 制造商所支配。<br />
</p>

<p>
随着显卡架构的成熟，显卡开始提供越来越多的可编程功能。所有这些新功能必须被集成到已有的 API 中。这导致了不理想的抽象，并且在显卡驱动层增加了很多猜测的工作，用来将程序员的意图映射到现代的显卡架构。这就是为什么有如此多的驱动程序更新来提高游戏性能，有时甚至是显着的提升。因为这些复杂的驱动，应用程序开发者还需要处理不同供应商不一致的问题，例如，shader 所接受的语法不同。除了这些新功能之外，过去十年还见证了具有强大图形硬件的移动设备的涌入。 这些移动 GPU 根据其能量和空间要求具有不同的架构。 一个这样的例子是 tiled rendering，它可以通过为程序员提供对该功能的更多控制来提高性能。源于这些 API 时代的另一个限制是有限的多线程支持，这可能导致 CPU 端出现瓶颈。<br />
</p>

<p>
Vulkan 针对现代图形架构从头开始设计，解决了这些问题。 它通过允许程序员使用更详细的 API 明确指定他们的意图来减少驱动程序开销，并允许多个线程并行创建和提交命令。它使用唯一一个编译器来切换到标准化字节码格式，从而减少着色器编译中的不一致。最后，它通过将图形和计算功能统一到单个 API 中来承认现代显卡的通用处理能力。<br />
</p>
</div>
</div>
<div id="outline-container-org68e9ea7" class="outline-4">
<h4 id="org68e9ea7">What it takes to draw a triangle (12)</h4>
<div class="outline-text-4" id="text-org68e9ea7">
<p>
下面是在 Vulkan 程序中画一个三角形的所有步骤的总览。这里引入的所有概念在后面章节会详细讲述，这里只是为了给你一个大图，让你可以将所有单独的组件关联起来。下图展示了 Vulkan 中各种对象之间的关系：<br />
</p>

<div id="org51cd658" class="figure">
<p><img src="./Vulkan/vulkan_objects.jpg" alt="vulkan_objects.jpg" width="600px" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://gpuopen.com/learn/understanding-vulkan-objects/">https://gpuopen.com/learn/understanding-vulkan-objects/</a><br /></li>
</ul>
</div>

<div id="outline-container-orgdd73e94" class="outline-5">
<h5 id="orgdd73e94">Step 1 - Instance and physical device selection</h5>
<div class="outline-text-5" id="text-orgdd73e94">
<p>
Vulkan 应用的开始，需要使用一个 VkInstance 实例来设置 Vulkan API。通过描述你的应用程序并指定你想使用的 API 扩展来创建该 VKInstance 实例。创建 VKInstance 实例后，你可以查询支持 Vulkan 的硬件并选择一个或多个 VkPhysicalDevice 来使用。你还可以查询 VRAM 尺寸和设备能力等属性来选择希望使用的设备，例如，优先使用专用显卡(独显)。<br />
</p>
</div>
</div>
<div id="outline-container-orgc5ba72b" class="outline-5">
<h5 id="orgc5ba72b">Step 2 - Logical device and queue families</h5>
<div class="outline-text-5" id="text-orgc5ba72b">
<p>
选择了正确的硬件设备后，你需要创建一个 VkDevice(逻辑设备)，对其更明确地描述你将使用哪些 VkPhysicalDeviceFeatures 特性，例如，多视口渲染、64 位浮点数支持等等。你还需要指定你使用哪些 Queue families。使用 Vulkan 执行的大多数操作，如绘制命令、内存操作等，都被提交到一个 VkQueue 来异步执行。Queues 是从 Queue families 分配的，每个 queue family 在其 queues 上提供一组特定的操作。例如，对于图形、计算以及内存转移操作可能有不同的 queue families。queue families 的可用操作也可以作为选择物理设备时的一个区别因素。支持 Vulkan 的设备可以不提供任何图形功能，尽管今天支持 Vulkan 的显卡通常都支持我们感兴趣的所有 queue 操作。<br />
</p>
</div>
</div>
<div id="outline-container-org7654692" class="outline-5">
<h5 id="org7654692">Step 3 - Window surface and swap chain</h5>
<div class="outline-text-5" id="text-org7654692">
<p>
除非你只对离屏渲染感兴趣，否则你需要创建一个窗口来展示渲染的图片。可以使用本地平台的 API 或类似 GLFW 和 SDL 这样的库来创建窗口。<br />
</p>

<p>
我们需要额外的两个组件来实际渲染到一个窗口：一个 window surface 组件(VkSurfaceKHR)和一个 swap chain 组件(VkSwapchainKHR).注意 KHR 后缀表示这些对象是 Vulkan 扩展的一部分。Vulkan API 自身是完全平台无关的，因此我们需要使用标准的 WSI(Windows System Interface)扩展来和窗口管理器交互。surface 是对用于渲染的窗口的跨平台抽象，通常通过提供一个指向本地窗口句柄的引用来实例化 surface，对于 Windows 平台本地窗口的句柄为 HWND。<br />
</p>

<p>
swap chain 是多个 render target 的一个集合。其基本目的是用于保证我们当前正在渲染到的 render target 和当前显示在屏幕上的 render target 不是同一个 render target。确保渲染完成的图片才被显示是非常重要的。每次我们想要绘制一帧时，都需要让 swap chain 为我们提供一个 image，让我们渲染到其中。当我们结束绘制一帧时，该 image 被返回给 swap chain，用于在某个时间点将其展示在屏幕上。render targets 的数量以及展示完成的图片到屏幕的条件都依赖于展示模式。常见的当前模式是双缓冲 (vsync) 和三重缓冲。 我们将在 swap chain creation 章节中研究这些。<br />
</p>

<p>
通过使用 VK_KHR_display 和 VK_KHR_display_swapchain 扩展，有些平台允许你直接渲染到显示器，而无需和任何窗口管理器进行交互。例如，这些扩展允许您创建一个代表整个屏幕的表面，这些扩展还可以用于实现您自己的窗口管理器。<br />
</p>
</div>
</div>
<div id="outline-container-orgfccf8b2" class="outline-5">
<h5 id="orgfccf8b2">Step 4 - Image views and framebuffers</h5>
<div class="outline-text-5" id="text-orgfccf8b2">
<p>
从 swap chain 获得一个 image 后，为了渲染到其中，我们需要将该 image 封装到一个 VkImageView 和 VkFramebuffer 中。一个 image view 会引用一个 image 的特定部分，一个 framebuffer 会引用多个 image views，多个 image views 被用于 color，depth 以及 stencil targets。因为 swap chain 中可以有很多不同的 images，我们将为每个 image 预先创建一个 image view 和一个 framebuffer，并在绘制时选择正确的 image。  TODO(framebuffer imageview image rendertarget 关系)<br />
</p>
</div>
</div>

<div id="outline-container-orgf9b415d" class="outline-5">
<h5 id="orgf9b415d">Step 5 - Render passes</h5>
<div class="outline-text-5" id="text-orgf9b415d">
<p>
Vulkan 中的 render passes 描述了渲染操作期间使用的 images 的类型，它们将被如何使用，以及应该如何对待它们的内容。在我们渲染三角形的应用中，我们告诉 Vulkan，我们将使用单个 image 作为 color target，并且在绘制操作之前我们希望其被清除为纯色。Render Passes 只描述 images 的类型，VkFramebuffer 执行实际的绑定操作，将 images 绑定到对应的 slots。<br />
</p>
</div>
</div>

<div id="outline-container-org802e777" class="outline-5">
<h5 id="org802e777">Step 6 - Graphics pipeline</h5>
<div class="outline-text-5" id="text-org802e777">
<p>
通过创建一个 VkPipeline 对象来设置 Vulkan 中的 graphics pipeline。其描述了显卡的可配置状态，例如：viewport 的尺寸，depth buffer 的操作，可编程状态(对应 VkShaderModule)等等。VkShaderModule 对象是由 shader 字节码创建的。驱动还需要知道哪些 render targets 将被 pipeline 所使用，这是我们通过引用 render pass 来指定的。<br />
</p>

<p>
Vulkan 与现有的其它 API 之间最明显的区别就是，几乎所有 graphics pipeline 的配置都需要提前设置好。这意味着如果你想切换到不同的 shader 或稍微改变你的顶点布局，那么你需要完全重新创建 graphics pipeline。这意味着你必须为渲染操作所需的所有不同组合提前创建许多 VkPipeline 对象。只有一些基本配置，如 viewport 大小和清除颜色，可以动态更改。所有状态也需要明确描述，例如没有默认的 color blend 状态。<br />
</p>

<p>
好消息是，由于你执行的是与即时编译的等效的提前编译操作，因此驱动程序有更多优化机会，并且运行时性能更可预测，因为大的状态更改，例如切换到不同的图形管道是非常明确的。<br />
</p>
</div>
</div>
<div id="outline-container-orge2125f4" class="outline-5">
<h5 id="orge2125f4">Step 7 - Command pools and command buffers</h5>
<div class="outline-text-5" id="text-orge2125f4">
<p>
如前所述，Vulkan 中我们想要执行的许多操作，例如绘图操作，都需要提交到一个 Queue 中。这些操作首先需要记录到 VkCommandBuffer 中，然后才能提交。这些 command buffers 是从 VkCommandPool 分配的，VkCommandPool 和特定的 queue family 相关联。要绘制一个简单的三角形，我们需要将以下操作记录到一个 command buffer 中：<br />
</p>
<ul class="org-ul">
<li>Begin the render pass<br /></li>
<li>Bind the graphics pipeline<br /></li>
<li>Draw 3 vertices<br /></li>
<li>End the render pass<br /></li>
</ul>

<p>
因为 framebuffer 中的 image 依赖于 swap chain 将哪个特定的 image 提供给我们，所以我们需要为每个可能的 image 记录一个 command buffer，并在绘制时选择正确的 image。 另一种方法是每帧再记录一次 command buffer，但这种方式不够高效。<br />
</p>
</div>
</div>
<div id="outline-container-orgf3df3e7" class="outline-5">
<h5 id="orgf3df3e7">Step 8 - Main loop</h5>
<div class="outline-text-5" id="text-orgf3df3e7">
<p>
现在绘制命令已经被包装到 command buffer 中了，主循环就很简单了。首先，我们使用 vkAcquireNextImageKHR 从 swap chain 获取一个 image。然后，我们为该 image 选择适当的 command buffer，并且使用 vkQueueSubmit 来执行该 command buffer。最后，我们将 image 返回给 swap chain，使用 vkQueuePresentKHR 来将其展示到屏幕上。<br />
</p>

<p>
提交到队列的操作是异步执行的。 因此，我们必须使用像信号量这样的同步对象来确保正确的执行顺序。绘制 command buffer 的执行必须被设置为等待 image 被获取完成，否则可能会发生我们开始渲染到 image 时，仍在读取该 image 显示到屏幕。 vkQueuePresentKHR 调用反过来需要等待渲染完成，为此我们将使用第二个信号量，在渲染完成后发出该信号。<br />
</p>
</div>
</div>
<div id="outline-container-orgaa0616c" class="outline-5">
<h5 id="orgaa0616c">Summary</h5>
<div class="outline-text-5" id="text-orgaa0616c">
<p>
请注意，我们采用了作弊的方式，将顶点坐标嵌入顶点着色器，而没有使用 vertex buffer。这是因为管理 vertex buffer 需要先熟悉 command buffers。<br />
简单来说，绘制我们的第一个三角形需要以下步骤：<br />
</p>
<ul class="org-ul">
<li>创建一个 VkInstance<br /></li>
<li>选择支持 Vulkan 的显卡 (VkPhysicalDevice)<br /></li>
<li>创建一个 VkDevice 和 一个 VkQueue 用于绘制和展示<br /></li>
<li>创建一个 window，一个 window surface，以及一个 swap chain<br /></li>
<li>将 swap chain 中的 images 封装到 VkImageView<br /></li>
<li>创建一个 render pass 指定将要使用的 render targets<br /></li>
<li>为 render pass 创建多个 framebuffers TODO<br /></li>
<li>设置 graphics pipeline<br /></li>
<li>为每一个可能的 swap chain 中的 image 分配一个 command buffer，并将绘制命令记录到 command buffer 中。<br /></li>
<li>从 swap chain 获取 images 来绘制帧，提交正确的绘制 command buffer 并将 images 返回给 swap chain<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgff42f5f" class="outline-4">
<h4 id="orgff42f5f">API concepts</h4>
<div class="outline-text-4" id="text-orgff42f5f">
</div>
<div id="outline-container-orge242799" class="outline-5">
<h5 id="orge242799">Coding Conventions</h5>
<div class="outline-text-5" id="text-orge242799">
<ul class="org-ul">
<li>函数名的前缀为 vk<br /></li>
<li>枚举类型名称和结构体类型名称的前缀为 Vk<br /></li>
<li>枚举值名称的前缀为 VK_<br /></li>
</ul>

<p>
Vulkan API 使用结构体作为函数参数的情况非常多。例如，对象创建通常按照下面的模式<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkXXXCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = <span style="color: #a45bad;">nullptr</span>;
createInfo.foo = ...;
createInfo.bar = ...;

<span style="color: #ce537a; font-weight: bold;">VkXXX</span> <span style="color: #7590db;">object</span>;
<span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateXXX(&amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;object) != VK_SUCCESS)
{
    <span style="color: #a45bad;">std</span>::cerr &lt;&lt; <span style="color: #2d9574;">"failed to create object"</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
}
</pre>
</div>

<ul class="org-ul">
<li>很多结构体需要通过 sType 成员来显示指定结构体的类型。<br /></li>
<li>pNext 成员可以指向其他的结构体，也可以是 nullptr<br /></li>
<li>创建或销毁对象的函数有一个 VkAllocationCallbacks 的参数，该参数可以为驱动内存指定自定义的分配器，该参数值也可以是 nullptr TODO<br /></li>
<li>几乎所有的函数都会有一个 VkResult 枚举类型的返回值，返回值要么为 VK_SUCCESS，要么为一个错误码<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1faaad7" class="outline-5">
<h5 id="org1faaad7">Validation layers</h5>
<div class="outline-text-5" id="text-org1faaad7">
<p>
如前所述，Vulkan 旨在实现高性能和驱动程序低开销。 因此，默认情况下它将包括非常有限的错误检查和调试功能。 如果你做错了什么，驱动程序通常会崩溃而不是返回错误代码，或者更糟糕的是，它似乎可以在你的显卡上运行而在其他显卡上却完全失败。<br />
</p>

<p>
Vulkan 允许你通过使用一个被称为 validation layers 的特性来开启广泛的检查。Validation layers 是一些被插入 API 和驱动之间的代码片段，可用于执行诸如函数参数检查、跟踪内存管理问题等操作。好处是你可以在开发过程中启用它们，然后在发布应用程序时完全禁用它们，从而实现零开销。任何人都可以编写自己的 validation layers，LunarG 的 Vulkan SDK 提供一组标准 validation layers，在本教程中将采用它。你还需要注册一个回调函数来接收来自 validation layers 的调试消息。<br />
</p>

<p>
由于 Vulkan 对每个操作都非常明确，而且 validation layers 检查范围非常广泛，因此与 OpenGL 和 Direct3D 相比，找出屏幕为什么是黑色的，实际上要容易得多！<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3600ac" class="outline-3">
<h3 id="orgd3600ac">Development environment (18)</h3>
<div class="outline-text-3" id="text-orgd3600ac">
</div>
<div id="outline-container-orgbcf6ab0" class="outline-4">
<h4 id="orgbcf6ab0">Windows (18)</h4>
<div class="outline-text-4" id="text-orgbcf6ab0">
<ul class="org-ul">
<li>下载并安装 SDK Installer <a href="https://vulkan.lunarg.com/">https://vulkan.lunarg.com/</a><br /></li>
<li>运行 Bin/vkcube.exe 来验证当前设备是否支持 Vulkan<br /></li>
<li>下载并解压 GLFW, 放到~/Documents/MySDK/GLFW/3.3.4/WIN64 目录下。 <a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a><br /></li>
<li>下载并解压 GLM, 放到~/Documents/MySDK/GLM/0.9.9.8 目录下。 <a href="https://github.com/g-truc/glm/releases">https://github.com/g-truc/glm/releases</a><br /></li>
<li>新建 Visual Studio Project，选择 Windows Desktop Wizard 项目模板，Application type 选择 Console Application，Additional Options 中勾选 Empty Project（避免 Visual Studio 添加样板代码）。<br /></li>
</ul>

<p>
配置工程：<br />
</p>
<ul class="org-ul">
<li>配置头文件路径 C++ -&gt; General -&gt; Additional Include Directories<br /></li>
<li>配置库文件路径 Linker -&gt; General -&gt; Additional Library Directories<br /></li>
<li>配置库文件名称 Linker -&gt; Input -&gt; Additional Dependencies<br /></li>
</ul>

<p>
Bin 目录下还有一些其他的很有用的开发工具:<br />
</p>
<ul class="org-ul">
<li>glslangValidator.exe 和 glslc.exe 用于将 GLSL shaders 编译为字节码。<br /></li>
<li>其中还包含 Vunlkan 的 loader 以及 validation layers<br /></li>
</ul>

<p>
Include 目录包含了 Vulkan 的头文件<br />
</p>

<p>
Lib 目录包含了库文件<br />
</p>
</div>
</div>
<div id="outline-container-org71b1238" class="outline-4">
<h4 id="org71b1238">Linux (28)</h4>
</div>
<div id="outline-container-org56cf847" class="outline-4">
<h4 id="org56cf847">MacOS (34)</h4>
</div>
</div>
<div id="outline-container-orgf52c96f" class="outline-3">
<h3 id="orgf52c96f">Drawing a triangle</h3>
<div class="outline-text-3" id="text-orgf52c96f">
</div>
<div id="outline-container-org71aefaf" class="outline-4">
<h4 id="org71aefaf">Setup</h4>
<div class="outline-text-4" id="text-org71aefaf">
</div>
<div id="outline-container-orgb1d8bf1" class="outline-5">
<h5 id="orgb1d8bf1">Base code (41)</h5>
<div class="outline-text-5" id="text-orgb1d8bf1">
<p>
Vulkan 对象要么是通过使用 vkCreateXXX 函数直接创建，要么是通过另一个对象使用 vkAllocateXXX 函数来分配。一个对象不再使用后，你需要使用对应的函数 vkDestroyXXX 或 vkFreeXXX 来销毁它。对于不同类型的对象，这些函数的参数也各不相同，但是他们都有一个公共的参数：pAllocator。这是一个可选参数，该参数允许你为自定义的分配器指定一个回调函数。 TODO<br />
</p>
</div>
</div>

<div id="outline-container-org261b3a0" class="outline-5">
<h5 id="org261b3a0">Instance (46)</h5>
<div class="outline-text-5" id="text-org261b3a0">
</div>
<div id="outline-container-org4b12d5d" class="outline-6">
<h6 id="org4b12d5d">创建一个 VkInstance</h6>
<div class="outline-text-6" id="text-org4b12d5d">
<p>
为了创建一个 VkInstance，首先需要创建一个 VkApplicationInfo，将我们应用程序的一些信息填充到该结构体中。技术上来说，这些信息是可选的，但是其可能会给驱动提供一些有用信息来对我们特定的应用程序进行优化。(驱动对于某些特定的行为会使用知名的图形引擎)<br />
</p>

<p>
对象创建函数参数的一般模式为：<br />
</p>
<ul class="org-ul">
<li>指向创建信息结构体的指针<br /></li>
<li>指向自定义分配器回调函数的指针<br /></li>
<li>指向变量的指针，该变量存储了新对象的句柄<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createInstance</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkApplicationInfo</span> <span style="color: #7590db;">appInfo</span>{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = <span style="color: #2d9574;">"Hello Triangle"</span>;
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = <span style="color: #2d9574;">"No Engine"</span>;
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_0;

    <span style="color: #ce537a; font-weight: bold;">VkInstanceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &amp;appInfo;

    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">glfwExtensionCount</span> = 0;
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>** <span style="color: #7590db;">glfwExtensions</span>;
    glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);
    createInfo.enabledExtensionCount = glfwExtensionCount;
    createInfo.ppEnabledExtensionNames = glfwExtensions;
    createInfo.enabledLayerCount = 0;

    <span style="color: #ce537a; font-weight: bold;">VkResult</span> <span style="color: #7590db;">result</span> = vkCreateInstance(&amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;instance);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (result != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create instance!"</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4334b94" class="outline-6">
<h6 id="org4334b94">检查支持的扩展</h6>
<div class="outline-text-6" id="text-org4334b94">
<p>
在创建 VkInstance 之前可以使用 vkEnumerateInstanceExtensionProperties 函数来获得当前支持的所有扩展的列表。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkResult</span> <span style="color: #bc6ec5; font-weight: bold;">vkEnumerateInstanceExtensionProperties</span>(
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>*            <span style="color: #7590db;">pLayerName</span>,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21487;&#36873;&#21442;&#25968;&#65292;&#36890;&#36807;&#19968;&#20010;&#25351;&#23450;&#30340;validation layer&#26469;&#36807;&#28388;&#19968;&#20123;&#25193;&#23637;</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span>*              <span style="color: #7590db;">pPropertyCount</span>, <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23384;&#20648;&#25152;&#26377;&#25903;&#25345;&#30340;&#25193;&#23637;&#30340;&#25968;&#37327;</span>
    <span style="color: #ce537a; font-weight: bold;">VkExtensionProperties</span>* <span style="color: #7590db;">pProperties</span>     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkExtensionProperties&#31867;&#22411;&#30340;&#25968;&#32452;&#65292;&#23384;&#20648;&#25152;&#26377;&#25903;&#25345;&#30340;&#25193;&#23637;&#30340;&#32454;&#33410;</span>
    );

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#33719;&#21462;&#20102;&#25152;&#26377;&#25903;&#25345;&#30340;&#25193;&#23637;&#65292;&#24182;&#25171;&#21360;&#36825;&#20123;&#25193;&#23637;&#30340;&#21517;&#23383;</span>
<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">extensionCount</span> = 0;
vkEnumerateInstanceExtensionProperties(<span style="color: #a45bad;">nullptr</span>, &amp;extensionCount, <span style="color: #a45bad;">nullptr</span>);
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkExtensionProperties</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">extensions</span>(extensionCount);
vkEnumerateInstanceExtensionProperties(<span style="color: #a45bad;">nullptr</span>, &amp;extensionCount, extensions.data());

<span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"available extensions:\n"</span>;

<span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">extension</span> : extensions) {
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">'\t'</span> &lt;&lt; extension.extensionName &lt;&lt; <span style="color: #2d9574;">'\n'</span>;
}
</pre>
</div>

<p>
检查需要的 extensions 是否被支持：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">checkRequiredExtensionsSupport</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>** <span style="color: #7590db;">requiredExts</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">requiredExtCount</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#24403;&#21069;&#25903;&#25345;&#30340;&#25152;&#26377; extensions</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">supportedExtensionCount</span> = 0;
    vkEnumerateInstanceExtensionProperties(<span style="color: #a45bad;">nullptr</span>, &amp;supportedExtensionCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkExtensionProperties&gt; <span style="color: #7590db;">supportedExtensions</span>(supportedExtensionCount);
    vkEnumerateInstanceExtensionProperties(<span style="color: #a45bad;">nullptr</span>, &amp;supportedExtensionCount, supportedExtensions.data());

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">supportedExt</span> : supportedExtensions)
    {
        <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"supported Ext : "</span> &lt;&lt; supportedExt.extensionName &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; requiredExtCount; i++)
    {
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">neededExt</span> = requiredExts[i];
        <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"needed Ext : "</span> &lt;&lt; neededExt &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;&#38656;&#35201;&#30340; extensions &#26159;&#21542;&#37117;&#34987;&#25903;&#25345;</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isAllSupported</span> = <span style="color: #a45bad;">true</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; requiredExtCount; i++)
    {
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">neededExt</span> = requiredExts[i];
        <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isSupported</span> = <span style="color: #a45bad;">false</span>;
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">supportedExt</span> : supportedExtensions)
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">std</span>::strcmp(supportedExt.extensionName, neededExt))
            {
                isSupported = <span style="color: #a45bad;">true</span>;
                <span style="color: #4f97d7; font-weight: bold;">continue</span>;
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>isSupported)
        {
            isAllSupported = <span style="color: #a45bad;">false</span>;
            <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"unsupport extension : "</span> &lt;&lt; neededExt &lt;&lt; <span style="color: #2d9574;">" "</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> isAllSupported;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#25105;&#30340;&#31995;&#32479;&#24403;&#21069;&#25903;&#25345;&#30340;extensions</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_device_group_creation</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_display</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_external_fence_capabilities</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_external_memory_capabilities</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_external_semaphore_capabilities</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_get_display_properties2</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_get_physical_device_properties2</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_get_surface_capabilities2</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_surface</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_surface_protected_capabilities</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_KHR_win32_surface</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_EXT_debug_report</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_EXT_debug_utils</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_EXT_swapchain_colorspace</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported Ext : VK_NV_external_memory_capabilities</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org42501cd" class="outline-6">
<h6 id="org42501cd">Cleaning up</h6>
<div class="outline-text-6" id="text-org42501cd">
<p>
VkInstance 对象需要在应用程序退出之前被销毁。使用 vkDestroyInstance 函数来销毁该对象。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgde24025" class="outline-5">
<h5 id="orgde24025">Validation layers (50)</h5>
<div class="outline-text-5" id="text-orgde24025">
</div>
<div id="outline-container-org26988f3" class="outline-6">
<h6 id="org26988f3">What are validation layers?</h6>
<div class="outline-text-6" id="text-org26988f3">
<p>
Vulkan API 的设计理念是将驱动程序开销降至最低。默认情况下，API 中的错误检查非常有限。甚至很简单的错误，如：枚举值不正确或者必须的参数指针为空等等，都没有被显示地处理，并且这些简单错误会简单地导致崩溃或未定义行为。但是，Vulkan 引入了一个优雅的系统用于这些错误检查，该系统就是 validation layers。Validation layers 是可选组件，其 hook 到 Vulkan 函数调用内来执行额外的操作。通常 validation layers 会执行如下操作：<br />
</p>
<ul class="org-ul">
<li>根据规范检查参数值以检测误用<br /></li>
<li>跟踪对象的创建和销毁以发现资源泄漏<br /></li>
<li>通过跟踪函数调用的线程来检查线程安全<br /></li>
<li>记录所有函数调用和函数调用对应的参数，并输出到标准输出<br /></li>
<li>跟踪 Vulkan 调用进行性能分析和重放<br /></li>
</ul>

<p>
下面是 validation layer 中一个函数的实现：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkResult</span> <span style="color: #bc6ec5; font-weight: bold;">vkCreateInstance</span>(
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkInstanceCreateInfo</span>* <span style="color: #7590db;">pCreateInfo</span>,
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkAllocationCallbacks</span>* <span style="color: #7590db;">pAllocator</span>,
    <span style="color: #ce537a; font-weight: bold;">VkInstance</span>* <span style="color: #7590db;">instance</span>) {

    <span style="color: #4f97d7; font-weight: bold;">if</span> (pCreateInfo == <span style="color: #a45bad;">nullptr</span> || instance == <span style="color: #a45bad;">nullptr</span>) {
        log(<span style="color: #2d9574;">"Null pointer passed to required parameter!"</span>);
        <span style="color: #4f97d7; font-weight: bold;">return</span> VK_ERROR_INITIALIZATION_FAILED;
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</pre>
</div>

<p>
这些 validation layers 可以自由堆叠以包含你感兴趣的所有调试功能。你可以简单地为调试版本启用 validation layers，并为发布版本完全禁用它们，这样就可以两全其美了！<br />
</p>

<p>
Vulkan 没有内置任何 validation layers，但 LunarG Vulkan SDK 提供了一组很好的 validation layers 来检查常见错误。它们也是完全开源的。由于意外依赖未定义行为，应用程序在不同驱动上会被破坏，使用 validation layers 是避免这种问题的最佳方法。validation layers 只有在安装到系统上后才能被使用。 例如，LunarG validation layers 仅在安装了 Vulkan SDK 的 PC 上可用。<br />
</p>

<p>
Vulkan 中以前有两种不同类型的 validation layers：instance 类型和特定设备类型。instance 类型的 validation layers 只会检查与全局 Vulkan 对象（如 VkInstance）相关的调用，而设备特定的 validation layers 只会检查与特定 GPU 相关的调用。设备特定的 validation layers 现已弃用，这意味着 instance 类型的 validation layers 适用于所有 Vulkan 调用。为了兼容性，规范文档仍然建议在设备级别也启用 validation layers，这是某些实现所要求的。 我们将简单地为 instance 和 逻辑设备指定相同的 validation layers。<br />
</p>
</div>
</div>

<div id="outline-container-orga24f93b" class="outline-6">
<h6 id="orga24f93b">Using validation layers</h6>
<div class="outline-text-6" id="text-orga24f93b">
<p>
和 extensions 一样，需要指定 validation layers 的名称来开启它们。所有有用的标准验证都捆绑在 SDK 中的一个层中，其名称为 VK_LAYER_KHRONOS_validation。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkInstanceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &amp;appInfo;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20351;&#29992;&#30340; extensions </span>
createInfo.enabledExtensionCount = glfwExtensionCount;
createInfo.ppEnabledExtensionNames = glfwExtensions;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20351;&#29992;&#30340; layers</span>
<span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers)
{
    createInfo.enabledLayerCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(validationLayers.size());
    createInfo.ppEnabledLayerNames = validationLayers.data();
}
<span style="color: #4f97d7; font-weight: bold;">else</span>
{
    createInfo.enabledLayerCount = 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#25105;&#30340;&#31995;&#32479;&#24403;&#21069;&#25903;&#25345;&#30340;layers</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_NV_optimus</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_NV_nomad_release_public_2021_3_1</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_NV_GPU_Trace_release_public_2021_3_1</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_RENDERDOC_Capture</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_VALVE_steam_overlay</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_VALVE_steam_fossilize</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_EOS_Overlay</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_EOS_Overlay</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_ROCKSTAR_GAMES_social_club</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_INTEL_state_tracker</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_LUNARG_api_dump</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_LUNARG_device_simulation</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_LUNARG_gfxreconstruct</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_KHRONOS_synchronization2</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_KHRONOS_validation</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_LUNARG_monitor</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">supported layer : VK_LAYER_LUNARG_screenshot</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgfcd2147"></a>ERROR: 支持的 layer 中不包含 VK_LAYER_KHRONOS_validation<br />
<div class="outline-text-7" id="text-orgfcd2147">
<p>
安装最新版本的 VulkanSDK 1.2.189.2，该问题修复。注意，安装时需要使用 administrator 权限运行安装程序。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org1100e75" class="outline-6">
<h6 id="org1100e75">Message callback</h6>
<div class="outline-text-6" id="text-org1100e75">
<p>
默认情况下，validation layers 会将调试消息打印到标准输出，但我们也可以通过提供显式的回调函数来自己处理调试消息。这也将允许你决定要查看哪种消息，因为并非所有消息都必然是（致命的）错误。为了设置一个回调函数来处理消息，我们需要使用 VK_EXT_debug_utils。<br />
</p>

<p>
下面函数就是用于处理调试消息的回调函数。VKAPI_ATTR 和 VKAPI_CALL 确保该函数有正确的签名，从而让 Vulkan 调用。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">static</span> VKAPI_ATTR VkBool32 <span style="color: #ce537a; font-weight: bold;">VKAPI_CALL</span> <span style="color: #bc6ec5; font-weight: bold;">debugCallback</span>(
    <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessageSeverityFlagBitsEXT</span> <span style="color: #7590db;">messageSeverity</span>,
    <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessageTypeFlagsEXT</span> <span style="color: #7590db;">messageType</span>,
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerCallbackDataEXT</span>* <span style="color: #7590db;">pCallbackData</span>,
    <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">pUserData</span>) {

    <span style="color: #a45bad;">std</span>::cerr &lt;&lt; <span style="color: #2d9574;">"validation layer: "</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; <span style="color: #a45bad;">std</span>::endl;

    <span style="color: #4f97d7; font-weight: bold;">return</span> VK_FALSE;
}
</pre>
</div>
<p>
函数的第一个参数（messageSeverity）指定消息的严重性，它可以是以下标志之一：<br />
</p>
<ul class="org-ul">
<li>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT 诊断消息<br /></li>
<li>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT    信息性消息，如创建资源<br /></li>
<li>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT 关于行为的消息，不一定是错误，但很可能是应用程序中的 Bug<br /></li>
<li>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT   有关无效行为的消息，并且该无效行为可能导致崩溃<br /></li>
</ul>

<p>
函数的第二个参数（messageType）可以包含如下所列的值：<br />
</p>
<ul class="org-ul">
<li>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT     发生了一些与规范或性能无关的事件<br /></li>
<li>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT  发生了违反规范或可能存在错误的事情<br /></li>
<li>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT 发生了可能是非最佳使用 Vulkan 的事情<br /></li>
</ul>

<p>
函数的第三个参数（pCallbackData）指向一个 VkDebugUtilsMessengerCallbackDataEXT 结构体，其中包含了消息的具体细节，该结构体中最主要的成员如下：<br />
</p>
<ul class="org-ul">
<li>pMessage     消息内容，为以空字符结尾的字符串<br /></li>
<li>pObjects     与消息相关的 Vulkan 对象句柄数组<br /></li>
<li>objectCount  数组中的对象数<br /></li>
</ul>

<p>
函数的最后一个参数（pUserData）是一个指针。在设置回调函数的时候可以指定该指针，从而允许你传递自己的数据。<br />
函数的返回值为一个 bool 值，其用于指示 Vulkan 调用某个函数触发 validation layer 的消息时，Vulkan 对该函数的调用是否应该中止。如果回调函数返回 true，则 Vulkan 对该函数的调用会中止，并返回 VK_ERROR_VALIDATION_FAILED_EXT 错误。这通常仅用于测试验证层本身，因此你应该始终返回 VK_FALSE。 TODO<br />
</p>

<p>
在 Vulkan 中 debug callback 也是通过句柄来管理的，需要显示的创建和销毁。debug callback 属于 debug messenger 的一部分，你可以有多个 debug messenger(VkDebugUtilsMessengerEXT)。需要使用 vkCreateDebugUtilsMessengerEXT 来创建 VkDebugUtilsMessengerEXT，但是 vkCreateDebugUtilsMessengerEXT 是一个扩展函数，不会被自动加载。因此，需要自己获取该函数的地址。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkResult</span> <span style="color: #bc6ec5; font-weight: bold;">CreateDebugUtilsMessengerEXT</span>(<span style="color: #ce537a; font-weight: bold;">VkInstance</span> <span style="color: #7590db;">instance</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerCreateInfoEXT</span>* <span style="color: #7590db;">pCreateInfo</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkAllocationCallbacks</span>* <span style="color: #7590db;">pAllocator</span>, <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerEXT</span>* <span style="color: #7590db;">pDebugMessenger</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vkCreateDebugUtilsMessengerEXT &#26159;&#19968;&#20010;&#25193;&#23637;&#20989;&#25968;&#65292;&#19981;&#20250;&#34987;&#33258;&#21160;&#21152;&#36733;&#12290;&#22240;&#27492;&#65292;&#38656;&#35201;&#33258;&#24049;&#33719;&#21462;&#35813;&#20989;&#25968;&#30340;&#22320;&#22336;</span>
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">func</span> = (<span style="color: #ce537a; font-weight: bold;">PFN_vkCreateDebugUtilsMessengerEXT</span>)vkGetInstanceProcAddr(instance, <span style="color: #2d9574;">"vkCreateDebugUtilsMessengerEXT"</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (func != <span style="color: #a45bad;">nullptr</span>)
    {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">debugMessenger&#26159;&#25351;&#23450;&#32473;Vulkan instance&#21644;&#23427;&#30340;layers&#30340;&#65292;&#22240;&#27492;&#38656;&#35201;&#23558;instance&#20316;&#20026;&#31532;&#19968;&#20010;&#21442;&#25968;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> func(instance, pCreateInfo, pAllocator, pDebugMessenger);
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}
</pre>
</div>

<p>
下面代码用来创建 debug messenger:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerCreateInfoEXT</span> <span style="color: #7590db;">createInfo</span>{};
createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
createInfo.pfnUserCallback = debugCallback;
createInfo.pUserData = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
<span style="color: #4f97d7; font-weight: bold;">if</span> (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS)
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to set up debug messenger!"</span>);
}
</pre>
</div>

<p>
需要使用 vkDestroyDebugUtilsMessengerEXT 函数来销毁 debug messenger。和创建时一样，也需要特殊处理。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">DestroyDebugUtilsMessengerEXT</span>(<span style="color: #ce537a; font-weight: bold;">VkInstance</span> <span style="color: #7590db;">instance</span>, <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerEXT</span> <span style="color: #7590db;">debugMessenger</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkAllocationCallbacks</span>* <span style="color: #7590db;">pAllocator</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">func</span> = (<span style="color: #ce537a; font-weight: bold;">PFN_vkDestroyDebugUtilsMessengerEXT</span>) vkGetInstanceProcAddr(instance, <span style="color: #2d9574;">"vkDestroyDebugUtilsMessengerEXT"</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (func != <span style="color: #a45bad;">nullptr</span>) {
        func(instance, debugMessenger, pAllocator);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org91e6c6b" class="outline-6">
<h6 id="org91e6c6b">Debugging instance creation and destruction</h6>
<div class="outline-text-6" id="text-org91e6c6b">
<p>
vkCreateDebugUtilsMessengerEXT 调用需要一个可用的 instance(VkInstance)，而且必须在 instance 销毁之前调用 vkDestroyDebugUtilsMessengerEXT，因此，调用 vkCreateInstance 和 vkDestroyInstance 时，我们还无法调试任何问题。<br />
</p>

<p>
我们可以为 VkInstanceCreateInfo 结构体的 pNext 成员提供一个指向 VkDebugUtilsMessengerCreateInfoEXT 结构体的指针，这样就可以为 vkCreateInstance 和 vkDestroyInstance 这两个函数创建一个单独的 debug messenger 了。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createInstance</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#21551; validation layers</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers &amp;&amp; <span style="color: #a45bad;">!</span>checkValidationLayerSupport())
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"some validation layers unsupported!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#38656;&#35201;&#30340;&#25152;&#26377; extensions</span>
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">neededExtensions</span> = getRequiredExtensions();
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>checkRequiredExtensionsSupport(neededExtensions.data(), neededExtensions.size()))
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"some extension unsupported!"</span>);
    }

    <span style="color: #ce537a; font-weight: bold;">VkApplicationInfo</span> <span style="color: #7590db;">appInfo</span>{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = <span style="color: #2d9574;">"Hello Triangle"</span>;
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = <span style="color: #2d9574;">"No Engine"</span>;
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_0;

    <span style="color: #ce537a; font-weight: bold;">VkInstanceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &amp;appInfo;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20351;&#29992;&#30340; extensions</span>
    createInfo.enabledExtensionCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(neededExtensions.size());
    createInfo.ppEnabledExtensionNames = neededExtensions.data();
    <span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerCreateInfoEXT</span> <span style="color: #7590db;">debugCreateInfo</span>{};
    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20351;&#29992;&#30340; layers</span>
        createInfo.enabledLayerCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; instance &#30340;&#21019;&#24314;&#21644;&#38144;&#27585;&#35843;&#29992;&#21019;&#24314; debug messenger</span>
        populateDebugMessengerCreateInfo(debugCreateInfo);
        createInfo.pNext = (<span style="color: #ce537a; font-weight: bold;">VkDebugUtilsMessengerCreateInfoEXT</span>*)&amp;debugCreateInfo;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        createInfo.enabledLayerCount = 0;
    }

    <span style="color: #ce537a; font-weight: bold;">VkResult</span> <span style="color: #7590db;">result</span> = vkCreateInstance(&amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;instance);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (result != VK_SUCCESS)
    {
        <span style="color: #a45bad;">std</span>::cerr &lt;&lt; <span style="color: #2d9574;">"ERROR Code : "</span>  &lt;&lt; result &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create instance!"</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf8b3c63" class="outline-6">
<h6 id="orgf8b3c63">Configuration</h6>
<div class="outline-text-6" id="text-orgf8b3c63">
<p>
除了 VkDebugUtilsMessengerCreateInfoEXT 结构中指定的标志之外，validation layers 的行为还有很多设置。 在 Vulkan SDK 中有一个 Config/vk_layer_settings.txt 文件，其中详细解释了如何 validation layers。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgde60f4f" class="outline-5">
<h5 id="orgde60f4f">Physical devices and queue families (62)</h5>
<div class="outline-text-5" id="text-orgde60f4f">
</div>
<div id="outline-container-org23e73b5" class="outline-6">
<h6 id="org23e73b5">Selecting a physical device</h6>
<div class="outline-text-6" id="text-org23e73b5">
<p>
通过 VkInstance 对 Vulkan 库进行初始化后，我们需要从系统中查询并选择一个显卡，该显卡支持我们所需的所有特性。事实上我们可以选择任意数量的显卡并同时使用他们，但是该教程中我们只使用第一个适合我们的显卡。最后，我们会将所选的显卡存储到一个 VkPhysicalDevice 句柄。当 VkInstance 被销毁时，该对象会被隐式地销毁，因此，我们不需要在 cleanup 中做显示的销毁操作。<br />
</p>

<p>
下面代码用来获取系统中的所有显卡：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">deviceCount</span> = 0;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, <span style="color: #a45bad;">nullptr</span>);
<span style="color: #4f97d7; font-weight: bold;">if</span> (deviceCount == 0) {
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find GPUs with Vulkan support!"</span>);
}
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkPhysicalDevice&gt; <span style="color: #bc6ec5; font-weight: bold;">devices</span>(deviceCount);
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());
</pre>
</div>

<p>
下面代码可以用来获取显卡设备的详细属性：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462; &#21517;&#31216;&#12289;&#31867;&#22411;&#12289;&#25903;&#25345;&#30340;Vulkan&#29256;&#26412;&#31561;&#22522;&#30784;&#26174;&#21345;&#35774;&#22791;&#23646;&#24615;</span>
<span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceProperties</span> <span style="color: #7590db;">deviceProperties</span>;
vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462; &#36148;&#22270;&#21387;&#32553;&#65292;64&#20301;&#28014;&#28857;&#25968;&#25903;&#25345;&#20197;&#21450;&#22810;&#35270;&#21475;&#28210;&#26579;&#25903;&#25345;(VR&#20250;&#20351;&#29992;&#35813;&#29305;&#24615;) &#31561;&#21487;&#36873;&#26174;&#21345;&#35774;&#22791;&#29305;&#24615;</span>
<span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>;
vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);
</pre>
</div>

<p>
假设我们的应用程序需要专用的显卡(用于支持 Geometry Shader)才能使用。则我们使用下面方法来判断 VkPhysicalDevice 是否合适：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isDeviceSuitable</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceProperties</span> <span style="color: #7590db;">deviceProperties</span>;
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>;
    vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &#34920;&#31034; &#26174;&#21345;&#35774;&#22791;&#20026;&#29420;&#31435;&#26174;&#21345;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26174;&#21345;&#35774;&#22791;&#20026;&#29420;&#31435;&#26174;&#21345;&#65292;&#24182;&#19988;&#25903;&#25345;GeometryShader</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &amp;&amp; deviceFeatures.geometryShader;
}
</pre>
</div>

<p>
我们可以对所有适合的显卡设备进行评分，从而选择评分最高的显卡设备：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">pickPhysicalDevice</span>()
{
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">deviceCount</span> = 0;
    vkEnumeratePhysicalDevices(instance, &amp;deviceCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (deviceCount == 0)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find GPUs with Vulkan support!"</span>);
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkPhysicalDevice&gt; <span style="color: #7590db;">devices</span>(deviceCount);
    vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Use an ordered map to automatically sort candidates by increasing score</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">multimap</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>, VkPhysicalDevice&gt; <span style="color: #7590db;">candidates</span>;

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">device</span> : devices)
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">score</span> = rateDeviceSuitability(device);
        candidates.insert(<span style="color: #a45bad;">std</span>::make_pair(score, device));
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Check if the best candidate is suitable at all</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (candidates.rbegin()-&gt;first &gt; 0)
    {
        physicalDevice = candidates.rbegin()-&gt;second;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find a suitable GPU!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> (physicalDevice == VK_NULL_HANDLE)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find a suitable GPU!"</span>);
    }
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">rateDeviceSuitability</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceProperties</span> <span style="color: #7590db;">deviceProperties</span>;
    vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>;
    vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">score</span> = 0;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Discrete GPUs have a significant performance advantage</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Maximum possible size of textures affects graphics quality</span>
    score += deviceProperties.limits.maxImageDimension2D;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Application can't function without geometry shaders</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>deviceFeatures.geometryShader)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> score;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6cd17d2" class="outline-6">
<h6 id="org6cd17d2">Queue families</h6>
<div class="outline-text-6" id="text-org6cd17d2">
<p>
Vulkan 中几乎每个操作都需要被提交到一个 queue 中。不同类型的 queue 来自不同的 queue families，每个 queue family 只允许一组命令集合，该集合只是所有命令集合的一个子集。我们需要检查显卡设备支持哪些 queue families，以及其中的哪个 queue family 支持的命令是我们需要使用的。<br />
</p>

<p>
使用如下方法来获得显卡设备支持的 queue families:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">uint32_t &#21487;&#20197;&#34920;&#31034;&#30340;&#20219;&#20309;&#19968;&#20010;&#20540;&#37117;&#21487;&#33021;&#26159;&#19968;&#20010;&#21487;&#29992;&#30340; queue family index std::optional&lt;uint32_t&gt; &#26469;&#34920;&#31034; queue family index</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">optional</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">graphicsFamily</span>;

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isComplete</span>() 
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403; graphicsFamily.has_value() &#20026; false &#26102;&#65292;&#34920;&#31034;&#19981;&#26159;&#19968;&#20010;&#21487;&#29992;&#30340; queue family</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> graphicsFamily.has_value();
    }
};

<span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #bc6ec5; font-weight: bold;">findQueueFamilies</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>) 
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#35774;&#22791;&#25903;&#25345;&#30340; queue family</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">queueFamilyCount</span> = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkQueueFamilyProperties&gt; <span style="color: #7590db;">queueFamilies</span>(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">queueFamily</span> : queueFamilies) 
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; queueFamily &#26159;&#21542;&#25903;&#25345;&#22270;&#24418;&#25805;&#20316;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) 
        {
            indices.graphicsFamily = i;
        }

        <span style="color: #4f97d7; font-weight: bold;">if</span> (indices.isComplete())
        {
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }
        i++;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> indices;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkQueueFlagBits &#26522;&#20030;&#23450;&#20041;&#22914;&#19979;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Provided by VK_VERSION_1_0</span>
<span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">VkQueueFlagBits</span>
{
    <span style="color: #7590db;">VK_QUEUE_GRAPHICS_BIT</span> = 0x00000001,          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22270;&#24418;&#25805;&#20316;</span>
    <span style="color: #7590db;">VK_QUEUE_COMPUTE_BIT</span> = 0x00000002,           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35745;&#31639;&#25805;&#20316;</span>
    <span style="color: #7590db;">VK_QUEUE_TRANSFER_BIT</span> = 0x00000004,          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36716;&#31227;&#25805;&#20316;</span>
    <span style="color: #7590db;">VK_QUEUE_SPARSE_BINDING_BIT</span> = 0x00000008,    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31232;&#30095;&#20869;&#23384;&#31649;&#29702;&#25805;&#20316;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Provided by VK_VERSION_1_1</span>
    <span style="color: #7590db;">VK_QUEUE_PROTECTED_BIT</span> = 0x00000010,         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20445;&#25252;&#20301;</span>
<span style="color: #bc6ec5;">#ifdef</span> VK_ENABLE_BETA_EXTENSIONS
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Provided by VK_KHR_video_decode_queue</span>
    <span style="color: #7590db;">VK_QUEUE_VIDEO_DECODE_BIT_KHR</span> = 0x00000020,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25903;&#25345;&#35270;&#39057;&#35299;&#30721;&#25805;&#20316;</span>
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#ifdef</span> VK_ENABLE_BETA_EXTENSIONS
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Provided by VK_KHR_video_encode_queue</span>
    <span style="color: #7590db;">VK_QUEUE_VIDEO_ENCODE_BIT_KHR</span> = 0x00000040,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25903;&#25345;&#35270;&#39057;&#32534;&#30721;&#25805;&#20316;</span>
<span style="color: #bc6ec5;">#endif</span>
} <span style="color: #ce537a; font-weight: bold;">VkQueueFlagBits</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgadb2634" class="outline-5">
<h5 id="orgadb2634">Logical device and queues (70)</h5>
<div class="outline-text-5" id="text-orgadb2634">
<p>
选择要使用的物理设备后，我们需要设置一个逻辑设备来与之交互。 逻辑设备创建过程与实例创建过程类似，我们需要描述想要使用的特性，我们还需要指定创建哪个队列(我们已经查询了哪些 queue families 是可用的)。如果你有不同的需求，你甚至可以从同一物理设备创建多个逻辑设备。使用 VkDevice 来存储逻辑设备的句柄。<br />
</p>

<p>
创建逻辑设备需要使用多个结构体指定一系列细节，VkDeviceQueueCreateInfo 结构体用于描述我们所需的 queue family、对于单个 queue family 我们需要 queue 的数量，以及这些 queues 的优先级。当前可用的驱动只允许你为每个 queue family 创建少量的 queue，事实上你通常所需的数量不会超过一个。因为你可以在多个线程上创建所有的 command buffers，然后在主线程上使用单次低消耗的调用将他们一次性提交到一个 queue 中。 VkPhysicalDeviceFeatures 结构体用于描述我们将要使用的设备特性。<br />
</p>

<p>
创建逻辑设备的代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createLogicalDevice</span>()
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span> = findQueueFamilies(physicalDevice);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314;&#22810;&#20010;VkDeviceQueueCreateInfo &#21487;&#20197;&#25351;&#23450;&#22810;&#20010;queue family</span>
    <span style="color: #ce537a; font-weight: bold;">VkDeviceQueueCreateInfo</span> <span style="color: #7590db;">queueCreateInfo</span>{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21019;&#24314;queue &#30340;&#25968;&#37327;</span>
    queueCreateInfo.queueCount = 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">queuePriority</span> = 1.0f;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;queues&#30340;&#20248;&#20808;&#32423;&#65292;&#20248;&#20808;&#32423;&#20250;&#24433;&#21709; command buffer &#25191;&#34892;&#30340;&#35843;&#24230;&#65292;&#21363;&#20351;&#21482;&#26377;&#19968;&#20010; queue &#20063;&#38656;&#35201;&#25351;&#23450;&#35813;&#21442;&#25968;</span>
    queueCreateInfo.pQueuePriorities = &amp;queuePriority;

    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>{};

    <span style="color: #ce537a; font-weight: bold;">VkDeviceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    createInfo.pQueueCreateInfos = &amp;queueCreateInfo;
    createInfo.queueCreateInfoCount = 1;

    createInfo.pEnabledFeatures = &amp;deviceFeatures;
    createInfo.enabledExtensionCount = 0;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32769;&#29256;&#26412;&#30340; Vulkan&#65292;&#23545; instance &#30340; validation layers &#21644; device &#29305;&#23450;&#30340;validation layers&#20570;&#20102;&#21306;&#20998;&#65292;&#26032;&#29256;&#26412;&#21435;&#25481;&#20102;&#36825;&#31181;&#21306;&#20998;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#20860;&#23481;&#32769;&#29256;&#26412;&#30340; Vulkan &#23454;&#29616;&#65292;&#27492;&#22788;&#20381;&#28982;&#20026; device &#25351;&#23450; validation layers</span>
        createInfo.enabledLayerCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        createInfo.enabledLayerCount = 0;
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDevice(physicalDevice, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;device) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create logical device!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">queues &#30340;&#21019;&#24314;&#26159;&#38543;&#30528;&#36923;&#36753;&#35774;&#22791;&#30340;&#21019;&#24314;&#33258;&#21160;&#21019;&#24314;&#30340;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#19979;&#38754;&#20989;&#25968;&#33719;&#21462; queues &#30340;&#21477;&#26564;&#65292;&#24182;&#20445;&#23384;&#21040;VkQueue&#31867;&#22411;&#30340;&#21464;&#37327;&#20013;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21442;&#25968;&#20026;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">&#36923;&#36753;&#35774;&#22791;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">queue family&#30340;&#32034;&#24341;&#20540;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">queue&#30340;&#32034;&#24341;&#20540;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">&#23384;&#20648;&#21477;&#26564;&#30340;&#21464;&#37327;</span>
    vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue);
}
</pre>
</div>

<p>
当 logical device 被销毁时，queues 会被隐式销毁，因此我们不需要做任何清理工作。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbe0c625" class="outline-4">
<h4 id="orgbe0c625">Presentation</h4>
<div class="outline-text-4" id="text-orgbe0c625">
</div>
<div id="outline-container-orgb22542b" class="outline-5">
<h5 id="orgb22542b">Window surface (74)</h5>
<div class="outline-text-5" id="text-orgb22542b">
<p>
Vulkan 是平台无关的 API，其无法直接和窗口系统进行交互。为了在 Vulkan 和窗口系统直接建立联系，我们需要使用 WSI（Windows System Integration）扩展。本章先介绍 VK_KHR_surface 扩展，该扩展暴露了一个 VkSurfaceKHR 对象，其为 surface 的抽象类型，用于展示渲染到图片中的内容。<br />
</p>

<p>
VK_KHR_surface 扩展属于 instance 级别的扩展，事实上，我们已经开启了该扩展，该扩展被包含在 glfwGetRequiredInstanceExtensions 函数返回的列表中。<br />
</p>

<p>
需要在 instance 创建后，紧接着就创建 window surface。window surface 扩展会影响到物理设备的选择。Vulkan 中 window surfaces 整体是一个可选的组件，如果你需要离屏渲染，就不需要使用该扩展了。<br />
</p>
</div>
<div id="outline-container-orgdd5e10c" class="outline-6">
<h6 id="orgdd5e10c">Window surface creation (74)</h6>
<div class="outline-text-6" id="text-orgdd5e10c">
<p>
虽然 VkSurfaceKHR 类型对象以及该对象的使用是平台无关的，但是该对象的创建依赖于窗口系统。例如，Windows 平台上创建 VkSurfaceKHR 对象需要 HWND 和 HMODULE 句柄，因此还存在平台相关的额外扩展，例如：Windows 平台的 VK_KHR_win32_surface 扩展，该扩展也被包含在 glfwGetRequiredInstanceExtensions 函数返回的列表中了。<br />
下面方法用来创建 Windows 平台的 VkSurfaceKHR:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">
<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">VK_USE_PLATFORM_WIN32_KHR</span>
<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">GLFW_INCLUDE_VULKAN</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;GLFW/glfw3.h&gt;</span>
<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">GLFW_EXPOSE_NATIVE_WIN32</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;GLFW/glfw3native.h&gt;</span>

<span style="color: #ce537a; font-weight: bold;">VkSurfaceKHR</span> <span style="color: #7590db;">surface</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createSurface</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkWin32SurfaceCreateInfoKHR</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    createInfo.hwnd = glfwGetWin32Window(window);
    createInfo.hinstance = GetModuleHandle(<span style="color: #a45bad;">nullptr</span>);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateWin32SurfaceKHR(instance, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;surface) != VK_SUCCESS) {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create window surface!"</span>);
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLFW &#20026;&#25105;&#20204;&#25552;&#20379;&#20102;&#21019;&#24314; VkSurfaceKHR &#30340;&#20989;&#25968;&#65292;&#25105;&#20204;&#21487;&#20197;&#30452;&#25509;&#35843;&#29992;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createSurface</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (glfwCreateWindowSurface(instance, window, <span style="color: #a45bad;">nullptr</span>, &amp;surface) != VK_SUCCESS) {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create window surface!"</span>);
    }
}
</pre>
</div>

<p>
在结束时，需要手动清理 VkSurfaceKHR 对象。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">vkDestroySurfaceKHR(instance, surface, <span style="color: #a45bad;">nullptr</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff37061" class="outline-6">
<h6 id="orgff37061">Querying for presentation support (76)</h6>
<div class="outline-text-6" id="text-orgff37061">
<p>
尽管 Vulkan 实现可能支持窗口系统的集成，但也不意味着系统中的每个 device 都支持。使用如下方法来检查设备是否支持 Surface：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #bc6ec5; font-weight: bold;">findQueueFamilies</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#35774;&#22791;&#25903;&#25345;&#30340; queue family</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">queueFamilyCount</span> = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkQueueFamilyProperties&gt; <span style="color: #7590db;">queueFamilies</span>(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">queueFamily</span> : queueFamilies)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; queueFamily &#26159;&#21542;&#25903;&#25345;&#22270;&#24418;&#25805;&#20316;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT)
        {
            indices.graphicsFamily = i;
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; queueFamily &#26159;&#21542;&#25903;&#25345;&#23637;&#31034;&#28210;&#26579;&#32467;&#26524;</span>
        <span style="color: #ce537a; font-weight: bold;">VkBool32</span> <span style="color: #7590db;">presentSupport</span> = <span style="color: #a45bad;">false</span>;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &amp;presentSupport);
        <span style="color: #4f97d7; font-weight: bold;">if</span> (presentSupport)
        {
            indices.presentFamily = i;
        }

        <span style="color: #4f97d7; font-weight: bold;">if</span> (indices.isComplete())
        {
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }
        i++;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> indices;
}
</pre>
</div>
<p>
需要注意的是，支持图形操作的 Queue Family 和支持 Surface 的 Queue Family 可能就是同一个 Queue Family，但是为了统一处理两者不是同一个 QueueFamily 的情况，我们在代码中使用了 graphicsFamily、presentFamily 两个 index。你还可以在代码中增加一些逻辑，如果某个物理设备的某个 Queue Family 同时支持图形操作和 Surface，则优先选择该物理设备，这样可以提升性能。<br />
</p>
</div>
</div>
<div id="outline-container-org2354977" class="outline-6">
<h6 id="org2354977">Creating the presentation queue (77)</h6>
<div class="outline-text-6" id="text-org2354977">
<p>
queues 的创建是随着逻辑设备的创建自动创建的，下面方法中添加了创建 presentQueue 相关的设置:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createLogicalDevice</span>()
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span> = findQueueFamilies(physicalDevice);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#21019;&#24314;&#22810;&#20010;VkDeviceQueueCreateInfo &#21487;&#20197;&#25351;&#23450;&#22810;&#20010;queue family]</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkDeviceQueueCreateInfo&gt; <span style="color: #7590db;">queueCreateInfos</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#36825;&#37324;&#25351;&#23450;&#20102; graphicsFamily &#21644; presentFamily&#65292;&#24182;&#20351;&#29992;set&#23481;&#22120;&#22788;&#29702;&#20102;&#20004;&#32773;&#30456;&#21516;&#21644;&#19981;&#21516;&#30340;&#24773;&#20917;]</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">set</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">uniqueQueueFamilies</span> = { indices.graphicsFamily.value(), indices.presentFamily.value() };
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">queuePriority</span> = 1.0f;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">queueFamily</span> : uniqueQueueFamilies)
    {
        <span style="color: #ce537a; font-weight: bold;">VkDeviceQueueCreateInfo</span> <span style="color: #7590db;">queueCreateInfo</span>{};
        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21019;&#24314;queue &#30340;&#25968;&#37327;</span>
        queueCreateInfo.queueCount = 1;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;queues&#30340;&#20248;&#20808;&#32423;&#65292;&#20248;&#20808;&#32423;&#20250;&#24433;&#21709; command buffer &#25191;&#34892;&#30340;&#35843;&#24230;&#65292;&#21363;&#20351;&#21482;&#26377;&#19968;&#20010; queue &#20063;&#38656;&#35201;&#25351;&#23450;&#35813;&#21442;&#25968;</span>
        queueCreateInfo.pQueuePriorities = &amp;queuePriority;
        queueCreateInfos.push_back(queueCreateInfo);
    }

    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>{};

    <span style="color: #ce537a; font-weight: bold;">VkDeviceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#25351;&#23450;&#21019;&#24314;&#30340; Queue &#21015;&#34920;]</span>
    createInfo.pQueueCreateInfos = queueCreateInfos.data();
    createInfo.queueCreateInfoCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(queueCreateInfos.size());

    createInfo.pEnabledFeatures = &amp;deviceFeatures;
    createInfo.enabledExtensionCount = 0;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32769;&#29256;&#26412;&#30340; Vulkan&#65292;&#23545; instance &#30340; validation layers &#21644; device &#29305;&#23450;&#30340;validation layers&#20570;&#20102;&#21306;&#20998;&#65292;&#26032;&#29256;&#26412;&#21435;&#25481;&#20102;&#36825;&#31181;&#21306;&#20998;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#20860;&#23481;&#32769;&#29256;&#26412;&#30340; Vulkan &#23454;&#29616;&#65292;&#27492;&#22788;&#20381;&#28982;&#20026; device &#25351;&#23450; validation layers</span>
        createInfo.enabledLayerCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        createInfo.enabledLayerCount = 0;
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDevice(physicalDevice, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;device) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create logical device!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">queues &#30340;&#21019;&#24314;&#26159;&#38543;&#30528;&#36923;&#36753;&#35774;&#22791;&#30340;&#21019;&#24314;&#33258;&#21160;&#21019;&#24314;&#30340;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#19979;&#38754;&#20989;&#25968;&#33719;&#21462; queues &#30340;&#21477;&#26564;&#65292;&#24182;&#20445;&#23384;&#21040;VkQueue&#31867;&#22411;&#30340;&#21464;&#37327;&#20013;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21442;&#25968;&#20026; &#36923;&#36753;&#35774;&#22791;, queue family&#30340;&#32034;&#24341;&#20540;, queue&#30340;&#32034;&#24341;&#20540;, &#23384;&#20648;&#21477;&#26564;&#30340;&#21464;&#37327;</span>
    vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue);
    vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &amp;presentQueue);
}
</pre>
</div>

<p>
当 logical device 被销毁时，queues 会被隐式销毁，因此我们不需要做任何清理工作。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge2dba9e" class="outline-5">
<h5 id="orge2dba9e">Swap chain (79)</h5>
<div class="outline-text-5" id="text-orge2dba9e">
<p>
Vulkan 没有默认的 framebuffer 这个概念，因此，需要一个基础设施来构建一些 buffer，从而才能渲染到这些 buffer 中。这个基础设施就是 swap chain，在 Vulkan 中必须显示地创建该基础设施。swap chain 本质上是一个等待呈现到屏幕上的 image 队列，应用程序从中获取一个 image，然后绘制到其中，接着将其返回到队列中。队列如何工作以及何时呈现队列中的一个 image 取决于 swap chain 的设置，但一般来说，swap chain 的目的是使图像的呈现与屏幕的刷新率相同步。<br />
</p>
</div>
<div id="outline-container-orgee3f836" class="outline-6">
<h6 id="orgee3f836">Checking for swap chain support (79)</h6>
<div class="outline-text-6" id="text-orgee3f836">
<p>
首先，并非所有显卡都支持直接将 images 呈现在屏幕上(原因可能有很多，例如：为服务器设计的显卡就不支持直接将 images 呈现在屏幕上)。其次，image 的呈现与窗口系统以及窗口关联的 surface 密切相关，swap chain 并不是 Vulkan 核心的一部分。因此，swap chain 属于设备扩展（device extension），你需要查询当前设备是否支持 VK_KHR_swapchain，然后再开启该扩展。<br />
</p>

<p>
使用下面方式来检查需要的设备扩展是否被支持<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">checkDeviceExtensionSupport</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">extensionCount</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#25903;&#25345;&#30340;&#35774;&#22791;&#25193;&#23637;&#25968;&#37327;</span>
    vkEnumerateDeviceExtensionProperties(device, <span style="color: #a45bad;">nullptr</span>, &amp;extensionCount, <span style="color: #a45bad;">nullptr</span>);

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkExtensionProperties&gt; <span style="color: #7590db;">availableExtensions</span>(extensionCount);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#25903;&#25345;&#30340;&#35774;&#22791;&#25193;&#23637;&#35814;&#24773;</span>
    vkEnumerateDeviceExtensionProperties(device, <span style="color: #a45bad;">nullptr</span>, &amp;extensionCount, availableExtensions.data());

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">supportedExt</span> : availableExtensions)
    {
        <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"supported Device Ext : "</span> &lt;&lt; supportedExt.extensionName &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; extensionCount; i++)
    {
        <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">neededExt</span> = deviceExtensions[i];
        <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"needed Device Ext : "</span> &lt;&lt; neededExt &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#38656;&#35201;&#30340;&#35774;&#22791;&#25193;&#23637; &#26159;&#21542;&#34987;&#25903;&#25345;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">set</span>&lt;<span style="color: #a45bad;">std</span>::string&gt; <span style="color: #7590db;">requiredExtensions</span>(deviceExtensions.begin(), deviceExtensions.end());
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">extension</span> : availableExtensions) 
    {
        requiredExtensions.erase(extension.extensionName);
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> requiredExtensions.empty();
}
</pre>
</div>
<p>
使用下面方法来开启设备扩展：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createLogicalDevice</span>() 
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span> = findQueueFamilies(physicalDevice);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314;&#22810;&#20010;VkDeviceQueueCreateInfo &#21487;&#20197;&#25351;&#23450;&#22810;&#20010;queue family</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkDeviceQueueCreateInfo&gt; <span style="color: #7590db;">queueCreateInfos</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#37324;&#25351;&#23450;&#20102; graphicsFamily &#21644; presentFamily&#65292;&#24182;&#20351;&#29992;set&#23481;&#22120;&#22788;&#29702;&#20102;&#20004;&#32773;&#30456;&#21516;&#21644;&#19981;&#21516;&#30340;&#24773;&#20917;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">set</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">uniqueQueueFamilies</span> = { indices.graphicsFamily.value(), indices.presentFamily.value() };
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">queuePriority</span> = 1.0f;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">queueFamily</span> : uniqueQueueFamilies)
    {
        <span style="color: #ce537a; font-weight: bold;">VkDeviceQueueCreateInfo</span> <span style="color: #7590db;">queueCreateInfo</span>{};
        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21019;&#24314;queue &#30340;&#25968;&#37327;</span>
        queueCreateInfo.queueCount = 1;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;queues&#30340;&#20248;&#20808;&#32423;&#65292;&#20248;&#20808;&#32423;&#20250;&#24433;&#21709; command buffer &#25191;&#34892;&#30340;&#35843;&#24230;&#65292;&#21363;&#20351;&#21482;&#26377;&#19968;&#20010; queue &#20063;&#38656;&#35201;&#25351;&#23450;&#35813;&#21442;&#25968;</span>
        queueCreateInfo.pQueuePriorities = &amp;queuePriority;
        queueCreateInfos.push_back(queueCreateInfo);
    }

    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">deviceFeatures</span>{};

    <span style="color: #ce537a; font-weight: bold;">VkDeviceCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    createInfo.pQueueCreateInfos = queueCreateInfos.data();
    createInfo.queueCreateInfoCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(queueCreateInfos.size());

    createInfo.pEnabledFeatures = &amp;deviceFeatures;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#24320;&#21551;&#25351;&#23450;&#30340;&#35774;&#22791;&#25193;&#23637;]</span>
    createInfo.enabledExtensionCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(deviceExtensions.size());
    createInfo.ppEnabledExtensionNames = deviceExtensions.data();

    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers) 
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32769;&#29256;&#26412;&#30340; Vulkan&#65292;&#23545; instance &#30340; validation layers &#21644; device &#29305;&#23450;&#30340;validation layers&#20570;&#20102;&#21306;&#20998;&#65292;&#26032;&#29256;&#26412;&#21435;&#25481;&#20102;&#36825;&#31181;&#21306;&#20998;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#20860;&#23481;&#32769;&#29256;&#26412;&#30340; Vulkan &#23454;&#29616;&#65292;&#27492;&#22788;&#20381;&#28982;&#20026; device &#25351;&#23450; validation layers</span>
        createInfo.enabledLayerCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();
    } 
    <span style="color: #4f97d7; font-weight: bold;">else</span> 
    {
        createInfo.enabledLayerCount = 0;
    }

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDevice(physicalDevice, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;device) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create logical device!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">queues &#30340;&#21019;&#24314;&#26159;&#38543;&#30528;&#36923;&#36753;&#35774;&#22791;&#30340;&#21019;&#24314;&#33258;&#21160;&#21019;&#24314;&#30340;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#19979;&#38754;&#20989;&#25968;&#33719;&#21462; queues &#30340;&#21477;&#26564;&#65292;&#24182;&#20445;&#23384;&#21040;VkQueue&#31867;&#22411;&#30340;&#21464;&#37327;&#20013;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21442;&#25968;&#20026; &#36923;&#36753;&#35774;&#22791;, queue family&#30340;&#32034;&#24341;&#20540;, queue&#30340;&#32034;&#24341;&#20540;, &#23384;&#20648;&#21477;&#26564;&#30340;&#21464;&#37327;</span>
    vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue);
    vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &amp;presentQueue);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf346f5b" class="outline-6">
<h6 id="orgf346f5b">Querying details of swap chain support (81)</h6>
<div class="outline-text-6" id="text-orgf346f5b">
<p>
只检测 swap chain 扩展是否可用还不够，还需要检查 swap chain 和 window surface 是否兼容。基本上我们还需要再检查 3 类属性：<br />
</p>
<ul class="org-ul">
<li>基本的 surface 能力 (如：swap chain 中的 images 数量，image 的最大最小宽度、高度)<br /></li>
<li>surface 的格式 (如：像素格式, 颜色空间)<br /></li>
<li>可用的展示模式<br /></li>
</ul>

<p>
使用下面方法来查询 swap chain 的详细属性：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">SwapChainSupportDetails</span> <span style="color: #bc6ec5; font-weight: bold;">querySwapChainSupport</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #ce537a; font-weight: bold;">SwapChainSupportDetails</span> <span style="color: #7590db;">details</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#35810;&#22522;&#30784;&#30340;&#33021;&#21147;</span>
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#35810;&#25903;&#25345;&#30340; surface formats</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">formatCount</span>;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (formatCount != 0)
    {
        details.formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data());
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#35810;&#25903;&#25345;&#30340;&#23637;&#31034;&#27169;&#24335;</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">presentModeCount</span>;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (presentModeCount != 0)
    {
        details.presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data());
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> details;
}
</pre>
</div>

<p>
使用下面方法来检查显卡设备支持的 swap chain 是否满足需要：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isDeviceSuitable</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;&#26174;&#21345;&#35774;&#22791;&#26159;&#21542;&#25903;&#25345;&#25105;&#20204;&#38656;&#35201;&#30340; queue families</span>
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span> = findQueueFamilies(device);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;&#26174;&#21345;&#35774;&#22791;&#26159;&#21542;&#25903;&#25345;&#25105;&#20204;&#25152;&#38656;&#30340;&#35774;&#22791;&#25193;&#23637;</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">extensionsSupported</span> = checkDeviceExtensionSupport(device);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;&#26174;&#21345;&#35774;&#22791;&#25903;&#25345;&#30340; swapChain &#26159;&#21542;&#36275;&#22815;</span>
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">swapChainAdequate</span> = <span style="color: #a45bad;">false</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (extensionsSupported)
    {
        <span style="color: #ce537a; font-weight: bold;">SwapChainSupportDetails</span> <span style="color: #7590db;">swapChainSupport</span> = querySwapChainSupport(device);
        swapChainAdequate = <span style="color: #a45bad;">!</span>swapChainSupport.formats.empty() &amp;&amp; <span style="color: #a45bad;">!</span>swapChainSupport.presentModes.empty();
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org2cfa120"></a>ERROR: vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr); 函数抛出异常 wil::ResultException<br />
<div class="outline-text-7" id="text-org2cfa120">
<p>
在 C++ Exceptions 选项中, 取消勾选 "&lt;All C++ Exceptions not in this list&gt;"。虽然抛出该异常，依然还可以继续执行。<br />
</p>

<ul class="org-ul">
<li><a href="https://answers.microsoft.com/en-us/windows/forum/all/error-spam-when-calling/e8f1f620-448c-47b2-ac51-992064799814?page=2">https://answers.microsoft.com/en-us/windows/forum/all/error-spam-when-calling/e8f1f620-448c-47b2-ac51-992064799814?page=2</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9a5949e" class="outline-6">
<h6 id="org9a5949e">Choosing the right settings for the swap chain (83)</h6>
<div class="outline-text-6" id="text-org9a5949e">
<p>
创建一个 swap chain 涉及的设置比创建 instance 和 device 还多。一共有三种类型的设置：<br />
</p>
<ul class="org-ul">
<li>Surface format（color depth）<br /></li>
<li>展示模式 (将 image 交换到屏幕的条件)<br /></li>
<li>交换的范围 (swap chain 中 images 的分辨率)<br /></li>
</ul>

<p>
使用下面方法来选择 surface format：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkSurfaceFormatKHR</span> <span style="color: #bc6ec5; font-weight: bold;">chooseSwapSurfaceFormat</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkSurfaceFormatKHR</span>&gt;&amp; <span style="color: #7590db;">availableFormats</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">availableFormat</span> : availableFormats)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36873;&#25321;&#26684;&#24335;&#20026; VK_FORMAT_B8G8R8A8_SRGB &#39068;&#33394;&#31354;&#38388;&#20026; VK_COLOR_SPACE_SRGB_NONLINEAR_KHR &#30340; surface format</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> availableFormat;
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> availableFormats[0];
}
</pre>
</div>

<p>
Vulkan 中有 4 种展示模式：<br />
</p>
<ul class="org-ul">
<li>VK_PRESENT_MODE_IMMEDIATE_KHR：你的应用程序提交的 image 会立即传输到屏幕，这可能会导致撕裂。<br /></li>
<li>VK_PRESENT_MODE_FIFO_KHR：swap chain 是一个队列，当显示器刷新时，显示器从队列前面取一张 image，而程序在队列后面插入渲染好的 image。如果队列已满，则程序必须等待。这与现代游戏中的 vertical sync 最为相似。显示刷新的那一刻被称为 vertical blank<br /></li>
<li>VK_PRESENT_MODE_FIFO_RELAXED_KHR：该模式和前一模式的唯一差别是，如果应用程序延迟并且队列在上一个 vertical blank 处为空，则当 image 最终到达时立即传输，而不是等待下一个 vertical blank。这可能会导致可见的撕裂。<br /></li>
<li>VK_PRESENT_MODE_MAILBOX_KHR：这是第二种模式的另一种变体。当队列已满时，不会阻塞应用程序，而是将已经排队的图像简单地替换为较新的图像。此模式可用于尽快地渲染帧，同时还避免了撕裂，从而比标准垂直同步有更少的延迟问题。这就是俗称的“三重缓冲”，但是，单独存在三个缓冲并不一定意味着帧率已解锁。<br /></li>
</ul>

<p>
我个人认为，如果不考虑能耗的话，VK_PRESENT_MODE_MAILBOX_KHR 是一个很好的折中方案。它允许我们避免撕裂，又维持了适当的低延迟。在手机设备上，能耗更加重要，我建议还是使用 VK_PRESENT_MODE_FIFO_KHR。<br />
</p>
<ul class="org-ul">
<li>游戏锁 60fps 和 60hz 屏幕开垂直同步有什么区别？ vsync <a href="https://www.zhihu.com/question/310558703">https://www.zhihu.com/question/310558703</a><br /></li>
<li>Vertical blanking interval <a href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">https://en.wikipedia.org/wiki/Vertical_blanking_interval</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkPresentModeKHR</span> <span style="color: #bc6ec5; font-weight: bold;">chooseSwapPresentMode</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkPresentModeKHR</span>&gt;&amp; <span style="color: #7590db;">availablePresentModes</span>) 
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">availablePresentMode</span> : availablePresentModes) 
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36873;&#25321; &#19977;&#37325;&#32531;&#20914; &#23637;&#31034;&#27169;&#24335;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) 
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> availablePresentMode;
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> VK_PRESENT_MODE_FIFO_KHR;
}
</pre>
</div>

<p>
swap extent 是 swap chain 中 images 的分辨率，它几乎总是完全等于我们要绘制的窗口的分辨率（以像素为单位）。 可能的分辨率范围在 VkSurfaceCapabilitiesKHR 结构中定义。 Vulkan 通过在 currentExtent 成员中设置宽度和高度来告诉我们匹配窗口的分辨率大小。 然而，一些窗口管理器将 currentExtent 中的宽度和高度设置为一个特殊值（uint32_t 的最大值）以此来表示允许 images 的分辨率可以和窗口分辨率不同。在这种情况下，我们将在 minImageExtent 和 maxImageExtent 范围内选择最匹配窗口的分辨率。 但是我们必须以正确的单位指定分辨率。<br />
度量尺寸时，GLFW 使用两种单位：像素和屏幕坐标。例如，之前我们创建窗口时，指定的分辨率 {WIDTH,HEIGHT} 使用的是屏幕坐标。但是，Vulkan 使用的是像素，因此 swap chain extent 必须以像素为单位。当你使用高 DPI 显示器时(如苹果的 Retina 显示屏)，屏幕坐标和像素并不对应。由于像素密度高，窗口的像素分辨率比屏幕坐标要高。因此，如果 Vulkan 没有为我们修正 swap extent，我们将无法使用原来的{WIDTH,HEIGHT}。我们可以使用 glfwGetFramebufferSize 来获取窗口的像素分辨率。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkExtent2D</span> <span style="color: #bc6ec5; font-weight: bold;">chooseSwapExtent</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">VkSurfaceCapabilitiesKHR</span>&amp; <span style="color: #7590db;">capabilities</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (capabilities.currentExtent.width != UINT32_MAX)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> capabilities.currentExtent;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">width</span>, <span style="color: #7590db;">height</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#35810;&#24403;&#21069;&#31383;&#21475;&#30340;&#20687;&#32032;&#20998;&#36776;&#29575;&#22823;&#23567;</span>
        glfwGetFramebufferSize(window, &amp;width, &amp;height);

        <span style="color: #ce537a; font-weight: bold;">VkExtent2D</span> <span style="color: #7590db;">actualExtent</span> = {
            <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(width),
            <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(height)
        };

        actualExtent.width = <span style="color: #a45bad;">std</span>::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
        actualExtent.height = <span style="color: #a45bad;">std</span>::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

        <span style="color: #4f97d7; font-weight: bold;">return</span> actualExtent;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7c03180" class="outline-6">
<h6 id="org7c03180">Creating the swap chain (86)</h6>
<div class="outline-text-6" id="text-org7c03180">
<p>
使用下面方法来创建 swap chain:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createSwapChain</span>()
{
    <span style="color: #ce537a; font-weight: bold;">SwapChainSupportDetails</span> <span style="color: #7590db;">swapChainSupport</span> = querySwapChainSupport(physicalDevice);

    <span style="color: #ce537a; font-weight: bold;">VkSurfaceFormatKHR</span> <span style="color: #7590db;">surfaceFormat</span> = chooseSwapSurfaceFormat(swapChainSupport.formats);
    <span style="color: #ce537a; font-weight: bold;">VkPresentModeKHR</span> <span style="color: #7590db;">presentMode</span> = chooseSwapPresentMode(swapChainSupport.presentModes);
    <span style="color: #ce537a; font-weight: bold;">VkExtent2D</span> <span style="color: #7590db;">extent</span> = chooseSwapExtent(swapChainSupport.capabilities);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; swap chain &#20013; images &#30340;&#25968;&#37327;</span>
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">imageCount</span> = swapChainSupport.capabilities.minImageCount;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;&#25351;&#23450;&#30340;&#25968;&#37327;&#26159;&#21542;&#36229;&#36807;&#20102;&#25903;&#25345;&#30340;&#26368;&#22823;&#25968;&#37327;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (swapChainSupport.capabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount)
    {
        imageCount = swapChainSupport.capabilities.maxImageCount;
    }

    <span style="color: #ce537a; font-weight: bold;">VkSwapchainCreateInfoKHR</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    createInfo.surface = surface;
    createInfo.minImageCount = imageCount;
    createInfo.imageFormat = surfaceFormat.format;
    createInfo.imageColorSpace = surfaceFormat.colorSpace;
    createInfo.imageExtent = extent;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#27599;&#20010;image&#30001;&#22810;&#23569;layer&#32452;&#25104; &#65288;&#24403;&#24320;&#21457;&#31435;&#20307;&#24863;3D&#24212;&#29992;&#26102;&#65292;&#38656;&#35201;&#25351;&#23450;&#22810;&#20010;layer&#65289;</span>
    createInfo.imageArrayLayers = 1;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#25105;&#20204;&#23545; swap chain &#20013;&#30340; image &#25191;&#34892;&#30340;&#25805;&#20316;&#31867;&#22411;</span>
    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">indices</span> = findQueueFamilies(physicalDevice);
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">queueFamilyIndices</span>[] = { indices.graphicsFamily.value(), indices.presentFamily.value() };

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403; swap chain &#20013;&#30340; images &#23646;&#20110;&#22810;&#20010;queue families&#26102;&#65292;&#25351;&#23450;&#22914;&#20309;&#20849;&#20139; images </span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (indices.graphicsFamily != indices.presentFamily) {
        createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21738;&#20123; queue families &#20043;&#38388;&#20250;&#20849;&#20139; images&#30340;&#25152;&#26377;&#26435;</span>
        createInfo.queueFamilyIndexCount = 2;
        createInfo.pQueueFamilyIndices = queueFamilyIndices;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> {
        createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
        createInfo.queueFamilyIndexCount = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        createInfo.pQueueFamilyIndices = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19981;&#20351;&#29992;&#20219;&#20309;&#21464;&#25442; &#21487;&#20197;&#23545; swap chain &#20013;&#30340; image &#25191;&#34892;&#19968;&#20123;&#26059;&#36716;&#12289;&#38236;&#20687;&#31561;&#21464;&#25442;</span>
    createInfo.preTransform = swapChainSupport.capabilities.currentTransform;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26159;&#21542;&#20351;&#29992; alpha channel &#21644;&#20854;&#20182;&#31383;&#21475;&#36827;&#34892;&#28151;&#21512;. &#20320;&#24212;&#35813;&#24635;&#26159;&#31616;&#21333;&#24573;&#30053; alpha channel</span>
    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#23637;&#31034;&#27169;&#24335;</span>
    createInfo.presentMode = presentMode;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_TRUE &#34920;&#31034;&#25105;&#20204;&#19981;&#20851;&#24515;&#34987;&#36974;&#25377;&#30340;&#20687;&#32032;&#39068;&#33394; (&#20363;&#22914;&#65292;&#24403;&#26377;&#20854;&#20182;&#31383;&#21475;&#22312;&#36825;&#20123;&#20687;&#32032;&#20043;&#21069;). &#24320;&#21551;clipping&#21487;&#20197;&#25552;&#39640;&#24615;&#33021;</span>
    createInfo.clipped = VK_TRUE;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37325;&#26032;&#21019;&#24314; swap chain &#26102;&#65292;&#20256;&#20837;&#20043;&#21069;&#30340; swap chain</span>
    createInfo.oldSwapchain = VK_NULL_HANDLE;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateSwapchainKHR(device, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;swapChain) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create swap chain!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462; swap chain &#20013;&#30340;&#25152;&#26377; images</span>
    vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, <span style="color: #a45bad;">nullptr</span>);
    swapChainImages.resize(imageCount);
    vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data());

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35760;&#24405;&#36873;&#25321;&#30340; surface format &#20197;&#21450; image&#30340;&#20687;&#32032;&#23610;&#23544;</span>
    swapChainImageFormat = surfaceFormat.format;
    swapChainExtent = extent;
}
</pre>
</div>

<p>
当 swap chain 中的 images 属于多个 queue families 时，有两种方式来处理 images 的共享：<br />
</p>
<ul class="org-ul">
<li>VK_SHARING_MODE_EXCLUSIVE：  同一时间一个 image 只能由一个 queue family 拥有，并且在另一个 queue family 中使用该 image 之前必须明确转移所有权。此选项可以提供最佳性能。<br /></li>
<li>VK_SHARING_MODE_CONCURRENT： image 可以跨多个 queue family 使用，无需明确的所有权转移。<br /></li>
</ul>
<p>
Concurrent 模式需要你事先指定哪些 queue families 会共享 images 的所有权。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org468b3d0" class="outline-5">
<h5 id="org468b3d0">Image views (92)</h5>
<div class="outline-text-5" id="text-org468b3d0">
<p>
使用如下方法创建 image view:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createImageViews</span>() 
{
    swapChainImageViews.resize(swapChainImages.size());

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImages.size(); i++) 
    {
        <span style="color: #ce537a; font-weight: bold;">VkImageViewCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
        createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        createInfo.image = swapChainImages[i];
        createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
        createInfo.format = swapChainImageFormat;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">components &#36873;&#39033;&#21487;&#20197;&#35753;&#20320;&#35843;&#25972;&#39068;&#33394;&#36890;&#36947;&#65292;&#22914;&#65306;&#23558;&#25152;&#26377;&#36890;&#36947;&#26144;&#23556;&#20026; r &#36890;&#36947;&#65307;&#25110;&#32773;&#23558; r &#36890;&#36947;&#26144;&#23556;&#20026; g &#36890;&#36947;&#65292;&#23558; g &#36890;&#36947;&#26144;&#23556;&#20026; r &#36890;&#36947; </span>
        createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">subresourceRange &#29992;&#20110;&#25551;&#36848; image &#30340;&#29992;&#36884;&#65292;&#20197;&#21450;&#24212;&#35813;&#35775;&#38382; image &#30340;&#21738;&#20010;&#37096;&#20998;</span>
        createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        createInfo.subresourceRange.baseMipLevel = 0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; mipmapping &#32423;&#21035;&#21482;&#26377;&#19968;&#32423; (&#21363; &#19981;&#20351;&#29992;mipmap)</span>
        createInfo.subresourceRange.levelCount = 1;
        createInfo.subresourceRange.baseArrayLayer = 0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; layer &#21482;&#26377;&#19968;&#20010;</span>
        createInfo.subresourceRange.layerCount = 1;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateImageView(device, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create image views!"</span>);
        }
    }
}
</pre>
</div>

<p>
结束时需要手动销毁 imageViews:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">cleanup</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; image view</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">imageView</span> : swapChainImageViews)
    {
        vkDestroyImageView(device, imageView, <span style="color: #a45bad;">nullptr</span>);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; swap chain</span>
    vkDestroySwapchainKHR(device, swapChain, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585;&#36923;&#36753;&#35774;&#22791;</span>
    vkDestroyDevice(device, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (enableValidationLayers)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; debug messenger</span>
        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, <span style="color: #a45bad;">nullptr</span>);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; surface</span>
    vkDestroySurfaceKHR(instance, surface, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; instance</span>
    vkDestroyInstance(instance, <span style="color: #a45bad;">nullptr</span>);

    glfwDestroyWindow(window);

    glfwTerminate();
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9aa8643" class="outline-4">
<h4 id="org9aa8643">Graphics pipeline basics</h4>
<div class="outline-text-4" id="text-org9aa8643">
</div>
<div id="outline-container-org3b59c37" class="outline-5">
<h5 id="org3b59c37">Introduction (95)</h5>
<div class="outline-text-5" id="text-org3b59c37">
<p>
在接下来的几章中，我们将设置一个 graphics pipeline，来绘制我们的第一个三角形。graphics pipeline 是一个操作序列，其以网格的顶点和纹理为输入经过一系列操作序列后得到 render targets 中的像素。下面展示了一个简化的概述：<br />
</p>

<div id="org10ea65a" class="figure">
<p><img src="./Vulkan/graphics-pipeline-simple.jpg" alt="graphics-pipeline-simple.jpg" width="300px" /><br />
</p>
</div>

<p>
输入装配器(Input assembler)从你指定的 buffers 中收集原始顶点数据，还可能使用 index buffer 来重复利用某些的元素从而避免重复顶点数据本身。<br />
</p>

<p>
顶点着色器(vertex shader)会被每个顶点执行，通常会应用一些变换来将顶点位置从模型空间转化到屏幕空间。其会将每个顶点的数据传递给管线的后面部分。<br />
</p>

<p>
细分着色器(tessellation shader)允许你按照某种特定的规则来细分几何元素(三角形，多边形)从而提高 mesh 的质量。这通常用于近距离的砖墙和楼梯等表面，使它们看起来不那么平坦。<br />
</p>

<p>
几何着色器(geometry shader)会被每个图元(如：三角形、线、点)执行，你可以抛弃这些图元，或者输出更多的图元。其和 tessellation shader 类似，但是更加灵活。但是，其消耗性能比较大。<br />
</p>

<p>
光栅化阶段(rasterization stage)会将图元离散化为片段(fragments)。片段是填充在 framebuffer 中的像素元素，顶点着色器输出的属性会被插值作为片段的属性。任何落在屏幕外面的片段都会被丢弃。通常由于深度测试(depth testing)图元后面的其他片段也会被丢弃。<br />
</p>

<p>
片段着色器(fragment shader)会被每个幸存的片段执行，这个阶段会确定将片段写入哪个或哪些 framebuffers，以及写入哪个颜色和深度值。其可以使用从顶点着色器插值得到的数据来计算写入 framebuffers 的颜色和深度。<br />
</p>

<p>
颜色混合(color blending stage)会对不同的片段(这些片段映射到 framebuffer 中相同的像素)进行混合。可以简单地覆盖其他的片段、或者叠加所有片段、又或者按照不透明度进行片段混合。<br />
</p>

<p>
上图中绿色框表示的阶段被称为 fixed-function 阶段。这些阶段只允许你使用参数对它们的操作进行微调，但是它们工作的方式是预先定义好的。橘色框表示的阶段为 programmable 阶段(可编程阶段)。你可以上传你自己的代码给显卡来精确应用你想要的操作。这些 shader 程序会在很多个 GPU 核上同时运行来并行处理很多对象（如：顶点、片段等）<br />
</p>

<p>
老式的 APIs(OpenGL Direct3D)可以修改 pipeline 的任何设置，如 使用 glBlendFunc 修改颜色混合的设置。在 Vulkan 中，graphics pipeline 几乎是完全不可改变的，如果你需要修改 shaders，绑定不同的 framebuffers 或修改混合函数，你需要重新创建一个 pipeline。缺点是你需要创建很多个 pipelines 来，优点是由于事先知道在管线中的所有操作，驱动可以做更好的优化。<br />
</p>

<p>
一些可编程阶段是可选的。例如，如果你只是绘制一个简单的几何体，tessellation 阶段和 geometry 阶段就可以被关闭。又比如，你只是生成 shadow map，则 fragment shader 阶段可以被关闭。<br />
</p>
</div>
</div>
<div id="outline-container-org17e5ffa" class="outline-5">
<h5 id="org17e5ffa">Shader modules (99)</h5>
<div class="outline-text-5" id="text-org17e5ffa">
<p>
和之前的 APIs 不同，在 Vulkan 中，shader 代码必须是指定的字节码格式，而不能是人类能读懂的 GLSL 或 HLSL。这种字节码格式被称为 SPIR-V（Standard Portable Intermediate Representation），其被用于 Vulkan 和 OpenCL。使用字节码的优点是极大减低了 GPU 供应商编译器的复杂度，该编译器将 shader 代码转换为本地代码。使用人类可读的语法时，一些 GPU 供应商对标准的解释相当灵活。 如果你碰巧使用来自这些供应商之一的 GPU 编写着色器，那么你将面临其他供应商的驱动程序因语法错误而拒绝你的代码的风险，或者更糟的是，你的着色器由于编译器错误而以不同方式运行。使用像 SPIR-V 这样简单的字节码格式，有望避免这种情况。但是，这并不意味着我们需要手工编写这种字节码。 Khronos 发布了他们自己的独立于供应商的编译器，其可以将 GLSL 编译为 SPIR-V。该编译器旨在验证您的着色器代码是否完全符合标准，同时会生成一个 SPIR-V 二进制文件，你可以将该文件随程序一起提供。你还可以将此编译器作为库包含到程序种，从而在运行时生成 SPIR-V。虽然我们可以通过 glslangValidator.exe 直接使用这个编译器，但我们将使用谷歌的 glslc.exe 来代替。 glslc 的优点是它使用了和 GCC 和 Clang 等知名编译器相同的参数格式，并包含一些额外的功能，如 includes。它们都已包含在 Vulkan SDK 中了，因此无需额外下载任何内容。<br />
</p>
</div>
<div id="outline-container-org95ec40c" class="outline-6">
<h6 id="org95ec40c">Vertex shader (100)</h6>
<div class="outline-text-6" id="text-org95ec40c">
<p>
顶点着色器处理每一个进来的顶点，其以顶点的属性（如：世界位置，颜色，法线以及贴图坐标）为输入，裁剪坐标系中的最终位置以及需要传递给 fragment shader 的属性为输出（如：颜色和贴图坐标）。这些值随后会被光栅化器在片段上进行插值，从而得到平滑的过渡。<br />
</p>

<p>
裁剪坐标是从顶点着色器得来的一个 4 维向量，通过执行透视除法，将裁剪坐标转换为标准设备坐标。标准设备坐标是齐次坐标，其将 framebuffer 映射为一个[-1, 1]到[1,-1]的坐标系统，如下所示：<br />
</p>


<div id="org4375680" class="figure">
<p><img src="./Vulkan/framebuffer-device-coordinate-system.jpg" alt="framebuffer-device-coordinate-system.jpg" width="500px" /><br />
</p>
</div>

<p>
Tips: 和 OpenGL 不同，Vulkan 的 normalized device coordinates 的 Y 轴指向下方，并且 Z 坐标的范围变为了[0, 1]。如下图所示：<br />
</p>

<div id="org8589559" class="figure">
<p><img src="./Vulkan/d3d-opengl-vulkan-coordinate-system.jpg" alt="d3d-opengl-vulkan-coordinate-system.jpg" width="500px" /><br />
</p>
</div>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/48036410/why-doesnt-vulkan-use-the-standard-cartesian-coordinate-system">https://stackoverflow.com/questions/48036410/why-doesnt-vulkan-use-the-standard-cartesian-coordinate-system</a><br /></li>
</ul>

<p>
创建一个 shader.vert 文件：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">#version 450

layout(location = 0) <span style="color: #4f97d7; font-weight: bold;">out</span> vec3 fragColor;

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9a51240" class="outline-6">
<h6 id="org9a51240">Fragment shader (102)</h6>
<div class="outline-text-6" id="text-org9a51240">
<p>
创建一个 shader.frag 文件：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">#version 450

layout(location = 0) <span style="color: #4f97d7; font-weight: bold;">in</span> vec3 fragColor;

layout(location = 0) <span style="color: #4f97d7; font-weight: bold;">out</span> vec4 outColor;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    outColor = vec4(fragColor, 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgda58211" class="outline-6">
<h6 id="orgda58211">Compiling the shaders (104)</h6>
<div class="outline-text-6" id="text-orgda58211">
<p>
创建一个 compile.bat 的编译脚本：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #2d9574;">"D:\Documents\MySDK\VulkanSDK\1.2.189.2\Bin32\glslc.exe"</span> shader.vert -o shader_vert.spv
<span style="color: #2d9574;">"D:\Documents\MySDK\VulkanSDK\1.2.189.2\Bin32\glslc.exe"</span> shader.frag -o shader_frag.spv
pause
</pre>
</div>
</div>
</div>
<div id="outline-container-org31ded9e" class="outline-6">
<h6 id="org31ded9e">Loading a shader (105)</h6>
<div class="outline-text-6" id="text-org31ded9e">
<p>
使用如下方法加载 shader 代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">char</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">readFile</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&amp; <span style="color: #7590db;">filename</span>) 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::ios::ate &#20174;&#25991;&#20214;&#26368;&#21518;&#24320;&#22987;&#35835;&#65292;&#26041;&#20415;&#33719;&#21462;&#25991;&#20214;&#22823;&#23567;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::ios::binary &#20197;&#20108;&#36827;&#21046;&#26032;&#24335;&#35835;&#21462;&#25991;&#20214;&#65292;&#36991;&#20813;&#25991;&#26412;&#36716;&#25442;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">ifstream</span> <span style="color: #7590db;">file</span>(filename, <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">ios</span>::ate | <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">ios</span>::binary);

    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>file.is_open()) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to open file!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#25991;&#20214;&#22823;&#23567;</span>
    <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">fileSize</span> = (<span style="color: #ce537a; font-weight: bold;">size_t</span>) file.tellg();
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">char</span>&gt; <span style="color: #7590db;">buffer</span>(fileSize);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22238;&#21040;&#25991;&#20214;&#36215;&#22987;&#20301;&#32622;&#65292;&#20877;&#24320;&#22987;&#35835;&#21462;&#25991;&#20214;</span>
    file.seekg(0);
    file.read(buffer.data(), fileSize);
    file.close();
    <span style="color: #4f97d7; font-weight: bold;">return</span> buffer;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org03dcb05" class="outline-6">
<h6 id="org03dcb05">Creating shader modules (107)</h6>
<div class="outline-text-6" id="text-org03dcb05">
<p>
Shader modules 只是对 shader bytecode 进行了简单封装。对 SPIR-V 字节码进行编译和链接(得到用于 GPU 执行的机器码)是在创建 graphics pipeline 时执行的。创建完 graphics pipeline 后就可以销毁 Shader modules 了。<br />
使用如下方法创建 shader modules:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #bc6ec5; font-weight: bold;">createShaderModule</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">char</span>&gt;&amp; <span style="color: #7590db;">code</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkShaderModuleCreateInfo</span> <span style="color: #7590db;">createInfo</span>{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38656;&#35201;&#20351;&#29992; reinterpret_cast &#23558; char* &#36716;&#21270;&#20026; uint32_t*</span>
    createInfo.pCode = <span style="color: #4f97d7; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">uint32_t</span>*&gt;(code.data());

    <span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #7590db;">shaderModule</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateShaderModule(device, &amp;createInfo, <span style="color: #a45bad;">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create shader module!"</span>);
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> shaderModule;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org30b1389" class="outline-6">
<h6 id="org30b1389">Shader stage creation (108)</h6>
<div class="outline-text-6" id="text-org30b1389">
<p>
使用如下方法创建 shader stage:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createGraphicsPipeline</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">vertShaderCode</span> = readFile(<span style="color: #2d9574;">"shader_vert.spv"</span>);
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"vert shader code size : "</span> &lt;&lt; vertShaderCode.size() &lt;&lt; <span style="color: #2d9574;">" Byte"</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fragShaderCode</span> = readFile(<span style="color: #2d9574;">"shader_frag.spv"</span>);
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"frag shader code size : "</span> &lt;&lt; fragShaderCode.size() &lt;&lt; <span style="color: #2d9574;">" Byte"</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;

    <span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #7590db;">vertShaderModule</span> = createShaderModule(vertShaderCode);
    <span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #7590db;">fragShaderModule</span> = createShaderModule(fragShaderCode);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; vertex shader stage</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">vertShaderStageInfo</span>{};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = <span style="color: #2d9574;">"main"</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; fragment shader stage</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">fragShaderStageInfo</span>{};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = <span style="color: #2d9574;">"main"</span>;

    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">shaderStages</span>[] = {vertShaderStageInfo, fragShaderStageInfo};

    vkDestroyShaderModule(device, fragShaderModule, <span style="color: #a45bad;">nullptr</span>);
    vkDestroyShaderModule(device, vertShaderModule, <span style="color: #a45bad;">nullptr</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdbe8575" class="outline-5">
<h5 id="orgdbe8575">Fixed functions (110)</h5>
<div class="outline-text-5" id="text-orgdbe8575">
</div>
<div id="outline-container-orgabbc5f3" class="outline-6">
<h6 id="orgabbc5f3">Vertex input (110)</h6>
<div class="outline-text-6" id="text-orgabbc5f3">
<p>
使用 VkPipelineVertexInputStateCreateInfo 来描述顶点数据的格式，粗略来说该数据结构描述了两类信息：<br />
</p>
<ul class="org-ul">
<li>Bindings : 数据之间的间隔，以及数据是基于顶点还是基于实例<br /></li>
<li>Attribute descriptions : 传递给 vertex shader 的属性的类型，从哪个 binding 加载这些属性，以及需要做多少偏移。<br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; vertex input</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineVertexInputStateCreateInfo</span> <span style="color: #7590db;">vertexInputInfo</span>{};
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
vertexInputInfo.vertexBindingDescriptionCount = 0;
vertexInputInfo.pVertexBindingDescriptions = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
vertexInputInfo.vertexAttributeDescriptionCount = 0;
vertexInputInfo.pVertexAttributeDescriptions = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0002027" class="outline-6">
<h6 id="org0002027">Input assembly (111)</h6>
<div class="outline-text-6" id="text-org0002027">
<p>
使用 VkPipelineInputAssemblyStateCreateInfo 来描述输入装配，主要描述两件事情：1. 利用顶点绘制什么类型的几何元素（topology），2.是否开启图元重启。<br />
topology 可以有如下选项：<br />
</p>
<ul class="org-ul">
<li>VK_PRIMITIVE_TOPOLOGY_POINT_LIST：绘制的几何元素为点，每个顶点即为一个点<br /></li>
<li>VK_PRIMITIVE_TOPOLOGY_LINE_LIST： 绘制的几何元素为线，每 2 个顶点构成一条线，不重用顶点<br /></li>
<li>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP：绘制的几何元素为线，每条线的末端顶点会被当作下一条线的起始顶点<br /></li>
<li>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST： 绘制的几何元素为三角形，每 3 个顶点组成的三角形，不重复顶点<br /></li>
<li>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP：绘制的几何元素为三角形，每个三角形的第二个和第三个顶点作为下一个三角形的前两个顶点<br /></li>
</ul>

<p>
通常情况下，从顶点缓冲区中加载顶点，顶点的索引即为顶点在缓冲区中的顺序，也可以使用 element buffer 来指定顶点的索引。这样就可以复用顶点。<br />
是否开启图元重启只对 _STRIP 类型的 topology 有影响，当开启图元重启时，可以使用特殊的索引(index) 0xFFFF 或 0xFFFFFFFF 来打断 lines strip 或 triangles strip。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; input assembly</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineInputAssemblyStateCreateInfo</span> <span style="color: #7590db;">inputAssembly</span>{};
inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
inputAssembly.primitiveRestartEnable = VK_FALSE;
</pre>
</div>
</div>
</div>
<div id="outline-container-org62ade11" class="outline-6">
<h6 id="org62ade11">Viewports and scissors (111)</h6>
<div class="outline-text-6" id="text-org62ade11">
<p>
viewport 定义了从 image 到 framebuffer 的变换。scissor 矩形定义了哪个区域的像素会被存储，scissor 矩形外的像素都会被光栅化器丢弃。下图是对 viewport 和 scissor rectangle 的可视化描述：<br />
</p>


<div id="org1172b86" class="figure">
<p><img src="./Vulkan/viewports_scissors.png" alt="viewports_scissors.png" width="500px" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; viewports &#21644; scissors</span>
<span style="color: #ce537a; font-weight: bold;">VkViewport</span> <span style="color: #7590db;">viewport</span>{};
viewport.x = 0.0f;
viewport.y = 0.0f;
viewport.width = (<span style="color: #ce537a; font-weight: bold;">float</span>) swapChainExtent.width;
viewport.height = (<span style="color: #ce537a; font-weight: bold;">float</span>) swapChainExtent.height;
viewport.minDepth = 0.0f;
viewport.maxDepth = 1.0f;
<span style="color: #ce537a; font-weight: bold;">VkRect2D</span> <span style="color: #7590db;">scissor</span>{};
scissor.offset = {0, 0};
scissor.extent = swapChainExtent;
<span style="color: #ce537a; font-weight: bold;">VkPipelineViewportStateCreateInfo</span> <span style="color: #7590db;">viewportState</span>{};
viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewportState.viewportCount = 1;
viewportState.pViewports = &amp;viewport;
viewportState.scissorCount = 1;
viewportState.pScissors = &amp;scissor;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgec6ed6d" class="outline-6">
<h6 id="orgec6ed6d">Rasterizer (113)</h6>
<div class="outline-text-6" id="text-orgec6ed6d">
<p>
使用 VkPipelineRasterizationStateCreateInfo 来配置光栅化阶段。<br />
</p>

<p>
depthClampEnable 成员为 VK_TRUE 时，若片段在近平面和远平面之间区域的外面，则对将片段截取到近平面或远平面；否则丢弃这些片段。渲染 shadowmaps 开启该功能会很有用，使用时需要开启一个 GPU 特性。<br />
</p>

<p>
rasterizerDiscardEnable 成员为 VK_TRUE 时，几何元素不可以通过光栅化阶段。这样就不会有任何输出到达 framebuffer。<br />
</p>

<p>
polygonMode 成员决定了为几何元素如何生成片段，其可以有三个选项：<br />
</p>
<ul class="org-ul">
<li>VK_POLYGON_MODE_FILL: 使用片段填充多边形区域<br /></li>
<li>VK_POLYGON_MODE_LINE: 只填充多边形的边<br /></li>
<li>VK_POLYGON_MODE_POINT: 只绘制多边形的顶点<br /></li>
</ul>
<p>
除了 VK_POLYGON_MODE_FILL 选项外，使用另外两个选项都需要开启一个 GPU 特性。<br />
</p>

<p>
lineWidth 成员根据片段的数量来描述线的粗细。支持的最大宽度取决于硬件，任何比 1.0f 粗的线都需要开启 wideLine GPU 特性。<br />
</p>

<p>
cullMode 决定了剔除表面的类型。你可以关闭剔除，也可以剔除正面，或者剔除背面，或者剔除正面和背面。<br />
</p>

<p>
frontFace 指定了如何确定是正面还是背面。<br />
</p>

<p>
光栅化器可以调整深度值，其可以在深度值基础上加一个常数值或者依据片段的斜率偏移深度值。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Rasterizer</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineRasterizationStateCreateInfo</span> <span style="color: #7590db;">rasterizer</span>{};
rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
rasterizer.depthClampEnable = VK_FALSE;
rasterizer.rasterizerDiscardEnable = VK_FALSE;
rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
rasterizer.lineWidth = 1.0f;
rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
rasterizer.depthBiasEnable = VK_FALSE;
rasterizer.depthBiasConstantFactor = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
rasterizer.depthBiasClamp = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
rasterizer.depthBiasSlopeFactor = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c1d0ea" class="outline-6">
<h6 id="org0c1d0ea">Multisampling (114)</h6>
<div class="outline-text-6" id="text-org0c1d0ea">
<p>
使用 VkPipelineMultisampleStateCreateInfo 来配置多重采样相关的设置。多重采样是一种抗锯齿的方式，其不需要执行片段着色器多次，因此，其比渲染一个高分辨的结果再缩放到低分辨率要高效很多。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; multisampling</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineMultisampleStateCreateInfo</span> <span style="color: #7590db;">multisampling</span>{};
multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
multisampling.sampleShadingEnable = VK_FALSE;
multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
multisampling.minSampleShading = 1.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
multisampling.pSampleMask = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
multisampling.alphaToCoverageEnable = VK_FALSE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
multisampling.alphaToOneEnable = VK_FALSE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org38e121d" class="outline-6">
<h6 id="org38e121d">Depth and stencil testing (114)</h6>
<div class="outline-text-6" id="text-org38e121d">
<p>
如果你使用了 depth 或 stencil buffer，你还需要配置深度和模板测试。使用 VkPipelineDepthStencilStateCreateInfo 来配置深度和模板测试。<br />
</p>
</div>
</div>
<div id="outline-container-org7e849de" class="outline-6">
<h6 id="org7e849de">Color blending (115)</h6>
<div class="outline-text-6" id="text-org7e849de">
<p>
片段着色器返回一个颜色后，需要将该颜色和 framebuffer 中的颜色组合起来。可以有两种方式来执行组合：<br />
</p>
<ul class="org-ul">
<li>混合旧的颜色和新的颜色得到最终颜色<br /></li>
<li>使用一个位操作来组合旧颜色和新颜色<br /></li>
</ul>
<p>
使用 VkPipelineColorBlendAttachmentState 来配置 framebuffer 相关的设置，使用 VkPipelineColorBlendStateCreateInfo 来配置 color blending 全局相关的设置：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Color Blending</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkPipelineColorBlendAttachmentState &#21644;&#38468;&#21152;&#30340;framebuffer &#30456;&#20851;&#30340; color blending &#35774;&#32622;</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineColorBlendAttachmentState</span> <span style="color: #7590db;">colorBlendAttachment</span>{};
colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
colorBlendAttachment.blendEnable = VK_FALSE;
colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkPipelineColorBlendStateCreateInfo &#20840;&#23616;&#30340; color blending &#35774;&#32622;</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineColorBlendStateCreateInfo</span> <span style="color: #7590db;">colorBlending</span>{};
colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
colorBlending.logicOpEnable = VK_FALSE;
colorBlending.logicOp = VK_LOGIC_OP_COPY; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlending.attachmentCount = 1;
colorBlending.pAttachments = &amp;colorBlendAttachment;
colorBlending.blendConstants[0] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlending.blendConstants[1] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlending.blendConstants[2] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
colorBlending.blendConstants[3] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>

<p>
Tips：<br />
如果你想按照第二种方式(位操作的方式)来组合新旧颜色，那么需要设置 logicOpEnable 为 VK_TRUE，此时会自动禁止第一种方式，如同你将每个 VkPipelineColorBlendAttachmentState.blendEnable 设置为 VK_FALSE。<br />
colorWriteMask 对两种方式都生效。<br />
</p>
</div>
</div>
<div id="outline-container-org79e5456" class="outline-6">
<h6 id="org79e5456">Dynamic state (117)</h6>
<div class="outline-text-6" id="text-org79e5456">
<p>
只有有限数量的状态可以在不重新创建 pipeline 的情况下被修改，如 viewport 的尺寸，线的宽度以及混合常数(blend constants)。通过使用 VkPipelineDynamicStateCreateInfo 来修改相关设置：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; &#21487;&#20197;&#21160;&#24577;&#20462;&#25913;&#30340;&#35774;&#32622;</span>
<span style="color: #ce537a; font-weight: bold;">VkDynamicState</span> <span style="color: #7590db;">dynamicStates</span>[] = {
    VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_LINE_WIDTH
};

<span style="color: #ce537a; font-weight: bold;">VkPipelineDynamicStateCreateInfo</span> <span style="color: #7590db;">dynamicState</span>{};
dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
dynamicState.dynamicStateCount = 2;
dynamicState.pDynamicStates = dynamicStates;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc5a9cef" class="outline-6">
<h6 id="orgc5a9cef">Pipeline layout (117)</h6>
<div class="outline-text-6" id="text-orgc5a9cef">
<p>
你可以在 shaders 中使用 uniform 值，它们是全局的变量，可以在绘制期间修改这些 uniform 值，从而改变这些 shaders 的行为，而不需要重新创建这些 shaders。通常会使用这些 uniform 值来传递变换矩阵给 vertex shader 等等。<br />
在创建 pipeline 时通过创建 VkPipelineLayout 对象来指定这些 uniform 值。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Pipeline Layout</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineLayoutCreateInfo</span> <span style="color: #7590db;">pipelineLayoutInfo</span>{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
pipelineLayoutInfo.pSetLayouts = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
pipelineLayoutInfo.pushConstantRangeCount = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
pipelineLayoutInfo.pPushConstantRanges = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

<span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, <span style="color: #a45bad;">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS)
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create pipeline layout!"</span>);
}
</pre>
</div>

<p>
结束时需要手动销毁 pipeline layout:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">vkDestroyPipelineLayout(device, pipelineLayout, <span style="color: #a45bad;">nullptr</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2ed7f21" class="outline-5">
<h5 id="org2ed7f21">Render passes (119)</h5>
<div class="outline-text-5" id="text-org2ed7f21">
<p>
创建 pipeline 时，我们还需要告诉 Vulkan，我们在渲染时使用的 framebuffer attachments，需要使用多少个 color buffers 和 depth buffers，每个 buffer 使用多少个样本，buffer 中的内容被如何处理。所有这些信息都被封装在 render pass 对象中。<br />
</p>
</div>
<div id="outline-container-org9e52f2d" class="outline-6">
<h6 id="org9e52f2d">Attachment description (119)</h6>
<div class="outline-text-6" id="text-org9e52f2d">
<p>
在本章的教程中，我们只使用一个 color buffer attachments。使用 VkAttachmentDescription 来设置 attachments 相关设置：<br />
VkAttachmentDescription.format              设置 attachments buffer 的格式，需要和 swap chain 中 images 的格式一致<br />
VkAttachmentDescription.samples             设置 buffer 的样本数量，开启多重采样时，设置样本数量<br />
VkAttachmentDescription.loadOp              设置渲染前后对 attachments 中的数据做何处理。<br />
VkAttachmentDescription.storeOp<br />
VkAttachmentDescription.stencilLoadOp<br />
VkAttachmentDescription.stencilStoreOp<br />
</p>

<p>
loadOp 和 storeOp 作用于 color buffer 和 depth buffer<br />
stencilLoadOp 和 stencilStoreOp 作用于 stencil buffer<br />
</p>

<p>
loadOp 有下列选项：<br />
</p>
<ul class="org-ul">
<li>VK_ATTACHMENT_LOAD_OP_LOAD：保留 attachment 中的现有内容<br /></li>
<li>VK_ATTACHMENT_LOAD_OP_CLEAR：在开始时将 attachment 中的内容清除为常量<br /></li>
<li>VK_ATTACHMENT_LOAD_OP_DONT_CARE：attachment 中的现有内容未定义，我们不在乎他们<br /></li>
</ul>
<p>
storeOp 有下列选项：<br />
</p>
<ul class="org-ul">
<li>VK_ATTACHMENT_STORE_OP_STORE：渲染后的内容会保存在内存中，以后可以读取<br /></li>
<li>VK_ATTACHMENT_STORE_OP_DONT_CARE：渲染操作后，帧缓冲区中的内容是未定义的<br /></li>
</ul>

<p>
在 Vulkan 中 Textures 和 framebuffers 都是使用 VkImage 对象来表示的，可以依据你对 image 的操作来修改内存中像素的布局。最常用的布局有以下几种：<br />
</p>
<ul class="org-ul">
<li>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL：用作 color attachment 的图像<br /></li>
<li>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR：要在 swap chain 中呈现的图像<br /></li>
<li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL：用作内存 copy 操作的目标图像<br /></li>
</ul>

<p>
VkAttachmentDescription.initialLayout 指定 render pass 开始时，image 的 layout<br />
VkAttachmentDescription.finalLayout   指定 render pass 结束时，image 的 layout 自动转换为 finalLayout<br />
</p>

<p>
将 VkAttachmentDescription.initialLayout 指定为 VK_IMAGE_LAYOUT_UNDEFINED 表示我们不关心 image 之前的布局是什么。<br />
</p>
</div>
</div>
<div id="outline-container-org2faf36a" class="outline-6">
<h6 id="org2faf36a">Subpasses and attachment references (121)</h6>
<div class="outline-text-6" id="text-org2faf36a">
<p>
一个 render pass 可以由多个 subpasses 组成。Subpasses 是渲染操作子序列，这些操作依赖于之前 passes 中 framebuffers 的内容，例如：一个后期效果序列，每一个后期效果都作用到前一个之上。如果将这些渲染操作组合在一个 render pass 中，Vulkan 可以对操作进行重排，并且能够节省内存带宽，从而提高性能。每一个 subpass 都会引用一个或多个 attachments，使用 VkAttachmentReference 来表示 attachment 的引用。<br />
VkAttachmentReference.attachment  指定引用的 attachment 的索引<br />
VkAttachmentReference.layout      指定 subpass 在引用该 attachment 期间所使用的布局<br />
</p>

<p>
使用 VkSubpassDescription 来设置 subpass，其有如下成员：<br />
</p>
<ul class="org-ul">
<li>pipelineBindPoint        指定 subpass 为 graphics subpass。未来 Vulkan 可能也会支持 compute subpass。<br /></li>
<li>colorAttachmentCount     指定引用的 color attachment 的数量<br /></li>
<li>pColorAttachments        指定引用的 color attachment<br /></li>
<li>pInputAttachments        从 shader 读取的 Attachments<br /></li>
<li>pResolveAttachments:     对 color attachments 进行多重采样时使用的 Attachments<br /></li>
<li>pDepthStencilAttachment  存储 depth 和 stencil 数据的 Attachment<br /></li>
<li>pPreserveAttachments     在当前 subpass 没有使用，但是需要保留其中数据的 Attachments<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd7d8f3d" class="outline-6">
<h6 id="orgd7d8f3d">Render pass (122)</h6>
<div class="outline-text-6" id="text-orgd7d8f3d">
<p>
使用如下方法创建 render pass:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createRenderPass</span>() 
{
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">colorAttachment</span>{};
    colorAttachment.format = swapChainImageFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">colorAttachmentRef</span>{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    <span style="color: #ce537a; font-weight: bold;">VkSubpassDescription</span> <span style="color: #7590db;">subpass</span>{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &amp;colorAttachmentRef;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35753; render pass &#31561;&#24453; VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>
    <span style="color: #ce537a; font-weight: bold;">VkSubpassDependency</span> <span style="color: #7590db;">dependency</span>{};
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
    dependency.dstSubpass = 0;
    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dependency.srcAccessMask = 0;
    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Render Pass</span>
    <span style="color: #ce537a; font-weight: bold;">VkRenderPassCreateInfo</span> <span style="color: #7590db;">renderPassInfo</span>{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = 1;
    renderPassInfo.pAttachments = &amp;colorAttachment;
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &amp;subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies = &amp;dependency;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateRenderPass(device, &amp;renderPassInfo, <span style="color: #a45bad;">nullptr</span>, &amp;renderPass) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create render pass!"</span>);
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org95189f1" class="outline-5">
<h5 id="org95189f1">Conclusion: Create Graphics Pipeline</h5>
<div class="outline-text-5" id="text-org95189f1">
<p>
使用如下方法来创建 Graphics pipeline:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createGraphicsPipeline</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">vertShaderCode</span> = readFile(<span style="color: #2d9574;">"shader_vert.spv"</span>);
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"vert shader code size : "</span> &lt;&lt; vertShaderCode.size() &lt;&lt; <span style="color: #2d9574;">" Byte"</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fragShaderCode</span> = readFile(<span style="color: #2d9574;">"shader_frag.spv"</span>);
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"frag shader code size : "</span> &lt;&lt; fragShaderCode.size() &lt;&lt; <span style="color: #2d9574;">" Byte"</span> &lt;&lt; <span style="color: #a45bad;">std</span>::endl;

    <span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #7590db;">vertShaderModule</span> = createShaderModule(vertShaderCode);
    <span style="color: #ce537a; font-weight: bold;">VkShaderModule</span> <span style="color: #7590db;">fragShaderModule</span> = createShaderModule(fragShaderCode);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; vertex shader stage</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">vertShaderStageInfo</span>{};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = <span style="color: #2d9574;">"main"</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; fragment shader stage</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">fragShaderStageInfo</span>{};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = <span style="color: #2d9574;">"main"</span>;

    <span style="color: #ce537a; font-weight: bold;">VkPipelineShaderStageCreateInfo</span> <span style="color: #7590db;">shaderStages</span>[] = {vertShaderStageInfo, fragShaderStageInfo};

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; vertex input</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineVertexInputStateCreateInfo</span> <span style="color: #7590db;">vertexInputInfo</span>{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexBindingDescriptionCount = 0;
    vertexInputInfo.pVertexBindingDescriptions = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    vertexInputInfo.vertexAttributeDescriptionCount = 0;
    vertexInputInfo.pVertexAttributeDescriptions = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; input assembly</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineInputAssemblyStateCreateInfo</span> <span style="color: #7590db;">inputAssembly</span>{};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; viewports &#21644; scissors</span>
    <span style="color: #ce537a; font-weight: bold;">VkViewport</span> <span style="color: #7590db;">viewport</span>{};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width = (<span style="color: #ce537a; font-weight: bold;">float</span>) swapChainExtent.width;
    viewport.height = (<span style="color: #ce537a; font-weight: bold;">float</span>) swapChainExtent.height;
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;
    <span style="color: #ce537a; font-weight: bold;">VkRect2D</span> <span style="color: #7590db;">scissor</span>{};
    scissor.offset = {0, 0};
    scissor.extent = swapChainExtent;
    <span style="color: #ce537a; font-weight: bold;">VkPipelineViewportStateCreateInfo</span> <span style="color: #7590db;">viewportState</span>{};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = &amp;viewport;
    viewportState.scissorCount = 1;
    viewportState.pScissors = &amp;scissor;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Rasterizer</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineRasterizationStateCreateInfo</span> <span style="color: #7590db;">rasterizer</span>{};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
    rasterizer.depthBiasEnable = VK_FALSE;
    rasterizer.depthBiasConstantFactor = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    rasterizer.depthBiasClamp = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    rasterizer.depthBiasSlopeFactor = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; multisampling</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineMultisampleStateCreateInfo</span> <span style="color: #7590db;">multisampling</span>{};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    multisampling.minSampleShading = 1.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    multisampling.pSampleMask = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    multisampling.alphaToCoverageEnable = VK_FALSE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    multisampling.alphaToOneEnable = VK_FALSE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Depth and stencil testing</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineDepthStencilStateCreateInfo</span> <span style="color: #7590db;">depthStencil</span>{};

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Color Blending</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkPipelineColorBlendAttachmentState &#21644;&#38468;&#21152;&#30340;framebuffer &#30456;&#20851;&#30340; color blending &#35774;&#32622;</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineColorBlendAttachmentState</span> <span style="color: #7590db;">colorBlendAttachment</span>{};
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.blendEnable = VK_FALSE;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkPipelineColorBlendStateCreateInfo &#20840;&#23616;&#30340; color blending &#35774;&#32622;</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineColorBlendStateCreateInfo</span> <span style="color: #7590db;">colorBlending</span>{};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &amp;colorBlendAttachment;
    colorBlending.blendConstants[0] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlending.blendConstants[1] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlending.blendConstants[2] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    colorBlending.blendConstants[3] = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; &#21487;&#20197;&#21160;&#24577;&#20462;&#25913;&#30340;&#35774;&#32622;</span>
    <span style="color: #ce537a; font-weight: bold;">VkDynamicState</span> <span style="color: #7590db;">dynamicStates</span>[] = {
        VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_LINE_WIDTH
    };

    <span style="color: #ce537a; font-weight: bold;">VkPipelineDynamicStateCreateInfo</span> <span style="color: #7590db;">dynamicState</span>{};
    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicState.dynamicStateCount = 2;
    dynamicState.pDynamicStates = dynamicStates;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Pipeline Layout</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineLayoutCreateInfo</span> <span style="color: #7590db;">pipelineLayoutInfo</span>{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    pipelineLayoutInfo.pSetLayouts = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    pipelineLayoutInfo.pushConstantRangeCount = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    pipelineLayoutInfo.pPushConstantRanges = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, <span style="color: #a45bad;">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create pipeline layout!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; graphics pipeline</span>
    <span style="color: #ce537a; font-weight: bold;">VkGraphicsPipelineCreateInfo</span> <span style="color: #7590db;">pipelineInfo</span>{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;

    pipelineInfo.pVertexInputState = &amp;vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &amp;inputAssembly;
    pipelineInfo.pViewportState = &amp;viewportState;
    pipelineInfo.pRasterizationState = &amp;rasterizer;
    pipelineInfo.pMultisampleState = &amp;multisampling;
    pipelineInfo.pDepthStencilState = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    pipelineInfo.pColorBlendState = &amp;colorBlending;
    pipelineInfo.pDynamicState = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    pipelineInfo.layout = pipelineLayout;
    pipelineInfo.renderPass = renderPass;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; subpass &#30340;&#32034;&#24341;&#21495;</span>
    pipelineInfo.subpass = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26032;&#21019;&#24314;&#30340;graphics pipeline &#28304;&#33258;&#21738;&#20010;&#24050;&#23384;&#22312;&#30340; pipeline </span>
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    pipelineInfo.basePipelineIndex = -1; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Graphics Pipeline</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, <span style="color: #a45bad;">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create graphics pipeline!"</span>);
    }

    vkDestroyShaderModule(device, fragShaderModule, <span style="color: #a45bad;">nullptr</span>);
    vkDestroyShaderModule(device, vertShaderModule, <span style="color: #a45bad;">nullptr</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbd7017e" class="outline-4">
<h4 id="orgbd7017e">Drawing</h4>
<div class="outline-text-4" id="text-orgbd7017e">
</div>
<div id="outline-container-orgb6ca066" class="outline-5">
<h5 id="orgb6ca066">Framebuffers (127)</h5>
<div class="outline-text-5" id="text-orgb6ca066">
<p>
一个 framebuffer 对象会引用所有 attachments 对应的 VkImageView 对象(在本章的教程中我们只是用了一个 color attachment)。但是，我们为 attachment 所使用的 image 取决于 swap chain 为我们返回哪个 image。这意味着我们需要为 swap chain 中的每个 image 创建一个 framebuffer，并且在绘制时使用的 framebuffer 要和从 swap chain 获得的 image 相对应。<br />
</p>

<p>
使用下面方法来创建 framebuffers：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createFramebuffers</span>()
{
    swapChainFramebuffers.resize(swapChainImageViews.size());
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImageViews.size(); i++) 
    {
        <span style="color: #ce537a; font-weight: bold;">VkImageView</span> <span style="color: #7590db;">attachments</span>[] = {
            swapChainImageViews[i]
        };

        <span style="color: #ce537a; font-weight: bold;">VkFramebufferCreateInfo</span> <span style="color: #7590db;">framebufferInfo</span>{};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = renderPass;
        framebufferInfo.attachmentCount = 1;
        framebufferInfo.pAttachments = attachments;
        framebufferInfo.width = swapChainExtent.width;
        framebufferInfo.height = swapChainExtent.height;
        framebufferInfo.layers = 1;

        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateFramebuffer(device, &amp;framebufferInfo, <span style="color: #a45bad;">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create framebuffer!"</span>);
        }
    }
}
</pre>
</div>
<p>
结束时需要手动销毁 framebuffers：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">cleanup</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">framebuffer</span> : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, <span style="color: #a45bad;">nullptr</span>);
    }
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org55a855f" class="outline-5">
<h5 id="org55a855f">Command buffers (130)</h5>
<div class="outline-text-5" id="text-org55a855f">
</div>
<div id="outline-container-orgb9f1b7f" class="outline-6">
<h6 id="orgb9f1b7f">Command pools (130)</h6>
<div class="outline-text-6" id="text-orgb9f1b7f">
<p>
创建 command buffers 之前需要先创建 command pool。command pools 管理用于存储 buffers 的内存，command buffers 就是从 command pools 中分配的。使用下面方法来创建 command pool：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createCommandPool</span>()
{
    <span style="color: #ce537a; font-weight: bold;">QueueFamilyIndices</span> <span style="color: #7590db;">queueFamilyIndices</span> = findQueueFamilies(physicalDevice);

    <span style="color: #ce537a; font-weight: bold;">VkCommandPoolCreateInfo</span> <span style="color: #7590db;">poolInfo</span>{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();
    poolInfo.flags = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateCommandPool(device, &amp;poolInfo, <span style="color: #a45bad;">nullptr</span>, &amp;commandPool) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create command pool!"</span>);
    }
}
</pre>
</div>
<p>
将 command buffers 提交到 device queues 后，来执行它们。每个 command pool 只能分配对应于一种 queue 的 command buffers。在本章的教程中，我们需要为绘制来记录命令，因此创建 command pool 时，我们选择 graphics queue family。<br />
</p>

<p>
VkCommandPoolCreateInfo.flags 有两个可选项：<br />
</p>
<ul class="org-ul">
<li>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT：表示使用最新的命令重新记录 command buffers （该选项可能会改变内存分配行为）<br /></li>
<li>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT：表示允许单独重新记录 command buffers，如果没有这个标志，所有 command buffers 都必须一起重置<br /></li>
</ul>
<p>
在本章的教程中我们在开始的时候记录 command buffers，之后在 main 循环中多次执行这些 command buffers，因此我们不需要使用这两种标记。<br />
</p>

<p>
结束时需要手动销毁 command pool :<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">cleanup</span>()
{
    vkDestroyCommandPool(device, commandPool, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf4e1f22" class="outline-6">
<h6 id="orgf4e1f22">Command buffer allocation (132)</h6>
<div class="outline-text-6" id="text-orgf4e1f22">
<p>
绘制命令中有一个命令涉及到绑定正确的 VkFramebuffer, 因此我们需要为每个 swap chain 中的 image 创建一个 command buffer。使用下面方法来创建 command buffers:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createCommandBuffers</span>()
{
    commandBuffers.resize(swapChainFramebuffers.size());
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = (<span style="color: #ce537a; font-weight: bold;">uint32_t</span>)commandBuffers.size();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; CommandBuffers</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate command buffers!"</span>);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
<p>
VkCommandBufferAllocateInfo.level 参数可以有如下两个选项：<br />
</p>
<ul class="org-ul">
<li>VK_COMMAND_BUFFER_LEVEL_PRIMARY：可以提交到 queue 来执行，但不能从其他 command buffers 调用。<br /></li>
<li>VK_COMMAND_BUFFER_LEVEL_SECONDARY：不能直接提交到 queue，但可以从主 command buffers 调用。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org039bf64" class="outline-6">
<h6 id="org039bf64">Starting command buffer recording (133)</h6>
<div class="outline-text-6" id="text-org039bf64">
<p>
使用下面方法来起始 command buffer 的记录:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; commandBuffers.size(); i++) {
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    beginInfo.pInheritanceInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to begin recording command buffer!"</span>);
    }
}
</pre>
</div>

<p>
VkCommandBufferBeginInfo.flags 参数可以有如下几个选项：<br />
</p>
<ul class="org-ul">
<li>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT：      command buffer 执行一次后会立即重新记录。<br /></li>
<li>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT： 这是一个 secondary command buffer，将完全在单个渲染通道中。<br /></li>
<li>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT：     命令缓冲区已经处于等待执行状态时，也可以被再次重新提交。<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orgc9f6c8d"></a>ERROR : validation layer: VkCommandBuffer 0x209cf379870[] is already in use and is not marked for simultaneous use. The Vulkan spec states: If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state.<br />
<div class="outline-text-7" id="text-orgc9f6c8d">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; &#21487;&#20197;&#20462;&#22797;&#35813;&#38382;&#39064;</span>
beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">beginInfo.flags = 0; // Optional</span>
beginInfo.pInheritanceInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>

<ul class="org-ul">
<li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Command_buffers">https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Command_buffers</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbedc8b8" class="outline-6">
<h6 id="orgbedc8b8">Starting a render pass (134)</h6>
<div class="outline-text-6" id="text-orgbedc8b8">
<p>
开始进行绘制时，先要开始一个 render pass，使用下面方法开始一个 render pass:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; render pass</span>
<span style="color: #ce537a; font-weight: bold;">VkRenderPassBeginInfo</span> <span style="color: #7590db;">renderPassInfo</span>{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
renderPassInfo.renderPass = renderPass;
renderPassInfo.framebuffer = swapChainFramebuffers[i];
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;renderArea&#12290;renderArea&#25351;&#23450;&#20102;&#30528;&#33394;&#22120;&#25191;&#34892;load&#21644;store&#30340;&#21306;&#22495;&#65292;&#21306;&#22495;&#22806;&#30340;&#20687;&#32032;&#20026;&#26410;&#23450;&#20041;&#20540;&#12290;&#35813;&#21306;&#22495;&#20540;&#38656;&#35201;&#21644;attachments&#30340;&#23610;&#23544;&#30456;&#21305;&#37197;&#65292;&#20174;&#32780;&#20445;&#35777;&#26368;&#20339;&#24615;&#33021;</span>
renderPassInfo.renderArea.offset = {0, 0};
renderPassInfo.renderArea.extent = swapChainExtent;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; VK_ATTACHMENT_LOAD_OP_CLEAR &#25351;&#23450;&#28165;&#38500;&#20540;</span>
<span style="color: #ce537a; font-weight: bold;">VkClearValue</span> <span style="color: #7590db;">clearColor</span> = { {{0.0f, 0.0f, 0.0f, 1.0f}} };
renderPassInfo.clearValueCount = 1;
renderPassInfo.pClearValues = &amp;clearColor;
vkCmdBeginRenderPass(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
</pre>
</div>
<p>
vkCmdBeginRenderPass 的第三个参数控制 render pass 命令会在哪儿执行，其可以有如下两个选项：<br />
</p>
<ul class="org-ul">
<li>VK_SUBPASS_CONTENTS_INLINE： render pass 的命令将被嵌入到 primary command buffer 中，没有 secondary command buffers 被执行。<br /></li>
<li>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS： render pass 的命令将在 secondary command buffers 上执行。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org13f25b8" class="outline-6">
<h6 id="org13f25b8">Basic drawing commands (135)</h6>
<div class="outline-text-6" id="text-org13f25b8">
<p>
随后，我们将 commandBuffers 绑定到 graphics pipeline，然后执行绘制命令:<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; command buffer &#21644; pipeline</span>
vkCmdBindPipeline(<span style="color: #ce537a; font-weight: bold;">commandBuffers</span>[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#32472;&#21046;&#21629;&#20196;</span>
vkCmdDraw(commandBuffers[i], 3, 1, 0, 0);
</pre>
</div>
<p>
vkCmdBindPipeline 的第二个参数用于指定 pipeline 是 graphics pipeline 还是 compute pipeline。<br />
</p>

<p>
vkCmdDraw 的四个参数意义如下：<br />
</p>
<ul class="org-ul">
<li>vertexCount：   即使我们没有顶点缓冲区，从技术上讲，我们仍然有 3 个顶点要绘制。<br /></li>
<li>instanceCount： 用于 instanced 渲染，不进行实例化渲染时，设置为 1。<br /></li>
<li>firstVertex：   用作顶点缓冲区的偏移量，定义 gl_VertexIndex 的最小值。<br /></li>
<li>firstInstance： 用作 instanced 渲染的偏移量，定义 gl_InstanceIndex 的最小值。<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgaf769ea" class="outline-6">
<h6 id="orgaf769ea">Finishing up (135)</h6>
<div class="outline-text-6" id="text-orgaf769ea">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; render pass</span>
vkCmdEndRenderPass(<span style="color: #ce537a; font-weight: bold;">commandBuffers</span>[i]);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; command buffer &#35760;&#24405;</span>
<span style="color: #4f97d7; font-weight: bold;">if</span> (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) 
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to record command buffer!"</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org51d67e7" class="outline-5">
<h5 id="org51d67e7">Rendering and presentation (137)</h5>
<div class="outline-text-5" id="text-org51d67e7">
<p>
接下来我们需要在主循环中做如下三件事：<br />
</p>
<ul class="org-ul">
<li>从 swap chain 获取一个 image<br /></li>
<li>将上一步得到的 image 作为 framebuffer 的 attachment, 然后执行 command buffer<br /></li>
<li>将 image 返回给 swap chain, 并展示渲染的结果<br /></li>
</ul>

<p>
上面每个中都有很多操作，这些操作都是同步执行的，但是上面步骤之间有依赖关系，每一个步骤都依赖前一个步骤结束。有两种方式可用于同步 swap chain 事件：fences 和 samaphores。这两种对象都可以用于协调多个操作。不同之处是，你可以在程序中使用 vkWaitForFences 来访问 fences 的状态，而无法访问 semaphores 的状态。Fences 主要用于同步应用程序和渲染操作，而 Semaphores 主要用于同步同一个 command queues 中的操作，或不同 command queues 中的操作。<br />
</p>
</div>
<div id="outline-container-orgb1d0ad9" class="outline-6">
<h6 id="orgb1d0ad9">Semaphores (138)</h6>
<div class="outline-text-6" id="text-orgb1d0ad9">
<p>
我们需要使用一个 Semaphore 来表示已经从 swap chain 中获得了 image，并且准备好了进行渲染，还需要另一个 Semaphore 表示渲染已经完成，可以进行展示了。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createSemaphores</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkSemaphoreCreateInfo</span> <span style="color: #7590db;">semaphoreInfo</span>{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateSemaphore(device, &amp;semaphoreInfo, <span style="color: #a45bad;">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||
        vkCreateSemaphore(device, &amp;semaphoreInfo, <span style="color: #a45bad;">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS) 
    {

        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create semaphores!"</span>);
    }
}
</pre>
</div>
<p>
结束时需要手动销毁 Semaphores：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">cleanup</span>()
{
    vkDestroySemaphore(device, renderFinishedSemaphore, <span style="color: #a45bad;">nullptr</span>);
    vkDestroySemaphore(device, imageAvailableSemaphore, <span style="color: #a45bad;">nullptr</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb359cdf" class="outline-6">
<h6 id="orgb359cdf">Acquiring an image from the swap chain (139)</h6>
<div class="outline-text-6" id="text-orgb359cdf">
<p>
前面提到，第一步先要从 swap chain 获得一个 image，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. &#20174; swapChain &#33719;&#21462; image</span>
<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">imageIndex</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#19977;&#20010;&#21442;&#25968;&#25351;&#23450; image &#21464;&#20026;&#21487;&#29992;&#30340;&#36229;&#26102;&#26102;&#38388;&#38271;&#24230;&#65292;&#21333;&#20301;&#20026;&#32435;&#31186;&#12290;&#20351;&#29992;UINT64_MAX&#34920;&#31034;&#20851;&#38381;&#36229;&#26102;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#22235;&#20010;&#21442;&#25968;&#25351;&#23450; &#24403;&#23637;&#31034;&#24341;&#25806;&#19981;&#20877;&#20351;&#29992;&#35813;image&#21518;&#65292;&#35302;&#21457;&#30340;&#20449;&#21495;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#20116;&#20010;&#21442;&#25968;&#25351;&#23450; &#24403;&#23637;&#31034;&#24341;&#25806;&#19981;&#20877;&#20351;&#29992;&#35813;image&#21518;&#65292;&#35302;&#21457;&#30340;fence</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#20845;&#20010;&#21442;&#25968;&#26159;&#33719;&#21462;&#21040;&#30340;image&#30340;&#32034;&#24341;</span>
vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);
</pre>
</div>
</div>
</div>
<div id="outline-container-org1605099" class="outline-6">
<h6 id="org1605099">Submitting the command buffer (140)</h6>
<div class="outline-text-6" id="text-org1605099">
<p>
按照如下方法来提交 command buffer 到 graphics queue，来执行绘制：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. &#37197;&#32622;&#38431;&#21015;&#30340;&#25552;&#20132;</span>
<span style="color: #ce537a; font-weight: bold;">VkSubmitInfo</span> <span style="color: #7590db;">submitInfo</span>{};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2.1 &#37197;&#32622;&#31561;&#24453;&#30340;&#20449;&#21495;&#37327; &#20197;&#21450; &#22312;pipeline&#30340;&#21738;&#20123;&#38454;&#27573;&#31561;&#24453;</span>
<span style="color: #ce537a; font-weight: bold;">VkSemaphore</span> <span style="color: #7590db;">waitSemaphores</span>[] = { imageAvailableSemaphore };
<span style="color: #ce537a; font-weight: bold;">VkPipelineStageFlags</span> <span style="color: #7590db;">waitStages</span>[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
submitInfo.waitSemaphoreCount = 1;
submitInfo.pWaitSemaphores = waitSemaphores;
submitInfo.pWaitDstStageMask = waitStages;

submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2.2 &#37197;&#32622;&#24403;command buffers&#25191;&#34892;&#32467;&#26463;&#21518;&#65292;&#35302;&#21457;&#21738;&#20123;&#20449;&#21495;</span>
<span style="color: #ce537a; font-weight: bold;">VkSemaphore</span> <span style="color: #7590db;">signalSemaphores</span>[] = { renderFinishedSemaphore };
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = signalSemaphores;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;command buffer&#25552;&#20132;&#21040;graphics queue</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;&#37319;&#29992;&#20449;&#21495;&#37327;&#36827;&#34892;&#21516;&#27493;&#65292;&#25152;&#20197;&#31532;&#19977;&#20010;&#21442;&#25968;&#27809;&#26377;&#20256;&#20837; Fence</span>
<span style="color: #4f97d7; font-weight: bold;">if</span> (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) 
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to submit draw command buffer!"</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org29bf864" class="outline-6">
<h6 id="org29bf864">Subpass dependencies (141)</h6>
<div class="outline-text-6" id="text-org29bf864">
<p>
render pass 中的 subpasses 会自动处理 image layout 的转换。这些转换是通过 subpass dependencies 来控制的，其指定了 subpasses 的内存以及彼此之间的执行依赖关系。我们现在只有一个 subpass，但是该 subpass 之前或之后的操作也被当作隐式的 subpasses。<br />
</p>

<p>
有两种内置的 dependencies 分别用于处理 render pass 开始时和 render pass 结束后的转换。前者假设转换发生在 pipeline 开始的时候，但是此时我们还没有获得 image。有两种方式来处理该问题。我们可以将 waitStages 从 imageAvailableSemaphore 修改为 VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT ，从而确保 image 可用后才开始 render pass。或者我们可以让 render pass 等待 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT 阶段。本教程中采用了第二种方案。<br />
</p>

<p>
VkSubpassDependency 有如下成员：<br />
</p>
<ul class="org-ul">
<li>srcSubpass 指定 src subpass 的索引。   srcSubpass=VK_SUBPASS_EXTERNAL 表示 dstSubpass 之前的 render pass<br /></li>
<li>dstSubpass 指定 des subpass 的索引。  dstSubpass=VK_SUBPASS_EXTERNAL 表示 srcSubpass 之后的 render pass<br /></li>
</ul>
<p>
0 为 subpass 的索引时，表示当前的 subpass。为了避免循环依赖，dstSubpass 必须比 srcSubpass 要高(除非其中有一个为 VK_SUBPASS_EXTERNAL)。<br />
</p>
<ul class="org-ul">
<li>srcStageMask   指定 src subpass 在哪个阶段被等待<br /></li>
<li>srcAccessMask  指定在等待完成后，src subpass 执行哪些操作<br /></li>
<li>dstStageMask   指定 dst subpass 在哪个阶段进行等待<br /></li>
<li>dstAccessMask  指定在等待完成后，dst subpass 执行哪些操作<br /></li>
</ul>

<p>
在本教程中，我们按照如下方法设置依赖：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35753; render pass &#31561;&#24453; VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>
<span style="color: #ce537a; font-weight: bold;">VkSubpassDependency</span> <span style="color: #7590db;">dependency</span>{};
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">dstSubpass &#30340; dstStageMask &#31561;&#24453; srcSubpass &#30340; srcStageMask</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20004;&#34892;&#25351;&#23450;&#65292;&#24403;&#21069;&#30340;subpass (dstSubpass)&#20381;&#36182;&#20854;&#21069;&#38754;&#30340;pass (&#24403;&#21069;&#30340;subpass &#20026;&#32472;&#21046;&#19977;&#35282;&#24418;&#23545;&#24212;&#30340;subpass)</span>
dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
dependency.dstSubpass = 0;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;srcSubpass&#34987;&#31561;&#24453;&#30340;&#38454;&#27573; (&#21069;&#19968;&#27425;swap chain&#20174;image&#35835;&#21462;&#25968;&#25454;&#38454;&#27573;)</span>
dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#31561;&#24453;&#23436;&#25104;&#21518; srcSubpass&#19981;&#25191;&#34892;&#20219;&#20309;&#25805;&#20316;</span>
dependency.srcAccessMask = 0;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; dstSubpass &#25191;&#34892;&#31561;&#24453;&#30340;&#38454;&#27573;&#65288;&#26412;&#27425;swap chain&#20174;image&#35835;&#21462;&#25968;&#25454;&#23436;&#27605;&#38454;&#27573;&#65289;</span>
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#31561;&#24453;&#23436;&#25104;&#21518; desSubpass &#25191;&#34892;&#20889;&#20837;color attachment&#30340;&#25805;&#20316;</span>
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
</pre>
</div>
</div>
</div>
<div id="outline-container-org1fea19e" class="outline-6">
<h6 id="org1fea19e">Presentation (142)</h6>
<div class="outline-text-6" id="text-org1fea19e">
<p>
最后一步就是将绘制好的结果返回给 swap chain，将结果展示在屏幕上。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#37197;&#32622;&#23637;&#31034;</span>
<span style="color: #ce537a; font-weight: bold;">VkPresentInfoKHR</span> <span style="color: #7590db;">presentInfo</span>{};
presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

presentInfo.waitSemaphoreCount = 1;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#28210;&#26579;&#23436;&#25104;&#30340;&#20449;&#21495;</span>
presentInfo.pWaitSemaphores = signalSemaphores;
<span style="color: #ce537a; font-weight: bold;">VkSwapchainKHR</span> <span style="color: #7590db;">swapChains</span>[] = {swapChain};
presentInfo.swapchainCount = 1;
presentInfo.pSwapchains = swapChains;
presentInfo.pImageIndices = &amp;imageIndex;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#26377;&#22810;&#20010;swap chain&#26102;&#65292;&#21487;&#29992;&#20110;&#21028;&#26029;&#27599;&#20010;swap chain&#26159;&#21542;&#37117;&#23637;&#31034;&#25104;&#21151;&#12290;&#21482;&#26377;&#19968;&#20010;swap chain&#26102;&#65292;&#35813;&#21442;&#25968;&#21487;&#36873;</span>
presentInfo.pResults = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
<span style="color: #4f97d7; font-weight: bold;">if</span>(vkQueuePresentKHR(presentQueue, &amp;presentInfo)!=VK_SUCCESS)
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"present error!"</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge68621b" class="outline-6">
<h6 id="orge68621b">Frames in flight (144)</h6>
<div class="outline-text-6" id="text-orge68621b">
<p>
当前应用程序在 drawFrame 函数中快速地提交工作，但没有检查提交的工作是否完成。如果 CPU 提交的速度比 GPU 处理的速度要快，则队列中会充满任务。更糟糕的是，我们只有了两个信号量做同步，这样同一时间有多个帧都在复用这两个信号量，这肯定是有问题的。最简单的解决方式是在提交工作后，等待工作完成，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">drawFrame</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>

    vkQueuePresentKHR(presentQueue, &amp;presentInfo);
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#23637;&#31034;&#23436;&#25104;</span>
    vkQueueWaitIdle(presentQueue);
}
</pre>
</div>
<p>
但是，以上面这种方式使用 GPU 不是最优的，当前帧经过的 graphics pipeline 阶段是闲置的，而此时它们本可以用于处理下一帧。我们现在将扩展我们的应用程序，以允许多个帧在运行，同时仍然限制堆积的工作量。<br />
</p>

<p>
下面图示展示了，采用新方案后的同步关系：<br />
<img src="./Vulkan/draw-triangle-sync.jpg" alt="draw-triangle-sync.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf0eb82a" class="outline-5">
<h5 id="orgf0eb82a">Swap chain recreation (152)</h5>
<div class="outline-text-5" id="text-orgf0eb82a">
<p>
当我们的应用程序改变窗口大小时，应用程序会直接 crash。这是由于 swap chain 不适用于当前窗口大小导致的，vkAcquireNextImageKHR 和 vkQueuePresentKHR 函数可以通过如下返回值来指示这种特殊情况：<br />
</p>
<ul class="org-ul">
<li>VK_ERROR_OUT_OF_DATE_KHR：swap chain 和 surface 不兼容，无法再用于渲染。 通常发生在窗口调整大小之后。<br /></li>
<li>VK_SUBOPTIMAL_KHR：swap chain 仍可用于成功呈现到 surface，但 surface 属性不再完全匹配。<br /></li>
</ul>

<p>
尽管很多平台和驱动在窗口尺寸发生变化后都会自动触发 VK_ERROR_OUT_OF_DATE_KHR ，但是并不保证会如此。可以为 glfw 设置回调函数来检测窗口发生变化的情况。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">initWindow</span>()
{
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);</span>
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
    window = glfwCreateWindow(WIDTH, HEIGHT, <span style="color: #2d9574;">"Vulkan"</span>, <span style="color: #a45bad;">nullptr</span>, <span style="color: #a45bad;">nullptr</span>);
    glfwSetWindowUserPointer(window, <span style="color: #4f97d7; font-weight: bold;">this</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35774;&#32622;&#22238;&#35843;&#20989;&#25968;&#26469;&#26816;&#27979;&#31383;&#21475;&#21457;&#29983;&#21464;&#21270;&#30340;&#24773;&#20917;</span>
    glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);
}

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">framebufferResizeCallback</span>(<span style="color: #ce537a; font-weight: bold;">GLFWwindow</span>* <span style="color: #7590db;">window</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">height</span>) 
{
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">app</span> = <span style="color: #4f97d7; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">HelloTriangleApplication</span>*&gt;(glfwGetWindowUserPointer(window));
    app-&gt;framebufferResized = <span style="color: #a45bad;">true</span>;
}
</pre>
</div>

<p>
另外，还需要处理最小化窗口的情况，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">recreateSwapChain</span>() 
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#31383;&#21475;&#26368;&#23567;&#21270;</span>
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">width</span> = 0, <span style="color: #7590db;">height</span> = 0;
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    <span style="color: #4f97d7; font-weight: bold;">while</span> (width == 0 || height == 0) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19968;&#30452;&#24490;&#29615;&#65292;&#30452;&#21040;&#31383;&#21475;&#23610;&#23544;&#19981;&#20026;0</span>
    {
        glfwGetFramebufferSize(window, &amp;width, &amp;height);
        glfwWaitEvents();
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#20043;&#21069;&#24037;&#20316;&#22788;&#29702;&#23436;&#25104;</span>
    vkDeviceWaitIdle(device);

    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandBuffers();
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd259258" class="outline-3">
<h3 id="orgd259258">Vertex buffers</h3>
<div class="outline-text-3" id="text-orgd259258">
<p>
前面我们直接在 shader 中硬编码了顶点数据，这章我们将使用 vertex buffer 将顶点数据传递给 GPU。我们创建一个 CPU 可见的 buffer，然后使用 memcopy 将顶点数据 copy 到其中。之后我们使用 staging buffer 将顶点数据 copy 到高性能的内存中。<br />
</p>
</div>
<div id="outline-container-org376ce6f" class="outline-4">
<h4 id="org376ce6f">Vertex input description (159)</h4>
<div class="outline-text-4" id="text-org376ce6f">
<p>
修改 vertex shader 如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">#version 450

layout(location = 0) <span style="color: #4f97d7; font-weight: bold;">in</span> vec2 inPosition;
layout(location = 1) <span style="color: #4f97d7; font-weight: bold;">in</span> vec3 inColor;

layout(location = 0) <span style="color: #4f97d7; font-weight: bold;">out</span> vec3 fragColor;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    gl_Position = vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</pre>
</div>

<p>
定义 vertex data 如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Vertex</span>
{
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">pos</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">color</span>;
};

<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">Vertex</span>&gt; <span style="color: #7590db;">vertices</span> = {
    {{0.0f, -0.5f}, {1.0f, 0.0f, 0.0f}},
    {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}},
    {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}
};
</pre>
</div>

<p>
定义顶点输入绑定描述：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">VkVertexInputBindingDescription</span> <span style="color: #bc6ec5; font-weight: bold;">getBindingDescription</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkVertexInputBindingDescription</span> <span style="color: #7590db;">bindingDescription</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#24403;&#21069;binding&#22312;bindings&#25968;&#32452;&#20013;&#30340;&#32034;&#24341;&#20540;</span>
    bindingDescription.binding = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#19968;&#20010;&#25968;&#25454;&#39033;&#30340;&#27493;&#38271;(stride) &#20197;&#23383;&#33410;&#20026;&#21333;&#20301; &#21363;&#19968;&#20010;&#25968;&#25454;&#39033;&#21040;&#19979;&#19968;&#20010;&#25968;&#25454;&#39033;&#26377;&#22810;&#23569;&#20010;&#23383;&#33410;</span>
    bindingDescription.stride = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(Vertex);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#39030;&#28857;&#23646;&#24615;&#22320;&#22336;&#26159;&#19968;&#20010;&#39030;&#28857;&#32034;&#24341;&#30340;&#20989;&#25968;</span>
    bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    <span style="color: #4f97d7; font-weight: bold;">return</span> bindingDescription;
}
</pre>
</div>
<p>
VkVertexInputBindingDescription.inputRate 有两个可选项：<br />
</p>
<ul class="org-ul">
<li>VK_VERTEX_INPUT_RATE_VERTEX：   指定顶点属性地址是一个顶点索引的函数<br /></li>
<li>VK_VERTEX_INPUT_RATE_INSTANCE： 指定顶点属性地址是一个实例索引的函数<br /></li>
</ul>

<p>
定义顶点输入属性描述：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkVertexInputAttributeDescription, 2&gt; <span style="color: #bc6ec5; font-weight: bold;">getAttributeDescriptions</span>() 
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkVertexInputAttributeDescription, 2&gt; <span style="color: #7590db;">attributeDescriptions</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#27599;&#20010;&#39030;&#28857;&#25968;&#25454;&#26469;&#33258;&#21738;&#20010; binding</span>
    attributeDescriptions[0].binding = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21644; vertex shader&#20013;&#30340;location &#25351;&#20196;&#30456;&#23545;&#24212;</span>
    attributeDescriptions[0].location = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#35813;&#23646;&#24615;&#23545;&#24212;&#25968;&#25454;&#30340;&#31867;&#22411;</span>
    attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#35813;&#23646;&#24615;&#22312;&#19968;&#20010;&#25968;&#25454;&#39033;&#20013;&#30340;&#20559;&#31227;</span>
    attributeDescriptions[0].offset = offsetof(Vertex, pos);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(Vertex, color);

    <span style="color: #4f97d7; font-weight: bold;">return</span> attributeDescriptions;
}
</pre>
</div>
<p>
VkVertexInputAttributeDescription.format 用于指定属性对应数据的类型。shader 中属性类型和此处枚举值类型的对应关系如下：<br />
</p>
<ul class="org-ul">
<li>float: VK_FORMAT_R32_SFLOAT<br /></li>
<li>vec2: VK_FORMAT_R32G32_SFLOAT<br /></li>
<li>vec3: VK_FORMAT_R32G32B32_SFLOAT<br /></li>
<li>vec4: VK_FORMAT_R32G32B32A32_SFLOAT<br /></li>
</ul>
<p>
枚举值中包含的 color channel 数量和 shader 中属性类型的维度要一致。如果枚举值中的 color channel 数量比 shader 中属性类型的维度多，多出部分会被忽略; 如果枚举值中的 color channel 数量比 shader 中属性类型的维度少，则 BG 通道会使用默认值 0，A 通道会使用默认值 1。枚举值中 color channel 的类型、位宽度与 shader 中属性分量的类型也要一致，例如：<br />
</p>
<ul class="org-ul">
<li>ivec2: VK_FORMAT_R32G32_SINT, a 2-component vector of 32-bit signed integers<br /></li>
<li>uvec4: VK_FORMAT_R32G32B32A32_UINT, a 4-component vector of 32-bit unsigned integers<br /></li>
<li>double: VK_FORMAT_R64_SFLOAT, a double-precision (64-bit) float<br /></li>
</ul>

<p>
VkVertexInputAttributeDescription.offset 指定了该属性在一个数据项中的偏移。binding 每次加载一个 Vertex，而 position 属性(pos)在整个数据偏移 0 的位置<br />
</p>

<p>
为 graphics pipeline 配置 vertex input:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createGraphicsPipeline</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; vertex shader stage</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; fragment shader stage</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; vertex input</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineVertexInputStateCreateInfo</span> <span style="color: #7590db;">vertexInputInfo</span>{};
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">bindingDescription</span> = <span style="color: #a45bad;">Vertex</span>::getBindingDescription();
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">attributeDescriptions</span> = <span style="color: #a45bad;">Vertex</span>::getAttributeDescriptions();
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    vertexInputInfo.vertexAttributeDescriptionCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(attributeDescriptions.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; input assembly</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; viewports &#21644; scissors</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Rasterizer</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; multisampling</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Depth and stencil testing</span>
    <span style="color: #ce537a; font-weight: bold;">VkPipelineDepthStencilStateCreateInfo</span> <span style="color: #7590db;">depthStencil</span>{};

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Color Blending</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; &#21487;&#20197;&#21160;&#24577;&#20462;&#25913;&#30340;&#35774;&#32622;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Pipeline Layout</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; graphics pipeline</span>
    <span style="color: #ce537a; font-weight: bold;">VkGraphicsPipelineCreateInfo</span> <span style="color: #7590db;">pipelineInfo</span>{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    pipelineInfo.pVertexInputState = &amp;vertexInputInfo;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Graphics Pipeline</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, <span style="color: #a45bad;">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create graphics pipeline!"</span>);
    }

    vkDestroyShaderModule(device, fragShaderModule, <span style="color: #a45bad;">nullptr</span>);
    vkDestroyShaderModule(device, vertShaderModule, <span style="color: #a45bad;">nullptr</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb72212c" class="outline-4">
<h4 id="orgb72212c">Vertex buffer creation (164)</h4>
<div class="outline-text-4" id="text-orgb72212c">
<p>
在 Vulkan 中，buffer 是内存的区域，可用于存储任意的数据，这些数据可以被图形显卡读取。和其他 Vulkan 对象不同，buffers 不会为自身自动申请内存。<br />
</p>
</div>
<div id="outline-container-orgd9d02d6" class="outline-5">
<h5 id="orgd9d02d6">创建 buffer</h5>
<div class="outline-text-5" id="text-orgd9d02d6">
<p>
使用下面方法来创建一个 buffer<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkBufferCreateInfo</span> <span style="color: #7590db;">bufferInfo</span>{};
bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
bufferInfo.size = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(vertices[0]) * vertices.size();
bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

<span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateBuffer(device, &amp;bufferInfo, <span style="color: #a45bad;">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS)
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create vertex buffer!"</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org13c2842" class="outline-5">
<h5 id="org13c2842">获取 buffer 的内存需求</h5>
<div class="outline-text-5" id="text-org13c2842">
<p>
创建 buffer 后，事实上还没有为其赋予内存。为 buffer 分配内存的第一步是查询 buffer 的内存需求，使用 vkGetBufferMemoryRequirements 函数可以查询 buffer 的内存需求，该函数会填充一个 VkMemoryRequirements 对象。VkMemoryRequirements 有如下 3 个成员：<br />
</p>
<ul class="org-ul">
<li>size： 所需的内存总量，可能和 bufferInfo.size 不同<br /></li>
<li>alignment： buffer 在申请的内存中的偏移量，该值取决于 bufferInfo.usage 和 bufferInfo.flags<br /></li>
<li>memoryTypeBits：该成员是一个位掩码，对于每种支持的资源内存类型都有一个位相对应。当且仅当资源支持 VkPhysicalDeviceMemoryProperties 结构中的内存类型 i 时，才会设置位 i。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#20869;&#23384;&#38656;&#27714;</span>
<span style="color: #ce537a; font-weight: bold;">VkMemoryRequirements</span> <span style="color: #7590db;">memRequirements</span>;
vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memRequirements);
</pre>
</div>

<p>
显卡可以提供不同类型的内存。 每种类型的内存在允许的操作和性能特征方面各不相同。 我们需要结合 buffer 的需求和我们自己的应用需求来找到合适的内存类型来使用。使用如下方法来获得合适的内存类型：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">memRequirements.memoryTypeBits       &#25351;&#23450; buffer &#25152;&#38656;&#30340;&#20869;&#23384;&#31867;&#22411;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VkMemoryPropertyFlags:</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT  &#25351;&#23450;&#20869;&#23384;&#22312;CPU&#31471;&#21487;&#35265;</span>
<span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT &#25351;&#23450;&#23545;&#20869;&#23384;&#30340;&#20462;&#25913;&#19981;&#38656;&#35201;Flush</span>
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #bc6ec5; font-weight: bold;">findMemoryType</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">typeFilter</span>, <span style="color: #ce537a; font-weight: bold;">VkMemoryPropertyFlags</span> <span style="color: #7590db;">properties</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceMemoryProperties</span> <span style="color: #7590db;">memProperties</span>;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties);

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; memProperties.memoryTypeCount; i++) 
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> i;
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find suitable memory type!"</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf5a66f6" class="outline-5">
<h5 id="orgf5a66f6">为 buffer 分配内存</h5>
<div class="outline-text-5" id="text-orgf5a66f6">
<p>
使用 vkAllocateMemory 来分配内存，使用 vkBindBufferMemory 来将 buffer 和内存关联起来：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30003;&#35831;&#20869;&#23384;</span>
<span style="color: #ce537a; font-weight: bold;">VkMemoryAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.size;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">memRequirements.memoryTypeBits       &#25351;&#23450; buffer &#25152;&#38656;&#30340;&#20869;&#23384;&#31867;&#22411;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT  &#25351;&#23450;&#20869;&#23384;&#22312;CPU&#31471;&#21487;&#35265;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT &#25351;&#23450;&#23545;&#20869;&#23384;&#30340;&#20462;&#25913;&#19981;&#38656;&#35201;Flush</span>
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
<span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span style="color: #a45bad;">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) 
{
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate vertex buffer memory!"</span>);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450;&#20869;&#23384; &#20851;&#32852;&#20869;&#23384;&#21644;buffer</span>
vkBindBufferMemory(device, vertexBuffer, vertexBufferMemory, 0);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgeb8e89a" class="outline-5">
<h5 id="orgeb8e89a">为 buffer 填充数据</h5>
<div class="outline-text-5" id="text-orgeb8e89a">
<p>
使用下面方法为 buffer 填充数据：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; vertex buffer</span>
<span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">data</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; buffer &#30340;&#20869;&#23384;&#26144;&#23556;&#21040; CPU &#21487;&#20197;&#35775;&#38382;&#30340;&#20869;&#23384;</span>
vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data);
memcpy(data, vertices.data(), (<span style="color: #ce537a; font-weight: bold;">size_t</span>)bufferInfo.size);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21462;&#28040;&#26144;&#23556;</span>
vkUnmapMemory(device, vertexBufferMemory);
</pre>
</div>

<p>
由于缓存的原因，驱动可能没有立即将数据 copy 到 buffer 的内存中，反之亦然，写入 buffer 的数据也可能在映射的内存中不可见。有两种方式来处理这类问题：<br />
</p>
<ul class="org-ul">
<li>申请内存时通过使用 VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 标记来指示使用一个和主机一致的内存堆<br /></li>
<li>写入映射的内存后，调用 vkFlushMappedMemoryRanges 函数。读取映射的内存前，调用 vkInvalidateMappedMemoryRanges<br /></li>
</ul>
<p>
第一种方式可以保证映射的内存中的内容和为 buffer 分配的内存中的内容总是保持一致。但是其性能要比显示地 flushing 要差。<br />
Flushing memory 或使用一致性内存堆意味着驱动可以感知到我们向 buffer 中写入数据，但是其并不意味着这些数据已经在 GPU 上是可见的。传递这些数据到 GPU 的操作发生在后台，规范只是简单要求下一次调用 vkQueueSubmit 时，传递数据的操作是完成的。<br />
</p>
</div>
</div>
<div id="outline-container-orgd43cffa" class="outline-5">
<h5 id="orgd43cffa">绑定 commandBuffer 和 vertexBuffer</h5>
<div class="outline-text-5" id="text-orgd43cffa">
<p>
在执行渲染操作期间，需要绑定 vertex buffer：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createCommandBuffers</span>()
{
    commandBuffers.resize(swapChainFramebuffers.size());
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = (<span style="color: #ce537a; font-weight: bold;">uint32_t</span>)commandBuffers.size();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; CommandBuffers</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate command buffers!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; commandBuffers.size(); i++)
    {
        <span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        beginInfo.pInheritanceInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; command buffers &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to begin recording command buffer!"</span>);
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; render pass</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; command buffer &#21644; pipeline</span>
        vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; vertex buffer</span>
        <span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">vertexBuffers</span>[] = { vertexBuffer };
        <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">offsets</span>[] = { 0 };
        vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#32472;&#21046;&#21629;&#20196;</span>
        vkCmdDraw(commandBuffers[i], <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(vertices.size()), 1, 0, 0);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; render pass</span>
        vkCmdEndRenderPass(commandBuffers[i]);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; command buffer &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to record command buffer!"</span>);
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfcb3723" class="outline-4">
<h4 id="orgfcb3723">Staging buffer (173)</h4>
<div class="outline-text-4" id="text-orgfcb3723">
<p>
我们当前使用的内存类型可以正确工作，但性能不是最优的。最优的内存是 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT 标记的内存，这种内存通常不能被 CPU 访问，其在专用的显卡上。我们可以创建两个 vertex buffers。一个 staging buffer（暂存缓冲区），其在 CPU 可以访问的内存，可以将顶点数据上传到这里。另一个是最终的 vertex buffer，其在显卡设备的本地内存上。我们使用 copy 命令将顶点数据从 staging buffer 移动到 最终的 vertex buffer。<br />
</p>
</div>
<div id="outline-container-org978e282" class="outline-5">
<h5 id="org978e282">Transfer queue (173)</h5>
<div class="outline-text-5" id="text-org978e282">
<p>
buffer copy 命令需要支持 transfer 操作的 queue family，其对应的标记为 VK_QUEUE_TRANSFER_BIT。好消息是，任何标记为 VK_QUEUE_GRAPHICS_BIT 或 VK_QUEUE_COMPUTE_BIT 的 queue family 已经隐式支持 VK_QUEUE_TRANSFER_BIT 标记要求的操作。<br />
</p>
</div>
</div>
<div id="outline-container-org3e3c766" class="outline-5">
<h5 id="org3e3c766">Using a staging buffer (175)</h5>
<div class="outline-text-5" id="text-org3e3c766">
<p>
使用如下方法来利用 staging buffer 传递顶点数据：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createVertexBuffer</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">bufferSize</span> = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(vertices[0]) * vertices.size();

    <span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">stagingBuffer</span>;
    <span style="color: #ce537a; font-weight: bold;">VkDeviceMemory</span> <span style="color: #7590db;">stagingBufferMemory</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314;&#26242;&#23384;&#32531;&#20914;&#21306;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_BUFFER_USAGE_TRANSFER_SRC_BIT &#34920;&#31034;&#21019;&#24314;&#30340;buffer&#29992;&#20110;&#25968;&#25454;&#36716;&#31227;&#65292;&#19988;&#35813;buffer&#20026;&#28304;buffer</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT &#34920;&#31034;&#35813;buffer&#20174;cpu&#21487;&#35265;&#65292;&#19988;&#20445;&#35777;&#26144;&#23556;&#20869;&#23384;&#21644;&#32531;&#23384;&#20869;&#23384;&#19968;&#33268;</span>
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22635;&#20805; staging buffer</span>
    <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">data</span>;
    vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data);
    memcpy(data, vertices.data(), (<span style="color: #ce537a; font-weight: bold;">size_t</span>)bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314;&#30495;&#27491;&#30340;vertex buffer</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_BUFFER_USAGE_TRANSFER_DST_BIT     &#34920;&#31034;&#21019;&#24314;&#30340;buffer&#29992;&#20110;&#25968;&#25454;&#36716;&#31227;&#65292;&#19988;&#35813;buffer&#20026;&#30446;&#26631;buffer</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT    &#34920;&#31034;&#21019;&#24314;&#30340;buffer&#29992;&#20110;&#23384;&#20648;&#39030;&#28857;&#25968;&#25454;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT  &#34920;&#31034;&#35813;buffer&#21482;&#22312;GPU&#31471;&#21487;&#35265;</span>
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#39030;&#28857;&#25968;&#25454;&#20174; staging buffer &#31227;&#21160;&#21040; vertex buffer</span>
    copyBuffer(stagingBuffer, vertexBuffer, bufferSize);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; staging buffer &#23545;&#35937;</span>
    vkDestroyBuffer(device, stagingBuffer, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37322;&#25918; staging buffer&#30340;&#20869;&#23384;</span>
    vkFreeMemory(device, stagingBufferMemory, <span style="color: #a45bad;">nullptr</span>);
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">copyBuffer</span>(<span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">srcBuffer</span>, <span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">dstBuffer</span>, <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">size</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    <span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">commandBuffer</span>;
    vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);

    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21578;&#35785;&#39537;&#21160;&#65292;&#25105;&#20204;&#21482;&#20351;&#29992;&#35813;command buffer &#19968;&#27425;</span>
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);
    <span style="color: #ce537a; font-weight: bold;">VkBufferCopy</span> <span style="color: #7590db;">copyRegion</span>{};
    copyRegion.srcOffset = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    copyRegion.dstOffset = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    copyRegion.size = size;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">copy buffer &#21629;&#20196;</span>
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion);
    vkEndCommandBuffer(commandBuffer);

    <span style="color: #ce537a; font-weight: bold;">VkSubmitInfo</span> <span style="color: #7590db;">submitInfo</span>{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &amp;commandBuffer;

    vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;copy&#25968;&#25454;&#23436;&#25104;</span>
    vkQueueWaitIdle(graphicsQueue);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37322;&#25918;&#25191;&#34892;copy buffer&#30340;commandBuffer</span>
    vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org45bca08" class="outline-5">
<h5 id="org45bca08">Conclusion (178)</h5>
<div class="outline-text-5" id="text-org45bca08">
<p>
在真实的应用程序开发中，我们不建议为每个独立的 buffer 都使用 vkAllocateMemory 来分配内存。同时可以申请的内存数量是有限的，最大值由物理设备的 maxMemoryAllocationCount 来决定，即使是 NVIDIA GTX 1080 这样的高端硬件设备，其值也可能只有 4096。当有很多个对象时，应该创建一个自定义的分配器，其可以利用 offset 参数将单次分配的内存划分给多个不同的对象。你也可以使用 GUPOpen 提供的 VulkanMemoryAllocator 库。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org90d9e15" class="outline-4">
<h4 id="org90d9e15">Index buffer (179)</h4>
<div class="outline-text-4" id="text-org90d9e15">
<p>
index buffer 的创建和填充与 vertex buffer 类似，在此不再重复。使用 index buffer 很简单：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createCommandBuffers</span>()
{
    commandBuffers.resize(swapChainFramebuffers.size());
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; CommandBuffers</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate command buffers!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; commandBuffers.size(); i++)
    {
        <span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; command buffers &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to begin recording command buffer!"</span>);
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; render pass</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; command buffer &#21644; pipeline</span>
        vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; vertex buffer</span>
        <span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">vertexBuffers</span>[] = { vertexBuffer };
        <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">offsets</span>[] = { 0 };
        vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#32465;&#23450; index buffer]</span>
        vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT16);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">[&#35843;&#29992;&#32472;&#21046;&#21629;&#20196;]</span>
        vkCmdDrawIndexed(commandBuffers[i], <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(indices.size()), 1, 0, 0, 0);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; render pass</span>
        vkCmdEndRenderPass(commandBuffers[i]);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; command buffer &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to record command buffer!"</span>);
        }
    }
}
</pre>
</div>
<p>
驱动开发者建议应该将多个 buffer(如：vertex buffer 和 index buffer)存储在一个 VkBuffer 中。这样做的优点是你的数据会对 cache 更加友好，因为这些相关的数据靠的更近。如果不会在相同的渲染操作期间使用这些资源, 甚至可以为多个资源重用相同的内存块。当然，前提是它们的数据被刷新。这被称为 aliasing(别名)，一些 Vulkan 函数具有显式标志来指定你要这样做。<br />
</p>

<ul class="org-ul">
<li><a href="https://developer.nvidia.com/vulkan-memory-management">https://developer.nvidia.com/vulkan-memory-management</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf5611a4" class="outline-3">
<h3 id="orgf5611a4">Uniform Buffers</h3>
<div class="outline-text-3" id="text-orgf5611a4">
<p>
我们现在已经可以使用 buffer 为 vertex shader 传递任意的顶点属性数据了，但是全局变量(如 MVP 矩阵)应该如何传递给 vertex/fragment shader 呢？<br />
在 Vulkan 中，可以使用 resource descriptors 来完成全局变量的传递。descriptor 是 shaders 自由访问资源(如：buffers、images)的一种方式。我们将设置一个 buffer，让其包含 MVP 矩阵，然后让 vertex shader 通过一个 descriptor 来访问 MVP 矩阵。descriptors 的使用需要以下 3 步：<br />
</p>
<ul class="org-ul">
<li>在创建 pipeline 阶段指定一个 descriptor layout<br /></li>
<li>从一个 descriptor pool 分配一个 descriptor set<br /></li>
<li>在渲染时，绑定该 descriptor set<br /></li>
</ul>
</div>

<div id="outline-container-org870fd2a" class="outline-4">
<h4 id="org870fd2a">Descriptor layout and buffer (184)</h4>
<div class="outline-text-4" id="text-org870fd2a">
<p>
descriptor layout 指定了在 pipeline 中将要访问的资源类型（就如同 render pass 指定了在 pipeline 中将要访问的 attachments 的类型）。descriptor set 指定了真正被绑定到 descriptors 的 buffer 或 image 资源（就如同 framebuffer 指定了真正被绑定到 attachments 的 image views）。使用时，需要将 descriptor set 绑定到 commandBuffer 上(就如同 vertex buffers 或 framebuffer 绑定到 commandBuffer 上)。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; descriptor sets </span>
vkCmdBindDescriptorSets(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;descriptorSets[i], 0, <span style="color: #a45bad;">nullptr</span>);
</pre>
</div>

<p>
desciptors 有很多种类型，本章我们使用的是 uniform buffer objects.<br />
</p>
</div>

<div id="outline-container-orga551380" class="outline-5">
<h5 id="orga551380">Vertex shader (185)</h5>
<div class="outline-text-5" id="text-orga551380">
<p>
在 vertex shader 中使用 uniform buffer object descriptor 的方法如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">layout(binding = 0) <span style="color: #ce537a; font-weight: bold;">uniform</span> <span style="color: #7590db;">UniformBufferObject</span> {
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
} ubo;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</pre>
</div>
<p>
descriptors 的 binding 指令和 attributes 的 location 指令类似，我们将在 descriptor layout 中引用这个 binding。<br />
</p>
</div>
</div>
<div id="outline-container-orgd427a2a" class="outline-5">
<h5 id="orgd427a2a">Descriptor set layout (186)</h5>
<div class="outline-text-5" id="text-orgd427a2a">
<p>
在 c++中定义 UniformBufferObject，之后便于使用 memcpy 将一个 UniformBufferObject 对象 copy 到一个 VkBuffer 中。另外在创建 pipeline 时，我们还需要提供每个 descriptor binding 的细节, 使用 VkDescriptorSetLayout 来指定 descriptor binding 的细节。（就如我们需要为每个顶点属性所做的一样, 我们使用 VkVertexInputBindingDescription 和 VkVertexInputAttributeDescription 来指定详细信息）。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorSetLayout</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutBinding</span> <span style="color: #7590db;">uboLayoutBinding</span>{};
    uboLayoutBinding.binding = 0;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    uboLayoutBinding.pImmutableSamplers = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutCreateInfo</span> <span style="color: #7590db;">layoutInfo</span>{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 1;
    layoutInfo.pBindings = &amp;uboLayoutBinding;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, <span style="color: #a45bad;">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create descriptor set layout!"</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcc2a684" class="outline-5">
<h5 id="orgcc2a684">Uniform buffer (188)</h5>
<div class="outline-text-5" id="text-orgcc2a684">
<p>
我们需要创建一个 buffer，来放置 UBO 数据。因为我们会在每帧将新的数据 copy 到 uniform buffer，使用 staging buffer 就没任何意义了，反而会增加性能销毁。<br />
因为同时可能有多帧被渲染，所以，我们需要多个 uniform buffer，我们不希望为下一帧做准备时更新了 uniform buffer 时，上一帧依然在读取该 buffer 的内容。我们应该为每一帧或每一个 swap chain image 申请一个 uniform buffer。由于我们需要从 command buffer 引用 uniform buffer, 而每一个 swap chain image 都对应了一个 command buffer，所以，我们为每个 swap chain image 申请一个 uniform buffer。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createUniformBuffers</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">bufferSize</span> = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(UniformBufferObject);

    uniformBuffers.resize(swapChainImages.size());
    uniformBuffersMemory.resize(swapChainImages.size());

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImages.size(); i++) 
    {
        createBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org85d1b9d" class="outline-5">
<h5 id="org85d1b9d">Updating uniform data (190)</h5>
<div class="outline-text-5" id="text-org85d1b9d">
<p>
在 drawFrame 中调用如下函数，从而在每帧更新 uniform buffer 中的数据:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">updateUniformBuffer</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">currentImage</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">startTime</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">high_resolution_clock</span>::now();

    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">currentTime</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">high_resolution_clock</span>::now();
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">time</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::duration&lt;<span style="color: #ce537a; font-weight: bold;">float</span>, <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">seconds</span>::period&gt;(currentTime - startTime).count();
    <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> <span style="color: #7590db;">ubo</span>{};
    ubo.model = <span style="color: #a45bad;">glm</span>::rotate(<span style="color: #a45bad;">glm</span>::mat4(1.0f), time * <span style="color: #a45bad;">glm</span>::radians(90.0f), <span style="color: #a45bad;">glm</span>::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = <span style="color: #a45bad;">glm</span>::lookAt(<span style="color: #a45bad;">glm</span>::vec3(2.0f, 2.0f, 2.0f), <span style="color: #a45bad;">glm</span>::vec3(0.0f, 0.0f, 0.0f), <span style="color: #a45bad;">glm</span>::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = <span style="color: #a45bad;">glm</span>::perspective(<span style="color: #a45bad;">glm</span>::radians(45.0f), swapChainExtent.width / (<span style="color: #ce537a; font-weight: bold;">float</span>) swapChainExtent.height, 0.1f, 10.0f);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glm &#29992;&#20110; opengl &#35009;&#21098;&#22352;&#26631;&#31995;y&#36724;&#21521;&#19978;&#20026;&#27491;&#65292;&#32780;vulkan&#35268;&#23450;&#35009;&#21098;&#22352;&#26631;&#31995;y&#36724;&#21521;&#19979;&#20026;&#27491;&#65292;&#22240;&#27492;&#38656;&#35201;&#22914;&#19979;&#20195;&#30721;</span>
    ubo.proj[1][1] *= -1;
    <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">data</span>;
    vkMapMemory(device, uniformBuffersMemory[currentImage], 0, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(ubo), 0, &amp;data);
    memcpy(data, &amp;ubo, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(ubo));
    vkUnmapMemory(device, uniformBuffersMemory[currentImage]);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4184e7e" class="outline-4">
<h4 id="org4184e7e">Descriptor pool and sets (193)</h4>
<div class="outline-text-4" id="text-org4184e7e">
<p>
我们还需要为每个 VkBuffer 资源创建一个 descriptor set，从而将其绑定到 uniform buffer descriptor。无法直接创建 descriptor set,需要通过 descriptor pool 来分配 descriptor set。<br />
</p>
</div>
<div id="outline-container-org0229bde" class="outline-5">
<h5 id="org0229bde">Descriptor pool (193)</h5>
<div class="outline-text-5" id="text-org0229bde">
<p>
使用如下方法创建 descriptor pool:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorPool</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorPoolSize</span> <span style="color: #7590db;">poolSize</span>{};
    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#27599;&#20010;swap chain image &#21019;&#24314;&#19968;&#20010;command buffer,&#20026;&#27599;&#20010;command buffer&#21019;&#24314;&#19968;&#20010;uniform buffer</span>
    poolSize.descriptorCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());

    <span style="color: #ce537a; font-weight: bold;">VkDescriptorPoolCreateInfo</span> <span style="color: #7590db;">poolInfo</span>{};
    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    poolInfo.poolSizeCount = 1;
    poolInfo.pPoolSizes = &amp;poolSize;
    poolInfo.maxSets = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDescriptorPool(device, &amp;poolInfo, <span style="color: #a45bad;">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create descriptor pool!"</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd6b174" class="outline-5">
<h5 id="orgbd6b174">Descriptor set (195)</h5>
<div class="outline-text-5" id="text-orgbd6b174">
<p>
使用 vkAllocateDescriptorSets 方法创建 descriptor set, VkDescriptorBufferInfo 指定 uniformBuffer, VkWriteDescriptorSet 将 uniformBuffer 和 descriptor set 关联起来，将 VkWriteDescriptorSet 提供给 vkUpdateDescriptorSets 来更新 descriptor set。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorSets</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25152;&#26377;&#30340; descriptor set &#20351;&#29992;&#30456;&#21516;&#30340; descriptor set layout</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkDescriptorSetLayout&gt; <span style="color: #7590db;">layouts</span>(swapChainImages.size(), descriptorSetLayout);
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    allocInfo.descriptorPool = descriptorPool;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor set layout &#25968;&#37327;</span>
    allocInfo.descriptorSetCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor set layout &#25968;&#25454;</span>
    allocInfo.pSetLayouts = layouts.data();

    descriptorSets.resize(swapChainImages.size());
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20998;&#37197;&#25351;&#23450;&#25968;&#37327;&#30340; descriptor set</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateDescriptorSets(device, &amp;allocInfo, descriptorSets.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate descriptor sets!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImages.size(); i++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">descriptor &#23545;&#24212;&#30340; buffer &#30340;&#20449;&#24687;</span>
        <span style="color: #ce537a; font-weight: bold;">VkDescriptorBufferInfo</span> <span style="color: #7590db;">bufferInfo</span>{};
        bufferInfo.buffer = uniformBuffers[i];
        bufferInfo.offset = 0;
        bufferInfo.range = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(UniformBufferObject);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26356;&#26032; descriptor set &#25152;&#20351;&#29992;&#30340;&#37197;&#32622;&#20449;&#24687;</span>
        <span style="color: #ce537a; font-weight: bold;">VkWriteDescriptorSet</span> <span style="color: #7590db;">descriptorWrite</span>{};
        descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#34987;&#26356;&#26032;&#30340; descriptor set </span>
        descriptorWrite.dstSet = descriptorSets[i];
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#34987;&#26356;&#26032;&#30340; descriptor set &#30340; binding</span>
        descriptorWrite.dstBinding = 0;
        descriptorWrite.dstArrayElement = 0;
        descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descriptorWrite.descriptorCount = 1;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor &#24341;&#29992;&#30340; buffer &#25968;&#25454;</span>
        descriptorWrite.pBufferInfo = &amp;bufferInfo;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor &#24341;&#29992;&#30340; image &#25968;&#25454;</span>
        descriptorWrite.pImageInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor &#24341;&#29992;&#30340; buffer view</span>
        descriptorWrite.pTexelBufferView = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; descriptor sets</span>
        vkUpdateDescriptorSets(device, 1, &amp;descriptorWrite, 0, <span style="color: #a45bad;">nullptr</span>);
    }
}
</pre>
</div>

<p>
vkUpdateDescriptorSets 接受两种类型的数组参数：VkWriteDescriptorSet 类型数组参数和 VkCopyDescriptorSet 类型数组参数。后者用于将 descriptor sets 从一个 copy 给另一个。<br />
</p>
</div>
</div>
<div id="outline-container-orgc64a6e4" class="outline-5">
<h5 id="orgc64a6e4">Using descriptor sets (197)</h5>
<div class="outline-text-5" id="text-orgc64a6e4">
<p>
现在我们还需要在 CommandBuffer 开始记录后，将 descriptorSet 和 command buffer 关联起来。updateUniformBuffer 处理了窗口尺寸修改的问题，因此我们不需要在 recreateSwapChain 中重新创建 descriptor set。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createCommandBuffers</span>()
{
    commandBuffers.resize(swapChainFramebuffers.size());
    <span style="color: #ce537a; font-weight: bold;">VkCommandBufferAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; CommandBuffers</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate command buffers!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; commandBuffers.size(); i++)
    {
        <span style="color: #ce537a; font-weight: bold;">VkCommandBufferBeginInfo</span> <span style="color: #7590db;">beginInfo</span>{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;</span>
        beginInfo.flags = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        beginInfo.pInheritanceInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; command buffers &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to begin recording command buffer!"</span>);
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#22987; render pass</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; command buffer &#21644; pipeline</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; vertex buffer</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; index buffer</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; command buffer &#21644; descriptor set</span>
        vkCmdBindDescriptorSets(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;descriptorSets[i], 0, <span style="color: #a45bad;">nullptr</span>);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#32472;&#21046;&#21629;&#20196;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);</span>
        vkCmdDrawIndexed(commandBuffers[i], <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(indices.size()), 1, 0, 0, 0);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; render pass</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32467;&#26463; command buffer &#35760;&#24405;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) 
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to record command buffer!"</span>);
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org196d419" class="outline-5">
<h5 id="org196d419">Alignment requirements (199)</h5>
<div class="outline-text-5" id="text-org196d419">
<p>
前面我们没有详细描述如何让 c++中的数据结构和 shader 中的 uniform 结构所表示的数据完全匹配，很显然两边都应该使用相同的类型，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> {
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
};

layout(binding = 0) <span style="color: #ce537a; font-weight: bold;">uniform</span> <span style="color: #7590db;">UniformBufferObject</span> {
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
} ubo;
</pre>
</div>
<p>
但是，只是这样做还不够，如果将数据结构改为如下定义，就会发现有颜色的方块会消失！<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> {
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">foo</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
};

layout(binding = 0) <span style="color: #ce537a; font-weight: bold;">uniform</span> <span style="color: #7590db;">UniformBufferObject</span> {
    <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">foo</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
} ubo;
</pre>
</div>
<p>
上面的问题是由于内存对齐(alignment)导致的。Vulkan 要求数据结构中的数据需要以特定方式对齐，具体如下：<br />
</p>
<ul class="org-ul">
<li>标量必须按 4 字节对齐<br /></li>
<li>vec2 必须按照 2*4=8 字节对齐<br /></li>
<li>vec3 或 vec4 必须按照 4*4=16 字节对齐<br /></li>
<li>嵌套结构必须按照其成员的基本对齐方式四舍五入为 16 的倍数来对齐<br /></li>
<li><p>
mat4 的对齐方式和 vec4 对齐方式相同<br />
</p>

<p>
我们原来的数据结构已经满足了对齐要求。每个 mat 是 4*4*4=64 字节，model 的偏移为 0，view 的偏移为 64，proj 的偏移为 128。所有偏移量都是 16 的整数倍。而新的结构中，vec2 只有 8 字节，这打乱了对齐要求。现在 model 的偏移为 8，view 的偏移为 72，proj 的偏移为 136，这三个矩阵的偏移都不是 16 的整数倍。可以使用 c++11 中提供的 alignas 指示符来解决该问题。<br />
</p></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> {
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">foo</span>;
    alignas(16) <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
};
</pre>
</div>
<p>
也可以在 include GLM 之前定义 GLM_FORCE_DEFAULT_ALIGNED_GENTYPES 宏来解决该问题，这会强制 GLM 使用满足对齐要求的 vec2 和 mat4 类型，其自动使用了特定的 alignas 指示符。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">GLM_FORCE_RADIANS</span>
<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;glm/glm.hpp&gt;</span>
</pre>
</div>

<p>
不幸的是当你使用嵌套结构时，上面这种方法会失效。考虑如下代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cpp</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Foo</span> {
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">v</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> {
    <span style="color: #ce537a; font-weight: bold;">Foo</span> <span style="color: #7590db;">f1</span>;
    <span style="color: #ce537a; font-weight: bold;">Foo</span> <span style="color: #7590db;">f2</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">shader</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span>
{
    <span style="color: #ce537a; font-weight: bold;">Foo</span> <span style="color: #7590db;">f1</span>;
    alignas(16) <span style="color: #ce537a; font-weight: bold;">Foo</span> <span style="color: #7590db;">f2</span>;
};
</pre>
</div>

<p>
此时 c++中 f2 的偏移量为 8，而 Vulkan 要求为 16，此时需要你自己指定正确的 alignas 指示符。为了避免对齐要求的错误，建议始终都自己来指定 alignas 指示符：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">UniformBufferObject</span> {
    alignas(16) <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    alignas(16) <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">view</span>;
    alignas(16) <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">proj</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orga69e178" class="outline-5">
<h5 id="orga69e178">Multiple descriptor sets (201)</h5>
<div class="outline-text-5" id="text-orga69e178">
<p>
事实上可以同时绑定多个 descriptor sets。在创建 pipeline layout 时，你需要为每个 descriptor set 指定一个 descriptor layout。在 shader 就中可以用如下方式引用特定的 descriptor set 了：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">layout(set = 0, binding = 0) <span style="color: #ce537a; font-weight: bold;">uniform</span> <span style="color: #7590db;">UniformBufferObject</span> { ... }
</pre>
</div>
<p>
使用这个特性，可以将每个对象不同的 descriptors 和每个对象共享的 descriptors 放在不同的 descriptor sets 中，这样就可以在绘制调用之间避免很多 descriptors 的重新绑定，从而提高了性能。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org2277157" class="outline-3">
<h3 id="org2277157">Texture mapping</h3>
<div class="outline-text-3" id="text-org2277157">
<p>
在我们的应用程序中添加一个 texture 涉及到如下步骤：<br />
</p>
<ul class="org-ul">
<li>创建一个设备内存支持的 image 对象<br /></li>
<li>用一张图片文件的像素填充该 image 对象的内存<br /></li>
<li>创建一个 image sampler<br /></li>
<li>添加一个组合的 image sampler descriptor，从而可以从 texture 中采样颜色<br /></li>
</ul>

<p>
前面我们通过 swap chain 扩展自动创建过 image 对象，这里我们需要手动自己创建 image 对象，并为其填充数据。我们可以创建一个 staging 资源，然后将像素数据填充到 staging 资源中，再将 staging 中的数据 copy 到最终 image 对象的内存中。尽管，我们可以创建一个 staging image 来执行 copy，但是 Vulkan 也允许我们从一个 VkBuffer 中 copy 数据到 image 中，而且在某些硬件平台上，从 VkBuffer 中 copy 效率更高。<br />
</p>

<p>
创建 image 和创建 buffer 差别不大，也涉及到查询内存需求，申请设备内存，绑定对象和内存。但是，创建 image 时还需要额外考虑像素在内存中的布局(layout)。由于显卡的工作方式，简单地在内存中将像素按照一行一行存储可能并不会提高性能。对 image 执行任何操作时，你需要确保它们的布局对于执行的操作来说是优化的。image 可用的布局如下：<br />
</p>
<ul class="org-ul">
<li>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 对于展示操作是优化的<br /></li>
<li>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: 对于通过 fragment shader 写入颜色的操作是优化的<br /></li>
<li>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 作为转移操作（如：vkCmdCopyImageToBuffer）的数据源是优化的<br /></li>
<li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 作为转移操作（如：vkCmdCopyBufferToImage）的数据目标是优化的<br /></li>
<li>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 对于 shader 中的采样操作是优化的<br /></li>
</ul>

<p>
转换 image 的 layout 的常见方式是使用 pipeline barrier。pipeline barrier 主要用于同步对资源的访问操作，如：保证读 image 时，image 已经被写入完成。barriers 也可用于转换 image 的 layout，另外当 swap chain 中的 images 属于多个 queue families 时，若指定 image 的共享方式为 VK_SHARING_MODE_EXCLUSIVE，此时可以使用 barrier 来传递 image 的所有权。<br />
</p>
</div>
<div id="outline-container-org8c2f47e" class="outline-4">
<h4 id="org8c2f47e">Create texture image</h4>
<div class="outline-text-4" id="text-org8c2f47e">
</div>
<div id="outline-container-org7bcaef9" class="outline-5">
<h5 id="org7bcaef9">Image library (203)</h5>
<div class="outline-text-5" id="text-org7bcaef9">
<p>
我们使用 stb library 来进行图片数据加载,其支持大部分常见的图片格式，如 jpeg,png,bmp 以及 gif。该 library 只需要包含头文件就可以了，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">STB_IMAGE_IMPLEMENTATION</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;stb_image.h&gt;</span>

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">texWidth</span>, <span style="color: #7590db;">texHeight</span>, <span style="color: #7590db;">texChannels</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21152;&#36733;&#22270;&#29255;&#25968;&#25454;</span>
<span style="color: #ce537a; font-weight: bold;">stbi_uc</span>* <span style="color: #7590db;">pixels</span> = stbi_load(<span style="color: #2d9574;">"textures/texture.jpg"</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
</pre>
</div>
</div>
</div>

<div id="outline-container-org35453a2" class="outline-5">
<h5 id="org35453a2">create Image (206)</h5>
<div class="outline-text-5" id="text-org35453a2">
<p>
使用下面方法来创建一个 image：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createImage</span>(<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">height</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">VkImageTiling</span> <span style="color: #7590db;">tiling</span>, <span style="color: #ce537a; font-weight: bold;">VkImageUsageFlags</span> <span style="color: #7590db;">usage</span>, <span style="color: #ce537a; font-weight: bold;">VkMemoryPropertyFlags</span> <span style="color: #7590db;">properties</span>, <span style="color: #ce537a; font-weight: bold;">VkImage</span>&amp; <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkDeviceMemory</span>&amp; <span style="color: #7590db;">imageMemory</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; image object</span>
    <span style="color: #ce537a; font-weight: bold;">VkImageCreateInfo</span> <span style="color: #7590db;">imageInfo</span>{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#22270;&#29255;&#31867;&#22411; &#21487;&#20197;&#20026;1D 2D 3D</span>
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">extent &#25351;&#23450;&#20102;image&#30340;&#32500;&#24230;</span>
    imageInfo.extent.width = width;
    imageInfo.extent.height = height;
    imageInfo.extent.depth = 1;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20351;&#29992;&#22810;&#23569;&#32423; mipmap</span>
    imageInfo.mipLevels = 1;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#36148;&#22270;&#25968;&#32452;&#20803;&#32032;&#20010;&#25968;</span>
    imageInfo.arrayLayers = 1;
    imageInfo.format = format;
    imageInfo.tiling = tiling;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imageInfo.usage = usage;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21644;&#22810;&#37325;&#37319;&#26679;&#26377;&#20851;</span>
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">image &#21482;&#34987;&#19968;&#20010; queue family&#20351;&#29992;&#65292;&#35813;queue family &#25903;&#25345;&#22270;&#24418;&#25805;&#20316;&#65288;&#24403;&#28982;&#21516;&#26102;&#20063;&#25903;&#25345;&#20256;&#36755;&#25805;&#20316;&#65289;</span>
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imageInfo.flags = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateImage(device, &amp;imageInfo, <span style="color: #a45bad;">nullptr</span>, &amp;image) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create image!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26597;&#35810; image &#30340;&#20869;&#23384;&#38656;&#27714;</span>
    <span style="color: #ce537a; font-weight: bold;">VkMemoryRequirements</span> <span style="color: #7590db;">memRequirements</span>;
    vkGetImageMemoryRequirements(device, image, &amp;memRequirements);

    <span style="color: #ce537a; font-weight: bold;">VkMemoryAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; image &#20998;&#37197;&#23545;&#24212;&#30340;&#20869;&#23384;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateMemory(device, &amp;allocInfo, <span style="color: #a45bad;">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate image memory!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32465;&#23450; &#20869;&#23384; &#21644; image &#23545;&#35937;</span>
    vkBindImageMemory(device, image, imageMemory, 0);
}
</pre>
</div>
<p>
VkImageCreateInfo.tiling 可以有如下两个选项：<br />
</p>
<ul class="org-ul">
<li>VK_IMAGE_TILING_LINEAR  贴图图元以行主序排列，和像素数组一样<br /></li>
<li>VK_IMAGE_TILING_OPTIMAL 贴图图元以利于访问的方式排列<br /></li>
</ul>
<p>
和 image 的 layout 不同，tiling mode 在以后无法被修改。如果你要从图片的内存中直接访问图元，则你必须使用 VK_IMAGE_TILING_LINEAR。由于我们使用一个 staging buffer 而不是使用一个 staging image,因此不需要 image 的从内存中直接访问图元，我们将使用 VK_IMAGE_TILING_OPTIMAL 选项，以便从 shader 中访问贴图图元时非常高效。<br />
</p>

<p>
VkImageCreateInfo.initialLayout 有如下两个选项：<br />
</p>
<ul class="org-ul">
<li>VK_IMAGE_LAYOUT_UNDEFINED：GPU 不可用，第一个 transition 将丢弃纹素。<br /></li>
<li>VK_IMAGE_LAYOUT_PREINITIALIZED：GPU 不可用，但第一个 transition 将保留贴图图元。<br /></li>
</ul>
<p>
在一些情况下，在第一次 transition 期间，将贴图图元保留下来是非常必要的。例如，当你想使用一个 image 作为一个 staging image 且使用了 VK_IMAGE_TILING_LINEAR layout。此时你要将贴图图元数据上传到 staging image，然后将 staging image 转换为一个传输源，并且不能丢失数据。在本章实例中，我们首先将 image 转换为传输目标，然后将贴图图元数据从 buffer 对象复制到 image，所以我们不需要这个属性，可以安全地使用 VK_IMAGE_LAYOUT_UNDEFINED。<br />
</p>

<p>
VkImageCreateInfo.usage 的语义和创建 buffer 时的语义一样。在本章实例中，我们要将 image 作为传输目标，并且在 fragment shader 阶段对切图进行采样，因此使用如下设置：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
</pre>
</div>

<p>
VkImageCreateInfo.flags 和 sparse images 相关。Sparse images 类型的图片只会为特定的图片区域分配内存。例如：如果你为一个地形使用 3D 贴图，你可以使用该选项，从而避免为大块体积的空值分配内存。<br />
</p>
</div>
</div>
<div id="outline-container-orgb554b78" class="outline-5">
<h5 id="orgb554b78">Layout transitions (211)</h5>
<div class="outline-text-5" id="text-orgb554b78">
<p>
执行 layout 转换的最常见方式是使用一个 image memory barrier。这种类型的 pipeline barrier 通常用于同步对资源的访问，例如：确保对一个 buffer 的读取在对该 buffer 的写入完成之后进行。但是，其也可用于转换 image layouts 或转移 queue family 所有权。<br />
使用如下代码利用 image memory barrier 来转换 image layouts：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">transitionImageLayout</span>(<span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">oldLayout</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">newLayout</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">commandBuffer</span> = beginSingleTimeCommands();
    <span style="color: #ce537a; font-weight: bold;">VkImageMemoryBarrier</span> <span style="color: #7590db;">barrier</span>{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26087;&#30340; layout, &#33509;&#19981;&#20851;&#24515;&#26087;&#30340; layout &#26159;&#20160;&#20040;&#65292;&#21487;&#20197;&#20351;&#29992; VK_IMAGE_LAYOUT_UNDEFINED</span>
    barrier.oldLayout = oldLayout;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26032;&#30340; layout</span>
    barrier.newLayout = newLayout;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; barrier &#36716;&#25442; queue family &#30340;&#25152;&#26377;&#26435;&#26102;&#65292;&#25351;&#23450;&#19979;&#38754;&#20004;&#20010;&#21442;&#25968;&#65292;&#25105;&#20204;&#20351;&#29992; barrier &#36716;&#25442; image layout&#65292;&#25925;&#20351;&#29992; VK_QUEUE_FAMILY_IGNORED</span>
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21463;&#24433;&#21709;&#30340; image</span>
    barrier.image = image;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">subresourceRange &#25351;&#23450;&#21463;&#24433;&#21709;&#30340; image &#30340;&#37096;&#20998;</span>
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    <span style="color: #ce537a; font-weight: bold;">VkPipelineStageFlags</span> <span style="color: #7590db;">sourceStage</span>;
    <span style="color: #ce537a; font-weight: bold;">VkPipelineStageFlags</span> <span style="color: #7590db;">destinationStage</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        barrier.srcAccessMask = 0;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::invalid_argument(<span style="color: #2d9574;">"unsupported layout transition!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25152;&#26377;&#31867;&#22411;&#30340;pipeline barriers &#37117;&#20351;&#29992; vkCmdPipelineBarrier &#20989;&#25968;&#36827;&#34892;&#25552;&#20132;</span>
    vkCmdPipelineBarrier(
        commandBuffer,
        sourceStage, destinationStage,
        0,
        0, <span style="color: #a45bad;">nullptr</span>,
        0, <span style="color: #a45bad;">nullptr</span>,
        1, &amp;barrier
        );

    endSingleTimeCommands(commandBuffer);
}
</pre>
</div>
<p>
barriers 主要用于同步，你必须指定在 barrier 之前资源相关的哪些操作必须已经发生，以及资源相关的哪些操作必须在 barriers 上进行等待。尽管已经使用 vkQueueWaitIdle 进行了手动同步，我们仍然需要指定 srcAccessMask 和 dstAccessMask。所有类型的 pipeline barriers 都使用 vkCmdPipelineBarrier 函数进行提交:<br />
</p>

<p>
vkCmdPipelineBarrier 函数的第 2 个参数 sourceStage 指定在哪个 pipeline stage 时 srcAcccessMask 指定的操作应该在 barrier 之前发生。<br />
vkCmdPipelineBarrier 函数的第 3 个参数 destinationStage 指定在哪个 pipeline stage 时 dstAcccessMask 指定的操作应该在 barrier 上进行等待。<br />
例如：如果你想在 barrier 之后在 VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT 读取一个 uniform，你可以为 dstAccessMask 使用 VK_ACCESS_UNIFORM_READ_BIT 选项。<br />
vkCmdPipelineBarrier 函数的第 4 个参数 dependencyFlags 可以为 0 也可以为 VK_DEPENDENCY_BY_REGION_BIT。VK_DEPENDENCY_BY_REGION_BIT 表示将 barrier 转变为 per-region 条件。这意味着资源以及被写入的部分已经允许被读取(不需要所有部分都被写入完成)。<br />
vkCmdPipelineBarrier 函数的第 5、6 个参数 memoryBarrierCount,pMemoryBarriers 指定提交的 memory barriers。<br />
vkCmdPipelineBarrier 函数的第 7、8 个参数 bufferMemoryBarrierCount,pBufferMemoryBarriers 指定提交的 buffer barriers。<br />
vkCmdPipelineBarrier 函数的第 9、10 个参数 imageMemoryBarrierCount,pImageMemoryBarriers 指定提交的 image barriers。<br />
</p>
</div>
</div>

<div id="outline-container-org3e2c207" class="outline-5">
<h5 id="org3e2c207">Copying buffer to image (214)</h5>
<div class="outline-text-5" id="text-org3e2c207">
<p>
使用如下方法将 buffer 中数据 copy 到 image 中：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">copyBufferToImage</span>(<span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">height</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">commandBuffer</span> = beginSingleTimeCommands();
    <span style="color: #ce537a; font-weight: bold;">VkBufferImageCopy</span> <span style="color: #7590db;">region</span>{};
    region.bufferOffset = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bufferRowLength bufferImageHeight &#25351;&#23450;&#20687;&#32032;&#22312;&#20869;&#23384;&#20013;&#22914;&#20309;&#20998;&#24067;&#30340;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20320;&#21487;&#20197;&#22312;image&#30340;&#27599;&#34892;&#25968;&#25454;&#20043;&#38388;&#22635;&#20805;&#19968;&#20123;&#23383;&#33410;&#65292;&#37117;&#20026;0&#26102;&#34920;&#31034;&#20687;&#32032;&#25968;&#25454;&#32039;&#23494;&#25490;&#21015;</span>
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;

    region.imageOffset = { 0, 0, 0 };
    region.imageExtent = { width, height, 1 };

    vkCmdCopyBufferToImage(
        commandBuffer,
        buffer,
        image,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        1,
        &amp;region
        );
    endSingleTimeCommands(commandBuffer);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb579905" class="outline-5">
<h5 id="orgb579905">Preparing the texture image (215)</h5>
<div class="outline-text-5" id="text-orgb579905">
<p>
创建 texture image 的完整操作如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createTextureImage</span>()
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">texWidth</span>, <span style="color: #7590db;">texHeight</span>, <span style="color: #7590db;">texChannels</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21152;&#36733;&#22270;&#29255;&#25991;&#20214;</span>
    <span style="color: #ce537a; font-weight: bold;">stbi_uc</span>* <span style="color: #7590db;">pixels</span> = stbi_load(<span style="color: #2d9574;">"texture.jpg"</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
    <span style="color: #ce537a; font-weight: bold;">VkDeviceSize</span> <span style="color: #7590db;">imageSize</span> = texWidth * texHeight * 4;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>pixels) {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to load texture image!"</span>);
    }

    <span style="color: #ce537a; font-weight: bold;">VkBuffer</span> <span style="color: #7590db;">stagingBuffer</span>;
    <span style="color: #ce537a; font-weight: bold;">VkDeviceMemory</span> <span style="color: #7590db;">stagingBufferMemory</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; staging buffer</span>
    createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);
    <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">data</span>;
    vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &amp;data);
    memcpy(data, pixels, <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">size_t</span>&gt;(imageSize));
    vkUnmapMemory(device, stagingBufferMemory);

    createImage(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;image &#30340; layout &#20174; VK_IMAGE_LAYOUT_UNDEFINED &#36716;&#25442;&#20026; VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</span>
    transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#22270;&#29255;&#25968;&#25454;&#20174;buffer copy &#21040; image &#23545;&#24212;&#30340;&#20869;&#23384;&#20013;</span>
    copyBufferToImage(stagingBuffer, textureImage, <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(texWidth), <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(texHeight));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;image &#30340; layout &#20174; VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &#36716;&#25442;&#20026; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span>
    transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38144;&#27585; staging buffer</span>
    vkDestroyBuffer(device, stagingBuffer, <span style="color: #a45bad;">nullptr</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37322;&#25918; staging buffer &#20851;&#32852;&#30340;&#20869;&#23384;</span>
    vkFreeMemory(device, stagingBufferMemory, <span style="color: #a45bad;">nullptr</span>);
}
</pre>
</div>

<p>
我们需要处理两个 image layout 转换：<br />
</p>
<ul class="org-ul">
<li>Undefined -&gt; transfer destination: 数据转移的写操作不需要做任何等待<br /></li>
<li>transfer destination -&gt; shader reading: shader 中读取操作需要等待数据转移的写操作完成。<br /></li>
</ul>
<p>
因此，我们在 transitionImageLayout 函数中依据 oldLayout 和 newLayout 来设置 VkImageMemoryBarrier 的 srcAccessMask、dstAccessMask 成员，以及 vkCmdPipelineBarrier 的 sourceStage、destinationStage 参数。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">transitionImageLayout</span>(<span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">oldLayout</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">newLayout</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">commandBuffer</span> = beginSingleTimeCommands();
    <span style="color: #ce537a; font-weight: bold;">VkImageMemoryBarrier</span> <span style="color: #7590db;">barrier</span>{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26087;&#30340; layout, &#33509;&#19981;&#20851;&#24515;&#26087;&#30340; layout &#26159;&#20160;&#20040;&#65292;&#21487;&#20197;&#20351;&#29992; VK_IMAGE_LAYOUT_UNDEFINED</span>
    barrier.oldLayout = oldLayout;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#26032;&#30340; layout</span>
    barrier.newLayout = newLayout;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; barrier &#36716;&#25442; queue family &#30340;&#25152;&#26377;&#26435;&#26102;&#65292;&#25351;&#23450;&#19979;&#38754;&#20004;&#20010;&#21442;&#25968;&#65292;&#25105;&#20204;&#20351;&#29992; barrier &#36716;&#25442; image layout&#65292;&#25925;&#20351;&#29992; VK_QUEUE_FAMILY_IGNORED</span>
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#21463;&#24433;&#21709;&#30340; image</span>
    barrier.image = image;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">subresourceRange &#25351;&#23450;&#21463;&#24433;&#21709;&#30340; image &#30340;&#37096;&#20998;</span>
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    <span style="color: #ce537a; font-weight: bold;">VkPipelineStageFlags</span> <span style="color: #7590db;">sourceStage</span>;
    <span style="color: #ce537a; font-weight: bold;">VkPipelineStageFlags</span> <span style="color: #7590db;">destinationStage</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">barriers &#20027;&#35201;&#29992;&#20110;&#21516;&#27493;&#65292;&#20320;&#24517;&#39035;&#25351;&#23450;&#22312;barrier&#20043;&#21069;&#36164;&#28304;&#30456;&#20851;&#30340;&#21738;&#20123;&#25805;&#20316;&#24517;&#39035;&#24050;&#32463;&#21457;&#29983;&#65292;&#20197;&#21450;&#24517;&#39035;&#22312;barriers&#19978;&#31561;&#24453;&#36164;&#28304;&#30456;&#20851;&#30340;&#21738;&#20123;&#25805;&#20316;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19981;&#25191;&#34892;&#20219;&#20309;&#25805;&#20316;&#65292;&#22240;&#27492;&#19981;&#36827;&#34892;&#20219;&#20309;&#31561;&#24453;</span>
        barrier.srcAccessMask = 0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#36716;&#31227;&#25968;&#25454;&#30340;&#20889;&#25805;&#20316;</span>
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT &#38454;&#27573;&#26102;&#65292;&#19981;&#36827;&#34892;&#20219;&#20309;&#31561;&#24453;</span>
        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_TRANSFER_BIT &#38454;&#27573;&#26102;&#65292;&#36716;&#31227;&#25968;&#25454;&#30340;&#20889;&#25805;&#20316;&#38656;&#35201;&#22312; barrier &#19978;&#25191;&#34892;&#31561;&#24453;</span>
        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#36716;&#31227;&#25968;&#25454;&#30340;&#20889;&#25805;&#20316;</span>
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#25968;&#25454;&#35835;&#21462;&#25805;&#20316;</span>
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_TRANSFER_BIT &#38454;&#27573;&#26102;&#65292;&#36716;&#31227;&#25968;&#25454;&#30340;&#20889;&#20837;&#25805;&#20316;&#38656;&#35201;&#22312; barrier &#20043;&#21069;&#23436;&#25104;</span>
        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT &#38454;&#27573;&#26102;&#65292;shader&#20013;&#35835;&#21462;&#25968;&#25454;&#30340;&#25805;&#20316;&#38656;&#35201;&#22312; barrier&#19978;&#25191;&#34892;&#31561;&#24453;</span>
        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::invalid_argument(<span style="color: #2d9574;">"unsupported layout transition!"</span>);
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25152;&#26377;&#31867;&#22411;&#30340;pipeline barriers &#37117;&#20351;&#29992; vkCmdPipelineBarrier &#20989;&#25968;&#36827;&#34892;&#25552;&#20132;</span>
    vkCmdPipelineBarrier(
        commandBuffer,
        sourceStage, destinationStage,
        0,
        0, <span style="color: #a45bad;">nullptr</span>,
        0, <span style="color: #a45bad;">nullptr</span>,
        1, &amp;barrier
        );

    endSingleTimeCommands(commandBuffer);
}
</pre>
</div>

<p>
VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT 并不是图形或计算管线的一个真实阶段，其为转移数据时的一个伪阶段。<br />
</p>

<p>
需要注意的是 vkCmdPipelineBarrier 函数提交 commandBuffer 会在开始时导致隐式 VK_ACCESS_HOST_WRITE_BIT 同步。 由于 transitionImageLayout 函数执行的 commandBuffer 中只有一个命令，如果你在布局转换中需要依赖 VK_ACCESS_HOST_WRITE_BIT ，可以使用这种隐式同步并将 srcAccessMask 设置为 0。是否显示地做这类事情取决于你自己，但我个人并不喜欢依赖这些类似 OpenGL 的“隐藏”操作。<br />
</p>

<p>
VK_IMAGE_LAYOUT_GENERAL 类型的 image layout 支持所有的操作，但是其性能不是最佳的。在某些特殊情况下可能需要使用这种 image layout, 如： 将一个 image 即作为输入又作为输出时，又或者在初始化 image 的 layout 后，又需要对 image 进行读取时。<br />
</p>

<p>
目前 createTextureImage 中的 transitionImageLayout、copyBufferToImage 被放在多个 command buffers 中同步执行，我们建议应该将所有这些操作放到一个一个 command buffer 中异步执行，从而提高吞吐量。你可以创建一个 command buffer 然后将命令记录在该 command buffer 中，然后再执行该 command buffer 中记录的所有命令。最好在纹理映射工作后执行此操作，以检查纹理资源是否仍然正确设置。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga1204c3" class="outline-4">
<h4 id="orga1204c3">Image view and sampler (219)</h4>
<div class="outline-text-4" id="text-orga1204c3">
</div>
<div id="outline-container-org2f55540" class="outline-5">
<h5 id="org2f55540">Texture image view (219)</h5>
<div class="outline-text-5" id="text-org2f55540">
<p>
使用如下方法创建 texture iamge view：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkImageView</span> <span style="color: #bc6ec5; font-weight: bold;">createImageView</span>(<span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkImageViewCreateInfo</span> <span style="color: #7590db;">viewInfo</span>{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = image;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = format;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">subresourceRange &#29992;&#20110;&#25551;&#36848; image &#30340;&#29992;&#36884;&#65292;&#20197;&#21450;&#24212;&#35813;&#35775;&#38382; image &#30340;&#21738;&#20010;&#37096;&#20998;</span>
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; mipmapping &#32423;&#21035;&#21482;&#26377;&#19968;&#32423; (&#21363; &#19981;&#20351;&#29992;mipmap)</span>
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; layer &#21482;&#26377;&#19968;&#20010;</span>
    viewInfo.subresourceRange.layerCount = 1;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">components &#36873;&#39033;&#21487;&#20197;&#35753;&#20320;&#35843;&#25972;&#39068;&#33394;&#36890;&#36947;&#65292;&#22914;&#65306;&#23558;&#25152;&#26377;&#36890;&#36947;&#26144;&#23556;&#20026; r &#36890;&#36947;&#65307;&#25110;&#32773;&#23558; r &#36890;&#36947;&#26144;&#23556;&#20026; g &#36890;&#36947;&#65292;&#23558; g &#36890;&#36947;&#26144;&#23556;&#20026; r &#36890;&#36947; </span>
    viewInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;

    <span style="color: #ce537a; font-weight: bold;">VkImageView</span> <span style="color: #7590db;">imageView</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateImageView(device, &amp;viewInfo, <span style="color: #a45bad;">nullptr</span>, &amp;imageView) != VK_SUCCESS) {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create texture image view!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">return</span> imageView;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf4e7e80" class="outline-5">
<h5 id="orgf4e7e80">Samplers (221)</h5>
<div class="outline-text-5" id="text-orgf4e7e80">
<p>
shader 可以直接从 images 中读取贴图图元，但是当 images 作为 textures 时，通常不会这样使用。一般会通过 samplers 来访问 textures，samplers 会应用滤波变换来计算最终的颜色。<br />
这些 filters 对于处理采样过密(oversampling)问题很有帮助。贴图被映射到几何体时，若对应的 fragments 比贴图图元多时，如果你只是简单地选取离像素最近的贴图图元，你会得到如下左边的图片。如果你联合最近的 4 个贴图图元，进行线性插值得到最终颜色，你将得到如下右边比较平滑的图片：<br />
<img src="./Vulkan/texture_filtering.png" alt="texture_filtering.png" /><br />
</p>

<p>
Undersampling 是一个和 oversampling 刚好相反的问题，此时一个 fragment 对应多个贴图图元。通过预过滤贴图生成 mipmap，采样时使用合适的 mipmap level 贴图可以消除这种问题。对于不同方向对应贴图图元数量不一致的问题还需要开启各向异性过滤。<br />
<img src="./Vulkan/texture_undersampling.jpg" alt="texture_undersampling.jpg" /><br />
</p>

<p>
除了 filters 外，sampler 还会处理 transformations。transformations 决定了当读取 image 外的图元时所得到的最终颜色值。下图展示了几种可选的模式：<br />
<img src="./Vulkan/texture_addressing.png" alt="texture_addressing.png" /><br />
</p>

<p>
使用如下代码来创建 sampler：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createTextureSampler</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkSamplerCreateInfo</span> <span style="color: #7590db;">samplerInfo</span>{};
    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VK_FILTER_NEAREST</span>
    samplerInfo.magFilter = VK_FILTER_LINEAR;
    samplerInfo.minFilter = VK_FILTER_LINEAR;
    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.anisotropyEnable = VK_TRUE;
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceProperties</span> <span style="color: #7590db;">properties</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#29289;&#29702;&#35774;&#22791;&#25903;&#25345;&#30340;&#26368;&#22823;&#30340;&#21508;&#21521;&#24322;&#24615;&#37319;&#26679;&#30340;&#26679;&#26412;&#25968;&#37327;</span>
    vkGetPhysicalDeviceProperties(physicalDevice, &amp;properties);
    samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#36793;&#30028;&#30340;&#39068;&#33394;</span>
    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unnormalizedCoordinates = VK_TRUE &#26102;&#65292;&#21487;&#20197;&#20351;&#29992;[0,texWidth) [0,texHeight) &#33539;&#22260;&#30340;&#36148;&#22270;&#22352;&#26631;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unnormalizedCoordinates = VK_FALSE &#26102;&#65292;&#24517;&#39035;&#20351;&#29992;[0,1) &#33539;&#22260;&#30340;&#36148;&#22270;&#22352;&#26631;</span>
    samplerInfo.unnormalizedCoordinates = VK_FALSE;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compareEnable = VK_TRUE &#26102;&#65292;&#20250;&#20808;&#23558;&#22270;&#20803;&#21644;&#19968;&#20010;&#20540;&#36827;&#34892;&#27604;&#36739;&#65292;&#27604;&#36739;&#30340;&#32467;&#26524;&#20250;&#34987;&#29992;&#20110;&#36807;&#28388;&#25805;&#20316;&#12290;&#20027;&#35201;&#29992;&#20110;&#23545;shadow map&#36827;&#34892;PCF(percentage-closer filtering)&#12290;</span>
    samplerInfo.compareEnable = VK_FALSE;
    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    samplerInfo.mipLodBias = 0.0f;
    samplerInfo.minLod = 0.0f;
    samplerInfo.maxLod = 0.0f;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateSampler(device, &amp;samplerInfo, <span style="color: #a45bad;">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create texture sampler!"</span>);
    }
}
</pre>
</div>
<p>
下面代码可以用来判断物理设备是否支持各向异性采样：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isDeviceSuitable</span>(<span style="color: #ce537a; font-weight: bold;">VkPhysicalDevice</span> <span style="color: #7590db;">device</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceFeatures</span> <span style="color: #7590db;">supportedFeatures</span>;
    vkGetPhysicalDeviceFeatures(device, &amp;supportedFeatures);

    <span style="color: #4f97d7; font-weight: bold;">return</span> indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgef04c32" class="outline-4">
<h4 id="orgef04c32">Combined image sampler (227)</h4>
<div class="outline-text-4" id="text-orgef04c32">
<p>
之前我们在 uniform buffer 相关的章节中已经接触过 descriptors。本章我们将使用一种新类型的 descriptor: combined image sampler。该 descriptor 使得 shaders 可以通过使用过一个 sampler 对象来访问 image 资源。首先，我们修改 descriptor layout, descriptor pool 以及 descriptor set 其它们都包含 combined image sampler descriptor；然后，将贴图坐标添加到 Vertex 结构体中；最后，修改 fragment shader 从 texture 中读取颜色。<br />
</p>
</div>
<div id="outline-container-org7aaa272" class="outline-5">
<h5 id="org7aaa272">Updating the descriptors (227)</h5>
<div class="outline-text-5" id="text-org7aaa272">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorSetLayout</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutBinding</span> <span style="color: #7590db;">uboLayoutBinding</span>{};
    uboLayoutBinding.binding = 0;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    uboLayoutBinding.pImmutableSamplers = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; combined image sampler descriptor &#28155;&#21152; VkDescriptorSetLayoutBinding</span>
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutBinding</span> <span style="color: #7590db;">samplerLayoutBinding</span>{};
    samplerLayoutBinding.binding = 1;
    samplerLayoutBinding.descriptorCount = 1;
    samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    samplerLayoutBinding.pImmutableSamplers = <span style="color: #a45bad;">nullptr</span>;
    samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutBinding</span>, 2&gt; <span style="color: #7590db;">bindings</span> = { uboLayoutBinding, samplerLayoutBinding };
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetLayoutCreateInfo</span> <span style="color: #7590db;">layoutInfo</span>{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(bindings.size());
    layoutInfo.pBindings = bindings.data();

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, <span style="color: #a45bad;">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create descriptor set layout!"</span>);
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorPool</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkDescriptorPoolSize, 2&gt; <span style="color: #7590db;">poolSizes</span>{};
    poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    poolSizes[0].descriptorCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026; combined image sampler descriptor &#22686;&#22823; descriptor pool &#30340;&#31354;&#38388;</span>
    poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    poolSizes[1].descriptorCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());

    <span style="color: #ce537a; font-weight: bold;">VkDescriptorPoolCreateInfo</span> <span style="color: #7590db;">poolInfo</span>{};
    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    poolInfo.poolSizeCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(poolSizes.size());
    poolInfo.pPoolSizes = poolSizes.data();
    poolInfo.maxSets = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());

    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateDescriptorPool(device, &amp;poolInfo, <span style="color: #a45bad;">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create descriptor pool!"</span>);
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDescriptorSets</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25152;&#26377;&#30340; descriptor set &#20351;&#29992;&#30456;&#21516;&#30340; descriptor set layout</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;VkDescriptorSetLayout&gt; <span style="color: #7590db;">layouts</span>(swapChainImages.size(), descriptorSetLayout);
    <span style="color: #ce537a; font-weight: bold;">VkDescriptorSetAllocateInfo</span> <span style="color: #7590db;">allocInfo</span>{};
    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    allocInfo.descriptorPool = descriptorPool;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor set layout &#25968;&#37327;</span>
    allocInfo.descriptorSetCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(swapChainImages.size());
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; descriptor set layout &#25968;&#25454;</span>
    allocInfo.pSetLayouts = layouts.data();

    descriptorSets.resize(swapChainImages.size());
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20998;&#37197;&#25351;&#23450;&#25968;&#37327;&#30340; descriptor set</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkAllocateDescriptorSets(device, &amp;allocInfo, descriptorSets.data()) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to allocate descriptor sets!"</span>);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImages.size(); i++)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">descriptor &#23545;&#24212;&#30340; buffer &#30340;&#20449;&#24687;</span>
        <span style="color: #ce537a; font-weight: bold;">VkDescriptorBufferInfo</span> <span style="color: #7590db;">bufferInfo</span>{};
        bufferInfo.buffer = uniformBuffers[i];
        bufferInfo.offset = 0;
        bufferInfo.range = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(UniformBufferObject);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">descriptor &#23545;&#24212;&#30340; image &#30340;&#20449;&#24687;</span>
        <span style="color: #ce537a; font-weight: bold;">VkDescriptorImageInfo</span> <span style="color: #7590db;">imageInfo</span>{};
        imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        imageInfo.imageView = textureImageView;
        imageInfo.sampler = textureSampler;

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkWriteDescriptorSet, 2&gt; <span style="color: #7590db;">descriptorWrites</span>{};
        descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptorWrites[0].dstSet = descriptorSets[i];
        descriptorWrites[0].dstBinding = 0;
        descriptorWrites[0].dstArrayElement = 0;
        descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descriptorWrites[0].descriptorCount = 1;
        descriptorWrites[0].pBufferInfo = &amp;bufferInfo;
        descriptorWrites[0].pImageInfo = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
        descriptorWrites[0].pTexelBufferView = <span style="color: #a45bad;">nullptr</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; descriptor set &#23558; combined image sampler descriptor &#21644; &#26368;&#32456;&#30340;&#22270;&#29255;&#32465;&#23450;&#22312;&#19968;&#36215;</span>
        descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptorWrites[1].dstSet = descriptorSets[i];
        descriptorWrites[1].dstBinding = 1;
        descriptorWrites[1].dstArrayElement = 0;
        descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        descriptorWrites[1].descriptorCount = 1;
        descriptorWrites[1].pImageInfo = &amp;imageInfo;
        vkUpdateDescriptorSets(device, <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(descriptorWrites.size()), descriptorWrites.data(), 0, <span style="color: #a45bad;">nullptr</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c6c26c" class="outline-5">
<h5 id="org0c6c26c">Texture coordinates and Shaders (231)</h5>
<div class="outline-text-5" id="text-org0c6c26c">
<p>
顶点数据中包含贴图坐标以及 shader 中采样贴图都比较简单，不啰嗦了。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org989d292" class="outline-3">
<h3 id="org989d292">Depth buffering (236)</h3>
<div class="outline-text-3" id="text-org989d292">
</div>
<div id="outline-container-orga9fc45a" class="outline-4">
<h4 id="orga9fc45a">Depth image and view (239)</h4>
<div class="outline-text-4" id="text-orga9fc45a">
<p>
和 texture image 不同，我们不必为 depth image 指定一个特定的格式，因为我们不会在程序中直接访问 depth image。depth image 的格式只要有合理的精确度就可以了，通常最少为 24 位。下面这些格式都符合该要求：<br />
</p>
<ul class="org-ul">
<li>VK_FORMAT_D32_SFLOAT: 32-bit 有符号浮点数用于存储深度值<br /></li>
<li>VK_FORMAT_D32_SFLOAT_S8_UINT: 32-bit 有符号浮点数用于存储深度值，8bit 无符号整数用于 stencil 值<br /></li>
<li>VK_FORMAT_D24_UNORM_S8_UINT: 24-bit 无符号归一化浮点数用于存储深度值，8bit 无符号整数用于 stencil 值<br /></li>
</ul>

<p>
我们使用如下方法得到最终所选的格式：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #bc6ec5; font-weight: bold;">findDepthFormat</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> findSupportedFormat (
        {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT}, <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20102;&#36866;&#21512;&#25105;&#20204;&#30340;depth format</span>
        VK_IMAGE_TILING_OPTIMAL,                                                           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20102;&#25105;&#20204;&#25152;&#20351;&#29992;&#30340; depth image&#30340;tiling mode</span>
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);                                   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#20102;&#25105;&#20204;&#38656;&#35201;&#30340;&#29305;&#24615;</span>
}
<span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #bc6ec5; font-weight: bold;">findSupportedFormat</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkFormat</span>&gt;&amp; <span style="color: #7590db;">candidates</span>, <span style="color: #ce537a; font-weight: bold;">VkImageTiling</span> <span style="color: #7590db;">tiling</span>, <span style="color: #ce537a; font-weight: bold;">VkFormatFeatureFlags</span> <span style="color: #7590db;">features</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span> : candidates) 
    {
        <span style="color: #ce537a; font-weight: bold;">VkFormatProperties</span> <span style="color: #7590db;">props</span>;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);

        <span style="color: #4f97d7; font-weight: bold;">if</span> (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> format;
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> format;
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to find supported format!"</span>);
}
</pre>
</div>
<p>
VkFormatProperties 结构体有如下三个成员：<br />
</p>
<ul class="org-ul">
<li>linearTilingFeatures: VkFormatFeatureFlagBits 类型的位掩码，指定了 images 支持的特性，这些 images 是使用 VK_IMAGE_TILING_LINEAR 参数创建的<br /></li>
<li>optimalTilingFeatures: VkFormatFeatureFlagBits 类型的位掩码，指定了 images 支持的特性，这些 images 是使用 VK_IMAGE_TILING_OPTIMAL 参数创建的<br /></li>
<li>bufferFeatures: VkFormatFeatureFlagBits 类型的位掩码，指定了 buffers 所支持的特性<br /></li>
</ul>

<p>
在创建 depth image view 时，需要将 VkImageViewCreateInfo 结构体的 subresourceRange.aspectMask 成员指定为 VK_IMAGE_ASPECT_DEPTH_BIT，表示 image 的 depth 部分会被包含在 image view 中。<br />
</p>
</div>
</div>
<div id="outline-container-org0436317" class="outline-4">
<h4 id="org0436317">Explicitly transitioning the depth image</h4>
<div class="outline-text-4" id="text-org0436317">
<p>
我们不必显示地为 depth image 转换 layout，因为在 render pass 中会进行处理。但是为了完整性，依然在 createDepthResources 中添加了 transitionImageLayout 来处理 image layout 转换。<br />
一开始 depth image 中没有内容很重要，所以 VK_IMAGE_LAYOUT_UNDEFINED 可用作初始的 layout。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createDepthResources</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">transitionImageLayout</span>(<span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">format</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">oldLayout</span>, <span style="color: #ce537a; font-weight: bold;">VkImageLayout</span> <span style="color: #7590db;">newLayout</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36824;&#38656;&#35201;&#23558; barrier.subresourceRange.aspectMask &#25351;&#23450;&#20026; VK_IMAGE_ASPECT_DEPTH_BIT&#65292;&#33509;&#25105;&#20204;&#25152;&#20351;&#29992;&#30340; depth format &#21253;&#21547;&#20102; stencil&#65292;&#36824;&#38656;&#35201;&#21253;&#21547; VK_IMAGE_ASPECT_STENCIL_BIT</span>
        barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;

        <span style="color: #4f97d7; font-weight: bold;">if</span> (hasStencilComponent(format)) {
            barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19981;&#25191;&#34892;&#20219;&#20309;&#25805;&#20316;&#65292;&#22240;&#27492;&#19981;&#36827;&#34892;&#20219;&#20309;&#31561;&#24453;</span>
        barrier.srcAccessMask = 0;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;depth stencil &#35835;&#12289;&#20889;&#25805;&#20316;</span>
        barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT &#38454;&#27573;&#26102;&#65292;&#19981;&#36827;&#34892;&#20219;&#20309;&#31561;&#24453;</span>
        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT &#38454;&#27573;&#26102;&#65292;depth stencil &#35835;&#12289;&#20889;&#25805;&#20316;&#38656;&#35201;&#22312; barrier &#19978;&#25191;&#34892;&#31561;&#24453;</span>
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::invalid_argument(<span style="color: #2d9574;">"unsupported layout transition!"</span>);
    }
}
</pre>
</div>
<p>
当执行深度测试时会读取 depth buffer，绘制一个新的片段时会写入 depth buffer。读取发生在 VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT 阶段，写入发生在 VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT 阶段。你应该选择与指定操作匹配的最早 pipeline 阶段，以便在需要时 depth attachment 是准备好的。<br />
</p>
</div>
</div>

<div id="outline-container-orgc8cc3ba" class="outline-4">
<h4 id="orgc8cc3ba">Render pass (244)</h4>
<div class="outline-text-4" id="text-orgc8cc3ba">
<p>
对 createRenderPass 进行修改，从而包含 depth attachment:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createRenderPass</span>() 
{
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">colorAttachment</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">depthAttachment</span>{};
    depthAttachment.format = findDepthFormat();
    depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32472;&#21046;&#23436;&#25104;&#21518;&#19981;&#20877;&#20351;&#29992; depth &#25968;&#25454;</span>
    depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">colorAttachmentRef</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">depthAttachmentRef</span>{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    <span style="color: #ce537a; font-weight: bold;">VkSubpassDescription</span> <span style="color: #7590db;">subpass</span>{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &amp;colorAttachmentRef;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21644; color attachments &#19981;&#21516;&#65292;&#19968;&#20010; subpass &#21482;&#33021;&#20351;&#29992;&#19968;&#20010; depth&#65288;+stencil&#65289;attachment&#12290;&#22312;&#22810;&#20010; buffers &#19978;&#25191;&#34892;&#22810;&#27425; depth tests &#27809;&#26377;&#20219;&#20309;&#24847;&#20041;</span>
    subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35753; render pass &#31561;&#24453; VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>
    <span style="color: #ce537a; font-weight: bold;">VkSubpassDependency</span> <span style="color: #7590db;">dependency</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">dstSubpass &#30340; dstStageMask &#31561;&#24453; srcSubpass &#30340; srcStageMask</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20004;&#34892;&#25351;&#23450;&#65292;&#24403;&#21069;&#30340; subpass(dstSubpass) &#20381;&#36182;&#20854;&#21069;&#38754;&#30340;pass (&#24403;&#21069;&#30340; subpass &#20026;&#32472;&#21046;&#19977;&#35282;&#24418;&#23545;&#24212;&#30340;subpass)</span>
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;   
    dependency.dstSubpass = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">0 &#34920;&#31034;&#24403;&#21069;&#30340; subpass</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;srcSubpass&#34987;&#31561;&#24453;&#30340;&#38454;&#27573; (swap chain&#20174;image&#35835;&#21462;&#25968;&#25454;&#38454;&#27573; | &#29255;&#27573;&#27979;&#35797;&#30340;&#26089;&#26399;&#38454;&#27573;)</span>
    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#31561;&#24453;&#23436;&#25104;&#21518; srcSubpass&#19981;&#25191;&#34892;&#20219;&#20309;&#25805;&#20316;</span>
    dependency.srcAccessMask = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; dstSubpass &#25191;&#34892;&#31561;&#24453;&#30340;&#38454;&#27573; (swap chain&#20174;image&#35835;&#21462;&#25968;&#25454;&#23436;&#27605; | &#29255;&#27573;&#27979;&#35797;&#30340;&#26089;&#26399;&#38454;&#27573;)</span>
    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450;&#31561;&#24453;&#23436;&#25104;&#21518; desSubpass &#25191;&#34892;&#30340;&#25805;&#20316; (&#20889;&#20837;color attachment&#30340;&#25805;&#20316; | &#20889;&#20837;depth stencil attachment&#30340;&#25805;&#20316;)</span>
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Render Pass</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span>, 2&gt; <span style="color: #7590db;">attachments</span> = {colorAttachment, depthAttachment};
    <span style="color: #ce537a; font-weight: bold;">VkRenderPassCreateInfo</span> <span style="color: #7590db;">renderPassInfo</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateRenderPass(device, &amp;renderPassInfo, <span style="color: #a45bad;">nullptr</span>, &amp;renderPass) != VK_SUCCESS) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create render pass!"</span>);
    }
}
</pre>
</div>
<p>
和 color attachments 不同，一个 subpass 只能使用一个 depth（+stencil）attachment。在多个 color attachments 上执行多次 depth tests 没有任何意义。<br />
上面对 Subpass Dependency 的配置避免了转换 depth image 操作和 loadOpt 对 depth 的清除操作相冲突，在 early fragment test 阶段对 depth image 的 load 操作会清除其中的 depth 值。<br />
</p>
</div>
</div>
<div id="outline-container-org39c159a" class="outline-4">
<h4 id="org39c159a">Framebuffer (245)</h4>
<div class="outline-text-4" id="text-org39c159a">
<p>
修改 framebuffer 的创建，将 depth image 绑定到 depth attachment。需要注意要在创建 framebuffer 之前创建 depth image。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkImageView, 2&gt; <span style="color: #7590db;">attachments</span> = {
    swapChainImageViews[i],
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;depth image &#32465;&#23450;&#21040; depth attachment</span>
    depthImageView
};

<span style="color: #ce537a; font-weight: bold;">VkFramebufferCreateInfo</span> <span style="color: #7590db;">framebufferInfo</span>{};
framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
framebufferInfo.renderPass = renderPass;
framebufferInfo.attachmentCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(attachments.size());
framebufferInfo.pAttachments = attachments.data();
framebufferInfo.width = swapChainExtent.width;
framebufferInfo.height = swapChainExtent.height;
framebufferInfo.layers = 1;
</pre>
</div>
</div>
</div>
<div id="outline-container-org79e97cf" class="outline-4">
<h4 id="org79e97cf">Clear values (246)</h4>
<div class="outline-text-4" id="text-org79e97cf">
<p>
在 render pass 开始时需要指定清除 depth buffer 使用的值：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkClearValue, 2&gt; <span style="color: #7590db;">clearValues</span>{};
clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
clearValues[1].depthStencil = {1.0f, 0};

renderPassInfo.clearValueCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(clearValues.size());
renderPassInfo.pClearValues = clearValues.data();
</pre>
</div>
</div>
</div>
<div id="outline-container-org211c48c" class="outline-4">
<h4 id="org211c48c">Depth and stencil state (246)</h4>
<div class="outline-text-4" id="text-org211c48c">
<p>
创建 graphics pipeline 时，配置 depth 和 stencil testing:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37197;&#32622; Depth and stencil testing</span>
<span style="color: #ce537a; font-weight: bold;">VkPipelineDepthStencilStateCreateInfo</span> <span style="color: #7590db;">depthStencil</span>{};
depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
depthStencil.depthTestEnable = VK_TRUE;
depthStencil.depthWriteEnable = VK_TRUE;
depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;
depthStencil.depthBoundsTestEnable = VK_FALSE;
depthStencil.minDepthBounds = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
depthStencil.maxDepthBounds = 1.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
depthStencil.stencilTestEnable = VK_FALSE;
depthStencil.front = {}; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
depthStencil.back = {}; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org23ffc59" class="outline-3">
<h3 id="org23ffc59">Loading models (250)</h3>
<div class="outline-text-3" id="text-org23ffc59">
<p>
Introduction (250)<br />
</p>
</div>
<div id="outline-container-org97852a8" class="outline-4">
<h4 id="org97852a8">Library (250)</h4>
<div class="outline-text-4" id="text-org97852a8">
<p>
我们使用 tinyobjloader 库来实现加载一个 OBJ 模型文件。其非常简单，只有需要包含一个头文件。<br />
</p>
<ul class="org-ul">
<li><a href="https://github.com/tinyobjloader/tinyobjloader">https://github.com/tinyobjloader/tinyobjloader</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc0ad779" class="outline-4">
<h4 id="orgc0ad779">Loading vertices and indices (252)</h4>
<div class="outline-text-4" id="text-orgc0ad779">
<p>
OBJ 文件由 positions、normals、texture coordinates 以及 faces 组成。Faces 由任意数量的 vertices 组成，每个 vertex 通过 index 引用一个 position，normal 和 texture coordinate。这样不仅可以复用顶点也可以复用顶点的属性。<br />
加载 OBJ 模型的代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">loadModel</span>()
{
    <span style="color: #a45bad;">tinyobj</span>::<span style="color: #ce537a; font-weight: bold;">attrib_t</span> <span style="color: #7590db;">attrib</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">tinyobj</span>::shape_t&gt; <span style="color: #7590db;">shapes</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">tinyobj</span>::material_t&gt; <span style="color: #7590db;">materials</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">warn</span>, <span style="color: #7590db;">err</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span><span style="color: #a45bad;">tinyobj</span>::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.c_str()))
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(warn + err);
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">shape</span> : shapes)
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">index</span> : shape.mesh.indices)
        {
            <span style="color: #ce537a; font-weight: bold;">Vertex</span> <span style="color: #7590db;">vertex</span>{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OBJ &#26684;&#24335;&#20551;&#23450;&#22270;&#29255;&#30340;&#22352;&#26631;&#21407;&#28857;&#20026;&#24038;&#19979;&#35282;</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vulkan &#20013;&#22270;&#29255;&#22352;&#26631;&#21407;&#28857;&#20026;&#24038;&#19978;&#35282;</span>
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = { 1.0f, 1.0f, 1.0f };

            vertices.push_back(vertex);
            indices.push_back(indices.size());
        }
    }
}
</pre>
</div>
<p>
attrib 容器中保存了所有的 positions(attrib.vertices)，normals(attrib.normals)以及 texture coordinates(attrib.texcoords)。shapes 容器中包含了所有分开的对象(shape)，shape 可以是面（即 shape.mesh）也可以是一组线段还可以是一组点。面由一组 vertices 的组成，每个 vertex 包含其 position 的索引(shader.mesh.indices[i].vertex_index)、normal 的索引(shader.mesh.indices[i].normal_index)、texture coordinate 的索引(shader.mesh.indices[i].texcoord_index)。<br />
</p>
</div>
</div>

<div id="outline-container-org1b62567" class="outline-4">
<h4 id="org1b62567">Vertex deduplication (256)</h4>
<div class="outline-text-4" id="text-org1b62567">
<p>
上面的方式会将重复的顶点数据提交给 GPU，并没有真正利用索引的优势。使用下面方法来剔除重复顶点数据：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">loadModel</span>()
{
    <span style="color: #a45bad;">tinyobj</span>::<span style="color: #ce537a; font-weight: bold;">attrib_t</span> <span style="color: #7590db;">attrib</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">tinyobj</span>::shape_t&gt; <span style="color: #7590db;">shapes</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">tinyobj</span>::material_t&gt; <span style="color: #7590db;">materials</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">warn</span>, <span style="color: #7590db;">err</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span><span style="color: #a45bad;">tinyobj</span>::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.c_str()))
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(warn + err);
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;Vertex, <span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">uniqueVertices</span>{};
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">shape</span> : shapes)
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">index</span> : shape.mesh.indices)
        {
            <span style="color: #ce537a; font-weight: bold;">Vertex</span> <span style="color: #7590db;">vertex</span>{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OBJ &#26684;&#24335;&#20551;&#23450;&#22270;&#29255;&#30340;&#22352;&#26631;&#21407;&#28857;&#20026;&#24038;&#19979;&#35282;</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Vulkan &#20013;&#22270;&#29255;&#22352;&#26631;&#21407;&#28857;&#20026;&#24038;&#19978;&#35282;</span>
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = { 1.0f, 1.0f, 1.0f };

            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#39030;&#28857;&#19981;&#23384;&#22312;&#25165;&#35760;&#24405;&#21040; vertices &#20013;</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span> (uniqueVertices.count(vertex) == 0) 
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">map&#30340;value&#20013;&#35760;&#24405;&#20102;&#39030;&#28857;&#30340;&#32034;&#24341;</span>
                uniqueVertices[vertex] = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(vertices.size());
                vertices.push_back(vertex);
            }
            indices.push_back(uniqueVertices[vertex]);
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org42d4517" class="outline-3">
<h3 id="org42d4517">Generating Mipmaps (259)</h3>
<div class="outline-text-3" id="text-org42d4517">
<p>
mipmaps 是预计算的缩小版的图片，每级 mipmap 比上一级尺寸缩小一半。使用 mipmaps 可以提高渲染性能并且可以避免摩尔纹。<br />
</p>
<ul class="org-ul">
<li><a href="https://computergraphics.stackexchange.com/questions/1592/moires-patterns-despite-using-mipmaps">https://computergraphics.stackexchange.com/questions/1592/moires-patterns-despite-using-mipmaps</a><br /></li>
</ul>
</div>
<div id="outline-container-orga87a76f" class="outline-4">
<h4 id="orga87a76f">Generating Mipmaps (261)</h4>
<div class="outline-text-4" id="text-orga87a76f">
<p>
使用如下方法计算最大的 mipmap 等级：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">mipLevels = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(<span style="color: #a45bad;">std</span>::floor(<span style="color: #a45bad;">std</span>::log2(<span style="color: #a45bad;">std</span>::max(texWidth, texHeight)))) + 1;
</pre>
</div>

<p>
使用 vkCmdBlitImage 函数，通过当前等级的 mipmap 得到下一等级的 mipmap：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">generateMipmaps</span>(<span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">image</span>, <span style="color: #ce537a; font-weight: bold;">VkFormat</span> <span style="color: #7590db;">imageFormat</span>, <span style="color: #ce537a; font-weight: bold;">int32_t</span> <span style="color: #7590db;">texWidth</span>, <span style="color: #ce537a; font-weight: bold;">int32_t</span> <span style="color: #7590db;">texHeight</span>, <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">mipLevels</span>)
{
    <span style="color: #ce537a; font-weight: bold;">VkFormatProperties</span> <span style="color: #7590db;">formatProperties</span>;
    vkGetPhysicalDeviceFormatProperties(physicalDevice, imageFormat, &amp;formatProperties);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: &#20351;&#29992; vkCmdBlitImage&#29983;&#25104;mipmap&#65292;&#38656;&#35201;&#30828;&#20214;&#24179;&#21488;&#25903;&#25345;linear filtering</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>(formatProperties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) 
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"texture image format does not support linear blitting!"</span>);
    }

    <span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">commandBuffer</span> = beginSingleTimeCommands();

    <span style="color: #ce537a; font-weight: bold;">VkImageMemoryBarrier</span> <span style="color: #7590db;">barrier</span>{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.image = image;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.subresourceRange.levelCount = 1;

    <span style="color: #ce537a; font-weight: bold;">int32_t</span> <span style="color: #7590db;">mipWidth</span> = texWidth;
    <span style="color: #ce537a; font-weight: bold;">int32_t</span> <span style="color: #7590db;">mipHeight</span> = texHeight;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mipmap-&gt;[0, mipLevels-1-1]</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">i</span> = 1; i &lt; mipLevels; i++)
    {
        barrier.subresourceRange.baseMipLevel = i - 1;
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i-1 mipmap VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL -&gt; VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</span>
        vkCmdPipelineBarrier(commandBuffer,
                             VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
                             0, <span style="color: #a45bad;">nullptr</span>,
                             0, <span style="color: #a45bad;">nullptr</span>,
                             1, &amp;barrier);

        <span style="color: #ce537a; font-weight: bold;">VkImageBlit</span> <span style="color: #7590db;">blit</span>{};
        blit.srcOffsets[0] = { 0, 0, 0 };
        blit.srcOffsets[1] = { mipWidth, mipHeight, 1 };
        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.srcSubresource.mipLevel = i - 1;
        blit.srcSubresource.baseArrayLayer = 0;
        blit.srcSubresource.layerCount = 1;
        blit.dstOffsets[0] = { 0, 0, 0 };
        blit.dstOffsets[1] = { mipWidth &gt; 1 ? mipWidth / 2 : 1, mipHeight &gt; 1 ? mipHeight / 2 : 1, 1 };
        blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.dstSubresource.mipLevel = i;
        blit.dstSubresource.baseArrayLayer = 0;
        blit.dstSubresource.layerCount = 1;
        vkCmdBlitImage(commandBuffer,
                       image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                       image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                       1, &amp;blit,
                       VK_FILTER_LINEAR);

        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i-1 mipmap VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL -&gt; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span>
        vkCmdPipelineBarrier(commandBuffer,
                             VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
                             0, <span style="color: #a45bad;">nullptr</span>,
                             0, <span style="color: #a45bad;">nullptr</span>,
                             1, &amp;barrier);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#19979;&#19968;&#32423;mipmap&#30340;&#38271;&#23485;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mipWidth &gt; 1) mipWidth /= 2;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mipHeight &gt; 1) mipHeight /= 2;
    }
    barrier.subresourceRange.baseMipLevel = mipLevels - 1;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mipLevels-1 mipmap VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL -&gt; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span>
    vkCmdPipelineBarrier(commandBuffer,
                         VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
                         0, <span style="color: #a45bad;">nullptr</span>,
                         0, <span style="color: #a45bad;">nullptr</span>,
                         1, &amp;barrier);

    endSingleTimeCommands(commandBuffer);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb65feb9" class="outline-4">
<h4 id="orgb65feb9">Sampler (267)</h4>
<div class="outline-text-4" id="text-orgb65feb9">
<p>
创建 Sampler 时可以指定 minLod 和 maxLod，以及 mipmapMode:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createTextureSampler</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    samplerInfo.minLod = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    samplerInfo.maxLod = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">float</span>&gt;(mipLevels);
    samplerInfo.mipLodBias = 0.0f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Optional</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org88053b0" class="outline-3">
<h3 id="org88053b0">Multisampling (271)</h3>
<div class="outline-text-3" id="text-org88053b0">
<p>
使用下面方法检测当前物理设备支持的 MSAA 的最大样本数量：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkSampleCountFlagBits</span> <span style="color: #bc6ec5; font-weight: bold;">getMaxUsableSampleCount</span>() 
{
    <span style="color: #ce537a; font-weight: bold;">VkPhysicalDeviceProperties</span> <span style="color: #7590db;">physicalDeviceProperties</span>;
    vkGetPhysicalDeviceProperties(physicalDevice, &amp;physicalDeviceProperties);

    <span style="color: #ce537a; font-weight: bold;">VkSampleCountFlags</span> <span style="color: #7590db;">counts</span> = physicalDeviceProperties.limits.framebufferColorSampleCounts &amp; physicalDeviceProperties.limits.framebufferDepthSampleCounts;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_64_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_64_BIT; }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_32_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_32_BIT; }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_16_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_16_BIT; }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_8_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_8_BIT; }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_4_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_4_BIT; }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (counts &amp; VK_SAMPLE_COUNT_2_BIT) { <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_2_BIT; }

    <span style="color: #4f97d7; font-weight: bold;">return</span> VK_SAMPLE_COUNT_1_BIT;
}
</pre>
</div>
<p>
使用 MSAA 后，每个像素的采样是在一个 offscreen buffer 中进行的，然后再将结果渲染到屏幕上。这种新的 buffer 和 swap chain 分配的 images 略有不同，这种新的 buffer 可以为每个像素存储多个样本。<br />
</p>

<p>
创建 image 时，通过 VkImageCreateInfo.samples 来指定每个像素对应的样本数量。<br />
</p>

<p>
TODO: 前面利用 Fence 实现同时渲染多帧的数据，这里只创建一个支持多重采样的 image，岂不是破坏了之前的设计？<br />
</p>
</div>
<div id="outline-container-org107deab" class="outline-4">
<h4 id="org107deab">Adding new attachments (276)</h4>
<div class="outline-text-4" id="text-org107deab">
<p>
在创建 RenderPass 时，为 colorAttachment 和 depthAttachment 指定样本数量。另外，需要将 colorAttachment 的 finalLayout 从 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR 改为 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL，这是因为多重采样的 images 不能被直接展示，需要将其 resolve 为一个常规的 image。不需要对 depth buffer 进行这样的操作，因为不会展示 depth image。<br />
增加一个新的 attachment 作为 resolve attachment。这样 render pass 就会将 multisampled color image 转化为一个常规的 color image。如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createRenderPass</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">colorAttachment</span>{};
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">colorAttachmentRef</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">colorAttachmentResolve</span>{};
    colorAttachmentResolve.format = swapChainImageFormat;
    colorAttachmentResolve.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachmentResolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachmentResolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachmentResolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachmentResolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">colorAttachmentResolveRef</span>{};
    colorAttachmentResolveRef.attachment = 2;
    colorAttachmentResolveRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    <span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span> <span style="color: #7590db;">depthAttachment</span>{};
    <span style="color: #ce537a; font-weight: bold;">VkAttachmentReference</span> <span style="color: #7590db;">depthAttachmentRef</span>{};
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

    <span style="color: #ce537a; font-weight: bold;">VkSubpassDescription</span> <span style="color: #7590db;">subpass</span>{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &amp;colorAttachmentRef;
    subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25351;&#23450; resolveAttachments</span>
    subpass.pResolveAttachments = &amp;colorAttachmentResolveRef;


    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; Render Pass</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkAttachmentDescription</span>, 3&gt; <span style="color: #7590db;">attachments</span> = { colorAttachment, depthAttachment, colorAttachmentResolve };
    <span style="color: #ce537a; font-weight: bold;">VkRenderPassCreateInfo</span> <span style="color: #7590db;">renderPassInfo</span>{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(attachments.size());
    renderPassInfo.pAttachments = attachments.data();
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &amp;subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies = &amp;dependency;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateRenderPass(device, &amp;renderPassInfo, <span style="color: #a45bad;">nullptr</span>, &amp;renderPass) != VK_SUCCESS)
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create render pass!"</span>);
    }
}
</pre>
</div>
<p>
在创建 frame buffer 时，将 colorImageView 和 colorAttachmentResolve 关联起来：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createFramebuffers</span>()
{
    swapChainFramebuffers.resize(swapChainImageViews.size());
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">i</span> = 0; i &lt; swapChainImageViews.size(); i++)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;VkImageView, 3&gt; <span style="color: #7590db;">attachments</span> = {
            colorImageView,
            depthImageView,
            swapChainImageViews[i],
        };

        <span style="color: #ce537a; font-weight: bold;">VkFramebufferCreateInfo</span> <span style="color: #7590db;">framebufferInfo</span>{};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = renderPass;
        framebufferInfo.attachmentCount = <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt;(attachments.size());
        framebufferInfo.pAttachments = attachments.data();
        framebufferInfo.width = swapChainExtent.width;
        framebufferInfo.height = swapChainExtent.height;
        framebufferInfo.layers = 1;

        <span style="color: #4f97d7; font-weight: bold;">if</span> (vkCreateFramebuffer(device, &amp;framebufferInfo, <span style="color: #a45bad;">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"failed to create framebuffer!"</span>);
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcb0953b" class="outline-4">
<h4 id="orgcb0953b">Quality improvements (279)</h4>
<div class="outline-text-4" id="text-orgcb0953b">
<p>
MSAA 只会平滑几何边缘，几何内部的填充不受影响。开启样本着色可以改进整体的锯齿，进一步提升图片质量，但是会导致额外的性能消耗。使用如下方法开启样本着色：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createLogicalDevice</span>() {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    deviceFeatures.sampleRateShading = VK_TRUE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">enable sample shading feature for the device</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">createGraphicsPipeline</span>() {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    multisampling.sampleShadingEnable = VK_TRUE; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">enable sample shading in the pipeline</span>
    multisampling.minSampleShading = .2f; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">min fraction for sample shading; closer to one is smoother</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org34654db" class="outline-3">
<h3 id="org34654db">Summary</h3>
<div class="outline-text-3" id="text-org34654db">
<p>
下面是对整个流程的梳理：<br />
</p>
<ul class="org-ul">
<li>创建 instance, 作为 app 和 vulkan 交互的接口<br />
<ul class="org-ul">
<li>instance 有自己所支持的 layers,如：VK_LAYER_KHRONOS_validation,VK_LAYER_RENDERDOC_Capture 等<br /></li>
<li>instance 有自己所支持的 extensions,如：VK_EXT_debug_utils,VK_KHR_surface 等<br /></li>
<li>创建 instance 时需要检测所需的 layers、extensions 是否支持<br /></li>
</ul></li>
<li>查询可用的 physical device，选择合适的 physical device<br />
<ul class="org-ul">
<li>physical device 有自己支持的属性(properties),如： 是否是独显、支持的最大贴图尺寸等<br />
<ul class="org-ul">
<li>选择 physical device 时会考虑 physical device properties<br /></li>
</ul></li>
<li>physical device 有自己支持的特性(features),如：是否支持 geomeryShader,tessellationShader,sampleRateShading 等等<br /></li>
<li>physical device 有自己支持的 queue families,如：VK_QUEUE_GRAPHICS_BIT、VK_QUEUE_COMPUTE_BIT 等<br />
<ul class="org-ul">
<li>使用 Vulkan 执行的大多数操作，如绘制命令、内存操作等，都被提交到一个 VkQueue 来异步执行。Queues 是从 Queue families 分配的，每个 queue family 在其 queues 上提供一组特定的操作集合(该集合只是所有命令集合的一个子集)<br /></li>
</ul></li>
<li>physical device 有自己支持的扩展(device extensions),如：VK_KHR_swapchain<br /></li>
</ul></li>
<li>创建 logical device，作为 vulkan 和 physical device 交互的接口<br />
<ul class="org-ul">
<li>创建 logical device,需要指定对应的 physical device,以及所需的 physical device features、queue families 以及对应的 queue 的数量、layers、extensions<br /></li>
<li>创建 logical device 的同时会创建 queue<br /></li>
</ul></li>
<li>创建 surface ,其将 vulkan 和窗口系统关联起来，surface 是对渲染的窗口的跨平台抽象<br />
<ul class="org-ul">
<li>surface 是对渲染的窗口的跨平台抽象，通常通过提供一个指向本地窗口句柄的引用来实例化 surface，对于 Windows 平台本地窗口的句柄为 HWND。<br /></li>
<li>选择 physical device 时，需要检查 physical device 是否支持 surface<br /></li>
</ul></li>
<li>Vulkan 中不存在默认的 framebuffer，swap chain 是构建 framebuffer 的基础设施。swap chain 管理着一个 image 队列，渲染结果就放置在其中的一个 image 中。<br />
<ul class="org-ul">
<li>创建 swap chain 时会同时创建 images。其基本目的是用于保证我们当前正在渲染到的 render target 和当前显示在屏幕上的 render target 不是同一个 render target。确保渲染完成的图片才被显示是非常重要的。每次我们想要绘制一帧时，都需要让 swap chain 为我们提供一个 image，让我们渲染到其中。当我们结束绘制一帧时，该 image 被返回给 swap chain，用于在某个时间点将其展示在屏幕上。<br /></li>
<li>不能直接使用 image，image view 是和 image 交互的接口。<br /></li>
</ul></li>
<li>创建 graphics pipeline，配置各个处理流程<br />
<ul class="org-ul">
<li>和老式的 APIs 不同，Vulkan 中，graphics pipeline 几乎是完全不可以改变的（只有少数状态可以被动态修改）, 修改大部分状态需要重新创建 graphics pipeline, 切换整个 graphics pipeline。<br /></li>
<li>graphics pipeline 包含如下阶段： 输入装配器(Input assembler) 顶点着色器(vertex shader) 细分着色器(tessellation shader) 几何着色器(geometry shader) 光栅化阶段(rasterization stage) 片段着色器(fragment shader) 颜色混合(color blending stage)<br /></li>
<li>创建 pipeline 时，我们还需要告诉 Vulkan，我们在渲染时使用的 framebuffer attachments，需要使用多少个 color buffers 和 depth buffers，每个 buffer 使用多少个样本，buffer 中的内容被如何处理。所有这些信息都被封装在 render pass 对象中。<br />
<ul class="org-ul">
<li>一个 render pass 可以由多个 subpasses 组成。Subpasses 是渲染操作子序列，这些操作会依赖之前 passes 的 framebuffers 内容。<br /></li>
</ul></li>
</ul></li>
<li>创建 CommandPool，从中创建 CommandBuffer，将渲染命令记录到 CommandBuffer 中，(渲染主循环中会将 command buffer 提交到 queue 中执行)<br />
<ul class="org-ul">
<li>创建 command buffers 之前需要先创建 command pool。command pools 管理用于存储 buffers 的内存，command buffers 就是从 command pools 中分配的。<br /></li>
<li>调用 vkBeginCommandBuffer 函数开始将命令记录到 CommandBuffer<br /></li>
<li>调用 vkCmdBeginRenderPass 函数开始一个 render pass<br /></li>
<li>调用 vkCmdBindPipeline 函数绑定 graphics pipeline 和 command buffer<br /></li>
<li>调用 vkCmdBindVertexBuffers 函数绑定 vertex buffer<br /></li>
<li>调用 vkCmdBindIndexBuffers 函数绑定 index buffer<br /></li>
<li>调用 vkCmdBindDescriptorSets 函数绑定 descriptor sets<br /></li>
<li>调用 vkCmdDraw 或 vkCmdDrawIndexed 执行绘制<br /></li>
<li>调用 vkCmdEndRenderPass 结束 render pass<br /></li>
<li>调用 vkEndCommandBuffer 停止向 command buffer 中记录命令<br /></li>
</ul></li>
<li>渲染主循环<br />
<ul class="org-ul">
<li>从 swap chain 获取一个 image<br /></li>
<li>将上一步得到的 image 作为 framebuffer 的 attachment, 然后执行 command buffer<br />
<ul class="org-ul">
<li>调用 vkQueueSubmit 将 command buffer 提交到 graphics queue 中执行(可以同时提交多个 command buffers)<br /></li>
<li>提交到 queue 时需要指定提交哪些 command buffer<br /></li>
</ul></li>
<li>展示渲染的结果, 并将 image 返回给 swap chain<br /></li>
</ul></li>
</ul>

<p>
下面是上面整体流程的补充说明：<br />
</p>
<ul class="org-ul">
<li>pipeline (创建 graphics pipeline，配置各个处理流程)<br />
<ul class="org-ul">
<li>创建 render pass 时，需要指定相关的 attachments，render pass 包含的 subpasses 以及 subpasses 之间的依赖<br />
<ul class="org-ul">
<li>attachment description 描述了 attachment 的格式、样本数量、渲染前后对 attachments 中的数据做何处理<br /></li>
<li>subpass description 指定 subpass 引用的 color attachment、depth stencil attachment、resolve attachment<br /></li>
<li>subpass dependency 指定了 subpass 之间的依赖关系，依赖所涉及的具体相关操作<br /></li>
</ul></li>
<li>创建 pipeline layout 时，需要指定 desciptor set layouts 和 push constant ranges<br />
<ul class="org-ul">
<li>descriptor 是 shaders 访问资源(如：buffers、images)的一种方式<br />
<ul class="org-ul">
<li>desciptors 有很多种类型，如：uniform buffer objects、combined image sampler 等<br /></li>
</ul></li>
<li>descriptor pool 用于分配 descriptor set<br /></li>
<li>descriptor set 指定了真正被绑定到 descriptors 的 buffer 或 image 资源<br /></li>
<li>descriptor set layout 指定了 descriptor binding<br /></li>
<li>descriptor binding 指定了 descriptor 的类型、descriptor 的个数、descriptor 被使用的阶段(如：VK_SHADER_STAGE_VERTEX_BIT 或 VK_SHADER_STAGE_FRAGMENT_BIT)等<br /></li>
</ul></li>
</ul></li>
<li>command buffer (创建 CommandBuffer，将渲染命令记录到 CommandBuffer 中)<br />
<ul class="org-ul">
<li>使用 command pool 来分配 command buffer<br />
<ul class="org-ul">
<li>创建 command pool 时需要指定对应的 queue family。一个 command pool 指定对应一个 queue family<br /></li>
<li>分配 command buffer 时需要指定分配的 command buffer 的数量、commandbuffer 的 level<br />
<ul class="org-ul">
<li>VK_COMMAND_BUFFER_LEVEL_PRIMARY：可以提交到 queue 来执行，但不能从其他 command buffers 调用<br /></li>
<li>VK_COMMAND_BUFFER_LEVEL_SECONDARY：不能直接提交到 queue，但可以从主 command buffers 调用<br /></li>
</ul></li>
</ul></li>
<li>调用 vkCmdBeginRenderPass 函数开始一个 render pass<br />
<ul class="org-ul">
<li>此时需要指定使用的 framebuffer, 指定渲染的区域，指定 loadOp 的清除值<br /></li>
<li>创建 framebuffer 时，需要指定对应的 renderPass，attachments、framebuffer 的宽高等<br /></li>
</ul></li>
</ul></li>
</ul>

<p>
为了可以同时渲染很多帧，GPU 端可以同时执行多个 command buffers(渲染主循环中每帧都提交 command buffer, command buffer 不会立即执行完毕, 因此会有多个 command buffers 在同时执行)：<br />
</p>
<ul class="org-ul">
<li>多个 command buffers &#x2013;&gt; 多个 framebuffers &#x2013;&gt; 多个 color attachments &#x2013;&gt; 多个 images<br /></li>
<li>pipeline 和 renderPass 可以被多个 command buffers 复用，因此不需要多个 renderPass 和 pipeline<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9572030" class="outline-3">
<h3 id="org9572030">Q&amp;A</h3>
<div class="outline-text-3" id="text-org9572030">
</div>
<div id="outline-container-org6876f49" class="outline-4">
<h4 id="org6876f49">VkAllocationCallbacks 的使用示例</h4>
<div class="outline-text-4" id="text-org6876f49">
<div class="org-src-container">
<pre class="src src-cpp">VKAPI_ATTR <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #bc6ec5; font-weight: bold;">VKAPI_CALL</span> myrealloc(<span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pUserData</span>, <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pOriginal</span>,
                                      <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">size</span>, <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">alignment</span>,
                                      <span style="color: #ce537a; font-weight: bold;">VkSystemAllocationScope</span> <span style="color: #7590db;">allocationScope</span>) {
    <span style="color: #4f97d7; font-weight: bold;">return</span> realloc(pOriginal, size);
}

VKAPI_ATTR <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #bc6ec5; font-weight: bold;">VKAPI_CALL</span> myalloc(<span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pUserData</span>, <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">size</span>,
                                    <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">alignment</span>,
                                    <span style="color: #ce537a; font-weight: bold;">VkSystemAllocationScope</span> <span style="color: #7590db;">allocationScope</span>) {
<span style="color: #bc6ec5;">#ifdef</span> _MSC_VER
    <span style="color: #4f97d7; font-weight: bold;">return</span> _aligned_malloc(size, alignment);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> aligned_alloc(alignment, size);
<span style="color: #bc6ec5;">#endif</span>
}

VKAPI_ATTR <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">VKAPI_CALL</span> myfree(<span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pUserData</span>, <span style="color: #ce537a; font-weight: bold;">void</span> *<span style="color: #7590db;">pMemory</span>) {
<span style="color: #bc6ec5;">#ifdef</span> _MSC_VER
    _aligned_free(pMemory);
<span style="color: #bc6ec5;">#else</span>
    free(pMemory);
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">demo</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    <span style="color: #ce537a; font-weight: bold;">VkSurfaceKHR</span> <span style="color: #7590db;">surface</span>;
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">prepared</span>;
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">use_staging_buffer</span>;

    <span style="color: #ce537a; font-weight: bold;">VkAllocationCallbacks</span> <span style="color: #7590db;">allocator</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">init allocator</span>
demo-&gt;allocator.pfnAllocation = myalloc;
demo-&gt;allocator.pfnFree = myfree;
demo-&gt;allocator.pfnReallocation = myrealloc;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use allocator</span>
err = vkCreateInstance(&amp;inst_info, &amp;demo-&gt;allocator, &amp;demo-&gt;inst);
</pre>
</div>

<ul class="org-ul">
<li><a href="https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/blob/sdk-1.0.3/demos/tri.c#L1702">https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/blob/sdk-1.0.3/demos/tri.c#L1702</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org463ef08" class="outline-4">
<h4 id="org463ef08">为什么 depthImageView 可以被多个 command buffer 复用，而 swapChainImageView 不能？</h4>
<div class="outline-text-4" id="text-org463ef08">
<p>
下面链接中有详细讨论。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/62371266/why-is-a-single-depth-buffer-sufficient-for-this-vulkan-swapchain-render-loop">https://stackoverflow.com/questions/62371266/why-is-a-single-depth-buffer-sufficient-for-this-vulkan-swapchain-render-loop</a><br /></li>
<li>评论部分 <a href="https://vulkan-tutorial.com/Depth_buffering">https://vulkan-tutorial.com/Depth_buffering</a><br /></li>
<li><a href="https://www.reddit.com/r/vulkan/comments/aavxl4/why_is_a_single_depth_buffer_sufficient_for/">https://www.reddit.com/r/vulkan/comments/aavxl4/why_is_a_single_depth_buffer_sufficient_for/</a><br /></li>
<li><a href="https://community.khronos.org/t/framebuffer-attachments-clarification/7595">https://community.khronos.org/t/framebuffer-attachments-clarification/7595</a><br /></li>
</ul>

<p>
Tips: 开启多重采样后，需要创建 colorImageView，colorImageView 也能被多个 command buffer 复用。<br />
</p>
</div>
</div>

<div id="outline-container-org2636407" class="outline-4">
<h4 id="org2636407">secondary command buffer 的使用示例</h4>
<div class="outline-text-4" id="text-org2636407">
<ul class="org-ul">
<li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/multithreading/multithreading.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/multithreading/multithreading.cpp</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org8acb433" class="outline-4">
<h4 id="org8acb433">使用惯例</h4>
<div class="outline-text-4" id="text-org8acb433">
<p>
view proj Matrix 通常会放到 uniform buffer<br />
unity srp batch 中，将<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7096fd2" class="outline-3">
<h3 id="org7096fd2">参考资料</h3>
<div class="outline-text-3" id="text-org7096fd2">
<ul class="org-ul">
<li>如何正确的入门 Vulkan？ <a href="https://www.zhihu.com/question/424430509">https://www.zhihu.com/question/424430509</a><br /></li>
<li>Vulkan tutorial code <a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles">https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles</a><br /></li>
<li>Vulkan tutorial en <a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a><br /></li>
<li>Vulkan 高性能渲染 <a href="https://zhuanlan.zhihu.com/p/20712354">https://zhuanlan.zhihu.com/p/20712354</a><br /></li>
<li>vkguide <a href="https://vkguide.dev/">https://vkguide.dev/</a><br /></li>
<li>vkguide github <a href="https://github.com/vblanco20-1/vulkan-guide">https://github.com/vblanco20-1/vulkan-guide</a><br /></li>
<li>Vulkan 学习笔记 <a href="https://github.com/GavinKG/ILearnVulkanFromScratch-CN">https://github.com/GavinKG/ILearnVulkanFromScratch-CN</a><br /></li>
<li>Vulkan C++ examples and demos <a href="https://github.com/SaschaWillems/Vulkan">https://github.com/SaschaWillems/Vulkan</a><br /></li>
<li>awesome-vulkan <a href="https://github.com/vinjn/awesome-vulkan">https://github.com/vinjn/awesome-vulkan</a><br /></li>
<li>VkResult Detail <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkResult.html">https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkResult.html</a><br /></li>
<li>NV Vulkan Samples <a href="https://github.com/nvpro-samples/build_all/blob/master/README.md">https://github.com/nvpro-samples/build_all/blob/master/README.md</a><br /></li>
<li>Vulkan Best Practice for Mobile Developers <a href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers">https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5a8fdac" class="outline-2">
<h2 id="org5a8fdac">Vulkan Guide</h2>
<div class="outline-text-2" id="text-org5a8fdac">
</div>
<div id="outline-container-orgb41f758" class="outline-3">
<h3 id="orgb41f758">Vulkan Base</h3>
<div class="outline-text-3" id="text-orgb41f758">
</div>
<div id="outline-container-org5bb9598" class="outline-4">
<h4 id="org5bb9598">Initial Setup</h4>
<div class="outline-text-4" id="text-org5bb9598">
<ol class="org-ol">
<li>获取源代码 git clone -b all-chapters <a href="https://github.com/vblanco20-1/vulkan-guide.git">https://github.com/vblanco20-1/vulkan-guide.git</a><br /></li>
<li>下载 SDL <a href="https://www.libsdl.org/download-2.0.php">https://www.libsdl.org/download-2.0.php</a> （Tips: 选择 Development Libraries SDL2-devel-2.0.16-VC.zip 版本）放置到 MySDK 目录下<br /></li>
<li><p>
按照下图方式配置 CMake<br />
</p>

<div id="org0e9f09a" class="figure">
<p><img src="./Vulkan/vulkan-guide-init.jpg" alt="vulkan-guide-init.jpg" width="900px" /><br />
</p>
</div></li>
<li>点击 Configure 再点击 Generate 生成 VS 工程<br /></li>
<li>在 vulkan-guide/build 目录下 打开 vulkan_guide.sln solution<br /></li>
<li>将 chapter 5 设置为 Startup Project, 进行编译<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org353f85d" class="outline-4">
<h4 id="org353f85d">Push Constants</h4>
<div class="outline-text-4" id="text-org353f85d">
<p>
Push constants 使我们可以发送少量的数据给 shader，该方式很简单也很高效。Push constants 可以将数据发送给 shader 中的任意阶段(vertex 阶段和 fragment 阶段都可以)，数据被存储到 command buffer 中。<br />
使用方式如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. &#23450;&#20041;&#21457;&#36865;&#30340;&#25968;&#25454;&#32467;&#26500;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">MeshPushConstants</span>
{
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">data</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">render_matrix</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. &#21019;&#24314; pipeline layout&#26102;&#25351;&#23450;&#21457;&#36865;&#25968;&#25454;&#30340;&#22823;&#23567;&#12289;&#20559;&#31227;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">init_pipelines</span>()
{
    <span style="color: #ce537a; font-weight: bold;">VkPipelineLayoutCreateInfo</span> <span style="color: #7590db;">mesh_pipeline_layout_info</span> = <span style="color: #a45bad;">vkinit</span>::pipeline_layout_create_info();

    <span style="color: #ce537a; font-weight: bold;">VkPushConstantRange</span> <span style="color: #7590db;">push_constant</span>;
    push_constant.offset = 0;
    push_constant.size = <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(MeshPushConstants);
    push_constant.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;

    mesh_pipeline_layout_info.pPushConstantRanges = &amp;push_constant;
    mesh_pipeline_layout_info.pushConstantRangeCount = 1;

    VK_CHECK(vkCreatePipelineLayout(_device, &amp;mesh_pipeline_layout_info, <span style="color: #a45bad;">nullptr</span>, &amp;_meshPipelineLayout));
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. &#20351;&#29992; vkCmdPushConstants&#21629;&#20196;&#23558;&#25968;&#25454;&#23884;&#20837;command buffer&#20013;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">draw</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
    <span style="color: #ce537a; font-weight: bold;">MeshPushConstants</span> <span style="color: #7590db;">constants</span>;
    constants.render_matrix = mesh_matrix;

    vkCmdPushConstants(cmd, _meshPipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(MeshPushConstants), &amp;constants);
    
    vkCmdDraw(cmd, _triangleMesh._vertices.size(), 1, 0, 0);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org343e1f6" class="outline-4">
<h4 id="org343e1f6">Dynamic Descriptor sets</h4>
<div class="outline-text-4" id="text-org343e1f6">
<p>
利用 dynamic descriptor sets 可以让多个 descriptors 对应同一个 buffer 的不同部分。本教程中 GPUSceneData 和 GPUCameraData 被放在同一个 buffer 中的不同部位，有两个 descriptor 对应该 buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vert shader</span>
layout(set = 0, binding = 0) <span style="color: #4f97d7; font-weight: bold;">uniform</span>  CameraBuffer
{
    mat4 view;
    mat4 proj;
    mat4 viewproj;
} cameraData;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">frag shader</span>
layout(set = 0, binding = 1) <span style="color: #4f97d7; font-weight: bold;">uniform</span>  SceneData
{
    vec4 fogColor; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">w is for exponent</span>
    vec4 fogDistances; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">x for min, y for max, zw unused.</span>
    vec4 ambientColor;
    vec4 sunlightDirection; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">w for sun power</span>
    vec4 sunlightColor;
} sceneData;
</pre>
</div>
</div>
</div>
<div id="outline-container-org8d2a7a3" class="outline-4">
<h4 id="org8d2a7a3">Storage buffers (shader storage buffer object)</h4>
<div class="outline-text-4" id="text-org8d2a7a3">
<p>
Uniform Buffer 适用于数据量小，只读的数据。Storage Buffer 适用于数据量大，可修改的数据(shader 可以修改其中数据)。<br />
OpenGL spec 可以保证 UBOs 的大小可以最少为 16KB（具体实现可以更大）. 而 OpenGL spec 可以保证 SSBOs 的大小最少为 128MB(大多数实现则允许你申请 GPU 支持的最大的内存大小)<br />
</p>

<p>
Tips:<br />
Storage Buffer 与 Staging Buffer 并不是同一种 Buffer。 <a href="#orgfcb3723">Staging buffer (173)</a><br />
</p>

<ul class="org-ul">
<li><a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object">https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org65ab860" class="outline-4">
<h4 id="org65ab860">ERROR</h4>
<div class="outline-text-4" id="text-org65ab860">
</div>
<div id="outline-container-orgb87b550" class="outline-5">
<h5 id="orgb87b550">ERROR CMake Error: The source "VulkanGuide/base/CMakeLists.txt" does not match the source "VulkanGuide/CMakeLists.txt" used to generate cache.  Re-run cmake with a different source directory.</h5>
<div class="outline-text-5" id="text-orgb87b550">
<p>
执行 CMake  File/Delete Cache 命令，重新配置 CMake 变量。再执行 Configure，Generate<br />
</p>
</div>
</div>
<div id="outline-container-orga86548a" class="outline-5">
<h5 id="orga86548a">ERROR Error C3646 'm_Lock': unknown override specifier</h5>
<div class="outline-text-5" id="text-orga86548a">
<p>
设置 c++版本为 c++17 可以解决该问题<br />
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/67512442/vulkan-memory-allocator-implementation-errors-after-define-vma-implementation">https://stackoverflow.com/questions/67512442/vulkan-memory-allocator-implementation-errors-after-define-vma-implementation</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgfb259a7" class="outline-5">
<h5 id="orgfb259a7">ERROR SDL2.dll 不存在</h5>
<div class="outline-text-5" id="text-orgfb259a7">
<p>
直接将 SDL2.dll copy 到 vulkan-guide/bin/Debug 目录下<br />
</p>
</div>
</div>

<div id="outline-container-org470e0bc" class="outline-5">
<h5 id="org470e0bc">ERROR Validation Error: [ VUID-VkPipelineShaderStageCreateInfo-module-parameter ] Object 0: handle = 0x19ae7186ec0, type = VK_OBJECT_TYPE_INSTANCE; | MessageID = 0xfd71dc70 | Invalid VkShaderModule Object 0xcccccccccccccccc. The Vulkan spec states: module must be a valid VkShaderModule handle</h5>
<div class="outline-text-5" id="text-org470e0bc">
<p>
新添加 shader 后需要使用 CMake 重新生成 project<br />
</p>
</div>
</div>

<div id="outline-container-orgc086fb4" class="outline-5">
<h5 id="orgc086fb4">ERROR LNK2019	unresolved external symbol "public: static struct VertexInputDescription __cdecl Vertex::get_vertex_description(void)" (?get_vertex_description@Vertex@@SA?AUVertexInputDescription@@XZ) referenced in function "private: void __cdecl VulkanEngine::init_pipelines(void)" (?init_pipelines@VulkanEngine@@AEAAXXZ)</h5>
<div class="outline-text-5" id="text-orgc086fb4">
<p>
新添加 .h .cpp 文件后需要修改 CMakeLists.txt 文件，否则使用 CMake 重新生成工程时，新加的文件不参与编译<br />
</p>
</div>
</div>

<div id="outline-container-orga3c0db1" class="outline-5">
<h5 id="orga3c0db1">ERROR gl_BaseInstance undeclared identifier</h5>
<div class="outline-text-5" id="text-orga3c0db1">
<p>
shader 的版本需要从 version 450 提高为 version 460<br />
</p>

<p>
glsl version、OpenGL version 以及 shader preprocessor version 对应关系如下：<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">GLSL Version</th>
<th scope="col" class="org-right">OpenGL Version</th>
<th scope="col" class="org-left">Date</th>
<th scope="col" class="org-left">Shader Preprocessor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1.10.59[1]</td>
<td class="org-right">2.0</td>
<td class="org-left">30 April 2004</td>
<td class="org-left">#version 110</td>
</tr>

<tr>
<td class="org-left">1.20.8[2]</td>
<td class="org-right">2.1</td>
<td class="org-left">07 September 2006</td>
<td class="org-left">#version 120</td>
</tr>

<tr>
<td class="org-left">1.30.10[3]</td>
<td class="org-right">3.0</td>
<td class="org-left">22 November 2009</td>
<td class="org-left">#version 130</td>
</tr>

<tr>
<td class="org-left">1.40.08[4]</td>
<td class="org-right">3.1</td>
<td class="org-left">22 November 2009</td>
<td class="org-left">#version 140</td>
</tr>

<tr>
<td class="org-left">1.50.11[5]</td>
<td class="org-right">3.2</td>
<td class="org-left">04 December 2009</td>
<td class="org-left">#version 150</td>
</tr>

<tr>
<td class="org-left">3.30.6[6]</td>
<td class="org-right">3.3</td>
<td class="org-left">11 March 2010</td>
<td class="org-left">#version 330</td>
</tr>

<tr>
<td class="org-left">4.00.9[7]</td>
<td class="org-right">4.0</td>
<td class="org-left">24 July 2010</td>
<td class="org-left">#version 400</td>
</tr>

<tr>
<td class="org-left">4.10.6[8]</td>
<td class="org-right">4.1</td>
<td class="org-left">24 July 2010</td>
<td class="org-left">#version 410</td>
</tr>

<tr>
<td class="org-left">4.20.11[9]</td>
<td class="org-right">4.2</td>
<td class="org-left">12 December 2011</td>
<td class="org-left">#version 420</td>
</tr>

<tr>
<td class="org-left">4.30.8[10]</td>
<td class="org-right">4.3</td>
<td class="org-left">7 February 2013</td>
<td class="org-left">#version 430</td>
</tr>

<tr>
<td class="org-left">4.40.9[11]</td>
<td class="org-right">4.4</td>
<td class="org-left">16 June 2014</td>
<td class="org-left">#version 440</td>
</tr>

<tr>
<td class="org-left">4.50.7[12]</td>
<td class="org-right">4.5</td>
<td class="org-left">09 May 2017</td>
<td class="org-left">#version 450</td>
</tr>

<tr>
<td class="org-left">4.60.5[13]</td>
<td class="org-right">4.6</td>
<td class="org-left">14 June 2018</td>
<td class="org-left">#version 460</td>
</tr>
</tbody>
</table>

<p>
glsl es version、OpenGL ES version、WebGL version<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">GLSL ES version</th>
<th scope="col" class="org-right">OpenGL ES version</th>
<th scope="col" class="org-right">WebGL version</th>
<th scope="col" class="org-left">Based on GLSL version</th>
<th scope="col" class="org-left">Date</th>
<th scope="col" class="org-left">Shader Preprocessor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1.00.17[14]</td>
<td class="org-right">2.0</td>
<td class="org-right">1.0</td>
<td class="org-left">1.20</td>
<td class="org-left">12 May 2009</td>
<td class="org-left">#version 100</td>
</tr>

<tr>
<td class="org-left">3.00.6[15]</td>
<td class="org-right">3.0</td>
<td class="org-right">2.0</td>
<td class="org-left">3.30</td>
<td class="org-left">29 January 2016</td>
<td class="org-left">#version 300 es</td>
</tr>

<tr>
<td class="org-left">3.10.5[16]</td>
<td class="org-right">3.1</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">GLSL ES 3.00</td>
<td class="org-left">29 January 2016</td>
<td class="org-left">#version 310 es</td>
</tr>

<tr>
<td class="org-left">3.20.6[17]</td>
<td class="org-right">3.2</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">GLSL ES 3.10</td>
<td class="org-left">10 July 2019</td>
<td class="org-left">#version 320 es</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.wikipedia.org/wiki/OpenGL_Shading_Language</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org70433bb" class="outline-5">
<h5 id="org70433bb">ERROR Validation Error: [ VUID-VkShaderModuleCreateInfo-pCode-01091 ]</h5>
<div class="outline-text-5" id="text-org70433bb">
<p>
该错误貌似并没有任何影响<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org27e3729" class="outline-3">
<h3 id="org27e3729">GPU Driven Rendering</h3>
<div class="outline-text-3" id="text-org27e3729">
</div>
<div id="outline-container-org326a53d" class="outline-4">
<h4 id="org326a53d">Init Setup</h4>
<div class="outline-text-4" id="text-org326a53d">
</div>
<div id="outline-container-org1f4300d" class="outline-5">
<h5 id="org1f4300d">编译 assimp</h5>
<div class="outline-text-5" id="text-org1f4300d">
<ol class="org-ol">
<li>下载 assimp 源代码，放置到 MySDK/assimp/ 目录下<br /></li>
<li>使用 CMake 进行编译<br /></li>
<li>将编译出来的 assimp-vc142-mt.dll 和 assimp-vc142-mt.lib 文件放置到 third_party/assimp_build/code/Release/ 目录下<br /></li>
<li>将头文件目录 MySDK/assimp/include 放置到 third_party/assimp/include<br /></li>
</ol>
</div>
</div>

<div id="outline-container-orgbf193f0" class="outline-5">
<h5 id="orgbf193f0">导出 asset</h5>
<div class="outline-text-5" id="text-orgbf193f0">
<p>
执行下面命令，将模型导出为 prefab 文件(.pfb)，将贴图导出为.tx 文件<br />
</p>

<div class="org-src-container">
<pre class="src src-shell">.\bin\Debug\baker.exe .\assets<span style="color: #2d9574;">\</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2deba3d" class="outline-4">
<h4 id="org2deba3d">GPU Driven Rendering Overview</h4>
<div class="outline-text-4" id="text-org2deba3d">
<p width="900px">
<img src="./Vulkan/vg_cityrender.png" alt="vg_cityrender.png" width="900px" /><br />
上图处理了 125000 个对象，并且在 main view 和 shadow view 上执行了 culling，帧数达到了 290FPS。上面的视图渲染处理了 4 亿个三角形(main view+shadow view), 使用的显卡为 RTX2080.<br />
</p>
</div>
<div id="outline-container-org7d450b3" class="outline-5">
<h5 id="org7d450b3">Introduction</h5>
<div class="outline-text-5" id="text-org7d450b3">
<p>
在过去几年中，前沿渲染引擎越来越倾向于在 GPU 上的 compute shaders 中计算渲染本身。 由于引入了 MultiDrawIndirect 和类似的功能，现在可以在 compute shaders 中执行大量的渲染工作。这样做的好处很明显：<br />
</p>
<ul class="org-ul">
<li>在数据并行算法上，GPU 的性能比 CPU 高几个数量级。渲染几乎都是数据并行算法。<br /></li>
<li>随着 GPU 决定自己的工作，延迟被最小化，因为没有从 CPU 到 GPU 的往返。<br /></li>
<li>将 CPU 从大量工作中解放出来，这些工作现在可以用于其他事情。<br /></li>
</ul>

<p>
这样就可以支持更复杂的场景以及更多的对象。以第五章教程的代码为基础，我们将逐步深入。最终，我们可以在 Nintendo Switch 上执行 250000 个 drawcall，并且达到 60fps。在 PC 平台上则可以达到 500fps。我们基本上几乎可以使用无限数量的对象，瓶颈转移为 GPU 可以绘制多少个三角形。如下图所示，CPU 处理消耗少于 0.5 毫秒。<br />
</p>


<div id="org2675f9a" class="figure">
<p><img src="./Vulkan/vg_indirectperf.png" alt="vg_indirectperf.png" width="900px" /><br />
</p>
</div>

<p>
基于 compute-shader-rendering 的技术在过去 5 年变得越来越流行。之前，该技术主要用于 CAD 类型的场景。著名的刺客信条-大革命(Assassin's Creed: Unity)及其续作使用该技术使得场景复杂度提高了一个数量级。在龙腾世纪-审判(Dragon Age: Inquisition)中为了达到非常高的几何细节，Frostbite 引擎也采用了这种技术。就是因为这种技术，彩虹六号(Rainbow Six Siege)才能从其破坏系统中创建数以千计的动态碎片。这些技术在 PS4 和 Xbox One 游戏机上非常流行，因为它们很容易在三角形吞吐量方面遇到瓶颈，因此非常准确的剔除可以带来非常大的性能提升。Unreal Engine 4 和 Unity 没有使用这种技术，Unreal Engine 5 可能将会使用该技术。<br />
</p>
</div>
</div>
<div id="outline-container-org0aa70c9" class="outline-5">
<h5 id="org0aa70c9">Draw Indirect</h5>
<div class="outline-text-5" id="text-org0aa70c9">
<p>
这个想法的核心围绕着在图形 API 中使用 Draw Indirect 支持。 这些技术适用于所有图形 API，但它们在 Vulkan 或 DX12 上效果最佳，因为它们可以更好地控制低级内存管理和 compute barriers。它们在 PS4 和 Xbox One 游戏机上也能很好地工作，并且下一代游戏机所具备的特性对这种技术的依赖更大，例如 mesh shaders 和 raytracing。<br />
</p>

<p>
draw indirect 是一个 drawcall，其从 GPU buffer 中获取参数，而不是通过函数调用直接传递参数。当使用 draw indirect 时，你只需要指定在 gpu buffer 上哪个位置获取参数即可，伪代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">normal drawing ---------------</span>
vkCmdDrawIndexed(cmd, object.indexCount, 1 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">instance count</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>,object.firstIndex, object.vertexOffset, object.ID <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">firstInstance</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span> );

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect drawing ---------------</span>

<span style="color: #ce537a; font-weight: bold;">Buffer</span>* <span style="color: #7590db;">drawBuffer</span> = create_buffer(<span style="color: #4f97d7; font-weight: bold;">sizeof</span>(VkDrawIndexedIndirectCommand));

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">we can immediately enqueue the draw indirect</span>
vkCmdDrawIndexedIndirect(cmd, drawBuffer.buffer, 0 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">offset</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>, 1 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">drawCount</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>(VkDrawIndexedIndirectCommand));


<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">we can write the actual draw command at any time we want before VkQueueSubmit(), or from a different thread, or from a compute shader</span>
<span style="color: #ce537a; font-weight: bold;">VkDrawIndexedIndirectCommand</span>* <span style="color: #7590db;">command</span> = map_buffer(drawBuffer);

command-&gt;indexCount = object.indexCount;
command-&gt;instanceCount = 1;
command-&gt;firstIndex = object.firstIndex ;
command-&gt;vertexOffset = object.vertexOffset;
command-&gt;firstInstance = object.ID;
</pre>
</div>
<p>
因为其从一个 gpu buffer 上获取参数，因此可以使用 compute shaders 将参数写入 gpu buffer，并且在 compute shaders 中进行 culling 或 LOD 选择。这种方法是执行 culling 最简单、最高效的方法之一。借助 GPU 强大的功能，可以在不到半毫秒的时间内剔除超过一百万个对象。一般的场景都不会有那么多物体。在更高级的管线中(如龙腾世纪-审判(Dragon Age: Inquisition)或彩虹六号(Rainbow Six Siege)中使用的管线), 会更进一步从 meshes 中剔除三角形。他们为幸存的三角形生成新的 index buffer，然后使用新生成的 index buffer 来进行绘制。<br />
</p>

<p>
当你设计一个 GPU-driven renderer 时，主要的理念是场景的一切都应该在 GPU 上。前面教程中，我们看到如何将所有加载的对象对应的 matrices 存储到一个大的 SSBO(Shader Storage Buffer Object) 中。在 GPU driven pipelines，我们需要存储更多的数据，如 material ID、cull bounds。如果我们将所有的一切都存储到大 GPU buffers 中，我们将不再为每个对象使用 PushConstants 或 descriptor sets。<br />
</p>

<p>
由于希望尽可能在 GPU 上做更多事情，如果将 GPU-driven renderer 和 Bindless 技术相结合，你将不需要为每个材质绑定 descriptor sets 或更改 vertex buffers。毁灭战士：永恒（DOOM Eternal）引擎中，他们全面使用了 bindless，引擎最终每帧只执行很少的 drawcall。在本教程中，我们不会使用 bindless textures, 因为他们的支持是有限的，我们将对每个使用的材质进行一次 draw-indirect。我们仍然会将所有的 meshes 合并到一个大的 vertex buffer 中，以避免在绘制之间不断地执行绑定操作。bindless renderer 还可以使光线追踪更加高效。<br />
</p>

<ul class="org-ul">
<li>OpenGL 中 RBO 与 Texture,UBO 与 SSBO 的异同 <a href="https://blog.csdn.net/w450468524/article/details/51649071">https://blog.csdn.net/w450468524/article/details/51649071</a><br /></li>
<li>Bindless Texture <a href="https://www.khronos.org/opengl/wiki/Bindless_Texture">https://www.khronos.org/opengl/wiki/Bindless_Texture</a><br /></li>
<li>游戏引擎随笔 0x05：现代图形 API 讲义 <a href="https://zhuanlan.zhihu.com/p/73016473">https://zhuanlan.zhihu.com/p/73016473</a><br /></li>
<li>游戏引擎随笔 0x13：现代图形 API 的 Bindless <a href="https://zhuanlan.zhihu.com/p/136449475">https://zhuanlan.zhihu.com/p/136449475</a><br /></li>
<li>游戏引擎随笔 0x23：再论现代图形 API 的 Bindless（上）<a href="https://zhuanlan.zhihu.com/p/416895286">https://zhuanlan.zhihu.com/p/416895286</a><br /></li>
<li>游戏引擎随笔 0x24：再论现代图形 API 的 Bindless（下）<a href="https://zhuanlan.zhihu.com/p/421175854">https://zhuanlan.zhihu.com/p/421175854</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org183bf79" class="outline-5">
<h5 id="org183bf79">Bindless Design</h5>
<div class="outline-text-5" id="text-org183bf79">
<p>
NovusCore 是一个 Wow 模拟器研究项目。World of Warcraft 中的一整个大陆的渲染只要不到 10 次 drawcalls，并且帧率可达到 100+FPS, 不限制绘制距离。<br />
</p>

<p>
当 binds 数量尽可能少时，GPU driven pipeline 的效果最佳。最好的情况是执行极少量的 BindVertexBuffer、BindIndexBuffer、BindPipeline 和 BindDescriptorSet 调用。 Bindless designs 使 CPU 端的工作速度更快， CPU 只需做更少的工作，并且 GPU 也可以更快地运行，由于每个 drawcall 都“更大”, GPU 利用率更高。 用于渲染场景的绘制调用越少越好，因为现在的 GPU 真的很大，并且有很长的 ramp up/down 时间。 现在的 GPU 喜欢在每次绘制调用时为它们提供大量工作，因为这样它们的使用率可以提高到 100%。<br />
</p>

<p>
为了将 vertex buffer 和 index buffer 转为 bindless 方式，通常你需要将 meshes 合并到一个大的 buffers 中。不再是 1 个 buffer 对应一对 vertex buffer 和 index buffer，而是 1 个 buffer 对应场景中所有的 vertex buffers。当渲染时，在 drawcalls 中使用 BaseVertex 偏移来指定渲染的物体。<br />
在有些引擎中，他们从 pipelines 中完全移除了 vertex attributes，他们在 vertex shader 中从 buffer 中来获取顶点数据。这样为所有 drawcalls 保存一个大的 vertex buffer 会很容易，即使不同的 drawcalls 使用的 vertex attribute 的格式不同。并且还可以使用一些高级的打包/压缩技术，这是 Mesh Shaders 的主要使用案例。<br />
</p>

<p>
为了将 textures 转为 bindless 方式，你可以使用 texture arrays。使用正确的扩展，shader 中 texture array 的尺寸可以是无限的，如同你使用 SSBOs。这样，在 shader 中访问 textures 时，你通过索引来进行访问，该索引是从另一个 buffer 获取到的。如果你不使用 Descriptor Indexing 扩展，你依然可以使用 texture arrays，此时 texture arrays 的尺寸必须是有限的，查询你的设备限制可获得最大的值。<br />
</p>

<p>
为了将 materials 转为 bindless 方式，你不能在为每个材质创建一个 pipeline，你需要将材质参数放到 SSBOs 中，采用一个 ubershader 的方式来渲染。在 Doom 引擎中，他们只使用了少量的 pipelines。Doom eternal 中的 pipelines 数量要少于 500，而 Unreal Engine 游戏通常都会有 100000+个 pipelines。如果你使用 ubershaders 来极大减少 pipelines 的数量，你将可以极大地增加效率，因为 VkCmdBindPipeline 是最耗时的调用之一。<br />
</p>

<p>
Push Constants 和 Dynamic Descriptors 可以被使用，但是他们必须是全局的。使用 push constants 来存储摄像机位置是可以的，但是你不能使用他们来存储对象 ID，因为这是和每个对象相关的，而你希望在一次绘制调用中处理尽可能多的对象。<br />
</p>

<p>
整体上的工作流程是，将相关的数据放入 buffers 中，采用大的 buffers 你就不需要在每次调用之间绑定这些 buffers。带来的好处是，你也可以在 GPU 上将数据写入这些 buffers 中，例如：Dragon Age Inquisition 就是在 GPU 上为 index buffers 写入数据的，其在 culling shaders 中将 index 数据写入 index buffers 中，这样只有可见的三角形会被绘制。<br />
</p>
</div>
</div>

<div id="outline-container-org6562b2d" class="outline-5">
<h5 id="org6562b2d">Overview of Vkguide engine architecture for compute rendering.</h5>
<div class="outline-text-5" id="text-org6562b2d">
<p>
第一件事是将对象数据都放到 GPU buffers 中。需要移除对应于每个对象的 PushConstants，也需要移除对应于每个对象的 uniform buffers，一切都要用 ObjectBuffer 替换，例如：我们将对象的 matrix 存储在其中，并在 shader 中通过索引获得该 matrix 数据。<br />
</p>

<p>
我们还要修改 meshes 的工作方式。加载完一个场景后，我们创建一个大的 vertex buffer,将所有场景中的 meshes 都放入该 vertex buffer。这样就可以避免重复绑定多个 vertex buffers。<br />
</p>

<p>
数据管理完成后，我们就可以实现 indirect draw 了。<br />
</p>

<p>
我们将会按照 mesh-pass 来对可渲染对象进行分割。每个 mesh-pass 是渲染器中的一个特定的 pass。本教程中，我们将采用 2 个 mesh passes，一个为 forward-rendered mesh-pass, 另一个为阴影投射 mesh-pass。一些对象只会在其中一个 pass 中注册，而大多数对象则在两个 passes 中都会注册。将多个不同的对象分到多个 mesh-passes 中，可以显著简化渲染主循环，并且可以提升性能。<br />
</p>

<p>
处理 indirect draws 的代码在 RenderScene 类中，其会抓取一个 mesh-pass 中的所有对象，并将他们排列为多个 batches。一个 Batch 是一组对象他们使用了相同的材质和 mesh。每个 batch 的渲染都会使用一个 DrawIndirect 调用，该调用执行 instanced drawing。每个 mesh pass(forward pass, shadow pass, 等等)都包含一个 batches 数组。<br />
</p>

<p>
在主 ObjectBuffer 中，我们存储对象的 matrix 以及 cull bounds。<br />
</p>

<p>
当开始一帧时，我们将每个 mesh pass 中的对象都同步到一个 buffer 中。该 buffer 是一个对象数组，每个对象为 ObjectID+BatchID。BatchID 直接映射为一个索引，该索引为 mesh-pass 中 batch 数组的索引。<br />
</p>

<p>
当我们将该 buffer 上传同步到 GPU 后，我们执行一个 compute shader 来进行 culling。对于上述 ObjectID + BatchID 对象数组中的每个对象，我们使用 ObjectID 访问 ObjectBuffer 中的对象数据，并检查它是否可见。 如果它是可见的，我们将 BatchID 对应的绘制插入到 batches array 中，该 batches array 包含了所有的 indirect calls。我们还会将其写入 indirection buffer 中，该 buffer 将每个 batch 的 instance ID 映射到对应的 ObjectID。<br />
</p>

<p>
然后，我们就可以在 CPU 端遍历一个 mesh pass 中的所有 batches，然后按顺序执行这些 batches，执行前需要为当前 batch pipeline 绑定 material descriptor set。GPU 将会使用其刚刚在 culling pass 写入的参数来渲染对象。<br />
</p>


<div id="org29167b5" class="figure">
<p><img src="./Vulkan/vg-gpu-driven-rendering-overview.jpg" alt="vg-gpu-driven-rendering-overview.jpg" width="500px" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge141ecf" class="outline-4">
<h4 id="orge141ecf">Engine architecture overview</h4>
<div class="outline-text-4" id="text-orge141ecf">
</div>
<div id="outline-container-org524d82c" class="outline-5">
<h5 id="org524d82c">Asset System</h5>
<div class="outline-text-5" id="text-org524d82c">
<p>
资源系统的设计架构图如下：<br />
</p>


<div id="org2e6b848" class="figure">
<p><img src="./Vulkan/vg-assetsystem01.jpg" alt="vg-assetsystem01.jpg" width="500px" /><br />
</p>
</div>

<p>
converter 是一个单独的执行程序，其可以遍历一个目录下的所有文件，将默认格式的文件转化为优化格式的文件。<br />
AssetLib 是一个共享库。converter 和 engine 都会引用该 lib。其定义了引擎使用的资源的标准格式，并提供了加载资源，序列化资源的接口。<br />
</p>
</div>

<div id="outline-container-orgd39aea6" class="outline-6">
<h6 id="orgd39aea6">Asset Format</h6>
<div class="outline-text-6" id="text-orgd39aea6">
<p>
资源数据分为两部分：一个 json 字符串+一段二进制数据<br />
json 字符串包含了资源对象的一些信息，例如：若资源为图片资源，则 json 字符串中存储了图片的宽度、高度、格式等等<br />
二进制数据包含了资源对象的原始数据，例如：若资源为图片资源，则二进制数据就是图片的所有像素数据<br />
</p>

<p>
对于二进制数据，我们会使用 LZ4 压缩格式。使用压缩格式可以加速从磁盘读取文件的速度。<br />
</p>
</div>
</div>

<div id="outline-container-org0bf4692" class="outline-6">
<h6 id="org0bf4692">Texture Asset</h6>
<div class="outline-text-6" id="text-org0bf4692">
<p>
贴图资源相关的结构体和函数都在 texture_asset.h 和 texture_asset.cpp 中。<br />
</p>

<p>
json 字符串中存储了图片的宽度、高度、贴图格式、压缩格式等等，对应于 TextureInfo 数据结构<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mipmap &#20449;&#24687;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">PageInfo</span> {
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">width</span>;
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">height</span>;
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">compressedSize</span>;
    <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">originalSize</span>;
};
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36148;&#22270;&#20449;&#24687;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">TextureInfo</span> {
    <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">textureSize</span>;
    <span style="color: #ce537a; font-weight: bold;">TextureFormat</span> <span style="color: #7590db;">textureFormat</span>;
    <span style="color: #ce537a; font-weight: bold;">CompressionMode</span> <span style="color: #7590db;">compressionMode</span>;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">originalFile</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">PageInfo</span>&gt; <span style="color: #7590db;">pages</span>;
};
</pre>
</div>

<p>
引擎加载图片资源后，先读取 json 字符串部分，得到 TextureInfo 信息，然后，根据 TextureInfo 信息对二进制部分进行解压缩。之后调用 Vulkan 相关的 API 创建 VkImage 对象，利用 CommandBuffer 将图片数据提交到 GPU 端 VkImage 对应的内存。<br />
</p>

<p>
引擎实现了一个简单的贴图 cache，以贴图名称为 key，以 Texture 对象为值。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Texture</span> {
    <span style="color: #ce537a; font-weight: bold;">AllocatedImage</span> <span style="color: #7590db;">image</span>;
    <span style="color: #ce537a; font-weight: bold;">VkImageView</span> <span style="color: #7590db;">imageView</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">AllocatedImage</span> {
    <span style="color: #ce537a; font-weight: bold;">VkImage</span> <span style="color: #7590db;">_image</span>;
    <span style="color: #ce537a; font-weight: bold;">VmaAllocation</span> <span style="color: #7590db;">_allocation</span>;
    <span style="color: #ce537a; font-weight: bold;">VkImageView</span> <span style="color: #7590db;">_defaultView</span>;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">mipLevels</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orge13a578" class="outline-6">
<h6 id="orge13a578">Mesh Asset</h6>
<div class="outline-text-6" id="text-orge13a578">
<p>
模型资源相关的结构体和函数都在 mesh_asset.h 和 mesh_asset.cpp 中。<br />
</p>

<p>
json 字符串中存储了模型顶点数据的大小、索引数据的大小、模型的 bounds 等等，对应 MeshInfo 数据结构<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">MeshBounds</span> {
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">origin</span>[3];
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">radius</span>;
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">extents</span>[3];
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">MeshInfo</span> {
    <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">vertexBuferSize</span>;
    <span style="color: #ce537a; font-weight: bold;">uint64_t</span> <span style="color: #7590db;">indexBuferSize</span>;
    <span style="color: #ce537a; font-weight: bold;">MeshBounds</span> <span style="color: #7590db;">bounds</span>;
    <span style="color: #ce537a; font-weight: bold;">VertexFormat</span> <span style="color: #7590db;">vertexFormat</span>;
    <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">indexSize</span>;
    <span style="color: #ce537a; font-weight: bold;">CompressionMode</span> <span style="color: #7590db;">compressionMode</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">originalFile</span>;
};
</pre>
</div>

<p>
引擎加载模型资源后，先读取 json 字符串部分，得到 MeshInfo 信息，然后，根据 MeshInfo 信息对二进制部分进行解压缩。之后将顶点数据和索引数据存储到 Mesh 对象中，利用 memcpy 将数据提交到 GPU 端 VkBuffer 对应的内存。<br />
</p>

<p>
引擎实现了一个简单的模型 cache，以模型路径为 key，以 Mesh 对象为值。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Mesh</span> {
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;Vertex&gt; <span style="color: #7590db;">_vertices</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">_indices</span>;

    <span style="color: #ce537a; font-weight: bold;">AllocatedBuffer</span>&lt;Vertex&gt; <span style="color: #7590db;">_vertexBuffer</span>;
    <span style="color: #ce537a; font-weight: bold;">AllocatedBuffer</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint32_t</span>&gt; <span style="color: #7590db;">_indexBuffer</span>;

    <span style="color: #ce537a; font-weight: bold;">RenderBounds</span> <span style="color: #7590db;">bounds</span>;

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">load_from_meshasset</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #7590db;">filename</span>);
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org15a96b9" class="outline-6">
<h6 id="org15a96b9">Material Asset</h6>
<div class="outline-text-6" id="text-org15a96b9">
<p>
材质资源只包含了 json 字符串部分，没有二进制数据部分。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">MaterialInfo</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26448;&#36136;&#21517;&#31216;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">baseEffect</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26448;&#36136;&#36148;&#22270;&lt;&#21517;&#31216;&#65292;&#36335;&#24452;&gt;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">textures</span>; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">name -&gt; path</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26448;&#36136;&#23646;&#24615;&lt;&#23646;&#24615;&#21517;&#65292;&#23646;&#24615;&#20540;&gt;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">customProperties</span>;
    <span style="color: #ce537a; font-weight: bold;">TransparencyMode</span> <span style="color: #7590db;">transparency</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orga91e328" class="outline-6">
<h6 id="orga91e328">Prefab Asset</h6>
<div class="outline-text-6" id="text-orga91e328">
<p>
预制体资源是对应了一系列节点树。 json 字符串部分对应 PrefabInfo 信息，二进制部分存储节点矩阵数据<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">PrefabInfo</span>
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33410;&#28857;&#30340;matrix &#32034;&#24341; &lt;&#33410;&#28857;ID&#65292;&#33410;&#28857;matrix&#32034;&#24341;&gt;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint64_t</span>, <span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">node_matrices</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33410;&#28857;&#30340;matrix &#32034;&#24341; &lt;&#33410;&#28857;ID&#65292;&#33410;&#28857;&#21517;&#31216;&gt;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint64_t</span>, <span style="color: #a45bad;">std</span>::string&gt; <span style="color: #7590db;">node_names</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33410;&#28857;&#30340;matrix &#32034;&#24341; &lt;&#33410;&#28857;ID&#65292;&#29238;&#33410;&#28857;ID&gt;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint64_t</span>, <span style="color: #ce537a; font-weight: bold;">uint64_t</span>&gt; <span style="color: #7590db;">node_parents</span>;

    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">NodeMesh</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">material_path</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">mesh_path</span>;
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #ce537a; font-weight: bold;">uint64_t</span>, <span style="color: #ce537a; font-weight: bold;">NodeMesh</span>&gt; <span style="color: #7590db;">node_meshes</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;<span style="color: #ce537a; font-weight: bold;">float</span>,16&gt;&gt; <span style="color: #7590db;">matrices</span>;
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org02de1fc" class="outline-5">
<h5 id="org02de1fc">Abstraction for descritpor sets</h5>
<div class="outline-text-5" id="text-org02de1fc">
<p>
将 VkDescriptorPool 的创建封装在 DescriptorAllocator 中，并使用缓冲池进行管理，缓冲池中 VkDescriptorPool 的容量不够时才分配新的。<br />
将 VkDescriptorSetLayout 的创建封装在 DescriptorLayoutCache 中，并使用缓冲池进行管理，将创建的 VkDescriptorSetLayout 添加到缓冲池中，下次创建相同的 VkDescriptorSetLayout 时，直接使用缓冲池中的 VkDescriptorSetLayout。<br />
</p>
</div>
</div>
<div id="outline-container-org7e86169" class="outline-5">
<h5 id="org7e86169">Configurable options through a CVAR System</h5>
<div class="outline-text-5" id="text-org7e86169">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">//// </span><span style="color: #2aa1ae; background-color: #292e34;">CVAR &#31995;&#32479;&#20013;&#38745;&#24577;&#27880;&#20876;&#21464;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">checkbox CVAR</span>
<span style="color: #ce537a; font-weight: bold;">AutoCVar_Int</span> <span style="color: #7590db;">CVAR_TestCheckbox</span>(<span style="color: #2d9574;">"test.checkbox"</span>, <span style="color: #2d9574;">"just a checkbox"</span>, 0, <span style="color: #a45bad;">CVarFlags</span>::EditCheckbox);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">int CVAR</span>
<span style="color: #ce537a; font-weight: bold;">AutoCVar_Int</span> <span style="color: #7590db;">CVAR_TestInt</span>(<span style="color: #2d9574;">"test.int"</span>, <span style="color: #2d9574;">"just a configurable int"</span>, 42);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float CVAR</span>
<span style="color: #ce537a; font-weight: bold;">AutoCVar_Int</span> <span style="color: #7590db;">CVAR_TestFloat</span>(<span style="color: #2d9574;">"test.float"</span>, <span style="color: #2d9574;">"just a configurable float"</span>, 13.37);
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">string CVAR</span>
<span style="color: #ce537a; font-weight: bold;">AutoCVar_String</span> <span style="color: #7590db;">CVAR_TestString</span>(<span style="color: #2d9574;">"test.string"</span>, <span style="color: #2d9574;">"just a configurable string"</span>, <span style="color: #2d9574;">"just a configurable string"</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get value</span>
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">var</span> = CVAR_TestInt.Get();

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set value</span>
CVAR_TestInt.Set(7);

<span style="color: #2aa1ae; background-color: #292e34;">//// </span><span style="color: #2aa1ae; background-color: #292e34;">CVAR &#31995;&#32479;&#20013;&#21160;&#24577;&#27880;&#20876;&#21464;&#37327;</span>
<span style="color: #ce537a; font-weight: bold;">CVarParameter</span>* <span style="color: #7590db;">cvar</span> = <span style="color: #a45bad;">CVarSystem</span>::Get()-&gt;CreateIntCVar(<span style="color: #2d9574;">"test.int2"</span>, <span style="color: #2d9574;">"another int cvar"</span>, 3<span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">default value</span><span style="color: #2aa1ae; background-color: #292e34;"> */</span>, 3<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">current value</span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get value</span>
<span style="color: #ce537a; font-weight: bold;">int</span>* <span style="color: #7590db;">value</span> = <span style="color: #a45bad;">CVarSystem</span>::Get()-&gt;GetIntCvar(<span style="color: #2d9574;">"test.int"</span>);
<span style="color: #4f97d7; font-weight: bold;">if</span>(value)
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">var</span> = *value;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set value (for the setter it can be done directly. if the cvar doesn't exist, this does nothing)</span>
<span style="color: #a45bad;">CVarSystem</span>::Get()-&gt;SetIntCvar(<span style="color: #2d9574;">"test.int"</span>,3);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0eadb9" class="outline-5">
<h5 id="orgb0eadb9">Multithreading for game engines</h5>
<div class="outline-text-5" id="text-orgb0eadb9">
</div>
<div id="outline-container-org6835a15" class="outline-6">
<h6 id="org6835a15">Ways of using multithreading in game engines</h6>
<div class="outline-text-6" id="text-org6835a15">
<p>
一开始游戏引擎都是单线程的。最早期最经典的多线程游戏引擎会直接创建多个线程，每个线程执行他们自己的任务。例如，你可以有一个 Game Thread，来执行所有的 gameplay 逻辑和 AI；一个 Render Thread 处理渲染，准备需要绘制的物体，并执行图形命令。其架构如下图所示：<br />
</p>

<div id="orgb48913f" class="figure">
<p><img src="./Vulkan/vg-multi-thread-gameEngine.jpg" alt="vg-multi-thread-gameEngine.jpg" width="500px" /><br />
</p>
</div>

<p>
UE4 有一个 Game Thread 和一个 Render Thread 作为主要的线程，还有一些其他线程用于 audio、loading 以及 helpers。UE 中 Game Thread 执行所有的游戏开发者使用 Blueprints 和 C++编写的游戏逻辑，在每一帧结束时，其会和 Render Thread 同步场景中物体的的位置和状态。Render Thread 会处理所有的渲染逻辑，并将结果显示。<br />
</p>

<p>
上面这种架构非常流行也非常简单易用，但是其缺点是伸缩性很糟糕。通常 UE4 开发的游戏在核心数量超过 4 的平台上无法有效利用所有核心，在主机平台上由于其无法为 8 个核心填充满工作，性能会很低。这种模型的另一个缺点是，通常多个线程中的某个线程比其他线程执行的工作要多，导致等待。在 UE4 中，Game Thread 和 Render Thread 在每帧都会进行同步，因此其中任何一个线程变慢，整体都会变慢。例如，如果游戏包含了很多 blueprint 和 AI 计算，则 Game Thread 会在 1 个核心上繁忙工作，而机器的其他核心却没被使用。<br />
</p>

<p>
增强这种架构的一种通用方式是将更多内容改为 fork/join 方式，你有一个主要的执行线程，在某些点上，工作的多个部分被分配到多个线程上。UE4 就是这样处理动画和物理的。Game Thread 负责整个游戏逻辑，当其到达需要播放动画的点时，将动画分割成小任务进行计算，并将这些任务分配给其他核心的辅助线程。虽然仍然有一个主要的执行时间线，但在某些点其可以从未使用的内核中获得额外的帮助。这提高了可伸缩性，但仍然不够好，因为框架的其余部分仍然是单线程的。这种增强后的架构图如下：<br />
</p>

<div id="org9e00270" class="figure">
<p><img src="./Vulkan/vg-multi-thread-gameEngine01.jpg" alt="vg-multi-thread-gameEngine01.jpg" width="500px" /><br />
</p>
</div>

<p>
最近，游戏引擎的架构已经进化为试图确保所有核心都参与工作。很多游戏引擎引入 Task based system 来达到此目的。这种架构下，不再是让一个线程专门做一件事情，而是将工作划分为多个小部分，多个线程并行处理，并在任务完成后合并结果。和 fork-join 方式不同(这种方式有一个专门的线程，由其将工作派发给 helper)，你会在 helper 线程上执行一切。所有操作的时间线被构建为一个任务图，这些任务会被分配到多个核上执行。当一个任务的所有前置任务完成后，该任务才可以开始执行。如果任务系统使用得当，它会提供非常好的伸缩性，因为所有内容都会自动分发到可用的 CPU 核心上进行执行。<br />
</p>

<p>
Doom Eternal 就使用了 Task based System。Naughty Dog Engine 和 2 Destiny Engine 这两个引擎也都引入了 Task based system。UE4 中引入了类似的 TaskGraph 系统。<br />
</p>

<ul class="org-ul">
<li>多线程 <a href="https://www.cnblogs.com/timlly/p/14327537.html">https://www.cnblogs.com/timlly/p/14327537.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4a5eb83" class="outline-6">
<h6 id="org4a5eb83">In practive</h6>
<div class="outline-text-6" id="text-org4a5eb83">
</div>
<ul class="org-ul">
<li><a id="orgf0bc8e8"></a>经典游戏引擎多线程模型<br />
<div class="outline-text-7" id="text-orgf0bc8e8">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GameLoop</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>finish)
    {
        SyncRenderThread();

        PerformGameLogic();

        SyncRenderThread();
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">gamethread</span>(GameLoop);

    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>finish)
    {
        SyncGameThread();

        PerformRenderLogic();

        SyncGameThread();

        CopyGameThreadDataToRenderer();
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">PerformGameLogic</span>()
{
    input-&gt;QueryPlayerInput();
    player-&gt;UpdatePlayerCharacter();

    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">AICharacter</span>* <span style="color: #7590db;">AiChar</span> : AICharacters)
    {
        AiChar-&gt;UpdateAI();
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">WorldObject</span>* <span style="color: #7590db;">Obj</span> : Objects)
    {
        Obj-&gt;Update();
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">Particle</span>* <span style="color: #7590db;">Part</span> : ParticleSystems)
    {
        Part-&gt;UpdateParticles();
    }

    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">AICharacter</span>* <span style="color: #7590db;">AiChar</span> : AICharacters)
    {
        AiChar-&gt;UpdateAnimation();
    }

    physicsSystem-&gt;UpdatePhysics();
}
</pre>
</div>
<p>
上面代码中，游戏逻辑全部在 GameThread 执行，渲染逻辑全部在主线程执行。每一帧 GameThread 和 MainThread(RenderThread)都会进行同步，当 GameThread 和 MainThread(RenderThread) 都完成工作后，RenderThread 会将 GameThread 的数据 Copy 到 RenderThread 内部的数据结构中。在这样的设计中，GameThread 不能访问 RenderThread 的内部数据结构，RenderThread 访问 GameThread 的数据也只能在 GameThread 完成执行后。两个线程各自执行各自的逻辑，只在一帧结束时，同步数据。<br />
</p>
</div>
</li>
<li><a id="orgb497870"></a>利用 helper 线程增强上述多线程模型<br />
<div class="outline-text-7" id="text-orgb497870">
<p>
在游戏逻辑线程的 GameLoop 中，每一帧都需要按顺序执行一系列事情。我们可以找出哪些可以独立运行的任务，将其分配到其他线程执行。例如，AiCharacter 上执行的 UpdateAnimation()只会访问对应的 AiCharacter，因此可以将其分配到其他线程执行。如下面代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par, <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">we need the execution::par for this foreach to execute parallel. It's on the &lt;execution&gt; header</span>
              AICharacters.begin(),
              AICharacters.end(),
              [](<span style="color: #ce537a; font-weight: bold;">AICharacter</span>* <span style="color: #7590db;">AiChar</span>)
              { <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">cpp lambda that executes for each element in the AICharacters container.</span>
                  AiChar-&gt;UpdateAnimation();
              });
</pre>
</div>
</div>
</li>
<li><a id="orgf976288"></a>引入 TaskSystem<br />
<div class="outline-text-7" id="text-orgf976288">
<p>
我们使用 std::async 来作为一个 task system，std::async 会创建一个轻量级的 thread，我们可以创建很多 lightweight thread 而不引起很大问题，创建 lightweight thread 的消耗要比创建 std::thread 要少很多。不过需要确认这种方式在你的平台上是如何运行的，例如，在 VisualStudio 平台上这种方式实现非常好，但是，GCC/clang 的实现方式可能并非如此。你可以使用 Taskflow 这样的库来代替这里使用 std::async 的方式。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">player_tasks</span> = <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,
                               [](){
                               input-&gt;QueryPlayerInput();
                               player-&gt;UpdatePlayerCharacter();
                               });

<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">ai_task</span> = <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,
                          [](){
                          <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">we cant parallelize all the AIs together as they communicate with each other, so no parallel for here.</span>
                              <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">AICharacter</span>* <span style="color: #7590db;">AiChar</span> : AICharacters)
                              {
                                  AiChar-&gt;UpdateAI();
                              }
                          });

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">lets wait until both player and AI asyncs are finished before continuing</span>
player_tasks.wait();
ai_task.wait();

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">world objects cant be updated in parallel as they affect each other too</span>
<span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">WorldObject</span>* <span style="color: #7590db;">Obj</span> : Objects)
{
    Obj-&gt;Update();
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">particles is standalone AND we can update each particle on its own, so we can combine async with parallel for</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">particles_task</span> = <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,
                                 [](){
                                 <span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,
                                               ParticleSystems.begin(),
                                               ParticleSystems.end(),
                                               [](<span style="color: #ce537a; font-weight: bold;">Particle</span>* <span style="color: #7590db;">Part</span>){
                                               Part-&gt;UpdateParticles();
                                               });
                                 });

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">same with animation</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">animation_task</span> = <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,
                                 [](){
                                 <span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,
                                               AICharacters.begin(),
                                               AICharacters.end(),
                                               [](<span style="color: #ce537a; font-weight: bold;">AICharacter</span>* <span style="color: #7590db;">AiChar</span>){
                                               AiChar-&gt;UpdateAnimation();
                                               });
                                 });

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">physics can also be updated on its own</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">physics_task</span> = <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,
                               [](){
                               physicsSystem-&gt;UpdatePhysics();
                               });

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">synchronize the 3 tasks</span>
particles_task.wait();
animation_task.wait();
physics_task.wait();
</pre>
</div>

<p>
上面代码中，我们定义了一个任务图。代码的最后面，我们并行运行了 3 个任务，虽然其中 2 个任务中使用了并行 fors，但这里的线程远远优于之前的模型。 我们在 ObjectUpdate 部分仍然是一个完全单线程执行，但至少其他事情是合理并行化的。框架的某些部分会成为任务的瓶颈并且只能在一个内核中运行是很常见的，因此大多数引擎仍然分离开游戏线程和渲染线程，但它们中的每一个都有自己的并行任务, 希望有足够的任务可以自行运行以填充所有核心。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9a5e4be" class="outline-6">
<h6 id="org9a5e4be">Identifying tasks</h6>
<div class="outline-text-6" id="text-org9a5e4be">
<p>
实践中，明确哪些任务可以和其他任务并行执行是非常难的。一个通用的方法是，将一个任务执行所需的数据打包起来，确保该任务不会访问任何其他数据。例如，渲染线程中的 Renderer 类存储了所有的渲染数据，GameThread 永远都不会访问这些数据。我们只会在一帧内的特定的时间点，允许 RenderThread 访问 GameThread 的数据，而此时 GameThread 不会访问这些数据。<br />
</p>
</div>
</div>

<div id="outline-container-org6b15b4f" class="outline-6">
<h6 id="org6b15b4f">Multithreading Vulkan</h6>
<div class="outline-text-6" id="text-org6b15b4f">
<p>
在 OpenGL 或其他老式的 APIs 中，只能在一个线程上调用 API，不是说同一时间在同一个线程上，而是只能在一个特定的线程上。对于这类 APIs，渲染器通常会创建一个专门的 OpenGL/API 线程，由该线程执行命令，而其他线程将命令发送给该线程。Doom3 引擎和 UE4 引擎都是如此。对于这些老式 API，在一些特殊的情况下，可以在多线程中调用部分 API，例如，OpenGL 的贴图加载可以在其他线程中调用，但是，这些支持都是作为扩展而实现的，可能你的系统并未实现这些扩展。总的来说，这些老式的 API 设计并没有考虑多线程。<br />
</p>

<p>
而现代的 APIs 如 Vulkan 和 DX12, 他们的设计考虑了多个线程。下面我们会看一些典型的例子，其展示了你在 Vulkan 中可以对哪些类型的事情进行多线程处理，以及对应的规则。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org34f5a3d"></a>compiling pipelines<br />
<div class="outline-text-7" id="text-org34f5a3d">
<p>
对于编译 pipelines，vkCreateShaderModule 和 vkCreateGraphicsPipeline 都允许在多个线程上同时被调用。一种通用的方式是，为 shader 编译专门指定一个后台线程，该线程定期从一个并行队列中获取编译请求，并将编译完成的 pipelines 放入另外一个队列，之后渲染主线程就可以使用编译后的 pipeline 了。如果你想要引擎没有很多卡顿，你就需要这样做。编译 shader 会花费很长时间，如果你需要在 loading 界面以外的地方实时编译 pipeline，你就需要实现这样一个多线程异步编译模式。<br />
</p>
</div>
</li>

<li><a id="org1890243"></a>descriptor set building<br />
<div class="outline-text-7" id="text-org1890243">
<p>
对于创建 descriptor sets，其也可以在多个线程中完成，只要用于分配 descriptor sets 的 DescriptorPool 不会被多个线程同时访问即可。一种通用的方式是使用管理器生成多个 DescriptorPools，当一个线程需要分配 descritprs 时，该线程从该管理器中获取一个 descriptor pool 来用，然后，再将其返回给管理器，这样以来多个线程就可以使用相同的 descriptor pool 了(管理器限制了多个线程同时使用同一个 descriptor pool)。<br />
</p>
</div>
</li>

<li><a id="org4938aa5"></a>command submission and recording<br />
<div class="outline-text-7" id="text-org4938aa5">
<p>
命令提交和记录也可以是完全并行的，但是有一些规则。<br />
</p>
<ol class="org-ol">
<li>对于一个给定的 queue，在任何时候，只能由一个线程将命令提交给该 queue. 如果你想要多个线程执行 VkQueueSubmit，你需要创建多个 queues。而在某些设备上 queues 的数量只有一个，因此引擎会指定一个专门的线程来执行 VkQueueSubmit。VkQueueSubmit 是耗费非常高的操作，当一个线程执行该操作时，引擎的主逻辑可以同步执行，而不必停下来等待。<br /></li>
<li><p>
尽管你可以从一个 command pool 创建多个 command buffers，但是你不能在多个线程中将 commands 填充到这些 command buffers 中。如果你想要在多个线程中向多个 command buffers 中填充命令，你需要创建多个 command pools，每个线程使用一个 command pool。<br />
Vulkan command buffers 有一个 primary 和 secondary command buffers 系统。 primary command buffer 可以打开和关闭 RenderPass，并且可以直接提交到队列。secondary command buffer 则用作“子”命令缓冲区，作为 primary 命令缓冲区的一部分被执行。这种设计的主要目的就是多线程提交命令。secondary command buffer 不能直接被提交到队列中，Secondary 通过 vkCmdExecuteCommands 提交到 Primary。<br />
例如，你有一个名为 ForwardPass 的 render pass。你可以创建 3 个 command pools，每个 command pool 分配 1 个 command buffer，得到 3 个 command buffer。然后，将他们分配给 3 个工作线程，每个线程将 ForwardPass 三分之一的命令记录到自己的 command buffer 中。当 3 个工作线程完成工作后，你就可以结束 main command buffer 的记录，main command buffer 最终在其自己的 render pass 上执行这 3 个 subpasses。如下面代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span> <span style="color: #7590db;">primaryBuffer</span> = allocate_buffer( main_command_pool );

vkCmdBegin(primaryBuffer, ... );

<span style="color: #ce537a; font-weight: bold;">VkRenderPassBeginInfo</span> <span style="color: #7590db;">renderPassBeginInfo</span> = init_renderpass(forward_pass);


<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">begin render pass from the main execution</span>
vkCmdBeginRenderPass(primaryBuffer, forward_pass);


<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">when allocating secondary commands, we need to fill inheritance info struct, to tell the commands what renderpass is their parent.</span>
<span style="color: #ce537a; font-weight: bold;">VkCommandBufferInheritanceInfo</span> <span style="color: #7590db;">inheritanceInfo</span> = init_inheritance_info(forward_pass);


<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">we can now record the secondary commands</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">array</span>&lt;<span style="color: #ce537a; font-weight: bold;">VkCommandBuffer</span>, 3&gt; <span style="color: #7590db;">subcommands</span>;

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">create 3 parallel tasks to each render a section</span>
parallel_for(3,[](<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">secondary commands have to be created with the inheritance info that links to renderpass</span>
    subcommands[i] = allocate_buffer( worker_command_pools[i],inheritanceInfo );

    build_scene_section(i, subcommands[i]);
});

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">now that the workers have finished writing the commands, we can add their contents to the main command buffer</span>
vkCmdExecuteCommands(primaryBuffer, subcommands.size(), subcommands.data());

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">finish the buffer</span>
vkCmdEndRenderPass(primaryBuffer);
vkEndCommandBuffer(primaryBuffer);
</pre>
</div>
<p>
这种同步 Vulkan subcommands 及其资源的方案可能很难正确完成，而且 Vulkan 命令编码非常高效，因此没有太多优化空间。 一些引擎实现了自己的命令缓冲区抽象，以便更容易由多个线程处理，然后由记录线程非常快速地将这些抽象命令转换为 Vulkan 命令。<br />
</p>

<p>
因为 Vulkan 命令记录非常高效，因此从多个线程来记录 Vulkan 命令并不是一个很大的优化。但是你的渲染器不仅仅是在一个深度循环中记录命令，其还需要做其他更多的工作。通过将命令记录拆分到多个线程中，渲染器内部可以更好地进行多线程处理。Doom eternal 就是如此实现的。<br />
</p>

<ul class="org-ul">
<li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/multithreading/multithreading.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/multithreading/multithreading.cpp</a><br /></li>
<li><a href="https://zhuanlan.zhihu.com/p/435337686">https://zhuanlan.zhihu.com/p/435337686</a><br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgabb6617"></a>data upload<br />
<div class="outline-text-7" id="text-orgabb6617">
<p>
通常会有一个专门的 IO 线程，其会从磁盘加载资源。IO 线程有自己的队列和 command allocators, 此处的队列最好是一个 transfer queue。这种方式可以将资源的上传速度从帧循环中完全独立出来，上传一组很大的贴图消耗了好几秒，主循环也不会被卡住。具体来说，就是为 IO thread 创建一个专门的 transfer queue(或者 async-compute queue)，IO thread 通过该并发队列和主循环进行通讯，从而使得上传数据以异步方式进行。可以使用 Fence 来检查，数据上传到 transfer queue 的操作是否完成，一旦完成，IO thread 就可以将该信息发送给主循环，之后引擎就可以将新的贴图或模型传递给渲染器了。<br />
</p>

<ul class="org-ul">
<li>Java 7 中的 TransferQueue <a href="https://ifeve.com/java-transfer-queue/">https://ifeve.com/java-transfer-queue/</a> 有道云有备份<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd62336b" class="outline-5">
<h5 id="orgd62336b">Render Flow</h5>
</div>
</div>

<div id="outline-container-orgd442326" class="outline-4">
<h4 id="orgd442326">Draw Indirect</h4>
</div>
<div id="outline-container-org95ae95b" class="outline-4">
<h4 id="org95ae95b">Compute Shaders</h4>
</div>
<div id="outline-container-org09ba57e" class="outline-4">
<h4 id="org09ba57e">Material System</h4>
</div>
<div id="outline-container-org9336472" class="outline-4">
<h4 id="org9336472">Mesh Rendering</h4>
</div>
<div id="outline-container-org26bbf50" class="outline-4">
<h4 id="org26bbf50">Compute based Culling</h4>
</div>
</div>
<div id="outline-container-orgef7d388" class="outline-3">
<h3 id="orgef7d388">参考资料</h3>
<div class="outline-text-3" id="text-orgef7d388">
<ul class="org-ul">
<li>vkguide <a href="https://vkguide.dev/">https://vkguide.dev/</a><br /></li>
<li>vkguide github <a href="https://github.com/vblanco20-1/vulkan-guide">https://github.com/vblanco20-1/vulkan-guide</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfbd166c" class="outline-2">
<h2 id="orgfbd166c">Vulkan vs OpenGL vs OpenGLES vs D3D</h2>
<div class="outline-text-2" id="text-orgfbd166c">
</div>
<div id="outline-container-org8ed9f95" class="outline-3">
<h3 id="org8ed9f95">Version</h3>
<div class="outline-text-3" id="text-org8ed9f95">
</div>
<div id="outline-container-org81c90ca" class="outline-4">
<h4 id="org81c90ca">OpenGL version</h4>
<div class="outline-text-4" id="text-org81c90ca">
<p>
OpenGL version history<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">Version</td>
<td class="org-left">Release Date</td>
<td class="org-left">Features</td>
</tr>

<tr>
<td class="org-right">1.1</td>
<td class="org-left">March 4, 1997</td>
<td class="org-left">Texture objects, Vertex Arrays</td>
</tr>

<tr>
<td class="org-right">1.2</td>
<td class="org-left">March 16, 1998</td>
<td class="org-left">3D textures, BGRA and packed pixel formats,[23] introduction of the imaging subset useful to image-processing applications</td>
</tr>

<tr>
<td class="org-right">1.2.1</td>
<td class="org-left">October 14, 1998</td>
<td class="org-left">A concept of ARB extensions</td>
</tr>

<tr>
<td class="org-right">1.3</td>
<td class="org-left">August 14, 2001</td>
<td class="org-left">Multitexturing, multisampling, texture compression</td>
</tr>

<tr>
<td class="org-right">1.4</td>
<td class="org-left">July 24, 2002</td>
<td class="org-left">Depth textures, GLSlang[24]</td>
</tr>

<tr>
<td class="org-right">1.5</td>
<td class="org-left">July 29, 2003</td>
<td class="org-left">Vertex Buffer Object (VBO), Occlusion Queries[25]</td>
</tr>

<tr>
<td class="org-right">2.0</td>
<td class="org-left">September 7, 2004</td>
<td class="org-left">GLSL 1.1, MRT, Non Power of Two textures, Point Sprites,[26] Two-sided stencil[25]</td>
</tr>

<tr>
<td class="org-right">2.1</td>
<td class="org-left">July 2, 2006</td>
<td class="org-left">GLSL 1.2, Pixel Buffer Object (PBO), sRGB Textures[25]</td>
</tr>

<tr>
<td class="org-right">3.0</td>
<td class="org-left">August 11, 2008</td>
<td class="org-left">GLSL 1.3, Texture Arrays, Conditional rendering, Frame Buffer Object (FBO)[27]</td>
</tr>

<tr>
<td class="org-right">3.1</td>
<td class="org-left">March 24, 2009</td>
<td class="org-left">GLSL 1.4, Instancing, Texture Buffer Object, Uniform Buffer Object, Primitive restart[28]</td>
</tr>

<tr>
<td class="org-right">3.2</td>
<td class="org-left">August 3, 2009</td>
<td class="org-left">GLSL 1.5, Geometry Shader, Multi-sampled textures[29]</td>
</tr>

<tr>
<td class="org-right">3.3</td>
<td class="org-left">March 11, 2010</td>
<td class="org-left">GLSL 3.30, Backports as much function as possible from the OpenGL 4.0 specification</td>
</tr>

<tr>
<td class="org-right">4.0</td>
<td class="org-left">March 11, 2010</td>
<td class="org-left">GLSL 4.00, Tessellation on GPU, shaders with 64-bit precision[30]</td>
</tr>

<tr>
<td class="org-right">4.1</td>
<td class="org-left">July 26, 2010</td>
<td class="org-left">GLSL 4.10, Developer-friendly debug outputs, compatibility with OpenGL ES 2.0[31]</td>
</tr>

<tr>
<td class="org-right">4.2</td>
<td class="org-left">August 8, 2011[32]</td>
<td class="org-left">GLSL 4.20, Shaders with atomic counters, draw transform feedback instanced, shader packing, performance improvements</td>
</tr>

<tr>
<td class="org-right">4.3</td>
<td class="org-left">August 6, 2012[33]</td>
<td class="org-left">GLSL 4.30, Compute shaders leveraging GPU parallelism, shader storage buffer objects, high-quality ETC2/EAC texture compression, increased memory security, a multi-application robustness extension, compatibility with OpenGL ES 3.0[34]</td>
</tr>

<tr>
<td class="org-right">4.4</td>
<td class="org-left">July 22, 2013[35]</td>
<td class="org-left">GLSL 4.40, Buffer Placement Control, Efficient Asynchronous Queries, Shader Variable Layout, Efficient Multiple Object Binding, Streamlined Porting of Direct3D applications, Bindless Texture Extension, Sparse Texture Extension[35]</td>
</tr>

<tr>
<td class="org-right">4.5</td>
<td class="org-left">August 11, 2014[8][36]</td>
<td class="org-left">GLSL 4.50, Direct State Access (DSA), Flush Control, Robustness, OpenGL ES 3.1 API and shader compatibility, DX11 emulation features</td>
</tr>

<tr>
<td class="org-right">4.6</td>
<td class="org-left">July 31, 2017[37][38]</td>
<td class="org-left">GLSL 4.60, More efficient geometry processing and shader execution, more information, no error context, polygon offset clamp, SPIR-V, anisotropic filtering</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/OpenGL">https://en.wikipedia.org/wiki/OpenGL</a><br /></li>
<li><a href="https://www.khronos.org/opengl/wiki/History_of_OpenGL">https://www.khronos.org/opengl/wiki/History_of_OpenGL</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2694eb2" class="outline-4">
<h4 id="org2694eb2">Open GLES</h4>
<div class="outline-text-4" id="text-org2694eb2">
<ul class="org-ul">
<li><a href="https://www.khronos.org/opengles/">https://www.khronos.org/opengles/</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a><br /></li>
<li>AEP(ANDROID_extension_pack) <a href="https://www.khronos.org/registry/OpenGL/extensions/ANDROID/ANDROID_extension_pack_es31a.txt">https://www.khronos.org/registry/OpenGL/extensions/ANDROID/ANDROID_extension_pack_es31a.txt</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge9b6a20" class="outline-4">
<h4 id="orge9b6a20">GLSL Version</h4>
<div class="outline-text-4" id="text-orge9b6a20">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">GLSL Version</td>
<td class="org-right">OpenGL Version</td>
<td class="org-left">Date</td>
<td class="org-left">Shader Preprocessor</td>
</tr>

<tr>
<td class="org-left">1.10.59[1]</td>
<td class="org-right">2.0</td>
<td class="org-left">30 April 2004</td>
<td class="org-left">#version 110</td>
</tr>

<tr>
<td class="org-left">1.20.8[2]</td>
<td class="org-right">2.1</td>
<td class="org-left">07 September 2006</td>
<td class="org-left">#version 120</td>
</tr>

<tr>
<td class="org-left">1.30.10[3]</td>
<td class="org-right">3.0</td>
<td class="org-left">22 November 2009</td>
<td class="org-left">#version 130</td>
</tr>

<tr>
<td class="org-left">1.40.08[4]</td>
<td class="org-right">3.1</td>
<td class="org-left">22 November 2009</td>
<td class="org-left">#version 140</td>
</tr>

<tr>
<td class="org-left">1.50.11[5]</td>
<td class="org-right">3.2</td>
<td class="org-left">04 December 2009</td>
<td class="org-left">#version 150</td>
</tr>

<tr>
<td class="org-left">3.30.6[6]</td>
<td class="org-right">3.3</td>
<td class="org-left">11 March 2010</td>
<td class="org-left">#version 330</td>
</tr>

<tr>
<td class="org-left">4.00.9[7]</td>
<td class="org-right">4.0</td>
<td class="org-left">24 July 2010</td>
<td class="org-left">#version 400</td>
</tr>

<tr>
<td class="org-left">4.10.6[8]</td>
<td class="org-right">4.1</td>
<td class="org-left">24 July 2010</td>
<td class="org-left">#version 410</td>
</tr>

<tr>
<td class="org-left">4.20.11[9]</td>
<td class="org-right">4.2</td>
<td class="org-left">12 December 2011</td>
<td class="org-left">#version 420</td>
</tr>

<tr>
<td class="org-left">4.30.8[10]</td>
<td class="org-right">4.3</td>
<td class="org-left">7  February 2013</td>
<td class="org-left">#version 430</td>
</tr>

<tr>
<td class="org-left">4.40.9[11]</td>
<td class="org-right">4.4</td>
<td class="org-left">16 June 2014</td>
<td class="org-left">#version 440</td>
</tr>

<tr>
<td class="org-left">4.50.7[12]</td>
<td class="org-right">4.5</td>
<td class="org-left">09 May 2017</td>
<td class="org-left">#version 450</td>
</tr>

<tr>
<td class="org-left">4.60.5[13]</td>
<td class="org-right">4.6</td>
<td class="org-left">14 June 2018</td>
<td class="org-left">#version 460</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">GLSL ES version</td>
<td class="org-right">OpenGL ES version</td>
<td class="org-right">WebGL version</td>
<td class="org-left">Based on GLSL version</td>
<td class="org-left">Date</td>
<td class="org-left">Shader Preprocessor</td>
</tr>

<tr>
<td class="org-left">1.00.17[14]</td>
<td class="org-right">2.0</td>
<td class="org-right">1.0</td>
<td class="org-left">1.20</td>
<td class="org-left">12 May 2009</td>
<td class="org-left">#version 100</td>
</tr>

<tr>
<td class="org-left">3.00.6[15]</td>
<td class="org-right">3.0</td>
<td class="org-right">2.0</td>
<td class="org-left">3.30</td>
<td class="org-left">29 January 2016</td>
<td class="org-left">#version 300 es</td>
</tr>

<tr>
<td class="org-left">3.10.5[16]</td>
<td class="org-right">3.1</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">GLSL ES 3.00</td>
<td class="org-left">29 January 2016</td>
<td class="org-left">#version 310 es</td>
</tr>

<tr>
<td class="org-left">3.20.6[17]</td>
<td class="org-right">3.2</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">GLSL ES 3.10</td>
<td class="org-left">10 July 2019</td>
<td class="org-left">#version 320 es</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.wikipedia.org/wiki/OpenGL_Shading_Language</a><br /></li>
<li><a href="https://www.khronos.org/opengl/wiki/Detecting_the_Shader_Model">https://www.khronos.org/opengl/wiki/Detecting_the_Shader_Model</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbe3b66a" class="outline-3">
<h3 id="orgbe3b66a">Compare</h3>
<div class="outline-text-3" id="text-orgbe3b66a">
</div>
<div id="outline-container-org631e62b" class="outline-4">
<h4 id="org631e62b">EGL DX11 对比</h4>
<div class="outline-text-4" id="text-org631e62b">
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/windows/uwp/gaming/moving-from-egl-to-dxgi">https://docs.microsoft.com/en-us/windows/uwp/gaming/moving-from-egl-to-dxgi</a><br /></li>
</ul>
</div>
<div id="outline-container-org86ec29f" class="outline-5">
<h5 id="org86ec29f">EGL and DXGI</h5>
<div class="outline-text-5" id="text-org86ec29f">
<p>
DXGI 是 DirectX Graphics Interface 的简称。Direct3D 是 3D 相关的 API。<br />
</p>

<p>
基本的 EGL 对象到 Direct3D 接口的映射：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">EGL abstraction</td>
<td class="org-left">Similar Direct3D representation</td>
</tr>

<tr>
<td class="org-left">EGLDisplay</td>
<td class="org-left">使用 Windows::UI::CoreWindow 来获取 display handle,</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">使用 IDXGIAdapter, IDXGIDevice1 接口来分别配置 adpter 和 显卡</td>
</tr>

<tr>
<td class="org-left">EGLSurface</td>
<td class="org-left">使用 DXGI 的接口来创建和配置 buffers 和其他窗口资源(如：IDXGIFactory2)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">使用 D3D11Device::CreateDevice 来获得 ID3D11Device1，其表示图形设备机器资源.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">使用 ID3D11RenderTargetView 的接口来创建 RenderTargets</td>
</tr>

<tr>
<td class="org-left">EGLContext</td>
<td class="org-left">使用 ID3D11DeviceContext1 的接口来配置和发布命令到图形管线</td>
</tr>

<tr>
<td class="org-left">EGLConfig</td>
<td class="org-left">通过 ID3D11Device1 的接口来配置显卡资源</td>
</tr>
</tbody>
</table>

<p>
EGL 到 Direct3D 11 的 API 映射：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">EGL</td>
<td class="org-left">DX11</td>
</tr>

<tr>
<td class="org-left">eglBindAPI</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">eglBindTexImage</td>
<td class="org-left">ID3D11Device::CreateTexture2D</td>
</tr>

<tr>
<td class="org-left">eglReleaseTexImage</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">eglChooseConfig</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">eglCopyBuffers</td>
<td class="org-left">ID3D11DeviceContext::CopyStructureCount / ID3DDeviceContext::CopyResource</td>
</tr>

<tr>
<td class="org-left">eglCreateContext</td>
<td class="org-left">D3D11CreateDevice 返回 ID3D11DeviceContext1  / ID3D11Device2::CreateDeferredContext</td>
</tr>

<tr>
<td class="org-left">eglCreatePbufferFromClientBuffer</td>
<td class="org-left">ID3D11DeviceContext1:CopyResource.</td>
</tr>

<tr>
<td class="org-left">eglCreatePbufferSurface</td>
<td class="org-left">使用 D3D11CreateDevice 创建不包含 swap chain 的 D3D device. 使用 ID3D11Device::CreateRenderTargetView 创建 D3D render target view</td>
</tr>

<tr>
<td class="org-left">eglCreatePixmapSurface</td>
<td class="org-left">同上</td>
</tr>

<tr>
<td class="org-left">eglCreateWindowSurface</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">eglDestroyContext</td>
<td class="org-left">使用 ID3D11DeviceContext::DiscardView1 来抹除一个 render target view。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">将 Context 实例设置位 null 等待平台回收其资源，无法直接删除 device context</td>
</tr>

<tr>
<td class="org-left">eglDestroySurface</td>
<td class="org-left">N/A. 由平台负责删除</td>
</tr>

<tr>
<td class="org-left">eglGetCurrentDisplay</td>
<td class="org-left">CoreWindow::GetForCurrentThread</td>
</tr>

<tr>
<td class="org-left">eglGetError</td>
<td class="org-left">API return error code / GetLastError</td>
</tr>

<tr>
<td class="org-left">eglInitialize</td>
<td class="org-left">调用 CoreWindow::GetForCurrentThread 来获得当前 main app window 的引用</td>
</tr>

<tr>
<td class="org-left">eglMakeCurrent</td>
<td class="org-left">调用 ID3D11DeviceContext1::OMSetRenderTargets 为当前 contex 设置 render target</td>
</tr>

<tr>
<td class="org-left">eglQueryContext</td>
<td class="org-left">N/A. 使用 ID3D11Device1 实例来获得 rending targets 以及其他配置数据</td>
</tr>

<tr>
<td class="org-left">eglQuerySurface</td>
<td class="org-left">N/A. 使用 ID3D11Device1 实例来获得 viewports 和当前显卡相关的数据</td>
</tr>

<tr>
<td class="org-left">eglSurfaceAttrib</td>
<td class="org-left">使用 D3D11_RENDER_TARGET_VIEW_DESC 来配置 D3D render target view</td>
</tr>

<tr>
<td class="org-left">eglSwapBuffers</td>
<td class="org-left">IDXGISwapChain1::Present1</td>
</tr>

<tr>
<td class="org-left">eglSwapInterval</td>
<td class="org-left">IDXGISwapChain1::Present1 的 SyncInterval 参数</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>EGLSurface 和 OpenGL ES <a href="https://source.android.com/docs/core/graphics/arch-egl-opengl">https://source.android.com/docs/core/graphics/arch-egl-opengl</a><br /></li>
<li>d3d surface <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d9/direct3d-surfaces">https://docs.microsoft.com/en-us/windows/win32/direct3d9/direct3d-surfaces</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org04f1975" class="outline-5">
<h5 id="org04f1975">buffer, uniforms, vertices, texture</h5>
<div class="outline-text-5" id="text-org04f1975">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">EGL</td>
<td class="org-left">DX11</td>
</tr>

<tr>
<td class="org-left">uniform</td>
<td class="org-left">constant buffer</td>
</tr>

<tr>
<td class="org-left">attribute</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">buffer object</td>
<td class="org-left">buffer</td>
</tr>

<tr>
<td class="org-left">frame buffer object</td>
<td class="org-left">render target(s)</td>
</tr>

<tr>
<td class="org-left">back buffer</td>
<td class="org-left">swap chain with "back buffer"</td>
</tr>

<tr>
<td class="org-left">storage buffer</td>
<td class="org-left">structured buffer</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">EGL</td>
<td class="org-left">DX11</td>
</tr>

<tr>
<td class="org-left">glGenBuffer/glBindBuffer/glBufferData</td>
<td class="org-left">CreateBuffer</td>
</tr>

<tr>
<td class="org-left">glGetAttribLocation/glVertexAttribPointer/glEnableVertexAttribArray</td>
<td class="org-left">CreateInputLayout/IASetInputLayout</td>
</tr>

<tr>
<td class="org-left">glActiveTexture() / glBindTexture() / glUniform1i()</td>
<td class="org-left">PSSetShaderResources / PSSetSamplers</td>
</tr>
</tbody>
</table>

<p>
d3d11 和 OpenGL 使用 Texture 比较：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">/////////////////////////</span>
<span style="color: #2aa1ae; background-color: #292e34;">//// </span><span style="color: #2aa1ae; background-color: #292e34;">D3D</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">C++ code</span>
context-&gt;PSSetShaderResources (0, 1, &amp;texture);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">HLSL code</span>
<span style="color: #ce537a; font-weight: bold;">SamplerState</span> <span style="color: #bc6ec5; font-weight: bold;">sampler0</span> : <span style="color: #4f97d7; font-weight: bold;">register</span>(s0);
<span style="color: #ce537a; font-weight: bold;">SamplerState</span> <span style="color: #bc6ec5; font-weight: bold;">sampler1</span> : <span style="color: #4f97d7; font-weight: bold;">register</span>(s1);

<span style="color: #ce537a; font-weight: bold;">Texture2D</span> <span style="color: #bc6ec5; font-weight: bold;">tex0</span> : <span style="color: #4f97d7; font-weight: bold;">register</span>(t0);

tex0.Sample (sampler0, ...);
tex0.Sample (sampler1, ...);

<span style="color: #2aa1ae; background-color: #292e34;">/////////////////////////</span>
<span style="color: #2aa1ae; background-color: #292e34;">//// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">C++ code</span>
<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">tex1_uniform_loc</span> = glGetUniformLocation(prog, <span style="color: #2d9574;">"tex1"</span>);
glUniform1i(tex1_uniform_loc, 0);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, tex1);

<span style="color: #ce537a; font-weight: bold;">GLint</span> <span style="color: #7590db;">tex2_uniform_loc</span> = glGetUniformLocation(prog, <span style="color: #2d9574;">"tex2"</span>);
glUniform1i(tex2_uniform_loc, 1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, tex2);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLSL code</span>
uniform <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">tex1</span>;
uniform <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">tex2</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org90fe6a0" class="outline-5">
<h5 id="org90fe6a0">pipeline</h5>
<div class="outline-text-5" id="text-org90fe6a0">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">EGL</td>
<td class="org-left">DX11</td>
</tr>

<tr>
<td class="org-left">glCreateShader</td>
<td class="org-left">ID3D11Device1::CreateVertexShader / ID3D11Device1::CreatePixelShader</td>
</tr>

<tr>
<td class="org-left">glViewport</td>
<td class="org-left">ID3D11DeviceContext::RSSetViewports</td>
</tr>

<tr>
<td class="org-left">glAttachShader</td>
<td class="org-left">ID3D11Device1::CreateVertexShader / ID3D11Device1::CreatePixelShader</td>
</tr>

<tr>
<td class="org-left">glGetShaderiv, glGetShaderSource</td>
<td class="org-left">ID3D11DeviceContext1::VSGetShader</td>
</tr>

<tr>
<td class="org-left">glGetUniformfv, glGetUniformiv</td>
<td class="org-left">ID3D11DeviceContext1::VSGetConstantBuffers1.</td>
</tr>

<tr>
<td class="org-left">glUseProgram</td>
<td class="org-left">N/A. Direct3D 11 does not use the shader program object abstraction. VSSetShader PSSetShader</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org0569634" class="outline-4">
<h4 id="org0569634">Vulkan DX12 概念对比</h4>
<div class="outline-text-4" id="text-org0569634">
</div>
<div id="outline-container-org618b572" class="outline-5">
<h5 id="org618b572">基本的 API 方面</h5>
<div class="outline-text-5" id="text-org618b572">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">IDXGIFactory4</td>
</tr>

<tr>
<td class="org-left">VkInstance</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">VkPhysicalDevice</td>
<td class="org-left">IDXGIAdapter1</td>
</tr>

<tr>
<td class="org-left">VkDevice</td>
<td class="org-left">ID3D12Device</td>
</tr>

<tr>
<td class="org-left">VkQueue</td>
<td class="org-left">ID3D12CommandQueue</td>
</tr>

<tr>
<td class="org-left">VkSwapchain</td>
<td class="org-left">IDXGISwapChain3</td>
</tr>

<tr>
<td class="org-left">VkFormat</td>
<td class="org-left">DXGI_FORMAT</td>
</tr>

<tr>
<td class="org-left">SPIR-V</td>
<td class="org-left">D3D12_SHADER_BYTECODE</td>
</tr>

<tr>
<td class="org-left">VkFence</td>
<td class="org-left">fences</td>
</tr>

<tr>
<td class="org-left">VkSemaphore</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">VkEvent</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd362649" class="outline-5">
<h5 id="orgd362649">Command Buffer and Pool</h5>
<div class="outline-text-5" id="text-orgd362649">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">VkCommandPool</td>
<td class="org-left">ID3D12CommandAllocator</td>
</tr>

<tr>
<td class="org-left">VkCommandBuffer</td>
<td class="org-left">ID3D12CommandList/ID3D12GraphicsCommandList</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org376138e" class="outline-5">
<h5 id="org376138e">Descriptors</h5>
<div class="outline-text-5" id="text-org376138e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">VkDescriptorPool</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">VkDescriptorSet</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">VkDescriptorSetLayout</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">VkDescriptorSetLayoutBinding</td>
<td class="org-left">RootParameter**</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">ID3D12DescriptorHeap</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd55cec5" class="outline-5">
<h5 id="orgd55cec5">Pipeline</h5>
<div class="outline-text-5" id="text-orgd55cec5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">VkPipelineLayout</td>
<td class="org-left">RootSignature**</td>
</tr>

<tr>
<td class="org-left">VkPipeline</td>
<td class="org-left">ID3D12PipelineState</td>
</tr>

<tr>
<td class="org-left">VkVertexInputAttributeDescription</td>
<td class="org-left">D3D12_INPUT_ELEMENT_DESC</td>
</tr>

<tr>
<td class="org-left">VkVertexInputBindingDescription</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org52d0061" class="outline-5">
<h5 id="org52d0061">Images and Buffers</h5>
<div class="outline-text-5" id="text-org52d0061">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">VkImage</td>
<td class="org-left">ID3D12Resource</td>
</tr>

<tr>
<td class="org-left">VkImageView</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">VkSampler</td>
<td class="org-left">sampler</td>
</tr>

<tr>
<td class="org-left">VkBuffer</td>
<td class="org-left">ID3D12Resource</td>
</tr>

<tr>
<td class="org-left">uniform Buffer</td>
<td class="org-left">constant buffer</td>
</tr>

<tr>
<td class="org-left">index buffer</td>
<td class="org-left">index buffer</td>
</tr>

<tr>
<td class="org-left">vertex buffer</td>
<td class="org-left">vertex buffer</td>
</tr>

<tr>
<td class="org-left">storage buffer</td>
<td class="org-left">structured buffer</td>
</tr>

<tr>
<td class="org-left">barriers/transitions</td>
<td class="org-left">barriers/transitions</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">OpenGL</td>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">glBindBuffer</td>
<td class="org-left">vkCmdBindVertexBuffers</td>
<td class="org-left">IASetVertexBuffers</td>
</tr>

<tr>
<td class="org-left">glBindBuffer</td>
<td class="org-left">vkCmdBindIndexBuffers</td>
<td class="org-left">IASetIndexBuffer</td>
</tr>

<tr>
<td class="org-left">glMapBuffer</td>
<td class="org-left">vkMapMemory</td>
<td class="org-left">Map</td>
</tr>

<tr>
<td class="org-left">glUnmapBuffer</td>
<td class="org-left">vkUnmapMemory</td>
<td class="org-left">Unmap</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">vkCmdCopyBufferToImage</td>
<td class="org-left">CopyTextureRegion</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org9fd1a48" class="outline-5">
<h5 id="org9fd1a48">RenderPasses/RenderTargets</h5>
<div class="outline-text-5" id="text-org9fd1a48">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Vulkan</td>
<td class="org-left">DirectX 12</td>
</tr>

<tr>
<td class="org-left">VkRenderPass</td>
<td class="org-left">render pass</td>
</tr>

<tr>
<td class="org-left">VkFramebuffer</td>
<td class="org-left">collection of ID3D12Resource</td>
</tr>

<tr>
<td class="org-left">subpass</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">render target</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><a href="https://zhuanlan.zhihu.com/p/347268165">https://zhuanlan.zhihu.com/p/347268165</a><br /></li>
<li><a href="https://stackoverflow.com/questions/48439539/how-to-create-and-use-buffer-of-structs">https://stackoverflow.com/questions/48439539/how-to-create-and-use-buffer-of-structs</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge7d7f83" class="outline-4">
<h4 id="orge7d7f83">GLSL vs HLSL</h4>
<div class="outline-text-4" id="text-orge7d7f83">
</div>
<div id="outline-container-org638bf18" class="outline-5">
<h5 id="org638bf18">System values &amp; built-in inputs</h5>
<div class="outline-text-5" id="text-org638bf18">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">SV_ClipDistance</td>
<td class="org-left">gl_ClipDistance</td>
</tr>

<tr>
<td class="org-left">SV_CullDistance</td>
<td class="org-left">gl_CullDistance if ARB_cull_distance is present</td>
</tr>

<tr>
<td class="org-left">SV_Coverage</td>
<td class="org-left">gl_SampleMaskIn &amp; gl_SampleMask</td>
</tr>

<tr>
<td class="org-left">SV_Depth</td>
<td class="org-left">gl_FragDepth</td>
</tr>

<tr>
<td class="org-left">SV_DepthGreaterEqual</td>
<td class="org-left">layout (depth_greater) out float gl_FragDepth;</td>
</tr>

<tr>
<td class="org-left">SV_DepthLessEqual</td>
<td class="org-left">layout (depth_less) out float gl_FragDepth;</td>
</tr>

<tr>
<td class="org-left">SV_DispatchThreadID</td>
<td class="org-left">gl_GlobalInvocationID</td>
</tr>

<tr>
<td class="org-left">SV_DomainLocation</td>
<td class="org-left">gl_TessCord</td>
</tr>

<tr>
<td class="org-left">SV_GroupID</td>
<td class="org-left">gl_WorkGroupID</td>
</tr>

<tr>
<td class="org-left">SV_GroupIndex</td>
<td class="org-left">gl_LocalInvocationIndex</td>
</tr>

<tr>
<td class="org-left">SV_GroupThreadID</td>
<td class="org-left">gl_LocalInvocationID</td>
</tr>

<tr>
<td class="org-left">SV_GSInstanceID</td>
<td class="org-left">gl_InvocationID</td>
</tr>

<tr>
<td class="org-left">SV_InsideTessFactor</td>
<td class="org-left">gl_TessLevelInner</td>
</tr>

<tr>
<td class="org-left">SV_InstanceID</td>
<td class="org-left">gl_InstanceID &amp; gl_InstanceIndex (latter in Vulkan with different semantics)</td>
</tr>

<tr>
<td class="org-left">SV_IsFrontFace</td>
<td class="org-left">gl_FrontFacing</td>
</tr>

<tr>
<td class="org-left">SV_OutputControlPointID</td>
<td class="org-left">gl_InvocationID</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">gl_PatchVerticesIn</td>
</tr>

<tr>
<td class="org-left">SV_Position</td>
<td class="org-left">gl_Position in a vertex shader, gl_FragCoord in a fragment shader</td>
</tr>

<tr>
<td class="org-left">SV_PrimitiveID</td>
<td class="org-left">gl_PrimitiveID</td>
</tr>

<tr>
<td class="org-left">SV_RenderTargetArrayIndex</td>
<td class="org-left">gl_Layer</td>
</tr>

<tr>
<td class="org-left">SV_SampleIndex</td>
<td class="org-left">gl_SampleID</td>
</tr>

<tr>
<td class="org-left">EvaluateAttributeAtSample</td>
<td class="org-left">gl_SamplePosition</td>
</tr>

<tr>
<td class="org-left">SV_StencilRef</td>
<td class="org-left">gl_FragStencilRef if ARB_shader_stencil_export is present</td>
</tr>

<tr>
<td class="org-left">SV_Target</td>
<td class="org-left">layout(location=N) out your_var_name;</td>
</tr>

<tr>
<td class="org-left">SV_TessFactor</td>
<td class="org-left">gl_TessLevelOuter</td>
</tr>

<tr>
<td class="org-left">SV_VertexID</td>
<td class="org-left">gl_VertexID &amp; gl_VertexIndex (latter Vulkan with different semantics)</td>
</tr>

<tr>
<td class="org-left">SV_ViewportArrayIndex</td>
<td class="org-left">gl_ViewportIndex</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org3689661" class="outline-5">
<h5 id="org3689661">Atomic operations</h5>
<div class="outline-text-5" id="text-org3689661">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">Interlocked</td>
<td class="org-left">atomic</td>
</tr>

<tr>
<td class="org-left">InterlockedAdd</td>
<td class="org-left">atomicAdd</td>
</tr>

<tr>
<td class="org-left">InterlockedCompareExchange</td>
<td class="org-left">atomicCompSwap</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4cbca7b" class="outline-5">
<h5 id="org4cbca7b">Shared/local memory</h5>
<div class="outline-text-5" id="text-org4cbca7b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">groupshared</td>
<td class="org-left">shared</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orga50ceaa" class="outline-5">
<h5 id="orga50ceaa">Barriers</h5>
<div class="outline-text-5" id="text-orga50ceaa">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">GroupMemoryBarrierWithGroupSync</td>
<td class="org-left">groupMemoryBarrier and barrier</td>
</tr>

<tr>
<td class="org-left">GroupMemoryBarrier</td>
<td class="org-left">groupMemoryBarrier</td>
</tr>

<tr>
<td class="org-left">DeviceMemoryBarrierWithGroupSync</td>
<td class="org-left">memoryBarrier, memoryBarrierImage, memoryBarrierImage and barrier</td>
</tr>

<tr>
<td class="org-left">DeviceMemoryBarrier</td>
<td class="org-left">memoryBarrier, memoryBarrierImage, memoryBarrierImage</td>
</tr>

<tr>
<td class="org-left">AllMemoryBarrierWithGroupSync</td>
<td class="org-left">All of the barriers above and barrier</td>
</tr>

<tr>
<td class="org-left">AllMemoryBarrier</td>
<td class="org-left">All of the barriers above</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">memoryBarrierShared</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8f61a01" class="outline-5">
<h5 id="org8f61a01">Texture access</h5>
<div class="outline-text-5" id="text-org8f61a01">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">CalculateLevelOfDetail &amp; CalculateLevelOfDetailUnclamped</td>
<td class="org-left">textureQueryLod</td>
</tr>

<tr>
<td class="org-left">Load</td>
<td class="org-left">texelFetch and texelFetchOffset</td>
</tr>

<tr>
<td class="org-left">GetDimensions</td>
<td class="org-left">textureSize, textureQueryLevels and textureSamples</td>
</tr>

<tr>
<td class="org-left">Gather</td>
<td class="org-left">textureGather, textureGatherOffset, textureGatherOffsets</td>
</tr>

<tr>
<td class="org-left">Sample, SampleBias</td>
<td class="org-left">texture, textureOffset</td>
</tr>

<tr>
<td class="org-left">SampleCmp</td>
<td class="org-left">samplerShadow</td>
</tr>

<tr>
<td class="org-left">SampleGrad</td>
<td class="org-left">textureGrad, textureGradOffset</td>
</tr>

<tr>
<td class="org-left">SampleLevel</td>
<td class="org-left">textureLod, textureLodOffset</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">textureProj</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org9dd1fdd" class="outline-5">
<h5 id="org9dd1fdd">General math</h5>
<div class="outline-text-5" id="text-org9dd1fdd">
<p>
GLSL 矩阵为列主序， 矩阵和向量相乘为 M*v<br />
HLSL 矩阵为行主序， 矩阵和向量相乘为 v*M<br />
</p>
</div>
</div>
<div id="outline-container-orgf0a8fae" class="outline-5">
<h5 id="orgf0a8fae">Various functions</h5>
<div class="outline-text-5" id="text-orgf0a8fae">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">HLSL</td>
<td class="org-left">GLSL</td>
</tr>

<tr>
<td class="org-left">atan2(y,x)</td>
<td class="org-left">atan</td>
</tr>

<tr>
<td class="org-left">ddx</td>
<td class="org-left">dFdx</td>
</tr>

<tr>
<td class="org-left">ddx_coarse</td>
<td class="org-left">dFdxCoarse</td>
</tr>

<tr>
<td class="org-left">ddx_fine</td>
<td class="org-left">dFdxFine</td>
</tr>

<tr>
<td class="org-left">ddy</td>
<td class="org-left">dFdy</td>
</tr>

<tr>
<td class="org-left">ddy_coarse</td>
<td class="org-left">dFdyCoarse</td>
</tr>

<tr>
<td class="org-left">ddy_fine</td>
<td class="org-left">dFdyFine</td>
</tr>

<tr>
<td class="org-left">EvaluateAttributeAtCentroid</td>
<td class="org-left">interpolateAtCentroid</td>
</tr>

<tr>
<td class="org-left">EvaluateAttributeAtSample</td>
<td class="org-left">interpolateAtSample</td>
</tr>

<tr>
<td class="org-left">EvaluateAttributeSnapped</td>
<td class="org-left">interpolateAtOffset</td>
</tr>

<tr>
<td class="org-left">frac</td>
<td class="org-left">fract</td>
</tr>

<tr>
<td class="org-left">lerp</td>
<td class="org-left">mix</td>
</tr>

<tr>
<td class="org-left">mad</td>
<td class="org-left">fma</td>
</tr>

<tr>
<td class="org-left">saturate</td>
<td class="org-left">clamp(x, 0.0, 1.0)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org01749f8" class="outline-5">
<h5 id="org01749f8">参考资料</h5>
<div class="outline-text-5" id="text-org01749f8">
<ul class="org-ul">
<li><a href="https://anteru.net/blog/2016/mapping-between-HLSL-and-GLSL/">https://anteru.net/blog/2016/mapping-between-HLSL-and-GLSL/</a> <br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb7af179" class="outline-4">
<h4 id="orgb7af179">参考资料</h4>
<div class="outline-text-4" id="text-orgb7af179">
<ul class="org-ul">
<li>ShaderModel 与 ES 版本和 GPU 特性的关系 (有道云有备份) <a href="https://liangz0707.github.io/whoimi/blogs/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB.html">https://liangz0707.github.io/whoimi/blogs/Shader/ShaderModel%E4%B8%8EES%E7%89%88%E6%9C%AC%E5%92%8CGPU%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB.html</a><br /></li>
<li>DirectX / OpenGL(Vulkan) concepts mapping chart <a href="https://computergraphics.stackexchange.com/questions/4422/directx-openglvulkan-concepts-mapping-chart">https://computergraphics.stackexchange.com/questions/4422/directx-openglvulkan-concepts-mapping-chart</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'Vulkan',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>
