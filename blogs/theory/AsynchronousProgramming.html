<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-14 周一 17:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AsynchronousProgramming</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">AsynchronousProgramming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9cc2c3b">C++ Concurrency In Action</a>
<ul>
<li><a href="#orgc5f1a8f">01 hello world of concurrency in c++</a>
<ul>
<li><a href="#org2f487e3">What is Concurrency?</a>
<ul>
<li><a href="#org1eaf900">将应用程序设计为多进程来实现并发</a></li>
<li><a href="#orga957e3d">将应用程序设计为多线程来实现并发</a></li>
<li><a href="#orgcafd037">并发(concurrency) VS 并行(parallelism)</a></li>
</ul>
</li>
<li><a href="#orge8b1076">Why use Concurrency?</a>
<ul>
<li><a href="#orgbb3c779">使用 concurrency 来分离关注点 使用 concurrency 来提高性能</a></li>
<li><a href="#orgb3484b8">什么时候不要使用 concurrency?</a></li>
</ul>
</li>
<li><a href="#org5733a31">Concurrency and multithreading in C++</a>
<ul>
<li><a href="#org70bdc46">History of multithreading in C++</a></li>
<li><a href="#org4f57a54">Concurrency support in the C++11 standard</a></li>
<li><a href="#org595474f">Efficiency in the C++ Thread Library</a></li>
<li><a href="#orgcf64184">Platform-specific facilities</a></li>
</ul>
</li>
<li><a href="#org797acd7">Getting started</a></li>
</ul>
</li>
<li><a href="#orgaa86eef">02 managing threads</a>
<ul>
<li><a href="#org404434d">Basic thread management</a>
<ul>
<li><a href="#org23ed669">创建进程</a></li>
<li><a href="#org8f43cbd">等待进程结束</a>
<ul>
<li><a href="#org9fde78d">case1</a></li>
<li><a href="#org1444a5c">case2</a></li>
<li><a href="#orgebdbd62">case3</a></li>
<li><a href="#orgcfca390">case4</a></li>
<li><a href="#org943a09b">case5</a></li>
<li><a href="#org0ca907c">利用 RAII 来等待线程结束</a></li>
<li><a href="#org2377857">利用 detach 来使线程在后台运行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org485fabf">Passing arguments to a thread function</a>
<ul>
<li><a href="#orgffd51b9">通过传递对象指针，就可以使用成员函数作为线程入口函数</a></li>
<li><a href="#org7810686">传递只能 move 而不能 copy 的参数</a></li>
</ul>
</li>
<li><a href="#orgaf43aae">Transferring ownership of a thread</a>
<ul>
<li><a href="#org08c4ad6">scoped_thread</a></li>
<li><a href="#orgced868b">joining_thread</a></li>
<li><a href="#org5c6d6d6">thread and container</a></li>
</ul>
</li>
<li><a href="#org86cb5eb">Choosing the number of threads at runtime</a></li>
<li><a href="#org307cb0f">Identifying threads</a></li>
</ul>
</li>
<li><a href="#orgab44313">03 sharing data between threads</a>
<ul>
<li><a href="#org00cd723">Problems with sharing data between threads</a>
<ul>
<li><a href="#orgc6c8ab4">Race conditions</a></li>
<li><a href="#org455efcb">Avoiding problematic race conditions</a></li>
</ul>
</li>
<li><a href="#org7eed7a0">Protecting data with mutexes</a>
<ul>
<li><a href="#orgfdfef4b">Using mutexes in C++</a>
<ul>
<li><a href="#orgaf803b0">mutex</a></li>
<li><a href="#org9262ca0">lock_guard</a></li>
</ul>
</li>
<li><a href="#org8dbfb7c">Structuring code for protecting shared data</a></li>
<li><a href="#orgcb58817">Spotting race conditions inherent in interfaces</a>
<ul>
<li><a href="#orgf0f29e5">方法 1: Pass in a reference</a></li>
<li><a href="#org92d9156">方法 2: REQUIRE A NO-THROW COPY CONSTRUCTOR OR MOVE CONSTRUCTOR</a></li>
<li><a href="#org3ccb3b5">方法 3: RETURN A POINTER TO THE POPPED ITEM</a></li>
<li><a href="#orgeacecbc">方法 4: PROVIDE BOTH OPTION 1 AND EITHER OPTION 2 OR 3</a></li>
</ul>
</li>
<li><a href="#orgfd6d73f">Deadlock: the problem and a solution</a></li>
<li><a href="#org3e6f079">Further guidelines for avoiding deadlock</a>
<ul>
<li><a href="#org1266483">AVOID NESTED LOCKS</a></li>
<li><a href="#orgb3905ff">AVOID CALLING USER-SUPPLIED CODE WHILE HOLDING A LOCK</a></li>
<li><a href="#org69db1c8">ACQUIRE LOCKS IN A FIXED ORDER</a></li>
<li><a href="#org8dc79d7">USE A LOCK HIERARCHY</a></li>
<li><a href="#org63032e2">EXTENDING THESE GUIDELINES BEYOND LOCKS</a></li>
</ul>
</li>
<li><a href="#orgb699b38">Flexible locking with std::unique_lock</a></li>
<li><a href="#orga6c870d">Transferring mutex ownership between scopes</a></li>
<li><a href="#org3f336f6">Locking at an appropriate granularity</a></li>
</ul>
</li>
<li><a href="#org655820e">Alternative facilities for protecting shared data</a>
<ul>
<li><a href="#org19ba5b7">Protecting shared data during initialization</a>
<ul>
<li><a href="#org3a95b43">最简单的方式，但性能低下</a></li>
<li><a href="#org33a464a">double-checked locking 方式，尝试优化性能，但引入了 data race</a></li>
<li><a href="#org1e82069">std::call_once std::once_flag 方案</a></li>
<li><a href="#org111a314">static 方案</a></li>
</ul>
</li>
<li><a href="#orgae5765d">Protecting rarely updated data structures</a></li>
<li><a href="#orgdc2e24a">Recursive locking</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga726318">04 synchronizing concurrent operations on atomic types</a>
<ul>
<li><a href="#org58ab91b">Waiting for an event or other condition</a>
<ul>
<li><a href="#org3cc4ad0">Waiting for a condition with condition variables</a></li>
<li><a href="#orgf1d470a">Building a thread-safe queue with condition variables</a></li>
</ul>
</li>
<li><a href="#orgd5650f1">Waiting for one-off events with futures</a>
<ul>
<li><a href="#orgb7f02fb">Returning values from background tasks</a></li>
<li><a href="#org39aaff9">Associating a task with a future</a>
<ul>
<li><a href="#org5f9c2ce">Passing Task between thread</a></li>
</ul>
</li>
<li><a href="#orgdaa7557">Making (std::)promises</a></li>
<li><a href="#org5423a38">Saving an exception for the future</a></li>
<li><a href="#org61202e0">Waiting from multiple threads</a></li>
</ul>
</li>
<li><a href="#org2bd913c">Waiting with a time limit</a>
<ul>
<li><a href="#orgf9923d6">Clocks</a></li>
<li><a href="#org9f1abbf">Durations</a></li>
<li><a href="#org95fea1a">Time points</a></li>
<li><a href="#org4f7fd62">Functions that accept timeouts</a></li>
</ul>
</li>
<li><a href="#org0295227">Using synchronization of operations to simplify code</a>
<ul>
<li><a href="#org568b4c9">Functional programming with futures</a></li>
<li><a href="#org5b6f939">Synchronizing operations with message passing</a></li>
<li><a href="#org440c9d9">Continuation-style concurrency with the Concurrency TS</a></li>
<li><a href="#org4f1728d">Chaining continuations</a>
<ul>
<li><a href="#orge50252e">std::experimental::future continuation</a></li>
<li><a href="#org4dd8d91">std::experimental::shared_future continuation</a></li>
</ul>
</li>
<li><a href="#org30dfc43">Waiting for more than one future</a></li>
<li><a href="#orga543336">Waiting for the first future in a set with when_any</a></li>
<li><a href="#org244632c">Latches and barriers in the Concurrency TS</a>
<ul>
<li><a href="#orge8a2994">A basic latch type: std::experimental::latch</a></li>
<li><a href="#org5dd7fb8">std::experimental::barrier: a basic barrier</a></li>
<li><a href="#orgd201d81">std::experimental::flex_barrier—std::experimental::barrier’s flexible friend</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org94ed662">05 The C++ memory model and operations on atomic types</a>
<ul>
<li><a href="#org758cb27">Memory model basics</a>
<ul>
<li><a href="#orga126221">Objects and memory locations</a></li>
<li><a href="#org59c9b1d">Objects, memory locations, and concurrency</a></li>
<li><a href="#orgf01cac6">Modification orders</a></li>
</ul>
</li>
<li><a href="#orge60e390">Atomic operations and types in C++</a>
<ul>
<li><a href="#orge357067">The standard atomic types</a></li>
<li><a href="#orgfa93f98">Operations on std::atomic_flag</a></li>
<li><a href="#org27fa669">Operations on std::atomic&lt;bool&gt;</a>
<ul>
<li><a href="#orgf513b3e">compare-exchange</a></li>
</ul>
</li>
<li><a href="#orgd5de9aa">Operations on std::atomic&lt;T*&gt;: pointer arithmetic</a></li>
<li><a href="#org9d97a85">Operations on standard atomic integral types</a></li>
<li><a href="#orgd52d633">The std::atomic&lt;&gt; primary class template</a></li>
<li><a href="#org384c3f0">Free functions for atomic operations</a></li>
</ul>
</li>
<li><a href="#orgd950162">Synchronizing operations and enforcing ordering</a>
<ul>
<li><a href="#org8e7f279">The synchronizes-with relationship</a></li>
<li><a href="#org5116ff6">The happens-before relationship</a></li>
<li><a href="#orgc30384c">Memory ordering for atomic operations</a>
<ul>
<li><a href="#orgd054bdc">sequentially consistent ordering</a></li>
<li><a href="#org933fa29">Non-Sequentially consistent Memory orderings</a></li>
</ul>
</li>
<li><a href="#org00a8a77">Release sequences and synchronizes-with</a></li>
<li><a href="#org1fca3a4">Fences</a></li>
<li><a href="#org2077aab">Ordering non-atomic operations with atomics</a></li>
<li><a href="#orgc2f511d">Ordering non-atomic operations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2547bae">06 designing lock-based concurrent data structures</a>
<ul>
<li><a href="#orgc49fa6f">What does it mean to design for concurrency? (197)</a>
<ul>
<li><a href="#orgc76a0ea">Guidelines for designing data structures for concurrency (198)</a></li>
</ul>
</li>
<li><a href="#org8572d74">Lock-based concurrent data structures (199)</a>
<ul>
<li><a href="#org1319d1a">A thread-safe stack using locks (199)</a></li>
<li><a href="#org48b1a8d">A thread-safe queue using locks and condition variables (202)</a></li>
<li><a href="#org12893ab">A thread-safe queue using fine-grained locks and condition variables (206)</a>
<ul>
<li><a href="#org742556e">ENABLING CONCURRENCY BY SEPARATING DATA</a></li>
<li><a href="#org402b242">Waiting FOR AN ITEM TO POP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org38f4d3a">Designing more complex lock-based data structures (217)</a>
<ul>
<li><a href="#orga2ef6d3">Writing a thread-safe lookup table using locks (217)</a>
<ul>
<li><a href="#org2fb96cc">DESIGNING A MAP DATA STRUCTURE FOR FINE-GRAINED LOCKING</a></li>
</ul>
</li>
<li><a href="#orge0e7e86">Writing a thread-safe list using locks (222)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org70f7045">07 designing lock-free concurrent data structures</a>
<ul>
<li><a href="#org2cbc9d4">7.1 Definitions and consequences (229)</a>
<ul>
<li><a href="#orgebbc23c">Types of nonblocking data structures (229)</a></li>
<li><a href="#orge1c69be">Lock-free data structures (230)</a></li>
<li><a href="#orgcb4e336">Wait-free data structures (231)</a></li>
<li><a href="#orga4acc34">The pros and cons of lock-free data structures (231)</a></li>
</ul>
</li>
<li><a href="#orgb8b39c8">7.2 Examples of lock-free data structures (232)</a>
<ul>
<li><a href="#orgf134d02">Writing a thread-safe stack without locks (233)</a></li>
<li><a href="#orgaa8eefd">Stopping those pesky leaks: managing memory in lock-free data structures (237)</a></li>
<li><a href="#org86f8062">Detecting nodes that can’t be reclaimed using hazard pointers (241)</a>
<ul>
<li><a href="#org8d86e5a">BETTER RECLAMATION STRATEGIES USING HAZARD POINTERS</a></li>
</ul>
</li>
<li><a href="#org97337cb">Detecting nodes in use with reference counting (249)</a></li>
<li><a href="#org3441d37">Applying the memory model to the lock-free stack (255)</a></li>
<li><a href="#org73d012e">Writing a thread-safe queue without locks (259)</a>
<ul>
<li><a href="#org0e52a59">HANDLING MULTIPLE THREADS IN PUSH()</a></li>
<li><a href="#org465d63c">MAKING THE QUEUE LOCK-FREE BY HELPING OUT ANOTHER THREAD</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7eca738">7.3 Guidelines for writing lock-free data structures (271)</a>
<ul>
<li><a href="#orgae83897">Guideline: use std::memory_order_seq_cst for prototyping (271)</a></li>
<li><a href="#org89d1059">Guideline: use a lock-free memory reclamation scheme (271)</a></li>
<li><a href="#org1051cb1">Guideline: watch out for the ABA problem (272)</a></li>
<li><a href="#org68944c8">Guideline: identify busy-wait loops and help the other thread (272)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7e4bb73">08 designing concurrent code</a>
<ul>
<li><a href="#org12addf9">本章主要内容</a></li>
<li><a href="#org4adcd4e">8.1 Techniques for dividing work between threads (275)</a>
<ul>
<li><a href="#orge931b30">8.1.1 Dividing data between threads before processing begins (276)</a></li>
<li><a href="#org87862dc">8.1.2 Dividing data recursively (277)</a></li>
<li><a href="#org6b48fd0">8.1.3 Dividing work by task type (281)</a>
<ul>
<li><a href="#org353c95f">DIVIDING WORK BY TASK TYPE TO SEPARATE CONCERNS</a></li>
<li><a href="#org3f5041a">DIVIDING A SEQUENCE OF TASKS BETWEEN THREADS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8030472">8.2 Factors affecting the performance of concurrent code (283)</a>
<ul>
<li><a href="#org14c7e1c">8.2.1 How many processors? (284)</a></li>
<li><a href="#org9e08aad">8.2.2 Data contention and cache ping-pong (285)</a></li>
<li><a href="#org1c855a8">8.2.3 False sharing (287)</a></li>
<li><a href="#orgc4a53df">8.2.4 How close is your data? (288)</a></li>
<li><a href="#org7f401b7">8.2.5 Oversubscription and excessive task switching (289)</a></li>
</ul>
</li>
<li><a href="#orgac7e2cc">8.3 Designing data structures for multithreaded performance (289)</a>
<ul>
<li><a href="#org7caa2fd">8.3.1 Dividing array elements for complex operations (290)</a></li>
<li><a href="#org8bda13d">8.3.2 Data access patterns in other data structures (292)</a></li>
</ul>
</li>
<li><a href="#org66d58dc">8.4 Additional considerations when designing for concurrency (293)</a>
<ul>
<li><a href="#org4b7e287">8.4.1 Exception safety in parallel algorithms (294)</a>
<ul>
<li><a href="#org242bc53">ADDING EXCEPTION SAFETY</a></li>
<li><a href="#org2fbdd24">EXCEPTION SAFETY WITH STD::ASYNC()</a></li>
</ul>
</li>
<li><a href="#org6734afd">8.4.2 Scalability and Amdahl’s law (300)</a></li>
<li><a href="#orgaedaaa3">8.4.3 Hiding latency with multiple threads (302)</a></li>
<li><a href="#org724dccc">8.4.4 Improving responsiveness with concurrency (303)</a></li>
</ul>
</li>
<li><a href="#org12274dd">8.5 Designing concurrent code in practice (305)</a>
<ul>
<li><a href="#org7d3633d">8.5.1 A parallel implementation of std::for_each (305)</a></li>
<li><a href="#orgdcb693a">8.5.2 A parallel implementation of std::find (307)</a></li>
<li><a href="#orgebe1cd0">8.5.3 A parallel implementation of std::partial_sum (313)</a>
<ul>
<li><a href="#orgc5fde41">IMPLEMENTING THE INCREMENTAL PAIRWISE ALGORITHM FOR PARTIAL SUMS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org55328f8">09 advanced thread management</a>
<ul>
<li><a href="#org9f53db3">本章主要内容</a></li>
<li><a href="#org5abe77b">9.1 Thread pools (324)</a>
<ul>
<li><a href="#org2d32a58">The simplest possible thread pool (324)</a></li>
<li><a href="#org52bb67b">Waiting for tasks submitted to a thread pool (326)</a></li>
<li><a href="#org9802089">Tasks that wait for other tasks (330)</a></li>
<li><a href="#orgbf13beb">Avoiding contention on the work queue (333)</a></li>
<li><a href="#org99cae67">Work stealing (334)</a></li>
</ul>
</li>
<li><a href="#orgc2318ab">9.2 Interrupting threads (338)</a>
<ul>
<li><a href="#org42ea2b7">Launching and interrupting another thread (339)</a></li>
<li><a href="#orga18d27c">Detecting that a thread has been interrupted (341)</a></li>
<li><a href="#orgf42b814">Interrupting a condition variable wait (341)</a></li>
<li><a href="#org0946a7c">Interrupting a wait on std::condition_variable_any (344)</a></li>
<li><a href="#org35b0790">Interrupting other blocking calls (346)</a></li>
<li><a href="#org0bf9d45">Handling interruptions (347)</a></li>
<li><a href="#org4e87774">Interrupting background tasks on application exit (348)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga4622fb">10 parallel algorithms</a>
<ul>
<li><a href="#orgc51360d">本章主要内容</a></li>
<li><a href="#org940e0e4">10.1 Parallelizing the standard library algorithms (350)</a></li>
<li><a href="#org89ff22a">10.2 Execution policies (351)</a>
<ul>
<li><a href="#org972bcdc">General effects of specifying an execution policy (351)</a>
<ul>
<li><a href="#org3921c18">算法复杂度影响</a></li>
<li><a href="#org99aa54f">异常行为</a></li>
<li><a href="#org38b1d4c">算法步骤执行的位置和时间</a></li>
</ul>
</li>
<li><a href="#org3e037dc">std::execution::sequenced_policy (353)</a></li>
<li><a href="#org794a0e5">std::execution::parallel_policy (353)</a></li>
<li><a href="#orgac310fe">std::execution::parallel_unsequenced_policy (354)</a></li>
</ul>
</li>
<li><a href="#org2e1a2d7">10.3 The parallel algorithms from the C++ Standard Library (354)</a>
<ul>
<li><a href="#org757ea3d">Examples of using parallel algorithms (357)</a>
<ul>
<li><a href="#orgdc0dcdd">CHOICE OF EXECUTION POLICY</a></li>
</ul>
</li>
<li><a href="#orge0f2773">Counting visits (359)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge48266f">11 testing and debugging multithreaded applications</a>
<ul>
<li><a href="#org9dc6b37">本章主要内容</a></li>
<li><a href="#org86cdada">11.1 Types of concurrency-related bugs (363)</a>
<ul>
<li><a href="#org6bc5669">Unwanted blocking (363)</a></li>
<li><a href="#org7197a88">Race conditions (364)</a></li>
</ul>
</li>
<li><a href="#org17fc0e3">11.2 Techniques for locating concurrency-related bugs (365)</a>
<ul>
<li><a href="#orgf246d73">Reviewing code to locate potential bugs (365)</a>
<ul>
<li><a href="#orgbf548b6">QUESTIONS TO THINK ABOUT WHEN REVIEWING MULTITHREADED CODE</a></li>
</ul>
</li>
<li><a href="#orgcbe42ff">Locating concurrency-related bugs by testing (367)</a></li>
<li><a href="#org2bf0dc9">Designing for testability (369)</a></li>
<li><a href="#org2f41a46">Multithreaded testing techniques (370)</a>
<ul>
<li><a href="#org5ffb814">BRUTE-FORCE TESTING</a></li>
<li><a href="#orgac823a5">COMBINATION SIMULATION TESTING</a></li>
<li><a href="#org5b84a69">DETECTING PROBLEMS EXPOSED BY TESTS WITH A SPECIAL LIBRARY</a></li>
</ul>
</li>
<li><a href="#org79b1cb1">Structuring multithreaded test code (373)</a></li>
<li><a href="#org4288bfb">Testing the performance of multithreaded code (375)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3bc08f6">c++ 多线程编程</a>
<ul>
<li><a href="#orgb49f7d3">实例分析</a>
<ul>
<li><a href="#org37146c6">cocos2dx CCTextureCache 多线程使用</a></li>
<li><a href="#org0b3124d">semaphore 信号量的实现</a></li>
<li><a href="#org4ced0a6">多线程下载文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5a59cdc">参考资料</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9cc2c3b" class="outline-2">
<h2 id="org9cc2c3b">C++ Concurrency In Action</h2>
<div class="outline-text-2" id="text-org9cc2c3b">
</div>
<div id="outline-container-orgc5f1a8f" class="outline-3">
<h3 id="orgc5f1a8f">01 hello world of concurrency in c++</h3>
<div class="outline-text-3" id="text-orgc5f1a8f">
</div>
<div id="outline-container-org2f487e3" class="outline-4">
<h4 id="org2f487e3">What is Concurrency?</h4>
<div class="outline-text-4" id="text-org2f487e3">
</div>
<div id="outline-container-org1eaf900" class="outline-5">
<h5 id="org1eaf900">将应用程序设计为多进程来实现并发</h5>
<div class="outline-text-5" id="text-org1eaf900">
<p>
通信方式：进程之间通过常见的内部进程间通信（例如 信号、socket、files、pipes 等等）来互相交流信息<br />
缺点：<br />
</p>
<ul class="org-ul">
<li>进程之间的通信比较复杂或者比较慢，或者又复杂又慢，因为操作系统通常提供了很多保护为了避免一个进程意外修改另一个进程的数据。<br /></li>
<li>运行多个进程有天然的消耗，操作系统必须拿一部分内部资源用于管理进程。<br /></li>
</ul>
<p>
优点：<br />
</p>
<ul class="org-ul">
<li>操作系统为进程间提供的保护和高阶通信机制，有利于编写安全的同步代码。Erlang 编程语言就是基于进程实现并行的。<br /></li>
<li>使用分开的进程来实现并发时，可以将分开的进程在不同的机器上运行，这些机器通过网络链接在一起。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga957e3d" class="outline-5">
<h5 id="orga957e3d">将应用程序设计为多线程来实现并发</h5>
<div class="outline-text-5" id="text-orga957e3d">
<p>
通信方式：一个进程内的所有线程共享相同的地址空间，大多数数据可以被多线程直接访问（全局变量依然是全局的，对象或数据的指针或引用可以在线程之间进行传递）<br />
缺点：<br />
</p>
<ul class="org-ul">
<li>当数据被多个线程访问时，应用程序开发者需要确保每个线程在任意时刻访问该数据时看到的值是一致的。<br /></li>
<li>多线程共享数据可能会引起很多问题，为了避免这些问题，要使用一些工具，还要遵守一些指导原则。<br /></li>
</ul>
<p>
优点：<br />
</p>
<ul class="org-ul">
<li>共享地址空间加上线程之间没有数据保护，使得多线程比多进程的开销要小很多，操作系统不需要过多的记录。<br /></li>
<li>C++标准没有为多进程的通信提供任何内置支持，使用多进程需要开发人员依赖平台相关的特定 API。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcafd037" class="outline-5">
<h5 id="orgcafd037">并发(concurrency) VS 并行(parallelism)</h5>
<div class="outline-text-5" id="text-orgcafd037">
<p>
这两个术语都是指，利用可用的硬件同时执行多个任务。但是并行更多是面向性能的，当人们谈到并行时，他们主要关心的是利用可用硬件的优势来提升大量数据处理的性能。当人们谈到并发时，他们主要关心的是任务的分割(关注点分离 Separation of concerns)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge8b1076" class="outline-4">
<h4 id="orge8b1076">Why use Concurrency?</h4>
<div class="outline-text-4" id="text-orge8b1076">
<p>
使用 concurrency 主要有两个原因：分离关注点（Separation of concerns）和性能。<br />
</p>
</div>
<div id="outline-container-orgbb3c779" class="outline-5">
<h5 id="orgbb3c779">使用 concurrency 来分离关注点 使用 concurrency 来提高性能</h5>
<div class="outline-text-5" id="text-orgbb3c779">
<p>
可以利用 concurrency 通过两种方式来提高性能：<br />
第一种方式：将一个整体划分为多个部分。听上去很简单，但是划分可能很复杂，因为各个部分可能会有依赖。划分既可以是对处理流程的划分（任务并行），也可以是对数据的划分（数据并行）。<br />
</p>

<p>
第二种方式：利用可行的并行解决更大的问题。一次处理不止一个文件，而是处理两个或 10 个或 20 个。尽管这是数据并行的一种应用，但是侧重不同。其使用相同的时间处理一大批数据。<br />
</p>
</div>
</div>
<div id="outline-container-orgb3484b8" class="outline-5">
<h5 id="orgb3484b8">什么时候不要使用 concurrency?</h5>
<div class="outline-text-5" id="text-orgb3484b8">
<p>
当使用 concurrency 得到的收益比不上付出的代价，就不应该使用 concurrency。<br />
</p>

<p>
启动一个线程有天生的开销。OS 需要申请对应的内核资源，栈空间，还需要将线程加到 scheduler，这些都需要消耗时间。如果线程上的任务很快就结束了，可能任务消耗的时间还没启动线程消耗的时间多，这可能使得性能更差。<br />
</p>

<p>
线程是有限的资源。如果你同时运行很多线程，这消耗了 OS 资源，可能使系统整体会变慢。不仅如此，使用太多线程可以耗尽一个进程的可用内存或地址空间，因为每个线程都需要一个独立的栈空间。对于 平坦架构的 32 位进程，地址空间的大小限制为 4GB，如果每个线程的栈占用 1MB，则最多可以有 4096 个线程。尽管可以使用线程池来限制线程的数量，但是并不能解决所有的问题，线程池有其自身的问题。<br />
</p>

<p>
在 client/server 应用程序中，为每个连接启动一个线程，这对于少量连接来说是可行的，对于需要处理很多连接的高需求服务，这会很快耗尽系统的资源。这种情况下，可以使用线程池来优化性能。<br />
</p>

<p>
线程越多，操作系统要做的上下文切换就越多。添加额外的线程将会减低应用程序整体的性能。因此，为了达到系统最佳性能，需要依据硬件的并行能力来调整线程数量。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5733a31" class="outline-4">
<h4 id="org5733a31">Concurrency and multithreading in C++</h4>
<div class="outline-text-4" id="text-org5733a31">
</div>
<div id="outline-container-org70bdc46" class="outline-5">
<h5 id="org70bdc46">History of multithreading in C++</h5>
<div class="outline-text-5" id="text-org70bdc46">
<p>
1998 C++ 标准没有包含多线程，当时内存模型也没有正式定义，没有编译器扩展是无法编写多线程应用的。<br />
很多编译器提供商利用当时很流行的平台相关的 C 多线程 API(POSIX C 标准和 Windows API)来支持 C++多线程。编译器的支持只是允许调用对应平台的 C API，以及保证 C++ 运行时库在多线程存在的情况下也可以正确执行。尽管很少有编译器商家提供正式的可感知多线程的内存模型，但是编译器和进程的行为已经足够好，因此编写了大量多线程 C++程序。<br />
</p>

<p>
不满足于使用平台特定的 C API 来处理多线程，C++程序员指望他们的类库来提供面向对象的多线程设施。MFC、Boost、ACE 等等，都累积了一系列类，对底层平台相关的 API 进行了封装，为多线程提供更高级的设施，来简化多线程编程任务。尽管这些类库的具体细节差异很大，特别是启动新线程的处理，这些类的整体上也有很多共同点。他们都使用了 RAII 惯用方法来管理 mutex。<br />
</p>

<p>
大部分情况下支持多线程的 C++编译器和平台无关的类库是足够了的。但是缺乏 C++标准的支持,意味着由于缺少多线程感知的内存模型可能会在偶然的地方导致问题，特别是利用处理器硬件知识来获得更高性能的时候，以及编写跨平台代码而编译器在不同平台上行为不同时。<br />
</p>
</div>
</div>

<div id="outline-container-org4f57a54" class="outline-5">
<h5 id="org4f57a54">Concurrency support in the C++11 standard</h5>
<div class="outline-text-5" id="text-org4f57a54">
<p>
C++11 不止提供了多线程感知内存模型。C++标准库还包含了管理线程的类，保护共享数据的类，在线程之间同步操作的类，以及低级的原子操作。<br />
</p>

<p>
C++14 中新加了一种 mutex 类型用于保护共享的数据。<br />
</p>

<p>
C++17 中添加了一整套并行算法。<br />
</p>
</div>
</div>

<div id="outline-container-org595474f" class="outline-5">
<h5 id="org595474f">Efficiency in the C++ Thread Library</h5>
<div class="outline-text-5" id="text-org595474f">
<p>
高性能计算领域，开发者关心的其中一个问题是 C++的效率。如果你追求极致的性能，那么你需要知道，任何高阶工具都会有一定的消耗，这是抽象的代价。<br />
</p>

<p>
C++ Standard Library 和 Thread Library 的设计目标之一是和直接使用低阶 API 相比，消耗相同或差距不大。另一个设计目标是提供低阶的工具用于实现极限性能。<br />
</p>
</div>
</div>

<div id="outline-container-orgcf64184" class="outline-5">
<h5 id="orgcf64184">Platform-specific facilities</h5>
<div class="outline-text-5" id="text-orgcf64184">
<p>
C++ Thread Library 为多线程和并发提供了全面的工具，而总会有平台特定的一些工具，为了便于访问平台特定的工具 C++ Thread Library 提供了 native_handler() 成员函数，其允许底层实现直接操作平台相关的 API。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org797acd7" class="outline-4">
<h4 id="org797acd7">Getting started</h4>
<div class="outline-text-4" id="text-org797acd7">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>
<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">hello</span>()
  {
      <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">"Hello Concurrent World\n"</span>;
  }
  <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
  {
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(hello);
      t.join();
  }
</pre>
</div>
<p>
每个线程都有一个初始化函数，对于应用程序的初始线程(主线程)来说，这个函数就是 main 函数。其他线程的初始函数是通过 std::thread 对象构造时来指定的。<br />
</p>

<p>
新的线程被启动后，主线程会继续执行。如果主线程不等待新线程结束，主线程会直接执行完成(可能在新线程获得执行机会之前)。通过调用 join() 来让主线程等待关联的新线程。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgaa86eef" class="outline-3">
<h3 id="orgaa86eef">02 managing threads</h3>
<div class="outline-text-3" id="text-orgaa86eef">
</div>
<div id="outline-container-org404434d" class="outline-4">
<h4 id="org404434d">Basic thread management</h4>
<div class="outline-text-4" id="text-org404434d">
</div>
<div id="outline-container-org23ed669" class="outline-5">
<h5 id="org23ed669">创建进程</h5>
<div class="outline-text-5" id="text-org23ed669">
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">background_task</span>
  {
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
      {
          do_something();
          do_something_else();
      }
  };
  
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">thread &#25509;&#21463;&#20219;&#24847;&#21487;&#35843;&#29992;&#23545;&#35937;&#65292;&#20989;&#25968;&#12289;&#37325;&#36733;&#20102;&#35843;&#29992;&#25805;&#20316;&#31526;&#30340;&#31867;&#12289;lambda&#31561;</span>
  <span style="color: #ce537a; font-weight: bold;">background_task</span> <span style="color: #7590db;">f</span>;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">f&#20250;&#34987;copy&#21040;&#23646;&#20110;&#26032;&#32447;&#31243;&#30340;&#23384;&#20648;&#31354;&#38388;&#65292;&#24182;&#34987;&#35843;&#29992;</span>
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">my_thread</span>(f);
  
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips&#65306;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#35299;&#26512;&#20026;&#22768;&#26126;&#19968;&#20010;&#21517;&#31216;&#20026;my_thread&#30340;&#20989;&#25968;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20989;&#25968;&#21442;&#25968;&#20026;&#20989;&#25968;&#25351;&#38024;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21442;&#25968;&#20989;&#25968;&#30340;&#21442;&#25968;&#20026;&#31354;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21442;&#25968;&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;&#31867;&#22411;&#20026;background_task</span>
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">my_thread</span>(<span style="color: #ce537a; font-weight: bold;">background_task</span>());
  
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27491;&#30830;&#30340;&#26041;&#24335;&#22914;&#19979;</span>
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">my_thread</span>((<span style="color: #ce537a; font-weight: bold;">background_task</span>()));
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">my_thread</span>{background_task()};
  
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; lambda &#20316;&#20026; thread &#30340;&#25191;&#34892;&#20989;&#25968;</span>
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">my_thread</span>([]{
      do_something();
      do_something_else();
  });
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f43cbd" class="outline-5">
<h5 id="org8f43cbd">等待进程结束</h5>
<div class="outline-text-5" id="text-org8f43cbd">
<p>
线程启动后，需要显示地指定是否等待其结束（调用 thread 对象的 join 函数）还是让线程自己运行（调用 thread 对象的 detach 函数）。如果在线程对象销毁前不进行指定，std::thread 的析构函数会调用 std::terminate()，这会导致进程被终止。<br />
</p>
</div>
<div id="outline-container-org9fde78d" class="outline-6">
<h6 id="org9fde78d">case1</h6>
<div class="outline-text-6" id="text-org9fde78d">
<p>
创建线程后，执行 detach，线程执行的函数永不结束，当主线程结束后，子线程也会被迫结束。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/4666628/do-child-threads-exit-when-the-parent-thread-terminates">https://stackoverflow.com/questions/4666628/do-child-threads-exit-when-the-parent-thread-terminates</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1444a5c" class="outline-6">
<h6 id="org1444a5c">case2</h6>
<div class="outline-text-6" id="text-org1444a5c">
<p>
创建线程后，主线程将局部变量的引用或指针传递给线程，执行 detach，主线程离开局部变量作用域，局部变量会被释放掉，之后线程引用的数据将是错误的。<br />
</p>
<pre class="example" id="orgd665449">
id: 100504 print ival = 10              // 子线程启动后打印引用变量的值10
id: 89912 main-thread sleep 1 second    // 主线程sleep 1s
id: 100504 print ival = 10              // 此时主线程还在sleep局部变量还未被释放，子线程此时打印的值依然正确
id: 100504 print ival = 143             // 主线程已经离开创建子线程的作用域，局部变量被释放，子线程打印的值为随机值，每次运行该值都不同
id: 100504 print ival = 143
id: 100504 print ival = 143
id: 100504 print ival = 143
id: 89912 main-thread sleep 5 second
</pre>
</div>
</div>

<div id="outline-container-orgebdbd62" class="outline-6">
<h6 id="orgebdbd62">case3</h6>
<div class="outline-text-6" id="text-orgebdbd62">
<p>
创建线程后，主线程将局部变量的引用或指针传递给线程，执行 join，主线程会等待子线程执行完毕后，才会继续执行，离开局部变量作用域。<br />
</p>
<pre class="example" id="orgb5cbe1f">
id: 97172 print ival = 10               // 子线程启动后打印引用变量的值10，主线程等待子线程执行完毕后，才会继续执行
id: 97172 print ival = 10
id: 97172 print ival = 10
id: 97172 print ival = 10
id: 97172 print ival = 10
id: 93504 main-thread sleep 1 second
id: 93504 main-thread sleep 5 second
</pre>

<p>
join() 会清理子线程关联的存储空间，因此 std::thread 对象不再关联结束的线程，其不再关联任意线程。所以，只能对指定的线程调用一次 join，join 之后再调用 joinable 将返回 false。<br />
</p>
</div>
</div>

<div id="outline-container-orgcfca390" class="outline-6">
<h6 id="orgcfca390">case4</h6>
<div class="outline-text-6" id="text-orgcfca390">
<p>
主线程创建子线程后 sleep 2 秒，然后再调用 join.<br />
子线程只执行一次打印就结束.<br />
</p>

<p>
主线程创建子线程后 sleep 2 秒，然后再调用 detach.<br />
子线程只执行一次打印就结束.<br />
</p>

<p>
TIPS: 子线程很快就会完成的情况下，并不会报错。只要在 std::thread 的析构之前调用 join 或 detach 就可以了。<br />
</p>
</div>
</div>

<div id="outline-container-org943a09b" class="outline-6">
<h6 id="org943a09b">case5</h6>
<div class="outline-text-6" id="text-org943a09b">
<p>
主线程创建子线程 A, 子线程 A 创建子线程 B，子线程 A 完成后，子线程 B 会依然执行，不会被迫结束。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/4666628/do-child-threads-exit-when-the-parent-thread-terminates">https://stackoverflow.com/questions/4666628/do-child-threads-exit-when-the-parent-thread-terminates</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org0ca907c" class="outline-6">
<h6 id="org0ca907c">利用 RAII 来等待线程结束</h6>
<div class="outline-text-6" id="text-org0ca907c">
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">thread_guard</span>
  {
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span>&amp; <span style="color: #7590db;">t</span>;
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
      <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">thread_guard</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span>&amp; <span style="color: #7590db;">t_</span>):<span style="color: #bc6ec5; font-weight: bold;">t</span>(t_){}
      ~<span style="color: #bc6ec5; font-weight: bold;">thread_guard</span>()
      {
          <span style="color: #4f97d7; font-weight: bold;">if</span>(t.joinable())
          {
              t.join();
          }
      }
      <span style="color: #bc6ec5; font-weight: bold;">thread_guard</span>(<span style="color: #ce537a; font-weight: bold;">thread_guard</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
      <span style="color: #ce537a; font-weight: bold;">thread_guard</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">thread_guard</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
  };
  <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">func</span>;
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>()
  {
      <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_local_state</span> = 0;
      <span style="color: #ce537a; font-weight: bold;">func</span> <span style="color: #7590db;">my_func</span>(some_local_state);
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(my_func);
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">RAII&#26469;&#31561;&#24453;&#32447;&#31243;&#32467;&#26463;</span>
      thread_guard(t);
      do_something_in_current_thread();
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org2377857" class="outline-6">
<h6 id="org2377857">利用 detach 来使线程在后台运行</h6>
<div class="outline-text-6" id="text-org2377857">
<p>
detached 的线程通常被称为后台线程(daemon threads)，其概念来源于操作系统中后台进程(daemon process)。<br />
下面是利用 detach 线程实现的文字处理器，其可以同时处理多个文件，每个线程处理一个文件。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">edit_document</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">filename</span>)
  {
      open_document_and_display_gui(filename);
      <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done_editing())
      {
          <span style="color: #ce537a; font-weight: bold;">user_command</span> <span style="color: #7590db;">cmd</span> = get_user_input();
          <span style="color: #4f97d7; font-weight: bold;">if</span>(cmd.type == open_new_document)
          {
              <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_name</span> = get_filename_from_user();
              <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(edit_document, new_name);
              t.detach();
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          {
              process_user_input(cmd);
          }
      }
  }
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org485fabf" class="outline-4">
<h4 id="org485fabf">Passing arguments to a thread function</h4>
<div class="outline-text-4" id="text-org485fabf">
<p>
传递指针参数给线程非常容易引起访问悬挂指针的问题，指针所指对象已经被回收了，线程还使用指针进行访问。<br />
传递给线程参数的处理分两步：<br />
</p>
<ol class="org-ol">
<li>将参数传递给 thread 构造函数，thread 构造函数会将参数 copy 一份记录下来。<br /></li>
<li>thread 对象再将记录下来的参数传递给线程入口函数。传递给线程入口函数的实参是在子线程的上下文中进行构造的。<br /></li>
</ol>


<ul class="org-ul">
<li>C++的 std::thread 是怎么进行参数传递的？ <a href="https://www.zhihu.com/question/40428244">https://www.zhihu.com/question/40428244</a>   <br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #2aa1ae; background-color: #292e34;">////////////////////////////</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case 1 &#19979;&#38754;&#20195;&#30721;&#23558;char const* &#20256;&#36882;&#32473;thread&#65292;thread&#20197;char const*&#20026;&#21442;&#25968;&#26500;&#36896;std::string&#23545;&#35937;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;"hello"&#20026;&#24120;&#37327;&#23383;&#31526;&#20018;&#65292;&#20854;&#23384;&#20648;&#22312;&#24120;&#37327;&#25968;&#25454;&#21306;&#65288;&#36827;&#31243;&#36864;&#20986;&#26102;&#25165;&#37322;&#25918;&#65289;&#65292;&#31163;&#24320;&#23616;&#37096;&#20316;&#29992;&#22495;&#21518;&#19981;&#20250;&#34987;&#37322;&#25918;&#65292;&#25152;&#20197;&#22914;&#19979;&#20195;&#30721;&#19981;&#20250;&#23384;&#22312;&#26410;&#23450;&#20041;&#34892;&#20026;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>,<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">s</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">opps</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_param</span>)
  {
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(f, 3, <span style="color: #2d9574;">"hello"</span>);
  }
  
  <span style="color: #2aa1ae; background-color: #292e34;">////////////////////////////</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case 2.1 &#19979;&#38754;&#20195;&#30721;&#23558;char* buffer &#20256;&#36882;&#32473;thread&#65292;thread &#20197; char const*&#20026;&#21442;&#25968;&#26500;&#36896;std::string&#23545;&#35937;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;buffer&#20026;&#23616;&#37096;&#23383;&#31526;&#25968;&#32452;&#65292;&#31163;&#24320;&#23616;&#37096;&#20316;&#29992;&#22495;&#21518;&#20250;&#34987;&#37322;&#25918;&#65292;&#25152;&#20197;&#24403;&#20027;&#32447;&#31243;&#20808;&#31163;&#24320;oops&#23376;&#32447;&#31243;&#25165;&#24320;&#22987;&#36816;&#34892;&#26102;&#65292;&#22914;&#19979;&#20195;&#30721;&#20250;&#23384;&#22312;&#26410;&#23450;&#20041;&#34892;&#20026;&#65281;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://www.zhihu.com/question/40428244</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">https://www.jianshu.com/p/816df045f93e</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">oops</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_param</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">buffer</span>[1024];
      sprintf(buffer, <span style="color: #2d9574;">"%i"</span>, some_param);
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(f, 3, buffer);
      t.detach();
  }
  
  <span style="color: #2aa1ae; background-color: #292e34;">////////////////////////////</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case 2.2 &#19979;&#38754;&#20195;&#30721;&#23558;string&#23545;&#35937;&#30340;&#26500;&#36896;&#31227;&#21040;&#20102;&#20027;&#32447;&#31243;&#20013;&#65292;&#20256;&#36882;&#32473;thread&#26500;&#36896;&#20989;&#25968;&#30340;&#26159;string&#23545;&#35937;&#65292;thread&#26500;&#36896;&#20989;&#25968;&#20250;copy&#19968;&#20221;string&#23545;&#35937;&#20445;&#23384;&#19979;&#26469;&#65292;&#28982;&#21518;&#20250;&#23558;copy&#19979;&#26469;&#30340;string&#23545;&#35937;&#20256;&#36882;&#32473;&#32447;&#31243;&#20837;&#21475;&#20989;&#25968;&#12290;&#36825;&#26679;&#23601;&#19981;&#20250;&#23384;&#22312;&#35775;&#38382;&#23545;&#35937;&#34987;&#37322;&#25918;&#30340;&#24773;&#20917;&#20102;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">oops</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_param</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">buffer</span>[1024];
      sprintf(buffer, <span style="color: #2d9574;">"%i"</span>, some_param);
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(f, 3, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>(<span style="color: #7590db;">buffer</span>));
      t.detach();
  }
  
  <span style="color: #2aa1ae; background-color: #292e34;">////////////////////////////</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case 3.1 &#19979;&#38754;&#20195;&#30721;&#24076;&#26395;&#36890;&#36807;&#23376;&#32447;&#31243;&#21435;&#20462;&#25913;data&#65292;&#23376;&#32447;&#31243;&#32467;&#26463;&#21518;&#65292;&#20027;&#32447;&#31243;&#20877;&#32487;&#32493;&#22788;&#29702;&#25968;&#25454;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20294;&#26159;&#65292;&#32447;&#31243;&#26500;&#36896;&#20989;&#25968;&#30340;&#21442;&#25968;&#26159;&#20540;&#31867;&#22411;&#65292;&#25152;&#20197;&#32447;&#31243;&#20256;&#36882;&#32473;&#20837;&#21475;&#20989;&#25968;&#30340;&#23454;&#21442;&#26159;data&#30340;copy&#12290;&#20027;&#32447;&#31243;&#30340;data&#23545;&#35937;&#24182;&#27809;&#26377;&#34987;&#20462;&#25913;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update_data_for_widget</span>(<span style="color: #ce537a; font-weight: bold;">widget_id</span> <span style="color: #7590db;">w</span>, <span style="color: #ce537a; font-weight: bold;">widget_data</span>&amp; <span style="color: #7590db;">data</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">oops_again</span>(<span style="color: #ce537a; font-weight: bold;">widget_id</span> <span style="color: #7590db;">w</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">widget_data</span> <span style="color: #7590db;">data</span>;
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(update_data_for_widget, w, data);
      display_status();
      t.join();
      process_widget_data(data);
  }
  
  <span style="color: #2aa1ae; background-color: #292e34;">////////////////////////////</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">case 3.2 &#19979;&#38754;&#20195;&#30721;&#20351;&#29992;std::ref &#23558;data&#30340;&#24341;&#29992;&#20256;&#36882;&#32473;&#32447;&#31243;&#26500;&#36896;&#20989;&#25968;&#65292;&#20351;&#24471;&#32447;&#31243;&#35775;&#38382;&#30340;data&#25968;&#25454;&#23601;&#26159;&#20027;&#32447;&#31243;&#30340;data</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update_data_for_widget</span>(<span style="color: #ce537a; font-weight: bold;">widget_id</span> <span style="color: #7590db;">w</span>, <span style="color: #ce537a; font-weight: bold;">widget_data</span>&amp; <span style="color: #7590db;">data</span>);
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">oops_again</span>(<span style="color: #ce537a; font-weight: bold;">widget_id</span> <span style="color: #7590db;">w</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">widget_data</span> <span style="color: #7590db;">data</span>;
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(update_data_for_widget, w, <span style="color: #a45bad;">std</span>::ref(data));
      display_status();
      t.join();
      process_widget_data(data);
  }
</pre>
</div>
</div>
<div id="outline-container-orgffd51b9" class="outline-5">
<h5 id="orgffd51b9">通过传递对象指针，就可以使用成员函数作为线程入口函数</h5>
<div class="outline-text-5" id="text-orgffd51b9">
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span>
  {
  <span style="color: #4f97d7; font-weight: bold;">public</span>:
      <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_lengthy_work</span>();
  };
  
  <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">my_x</span>;
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(&amp;<span style="color: #a45bad;">X</span>::do_lengthy_work, &amp;my_x);
</pre>
</div>
</div>
</div>
<div id="outline-container-org7810686" class="outline-5">
<h5 id="org7810686">传递只能 move 而不能 copy 的参数</h5>
<div class="outline-text-5" id="text-org7810686">
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_big_object</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;big_object&gt;);
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;big_object&gt; <span style="color: #7590db;">p</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">big_object</span>);
  p-&gt;prepare_data(42);
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">t</span>(process_big_object, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">p</span>));
</pre>
</div>
<p>
std::thread 对象和 std::unique_ptr 对象一样，只能 move 而不能 copy<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgaf43aae" class="outline-4">
<h4 id="orgaf43aae">Transferring ownership of a thread</h4>
<div class="outline-text-4" id="text-orgaf43aae">
<div class="org-src-container">
<pre class="src src-cpp">  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">some_function</span>();
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">some_other_function</span>();
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">t1</span>(some_function);
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t2</span>=<span style="color: #a45bad;">std</span>::move(t1);          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;t1&#25152;&#26377;&#26435;&#31227;&#21160;&#32473;t2</span>
  t1 = <span style="color: #a45bad;">std</span>::thread(some_other_function); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#31227;&#21160;&#26500;&#36896;&#20989;&#25968;&#23558;&#26032;&#26500;&#36896;&#30340;&#32447;&#31243;&#25152;&#26377;&#26435;&#31227;&#21160;&#32473;t1</span>
  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t3</span>;                        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;&#26500;&#36896;std::thread&#23545;&#35937;t3&#65292;&#20854;&#19981;&#20851;&#32852;&#20219;&#20309;&#32447;&#31243;</span>
  t3 = <span style="color: #a45bad;">std</span>::move(t2);                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;t2&#25152;&#26377;&#26435;&#31227;&#21160;&#32473;t3</span>
  t1 = <span style="color: #a45bad;">std</span>::move(t3);                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#39318;&#20808;&#23558;t1&#33258;&#36523;&#25152;&#26377;&#26435;&#37322;&#25918;&#65288;&#30001;&#20110;&#27809;&#26377;&#23545;t1&#25191;&#34892;join&#25110;detach&#65292;&#25152;&#20197;&#65292;&#36825;&#37324;&#20250;&#30452;&#25509;&#35843;&#29992;std::terminate &#32467;&#26463;&#36827;&#31243;&#65289;&#65292;==(&#36827;&#31243;&#32467;&#26463;&#65292;&#27809;&#26377;&#28982;&#21518;&#20102;&#65281;)==</span>
</pre>
</div>

<p>
std::thread 支持 move 意味着，可以将 std::thread 的所有权传递到函数外：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>()
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #7590db;">some_function</span>();
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::thread(some_function);
}

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">g</span>()
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #7590db;">some_other_function</span>(<span style="color: #ce537a; font-weight: bold;">int</span>);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(some_other_function, 42);
    <span style="color: #4f97d7; font-weight: bold;">return</span> t;
}
</pre>
</div>

<p>
同理，也可以将所有权传递到一个函数内：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">g</span>()
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #7590db;">some_function</span>();
    f(<span style="color: #a45bad;">std</span>::thread(some_function));
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(some_function);
    f(<span style="color: #a45bad;">std</span>::move(t));
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">f(t);   // TIPS: &#27492;&#22788;&#35843;&#29992;&#20102;thread&#30340;copy&#26500;&#36896;&#20989;&#25968;&#65292;&#35813;&#20989;&#25968;&#34987;thread&#26631;&#35760;&#20026;&#20102;delete&#65292;&#22240;&#27492;&#20250;&#32534;&#35793;&#38169;&#35823;</span>
}
</pre>
</div>
</div>
<div id="outline-container-org08c4ad6" class="outline-5">
<h5 id="org08c4ad6">scoped_thread</h5>
<div class="outline-text-5" id="text-org08c4ad6">
<p>
std::thread 支持移动的一个好处是，可以依赖 scoped_thread 类，让其拥有 thread 的所有权。这避免了不好的事情发生，thread_scoped 对象要比其管理的 thread 的生命期长，而且一旦 thread 的所有权移动到 scoped_thread 对象中，其他对象将不能再对线程进行 join 或 detach 操作。因为，该类的目的是让 thread 在作用域内执行完成，因此将该类命名为 scoped_thread。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">scoped_thread</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">scoped_thread</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t_</span>): t(<span style="color: #a45bad;">std</span>::move(t_))
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>t.joinable())
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::logic_error(&#8220;No thread&#8221;);
    }
    ~<span style="color: #bc6ec5; font-weight: bold;">scoped_thread</span>()
    {
        t.join();
    }
    <span style="color: #bc6ec5; font-weight: bold;">scoped_thread</span>(<span style="color: #ce537a; font-weight: bold;">scoped_thread</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">scoped_thread</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">scoped_thread</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
};
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">func</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23454;&#29616;&#20102;&#35843;&#29992;&#25805;&#20316;&#31526;&#30340;struct</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>()
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_local_state</span>;
    <span style="color: #ce537a; font-weight: bold;">scoped_thread</span> <span style="color: #7590db;">t</span>{<span style="color: #a45bad;">std</span>::thread(func(some_local_state))};
    do_something_in_current_thread();
}
</pre>
</div>
<p>
上面 scoped_thread 和前面 thread_guard 类实现类似，不同之处在于，scoped_thread 可以接受直接构造的 thread 对象，而 thread_guard 则需要先创建一个 thread 对象，再将该对象通过引用传递给 thread_guard。<br />
</p>
</div>
</div>
<div id="outline-container-orgced868b" class="outline-5">
<h5 id="orgced868b">joining_thread</h5>
<div class="outline-text-5" id="text-orgced868b">
<p>
C++17 有一个提议是 joining_thread，其和 thread 类似，但是会在 joining_thread 对象释放时自动执行 join。该提议没有被同意，C++20 有一个相同的提议 jthread。我们可以很容易自己实现 joining_thread,如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">joining_thread</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">joining_thread</span>() <span style="color: #4f97d7; font-weight: bold;">noexcept</span>=<span style="color: #4f97d7; font-weight: bold;">default</span>;
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Callable</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> ... <span style="color: #ce537a; font-weight: bold;">Args</span>&gt;
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">joining_thread</span>(<span style="color: #ce537a; font-weight: bold;">Callable</span>&amp;&amp; <span style="color: #7590db;">func</span>,<span style="color: #ce537a; font-weight: bold;">Args</span>&amp;&amp; ... <span style="color: #7590db;">args</span>): <span style="color: #bc6ec5; font-weight: bold;">t</span>(<span style="color: #a45bad;">std</span>::forward&lt;<span style="color: #ce537a; font-weight: bold;">Callable</span>&gt;(func),<span style="color: #a45bad;">std</span>::forward&lt;<span style="color: #ce537a; font-weight: bold;">Args</span>&gt;(args)...)
    {}
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">joining_thread</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t_</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span>:
        t(<span style="color: #a45bad;">std</span>::move(t_))
    {}
    <span style="color: #bc6ec5; font-weight: bold;">joining_thread</span>(<span style="color: #ce537a; font-weight: bold;">joining_thread</span>&amp;&amp; <span style="color: #7590db;">other</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span>:
        t(<span style="color: #a45bad;">std</span>::move(other.t))
    {}
    <span style="color: #ce537a; font-weight: bold;">joining_thread</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">joining_thread</span>&amp;&amp; <span style="color: #7590db;">other</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(joinable())
            join();
        t=<span style="color: #a45bad;">std</span>::move(other.t);
        <span style="color: #4f97d7; font-weight: bold;">return</span> *<span style="color: #4f97d7; font-weight: bold;">this</span>;
    }
    <span style="color: #ce537a; font-weight: bold;">joining_thread</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">other</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(joinable())
            join();
        t=<span style="color: #a45bad;">std</span>::move(other);
        <span style="color: #4f97d7; font-weight: bold;">return</span> *<span style="color: #4f97d7; font-weight: bold;">this</span>;
    }
    ~joining_thread() <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(joinable())
            join();
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">joining_thread</span>&amp; <span style="color: #7590db;">other</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        t.swap(other.t);
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::<span style="color: #ce537a; font-weight: bold;">id</span> <span style="color: #bc6ec5; font-weight: bold;">get_id</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> t.get_id();
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">joinable</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> t.joinable();
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">join</span>() { t.join(); }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">detach</span>()
    {
        t.detach();
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">as_thread</span>() <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> t;
    }
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">as_thread</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">noexcept</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> t;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org5c6d6d6" class="outline-5">
<h5 id="org5c6d6d6">thread and container</h5>
<div class="outline-text-5" id="text-org5c6d6d6">
<p>
thread 支持移动，使得可以用识别移动的 container 来存放 thread。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_work</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">id</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;20;++i)
    {
        threads.emplace_back(do_work,i);
    }
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">entry</span>: threads)
        entry.join();
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org86cb5eb" class="outline-4">
<h4 id="org86cb5eb">Choosing the number of threads at runtime</h4>
<div class="outline-text-4" id="text-org86cb5eb">
<p>
std::thread::hardware_concurrency() 返回真正可以并行执行的线程数量。在一个多核系统中，其返回的可能是 CPU 的核心数量。如果相关信息不可用时，其可能返回 0。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">accumulate_block</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">result</span>)
    {
        result=<span style="color: #a45bad;">std</span>::accumulate(first,last,result);
    }
};
<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length)
        <span style="color: #4f97d7; font-weight: bold;">return</span> init;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=
        (length+min_per_thread-1)/min_per_thread;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=
        <span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">results</span>(num_threads);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt;  <span style="color: #7590db;">threads</span>(num_threads-1);
    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        threads[i]=<span style="color: #a45bad;">std</span>::thread(
            accumulate_block&lt;Iterator,T&gt;(),
            block_start,block_end,<span style="color: #a45bad;">std</span>::ref(results[i]));
        block_start=block_end;
    }
    accumulate_block&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">T</span>&gt;()(
        block_start,last,results[num_threads-1]);
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">entry</span>: threads)
        entry.join();
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::accumulate(results.begin(),results.end(),init);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org307cb0f" class="outline-4">
<h4 id="org307cb0f">Identifying threads</h4>
<div class="outline-text-4" id="text-org307cb0f">
<p>
thread 身份标识的类型为 std::thread::id，可以通过两种方式获得 thread 的身份标识。<br />
</p>
<ol class="org-ol">
<li>通过 std::thread 的 get_id()成员函数获得 std::thread 关联线程的身份标识。如果 std::thread 对象不关联任何线程，则 get_id()成员函数返回一个默认的 std::thread::id 对象。<br /></li>
<li>通过 std::this_thread::get_id() 获得当前线程的身份标识。TIPS: std::this_thread 为一个命名空间。<br /></li>
</ol>

<p>
std::thread::id 类型的对象可以被自由地 copy 和比较。如果两个 std::thread::id 类型的对象相等，说明他们表示相同的线程，或者他们都不关联任何线程。<br />
std::thread::id 提供了完整的比较操作集合，其可以作为关联容器的 key，也可以对其进行排序。标准库还提供了 std::hash&lt;std::thread::id&gt;，因此其还可以作为新的非排序关联容器的 key。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::<span style="color: #ce537a; font-weight: bold;">id</span> <span style="color: #7590db;">master_thread</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">some_core_part_of_algorithm</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::get_id()==master_thread)
    {
        do_master_thread_work();
    }
    do_common_work();
}
</pre>
</div>

<p>
可以将 std::thread::id 输出。TIPS：std::thread::id 的输出是依赖于实现的，不同实现输出可能不同。输出值只用于调试，其没有任何意义。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::get_id();
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgab44313" class="outline-3">
<h3 id="orgab44313">03 sharing data between threads</h3>
<div class="outline-text-3" id="text-orgab44313">
<p>
使用线程来实现并发的一个关键好处是，线程之间可以更容易，更直接地共享数据。<br />
</p>

<p>
共享也会带来一些问题。假如你和一个普通朋友共享一间公寓。这间公寓只有一个厨房一个卫生间。你和你的朋友无法同时使用卫生间。如果在你需要使用卫生间时，你的朋友占用卫生间很长时间，这会使你非常沮丧。类似地，假如厨房有一个组合在一起的烤炉和烤架，如果你在烤香肠的同时，你室友在烘培蛋糕。这样做你们得到的结果不会很好。（你室友会得到混有香肠味的蛋糕）<br />
</p>

<p>
对线程来说也一样。多个线程之间共享数据时，你需要有规则规定，哪个线程可以在什么时候可以访问数据的哪些位，以及任何对该数据的改动如何同步给关心该数据的其他线程。可以很容易地在多线程之间共享数据不只是一个便利，其也是一个很大的麻烦。不正确地使用共享数据是导致并发相关 bug 的最大原因之一。<br />
</p>
</div>
<div id="outline-container-org00cd723" class="outline-4">
<h4 id="org00cd723">Problems with sharing data between threads</h4>
<div class="outline-text-4" id="text-org00cd723">
<p>
归根结底，多线程共享数据的问题都是由于修改数据导致的。如果所有共享的数据都是只读的，就不会有任何问题，因为数据被一个线程读取并不会影响其他线程对该数据的读取。但是，如果多个线程之间共享数据，其中一个或多个线程对数据进行修改，这将有很多潜在的问题。<br />
</p>

<p>
不变性（invariants）被广泛使用，来帮助程序员思考他们的代码。在做数据更新时，这些不变性常常会被破坏，特别是数据结构比较复杂，需要修改不只一个值的时候。考虑一个双向链表，每个节点有两个指针，指针 pre 指向前一个节点，指针 next 指向后一个节点。其包含这样的不变性：假如 A.next = B，则 B.pre=A。当删除一个节点时，被删除节点的两侧的节点都需要更新，只有一个节点更新后，不变性就会被破坏，直到另一个节点也更新完毕，不变性得以再次保持。<br />
</p>

<p>
在不变性被破坏的时候，从两个方向遍历列表获得的结果是不一致的。不变性被破坏的后果会各不相同；如果一个线程从左到右读列表，其会忽略被删除的节点。另一方面，如果另一个线程试图删除最右边的节点，则其可能永远将数据结构污染，甚至使进程 crash。这是一个 race conditions 的例子，其是在并行代码中最常见的导致 bug 的一种原因。<br />
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Invariant">https://en.wikipedia.org/wiki/Invariant</a><br /></li>
<li>计算机科学中的不变式思想 <a href="https://zhuanlan.zhihu.com/p/148144901">https://zhuanlan.zhihu.com/p/148144901</a><br /></li>
</ul>
</div>
<div id="outline-container-orgc6c8ab4" class="outline-5">
<h5 id="orgc6c8ab4">Race conditions</h5>
<div class="outline-text-5" id="text-orgc6c8ab4">
<p>
假如你在一个很大的电影院买电影票，有很多售票员，因此同时有很多人可以购票。如果另一个售票员窗口的购票者正在和你买同一场电影的电影票，那么你可选的座位依赖于你和另一个人谁先订票。如果所剩座位不多，谁先谁后的差别就会非常重要：其甚至是一场竞赛，看谁拿到最后一张票。这是一个 race condition 的例子：你获得哪个座位(或者你是否能得到座位)取决于两次购买的先后顺序。<br />
</p>

<p>
在并行中，当结果依赖于两个或多个线程上执行的操作的相对顺序时，这种情况就是 race condition。多个线程竞争执行他们各自的操作。大多数时间，这种竞争是良性的，因为各种结果都是可接受的。例如，如果两个线程添加 item 到一个队列中，通常哪个 item 被先添加到队列并不重要，其系统的不变性一直被保持。当 race condition 导致不变性被破坏时，才会产生问题。在并行中谈到 race condition 时，通常是指有问题的 race condition；C++ 标准还定义了 data race 专业术语，用于表示一种特殊的 race condition，其专指对单个对象进行异步修改；data races 会导致可怕的未定义行为。<br />
</p>

<p>
有问题的 race conditions 通常发生在完成一个操作需要修改两个或多个不同的的数据。例如，上面提到的双向链表中删除节点。因为操作必须访问两个分开的数据，这些修改必须在分开的指令中，因此另一个线程可能在只有其中一个修改完成时就对数据进行访问。Race conditions 通常很难被发现并且很难被复现，因为复现的窗口机会非常小。如果修改是由连续的 CPU 指令完成的，该问题显露的机会在任何一次执行中都很小，即使是该数据结构被另一个线程同步访问。随着系统负载的增加，以及该操作执行次数的增加，有问题的执行次序出现的机会也会增加。这类问题几乎必然会在大多数不顺畅的时候出现。因为 race conditions 通常是时机敏感的，而 debugger 会影响程序的执行时机，因此在调试程序时，race conditions 通常会消失。<br />
</p>
</div>
</div>
<div id="outline-container-org455efcb" class="outline-5">
<h5 id="org455efcb">Avoiding problematic race conditions</h5>
<div class="outline-text-5" id="text-org455efcb">
<p>
有很多种方式来处理 problematic race conditions,最简单的方式是使用保护机制来封装数据结构，确保只有一个线程可以修改数据结构，只有修改数据结构的线程可以看到 invariants 被破坏的中间状态。从其他访问该数据结构的线程看，对数据结构的修改要么还没开始，要么已经完成。C++标准库提供了很多这样的机制。<br />
</p>

<p>
另一种方法是，修改你的数据结构的设计和不变性，使得对数据结构的修改是通过一系列不可分的修改来完成的，每个小的修改都保持了不变性。这种方式通常被称为无锁编程(lock-free programming)，其通常很难达到正确结果。如果您在此级别工作，内存模型的细微差别以及识别哪些线程可能会看到哪组值可能会变得复杂。内存模型在第 5 章介绍，无锁编程在第 7 章介绍。<br />
</p>

<p>
还有一种方法是，将对数据结构的修改当作事务（transaction），就像对数据库的更新是在一个事务内完成的。所需的一系列数据修改和读取存储在事务日志中，然后在一个步骤中提交。如果由于数据结构被其他线程修改提交无法被处理，事务会被重启。这种方法的专业术语名称为 software transactional memory (STM),当前是一个活跃的研究领域。本书不会介绍该方法，因为 c++中没有直接支持 STM（有一个对 c++进行 Transactional Memory 扩展的技术规范）。但是，秘密地做一些事，然后在单个步骤提交的基本理念会在后面提到。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7eed7a0" class="outline-4">
<h4 id="org7eed7a0">Protecting data with mutexes</h4>
<div class="outline-text-4" id="text-org7eed7a0">
<p>
为了保护共享数据结构，如果你可以标记所有代码片段，使他们互相排斥地(mutually exclusive)访问共享数据结构，当任何一个线程在执行其中一个代码片段时，其他试图访问共享数据结构的线程必须等待直到第一个线程访问结束。这将会保证除了做修改的线程外，其他线程无法看到不变性被破坏。<br />
使用互斥锁同步原语即可达到上面效果。mutex 是 mutual exclusion 的缩写。<br />
</p>

<p>
mutex 是 c++中最通用的数据保护机制。但是其不是银弹；你还需要组织你的代码以保护正确的数据，在你的接口中避免固有的 race conditions。mutexs 还会带来 deadlock 的问题。<br />
</p>
</div>
<div id="outline-container-orgfdfef4b" class="outline-5">
<h5 id="orgfdfef4b">Using mutexes in C++</h5>
<div class="outline-text-5" id="text-orgfdfef4b">
</div>
<div id="outline-container-orgaf803b0" class="outline-6">
<h6 id="orgaf803b0">mutex</h6>
<div class="outline-text-6" id="text-orgaf803b0">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;list&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;algorithm&gt;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">some_list</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">some_mutex</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">add_to_list</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">new_value</span>)
{
    some_mutex.lock();
    some_list.push_back(new_value);
    some_mutex.unlock();
    
}
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">list_contains</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">value_to_find</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">guard</span>(some_mutex);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9262ca0" class="outline-6">
<h6 id="org9262ca0">lock_guard</h6>
<div class="outline-text-6" id="text-org9262ca0">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;list&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;algorithm&gt;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">some_list</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">some_mutex</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">add_to_list</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">new_value</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::lock_guard &#21033;&#29992;RAII&#30340;&#29702;&#24565;&#26469;&#31649;&#29702; mutex</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">c++17&#20013;&#24341;&#20837;&#20102;&#22686;&#24378;&#29256;&#26412;&#30340; lock guard&#65292;&#20854;&#20026;std::scoped_lock</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::scoped_lock guard(some_mutex);</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">guard</span>(some_mutex);
    some_list.push_back(new_value);
}
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">list_contains</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">value_to_find</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">guard</span>(some_mutex);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8dbfb7c" class="outline-5">
<h5 id="org8dbfb7c">Structuring code for protecting shared data</h5>
<div class="outline-text-5" id="text-org8dbfb7c">
<p>
使用 mutex 保护数据不单单是在每个成员函数中放置 lock_guard 对象。一个逃逸的指针或引用会使得所有数据保护都是徒劳的。从某种角度看，检查逃逸指针或引用是比较容易的。只要没有成员函数返回共享数据的指针或引用给函数调用者。如果你更深入地挖掘，你会发现并不那么简单。你还要检查成员函数不会将共享数据的指针或引用传递进不受你控制的函数。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">some_data</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">a</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">b</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_something</span>();
};
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">data_wrapper</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">some_data</span> <span style="color: #7590db;">data</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Function</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_data</span>(<span style="color: #ce537a; font-weight: bold;">Function</span> <span style="color: #7590db;">func</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">l</span>(m);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#20445;&#25252;&#25968;&#25454;&#30340;&#24341;&#29992;&#20256;&#36882;&#32473;&#19981;&#21463;&#25511;&#21046;&#30340;func&#20989;&#25968;&#65292;func&#20989;&#25968;&#23558;&#20445;&#25252;&#25968;&#25454;&#30340;&#25351;&#38024;&#20445;&#23384;&#19979;&#26469;&#65292;&#23548;&#33268;&#20102;&#20849;&#20139;&#25968;&#25454;&#25351;&#38024;&#30340;&#36867;&#36920;</span>
        func(data);
    }
};
<span style="color: #ce537a; font-weight: bold;">some_data</span>* <span style="color: #7590db;">unprotected</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">malicious_function</span>(<span style="color: #ce537a; font-weight: bold;">some_data</span>&amp; <span style="color: #7590db;">protected_data</span>)
{
    unprotected=&amp;protected_data;
}
<span style="color: #ce537a; font-weight: bold;">data_wrapper</span> <span style="color: #7590db;">x</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>()
{
    x.process_data(malicious_function);
    unprotected-&gt;do_something();
}
</pre>
</div>

<p>
TIPS:<br />
不要通过函数返回共享数据的指针或引用，不要将共享数据的指针或引用存储在外部可见的地方，不要将共享数据的指针或引用当作参数传递给用户提供的函数。总之就是，不要将共享数据的指针或引用传递到锁的作用域外。<br />
</p>
</div>
</div>
<div id="outline-container-orgcb58817" class="outline-5">
<h5 id="orgcb58817">Spotting race conditions inherent in interfaces</h5>
<div class="outline-text-5" id="text-orgcb58817">
<p>
仅仅使用互斥锁或其他机制来保护共享数据，并不意味着就不会受 race condition 影响。你依然必须确保适当的数据被保护。考虑双向链表的例子，为了使一个线程安全地删除一个节点，必须避免其他线程同步访问 3 个节点：被删除的节点，以及该节点的前后节点。如果你独立地保护访问每个节点的指针，这样做不会比不使用互斥锁的代码更好，因为 race conditions 依然存在。最简单的方式是，使用一个互斥锁保护整个链表。<br />
</p>

<p>
仅仅使链表上的单个操作是安全的，也并不意味着不受 race condition 影响。考虑一个栈数据结构，如果你修改 top()函数使其返回一个数据 copy 而不是引用，并且使用 mutex 保护内部数据，这个接口本质上依然受 race condition 影响。该问题并不是只存在于基于 mutex 的实现方式，对于 lock-free 的实现方式也存在该问题，该问题是接口的问题。此处的问题是，empty()和 size()不能够被信赖。尽管在调用的时候，他们是正确的，但是一旦返回，其他线程即可自由地访问 stack，他们可能 push 新的元素或者 pop 老元素出来，此时再使用 empty()和 size()返回的结果将是错误的。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Container</span>=<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">deque</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Container</span>&amp;);
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #ce537a; font-weight: bold;">Container</span>&amp;&amp; = Container());
    <span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&gt; <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&amp;);
    <span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Container</span>&amp;, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&amp;);
    <span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #ce537a; font-weight: bold;">Container</span>&amp;&amp;, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&amp;);
    <span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">stack</span>(<span style="color: #ce537a; font-weight: bold;">stack</span>&amp;&amp;, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Alloc</span>&amp;);
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
    <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #bc6ec5; font-weight: bold;">size</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
    <span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">top</span>();
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">top</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;);
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp;&amp;);
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">pop</span>();
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">stack</span>&amp;&amp;);
    <span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span>... <span style="color: #ce537a; font-weight: bold;">Args</span>&gt; <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">emplace</span>(<span style="color: #ce537a; font-weight: bold;">Args</span>&amp;&amp;... <span style="color: #7590db;">args</span>);
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">stack</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">s</span>;
<span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>s.empty())                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 1</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">value</span>=s.top();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 2</span>
    s.pop();                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 3</span>
    do_something(value);
}
</pre>
</div>
<p>
当 stack 实例不被共享时，上面的代码是安全的。当 stack 实例被共享时，上面的代码就会有问题。该问题是由于接口设计导致的，因此需要修改接口。<br />
问题 1: mark1 和 mark2 之间可能有其他线程调用 pop。mark2 处调用 top 时，可能 stack 中已经没有数据了。这是因为 empty 和 top 的竞争导致的。解决该问题最简单的方式是，声明当 stack 中没数据时，top 会抛出异常。这样处理虽然定位了问题，它使得编程更加繁琐，你需要在 empty 返回 false 的情况下也要捕获异常。<br />
问题 2: 假设只有两个线程，且他们按照下面的顺序执行代码，两个线程的 value 变量是相同的值，所以两个线程中 do_something 处理的数据相同。stack 中 pop 出了两个元素，其中一个被处理两次，另一个没有被处理。这也是一种 race condition，其非常隐蔽，很难被发现。解决该问题需要对接口做更激进的修改。<br />
<img src="./AsynchronousProgramming/2021_07_29_stack_two_t.png" alt="2021_07_29_stack_two_t.png" /><br />
可以将 top 和 pop 合并在一起使用互斥量进行保护。但是，将 top 和 pop 合并也会引入新的问题。假如 stack 的类型为 stack&lt;vector&lt;int&gt;&gt;，vector 是一个尺寸动态变化的容器，当调用 top 时，执行 vector 的 copy，如果此时内存不够，则 copy 构造 vector 会抛出 std::bad_alloc 异常。新的 pop 函数被定义为返回弹出的数据，同时将其从 stack 上删除。你所面对的问题是，返回弹出的数据给调用者在，从 stack 上删除数据之后。如果从 stack 上删除数据成功，而返回数据给调用者抛出异常，则数据会永远丢失。可以通过下面几种方式来解决该问题：<br />
</p>
</div>
<div id="outline-container-orgf0f29e5" class="outline-6">
<h6 id="orgf0f29e5">方法 1: Pass in a reference</h6>
<div class="outline-text-6" id="text-orgf0f29e5">
<p>
这种方案在大多数情况下是可行的。但是，其缺点是需要调用者在调用之前构造一个 stack 元素的实例。对一些类型来说，这是不切实际的，构造一个实例是比较昂贵的。而对另外一些类型来说，这是不可行的，因为构造对象需要参数，而此处参数可能是不可行的。最后，其还需要 stack 的元素类型支持赋值。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">result</span>;
some_stack.pop(result);
</pre>
</div>
</div>
</div>
<div id="outline-container-org92d9156" class="outline-6">
<h6 id="org92d9156">方法 2: REQUIRE A NO-THROW COPY CONSTRUCTOR OR MOVE CONSTRUCTOR</h6>
<div class="outline-text-6" id="text-org92d9156">
<p>
限制 stack 元素的类型具有不抛异常的 copy 构造函数或具有不抛异常的 move 构造函数。这种方案限制了很多类型的元素无法存储在该 stack 中。<br />
</p>
</div>
</div>
<div id="outline-container-org3ccb3b5" class="outline-6">
<h6 id="org3ccb3b5">方法 3: RETURN A POINTER TO THE POPPED ITEM</h6>
<div class="outline-text-6" id="text-org3ccb3b5">
<p>
返回一个指针而不是返回元素的值。可以使用 std::shared_ptr 来管理指针。这种方案对于简单类型来说，比直接返回值性能要低。<br />
</p>
</div>
</div>
<div id="outline-container-orgeacecbc" class="outline-6">
<h6 id="orgeacecbc">方法 4: PROVIDE BOTH OPTION 1 AND EITHER OPTION 2 OR 3</h6>
<div class="outline-text-6" id="text-orgeacecbc">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;exception&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;memory&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;stack&gt;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">empty_stack</span>: <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>
{
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #bc6ec5; font-weight: bold;">what</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">throw</span>();
};
<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">stack</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mutable &#34920;&#31034;&#21487;&#20197;&#22312;const&#25104;&#21592;&#20989;&#25968;&#20013;&#20462;&#25913;&#35813;&#25104;&#21592;&#21464;&#37327;</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_stack</span>(){}
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_stack</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp; <span style="color: #7590db;">other</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(other.m);
        data=other.data;
    }
    <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp;) = <span style="color: #4f97d7; font-weight: bold;">delete</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36171;&#20540;&#36816;&#31639;&#31526;&#34987;&#21024;&#38500; &#22240;&#20026;std::mutex&#26159;&#19981;&#33021;copy &#19981;&#33021;move&#30340;&#23545;&#35937;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        data.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>));
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data.empty()) <span style="color: #4f97d7; font-weight: bold;">throw</span> empty_stack();
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data.top()));
        data.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data.empty()) <span style="color: #4f97d7; font-weight: bold;">throw</span> empty_stack();
        value=data.top();
        data.pop();
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data.empty();
    }
};
</pre>
</div>

<p>
前面讨论的 top 和 pop 接口之间的 race conditions，是因为锁的粒度太小导致的，锁没有覆盖到所有要保护的代码。将 top 和 pop 合为 pop 之后，解决了该问题。锁的粒度过大同样也会带来问题，极端情况下只用一个锁来保护所有的共享数据，这会消除所有并行带来的性能提升，因为同一时间只能执行一个线程。<br />
</p>

<p>
粒度适当的锁机制，有时候需要你使用多个互斥量来保护一个操作中的所有共享数据。例如，某个操作使用了某个类的多个实例，多个互斥量分别保护某个类的多个实例。在这种情况下，需要在上一级进行锁定，要么把锁定操作留给用户来做，要么就需要对类的所有实例进行锁定。这两种方式都不够好。<br />
</p>

<p>
当你需要为某个操作对两个或更多互斥量上锁时，这可能会导致死锁。<br />
</p>

<ul class="org-ul">
<li>C++ 中的 mutable 关键字 <a href="https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/">https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfd6d73f" class="outline-5">
<h5 id="orgfd6d73f">Deadlock: the problem and a solution</h5>
<div class="outline-text-5" id="text-orgfd6d73f">
<p>
假如你有两个小孩，你为他们买了一个玩具，该玩具有两部分：锣和锤。只有同时获得锣和锤才能玩敲锣的游戏。这时，你的两个孩子一个拿到了锣一个拿到了锤，他们都在等对方不让出拿到的一部分，这导致他们谁也不能玩敲锣游戏。这就是典型的死锁情况。<br />
两个线程也会发生这样的情况。死锁和 race conditions 完全相反，发生死锁后，每个线程都在等待对方完成。导致该问题的核心原因是完成某个操作需要同时对多个互斥量上锁。<br />
</p>

<p>
解决死锁的最平常的方式是，始终按照一定的顺序对互斥量进行上锁。这样，你将永远不会死锁。但是，有时候不容易做到。例如，某个函数是交换同一个类的两个实例，该函数的两个参数是等价的，调用该函数时，实参顺序可以被调换，这就破坏了上锁的顺序。<br />
</p>

<p>
C++标准库提供了 std::lock 函数，其可以对多个互斥量同时上锁。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">some_big_object</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">some_big_object</span>&amp; <span style="color: #7590db;">lhs</span>,<span style="color: #ce537a; font-weight: bold;">some_big_object</span>&amp; <span style="color: #7590db;">rhs</span>);
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">some_big_object</span> <span style="color: #7590db;">some_detail</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">X</span>(<span style="color: #ce537a; font-weight: bold;">some_big_object</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">sd</span>):<span style="color: #bc6ec5; font-weight: bold;">some_detail</span>(sd){}
    <span style="color: #4f97d7; font-weight: bold;">friend</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">lhs</span>, <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">rhs</span>)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#20004;&#20010;&#21442;&#25968;&#26159;&#21516;&#19968;&#20010;&#23545;&#35937;&#65292;&#21017;&#36820;&#22238;&#12290;&#36991;&#20813;&#23545;&#21516;&#19968;&#20010;&#20114;&#26021;&#37327;&#19978;&#38145;&#22810;&#27425;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#21516;&#19968;&#20010;&#20114;&#26021;&#37327;&#19978;&#38145;&#22810;&#27425;&#23646;&#20110;&#26410;&#23450;&#20041;&#34892;&#20026;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(&amp;lhs==&amp;rhs) 
            <span style="color: #4f97d7; font-weight: bold;">return</span>;
        <span style="color: #a45bad;">std</span>::lock(lhs.m,rhs.m);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock_a</span>(lhs.m,<span style="color: #a45bad;">std</span>::adopt_lock);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock_b</span>(rhs.m,<span style="color: #a45bad;">std</span>::adopt_lock);
        swap(lhs.some_detail,rhs.some_detail);
    }
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">C++17 &#24341;&#20837;&#20102; std::scoped_lock&lt;&gt; &#21487;&#20197;&#23545;&#19978;&#38754;swap&#20989;&#25968;&#36827;&#34892;&#31616;&#21270;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">lhs</span>, <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">rhs</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(&amp;lhs==&amp;rhs)  
        <span style="color: #4f97d7; font-weight: bold;">return</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::scoped_lock &#26159;&#19968;&#20010;&#27169;&#26495;&#31867;&#65292;&#27492;&#22788;&#21033;&#29992;&#20102;C++17&#20013;&#24341;&#20837;&#30340;&#31867;&#27169;&#26495;&#21442;&#25968;&#31867;&#22411;&#25512;&#26029;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">scoped_lock</span> <span style="color: #7590db;">guard</span>(lhs.m,rhs.m);
    swap(lhs.some_detail,rhs.some_detail);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3e6f079" class="outline-5">
<h5 id="org3e6f079">Further guidelines for avoiding deadlock</h5>
<div class="outline-text-5" id="text-org3e6f079">
<p>
死锁不止发生在互斥量上锁的时候。当两个线程互相调用对方 std::thread 对象的 join 函数，也会导致死锁。此时两个线程都无法向前执行，因为他们都在等待对方结束。<br />
所有避免死锁的指导原则都可以归结为：如果有机会等着你，那么就不要等另外其他线程。<br />
</p>
</div>
<div id="outline-container-org1266483" class="outline-6">
<h6 id="org1266483">AVOID NESTED LOCKS</h6>
<div class="outline-text-6" id="text-org1266483">
<p>
如果你已经对一个互斥量上了锁，不要再对其他互斥量上锁。这样就不会因为对互斥量上锁而导致死锁。如果需要对多个互斥量上锁，应该使用 std::lock。<br />
</p>
</div>
</div>
<div id="outline-container-orgb3905ff" class="outline-6">
<h6 id="orgb3905ff">AVOID CALLING USER-SUPPLIED CODE WHILE HOLDING A LOCK</h6>
<div class="outline-text-6" id="text-orgb3905ff">
<p>
用户的代码可能执行任何操作，其可能对互斥量上锁。如果你已经对一个互斥量上了锁，若用户的代码又对其他互斥量上锁，这破坏了第一条 guideline，有可能导致死锁。<br />
</p>
</div>
</div>
<div id="outline-container-org69db1c8" class="outline-6">
<h6 id="org69db1c8">ACQUIRE LOCKS IN A FIXED ORDER</h6>
<div class="outline-text-6" id="text-org69db1c8">
<p>
如果你需要获得多个锁，并且无法同时对这些互斥量进行上锁，那么你需要在所有线程中保证按照相同的顺序对 mutex 进行上锁。<br />
有时候无法很容易做到，考虑双向链表的例子。对于删除一个节点，我们需要获得 3 个节点的锁；遍历列表时，为了避免同时有其他线程对当前节点的 next ptr 有修改，当其获取下一个节点的锁时，其必须保持当前节点的锁。一旦获得下一个节点的锁，则可以释放当前节点的锁，下一个节点变为当前节点。这种 hand-over-hand 上锁方式，可以让多个线程同时访问列表的不同节点。但是，为了避免死锁，节点必须按照相同的顺序上锁。例如：如果一个线程从头到尾遍历列表，另一个线程从尾到头遍历列表，就会出现死锁，详细分析如下：<br />
<img src="./AsynchronousProgramming/03_02_05_list_traverse.png" alt="03_02_05_list_traverse.png" /><br />
类似的，假设 A,B,C 是按顺序的三个节点。当删除节点 B 时，需要分别获得 A，B，C 的锁，如果先获得 B 的锁，此时其他线程有可能获得 A 的锁或 C 的锁，从而导致死锁。如果始终遵守获得锁的顺序则可避免死锁的问题。<br />
</p>
</div>
</div>
<div id="outline-container-org8dc79d7" class="outline-6">
<h6 id="org8dc79d7">USE A LOCK HIERARCHY</h6>
<div class="outline-text-6" id="text-org8dc79d7">
<p>
这是一种特殊的获取锁的顺序。层次锁结构提供了一种方法来检查在运行时约定规则是否被遵守。其理念是，将应用程序分层，确定给定层所有可能被锁定的互斥量。当代码试图对互斥量上锁时，如果其已经持有一个更底层的锁，则不允许其当前的操作。你可以为每个互斥量赋予一个层次编号，并记录哪些互斥量被哪些线程持有。C++标准库，没有直接提供这种机制。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span> <span style="color: #7590db;">high_level_mutex</span>(10000);
<span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span> <span style="color: #7590db;">low_level_mutex</span>(5000);
<span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span> <span style="color: #7590db;">other_mutex</span>(6000);
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">do_low_level_stuff</span>();

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">low_level_func</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span>&gt; <span style="color: #7590db;">lk</span>(low_level_mutex);
    <span style="color: #4f97d7; font-weight: bold;">return</span> do_low_level_stuff();
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">high_level_stuff</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_param</span>);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">high_level_func</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span>&gt; <span style="color: #7590db;">lk</span>(high_level_mutex);
    high_level_stuff(low_level_func()); 
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">thread_a &#36981;&#23432;&#20102;&#35268;&#21017;&#65292;&#20854;&#21487;&#20197;&#27491;&#30830;&#36816;&#34892;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20854;&#25345;&#26377; high level&#38145;&#65292;&#20801;&#35768;&#20877;&#33719;&#21462;low level&#38145;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_a</span>() 
{
    high_level_func();
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_other_stuff</span>();
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">other_stuff</span>()
{
    high_level_func();
    do_other_stuff();
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">thread_b &#36829;&#21453;&#20102;&#35268;&#21017;&#65292;&#25345;&#26377;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20854;&#25345;&#26377;middle level&#38145;&#65292;&#21448;&#21435;&#33719;&#21462;high level&#38145;&#65292;&#36825;&#26159;&#19981;&#34987;&#20801;&#35768;&#30340;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_b</span>()  
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span>&gt; <span style="color: #7590db;">lk</span>(other_mutex);
    other_stuff();
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">hierarchical_mutex</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">internal_mutex</span>;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hierarchy_value</span>;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">previous_hierarchy_value</span>;
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34987;thread_local &#26631;&#35760;&#30340;&#21464;&#37327;&#65292;&#27599;&#20010;&#32447;&#31243;&#37117;&#26377;&#33258;&#24049;&#30340;copy</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25152;&#26377;hierarchical_mutex &#23454;&#20363;&#37117;&#21487;&#20197;&#35775;&#38382;&#35813;&#21464;&#37327;&#65292;&#20294;&#26159;&#19981;&#21516;&#32447;&#31243;&#65292;&#35813;&#21464;&#37327;&#30340;&#20540;&#19981;&#21516;&#12290;</span>
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">this_thread_hierarchy_value</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">check_for_hierarchy_violation</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::logic_error(<span style="color: #2d9574;">"mutex hierarchy violated"</span>);
        }
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update_hierarchy_value</span>()
    {
        previous_hierarchy_value=this_thread_hierarchy_value;
        this_thread_hierarchy_value=hierarchy_value;
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">hierarchical_mutex</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">value</span>): hierarchy_value(value), previous_hierarchy_value(0) {}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>() {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38145;&#26102;&#65292;&#26816;&#26597;&#32447;&#31243;&#30340;&#38145;&#31561;&#32423;&#26159;&#21542;&#39640;&#20110;&#20114;&#26021;&#37327;&#38145;&#31561;&#32423;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this_thread_hierarchy_value &lt;= hierarchy_value &#33719;&#21462;&#26356;&#39640;&#31561;&#32423;&#30340;&#38145;&#65292;&#34987;&#31105;&#27490;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this_thread_hierarchy_value &gt; hierarchy_value  &#33719;&#21462;&#26356;&#20302;&#31561;&#32423;&#30340;&#38145;&#65292;&#34987;&#20801;&#35768;</span>
        check_for_hierarchy_violation(); 
        internal_mutex.lock();
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#24403;&#21069;&#32447;&#31243;&#30340;&#38145;&#31561;&#32423;</span>
        update_hierarchy_value();
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37322;&#25918;&#38145;&#26102;&#65292;&#26816;&#26597;&#32447;&#31243;&#30340;&#38145;&#31561;&#32423;&#26159;&#21542;&#31561;&#20110;&#20114;&#26021;&#37327;&#38145;&#31561;&#32423;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20081;&#24207;&#35299;&#38145;&#65292;&#20250;&#23548;&#33268;&#32447;&#31243;&#30340;&#38145;&#31561;&#32423;&#38169;&#35823;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//                                    </span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20363;&#22914;&#65306;&#33719;&#21462;&#38145;&#30340;&#39034;&#24207;&#20026; high-&gt;low&#65292;&#37322;&#25918;&#38145;&#30340;&#39034;&#24207;&#20063;&#20026; high-low</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//               </span><span style="color: #2aa1ae; background-color: #292e34;">hierachy_value     previous_hierachy_value     this_thread_hierachy_value</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lock high     high               ULONG_MAX                   high</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lock low      low                high                        low</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unlock high   high               ULONG_MAX                   ULONG_MAX</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unlock low    low                high                        high</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#27492;&#24212;&#35813;&#36870;&#24207;&#37322;&#25918;&#38145;&#65281;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(this_thread_hierarchy_value!=hierarchy_value) <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::logic_error(<span style="color: #2d9574;">"mutex hierarchy violated"</span>);
        this_thread_hierarchy_value=previous_hierarchy_value;
        internal_mutex.unlock();
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_lock</span>()
    {
        check_for_hierarchy_violation();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>internal_mutex.try_lock())
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        update_hierarchy_value();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }
};
<span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #a45bad;">hierarchical_mutex</span>::<span style="color: #bc6ec5; font-weight: bold;">this_thread_hierarchy_value</span>(ULONG_MAX);
</pre>
</div>
</div>
</div>
<div id="outline-container-org63032e2" class="outline-6">
<h6 id="org63032e2">EXTENDING THESE GUIDELINES BEYOND LOCKS</h6>
<div class="outline-text-6" id="text-org63032e2">
<p>
导致死锁的不止是对互斥量上锁，任何同步操作也会导致循环等待。因此，需要将上面的 guidelines 扩展到其他情况。例如，我们可以扩展 Avoid nested locks 这条 guideline。当线程获得一个锁时，不要去等待其他线程结束（等待的线程，可能正在获取当前线程持有的锁）。类似地，对于 Use a lock hierarchy 这条 guideliine，对于等待线程结束也适用，可以为线程指定 hierarchy，低等级的线程不能等待高等级的线程。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb699b38" class="outline-5">
<h5 id="orgb699b38">Flexible locking with std::unique_lock</h5>
<div class="outline-text-5" id="text-orgb699b38">
<p>
通过放松不变性，std::unique_lock 和 lock_guard 相比，提供了更多的灵活性。std::unique_lock 内部有一个 flag 用来标记其是否拥有 mutex 的所有权，如果其没有，则在析构函数中将不会对 mutex 进行 unlock，否则才会对 mutex 进行 unlock。std::unique_lock 的成员函数 owns_lock()可以用于查询 std::unique_lock 是否对 mutex 具有所有权。<br />
std::unique_lock 内部有 flag，因此，其所占内存大小要比 std::lock_guard 要大。由于 flag 的存在，std::unique_lock 的相关操作中需要对 flag 进行检查或更新，其性能也要比 std::lock_guard 要差一些。如果 std::lock_guard 满足你的需求，尽量使用 std::lock_guard，需要 defer lock 或需要将锁的所有权从一个作用域转移到另外作用域时，再使用 std::unique_lock .<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">some_big_object</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">some_big_object</span>&amp; <span style="color: #7590db;">lhs</span>,<span style="color: #ce537a; font-weight: bold;">some_big_object</span>&amp; <span style="color: #7590db;">rhs</span>);
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">some_big_object</span> <span style="color: #7590db;">some_detail</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">X</span>(<span style="color: #ce537a; font-weight: bold;">some_big_object</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">sd</span>):<span style="color: #bc6ec5; font-weight: bold;">some_detail</span>(sd){}
    <span style="color: #4f97d7; font-weight: bold;">friend</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">swap</span>(<span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">lhs</span>, <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">rhs</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(&amp;lhs==&amp;rhs)
            <span style="color: #4f97d7; font-weight: bold;">return</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::defer_lock &#34920;&#31034;&#65292;&#26242;&#26102;&#19981;&#23545;mutex&#19978;&#38145;</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock_a</span>(lhs.m,<span style="color: #a45bad;">std</span>::defer_lock);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock_b</span>(rhs.m,<span style="color: #a45bad;">std</span>::defer_lock);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#20351;&#29992;std::lock&#23545; std::unique_lock &#19978;&#38145;&#65292;&#20250;&#35843;&#29992;std::unique_lock&#30340;lock&#25104;&#21592;&#20989;&#25968;&#65292;&#36827;&#32780;&#35843;&#29992;mutex&#30340;lock&#25104;&#21592;&#20989;&#25968;</span>
        <span style="color: #a45bad;">std</span>::lock(lock_a,lock_b);
        swap(lhs.some_detail,rhs.some_detail);
    }
};
</pre>
</div>

<ul class="org-ul">
<li>std::unique_lock 源代码分析 <a href="https://blog.csdn.net/q943520218/article/details/95721696">https://blog.csdn.net/q943520218/article/details/95721696</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga6c870d" class="outline-5">
<h5 id="orga6c870d">Transferring mutex ownership between scopes</h5>
<div class="outline-text-5" id="text-orga6c870d">
<p>
由于 std::unique_lock 实例可以不拥有其所关联的 mutex，因此可以通过 moving 在 std::unique_lock 实例之间传递 mutex 的所有权。std::unique_lock 类型是 movable 类型，但不是 copyable 类型，当 std::unique_lock 实例为 rvalue 时可以自动传递，当 std::unique_lock 实例为 lvalue 时需要使用 std::move 将其转化为 rvalue。<br />
一种使用 std::unique_lock 传递 mutex 所有权的方式如下，get_lock 函数对 mutex 进行上锁，然后将所有权转移给调用者，调用者在锁的保护下可以继续做一些事情，调用者退出时，std::unique_lock 对象销毁，自动解锁 mutex。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt; <span style="color: #bc6ec5; font-weight: bold;">get_lock</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">TODO Why extern?</span>
    <span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">some_mutex</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(some_mutex);
    prepare_data();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">TODO mutex &#26080;&#27861;copy&#65292;&#37027;&#20040;lk&#23545;&#35937;&#22914;&#20309;&#20256;&#36882;&#20854;&#20851;&#32852;&#30340;mutex&#65311;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> lk;
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_data</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(get_lock());
    do_something();
}
</pre>
</div>
<p>
通常当对 mutex 的上锁依赖于程序状态或传入函数的参数时，会使用这种模式。一种方式是不直接返回 std::unique_lock 对象，而是将其作为一个 gateway 类的数据成员，用于保证正确上锁访问某些保护数据。这种情况下，所有对保护数据的访问都需要通过 gateway 类：当你需要访问数据时，你需要获得一个 gateway 的实例，然后通过该实例的成员函数来访问数据。当你访问结束后，你销毁了 gateway 对象，这样其他线程就可以访问保护数据了。该 gateway 对象很可能是 movable 的，此时锁对象也需要是 movable 的。<br />
</p>

<p>
std::unique_lock 还允许在对象销毁之前释放锁，只要调用其成员函数 unlock 就可以了。这样可以灵活控制锁的粒度，提高并行性能。<br />
</p>
</div>
</div>
<div id="outline-container-org3f336f6" class="outline-5">
<h5 id="org3f336f6">Locking at an appropriate granularity</h5>
<div class="outline-text-5" id="text-org3f336f6">
<p>
锁的粒度是一个形象的术语用于描述被一个锁保护的数据的量。细粒度锁保护少量数据，粗粒度锁保护大量数据。 选择足够粗的锁粒度以确保所需数据受到保护很重要，只为那些需要保护的操作持有锁也很重要。<br />
在超市购买商品，排队去结账，结账的时候发现漏买了果酱，其跑去拿果酱，使得其他所有人都等待；付款的时候，其又在包里找信用卡，此时别人也只能等待，这样减低了整体的速度。如果能提前检查购物清单，提前准备好信用卡，就可以消除其他客户不必要的等待。对于多线程也一样，当多个线程都在等待某个资源，如果任何一个线程持有该锁的时间包含了不必要保护的操作，都会导致整体的等待时间上升。尽可能只在访问共享数据时锁定互斥量，尽量在锁外对数据进行处理。特别是不要在持有锁时进行任何耗时的活动，例如文件 I/O。除非锁是用于保护对特定文件的访问。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">get_and_process_data</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt; <span style="color: #7590db;">my_lock</span>(the_mutex);
    <span style="color: #ce537a; font-weight: bold;">some_class</span> <span style="color: #7590db;">data_to_process</span>=get_next_data_chunk();
    my_lock.unlock(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#24471;&#25968;&#25454;&#21518;&#65292;&#37322;&#25918;&#38145;</span>
    <span style="color: #ce537a; font-weight: bold;">result_type</span> <span style="color: #7590db;">result</span>=process(data_to_process);
    my_lock.lock();   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20889;&#25968;&#25454;&#26102;&#65292;&#20877;&#19978;&#38145;</span>
    write_result(data_to_process,result);
}
</pre>
</div>
<p>
适当粒度的锁不仅是保护的数据量要尽可能少，持有锁的时间也要尽可能短。当持有锁时，不要去执行耗时很长的操作，例如文件 IO 或获取另一个锁（获取另一个锁时，可能会被阻塞，这样可能会等待很长时间）。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Y</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">some_detail</span>;
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">get_detail</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock_a</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">return</span> some_detail;
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">Y</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">sd</span>):<span style="color: #bc6ec5; font-weight: bold;">some_detail</span>(sd){}
    <span style="color: #4f97d7; font-weight: bold;">friend</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">==</span>(<span style="color: #ce537a; font-weight: bold;">Y</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">lhs</span>, <span style="color: #ce537a; font-weight: bold;">Y</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">rhs</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(&amp;lhs==&amp;rhs)
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#20998;&#24320;&#23545;&#20004;&#20010;&#21442;&#25968;&#36827;&#34892;&#19978;&#38145;&#65292;&#20943;&#20302;&#20102;&#38145;&#30340;&#31890;&#24230;&#65292;&#25552;&#39640;&#20102;&#24615;&#33021;&#12290;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20294;&#26159;&#65292;&#20063;&#20462;&#25913;&#20102;operator==&#30340;&#35821;&#24847;&#65292;&#20854;&#19981;&#20877;&#34920;&#31034;&#26576;&#20010;&#26102;&#38388;&#28857;&#20004;&#20010;&#23545;&#35937;&#30456;&#31561;&#65292;&#32780;&#26159;&#34920;&#31034;&#26576;&#20004;&#20010;&#26102;&#38388;&#28857;&#20004;&#20010;&#23545;&#35937;&#30456;&#31561;</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">lhs_value</span>=lhs.get_detail();
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">rhs_value</span>=rhs.get_detail();
        <span style="color: #4f97d7; font-weight: bold;">return</span> lhs_value==rhs_value;
    }
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org655820e" class="outline-4">
<h4 id="org655820e">Alternative facilities for protecting shared data</h4>
<div class="outline-text-4" id="text-org655820e">
</div>
<div id="outline-container-org19ba5b7" class="outline-5">
<h5 id="org19ba5b7">Protecting shared data during initialization</h5>
<div class="outline-text-5" id="text-org19ba5b7">
<p>
假设你有一个共享资源，构造该共享资源消耗比较大(例如：连接数据库或申请一大块内存)，你希望在使用的时候才执行构造。这种设计方式被称为 Lazy Initialization。单线程情况下，其实现方法如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;some_resource&gt; <span style="color: #7590db;">resource_ptr</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>resource_ptr)
    {
        resource_ptr.reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">some_resource</span>);
    }
    resource_ptr-&gt;do_something();
}
</pre>
</div>
<p>
上面的方式只能工作在单线程模式下，多线程情况下可能会多次执行初始化。可以通过下面几种方法来实现多线程模式的 Lazy Initialization。<br />
</p>
</div>
<div id="outline-container-org3a95b43" class="outline-6">
<h6 id="org3a95b43">最简单的方式，但性能低下</h6>
<div class="outline-text-6" id="text-org3a95b43">
<p>
最简单的方式是，使用互斥量来保护初始化过程，实现方式如下。但是，该方法导致初始化后的后续调用也会加锁解锁。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;some_resource&gt; <span style="color: #7590db;">resource_ptr</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">resource_mutex</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(resource_mutex);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>resource_ptr)
    {
        resource_ptr.reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">some_resource</span>);
    }
    lk.unlock();
    resource_ptr-&gt;do_something();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org33a464a" class="outline-6">
<h6 id="org33a464a">double-checked locking 方式，尝试优化性能，但引入了 data race</h6>
<div class="outline-text-6" id="text-org33a464a">
<p>
很多人使用 double-checked locking 模式来优化该问题，但是，该方法是错误的，其会导致更严重的未定义行为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">undefined_behaviour_with_double_checked_locking</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>resource_ptr) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 1</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt; <span style="color: #7590db;">lk</span>(resource_mutex);  
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>resource_ptr)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 2</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#25191;&#34892;&#20102;3&#27493;&#25805;&#20316;&#65306;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. &#20026; some_resource &#23545;&#35937;&#20998;&#37197;&#20869;&#23384;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. &#22312;&#20998;&#37197;&#30340;&#20869;&#23384;&#19978;&#35843;&#29992; some_resource&#30340;&#26500;&#36896;&#20989;&#25968;&#65292;&#26500;&#36896;&#19968;&#20010;some_resource&#23545;&#35937;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. &#36820;&#22238;&#35813;&#20869;&#23384;&#30340;&#25351;&#38024;&#65292;&#35753;resource_ptr&#25351;&#21521;&#35813;&#20869;&#23384;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32534;&#35793;&#22120;&#19981;&#19968;&#23450;&#25353;23&#39034;&#24207;&#25191;&#34892;&#65292;&#21487;&#33021;32</span>
            resource_ptr.reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">some_resource</span>); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 3</span>
        }
    }
    resource_ptr-&gt;do_something(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mark 4</span>
}
</pre>
</div>
<p>
这个方案也存在潜在的 race condition，第一次的检查没上锁，可能与其他线程中被保护的 reset 操作产生竞争。如果当前线程看见其他线程写入了指针，但没看到新创建的对象实例，调用 do_something 就会出错。这个例子就是 c++中定义的 data race 问题。<br />
</p>
</div>
</div>
<div id="outline-container-org1e82069" class="outline-6">
<h6 id="org1e82069">std::call_once std::once_flag 方案</h6>
<div class="outline-text-6" id="text-org1e82069">
<p>
std::once_flag 中存储了同步数据。使用 std::call_once std::once_flag 要比上面第一个最简单方案性能要好很多。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;some_resource&gt; <span style="color: #7590db;">resource_ptr</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">once_flag</span> <span style="color: #7590db;">resource_flag</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">init_resource</span>()
{
    resource_ptr.reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">some_resource</span>);
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>() {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span>
    <span style="color: #a45bad;">std</span>::call_once(resource_flag,init_resource);
    resource_ptr-&gt;do_something();
}
</pre>
</div>
<p>
下面是使用 std::call_once std::once_flag 实现类成员的 lazy initialization<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">connection_info</span> <span style="color: #7590db;">connection_details</span>;
    <span style="color: #ce537a; font-weight: bold;">connection_handle</span> <span style="color: #7590db;">connection</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">once_flag</span> <span style="color: #7590db;">connection_init_flag</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">open_connection</span>()
    {
        connection=connection_manager.open(connection_details);
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">X</span>(<span style="color: #ce537a; font-weight: bold;">connection_info</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">connection_details_</span>): <span style="color: #bc6ec5; font-weight: bold;">connection_details</span>(connection_details_) {}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">send_data</span>(<span style="color: #ce537a; font-weight: bold;">data_packet</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
    {
        <span style="color: #a45bad;">std</span>::call_once(connection_init_flag,&amp;<span style="color: #a45bad;">X</span>::open_connection,<span style="color: #4f97d7; font-weight: bold;">this</span>);
        connection.send_data(data);
    }
    <span style="color: #ce537a; font-weight: bold;">data_packet</span> <span style="color: #bc6ec5; font-weight: bold;">receive_data</span>()
    {
        <span style="color: #a45bad;">std</span>::call_once(connection_init_flag,&amp;<span style="color: #a45bad;">X</span>::open_connection,<span style="color: #4f97d7; font-weight: bold;">this</span>);
        <span style="color: #4f97d7; font-weight: bold;">return</span> connection.receive_data();
    }
};
</pre>
</div>

<p>
TIPS： std::once_flag 和 std::mutex 类似，他们的实例都不可以被 copy 和 move。因此，当你使用这些实例作为成员变量，并且你还需要 copy 构造函数或移动构造函数等时，你需要自己显示实现这些成员函数，编译器不会生成。<br />
</p>
</div>
</div>
<div id="outline-container-org111a314" class="outline-6">
<h6 id="org111a314">static 方案</h6>
<div class="outline-text-6" id="text-org111a314">
<p>
当一个局部变量被声明为 static 时，第一次执行到定义该变量的时候，对该变量执行初始化。当多个线程调用该函数时，可能会对该变量初始化多次，每个线程可能都会认为自己是第一次执行到定义该变量的线程，或者一个线程开始初始化该变量但还没初始化完成，而另一个线程已经在使用该对象。c++11 之前的很多编译器都会有该问题，c++11 之后规定 static 变量的初始化只完全发生在一个线程内，直到初始化完成前其他线程都不会做处理，从而避免了 race condition。只有一个全局实例时可以不使用 std::call_once 而直接用 static。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">my_class</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22810;&#20010;&#32447;&#31243;&#21487;&#20197;&#35843;&#29992; get_my_class_instance() &#65292;&#32780;&#19981;&#29992;&#25285;&#24515; instance&#21021;&#22987;&#21270;&#26102;&#26377;race condition&#38382;&#39064;&#12290;</span>
<span style="color: #ce537a; font-weight: bold;">my_class</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">get_my_class_instance</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">my_class</span> <span style="color: #7590db;">instance</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> instance;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae5765d" class="outline-5">
<h5 id="orgae5765d">Protecting rarely updated data structures</h5>
<div class="outline-text-5" id="text-orgae5765d">
<p>
DNS 表就属于很少需要更新的数据结构。DNS 表中存储了很多条数据项，每条数据项存储一条域名和其对应的 IP 地址。尽管，当用户访问新的不同的网站时，会增加新的数据项目，通常一条数据项会保持一段时间都不变。系统会定期检查每条数据项的有效性，只有域名对应的 IP 地址变更或者域名不可用时，才需要对数据项进行更新。尽管更新很少发生，但是当多个线程访问 DNS 表时，依然需要在更新数据期间对 DNS 表进行适当保护，避免其他线程看到破坏了的数据（更新只完成一部分，没有完全完成）。<br />
使用 std::mutex 来保护 DNS 表，有些过度悲观了，这使得多个线程对 DNS 表的读取操作也无法并行执行。此处，我们需要一种通常被称为 reader-writer mutex 的互斥量，其允许单个写者互斥访问，多个读者同步访问。<br />
</p>

<p>
C++11 中没有提供这样的互斥量。C++14 中提供了 std::shared_timed_mutex。C++17 中提供了 std::shared_mutex。std::shared_timed_mutex 比 std::shared_mutex 提供了额外的操作，当不需要该额外操作时，某些平台上 std::shared_mutex 的效率会更高。<br />
</p>

<p>
对于更新操作，使用 std::lock_guard &lt;std::shared_mutex&gt; 和 std::unique_lock&lt;std::shared_mutex&gt; 来进行保护，保证互斥访问。对于读取操作，使用 std::shared_lock&lt;std::shared_mutex&gt;来进行保护，保证共享访问。std::shared_lock&lt;std::shared_mutex&gt; 是 C++14 中加入的。<br />
</p>

<p>
当任何一个线程对 reader-writer 互斥量上了共享锁，请求对该 reader-writer 互斥量上互斥锁的线程会一直被阻塞，直到所有拥有共享锁的线程释放了共享锁。当任何一个线程对 reader-writer 互斥量上了互斥锁，请求对该 reader-writer 互斥量上共享锁或互斥锁的其他线程会一直被阻塞，直到拥有互斥锁的线程释放了互斥锁。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;map&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;string&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;shared_mutex&gt;</span>
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">dns_entry</span>;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">dns_cache</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">map</span>&lt;<span style="color: #a45bad;">std</span>::string,<span style="color: #ce537a; font-weight: bold;">dns_entry</span>&gt; <span style="color: #7590db;">entries</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">reader-writer &#20114;&#26021;&#37327;</span>
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span> <span style="color: #7590db;">entry_mutex</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">dns_entry</span> <span style="color: #bc6ec5; font-weight: bold;">find_entry</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">domain</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#20849;&#20139;&#38145;&#65292;&#22810;&#20010;&#32447;&#31243;&#21487;&#20197;&#24182;&#34892;&#25191;&#34892;find_entry&#65292;&#20294;&#20250;&#38459;&#22622;&#35843;&#29992;update_or_add_entry&#30340;&#32447;&#31243;</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span>&gt; <span style="color: #7590db;">lk</span>(entry_mutex);
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">map</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>,<span style="color: #ce537a; font-weight: bold;">dns_entry</span>&gt;::<span style="color: #ce537a; font-weight: bold;">const_iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">it</span>= entries.find(domain);
        <span style="color: #4f97d7; font-weight: bold;">return</span> (it==entries.end())?dns_entry():it-&gt;second;
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update_or_add_entry</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">domain</span>, <span style="color: #ce537a; font-weight: bold;">dns_entry</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">dns_details</span>)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33719;&#21462;&#20114;&#26021;&#38145;&#65292;&#21482;&#26377;&#19968;&#20010;&#32447;&#31243;&#21487;&#20197;&#25191;&#34892; update_or_add_entry&#12290;&#20250;&#38459;&#22622;&#20854;&#20182;&#35843;&#29992; update_or_add_entry &#25110; find_entry &#30340;&#32447;&#31243;</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span>&gt; <span style="color: #7590db;">lk</span>(entry_mutex);
        entries[domain]=dns_details;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdc2e24a" class="outline-5">
<h5 id="orgdc2e24a">Recursive locking</h5>
<div class="outline-text-5" id="text-orgdc2e24a">
<p>
当已经对一个 std::mutex 上锁后，再对该互斥量上锁会导致未定义行为。C++标准库提供了 std::recursive_mutex 互斥量，可以对其多次上锁，但是 lock 次数必须和 unlock 次数相匹配。正确使用 std::lock_guard&lt;std::recursive_mutex&gt; 和 std::unique_lock&lt;std::recursive_mutex&gt; 就可以保证 lock 和 unlock 次数的匹配。<br />
</p>

<p>
大多数情况下，当你想使用 std::recursive_mutex 时，你可能真正需要的是换一种设计。下面这种情况可以使用 std::recursive_mutex ：一个类被设计为可以有多个线程并发访问，该类有一个互斥量用于保护数据成员，每个成员函数都会先对互斥量上锁，然后执行操作，之后再对互斥量解锁，当一个成员函数需要调用另一个成员函数时，那么就需要对一个互斥量多次上锁了。但是，通常不推荐这种使用方式，这种方式会导致不好的设计。当上锁后，类的不变性通常会被破坏，这意味着第二个成员函数是在不变性被破坏之后的基础上工作的。更好的方式是，从第二个成员函数分离出来一个 private 的成员函数，让上锁的这两个成员函数分别调用这个私有的成员函数。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga726318" class="outline-3">
<h3 id="orga726318">04 synchronizing concurrent operations on atomic types</h3>
<div class="outline-text-3" id="text-orga726318">
<p>
有时候不止需要保护多个线程之间共享数据，还需要同步多个线程的不同行为。一个线程等待特定事件发生或某个条件为真的情况很常见。尽管可以定期去检查事件是否发生或条件是否为真，但是这种实现性能太差了。C++标准库提供了 condition variables 和 futures , C++ Technical Specification 中提供了对 condition variables 和 futures 的扩展，还提供了 latches 和 barriers，这些都是用于处理多线程行为同步的工具。<br />
</p>
</div>

<div id="outline-container-org58ab91b" class="outline-4">
<h4 id="org58ab91b">Waiting for an event or other condition</h4>
<div class="outline-text-4" id="text-org58ab91b">
<p>
假设你正在乘坐夜间火车进行旅行。为了保证你可以在正确站台下车，有如下几个方案：<br />
方案 1：一晚上不睡觉，并注意每次停车是在哪个站台。一晚无法睡觉，会很累。<br />
方案 2：查看列车到站时刻表，定一个在到站时刻之前的闹钟。如果列车延迟，则你会提早醒来。如果闹钟电池不足，则你可能会坐过站。<br />
方案 3：最理想的方式是，列车到达你下车的站台后，有人可以通知你下车。<br />
</p>

<p>
对于线程也一样，如果一个线程 A 在等待另一个线程 B 完成一个任务。为了保证线程 B 完成任务后，线程 A 可以马上执行，有如下几个方案：<br />
方案 1：线程 A 不停去检查一个共享变量标记(使用 mutex 保护该共享变量)，线程 B 完成任务后会写入该共享变量标记。线程 A 浪费了珍贵的执行时间去检查标记；线程 A 对共享变量上锁，导致其他线程阻塞。<br />
方案 2：线程 A 在每次检查之间使用 sleep_for，让自己 sleep 一段时间。该方案一定程度上改善了执行时间的浪费，但是 sleep 的时间很难是恰到好处的。sleep 时间过短，会导致执行时间浪费；sleep 时间过长，会导致线程 A 无法及时处理后续工作。<br />
方案 3：使用 c++标准库提供的 condition variable 来实现。概念上讲，一个条件变量和一个事件或其他条件相关联，一个线程或多个线程可以等待该条件被满足，此时，其可以通知一个或多个等待该条件的线程，将他们唤醒从而让他们继续执行。<br />
</p>
</div>

<div id="outline-container-org3cc4ad0" class="outline-5">
<h5 id="org3cc4ad0">Waiting for a condition with condition variables</h5>
<div class="outline-text-5" id="text-org3cc4ad0">
<p>
C++标准库提供了两种条件变量：std::condition_variable 和 std::condition_variable_any。他们都需要和互斥量配合来实现适当的同步，std::condition_variable 只能和 std::mutex 一起使用；std::condition_variable_any 可以和任意满足最小条件的类 mutex 一起工作。std::condition_variable_any 在内存占用、性能以及 OS 资源消耗上都比 std::condition_variable 要多。因此，应该优先使用 std::condition_variable，除非需要 std::condition_variable_any 提供的额外灵活性。<br />
</p>

<p>
下面实例使用 std::condition_variable 和 std::mutex 配合实现了 data_preparation_thread 和 data_processing_thread 两个线程的同步：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">mut</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;data_chunk&gt; <span style="color: #7590db;">data_queue</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">data_cond</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">data_preparation_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(more_data_to_prepare())
    {
        <span style="color: #ce537a; font-weight: bold;">data_chunk</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">data</span>=prepare_data();
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20114;&#26021;&#37327;&#36827;&#34892;&#19978;&#38145;</span>
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
            data_queue.push(data);
        }
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;condition_variable&#30340;notify_one&#20989;&#25968;&#36890;&#30693;&#31561;&#24453;&#32447;&#31243;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#35299;&#38145;&#21518;&#20877;&#35843;&#29992;notify_one&#65292;&#36991;&#20813;&#31561;&#24453;&#32447;&#31243;&#31435;&#21363;wake&#21518;&#65292;&#30001;&#20110;&#20114;&#26021;&#37327;&#26410;&#34987;&#35299;&#38145;&#32780;&#21448;&#34987;&#38459;&#22622;&#12290;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35299;&#38145;&#19968;&#20010;&#31561;&#24453;&#35813;&#26465;&#20214;&#21464;&#37327;&#30340;&#32447;&#31243;&#12290;&#22914;&#26524;&#19981;&#23384;&#22312;&#31561;&#24453;&#32447;&#31243;&#65292;&#21017;&#20160;&#20040;&#20063;&#19981;&#21457;&#29983;&#65307;&#22914;&#26524;&#23384;&#22312;&#22810;&#20010;&#31561;&#24453;&#32447;&#31243;&#65292;&#21017;&#26080;&#27861;&#30830;&#23450;&#21796;&#37266;&#21738;&#20010;&#31561;&#24453;&#32447;&#31243;</span>
        data_cond.notify_one();
    }
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">data_processing_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23545;&#20114;&#26021;&#37327;&#36827;&#34892;&#19978;&#38145;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: &#27492;&#22788;&#20351;&#29992;&#30340;&#26159; std::unique_lock&lt;std::mutex&gt;&#65292;&#19981;&#33021;&#20351;&#29992; std::lock_guard&lt;std::mutex&gt;(&#35813;&#20989;&#25968;&#27809;&#26377;&#25552;&#20379;unlock&#20989;&#25968;)</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#19968;&#20010;&#21442;&#25968;&#65306;std::unique_lock&lt;std::mutex&gt;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#20108;&#20010;&#21442;&#25968;&#65306;lambda &#20989;&#25968;&#29992;&#20110;&#34920;&#31034;&#31561;&#24453;&#30340;&#26465;&#20214;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wait &#20989;&#25968;&#30340;&#23454;&#29616;&#65306;&#20808;&#35843;&#29992;lambda&#20989;&#25968;&#26816;&#26597;&#26465;&#20214;&#26159;&#21542;&#28385;&#36275;&#65292;&#22914;&#26524;&#28385;&#36275;&#65292;&#21017;&#36820;&#22238;&#65307;&#22914;&#26524;&#19981;&#28385;&#36275;&#65292;&#21017;&#35843;&#29992; lk.unlock &#37322;&#25918;&#38145;&#65292;&#24182;&#19988;&#23558;&#32447;&#31243;&#29366;&#24577;&#36716;&#25442;&#20026;&#38459;&#22622;&#25110;&#31561;&#24453;&#29366;&#24577;&#12290;&#24403; data_preparation_thread &#32447;&#31243;&#35843;&#29992;&#26465;&#20214;&#21464;&#37327; data_cond &#30340; notify_one &#20989;&#25968;&#26102;&#65292;data_processing_thread &#20174;&#30561;&#30496;&#29366;&#24577;&#37266;&#26469;&#65292;&#35843;&#29992; lk.lock &#19978;&#38145;&#65292;&#28982;&#21518;&#20877;&#27425;&#35843;&#29992; lambda &#20989;&#25968;&#26816;&#26597;&#26465;&#20214;&#26159;&#21542;&#28385;&#36275;&#12290;</span>
        data_cond.wait(lk,[]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        <span style="color: #ce537a; font-weight: bold;">data_chunk</span> <span style="color: #7590db;">data</span>=data_queue.front();
        data_queue.pop();
        
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#21069;&#38754; wait &#27809;&#26377;&#38459;&#22622;&#36807;&#26102;&#65292;&#27492;&#22788; unlock &#23545;&#24212;&#19982;&#24320;&#22987;&#30340; lock</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#21069;&#38754; wait &#38459;&#22622;&#36807;&#26102;&#65292;&#27492;&#22788;&#30340; unlock &#23545;&#20110;&#19982; wait &#20013;&#30340; lock</span>
        lk.unlock();
        process(data);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(is_last_chunk(data))
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
}
</pre>
</div>

<p>
不是直接响应另一个线程的通知而执行上锁和检查(等待线程重新获取互斥量并检查条件变量)的情况，被称为 spurious wake（伪唤醒）。伪唤醒的数量和频率都是不确定的，所以不建议使用有副作用的函数做条件检查（如果条件检查很耗时，对性能影响会很大）。<br />
</p>

<p>
本质上来说 std::condition_variable::wait 是对忙等的优化。下面代码是使用忙等实现的 wait，你的代码既应该能适用于 minimal_wait ，也应该能适用于杜绝了伪唤醒的 wait。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Predicate</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">minimal_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt;&amp; <span style="color: #7590db;">lk</span>,<span style="color: #ce537a; font-weight: bold;">Predicate</span> <span style="color: #7590db;">pred</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>pred())
    {
        lk.unlock();
        lk.lock();
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf1d470a" class="outline-5">
<h5 id="orgf1d470a">Building a thread-safe queue with condition variables</h5>
<div class="outline-text-5" id="text-orgf1d470a">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;queue&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;memory&gt;</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#20351;&#29992;std::shared_ptr</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;condition_variable&gt;</span>

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">mut</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">bool empty() const&#25104;&#21592;&#20989;&#25968;&#20013;&#20351;&#29992;&#20102;&#35813;&#21464;&#37327;&#65292;&#22240;&#27492;&#38656;&#35201;&#20351;&#29992;mutable&#20462;&#39280;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data_queue</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">data_cond</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>() {}
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>(<span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">other</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(other.mut);
        data_queue=other.data_queue;
    }
    <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp;) = <span style="color: #4f97d7; font-weight: bold;">delete</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#31616;&#21333;&#36215;&#35265;&#65292;&#19981;&#20801;&#35768;&#36171;&#20540;&#25805;&#20316;&#31526;</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
            data_queue.push(new_value);
        }
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#30693;&#31561;&#24453;&#32447;&#31243; &#38431;&#21015;&#20013;&#26377;&#25968;&#25454;&#20102;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">notify_one &#26080;&#27861;&#20445;&#35777;&#20250;&#36890;&#30693;&#21738;&#20010;&#31561;&#24453;&#32447;&#31243;</span>
        data_cond.notify_one();
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        value=data_queue.front();
        data_queue.pop();
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_queue.front()));
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty())
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        value=data_queue.front();
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty())
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_queue.front()));
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data_queue.empty();
    }
};

<span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&lt;data_chunk&gt; <span style="color: #7590db;">data_queue</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">data_preparation_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(more_data_to_prepare())
    {
        <span style="color: #ce537a; font-weight: bold;">data_chunk</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">data</span>=prepare_data();
        data_queue.push(data);
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">data_processing_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">data_chunk</span> <span style="color: #7590db;">data</span>;
        data_queue.wait_and_pop(data);
        process(data);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(is_last_chunk(data))
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd5650f1" class="outline-4">
<h4 id="orgd5650f1">Waiting for one-off events with futures</h4>
<div class="outline-text-4" id="text-orgd5650f1">
<p>
假设你要乘飞机去国外度假，当到达机场办理完各种登机手续后，还需要等待机场广播通知登机。这段时间内，你可能会在候机室里面找一些事情来打发时间，比如：读书，上网，或者来一杯咖啡。但本质上讲，你只是在等待一件事情：机场广播通知登机。另外，指定的航班只会出发一次，下次你再乘飞机去度假时，乘坐的可能就是其他航班了。<br />
</p>

<p>
C++标准库使用 future 来表示这种一次性事件。当线程需要等待特定事件时，其会以某种方式获得代表该事件的 future。之后，线程可以周期性地(以很短的周期)在 future 上进行等待，来检查事件是否触发(检查信息板)，检查期间也会执行其他任务(品尝机场昂贵的咖啡)。或者，线程可以先执行其他任务，直到该任务需要此事件发生时，再等待此事件对应的 future 的状态会变为就绪状态。future 可能是和数据相关(比如，登机口编号)，也可能不是。一旦事件发生后(future 状态变为就绪)，这个 future 将不能被重置。<br />
</p>

<p>
C++标准库提供了两类 future：unique futures (std::future&lt;&gt;) 和 shared futures (std::shared_future&lt;&gt;)。这两个类和 std::unique_ptr&lt;&gt;、std::shared_ptr&lt;&gt;这两个类很类似。对于指定事件，只能有一个 std::future&lt;&gt; 实例与该事件关联；但是，可以有多个 std::shared_future&lt;&gt;实例关联同一个事件，当事件发生后，其对应的多个 std::shared_future&lt;&gt;实例会同时变为 ready 状态。<br />
</p>

<p>
std::future&lt;T&gt;和 std::shared_future&lt;T&gt;的模版参数类型为他们所关联的数据的类型。std::future&lt;void&gt;和 std::shared_future&lt;void&gt;表示 future 不关联任何数据。尽管，future 对象可用于不同线程之间交流信息，但是，future 对象本身并没有提供同步访问保护，需要使用 mutex 或其他同步机制来保护多个线程对同一个 future 对象的访问。但是，每个线程可以拥有自己的 std::shared_future&lt;&gt;实例，这样就不需要同步机制保护了。<br />
</p>

<p>
Concurrency Technical Specification 提供了 std::future&lt;T&gt;和 std::shared_future&lt;T&gt; 的扩展版本 std::experimental::future&lt;&gt; 和 std::experimental::shared_future&lt;&gt;。它们的行为与 std 命名空间中的对应项相同，但它们具有额外的成员函数以提供额外的功能。重要的是要注意 std::experimental 名称并不意味着代码质量有任何问题（我希望实现将与您的库供应商提供的其他所有东西的质量相同）。强调这些是非标准的类和函数，因为，它们可能和最终未来被 C++ 标准采用的版本，在语法和语义上有差别。包含头文件 &lt;experimental/future&gt; 就可以使用这两个类了。<br />
</p>
</div>
<div id="outline-container-orgb7f02fb" class="outline-5">
<h5 id="orgb7f02fb">Returning values from background tasks</h5>
<div class="outline-text-5" id="text-orgb7f02fb">
<p>
假设你有一个耗时的计算，其最终会返回一个有用的结果，你当前还不需要这个结果值。你可以开启一个线程来执行计算，但是，其没有提供直接返回结果的机制。std::async 实现了该功能。你可以使用 std::async 开启一个异步任务，其会返回一个 std::future 对象，该 std::future 对象最终会持有异步任务计算的结果。当你需要计算结果的时候，可以在该 std::future 对象上执行 get() 方法，这会导致当前线程阻塞，直到 std::future 对象变为 ready 状态，然后返回结果值。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;future&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">find_the_answer_to_ltuae</span>();
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_other_stuff</span>();
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">the_answer</span>=<span style="color: #a45bad;">std</span>::async(find_the_answer_to_ltuae);
    do_other_stuff();
    <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">"The answer is "</span>&lt;&lt;the_answer.get()&lt;&lt;<span style="color: #a45bad;">std</span>::endl;
}
</pre>
</div>

<p>
std::async 和 std::thread 一样，也允许传递额外的参数，如果参数为 rvalue，会使用移动构造函数。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;string&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;future&gt;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>(<span style="color: #ce537a; font-weight: bold;">int</span>,<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;);
};
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x</span>;
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f1</span>=<span style="color: #a45bad;">std</span>::async(&amp;<span style="color: #a45bad;">X</span>::foo,&amp;x,42,<span style="color: #2d9574;">"hello"</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;p-&gt;foo(42, "hello")&#65292;p&#26159;&#25351;&#21521;x&#30340;&#25351;&#38024;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f2</span>=<span style="color: #a45bad;">std</span>::async(&amp;<span style="color: #a45bad;">X</span>::bar,x,<span style="color: #2d9574;">"goodbye"</span>);    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;tmpx.bar("goodbye")&#65292; tmpx&#26159;x&#30340;&#25335;&#36125;&#21103;&#26412;</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Y</span>
{
    <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">double</span>);
};
<span style="color: #ce537a; font-weight: bold;">Y</span> <span style="color: #7590db;">y</span>;
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f3</span>=<span style="color: #a45bad;">std</span>::async(Y(),3.141);          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;tmpy(3.141)&#65292;tmpy&#36890;&#36807;Y&#30340;&#31227;&#21160;&#26500;&#36896;&#20989;&#25968;&#24471;&#21040;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f4</span>=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::ref(y),2.718);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;y(2.718)</span>
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">baz</span>(<span style="color: #ce537a; font-weight: bold;">X</span>&amp;);
<span style="color: #a45bad;">std</span>::async(baz,<span style="color: #a45bad;">std</span>::ref(x));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;baz(x)</span>
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">move_only</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">move_only</span>();
    <span style="color: #bc6ec5; font-weight: bold;">move_only</span>(<span style="color: #ce537a; font-weight: bold;">move_only</span>&amp;&amp;)
    <span style="color: #bc6ec5; font-weight: bold;">move_only</span>(<span style="color: #ce537a; font-weight: bold;">move_only</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;) = <span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">move_only</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">move_only</span>&amp;&amp;);
    <span style="color: #ce537a; font-weight: bold;">move_only</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">move_only</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;) = <span style="color: #4f97d7; font-weight: bold;">delete</span>;
  
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>();
};
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f5</span>=<span style="color: #a45bad;">std</span>::async(move_only());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;tmp()&#65292;tmp&#26159;&#36890;&#36807;std::move(move_only())&#26500;&#36896;&#24471;&#21040;</span>
</pre>
</div>

<p>
默认情况下，std::async 是否会开启一个新的线程，future 所等待的任务是否是异步执行，取决于实现。你可以通过为 std::async 指定额外的参数来控制。参数的类型为 std::launch。参数 std::launch::deferred 表示延迟调用，其指定在 future 对象上执行 get 或 wait 时才调用任务。std::launch::async 表示异步调用，其指定任务必须是异步执行的。std::launch::deferred | std::launch::async 参数表示异步延迟调用，该参数是默认参数。<br />
</p>

<p>
Tips:<br />
</p>
<ol class="org-ol">
<li>延迟调用的函数，可能永远都不会被调用（因为，没有执行 future 的 wait 或 get 方法）。<br /></li>
<li>c++标准指出，std::launch::deferred | std::launch::async 参数表示自动策略模式。具体实现取决于系统和 libray。通常实现会考虑系统的并行能力来进行优化。<br /></li>

<li><a href="https://www.cplusplus.com/reference/future/async/">https://www.cplusplus.com/reference/future/async/</a><br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f6</span>=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async, Y(), 1.2);             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#26032;&#32447;&#31243;&#19978;&#25191;&#34892;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f7</span>=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::deferred, baz, <span style="color: #a45bad;">std</span>::ref(x));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;wait()&#25110;get()&#35843;&#29992;&#26102;&#25191;&#34892;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f8</span>=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::deferred | <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async, baz, <span style="color: #a45bad;">std</span>::ref(x));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24322;&#27493;&#12289;&#24310;&#36831;&#35843;&#29992;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">f9</span>=<span style="color: #a45bad;">std</span>::async(baz, <span style="color: #a45bad;">std</span>::ref(x));
f7.wait();  <span style="color: #2aa1ae; background-color: #292e34;">//  </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#24310;&#36831;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org39aaff9" class="outline-5">
<h5 id="org39aaff9">Associating a task with a future</h5>
<div class="outline-text-5" id="text-org39aaff9">
<p>
std::packaged_task&lt;&gt; 可以将 std::future 和一个函数或可调用对象绑在一起。当 std::packaged_task&lt;&gt;被调用调用后，其会调用关联的函数或可调用对象，并将 std::future 的状态变为 ready，返回值被存储为 future 所关联的数据。这可用于实现线程池 (thread pool) 或其他的任务管理机制。如果一个大任务可以被分解为多个子任务，可以将每个子任务封装为一个 std::packaged_task&lt;&gt; 实例，然后将实例传递给任务调度器或线程池。这样的抽象，使得调度器只需要处理 std::packaged_task&lt;&gt; 实例，而不是各个独立的函数，也就不用关心任务的具体细节了。<br />
std::packaged_task&lt;&gt;的目标参数是函数签名。例如：void()表示不需要参数，没有返回值的函数。int(std::string&amp;,double*)表示需要 string 和 double*参数，返回值为 int 的函数。传递给 std::packaged_task&lt;&gt;的函数的参数必须和 std::packaged_task&lt;&gt;的模板参数匹配，函数返回值只要可以转化为对应模板参数函数签名的返回值即可。模板参数函数签名的返回值对应了 std::future 所关联的数据类型。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;<span style="color: #a45bad;">std</span>::string(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">char</span>&gt;*,<span style="color: #ce537a; font-weight: bold;">int</span>)&gt;
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Callable</span>&gt;
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">packaged_task</span>(<span style="color: #ce537a; font-weight: bold;">Callable</span>&amp;&amp; <span style="color: #7590db;">f</span>);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::string&gt; <span style="color: #bc6ec5; font-weight: bold;">get_future</span>();
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">char</span>&gt;*,<span style="color: #ce537a; font-weight: bold;">int</span>);
};
</pre>
</div>
</div>
<div id="outline-container-org5f9c2ce" class="outline-6">
<h6 id="org5f9c2ce">Passing Task between thread</h6>
<div class="outline-text-6" id="text-org5f9c2ce">
<p>
很多 GUI frameworks 要求对 GUI 的更新必须在指定线程上执行，当其他线程需要更新 GUI 时，其必须发送消息给指定线程。std::packaged_task&lt;&gt; 提供了一种方式可以实现该需求，而不需要自定义消息。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;deque&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;future&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;utility&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">deque</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt; &gt; <span style="color: #7590db;">tasks</span>;

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">gui_shutdown_message_received</span>();
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">get_and_process_gui_message</span>();

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">gui_thread</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>gui_shutdown_message_received())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {
        get_and_process_gui_message();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt; <span style="color: #7590db;">task</span>;
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(m);
            <span style="color: #4f97d7; font-weight: bold;">if</span>(tasks.empty())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                <span style="color: #4f97d7; font-weight: bold;">continue</span>;
            task=<span style="color: #a45bad;">std</span>::move(tasks.front());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            tasks.pop_front();
        }
        task();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
}

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #bc6ec5; font-weight: bold;">gui_bg_thread</span>(gui_thread);

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Func</span>&gt;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">post_task_for_gui_thread</span>(<span style="color: #ce537a; font-weight: bold;">Func</span> <span style="color: #7590db;">f</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt; <span style="color: #7590db;">task</span>(f);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">res</span>=task.get_future();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(m);
    tasks.push_back(<span style="color: #a45bad;">std</span>::move(task));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> res; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdaa7557" class="outline-5">
<h5 id="orgdaa7557">Making (std::)promises</h5>
<div class="outline-text-5" id="text-orgdaa7557">
<p>
当应用程序需要处理很多网络连接时，为每个连接分配一个线程，这样使得网络交互更容易理解，也容易代码编写。不幸的是，随着连接数量的增长，这种方式变的不再适用。因为大量的线程会消耗大量的系统资源，还有可能造成线程上下文频繁切换(当线程数量超出硬件可接受的并发数时)，这都会对性能有影响。极端情况下，操作系统可能会在其网络连接容量耗尽之前耗尽用于运行新线程的资源。因此只使用少数线程处理网络连接，每个线程同时处理多个连接，对需要处理大量网络连接的应用而言，这是一种比较普遍的做法。<br />
</p>

<p>
std::promise&lt;T&gt; 提供了一种方式可以设置一个 T 类型的值，随后可以通过关联的 std::future&lt;T&gt;读取该值。一对 std::promise&lt;T&gt;和 std::future&lt;T&gt; 可以提供一种机制实现如下功能：等待线程可以阻塞在 future 上，提供数据的线程可以使用 promise 来设置关联的数据，使得 future 的状态变为 ready。你可以通过调用 std::promise&lt;T&gt;的成员函数 get_future 来获得其关联的 future。当使用 std::promise&lt;T&gt;的成员函数 set_value()设置 std::promise 的值后，std::future&lt;T&gt;的状态变为 ready，此时就可以通过 future 获得存储的值。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;future&gt;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_connections</span>(<span style="color: #ce537a; font-weight: bold;">connection_set</span>&amp; <span style="color: #7590db;">connections</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done(connections))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">connection_iterator</span> <span style="color: #7590db;">connection</span>=connections.begin(),<span style="color: #7590db;">end</span>=connections.end(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 </span>
            connection!=end;
            ++connection)
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span>(connection-&gt;has_incoming_data())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#26159;&#21542;&#25910;&#21040;&#25968;&#25454;</span>
            {
                <span style="color: #ce537a; font-weight: bold;">data_packet</span> <span style="color: #7590db;">data</span>=connection-&gt;incoming();
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#20551;&#35774;&#25910;&#21040;&#30340;&#25968;&#25454;&#21253;&#21547;&#19968;&#20010;id&#21644;&#19968;&#20010;payload&#25968;&#25454; &#27599;&#20010;id&#37117;&#23545;&#24212;&#19968;&#20010;promise&#23545;&#35937;</span>
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;payload_type&gt;&amp; <span style="color: #7590db;">p</span> = connection-&gt;get_promise(data.id);
                p.set_value(data.payload); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;payload&#25968;&#25454;&#35774;&#32622;&#20026; promise &#30340;&#20540;</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">if</span>(connection-&gt;has_outgoing_data())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#26159;&#21542;&#21457;&#36865;&#25968;&#25454;</span>
            {
                <span style="color: #ce537a; font-weight: bold;">outgoing_packet</span> <span style="color: #7590db;">data</span> = connection-&gt;top_of_outgoing_queue();
                connection-&gt;send(data.payload);
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21457;&#36865;&#25968;&#25454;&#23436;&#25104;&#21518;&#65292;&#35774;&#32622; promise &#30340;&#20540;&#20026;ture</span>
                data.promise.set_value(<span style="color: #a45bad;">true</span>);
            }
        }
    }
}
</pre>
</div>

<p>
Tips: 上面的代码没有处理异常情况。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;vector&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;future&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;numeric&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;chrono&gt;</span>

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">accumulate</span>(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt;::<span style="color: #ce537a; font-weight: bold;">iterator</span> <span style="color: #7590db;">first</span>,
                <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt;::<span style="color: #ce537a; font-weight: bold;">iterator</span> <span style="color: #7590db;">last</span>,
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">accumulate_promise</span>)
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">sum</span> = <span style="color: #a45bad;">std</span>::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Notify future</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_work</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">barrier</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::sleep_for(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::seconds(1));
    barrier.set_value();
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">numbers</span> = { 1, 2, 3, 4, 5, 6 };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">accumulate_promise</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">accumulate_future</span> = accumulate_promise.get_future();
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">work_thread</span>(accumulate, numbers.begin(), numbers.end(),
                            <span style="color: #a45bad;">std</span>::move(accumulate_promise));

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">future::get() will wait until the future has a valid result and retrieves it.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Calling wait() before get() is not needed</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">accumulate_future.wait();  // wait for result</span>
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"result="</span> &lt;&lt; accumulate_future.get() &lt;&lt; <span style="color: #2d9574;">'\n'</span>;
    work_thread.join();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wait for thread completion</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Demonstrate using promise&lt;void&gt; to signal state between threads.</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">barrier</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">barrier_future</span> = barrier.get_future();
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">new_work_thread</span>(do_work, <span style="color: #a45bad;">std</span>::move(barrier));
    barrier_future.wait();
    new_work_thread.join();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org5423a38" class="outline-5">
<h5 id="org5423a38">Saving an exception for the future</h5>
<div class="outline-text-5" id="text-org5423a38">
<p>
如果函数作为 std::async 的一部分被调用时，抛出了异常，异常会被保存到关联的 std::future 中，并且 future 状态会变为 ready，当调用 future 的 get()成员函数时，会再次抛出存储的异常（注意：标准没有指明，再次抛出的异常为原始异常对象还是原始异常对象的克隆体，不同编译器或库可能会有不同选择）。类似地，如果使用 std::packaged_take&lt;&gt;封装一个函数，调用任务时，如果抛出异常，异常也会被保存到关联的 std::future 中。std::promise 也提供了类似的机制。如果你希望保存一个异常而不是值，你可以调用 std::promise 的 set_exception() 成员函数<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">double</span>&gt; <span style="color: #7590db;">some_promise</span>;
<span style="color: #4f97d7; font-weight: bold;">try</span>
{
    some_promise.set_value(calculate_value());
}
<span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#20351;&#29992;&#20102;std::current_exception() &#26469;&#33719;&#24471;&#24403;&#21069;&#25243;&#20986;&#30340;&#24322;&#24120;</span>
    some_promise.set_exception(<span style="color: #a45bad;">std</span>::current_exception());
}
</pre>
</div>
<p>
如果异常是可知的，则应该使用 std::make_exception_ptr(&#x2026;)，这样可以允许编译器有更多机会来优化代码。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">double</span>&gt; <span style="color: #7590db;">some_promise</span>;

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">result</span> = process_data();
<span style="color: #4f97d7; font-weight: bold;">if</span> (result)
{
    some_promise.set_value(<span style="color: #a45bad;">true</span>);
}
<span style="color: #4f97d7; font-weight: bold;">else</span>
{
    some_promise.set_exception(<span style="color: #a45bad;">std</span>::make_exception_ptr(<span style="color: #a45bad;">std</span>::logic_error(<span style="color: #2d9574;">"process data error"</span>)));
}
</pre>
</div>

<p>
另一种存储异常到 future 对象的方法是，在调用 std::promise 的 set_value 方法之前或者在调用 std::packaged_task 封装的任务之前销毁 std::promise 或 std::packaged_task 对象。此时 std::promise 或 std::packaged_task 的析构函数会将 std::future_error 异常存入 future，该异常会携带一个 std::future_errc::broken_promise 的错误码。如果编译器没有写入任何异常，等待线程会一直等待。<br />
</p>
</div>
</div>
<div id="outline-container-org61202e0" class="outline-5">
<h5 id="org61202e0">Waiting from multiple threads</h5>
<div class="outline-text-5" id="text-org61202e0">
<p>
尽管从一个线程传递数据到另一个线程时，必须使用 future，但是，future 对象本身并不是多线程安全的，多个线程访问同一个 future 实例的成员函数会导致 data race。设计上 future 对象就是不可以由多个线程访问的，future 的 get 成员函数只能调用一次，只有一个线程可以调用 future 对象的 get 成员函数来获得计算结果，第一次调用 get 成员函数后，内部的共享状态会被释放，再次调用 get 成员函数将导致未定义行为。<br />
如果你需要多个线程等待同一事件，可以使用 std::shared_future。std::future 是只 movable 的，所有权可以在多个实例之间转移，但是，同一时间只有一个实例引用到特定的异步结果；std::shared_future 是 copyable 的，多个实例可以引用到同一个异步结果。<br />
多个线程同时访问单个 std::shared_future 时，依然是存在 data race 的。使用锁进行保护可以避免 data race。但是，更好的方式是为每个线程传入克隆的 std::shared_future 实例，这样每个线程可以安全地访问其局部的 std::shared_future 实例，而不需要锁的保护。<br />
<img src="./AsynchronousProgramming/04_02_05_shared_future_usage.png" alt="04_02_05_shared_future_usage.png" /><br />
</p>

<p>
使用 std::shared_future 的一个例子是 Excel。Excel 中多个 cell 最终的值可能是通过公式计算得到的，而这些 cell 可能都会引用某一个 cell 的值，我们可以使用 std::shared_future 表示每个 cell，这样每个 cell 的计算可以并行执行，当 cell A 引用另一个 cell B 时，cell A 调用 cellBFuture.get() 时会阻塞，直到 cell A 的计算完成。<br />
</p>

<p>
引用某个异步状态的 std::shared_future 实例是从引用该状态的 std::future 实例构造的。 由于 std::future 对象不与任何其他对象共享异步状态的所有权，因此必须使用 std::move 将所有权转移到 std::shared_future 中，使 std::future 处于空状态:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">p</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">f</span>(p.get_future());
assert(f.valid());   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">f &#26159;&#21512;&#27861;&#30340;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">sf</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">f</span>));
assert(<span style="color: #a45bad;">!</span>f.valid());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">f &#29616;&#22312;&#26159;&#19981;&#21512;&#27861;&#30340;</span>
assert(sf.valid());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">sf &#29616;&#22312;&#26159;&#21512;&#27861;&#30340;</span>
</pre>
</div>

<p>
如其他可移动对象一样，转移所有权对右值来说是隐式操作（不需要 std::move），所以可以使用 std::promise 对象的成员函数 get_future()的返回值，直接构造一个 std::shared_future 对象:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #a45bad;">std</span>::string&gt; <span style="color: #7590db;">p</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_future</span>&lt;<span style="color: #a45bad;">std</span>::string&gt; <span style="color: #bc6ec5; font-weight: bold;">sf</span>(p.get_future());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38544;&#24335;&#36716;&#31227;&#25152;&#26377;&#26435; &#20351;&#29992;std::future&#21491;&#20540;&#23545;&#35937;&#26500;&#36896;&#19968;&#20010;std::shared_future &#23545;&#35937;</span>
</pre>
</div>

<p>
std::future 有一个额外的特性，其可以方便 std::shared_future 的使用。该特性可以从初始化器自动推断变量的类型。share() 成员函数就利用了该特性，其创建一个新的 std::shared_future 对象，直接将自己的所有权传递给新对象。这有效简化了代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt; <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">map</span>&lt; SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator&gt; <span style="color: #7590db;">p</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25512;&#26029; sf &#30340;&#31867;&#22411;&#20026; std::shared_future&lt; std::map&lt;SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator &gt;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524; Comparator &#25110;Allocator&#25913;&#21464;&#20102;&#65292;&#21482;&#38656;&#35201;&#20462;&#25913;promise&#30340;&#31867;&#22411;&#65292;std::shared_future&#30340;&#31867;&#22411;&#20250;&#33258;&#21160;&#26356;&#26032;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">sf</span>=p.get_future().share();
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2bd913c" class="outline-4">
<h4 id="org2bd913c">Waiting with a time limit</h4>
<div class="outline-text-4" id="text-org2bd913c">
<p>
前面介绍的阻塞调用都会将线程阻塞一段不确定长度的时间，直到等待的特定事件发生才会唤醒等待线程。大多数情况下这样做都是可行的，但是有时候你希望能指定等待的最长时长。这样你就可以发送“正在处理中&#x2026;”这样的消息给交互的用户或其他进程，甚至当用户放弃等待并点击了取消按钮后，你可以直接退出等待。<br />
</p>

<p>
你可以指定两种类型的超时：时间段超时(duration-based timeout)，例如：等待 30 秒，绝对超时(absolute timeout)，例如：等到 2021 年 1 月 1 日 0 时 0 分 0 秒。等待函数的变体提供了指定超时的功能。_for 处理时间段超时，_until 处理绝对超时。<br />
</p>
</div>
<div id="outline-container-orgf9923d6" class="outline-5">
<h5 id="orgf9923d6">Clocks</h5>
<div class="outline-text-5" id="text-orgf9923d6">
<p>
就 C++ 标准库而言，时钟是时间信息的来源。 具体来说，时钟类提供了四种不同的时间信息：<br />
</p>
<ul class="org-ul">
<li>当前的时间信息<br /></li>
<li>时间值的类型信息<br /></li>
<li>时钟的嘀嗒周期<br /></li>
<li>时钟嘀嗒的周期是否是固定不变的（如果 tick 周期固定不变，则称时钟是稳定的）<br /></li>
</ul>

<p>
调用时钟类的 now() 静态成员函数可以获得当前时间。例如：std::chrono::system_clock::now() 返回系统时钟的当前时间。<br />
</p>

<p>
时间值(时间点)的类型信息为时钟的 time_point 类型成员。例如：std::chrono::system_clock::now() 返回的时间点类型为 std::chrono::system_clock::time_point。<br />
</p>

<p>
时钟的嘀嗒周期被指定为 n 秒 m 次，时钟周期的类型为时钟的 period 类型成员，其为 std::ratio&lt;int,int&gt;。例如：std::ratio&lt;5,2&gt; 表示 5 秒钟嘀嗒 2 次。如果时钟 tick 的周期到运行时才能确定，或者时钟 tick 周期会变化，则时钟周期可能被指定为平均的 tick 周期或者最小的 tick 周期或者库实现者认为合适的值。<br />
如果 tick 周期固定不变，且不可调节，则称时钟为稳定的(steady)时钟。该时钟类对应的静态成员函数 is_steady() 返回 true。通常来说 std::chrono::system_clock 时钟不是稳定的，该时钟的 tick 是可调节的（该时钟类 tick 的调节是自动执行的）。这样的调节可能导致，依次调用两次 now() 成员函数，后一次的时间点在前一次之前。稳定的时钟对于超时计算来说非常重要。c++标准库提供的稳定时钟为 std::chrono::steady_clock。std::chrono::system_clock 表示系统的实时时钟。std::chrono::high_resolution_clock 为标准库能提供的精度最高的时钟(该时钟可能是其他类型时钟的 typedef)。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">system_clock</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span>
{ 
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">rep</span>                       = <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #ce537a; font-weight: bold;">long</span>;
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">period</span>                    = <span style="color: #ce537a; font-weight: bold;">ratio</span>&lt;1, 10'000'000&gt;; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">100 nanoseconds</span>
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">duration</span>                  = _CHRONO <span style="color: #ce537a; font-weight: bold;">duration</span>&lt;<span style="color: #ce537a; font-weight: bold;">rep</span>, <span style="color: #ce537a; font-weight: bold;">period</span>&gt;;
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">time_point</span>                = _CHRONO <span style="color: #ce537a; font-weight: bold;">time_point</span>&lt;<span style="color: #ce537a; font-weight: bold;">system_clock</span>&gt;;
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">constexpr</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">is_steady</span> = <span style="color: #a45bad;">false</span>;

    _NODISCARD <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">time_point</span> <span style="color: #bc6ec5; font-weight: bold;">now</span>() <span style="color: #4f97d7; font-weight: bold;">noexcept</span> { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">get current time</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> time_point(<span style="color: #ce537a; font-weight: bold;">duration</span>(<span style="color: #7590db;">_Xtime_get_ticks</span>()));
    }

    _NODISCARD <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">__time64_t</span> <span style="color: #bc6ec5; font-weight: bold;">to_time_t</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">time_point</span>&amp; <span style="color: #7590db;">_Time</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span> { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">convert to __time64_t</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> duration_cast&lt;seconds&gt;(_Time.time_since_epoch()).count();
    }

    _NODISCARD <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">time_point</span> <span style="color: #bc6ec5; font-weight: bold;">from_time_t</span>(<span style="color: #ce537a; font-weight: bold;">__time64_t</span> <span style="color: #7590db;">_Tm</span>) <span style="color: #4f97d7; font-weight: bold;">noexcept</span> { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">convert from __time64_t</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> time_point{seconds{_Tm}};
    }
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">cout &lt;&lt; <span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">system_clock</span>::<span style="color: #a45bad;">period</span>::num &lt;&lt; <span style="color: #2d9574;">"/"</span> &lt;&lt; <span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">system_clock</span>::<span style="color: #a45bad;">period</span>::den &lt;&lt; endl;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">system_clock::to_time_t</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;ctime&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;ratio&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;chrono&gt;</span>

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span> ()
{
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #4f97d7; font-weight: bold;">namespace</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>;

    <span style="color: #ce537a; font-weight: bold;">duration</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>,<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">ratio</span>&lt;60*60*24&gt; &gt; <span style="color: #7590db;">one_day</span> (1);

    <span style="color: #a45bad;">system_clock</span>::<span style="color: #ce537a; font-weight: bold;">time_point</span> <span style="color: #7590db;">today</span> = <span style="color: #a45bad;">system_clock</span>::now();
    <span style="color: #a45bad;">system_clock</span>::<span style="color: #ce537a; font-weight: bold;">time_point</span> <span style="color: #7590db;">tomorrow</span> = today + one_day;

    <span style="color: #ce537a; font-weight: bold;">time_t</span> <span style="color: #7590db;">tt</span>;

    tt = <span style="color: #a45bad;">system_clock</span>::to_time_t ( today );
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"today is: "</span> &lt;&lt; ctime(&amp;tt);

    tt = <span style="color: #a45bad;">system_clock</span>::to_time_t ( tomorrow );
    <span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"tomorrow will be: "</span> &lt;&lt; ctime(&amp;tt);

    <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
}

<span style="color: #2aa1ae; background-color: #292e34;">//////////</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OUTPUT:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">today is: Wed May 30 12:38:06 2012</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tomorrow will be: Thu May 31 12:38:06 2012</span>
</pre>
</div>

<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/chrono/system_clock/">http://www.cplusplus.com/reference/chrono/system_clock/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9f1abbf" class="outline-5">
<h5 id="org9f1abbf">Durations</h5>
<div class="outline-text-5" id="text-org9f1abbf">
<p>
Durations 是时间支持中最简单的部分。std:: chrono::duration&lt;&gt; 模板类用于表示持续的时间间隔。第一个模板参数是表示时间间隔数量的类型，第二个参数表示单位时间间隔对应多少秒，是一个 ratio 类型。例如：std::chrono::duration&lt;short,std:: ratio&lt;60,1&gt;&gt; 表示单位时间间隔为 1 分钟(60/1 秒)，时间间隔数量使用 short 类型来存储。std::chrono::duration&lt;double,std::ratio &lt;1,1000&gt;&gt;表示单位时间间隔为 1 毫秒(1/1000 秒)，时间间隔数量使用 double 类型来存储。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span> &lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">_Rep</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">_Period</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">duration</span> { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">represents a time duration</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">rep</span>    = _Rep;
    <span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">period</span> = <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">_Period</span>::type;

    static_assert(<span style="color: #a45bad;">!</span><span style="color: #ce537a; font-weight: bold;">_Is_duration_v</span>&lt;<span style="color: #ce537a; font-weight: bold;">_Rep</span>&gt;, <span style="color: #2d9574;">"duration can't have duration as first template argument"</span>);
    static_assert(<span style="color: #ce537a; font-weight: bold;">_Is_ratio_v</span>&lt;<span style="color: #ce537a; font-weight: bold;">_Period</span>&gt;, <span style="color: #2d9574;">"period not an instance of std::ratio"</span>);
    static_assert(0 &lt; <span style="color: #a45bad;">_Period</span>::num, <span style="color: #2d9574;">"period negative or zero"</span>);
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
    
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">_Rep</span> <span style="color: #7590db;">_MyRep</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the stored rep</span>
};
</pre>
</div>

<p>
标准库定义了一些常见的时间间隔：nanoseconds, microseconds, milliseconds, seconds, minutes, and hours。标准库还定义了一些 ratio：std::atto(10 的负 18 次方)、std::exa(10 的 18 次方)、std::centi(百分之一)。<br />
在 c++14 中还引入了一些后缀操作符。可以很方便地定义 duration 常量。当使用整型字面值常量时，对应的类型为预定义的时间间隔。当使用浮点字面值常量时，会特化适当类型的 duration 模板类。如果对于 duration::rep 的精度有要求，应该自己特化 duration 模板类。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #4f97d7; font-weight: bold;">namespace</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono_literals</span>;
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">one_day</span>=24h;                     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30456;&#24403;&#20110; std::chrono::hours(24)</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">half_an_hour</span>=30min;              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30456;&#24403;&#20110; std::chrono::minutes(30)</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">max_time_between_messages</span>=30ms;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30456;&#24403;&#20110; std::chrono::milliseconds(30)</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">float_literal_dur</span> = 2.5min;      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30456;&#24403;&#20110; std::chrono::duration&lt;float, std::ratio&lt;60,1&gt;&gt;</span>
</pre>
</div>

<p>
当 duration 类型转换不会产生截断时，转化可以隐式进行，否则需要显示指定转化。例如：hours 转化为 seconds 可以隐式转化。显示转化的结果是截断后的结果，而不是执行四舍五入的结果。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #ce537a; font-weight: bold;">milliseconds</span> <span style="color: #7590db;">ms</span>(54802);
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #ce537a; font-weight: bold;">seconds</span> <span style="color: #7590db;">s</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::duration_cast&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #ce537a; font-weight: bold;">seconds</span>&gt;(ms);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;std::chrono::duration_cast&lt;&gt; &#36827;&#34892;&#26174;&#31034;&#36716;&#21270;</span>
</pre>
</div>

<p>
基于时间段的等待（duration-based wait）是通过使用 std::chrono::duration&lt;&gt; 实例来实现的。wait 函数会返回一个状态来指示等待结果。例如，对于 future 来说，状态类型为 std::future_status，std::future_status::timeout 表示等待超时；std::future_status::ready 表示等待的事件发生 future 状态为 ready；std::future_status::deferred 表示 future 对应的任务延时了。duration-based wait 使用的时钟是标准库中的稳定时钟(steady clock)，因此 35 毫秒就是意味着经过 35 毫秒，即使系统时钟可能向前或向后进行调节，都不会受到影响。当然，系统调度的变幻莫测以及操作系统时钟精度的变化可能会导致时间间隔比 35 毫秒要长。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">f</span>=<span style="color: #a45bad;">std</span>::async(some_task);
<span style="color: #4f97d7; font-weight: bold;">if</span>(f.wait_for(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::milliseconds(35))==<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">future_status</span>::ready)
{
    do_something_with(f.get());
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org95fea1a" class="outline-5">
<h5 id="org95fea1a">Time points</h5>
<div class="outline-text-5" id="text-org95fea1a">
<p>
时钟的时间点是通过 std::chrono::time_point&lt;&gt;模板类来表示的。第一个模板参数指定了时钟的类型，第二个模板参数指定了时钟对应的 duration，duration 表示了时间间隔数量的类型、时钟的嘀嗒周期。时间点的值(time_point)存储的是从某个特定时间点开始的时间长度，该特定的时间点被称为时钟纪元。时钟纪元是时钟的基础属性，但是时钟纪元无法被直接查询，其也不是由 c++标准指定的。典型的时间纪元包括 1970 年 1 月 1 日 0 时 0 分 0 秒 和 计算机启动的时刻。多个时钟可能共享同一个时间纪元也可能使用各自不同的时间纪元。 time_since_epoch()成员函数可以返回从时间纪元到给定时间点的时间间隔。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Clock</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Duration</span> = <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">Clock</span>::<span style="color: #ce537a; font-weight: bold;">duration</span>&gt; <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">time_point</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">some_time_point &#20445;&#23384;&#20102; std::chrono::system_clock &#30456;&#20851;&#30340;&#26102;&#38388;&#28857;&#65292;&#24182;&#19988;&#20197;&#20998;&#20026;&#21333;&#20301;&#26469;&#34913;&#37327;&#32780;&#19981;&#26159; std::chrono::system_clock &#25351;&#23450;&#30340;&#26102;&#38047;&#28404;&#31572;&#21608;&#26399;&#12290;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #ce537a; font-weight: bold;">time_point</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::system_clock, <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::minutes&gt; <span style="color: #7590db;">some_time_point</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21019;&#24314; time_point</span>
<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">p0</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #ce537a; font-weight: bold;">time_point</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::system_clock&gt;{};
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">time_t</span> <span style="color: #7590db;">epoch_time</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">system_clock</span>::to_time_t(p0);
<span style="color: #a45bad;">std</span>::cout &lt;&lt; <span style="color: #2d9574;">"epoch: "</span> &lt;&lt; <span style="color: #a45bad;">std</span>::ctime(&amp;epoch_time);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OUTPUT--&gt; epoch: Thu Jan  1 00:00:00 1970</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">time_point to unix-timestamp</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">microsecondsUTC</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::duration_cast&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::microseconds&gt;(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">system_clock</span>::now().time_since_epoch()).count();

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">time_point + duration</span>
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">high_resolution_clock</span>::now() + <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::nanoseconds(500)

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25171;&#21360;&#20195;&#30721;&#25191;&#34892;&#26102;&#38271;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">time_point - time_point --&gt; duration </span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">start</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">high_resolution_clock</span>::now();
do_something();
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">stop</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">high_resolution_clock</span>::now();
<span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">"do_something() took "</span> &lt;&lt; <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::duration&lt;<span style="color: #ce537a; font-weight: bold;">double</span>&gt;(stop-start).count() &lt;&lt; <span style="color: #2d9574;">" seconds"</span>&lt;&lt;<span style="color: #a45bad;">std</span>::endl;
</pre>
</div>

<p>
当将 time_point 传递给 wait 函数时，其指定了一个绝对的超时，time_point 的 clock 参数用于衡量超时。wait 函数会跟踪 clock 的改变，直到 clock 的 now 成员函数返回的值为 time_point 之后的值，wait 函数才会返回。如果 clock 被向前调整，会导致等待时长变短，如果 clock 被向后调整，等待时长则会变长。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;condition_variable&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;chrono&gt;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">cv</span>;
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">done</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">wait_loop</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">timeout</span>= <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::<span style="color: #a45bad;">steady_clock</span>::now()+<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::milliseconds(500);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(m);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#20351;&#29992;&#26465;&#20214;&#21464;&#37327;&#26102;&#65292;&#27809;&#26377;&#20256;&#20837;predicate&#65292;&#23601;&#38656;&#35201;&#20351;&#29992;&#24490;&#29615;&#26469;&#22788;&#29702;&#20266;&#21796;&#37266;&#30340;&#24773;&#20917;</span>
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips: &#22312;&#24490;&#29615;&#20013;&#20351;&#29992; wait_for&#65292;&#21487;&#33021;&#22312;&#20266;&#21796;&#37266;&#20043;&#21069;&#23601;&#31561;&#24453;&#36229;&#26102;&#65292;&#19979;&#27425;&#20877;&#36827;&#20837;&#31561;&#24453;&#21518;&#65292;&#21448;&#37325;&#26032;&#24320;&#22987;&#31561;&#24453;&#19968;&#27573;&#26102;&#38388;&#12290;&#36825;&#26679;&#30340;&#24773;&#20917;&#21487;&#33021;&#37325;&#22797;&#20219;&#24847;&#22810;&#27425;&#65292;&#20351;&#24471;&#24635;&#30340;&#31561;&#24453;&#26102;&#38271;&#26159;&#26080;&#30028;&#38480;&#30340;&#12290;&#32780;wait_util&#21017;&#19981;&#20250;&#20986;&#29616;&#36825;&#31181;&#24773;&#20917;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(cv.wait_until(lk,timeout)==<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">cv_status</span>::timeout)
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> done;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f7fd62" class="outline-5">
<h5 id="org4f7fd62">Functions that accept timeouts</h5>
<div class="outline-text-5" id="text-org4f7fd62">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">类型/命名空间</th>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">std::this_thread 命名空间</td>
<td class="org-left">sleep_for(duration)</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">sleep_until(time_point)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">std::condition_variable</td>
<td class="org-left">wait_for(duration)</td>
<td class="org-left">std::cv_status::time_out</td>
</tr>

<tr>
<td class="org-left">或 std::condition_variable_any</td>
<td class="org-left">wait_until(time_point)</td>
<td class="org-left">或 std::cv_status::no_timeout</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">wait_for(lock, duration, predicate)</td>
<td class="org-left">bool —— 当唤醒时，返回谓词的结果</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">wait_until(lock, duration, predicate)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">std::timed_mutex</td>
<td class="org-left">try_lock_for(duration)</td>
<td class="org-left">bool —— 获取锁时返回 true，否则返回 fasle</td>
</tr>

<tr>
<td class="org-left">或 std::recursive_timed_mutex</td>
<td class="org-left">try_lock_until(time_point)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">std::unique_lock&lt;TimedLockable&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unique_lock(lockable, duration)</td>
<td class="org-left">owns_lock()</td>
<td class="org-left">bool —— 当获取锁时返回 true，否则返回 false</td>
</tr>

<tr>
<td class="org-left">unique_lock(lockable, time_point)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">try_lock_for(duration)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">try_lock_until(time_point)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">std::future&lt;ValueType&gt;</td>
<td class="org-left">wait_for(duration)</td>
<td class="org-left">当等待超时，返回 std::future_status::timeout</td>
</tr>

<tr>
<td class="org-left">std::shared_future&lt;ValueType&gt;</td>
<td class="org-left">wait_until(time_point)</td>
<td class="org-left">当共享状态的标记已经为 ready(即 Provider 在共享状态上设置了值或者异常)，返回 std::future_status::ready</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">当共享状态包含一个 deferred 函数，返回 std::future_status::deferred</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org0295227" class="outline-4">
<h4 id="org0295227">Using synchronization of operations to simplify code</h4>
<div class="outline-text-4" id="text-org0295227">
<p>
使用前面提到的这些同步工具，你可以专注于需要同步的操作上，而不用关心同步的实现机制。这些同步工具提供了一种更加函数式地并发编程的方法，该方法可以简化你的代码。<br />
</p>
</div>
<div id="outline-container-org568b4c9" class="outline-5">
<h5 id="org568b4c9">Functional programming with futures</h5>
<div class="outline-text-5" id="text-org568b4c9">
<p>
函数式编程是指一种编程分格，函数结果只依赖于该函数的参数，而不依赖外部的任何状态。这和数学上的函数概念相关，如果你使用相同的参数调用函数两次，则函数的结果相同。C++标准库中的很多函数具备该性质，例如：math::sin math::cos math::sqrt 等等。直接作用于基础类型的操作也具备该性质，例如：3+3 6*9 等等。我们将满足这种性质的函数称为纯函数（pure function）。<br />
</p>

<p>
函数式编程不会修改函数外部的状态，因此，可以避免共享内存相关的很多问题。因为不会对共享数据进行修改，所以就不会有 race conditions，也就不需要使用互斥量对共享数据进行保护了。编程语言 Haskell 中，所有函数默认都为 prue function。因为大部分函数是纯函数，修改共享数据的非纯函数就会显得更加突出，因此更容易推理这些非纯函数是如何和整个程序结构配合的。<br />
</p>

<p>
c++是一种多范式编程语言，完全可以使用 c++进行函数式编程。特别是 c++11 的到来，其引入了 lambda 函数，合并了 Boost 和 TR1 中的 std::bind，引入了变量类型的自动推断。future 又使得函数式并发在 c++中变的可行。<br />
</p>

<p>
下面展示了函数式风格的、顺序执行的 QuickSort:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20989;&#25968;&#24335;&#32534;&#31243;&#39118;&#26684;&#30340;&#25509;&#21475;&#65292;&#20989;&#25968;&#19981;&#20250;&#20462;&#25913;&#20219;&#20309;&#22806;&#37096;&#29366;&#24577;&#65292;&#20989;&#25968;&#30340;&#25191;&#34892;&#32467;&#26524;&#36890;&#36807;&#36820;&#22238;&#20540;&#36820;&#22238;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">sequential_quick_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">input</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(input.empty())
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> input;
    }
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;&#20351;&#29992;&#20102;&#20989;&#25968;&#24335;&#39118;&#26684;&#30340;&#25509;&#21475;&#65292;&#27492;&#22788;&#38656;&#35201;&#21019;&#24314;&#26032;&#30340;list &#23384;&#25918;&#32467;&#26524;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">result</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">splice(pos, from_list, from_list_pos)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;input&#20013;&#24320;&#22987;&#30340;&#20803;&#32032;&#31227;&#21160;&#21040;result&#30340;&#24320;&#22987;&#20301;&#32622;</span>
    result.splice(result.begin(),input,input.begin());
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">pivot</span>=*result.begin();

    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">divide_point</span>=<span style="color: #a45bad;">std</span>::partition(input.begin(),input.end(), [&amp;](<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">t</span>){<span style="color: #4f97d7; font-weight: bold;">return</span> t&lt;pivot;});

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;&#20351;&#29992;&#20102;&#20989;&#25968;&#24335;&#39118;&#26684;&#30340;&#25509;&#21475;&#65292;&#27492;&#22788;&#38656;&#35201;&#21019;&#24314;&#26032;&#30340;list</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">lower_part</span>;
    lower_part.splice(lower_part.end(),input,input.begin(), divide_point);
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">new_lower</span>(sequential_quick_sort(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">lower_part</span>)));
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">new_higher</span>(sequential_quick_sort(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">input</span>)));

    result.splice(result.end(),new_higher);
    result.splice(result.begin(),new_lower);
    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
下面展示了函数式风格的、并行执行的 QuickSort:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">parallel_quick_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">input</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(input.empty())
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> input;
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">result</span>;
    result.splice(result.begin(),input,input.begin());
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">pivot</span>=*result.begin();

    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">divide_point</span>=<span style="color: #a45bad;">std</span>::partition(input.begin(),input.end(), [&amp;](<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">t</span>){<span style="color: #4f97d7; font-weight: bold;">return</span> t&lt;pivot;});
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">lower_part</span>;
    lower_part.splice(lower_part.end(),input,input.begin(), divide_point);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;future&#20445;&#23384;&#24322;&#27493;&#35745;&#31639;&#30340;&#32467;&#26524;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;&gt; <span style="color: #7590db;">new_lower</span>(<span style="color: #a45bad;">std</span>::async(&amp;<span style="color: #ce537a; font-weight: bold;">parallel_quick_sort</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;,<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">lower_part</span>)));

    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">new_higher</span>(parallel_quick_sort(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">input</span>)));

    result.splice(result.end(),new_higher);
    result.splice(result.begin(),new_lower.get());
    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>
<p>
函数式编程不是并发编程的唯一范式。另一种范式名为 CSP(Communicating Sequential Processes)，其从概念上将线程完全分开，多个线程完全没有共享数据，他们通过通信通道来互相发送消息。Erlang 编程语言以及 MPI(Message Passing Interface)使用了这种范式。<br />
</p>
</div>
</div>
<div id="outline-container-org5b6f939" class="outline-5">
<h5 id="org5b6f939">Synchronizing operations with message passing</h5>
<div class="outline-text-5" id="text-org5b6f939">
<p>
CSP(Communicating Sequential Processes) 的理念很简单：如果没有共享数据，每个线程就可以独立地进行推断，其行为完全依赖于它对收到消息是如何响应的。因此，每个线程相当于一个状态机：当收到一个消息后，其以某种方式更新自己的状态，还可能会给其他线程发送一个或多个消息。<br />
</p>

<p>
CSP 完全没有共享数据，所有的交流通过消息队列来实现。但是 c++线程共享同一个地址空间，无法强制要求。因此，library 或应用程序的作者需要保证多个线程之间没有共享数据。当然，消息队列是需要被共享的，这样多个线程才能互相交互。<br />
</p>

<p>
假设需要为 ATM 编写代码。代码需要处理 ATM 和取款人的交互，ATM 和银行柜台的交互，还需要控制物理机器接受取款人插入的磁卡，显示合适的信息，处理按键的点击，发放纸币，返还磁卡。可以将代码划分到 3 个独立线程中：一个处理物理机器，一个处理 ATM 逻辑，一个处理和银行的交互。<br />
下图为将 ATM 逻辑线程建模为一个简单的状态机器：<br />
<img src="./AsynchronousProgramming/04_04_01_atm_logic.jpg" alt="04_04_01_atm_logic.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">atm</span>
{
    <span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">receiver</span> <span style="color: #7590db;">incoming</span>;
    <span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">sender</span> <span style="color: #7590db;">bank</span>;
    <span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">sender</span> <span style="color: #7590db;">interface_hardware</span>;

    <span style="color: #ce537a; font-weight: bold;">void</span> (<span style="color: #a45bad;">atm</span>::*<span style="color: #ce537a; font-weight: bold;">state</span>)();

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">account</span>;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">withdrawal_amount</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">pin</span>;
    
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#21462;&#27454;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_withdrawal</span>()
    {
        incoming.wait()
            .handle&lt;withdraw_ok&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">withdraw_ok</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    interface_hardware.send(
                        <span style="color: #ce537a; font-weight: bold;">issue_money</span>(<span style="color: #7590db;">withdrawal_amount</span>));

                    bank.send(
                        withdrawal_processed(account,withdrawal_amount));

                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                })
            .handle&lt;withdraw_denied&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">withdraw_denied</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    interface_hardware.send(<span style="color: #ce537a; font-weight: bold;">display_insufficient_funds</span>());

                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                })
            .handle&lt;cancel_pressed&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    bank.send(
                        cancel_withdrawal(account,withdrawal_amount));

                    interface_hardware.send(
                        <span style="color: #ce537a; font-weight: bold;">display_withdrawal_cancelled</span>());

                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                });
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#20313;&#39069;&#26597;&#35810;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_balance</span>()
    {
        incoming.wait()
            .handle&lt;balance&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">balance</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    interface_hardware.send(display_balance(msg.amount));

                    state=&amp;<span style="color: #a45bad;">atm</span>::wait_for_action;
                })
            .handle&lt;<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span>&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                });
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#29992;&#25143;&#21462;&#27454;|&#26597;&#30475;&#20313;&#39069;|&#36864;&#20986;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait_for_action</span>()
    {
        interface_hardware.send(<span style="color: #ce537a; font-weight: bold;">display_withdrawal_options</span>());

        incoming.wait()
            .handle&lt;withdraw_pressed&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">withdraw_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    withdrawal_amount=msg.amount;
                    bank.send(withdraw(account,msg.amount,incoming));
                    state=&amp;<span style="color: #a45bad;">atm</span>::process_withdrawal;
                })
            .handle&lt;balance_pressed&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">balance_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    bank.send(get_balance(account,incoming));
                    state=&amp;<span style="color: #a45bad;">atm</span>::process_balance;
                })
            .handle&lt;<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span>&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                });
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#39564;&#35777;&#23494;&#30721;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">verifying_pin</span>()
    {
        incoming.wait()
            .handle&lt;pin_verified&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">pin_verified</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    state=&amp;<span style="color: #a45bad;">atm</span>::wait_for_action;
                })
            .handle&lt;pin_incorrect&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">pin_incorrect</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    interface_hardware.send(
                        <span style="color: #ce537a; font-weight: bold;">display_pin_incorrect_message</span>());
                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                })
            .handle&lt;<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span>&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                });
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#36755;&#20837;&#23494;&#30721;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">getting_pin</span>()
    {
        incoming.wait()
            .handle&lt;digit_pressed&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">digit_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">pin_length</span>=4;
                    pin+=msg.digit;

                    <span style="color: #4f97d7; font-weight: bold;">if</span>(pin.length()==pin_length)
                    {
                        bank.send(verify_pin(account,pin,incoming));
                        state=&amp;<span style="color: #a45bad;">atm</span>::verifying_pin;
                    }
                })
            .handle&lt;clear_last_pressed&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">clear_last_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>pin.empty())
                    {
                        pin.pop_back();
                    }
                })
            .handle&lt;<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span>&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">cancel_pressed</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    state=&amp;<span style="color: #a45bad;">atm</span>::done_processing;
                });
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#25554;&#20837;&#30913;&#21345;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">waiting_for_card</span>()
    {
        interface_hardware.send(<span style="color: #ce537a; font-weight: bold;">display_enter_card</span>());

        incoming.wait()
            .handle&lt;card_inserted&gt;(
                [&amp;](<span style="color: #ce537a; font-weight: bold;">card_inserted</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">msg</span>)
                {
                    account=msg.account;
                    pin=<span style="color: #2d9574;">""</span>;
                    interface_hardware.send(<span style="color: #ce537a; font-weight: bold;">display_enter_pin</span>());
                    state=&amp;<span style="color: #a45bad;">atm</span>::getting_pin;
                });
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">done_processing</span>()
    {
        interface_hardware.send(<span style="color: #ce537a; font-weight: bold;">eject_card</span>());
        state=&amp;<span style="color: #a45bad;">atm</span>::waiting_for_card;
    }

    <span style="color: #bc6ec5; font-weight: bold;">atm</span>(<span style="color: #ce537a; font-weight: bold;">atm</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">atm</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">atm</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">atm</span>(<span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">sender</span> <span style="color: #7590db;">bank_</span>,
        <span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">sender</span> <span style="color: #7590db;">interface_hardware_</span>):
        bank(bank_),interface_hardware(interface_hardware_)
    {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">done</span>()
    {
        get_sender().send(<span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">close_queue</span>());
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">run</span>()
    {
        state=&amp;<span style="color: #a45bad;">atm</span>::waiting_for_card;
        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
            {
                (<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;*state)();
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">close_queue</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)
        {
        }
    }

    <span style="color: #a45bad;">messaging</span>::<span style="color: #ce537a; font-weight: bold;">sender</span> <span style="color: #bc6ec5; font-weight: bold;">get_sender</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> incoming;
    }
};
</pre>
</div>

<p>
这种编程风格可以极大简化并发系统的设计，可以独立地考虑每个线程。这也是使用多线程来分离关注点(Separate Concerns)的一个例子，你需要明确如何将多个任务划分到不同的线程中。<br />
</p>
</div>
</div>
<div id="outline-container-org440c9d9" class="outline-5">
<h5 id="org440c9d9">Continuation-style concurrency with the Concurrency TS</h5>
<div class="outline-text-5" id="text-org440c9d9">
<p>
Concurrency TS 提供了新版本的 promise 和 packaged_task（std::experimental::promise 和 std::experimental::packaged_task.）。他们返回的实例为 std::experimental::future，其允许 Continuation-style 的并发编程。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">find_the_answer</span>;
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fut</span>=find_the_answer();
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;fut&#29366;&#24577;&#21464;&#20026;ready&#21518;&#65292;find_the_question&#20989;&#25968;&#20250;&#34987;&#35843;&#24230;&#65292;&#20174;&#32780;&#22312;&#26576;&#20010;&#26410;&#25351;&#26126;&#30340;&#32447;&#31243;&#19978;&#25191;&#34892;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#32473;&#20102;&#23454;&#29616;&#32773;&#33258;&#30001;&#26469;&#20915;&#23450;&#20989;&#25968;&#26159;&#22312;&#19968;&#20010;&#32447;&#31243;&#27744;&#19978;&#25191;&#34892;&#36824;&#26159;&#22312;&#24211;&#31649;&#29702;&#30340;&#32447;&#24615;&#19978;&#25191;&#34892;&#12290;&#36825;&#26679;&#20570;&#26159;&#26377;&#24847;&#32780;&#20026;&#20043;&#65292;&#24403;continuations&#34987;&#21152;&#21040;c++&#26631;&#20934;&#24211;&#21518;&#65292;&#23454;&#29616;&#32773;&#23601;&#21487;&#20197;&#26681;&#25454;&#20182;&#20204;&#30340;&#32463;&#39564;&#26469;&#26356;&#22909;&#22320;&#25351;&#23450;&#32447;&#31243;&#30340;&#36873;&#25321;&#24182;&#20026;&#29992;&#25143;&#25552;&#20379;&#21512;&#36866;&#30340;&#26426;&#21046;&#26469;&#25511;&#21046;&#32447;&#31243;&#30340;&#36873;&#25321;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fut2</span>=fut.then(find_the_question);
assert(<span style="color: #a45bad;">!</span>fut.valid());
assert(fut2.valid());
</pre>
</div>

<p>
和直接调用 std::async 或 std::thread 不同，你不能传递参数给一个 continuation 函数，因为参数已经由 library 定义了——其接受一个 ready 状态的 future，该 future 持有触发 continuation 的函数的结果。例如：上面例子中 find_the_question 的签名为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #bc6ec5; font-weight: bold;">find_the_question</span>(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">the_answer</span>);
</pre>
</div>

<p>
Concurrency TS 没有实现一个类似于 std::async 的模板函数，实现这样的一个模板函数很简单，如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Func</span>&gt;
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #4f97d7; font-weight: bold;">decltype</span>(<span style="color: #a45bad;">std</span>::declval&lt;<span style="color: #ce537a; font-weight: bold;">Func</span>&gt;()())&gt;
<span style="color: #bc6ec5; font-weight: bold;">spawn_async</span>(<span style="color: #ce537a; font-weight: bold;">Func</span>&amp;&amp; <span style="color: #7590db;">func</span>){
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #4f97d7; font-weight: bold;">decltype</span>(<span style="color: #a45bad;">std</span>::declval&lt;<span style="color: #ce537a; font-weight: bold;">Func</span>&gt;()())&gt; <span style="color: #7590db;">p</span>;
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">res</span>=p.get_future();
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t</span>(
        [<span style="color: #7590db;">p</span>=<span style="color: #a45bad;">std</span>::move(p),<span style="color: #7590db;">f</span>=<span style="color: #a45bad;">std</span>::decay_t&lt;<span style="color: #ce537a; font-weight: bold;">Func</span>&gt;(func)]() <span style="color: #4f97d7; font-weight: bold;">mutable</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">try</span>
            {
                p.set_value_at_thread_exit(<span style="color: #ce537a; font-weight: bold;">f</span>());
            }
            <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
            {
                p.set_exception_at_thread_exit(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">current_exception</span>());
            }
        });
    t.detach();
    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">TIPS: &#20351;&#29992;p.set_value_at_thread_exit &#21644; p.set_exception_at_thread_exit &#20445;&#35777; future &#29366;&#24577;&#21464;&#20026; ready &#26102;&#65292;&#32447;&#31243;&#30340;&#23616;&#37096;&#21464;&#37327;&#24050;&#32463;&#34987;&#28165;&#38500;&#12290;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4f1728d" class="outline-5">
<h5 id="org4f1728d">Chaining continuations</h5>
<div class="outline-text-5" id="text-org4f1728d">
</div>
<div id="outline-container-orge50252e" class="outline-6">
<h6 id="orge50252e">std::experimental::future continuation</h6>
<div class="outline-text-6" id="text-orge50252e">
<p>
std::experimental::future 对象的 then 成员函数的返回值依然是一个 std::experimental::future 对象。这意味着，可以链接多个 continuations。<br />
</p>

<p>
考虑如下这个例子：当用户请求登录应用程序时，你需要发送证书到后端做验证，当认证成功后，你需要向后端进一步请求用户账户相关的信息，最后，获得用户信息后，需要将相关信息展示出来。如果使用顺序方式编码，该过程对应的实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_login</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">username</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">password</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">try</span>
    {
        <span style="color: #ce537a; font-weight: bold;">user_id</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">id</span> = backend.authenticate_user(username, password);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#35748;&#35777;&#25104;&#21151;&#21518;&#65292;&#25165;&#33021;&#25191;&#34892;&#19979;&#38754;&#20195;&#30721;</span>
        <span style="color: #ce537a; font-weight: bold;">user_data</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">info_to_display</span> = backend.request_current_info(id);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#33719;&#21462;&#21040;&#29992;&#25143;&#20449;&#24687;&#21518;&#65292;&#25165;&#33021;&#25191;&#34892;&#19979;&#38754;&#20195;&#30721;</span>
        update_display(info_to_display);
    }
    <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>&amp; <span style="color: #7590db;">e</span>)
    {
        display_error(e);
    }
}
</pre>
</div>
<p>
但是，为了不阻塞 UI 线程，我们希望使用异步的代码。如果使用简单的 std::async，将所有逻辑都抛到后台线程。这样会阻塞后台线程，等待任务完成的过程中，依然消耗资源。如果当前有很多这样的任务，最终你将会有很多线程都在等待。下面是简单地使用 async 的方式：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">process_login</span>(
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">username</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">password</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,[=](){
        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            <span style="color: #ce537a; font-weight: bold;">user_id</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">id</span> = backend.authenticate_user(username, password);
            <span style="color: #ce537a; font-weight: bold;">user_data</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">info_to_display</span> = backend.request_current_info(id);
            update_display(info_to_display);
        }
        <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>&amp; <span style="color: #7590db;">e</span>)
        {
            display_error(e);
        }
    });
}
</pre>
</div>
<p>
为了避免线程的阻塞等待，需要某种机制(continuations)可以将多个 task 链接在一起，当一个任务完成后紧接着执行下一个任务，这样就可以避免阻塞等待或浪费资源在轮询上。下面代码使用了这种方式：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">process_login</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">username</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">password</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> spawn_async([=](){
        <span style="color: #4f97d7; font-weight: bold;">return</span> backend.authenticate_user(username, password);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174;continuation &#36820;&#22238;&#19968;&#20010;future &#31867;&#22411;&#20026; std::experimental::future&lt;user_id&gt; id</span>
    }).then([](<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;user_id&gt; <span style="color: #7590db;">id</span>){         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">continuation &#25552;&#20379;&#20102;future-unwrapping &#29305;&#24615;&#65292;&#21487;&#20197;&#23558; future&lt;future&lt;user_id&gt;&gt; &#35299;&#21253;&#20026; future&lt;user_id&gt;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> backend.request_current_info(id.get());
    }).then([](<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;user_data&gt; <span style="color: #7590db;">info_to_display</span>){
        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            update_display(info_to_display.get());
        } <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>&amp; <span style="color: #7590db;">e</span>){
            display_error(e);
        }
    });
}
</pre>
</div>
<p>
如果编译器支持 c++14 引入的泛型 lambda，上面的代码可以简化为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">process_login</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">username</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">password</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> spawn_async([=](){
        <span style="color: #4f97d7; font-weight: bold;">return</span> backend.authenticate_user(username, password);  
    }).then([](<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">id</span>){                                        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lambda &#21442;&#25968;&#31867;&#22411;&#21487;&#20197;&#20351;&#29992;auto</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> backend.request_current_info(id.get());
    }).then([](<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">info_to_display</span>){                           <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lambda &#21442;&#25968;&#31867;&#22411;&#21487;&#20197;&#20351;&#29992;auto</span>
        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            update_display(info_to_display.get());
        } <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>&amp; <span style="color: #7590db;">e</span>){
            display_error(e);
        }
    });
}
</pre>
</div>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/35074578/understanding-continuations-with-stdfuturethen">https://stackoverflow.com/questions/35074578/understanding-continuations-with-stdfuturethen</a><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org4dd8d91" class="outline-6">
<h6 id="org4dd8d91">std::experimental::shared_future continuation</h6>
<div class="outline-text-6" id="text-org4dd8d91">
<p>
std::experimental::shared_future 也支持 continuations。std::experimental::shared_future 对象可以有多个 continuation，continuation 的参数类型为 std::experimental::shared_future。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">std::experimental::future&#30340;share()&#25104;&#21592;&#20989;&#25968;&#36820;&#22238; std::experimental::shared_future &#23545;&#35937;</span>
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fut</span> = spawn_async(some_function).share();
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fut2</span> = fut.then([](<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">shared_future</span>&lt;some_data&gt; <span style="color: #7590db;">data</span>){
    do_stuff(data);
});
<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">fut3</span> = fut.then([](<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">shared_future</span>&lt;some_data&gt; <span style="color: #7590db;">data</span>){
    <span style="color: #4f97d7; font-weight: bold;">return</span> do_other_stuff(data);
});
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org30dfc43" class="outline-5">
<h5 id="org30dfc43">Waiting for more than one future</h5>
<div class="outline-text-5" id="text-org30dfc43">
<p>
假设你有大量数据需要处理，并且可以独立处理每个数据项。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;FinalResult&gt; <span style="color: #bc6ec5; font-weight: bold;">process_data</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;MyData&gt;&amp; <span style="color: #7590db;">vec</span>)
{
    <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">chunk_size</span> = whatever;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;ChunkResult&gt;&gt; <span style="color: #7590db;">results</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">begin</span>=vec.begin(), <span style="color: #7590db;">end</span>=vec.end(); beg!=end;)
    {
        <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">remaining_size</span> = end - begin;
        <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">this_chunk_size</span> = <span style="color: #a45bad;">std</span>::min(remaining_size, chunk_size);
        results.push_back(<span style="color: #a45bad;">std</span>::async(process_chunk, begin, begin+this_chunk_size));
        begin += this_chunk_size;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::async([<span style="color: #7590db;">all_results</span>=<span style="color: #a45bad;">std</span>::move(results)](){
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;ChunkResult&gt; <span style="color: #7590db;">v</span>;
        v.reserve(all_results.size());
        <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">f</span> : all_results)
        {
            v.push_back(f.get());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#20250;&#19981;&#26029;&#22320;&#38459;&#22622;&#21796;&#37266;</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> gather_results(v);
    });
}
</pre>
</div>
<p>
上面这种实现方式独立地等待每个任务，导致合并结果的线程会被反复阻塞唤醒。这不仅使合并线程被等待占满，而且还导致额外的上下文切换。使用 std::experimental::when_all 可以避免阻塞等待和频繁的上下文切换。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;FinalResult&gt; <span style="color: #bc6ec5; font-weight: bold;">process_data</span>(
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;MyData&gt;&amp; <span style="color: #7590db;">vec</span>)
{
    <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">chunk_size</span> = whatever;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;ChunkResult&gt;&gt; <span style="color: #7590db;">results</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">begin</span> = vec.begin(), <span style="color: #7590db;">end</span> = vec.end(); beg != end)
    {
        <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">remaining_size</span> = end - begin;
        <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">this_chunk_size</span> = <span style="color: #a45bad;">std</span>::min(remaining_size, chunk_size);
        results.push_back(spawn_async(process_chunk, begin, begin+this_chunk_size));
        begin += this_chunk_size;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::when_all(
        results.begin(), results.end()).then(
            [](<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;ChunkResult&gt;&gt;&gt; <span style="color: #7590db;">ready_results</span>)
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;ChunkResult&gt;&gt; <span style="color: #7590db;">all_results</span> = ready_results.get();
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;ChunkResult&gt; <span style="color: #7590db;">v</span>;
                v.reserve(all_results.size());
                <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">f</span>: all_results){
                    v.push_back(f.get()); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#19981;&#20250;&#38459;&#22622;</span>
                }
                <span style="color: #4f97d7; font-weight: bold;">return</span> gather_results(v);
            });
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga543336" class="outline-5">
<h5 id="orga543336">Waiting for the first future in a set with when_any</h5>
<div class="outline-text-5" id="text-orga543336">
<p>
假设你从一个巨大的数据集中搜索一个满足特定条件的值，如果有多个这样的值，则任何一个值都可以。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;FinalResult&gt;
<span style="color: #bc6ec5; font-weight: bold;">find_and_process_value</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;MyData&gt; &amp;<span style="color: #7590db;">data</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">concurrency</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_tasks</span> = (concurrency &gt; 0)? concurrency : 2;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">MyData</span> *&gt;&gt; <span style="color: #7590db;">results</span>;
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">chunk_size</span> = (data.size() + num_tasks - 1) / num_tasks;
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">chunk_begin</span> = data.begin();
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt;&gt; <span style="color: #7590db;">done_flag</span> = <span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt;&gt;(<span style="color: #a45bad;">false</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26631;&#35760;&#25214;&#21040;&#28385;&#36275;&#29305;&#23450;&#26465;&#20214;&#30340;&#20540;</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span> = 0; i &lt; num_tasks; ++i) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#29983;&#25104; num_tasks &#20010;&#32447;&#31243;</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">chunk_end</span> = (i &lt; (num_tasks - 1)? chunk_begin + chunk_size : data.end());
        results.push_back(spawn_async([=]{   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lambda &#20351;&#29992;copy capture&#65292;&#36825;&#26679;&#20256;&#20837;&#30340;&#21464;&#37327;&#23601;&#19981;&#20250;&#26377; lifetime &#38382;&#39064;&#20102;</span>
            <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">entry</span> = chunk_begin; <span style="color: #a45bad;">!</span>*done_flag &amp;&amp; (entry != chunk_end); ++entry)
            {
                <span style="color: #4f97d7; font-weight: bold;">if</span> (matches_find_criteria(*entry))
                {
                    *done_flag = <span style="color: #a45bad;">true</span>;
                    <span style="color: #4f97d7; font-weight: bold;">return</span> &amp;*entry;
                }
            }
            <span style="color: #4f97d7; font-weight: bold;">return</span> (<span style="color: #ce537a; font-weight: bold;">MyData</span> *)<span style="color: #a45bad;">nullptr</span>;
        }));
        chunk_begin = chunk_end;
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;FinalResult&gt;&gt; <span style="color: #7590db;">final_result</span> = <span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;FinalResult&gt;&gt;();
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">DoneCheck</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;FinalResult&gt;&gt; <span style="color: #7590db;">final_result</span>;

        <span style="color: #bc6ec5; font-weight: bold;">DoneCheck</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;FinalResult&gt;&gt; <span style="color: #7590db;">final_result_</span>)
            : final_result(<span style="color: #a45bad;">std</span>::move(final_result_)) {}

        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">when_any_result</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">MyData</span> *&gt;&gt;&gt;&gt; <span style="color: #7590db;">results_param</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">results</span> = results_param.get();
            <span style="color: #ce537a; font-weight: bold;">MyData</span> *<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ready_result</span> = results.futures[results.index].get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20174; future &#20013;&#33719;&#24471;&#23545;&#24212;&#30340;&#20540;</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span> (ready_result) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#20540;&#19981;&#20026;&#31354;&#65292;&#21017;&#24050;&#32463;&#25214;&#21040;&#31526;&#21512;&#26465;&#20214;&#30340;&#20540;</span>
            {
                final_result-&gt;set_value(<span style="color: #ce537a; font-weight: bold;">process_found_value</span>(*<span style="color: #7590db;">ready_result</span>));
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                results.futures.erase(results.futures.begin() + results.index); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31227;&#38500;&#22788;&#29702;&#36807;&#30340;&#32467;&#26524;</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>results.futures.empty()) 
                {
                    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::when_any(results.futures.begin(), results.futures.end()).then(<span style="color: #a45bad;">std</span>::move(*<span style="color: #4f97d7; font-weight: bold;">this</span>)); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#32487;&#32493;&#22788;&#29702;&#23436;&#25104;&#30340;&#20219;&#21153;</span>
                }
                <span style="color: #4f97d7; font-weight: bold;">else</span>
                {
                    final_result-&gt;set_exception(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">make_exception_ptr</span>(<span style="color: #a45bad;">std</span>::<span style="color: #7590db;">runtime_error</span>(<span style="color: #2d9574;">"Not found"</span>)));
                }
            }
        }
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::when_any(results.begin(), results.end()).then(DoneCheck(final_result));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#20219;&#20309;&#19968;&#20010;&#20219;&#21153;&#36820;&#22238;&#21518;&#65292;&#25191;&#34892;DoneCheck</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> final_result-&gt;get_future();
}
</pre>
</div>

<p>
when_all 和 when_any 函数还支持不同类型的多个 future 作为参数，此时这两个函数的返回值为 future&lt;tuple&gt;<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">f1</span>=spawn_async(func1);
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::string&gt; <span style="color: #7590db;">f2</span>=spawn_async(func2);
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">double</span>&gt; <span style="color: #7590db;">f3</span>=spawn_async(func3);
<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">tuple</span>&lt;
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt;,
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::string&gt;,
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">double</span>&gt;&gt;&gt; <span style="color: #7590db;">result</span> =
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::when_all(<span style="color: #a45bad;">std</span>::move(f1),<span style="color: #a45bad;">std</span>::move(f2),<span style="color: #a45bad;">std</span>::move(f3));
</pre>
</div>
</div>
</div>
<div id="outline-container-org244632c" class="outline-5">
<h5 id="org244632c">Latches and barriers in the Concurrency TS</h5>
<div class="outline-text-5" id="text-org244632c">
<p>
latch（门闩）是一个同步对象，但其计数减为 0 时，它的状态变为 ready。一旦其状态变为 ready 后，其会一直保持 ready 状态，直到该 latch 对象被销毁。latch 是等待一系列事件都发生的轻量级工具。同一个线程可以多次减少计数，多个线程也可以每个减少一次计数，或者前面两种情况的组合。<br />
barrier (栅栏) 是可复用的同步对象，其可用于一组线程之间的同步。每个线程在每次循环中只能有一次到达 barrier，当线程到达 barrier 后，其会被阻塞，直到所有线程都到达后，所有阻塞线程再次激活，开始下一次循环，这样 barrier 就可以被复用。<br />
</p>
</div>
<div id="outline-container-orge8a2994" class="outline-6">
<h6 id="orge8a2994">A basic latch type: std::experimental::latch</h6>
<div class="outline-text-6" id="text-orge8a2994">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;experimental/latch&gt;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">experimental</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>()
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">thread_count</span>=...;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">thread_count &#25351;&#23450;&#20102;latch&#30340;&#35745;&#25968;</span>
    <span style="color: #ce537a; font-weight: bold;">latch</span> <span style="color: #7590db;">done</span>(thread_count);
    <span style="color: #ce537a; font-weight: bold;">my_data</span> <span style="color: #7590db;">data</span>[thread_count];
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; &gt; <span style="color: #7590db;">threads</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;thread_count;++i)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38500;&#20102;i&#21464;&#37327;&#22806;&#65292;&#20854;&#20182;&#21464;&#37327;&#37117;&#26159;&#25353;&#29031;&#24341;&#29992;&#25429;&#33719;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21464;&#37327;i&#26159;&#24490;&#29615;&#20013;&#30340;&#30340;&#21464;&#37327;&#65292;&#25353;&#29031;&#24341;&#29992;&#25429;&#33719;&#20250;&#23548;&#33268;data race</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">data &#21644; done&#21464;&#37327;&#65292;&#21017;&#26159;&#38656;&#35201;&#20849;&#20139;&#30340;&#21464;&#37327;</span>
        threads.push_back(<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,[&amp;,<span style="color: #a45bad;">i</span>]{
            data[i]=make_data(i);
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992; count_down &#20943;&#23569;&#35745;&#25968;</span>
            done.count_down();
            do_more_stuff();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21644;&#19979;&#38754; process_data(data,thread_count); &#20250;&#21516;&#27493;&#25191;&#34892;</span>
        }));
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992; wait &#31561;&#24453;&#25152;&#26377;&#20107;&#20214;&#21457;&#29983;</span>
    done.wait();
    process_data(data,thread_count); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21644;&#19978;&#38754; do_more_stuff(); &#20250;&#21516;&#27493;&#25191;&#34892;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org5dd7fb8" class="outline-6">
<h6 id="org5dd7fb8">std::experimental::barrier: a basic barrier</h6>
<div class="outline-text-6" id="text-org5dd7fb8">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26500;&#36896;&#20989;&#25968; num_threads &#25351;&#23450;&#21442;&#19982;&#21516;&#27493;&#30340;&#32447;&#31243;&#25968;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">explicit std::experimental::barrier::barrier(std::ptrdiff_t num_threads);</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21040;&#36798;&#21516;&#27493;&#28857;&#24182;&#38459;&#22622;&#12290;&#35813;&#20989;&#25968;&#30340;&#35843;&#29992;&#21644;barrier&#23436;&#25104;&#38454;&#27573;&#30340;&#24320;&#22987;&#30456;&#21516;&#27493;&#12290;&#35813;&#20989;&#25968;&#30340;&#36820;&#22238;&#21644;barrier&#23436;&#25104;&#38454;&#27573;&#32467;&#26463;&#30456;&#21516;&#27493;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">void std::experimental::barrier::arrive_and_wait()</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21040;&#36798;&#21516;&#27493;&#28857;&#65292;&#24182;&#23558;&#24403;&#21069;&#32447;&#31243;&#20174;&#21442;&#19982;&#21516;&#27493;&#32447;&#31243;&#38598;&#21512;&#20013;&#31227;&#38500;&#12290;&#35813;&#20989;&#25968;&#26159;&#21542;&#38459;&#22622;&#33267;barrier&#23436;&#25104;&#38454;&#27573;&#32467;&#26463;&#26159;&#26410;&#25351;&#23450;&#30340;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#20989;&#25968;&#30340;&#35843;&#29992;&#21644;barrier&#23436;&#25104;&#38454;&#27573;&#30340;&#24320;&#22987;&#30456;&#21516;&#27493;&#12290;&#22914;&#26524;&#35813;&#20989;&#25968;&#38459;&#22622;&#65292;&#21017;&#35813;&#20989;&#25968;&#30340;&#36820;&#22238;&#21644;barrier&#23436;&#25104;&#38454;&#27573;&#32467;&#26463;&#30456;&#21516;&#27493;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">void std::experimental::barrier::arrive_and_drop()</span>

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;experimental/barrier&gt;</span>

<span style="color: #ce537a; font-weight: bold;">result_chunk</span> <span style="color: #bc6ec5; font-weight: bold;">process</span>(data_chunk);
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;data_chunk&gt;
<span style="color: #bc6ec5; font-weight: bold;">divide_into_chunks</span>(<span style="color: #ce537a; font-weight: bold;">data_block</span> <span style="color: #7590db;">data</span>, <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">num_threads</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_data</span>(<span style="color: #ce537a; font-weight: bold;">data_source</span> &amp;<span style="color: #7590db;">source</span>, <span style="color: #ce537a; font-weight: bold;">data_sink</span> &amp;<span style="color: #7590db;">sink</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">concurrency</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span> = (concurrency &gt; 0) ? concurrency : 2;

    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">barrier</span> <span style="color: #7590db;">sync</span>(num_threads);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;joining_thread&gt; <span style="color: #7590db;">threads</span>(num_threads);

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;data_chunk&gt; <span style="color: #7590db;">chunks</span>;
    <span style="color: #ce537a; font-weight: bold;">result_block</span> <span style="color: #7590db;">result</span>;

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span> = 0; i &lt; num_threads; ++i)
    {
        threads[i] = joining_thread([&amp;, <span style="color: #a45bad;">i</span>]
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25968;&#25454;&#27809;&#26377;&#20840;&#37096;&#22788;&#29702;&#23436;&#65292;&#24320;&#22987;&#19979;&#19968;&#27425;&#24490;&#29615;</span>
            <span style="color: #4f97d7; font-weight: bold;">while</span> (<span style="color: #a45bad;">!</span>source.done())
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i==0 &#30340;&#32447;&#31243;&#23558; block &#20998;&#35299;&#20026;&#22810;&#20010; chunk</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>i)
                {
                    <span style="color: #ce537a; font-weight: bold;">data_block</span> <span style="color: #7590db;">current_block</span> = source.get_next_data_block();
                    chunks = divide_into_chunks(current_block, num_threads);
                }
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i!=0 &#30340;&#32447;&#31243;&#31561;&#24453; i==0 &#30340;&#32447;&#31243;&#65292;&#25152;&#26377;&#32447;&#31243;&#20840;&#37096;&#21040;&#36798;&#21518;&#65292;&#37325;&#32622;barrier&#65292;&#24320;&#22987;&#19979;&#19968;&#27425;&#21516;&#27493;</span>
                sync.arrive_and_wait();
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21508;&#20010;&#32447;&#31243;&#23436;&#25104;&#21508;&#33258;&#30340;&#25968;&#25454;&#22788;&#29702;</span>
                result.set_chunk(i, num_threads, process(chunks[i]));
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i==0 &#30340;&#32447;&#31243;&#31561;&#24453; i!=0 &#30340;&#32447;&#31243;&#65292;&#25152;&#26377;&#32447;&#31243;&#20840;&#37096;&#21040;&#36798;&#21518;&#65292;&#37325;&#32622;barrier&#65292;&#24320;&#22987;&#19979;&#19968;&#27425;&#21516;&#27493;</span>
                sync.arrive_and_wait();
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i==0 &#30340;&#32447;&#31243;&#23558;&#22788;&#29702;&#32467;&#26524;&#20889;&#20837; sink</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>i)
                {
                    sink.write_data(<span style="color: #a45bad;">std</span>::move(result));
                }
            }
        });
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd201d81" class="outline-6">
<h6 id="orgd201d81">std::experimental::flex_barrier—std::experimental::barrier’s flexible friend</h6>
<div class="outline-text-6" id="text-orgd201d81">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_data</span>(<span style="color: #ce537a; font-weight: bold;">data_source</span> &amp;<span style="color: #7590db;">source</span>, <span style="color: #ce537a; font-weight: bold;">data_sink</span> &amp;<span style="color: #7590db;">sink</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">concurrency</span> = <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span> = (concurrency &gt; 0) ? concurrency : 2;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;data_chunk&gt; <span style="color: #7590db;">chunks</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#27809;&#26377;&#22788;&#29702;&#23436;&#25968;&#25454;&#65292;&#21017;&#33719;&#24471;&#19979;&#19968;&#20010;&#35201;&#22788;&#29702;&#30340;block&#65292;&#23558;&#35813;block&#20998;&#35299;&#20026;num_threads &#20010;chunk</span>
    <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">split_source</span> = [&amp;] {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>source.done())
        {
            <span style="color: #ce537a; font-weight: bold;">data_block</span> <span style="color: #7590db;">current_block</span> = source.get_next_data_block();
            chunks = divide_into_chunks(current_block, num_threads);
        }
    };
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#31532;&#19968;&#27425;&#20998;&#35299;</span>
    split_source();

    <span style="color: #ce537a; font-weight: bold;">result_block</span> <span style="color: #7590db;">result</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">flex_barrier &#26500;&#36896;&#20989;&#25968;&#21487;&#20197;&#26377;&#20004;&#20010;&#21442;&#25968;&#65292;&#31532;&#19968;&#20010;&#21442;&#25968;&#20026;&#21442;&#19982;&#21516;&#27493;&#30340;&#32447;&#31243;&#25968;&#37327;&#65292;&#31532;&#20108;&#20010;&#21442;&#25968;&#20026;&#23436;&#25104;&#20989;&#25968;(&#21487;&#20197;&#20026;&#20219;&#24847;&#21487;&#35843;&#29992;&#23545;&#35937;)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#25152;&#26377;&#32447;&#31243;&#37117;&#21040;&#36798;&#21516;&#27493;&#28857;&#21518;&#65292;&#20250;&#22312;&#24403;&#21069;&#32447;&#31243;&#35843;&#29992;&#23436;&#25104;&#20989;&#25968;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">flex_barrier</span> <span style="color: #7590db;">sync</span>(num_threads, [&amp;] {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#25152;&#26377;&#32447;&#31243;&#22788;&#29702;&#21518;&#30340;&#25968;&#25454;&#20889;&#20837; sink</span>
        sink.write_data(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">result</span>));
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029;&#25968;&#25454;&#26159;&#21542;&#22788;&#29702;&#23436;&#25104;&#65292;&#22914;&#26524;&#27809;&#26377;&#23436;&#25104;&#65292;&#21017;&#32487;&#32493;&#22788;&#29702;</span>
        split_source();
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36820;&#22238;&#19979;&#19968;&#27425;&#21442;&#19982;&#21516;&#27493;&#30340;&#32447;&#31243;&#25968;&#37327;&#65292;-1&#34920;&#31034;&#25968;&#37327;&#19981;&#21464;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> -1;
    });
    
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;joining_thread&gt; <span style="color: #7590db;">threads</span>(num_threads);
    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span> = 0; i &lt; num_threads; ++i)
    {
        threads[i] = joining_thread([&amp;, <span style="color: #a45bad;">i</span>] {
            <span style="color: #4f97d7; font-weight: bold;">while</span> (<span style="color: #a45bad;">!</span>source.done())
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22788;&#29702;&#20998;&#37197;&#32473;&#24403;&#21069;&#32447;&#31243;&#30340; chunk</span>
                result.set_chunk(i, num_threads, process(chunks[i]));
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31561;&#24453;&#20854;&#20182;&#32447;&#31243;&#23436;&#25104;</span>
                sync.arrive_and_wait();
            }
        });
    }
}
</pre>
</div>
<p>
std::experimental::flex_barrier 的完成函数可以修改参与线程的数量。这可用于实现 pipeline 风格的代码。线程数量在管线初始化填充阶段和管线最后排空阶段都比管线主要处理阶段要少。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org94ed662" class="outline-3">
<h3 id="org94ed662">05 The C++ memory model and operations on atomic types</h3>
<div class="outline-text-3" id="text-org94ed662">
<p>
designing lock-based concurrent data structures<br />
多线程感知的内存模型(multithreading-aware memory model)是 c++标准最重要的特性之一。如果没有内存模型准确定义基本构建块是如何工作的，则无法实现前面章节使用的各种工具(mutexes condition_variables futures latches barriers)。<br />
</p>
</div>
<div id="outline-container-org758cb27" class="outline-4">
<h4 id="org758cb27">Memory model basics</h4>
<div class="outline-text-4" id="text-org758cb27">
<p>
可以从两个角度来看内存模型：结构的角度和并发的角度。结构的角度看内存模型，主要考虑数据在内存中是如何分布的。从结构角度考虑内存模型对于并发来说是非常重要的，特别是分析低级的原子操作时。<br />
</p>
</div>
<div id="outline-container-orga126221" class="outline-5">
<h5 id="orga126221">Objects and memory locations</h5>
<div class="outline-text-5" id="text-orga126221">
<p>
c++ 程序中的所有数据都是由对象组成的，这里并不是说你可以从 int 派生一个新类，也不是说基础类型有成员函数，总之此处并不是面向对象编程中所说的一切皆对象。此处是说，c++中数据的构建块是对象。c++标准将一个对象定义为一个存储区域，c++标准还会为对象赋予各种属性，如类型、生命周期等等。<br />
一些对象属于基础类型，例如 int 或 float。而另一些对象则属于用户自定义类型。一些对象（如数组对象，派生类对象）包含子对象，另一些则没有子对象。无论对象的类型是什么，一个对象都会被存储到一个或多个内存位置。下图展示了一个结构体被划分为对象和内存位置。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">my_data</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>;
    <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">d</span>;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">bf1</span>       :10;
    <span style="color: #ce537a; font-weight: bold;">int</span>      <span style="color: #7590db;">bf2</span>       :23;
    <span style="color: #ce537a; font-weight: bold;">int</span>      <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">bf3</span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>   :0;
    <span style="color: #ce537a; font-weight: bold;">int</span>      <span style="color: #7590db;">bf4</span>       :5;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i2</span>;
    <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">c1</span>,<span style="color: #7590db;">c2</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">s</span>;
};
</pre>
</div>
<p>
<img src="./AsynchronousProgramming/05_01_01_struct_object_memory_locations.jpg" alt="05_01_01_struct_object_memory_locations.jpg" /><br />
整个结构体是一个对象，其包含多个子对象，每个数据成员也为一个对象。bf1 和 bf2 两个 bit fields 共享一个内存位置。std::string 类型的 s 对象由多个内存位置组成。c++规定占用位数为 0 的位域不能被命名，因此 bf3 必须被注释掉。另外，bf3 会将位域共享隔断，使得 bf4 不能和 bf2 共享一个内存位置。<br />
总之：<br />
</p>
<ul class="org-ul">
<li>每个变量都是一个对象。对象的成员变量也是对象。<br /></li>
<li>每个对象至少占用一个内存位置。<br /></li>
<li>基础类型的变量刚好占用一个内存位置，无论其大小如何，即使他们是相邻的或者是数组的一部分。<br /></li>
<li>相邻的位域(bit fields)共享同一个内存位置。<br /></li>

<li><a href="https://en.cppreference.com/w/cpp/language/bit_field">https://en.cppreference.com/w/cpp/language/bit_field</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org59c9b1d" class="outline-5">
<h5 id="org59c9b1d">Objects, memory locations, and concurrency</h5>
<div class="outline-text-5" id="text-org59c9b1d">
<p>
对于 c++ 多线程应用程序来说，至关重要的是所有的一切都取决于内存位置。如果两个线程访问分开的内存位置，则没有问题。如果两个线程访问相同的内存位置，则需要倍加小心。如果这两个线程没有更新内存位置中的内容，也不会出问题；只读的数据不需要保护或同步。如果任何其中一个线程修改数据，就会有机会出现 race condition。<br />
</p>

<p>
为了避免 race condition，两个线程对同一个内存位置的访问必须有强制排序。该顺序可以是固定的顺序，如线程 A 总是在线程 B 之前访问，也可以是不固定的，有时 A 线程先访问，有时 B 线程先访问，但是必须保证有某个确定的访问顺序(确保不会同时访问)。使用 mutex 可以保证有一个确定的访问顺序；使用 mutex 保护一个内存位置时，同一时间只有一个线程可以访问该内存位置，因此，多个线程之间必定有一个先后顺序。另一种方式是使用原子操作的同步属性来对两个线程的访问进行强制排序。如果多个线程同时访问同一个内存位置，任意两个线程的访问必须有某个确定的访问顺序。<br />
</p>

<p>
如果两个线程对同一个内存位置的访问没有被强制排序，并且两个访问中有任意一个不是原子的，并且两个访问中有任意一个是写操作，则这种情况属于 data race，会导致未定义行为。<br />
</p>
</div>
</div>
<div id="outline-container-orgf01cac6" class="outline-5">
<h5 id="orgf01cac6">Modification orders</h5>
<div class="outline-text-5" id="text-orgf01cac6">
<p>
C++ 程序中的每个对象都有一个修改顺序，该修改顺序由程序中所有线程对该对象的所有写入组成，这些写入操作从对象的初始化开始。在大多数情况下，每次执行之间该修改顺序会有所不同，但是程序的在给定执行中，系统的所有线程必须对该修改次序达成一致。如果对象类型不是原子类型，则你有责任确保线程对每个变量的修改顺序达成一致。 如果不同的线程看到单个变量的不同值序列，则存在 data races 和未定义行为。 如果你确实使用了原子操作，则编译器负责确保在恰当的地方实施必要的同步。<br />
</p>

<p>
这个要求意味着某些类型的预测执行是不被允许的，因为一旦一个线程看到了修改顺序中的特定条目，从该线程的后续读取必须返回后面的值，并且从该线程对该对象的后续写入必须发生在修改顺序的后面。 此外，在同一线程中写入该对象之后对该对象的读取必须返回写入的值或在该对象的修改顺序中稍后出现的另一个值。尽管所有线程必须对程序中每个单独对象的修改顺序达成一致，但它们不必对多个对象上操作的相对顺序达成一致。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge60e390" class="outline-4">
<h4 id="orge60e390">Atomic operations and types in C++</h4>
<div class="outline-text-4" id="text-orge60e390">
<p>
原子操作是不可分割的操作。在系统中的任何一个线程中，你都不会观察到该操作只完成了一半的情况。原子操作要么没完成，要么完成。如果读取某个对象的值的操作是原子的，并且所有修改该对象的操作也是原子的，则读取该对象的值时，要么获得对象初始的值，要么获得某个修改操作存入该对象的值。<br />
</p>

<p>
原子操作的反面就是非原子操作，非原子操作意味着可以观察到操作只完成了一半的情况。如果非原子操作是由多个原子操作组成的（例如，对一个结构体进行赋值，该结构体的所有成员都是原子类型的），此时其他线程可能会观察到一部分原子操作已经完成，而另一部分原子操作还没开始。在任何情况下，未同步访问非原子变量会导致有问题的 race condition，而且其可能构成一个 data race，进而导致未定义行为。<br />
</p>
</div>
<div id="outline-container-orge357067" class="outline-5">
<h5 id="orge357067">The standard atomic types</h5>
<div class="outline-text-5" id="text-orge357067">
<p>
c++标准原子类型被放置在&lt;atomic&gt;头文件中。在这些类型上的操作都是原子的，这里所说的操作是原子的是指 c++语言定义意义上的原子性，并不是 cpu 指令的原子性。你可以使用 mutexes 使得操作看起来是原子的。c++标准的原子类型都提供了 is_lock_free() 成员函数，如果原子类型的操作是直接通过原子指令实现的，则返回 true；如果是通过使用编译器和 libarary 内部的锁实现的，则返回 false。<br />
</p>

<p>
使用原子操作的主要用途是代替用 mutex 来同步非原子操作，从而提高性能。如果原子操作自身实现使用了内部的 mutex，则可能并不会提升性能，还不如直接使用更简单的基于 mutex 的实现方式。<br />
</p>

<p>
c++ 标准库提供了一系列宏，其可以在编译期确定各种整型对应的原子类型是否是 lock-free 的。从 c++17 开始，所有原子类型都有一个 static constexpr 成员变量: X::is_always_lock_free，当原子类型 X 对于所有支持的平台都是 lock-free 时，该成员变量的值才为 true。ATOMIC_BOOL_LOCK_FREE , ATOMIC_CHAR_LOCK_FREE , ATOMIC_CHAR16_T_LOCK_FREE , ATOMIC_CHAR32_T_LOCK_FREE ，ATOMIC_WCHAR_T_LOCK_FREE，ATOMIC_SHORT_LOCK_FREE , ATOMIC_INT_LOCK_FREE , ATOMIC_LONG_LOCK_FREE , ATOMIC_LLONG_LOCK_FREE 和 ATOMIC_POINTER_LOCK_FREE。前面这些宏指定了原子类型的 lock-free 状态，宏的值为 0 表示原子类型永远不是 lock-free 的; 值为 2 表示原子类型总是 lock-free 的; 值为 1 表示 lock-free 状态为运行时属性。<br />
</p>

<p>
唯一没有提供 is_lock_free 成员函数的原子类型是 std::atomic_flag。该类是一个简单的 Boolean 标记，该类上的操作要求必须为 lock-free 的。说它简单是指 std::atomic_flag 类型的对象初始化是被清除的，对象只能被查询并设置(使用 test_and_set() 成员函数)，以及清除(使用 clear()成员函数)。不支持赋值、copy 构造、查询并清除(test_and_clear)等等。<br />
</p>

<p>
其他所有原子类型都是通过特化模板类 std::atomic&lt;&gt; 来访问的。在大多数流行的平台上，所有内置类型的原子变体确实是无锁的，但这不是必需的。模板类 std::atomic&lt;&gt; 的每种特化版本的接口都反应了对应类型的属性，例如位操作&amp;=对于普通的指针类型是未定义的，因此，指针类型对应的原子类型也不会定义这些位操作。<br />
</p>

<p>
除了直接使用 std::atomic&lt;&gt;模板外，也可以使用在下表中所示的原子类型备选名称。由于历史原因，这些原子类型备选名可能引用相应的 std::atomic&lt;&gt;特化类型，也可能引用特化类型的基类。因此，同一程序中混合使用备选名与 std::atomic&lt;&gt;特化类名，会导致代码不可移植。但是，从 c++17 开始，备选名称都引用相应的 std::atomic&lt;&gt;特化类型。<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">原子类型 替代名称/备选名称</th>
<th scope="col" class="org-left">特化版本的原子类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">atomic_bool</td>
<td class="org-left">std::atomic&lt;bool&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_char</td>
<td class="org-left">std::atomic&lt;char&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_schar</td>
<td class="org-left">std::atomic&lt;signed char&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_uchar</td>
<td class="org-left">std::atomic&lt;unsigned char&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_int</td>
<td class="org-left">std::atomic&lt;int&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_uint</td>
<td class="org-left">std::atomic&lt;unsigned&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_short</td>
<td class="org-left">std::atomic&lt;short&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_ushort</td>
<td class="org-left">std::atomic&lt;unsigned short&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_long</td>
<td class="org-left">std::atomic&lt;long&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_ulong</td>
<td class="org-left">std::atomic&lt;unsigned long&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_llong</td>
<td class="org-left">std::atomic&lt;long long&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_ullong</td>
<td class="org-left">std::atomic&lt;unsigned long long&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_char16_t</td>
<td class="org-left">std::atomic&lt;char16_t&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_char32_t</td>
<td class="org-left">std::atomic&lt;char32_t&gt;</td>
</tr>

<tr>
<td class="org-left">atomic_wchar_t</td>
<td class="org-left">std::atomic&lt;wchar_t&gt;</td>
</tr>
</tbody>
</table>

<p>
c++标准库还提供了一系列原子类型的 typedefs，他们和非原子类型的 typedefs 对应如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">原子类型的 typedefs</th>
<th scope="col" class="org-left">非原子类型的 typedefs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">atomic_int_least8_t</td>
<td class="org-left">int_least8_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_least8_t</td>
<td class="org-left">uint_least8_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_least16_t</td>
<td class="org-left">int_least16_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_least16_t</td>
<td class="org-left">uint_least16_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_least32_t</td>
<td class="org-left">int_least32_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_least32_t</td>
<td class="org-left">uint_least32_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_least64_t</td>
<td class="org-left">int_least64_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_least64_t</td>
<td class="org-left">uint_least64_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_fast8_t</td>
<td class="org-left">int_fast8_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_fast8_t</td>
<td class="org-left">uint_fast8_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_fast16_t</td>
<td class="org-left">int_fast16_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_fast16_t</td>
<td class="org-left">uint_fast16_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_fast32_t</td>
<td class="org-left">int_fast32_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_fast32_t</td>
<td class="org-left">uint_fast32_t</td>
</tr>

<tr>
<td class="org-left">atomic_int_fast64_t</td>
<td class="org-left">int_fast64_t</td>
</tr>

<tr>
<td class="org-left">atomic_uint_fast64_t</td>
<td class="org-left">uint_fast64_t</td>
</tr>

<tr>
<td class="org-left">atomic_intptr_t</td>
<td class="org-left">intptr_t</td>
</tr>

<tr>
<td class="org-left">atomic_uintptr_t</td>
<td class="org-left">uintptr_t</td>
</tr>

<tr>
<td class="org-left">atomic_size_t</td>
<td class="org-left">size_t</td>
</tr>

<tr>
<td class="org-left">atomic_ptrdiff_t</td>
<td class="org-left">ptrdiff_t</td>
</tr>

<tr>
<td class="org-left">atomic_intmax_t</td>
<td class="org-left">intmax_t</td>
</tr>

<tr>
<td class="org-left">atomic_uintmax_t</td>
<td class="org-left">uintmax_t</td>
</tr>
</tbody>
</table>

<p>
标准的原子类型是不可 copy 或赋值的，因为他们没有 copy 构造函数或 copy 赋值运算符。但是，支持显示转化为对应内置类型，也支持使用对应内置类型为原子类型赋值，这些操作对应于 load() store() exchange() compare_exchange_weak() compare_exchange_strong() 函数。也支持类似+=，-=，*=，|=这样的组合赋值操作，以及适用于整型和指针类型的++，&#x2013;组合赋值操作。这些操作对应于 fetch_add() fetch_or() 等函数。这些函数返回值要么是当前存储的值，要么是之前存储的值，这避免了一些潜在的问题。通常这些赋值运算符原本应该返回被赋值对象的引用，但是，为了获得引用所指对象中存储的值，代码必须执行一次单独的读取，而其他线程可以在赋值和读取之间修改对象中存储的值，这会导致 race condition，所以原子类型的操作直接返回值而不是引用。<br />
</p>

<p>
std::atomic&lt;&gt; 类模板不只是一组特化版本的类。其也是一个原始模板，使用该模板类可以创建一个用户自定义的原子类型。因为其为泛型类模板，操作被限定为 load(), store(), exchange(), compare_exchange_weak(), 以及 compare_exchange_strong().<br />
</p>

<p>
原子类型的每个操作都有一个可选的 memory-ordering 参数，该参数为 std::memory_order 枚举类型。std::memory_order 枚举类型包含 6 个枚举值：std::memory_order_relaxed, std::memory_order_acquire, std::memory_order_consume, std::memory_order_acq_rel, std::memory_order_release, std::memory_order_seq_cst。如果没有指定任何枚举值，则使用默认的 std::memory_order_seq_cst。可以将原子操作分成下面 3 类，每类操作只能使用对应的几个 std::memory_order 枚举值:<br />
</p>
<ul class="org-ul">
<li>Store 类型操作。该类型操作可以使用 memory_order_relaxed, memory_order_release, memory_order_seq_cst<br /></li>
<li>Load 类型操作。该类型操作可以使用 memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_seq_cst<br /></li>
<li>Read-modify-write 类型操作。该类型操作可以使用 memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgfa93f98" class="outline-5">
<h5 id="orgfa93f98">Operations on std::atomic_flag</h5>
<div class="outline-text-5" id="text-orgfa93f98">
<p>
std::atomic_flag 是标准库中最简单的原子类型，其表示一个 Boolean 标签。std::atomic_flag 类型的对象只有两个状态：设置和清除。故意将其设计的很基础，目的就是作为一个基础构建块。<br />
</p>

<p>
必须使用 ATOMIC_FLAG_INIT 来初始化 std::atomic_flag 类型的对象，这会将其初始化为 clear 状态，Tips：无法将其初始化为其他状态。如果 std::atomic_flag 对象是静态变量，其会被静态初始化，这意味着不会有初始化顺序问题，其总会被第一次执行的操作初始化。std::atomic_flag 对象被初始化后，就可以在其上执行 3 种操作：销毁（对应析构函数），清除（对应 clear()成员函数）以及设置并查询前一次值（对应 test_and_set()成员函数）。你不能使用一个 std::atomic_flag 对象来 copy 构造另一个 std::atomic_flag 对象。这并非只适用于 std::atomic_flag 类型，对于所有原子类型都适用。原子类型上的所有操作都是原子的，而赋值和 copy 构造会涉及到两个对象。作用到两个不同对象的单个操作不可能是原子的，以赋值和 copy 构造操作来说，其必须先从一个对象读取值，然后再写入到另一个对象，这至少涉及到两个 cpu 指令。<br />
</p>

<p>
利用 std::atomic_flag 可以实现 spinlock mutex(自旋锁)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">spinlock_mutex</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic_flag</span> <span style="color: #7590db;">flag</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">spinlock_mutex</span>(): <span style="color: #bc6ec5; font-weight: bold;">flag</span>(ATOMIC_FLAG_INIT) {}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>()
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;flag&#26159;&#21542;&#34987;&#35774;&#32622;&#65288;&#21363;flag&#26159;&#21542;&#20026;true&#65289;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33509;&#34987;&#35774;&#32622;&#30452;&#25509;&#36820;&#22238;true&#65292;&#33509;&#27809;&#26377;&#35774;&#32622;&#21017;&#35774;&#32622;flag&#20026;true&#21518;&#20877;&#36820;&#22238;false</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(flag.test_and_set(<span style="color: #a45bad;">std</span>::memory_order_acquire));
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28165;&#38500;flag&#26631;&#24535;&#21363;flag=false</span>
        flag.clear(<span style="color: #a45bad;">std</span>::memory_order_release);
    }
};
</pre>
</div>

<p>
上面实现的 spinlock_mutex 虽然比较基础，但是已经可以配合 std::lock_guard&lt;&gt;一起使用。不过其本质上是一个忙等的锁，从效率上来看，是一个不好的选择。<br />
</p>
</div>
</div>
<div id="outline-container-org27fa669" class="outline-5">
<h5 id="org27fa669">Operations on std::atomic&lt;bool&gt;</h5>
<div class="outline-text-5" id="text-org27fa669">
<p>
最基本的整型原子类型是 std::atomic&lt;bool&gt;. 比起 std::atomic_flag，std::atomic&lt;bool&gt; 是提供了更加完整特性的 Boolean 标签。其支持如下额外的成员函数：<br />
</p>
<ul class="org-ul">
<li>load()                 读取值。属于 load 操作<br /></li>
<li>store(desiredValue)    写入值。属于 store 操作<br /></li>
<li>exchange(desiredValue) 写入值并返回原始值。属于 read-modify-write 操作<br /></li>
<li>compare_exchange_strong(expectedValue, desiredValue)  比较原始值和预期值来决定写入。属于 read-modify-write 操作<br /></li>
<li>compare_exchange_weak(expectedValue, desiredValue)  比较原始值和预期值来决定写入。属于 read-modify-write 操作<br /></li>
</ul>
</div>
<div id="outline-container-orgf513b3e" class="outline-6">
<h6 id="orgf513b3e">compare-exchange</h6>
<div class="outline-text-6" id="text-orgf513b3e">
<p>
compare-exchange 操作是原子类型编程的基石。其会比较原始值和预期值(expected value)，如果他们相等，则会将需要的值(desired value)写入，并返回 true；如果他们不相等，会使用原始值来更新预期值，并返回 false。<br />
</p>

<p>
对于 compare_exchange_weak 函数来说，当原始值和预期值相等时，也可能会写入失败。这很可能发生在缺乏单个 compare-and-exchange 指令的机器上，此时处理器无法保证指令被原子地执行，执行完比较后线程被调度出去，另一个线程之前判断出原始值和预期值不同，此时被调度进来继续执行就会返回 false。这种失败被称为假性失败，因为失败的原因是函数的执行时机导致的，而不是变量的值不相等导致的。因为 compare_exchange_weak 函数可能会假性失败，因此通常必须循环进行判断：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">expected</span>=<span style="color: #a45bad;">false</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">b</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set somewhere else</span>
<span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>b.compare_exchange_weak(expected,<span style="color: #a45bad;">true</span>) &amp;&amp; <span style="color: #a45bad;">!</span>expected);
</pre>
</div>
<p>
对于 compare_exchange_strong 函数来说，其可以保证只有原始值和预期值不同时才会写入失败，返回 false。<br />
</p>

<p>
如果你想修改变量而不论初始值是什么，那么更新预期值就变得很有用。每次进入循环，预期值都会被重新加载，因此，如果没有其他线程修改该值，compare_exchange_weak() 或 compare_exchange_strong() 的调用，会在下次循环时返回 true。若被存储的值的计算很简单，使用 compare_exchange_weak 可能更有益；若被存储的值的计算比较耗时，可能使用 compare_exchange_strong g 更合适，当预期值不变时，其可以避免对存储值的重新计算。对 std::atomic&lt;bool&gt; 来说，他们的差异并不重要，因为其只有两种可能的值，但是对于更大的原子类型来说，他们的差异会导致很大不同。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11">https://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11</a><br /></li>
</ul>

<p>
compare-exchange 函数可以有两个 memory_order 参数，用于分别指定写入成功时和失败时的内存模型。可能希望在调用成功时使用 memory_order_acq_rel 语义，在调用失败时使用 memory_order_relaxed 语义。如果不指定内存模型，则使用默认的 memory_order_seq_cst。<br />
</p>

<p>
Tips: std::atomic&lt;bool&gt; 可能不是 lock-free 的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd5de9aa" class="outline-5">
<h5 id="orgd5de9aa">Operations on std::atomic&lt;T*&gt;: pointer arithmetic</h5>
<div class="outline-text-5" id="text-orgd5de9aa">
<p>
std::atomic&lt;T*&gt; 是指针原子类型。除了和 std::atomic&lt;bool&gt; 一样的接口外，其还包含如下指针算术操作接口：<br />
</p>
<ul class="org-ul">
<li>fetch_add   执行地址增加操作，返回原始地址值. 也被称为 exchange-and-add 操作，属于 read-modify-write 操作。<br /></li>
<li>fetch_sub   执行地址减少操作，返回原始地址值. 也被称为 exchange-and-sub 操作，属于 read-modify-write 操作。<br /></li>
<li>+= 执行地址增加操作，返回新地址<br /></li>
<li>-= 执行地址减少操作，返回新地址<br /></li>
<li>++ pre-increment post-increment<br /></li>
<li>&#x2013; pre-decrement post-decrement<br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Foo</span>{};
<span style="color: #ce537a; font-weight: bold;">Foo</span> <span style="color: #7590db;">some_array</span>[5];
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">Foo</span>*&gt; <span style="color: #bc6ec5; font-weight: bold;">p</span>(some_array);
<span style="color: #ce537a; font-weight: bold;">Foo</span>* <span style="color: #7590db;">x</span>=p.fetch_add(2);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">p&#21152;2&#65292;&#24182;&#36820;&#22238;&#21407;&#22987;&#20540;</span>
assert(x==some_array);
assert(p.load()==&amp;some_array[2]);

x=(p-=1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">p&#20943;1&#65292;&#24182;&#36820;&#22238;&#26032;&#20540;</span>
assert(x==&amp;some_array[1]);
assert(p.load()==&amp;some_array[1]);
</pre>
</div>

<p>
fetch_add fetch_sub 都是 read-modify-write 操作，因此可以使用任意一个 memory-ordering 作为参数。无法为操作符形式的操作指定 memory-ordering，因为他们没有 memory-ordering 参数，因此操作符形式的操作使用默认的 memory_order_seq_cst。<br />
</p>
</div>
</div>
<div id="outline-container-org9d97a85" class="outline-5">
<h5 id="org9d97a85">Operations on standard atomic integral types</h5>
<div class="outline-text-5" id="text-org9d97a85">
<p>
原子整型类型如 std::atomic&lt;int&gt;和 std::atomic&lt;unsigned long long&gt;有相当全面的一整套可用的操作：fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()，还有复合赋值形式的操作(\+=, -<code>, &amp;</code>, |=和^=)，以及++和&#x2013;。但不包括除法、乘法和移位操作符。因为原子整数值通常用作计数器或位掩码，所以这也不是一个特别明显的损失；如果需要的话，可以在循环中使用 compare_exchange_weak()轻松完成其他操作。<br />
</p>
</div>
</div>
<div id="outline-container-orgd52d633" class="outline-5">
<h5 id="orgd52d633">The std::atomic&lt;&gt; primary class template</h5>
<div class="outline-text-5" id="text-orgd52d633">
<p>
元模板类 std::atomic&lt;&gt; 可用于实现用户自定义的原子类型。给定用于自定义类型 UDT，std::atomic&lt;UDT&gt; 提供了和 std::atomic&lt;bool&gt; 一样的接口。你无法为任意用户自定义类创建对应的原子类型，为了创建用户自定义类的原子类型，用户自定义类型必须有一个 trivial copy 赋值操作符。这意味着用户自定义的类不能包含虚函数或虚基类，其必须使用编译器生成的 copy 赋值操作符，并且每个基类以及非静态成员都需要使用 trivial copy 赋值操作符。这样就可以允许编译器使用 memcpy()或等价的操作来执行赋值操作，赋值操作中就不会有用户代码执行(持有锁时，不要去执行用户代码)。<br />
</p>

<p>
值得注意的是，compare-exchange 操作执行逐位比较(就如使用 memcmp)，而不是使用用户自定义的比较操作符。如果类型提供的比较操作和逐位比较的语义不同，或者类型有一些位填充不参与正常的比较，则即使比较操作得出值相等，也能导致 compare-exchange 操作失败。<br />
</p>

<p>
之所以添加这些限制，其背后原因就是不要将受保护数据的指针和引用传递到锁区域之外。通常编译器无法为用户自定义类型生成 lock-free 的原子类型，因此会为所有操作使用内部锁。如果允许用户提供 copy 赋值操作或比较操作，这就需要传递被保护数据的引用给用户提供的函数。此外，库完全可以自由地对所有需要锁的原子操作使用单个锁，允许在持有该锁的同时调用用户提供的函数可能会导致死锁或因为比较操作花费了很长时间从而导致其他线程阻塞。最后，这些限制增加了编译器直接为 std::atomic&lt;UDT&gt;使用原子指令的机会(并使特定的实例化无锁)，因为它可以将用户自定义的类型视为一组原始字节。<br />
</p>

<p>
尽管内置的浮点数（float double）满足可以使用 memcpy 和 memcmp 执行赋值和比较的条件，std::atomic&lt;float&gt;和 std::atomic&lt;double&gt; 的 compare_exchange_strong 的行为可能依然令人感到惊讶。如果原子类型对象存储的浮点值和预期值有不同的表示形式，即使这两个值相等 compare_exchange_strong 依然会返回 false。另外需要注意的是，在浮点数上，不存在原子操作的算术运算。使用用户自定义的原子类型时，也会遇到类似情况。如果用户类型定义的相等比较操作和 memcmp 不同，则 memcmp 会因为相等值有不同的表示而返回 false。<br />
</p>

<p>
如果用户类 UDT 的大小和 int 或 void*相等或者更小，大多数平台可以为 std::atomic&lt;UDT&gt;使用原子指令。有些平台可以为大小为 int 或 void*尺寸的两倍的用户类使用原子指令，这些平台通常支持一种被称为 double-word-compare-and-swap 的指令。<br />
</p>

<p>
你不能创建诸如 std::atomic&lt;std::vector&lt;int&gt;&gt; 这样的原子类（因为其有一个 non-trivial copy 构造函数和 copy 赋值操作符），但是用户类包含计数、标记、指针甚至简单类型数据的数组是可以的。<br />
</p>

<p>
下图展示了各种原子类型所支持的操作：<br />
<img src="./AsynchronousProgramming/05_02_05_atomic_interface.jpg" alt="05_02_05_atomic_interface.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-org384c3f0" class="outline-5">
<h5 id="org384c3f0">Free functions for atomic operations</h5>
<div class="outline-text-5" id="text-org384c3f0">
<p>
为了兼容 c 语言编译，标准库还支持 free function 形式的原子操作。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::atomic_store(&amp;atomic_var,new_value);
<span style="color: #a45bad;">std</span>::atomic_store_explicit(&amp;atomic_var,new_value,<span style="color: #a45bad;">std</span>::memory_order_release);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#36820;&#22238;&#20540;&#30456;&#21516;</span>
<span style="color: #a45bad;">std</span>::atomic_is_lock_free(&amp;a);
a.is_lock_free();

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">atomic_flag &#23545;&#24212;&#30340; free function&#22914;&#19979;&#65292;&#21517;&#31216;&#20013;&#21253;&#21547;&#20102;flag</span>
<span style="color: #a45bad;">std</span>::atomic_flag_test_and_set();
<span style="color: #a45bad;">std</span>::atomic_flag_test_and_set_explicit()
</pre>
</div>

<p>
c++标准库为访问 std::shared_ptr&lt;&gt;实例提供了原子风格的自由函数。这违反了只有原子类型才支持原子操作的原则，而 std::shared_ptr&lt;&gt;并不是原子类型。但是，c++标准委员会认为提供这些额外的函数是非常重要的。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;my_data&gt; <span style="color: #7590db;">p</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process_global_data</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36824;&#21487;&#20197;&#20351;&#29992; std::atomic_load_explicit &#29256;&#26412;&#26469;&#25351;&#23450; memory-ordering</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21516;&#26679;&#21487;&#20197;&#20351;&#29992; std::atomic_is_lock_free(&amp;p) &#26469;&#21028;&#26029;&#65292;&#23454;&#29616;&#26159;&#21542;&#26159;lock-free&#30340;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;my_data&gt; <span style="color: #7590db;">local</span>=<span style="color: #a45bad;">std</span>::atomic_load(&amp;p);
    process_data(local);
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update_global_data</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;my_data&gt; <span style="color: #7590db;">local</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">my_data</span>);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36824;&#21487;&#20197;&#20351;&#29992; std::atomic_store_explicit &#29256;&#26412;&#26469;&#25351;&#23450; memory-ordering</span>
    <span style="color: #a45bad;">std</span>::atomic_store(&amp;p,local);
}
</pre>
</div>

<p>
Concurrency TS 还提供了 std::experimental::atomic_shared_ptr&lt;T&gt; 原子类型。要使用它，必须包含&lt;experimental/atomic&gt;头文件。它提供了和 std::atomic&lt;UDT&gt;一样的操作集合：load，store，exchange，compare-exchange。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd950162" class="outline-4">
<h4 id="orgd950162">Synchronizing operations and enforcing ordering</h4>
<div class="outline-text-4" id="text-orgd950162">
<p>
假设你有两个线程，一个用于填充数据，另一个读取。为了避免有问题的 race condition, 第一个线程会设置一个标记用于指示数据已经填充好，第二个线程则在标记设置后，才进行读取。如下面代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;vector&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">data</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">data_ready</span>(<span style="color: #a45bad;">false</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">reader_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>data_ready.load())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::sleep(<span style="color: #a45bad;">std</span>::milliseconds(1));
    }
    <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">"The answer="</span>&lt;&lt;data[0]&lt;&lt;<span style="color: #2d9574;">"\m"</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">writer_thread</span>()
{
    data.push_back(42);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    data_ready=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
}
</pre>
</div>
<p>
先不考虑循环等待数据准备好的低效性(1)，你需要这么做，否则在线程之间共享数据将变得不切实际，因为那就要求每个数据项都必须是原子的。在没有强制顺序的情况下让非原子读(2)和写(3)访问相同的数据是未定义的行为，因此要使其工作，必须在某些地方强制排序。<br />
std::atomic&lt;bool&gt;变量 data_ready 借助内存模型关系(memory model relations) happens-before 和 synchronizes-with 提供了必要的强制排序。数据的写操作(3)发生在 data_ready 标记的写操作(4)之前，而 data_ready 标记的读操作(1)发生在数据的读操作(2)之前。当 data_ready 标记为 true 时，写操作(4)和读操作(1)相同步，其创建了一个 happens-before 关系。因为 happens-before 是可传递的，数据的写入操作(3)发生在标记的写入操作(4)之前，而(4)发生在读取标记为 true(1)之前，(1)又发生在读取数据(2)之前，因此，你就会得到一个强制的排序：数据写入(3)肯定发生在数据读取(2)之前，这样就不会出现 race condition 了。<br />
</p>


<div id="orgb6ec539" class="figure">
<p><img src="./AsynchronousProgramming/05_03_01_use_atomic_enforcing_an_ordering.jpg" alt="05_03_01_use_atomic_enforcing_an_ordering.jpg" /><br />
</p>
</div>

<p>
所有的一切可能看起来很直观：写入某个值的操作发生在读取该值的操作之前。使用默认的原子操作时(此时使用的是 memory_order_seq_cst)，前面的说法确实是正确的，但是必须指出：原子操作还有其他可选的内存顺序模型。<br />
</p>
</div>
<div id="outline-container-org8e7f279" class="outline-5">
<h5 id="org8e7f279">The synchronizes-with relationship</h5>
<div class="outline-text-5" id="text-org8e7f279">
<p>
sychronizes-with 关系只存在于原子类型上的两个操作之间。通过使用 mutex，数据结构上的操作也可以提供这样的关系，但本质上来讲其依然来自于原子类型的操作之间。其基础理念是：在变量 x 上执行的适当标记的原子写操作 W 和在变量 x 上执行的适当标记的原子读操作 R 相同步（该 R 读操作读取 W 操作写入 x 的值，或者 W 操作之后的同一线程的写操作写入 x 的值，亦或是任意线程上一系列 read-modify-write 原子操作写入 x 的值）。<br />
c++内存模型允许各种各样的顺序约束应用于原子操作上，这些顺序约束就是上面提到的适当的标记。<br />
</p>
</div>
</div>
<div id="outline-container-org5116ff6" class="outline-5">
<h5 id="org5116ff6">The happens-before relationship</h5>
<div class="outline-text-5" id="text-org5116ff6">
<p>
happens-before 和 strongly-happens-before 关系是操作顺序的基础构建块，他们指定了哪些操作可以看到另外的哪些操作的结果。<br />
</p>

<p>
对于单线程来说，其非常直白：如果一个操作 A 从顺序上在另一个操作 B 之前（A sequenced-before B），则 A 在 B 前发生(A happens-before B)，并且 A strongly-happens-before B。如果多个操作出现在同一个语句中，通常这些操作之间没有 happens-before 关系。如下代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">a</span>,<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">b</span>)
{
    <span style="color: #a45bad;">std</span>::cout&lt;&lt;a&lt;&lt;<span style="color: #2d9574;">","</span>&lt;&lt;b&lt;&lt;<span style="color: #a45bad;">std</span>::endl;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">get_num</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>=0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> ++i;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21487;&#33021;&#36755;&#20986; 2, 1 &#20063;&#21487;&#33021;&#36755;&#20986; 1, 2</span>
    foo(get_num(),get_num());
}
</pre>
</div>
<p>
有些情况下，多个操作即使在同一个语句中也会有先后顺序，例如：使用逗号操作符分割的操作之间，一个表达式的结果作为另一个表达式的参数。<br />
</p>

<p>
对于多线程来说，如果线程 a 上的操作 A inter-thread happens before 线程 b 上的操作 B，则操作 A happens-before 操作 B。这种关系(inter-thread happens before)对于编写多线程的代码来说非常重要。从底层上来讲，inter-thread happens before 依赖于 synchronizes-with 关系：如果线程 a 上的操作 A 和线程 b 上的操作 B 相同步，则操作 A inter-thread happens before 操作 B。其还具有传递性：如果 A inter-thread happens before B，B inter-thread happens before C，则 A inter-thread happens before C。inter-thread happens before 还可以和 sequence-before 关系进行组合：如果 A sequenced-before B，而 B inter-thread happens before C，则 A inter-thread happens before C。同样，如果 A synchronizes-with B，而 B sequenced-before C，则 A inter-thread happens before C。这意味着，如果你在一个线程中对数据做了一系列修改，你只需要一个 synchronizes-with 关系就可以将数据的可见性传递给 C 操作后续的操作。<br />
</p>

<p>
strongly-happens-before 关系在大多数情况下和 happens-before 相同，但也有略微差别。相同的规则如下：如果 A synchronizes-with operation B 或 A sequenced-before B，则 A strongly-happens-before B。如果 A strongly-happens-before B，B strongly-happens-before C，则 A strongly-happens-before C。不同之处在于：使用 memory_order_consume 标记操作时，依然满足 inter-thread-happens-before 关系，但是不满足 strongly-happens-before 关系。因为，大部分代码都不应该使用 strongly-happens-before 关系，因此本书在剩余章节将使用 happens-before 来统一指代 happens-before 和 inter-thread-happens-before。<br />
</p>
</div>
</div>
<div id="outline-container-orgc30384c" class="outline-5">
<h5 id="orgc30384c">Memory ordering for atomic operations</h5>
<div class="outline-text-5" id="text-orgc30384c">
<p>
有 6 种可选的 memory ordering 可被用于原子类型的操作上：<br />
</p>
<ul class="org-ul">
<li>memory_order_relaxed<br /></li>
<li>memory_order_consume<br /></li>
<li>memory_order_acquire<br /></li>
<li>memory_order_release<br /></li>
<li>memory_order_acq_rel<br /></li>
<li>memory_order_seq_cst 默认选项<br /></li>
</ul>
<p>
以上 6 种顺序选项可分为 3 类：<br />
</p>
<ul class="org-ul">
<li>sequentially consistent ordering (memory_order_seq_cst)<br /></li>
<li>acquire-release ordering (memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel)<br /></li>
<li>relaxed ordering (memory_order_relaxed)<br /></li>
</ul>

<p>
不同的 memory-ordering models 在不同 CPU 架构系统上消耗差别变化很大。例如，对处理器操作的可见性有精细控制的架构系统，要实现 sequentially consistent ordering 就需要在 acquire-release ordering 或 relaxed ordering 上执行额外的同步指令，而要实现 acquire-release ordering 就需要在 relaxed ordering 上执行额外的同步指令。如果这些系统上有很多个处理器，则这些额外的同步操作的时间消耗可能会很明显，这会导致系统整体性能下降。另一方面，使用了 x86 或 x8664 架构的 CPUs(例如：桌面 PC 平台使用的 Intel 和 AMD 处理器)除了哪些必要的保证原子性的指令外不需要任何额外的同步指令就可以达到 acquire-release ordering，甚至对于 sequentially consistent ordering，也只需要在 store 操作上花费额外的一点点消耗，而在 load 操作上则不需要任何特殊对待。<br />
</p>

<p>
memory-ordering 模型的差异使得专家可以利用更细粒度的 ordering 关系来提升性能。同时允许在性能不关键的地方使用默认的 sequentially consistent ordering。<br />
</p>

<p>
为了选择合适的 ordering 模型，或为了理解使用不同的顺序模型时，代码中的 ordering 关系，就需要知道这些不同的 ordering 模型如何影响程序。<br />
</p>
</div>
<div id="outline-container-orgd054bdc" class="outline-6">
<h6 id="orgd054bdc">sequentially consistent ordering</h6>
<div class="outline-text-6" id="text-orgd054bdc">
<p>
默认的 sequentially consistent ordering 表示程序的行为和现实世界的简单顺序观点是一致的。如果所有原子类型实例上的操作是顺序一致的，则多线程程序的行为就好像是所有这些操作都以某个特定的顺序在单个线程上执行（所有线程必须看到相同的操作排序）。其为最容易理解的 memory ordering，这也是为什么其作为默认选项的原因。这样就很容易推理使用原子变量编写的代码。你可以列出来不同线程上所有可能的操作顺序，消除哪些顺序不一致的序列，从而验证你代码的行为在其他线程中是否符合预期。<br />
</p>

<p>
从同步的观点来看，顺序一致的 store 操作 W 和顺序一致的 load 操作 R(load 操作读取 store 操作写入的值)相同步。其为两个或多个线程的操作提供了一种顺序约束，但是，顺序一致不止如此，其还提供了更强大的功能。任何在 load 操作 R 之后的顺序一致的原子操作必须出现在另一个线程的 stroe 操作 W 之后。这个约束不会扩展到使用 relaxed memory orderings 的原子操作，使用 relaxed memory orderings 的这些原子操作在不同的线程上依然会有不同的排序。因此，为了获得顺序一致的好处你需要在所有线程上使用 sequentially consistent ordering 的操作。<br />
</p>

<p>
不过，易于理解是要付出代价的。在一个弱序的多处理器机器上，sequentially consistent ordering 会导致明显的性能开销，为了保证所有处理器上的所有顺序操作(所有被标记为 sequentially consistent ordering 的操作)都必须保持一致，可能需要额外的且昂贵的同步操作。而一些处理器架构(例如 x86 和 x86-64 架构)提供的 sequentially consistent ordering 消耗则相对比较小。因此，如果你比较关心使用 sequentially consistent ordering 对性能的影响，你最好查看一下目标处理器架构的相关文档。<br />
</p>

<p>
如下代码展示了 sequentially consistent ordering 的行为方式。对 x 和 y 的 load store 操作都显示使用了 memory_order_seq_cst 标记，此处的标记是可以省略的，因为默认的标记就是 memory_order_seq_cst：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_seq_cst);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_y</span>()
{
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_seq_cst);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_x_then_y</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>x.load(<span style="color: #a45bad;">std</span>::memory_order_seq_cst)); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(y.load(<span style="color: #a45bad;">std</span>::memory_order_seq_cst))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_seq_cst));
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_seq_cst))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(write_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">c</span>(read_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">d</span>(read_y_then_x);
    a.join();
    b.join();
    c.join();
    d.join();
    
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5 </span>
}
</pre>
</div>
<p>
虽然无法确定(1)和(2)谁先发生，但是可以确定(1)和(2)在++z 之前都会先发生，因此上面(5)处的 assert 永远都不会被触发。如果读取 y 的操作(3)返回 false，则写入 x 的操作(1)必须发生在写入 y 的操作(2)之前，此时操作 4 必定返回 true。memory_order_seq_cst 的语义要求所有标记为 memory_order_seq_cst 的操作都有唯一总的排序，因此在(3)读取 y 返回 false 和(1)写入 y 之间有隐含的顺序关系。如果(6)处的 x==true 而后续(3)处的 y==false，说明写入 x(1)发生在写入 y(2)之前。对称地，如果读取 x 的操作(4)返回 false，则写入 y 的操作(2)必须发生在写入 x 的操作(1)之前，此时操作 3 必定返回 true。两种情况下，最终 z 的值都为 1；如果(3)和(4)两次读取操作都返回 true，则 z 的值为 2；没有任何一种情况会使得 z 的值为 0.<br />
<img src="./AsynchronousProgramming/05_03_02_sequential_consistency-code-sequential.jpg" alt="05_03_02_sequential_consistency-code-sequential.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org933fa29" class="outline-6">
<h6 id="org933fa29">Non-Sequentially consistent Memory orderings</h6>
<div class="outline-text-6" id="text-org933fa29">
<p>
一旦踏出 sequentially-consistent 的世界，事情就会变得复杂起来。最大的问题可能是再也没有唯一的全局排序了。这意味着不同的线程对于相同的一系列操作可能看到不同的排序，来自不同线程的操作会一个接一个整齐交错执行的思维模式必须丢弃。你不仅需要考虑到事情可能真的同步发生，而且多个线程也不必就事件的顺序达成一致。为了编写或理解没有使用默认内存模型(memory_order_seq_cst)的代码，弄明白这一点绝对是至关重要的。不止编译器可以对指令进行重新排序，即使多个线程执行的指令完全一样，他们依然可以不必就事件顺序达成一致，因为线程上的操作没有显示的顺序约束，也因为不同的 CPU caches 和内部缓存可以为相同的内存持有不同的值。总之，多个线程不需要对事件顺序达成一致。<br />
</p>

<p>
在没有其他顺序约束的情况下，唯一需要满足的是所有线程对于单个变量的修改顺序需要达成一致，而不同线程上不同变量上的操作可以有不同的顺序。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc7e22ad"></a>Relaxed ordering<br />
<div class="outline-text-7" id="text-orgc7e22ad">
<p>
使用 relaxed ordering 内存模型的原子操作之间不会有 synchronizes-with 关系。在 <b>单个线程内</b> <b>同一个变量上</b> 的操作依然遵守 happens-before 关系（同一个线程上对单个原子变量的多个访问的顺序不能被重排，在给定线程上，一旦其看到了原子变量的某个值，则该线程上后续对该变量的读取不能得到比该值更早的值），但是对其他线程在顺序上几乎没有任何要求。在没有任何额外同步的情况下，使用 memory_order_relaxed 的线程间唯一达成一致的是单个变量的修改顺序（即不同线程上，观察到的单个变量的修改操作的顺序是一致的）。 <b>不同变量</b> 上的 Relaxed 操作所产生值的可见性在其他线程上可以被自由地重新排列，使得他们在其他线程上可以违反任何 happens-before 关系，因此 memory_order_relaxed 不会引入 synchronizes-with 关系。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x_then_y</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(read_y_then_x);
    a.join();
    b.join();
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
}
</pre>
</div>
<p>
上面(5)处的 assert 可能被触发，因为，即使(3)处对 y 的读取返回 true，(4)处的 x 读取操作也可能返回 false。x 和 y 是不同的变量，因此，对于每个变量上操作所产生值的可见性没有顺序保证。即使(1)和(2) (3)和(4) 有 happens-before 关系，但是(2)和(3) (1)和(4)之间没有任何顺序关系。<br />
<img src="./AsynchronousProgramming/05_03_02_relaxed-ordering-two-thread.jpg" alt="05_03_02_relaxed-ordering-two-thread.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;iostream&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">x</span>(0),<span style="color: #7590db;">y</span>(0),<span style="color: #7590db;">z</span>(0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">go</span>(<span style="color: #a45bad;">false</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">loop_count</span>=10;

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">read_values</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>,<span style="color: #7590db;">z</span>;
};

<span style="color: #ce537a; font-weight: bold;">read_values</span> <span style="color: #7590db;">values1</span>[loop_count];
<span style="color: #ce537a; font-weight: bold;">read_values</span> <span style="color: #7590db;">values2</span>[loop_count];
<span style="color: #ce537a; font-weight: bold;">read_values</span> <span style="color: #7590db;">values3</span>[loop_count];
<span style="color: #ce537a; font-weight: bold;">read_values</span> <span style="color: #7590db;">values4</span>[loop_count];
<span style="color: #ce537a; font-weight: bold;">read_values</span> <span style="color: #7590db;">values5</span>[loop_count];

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increment</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt;* <span style="color: #7590db;">var_to_inc</span>,<span style="color: #ce537a; font-weight: bold;">read_values</span>* <span style="color: #7590db;">values</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>go) <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#33258;&#26059;&#65292;&#31561;&#24453;&#20449;&#21495;</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;loop_count;++i)
    {
        values[i].x=x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        values[i].y=y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        values[i].z=z.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        var_to_inc-&gt;store(i+1,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_vals</span>(<span style="color: #ce537a; font-weight: bold;">read_values</span>* <span style="color: #7590db;">values</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>go) <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5 &#33258;&#26059;&#65292;&#31561;&#24453;&#20449;&#21495;</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;loop_count;++i)
    {
        values[i].x=x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        values[i].y=y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        values[i].z=z.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">print</span>(<span style="color: #ce537a; font-weight: bold;">read_values</span>* <span style="color: #7590db;">v</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;loop_count;++i)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(i) <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">","</span>;
        <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #2d9574;">"("</span>&lt;&lt;v[i].x&lt;&lt;<span style="color: #2d9574;">","</span>&lt;&lt;v[i].y&lt;&lt;<span style="color: #2d9574;">","</span>&lt;&lt;v[i].z&lt;&lt;<span style="color: #2d9574;">")"</span>;
    }
    <span style="color: #a45bad;">std</span>::cout&lt;&lt;<span style="color: #a45bad;">std</span>::endl;
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t1</span>(increment,&amp;x,values1);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t2</span>(increment,&amp;y,values2);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t3</span>(increment,&amp;z,values3);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t4</span>(read_vals,values4);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t5</span>(read_vals,values5);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;go&#21407;&#23376;&#21464;&#37327;&#26469;&#20445;&#35777;&#25152;&#26377;&#32447;&#31243;&#33021;&#20960;&#20046;&#22312;&#21516;&#19968;&#26102;&#38388;&#24320;&#22987;&#36827;&#20837;&#21508;&#33258;&#30340;&#24490;&#29615;&#12290;&#21551;&#21160;&#19968;&#20010;&#32447;&#31243;&#26159;&#28040;&#32791;&#27604;&#22823;&#30340;&#25805;&#20316;&#65292;&#22914;&#26524;&#27809;&#26377;&#26174;&#31034;&#30340;&#24310;&#36831;&#65292;&#31532;&#19968;&#20010;&#32447;&#31243;&#21487;&#33021;&#22312;&#26368;&#21518;&#19968;&#20010;&#24320;&#22987;&#30340;&#26102;&#20505;&#23601;&#32467;&#26463;&#20102;</span>
    go=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6 &#25152;&#26377;&#32447;&#31243;&#24320;&#22987;&#21518;&#65292;&#35774;&#32622;go&#20026;true</span>

    t5.join();
    t4.join();
    t3.join();
    t2.join();
    t1.join();

    print(values1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7 &#25171;&#21360;&#26368;&#32456;&#32467;&#26524;</span>
    print(values2);
    print(values3);
    print(values4);
    print(values5);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20026;&#20195;&#30721;&#21487;&#33021;&#30340;&#19968;&#31181;&#36755;&#20986;&#32467;&#26524;:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8),(9,9,10)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9),(10,9,10)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0,0,9)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10),(9,10,10),(10,10,10)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9),(8,8,9)</span>
</pre>
</div>
<p>
上面输出结果中，前面 3 行是执行修改的线程的结果，后面 2 行是执行读取线程的结果。每个三元组对应着(x,y,z)变量组合。从这个输出可以观察到一下几点：<br />
</p>
<ul class="org-ul">
<li>第 1 行数据可以观察到 x 变量，从前到后每次增加 1; 第 2 行数据可以观察到 y 变量，从前到后每次增加 1; 第 3 行数据可以观察到 z 变量，从前到后每次增加 1.<br /></li>
<li>x 变量在第 2、3 行输出中，从前到后值是逐渐增大的，但是增大的幅度不均匀，并且 1、2、3 行中，x变量值出现的相对顺序都不同。对于 y,z 变量也如此。<br /></li>
<li>线程 3 看不到 x 或 y 的任何更新；它只看到它对 z 的更新。这并不妨碍别的线程观察到 z 的更新与对 x 和 y 的更新混在一起。<br /></li>
</ul>
<p>
对于 relaxed 操作来说，上面并不是唯一有效的输出结果。只要 t1 观察到 x 的值为从 0 到 9 依次增大 1，t1 观察到 y,z 的值在 0 到 10 之间，且逐渐增大（增大幅度可以不固定），符合这些规则的输出就是有效的。对于 t2,t3 也一样。<br />
</p>
</div>
</li>
<li><a id="org5daea8c"></a>Understanding relaxed ordering<br />
<div class="outline-text-7" id="text-org5daea8c">
<p>
为了方便理解 relexed ordering 的工作方式，可以做如下比拟。每个变量就如一个在小隔间里拿着记事本的人。他的记事本上是多个值的列表。你可以通过打电话的方式让他给你一个值，或你可以告诉他，让他写下一个新值。如果你告诉他写下一个新值，他会将这个新值写在列表的最后。如果你让他给你一个值，他会从列表中读取一个值给你。<br />
</p>

<p>
当你第一次与这个人交谈时，如果你问他要一个值，他可能会给你那时列表中的任意值。如果之后你再问他要一个值，它可能会再给你同一个值，或将列表更下面的值给你，但他不会给你列表更上端的值。如果你让他写下一个数字，并且随后再问他要一个值，他要不就给你你刚告诉他写下的那个数字，要不就是清单上比这个值更靠下的一个值。<br />
</p>

<p>
想像一下，他的列表上开始有 5，10，23，3，1，2 这几个值。如果你问他要一个值，你可能获取这几个数中的任意一个。如果他给你 10，下次你再查询时，他依然可能给你 10，也可能给你 10 之后的任意一个值，但不会给你 5.如果你向他询问 5 次，他可能给你的回复是"10, 10, 1, 2, 2"。如果你让他写下 42，他会将其添加到列表最下面，你再向他查询值时，他会一直给你 42，直到他的记事本上有新的值，且他愿意将新值给你。假如你的朋友 Carl 也有记数员的电话号，他也可以给记数员打电话查询值或让记数员记录值。记数员只有一个电话，他同一时间只能处理一个人的请求，因此他的记事本上是一个简单的列表(不会有值并排出现)。但是，你让他写下的新值，并不意味着他需要将新值告诉 Carl，反之亦然。假如 Carl 向他查询值，他将 32 给 Carl，然后你让他写下 42，之后 Carl 再查询值时，他不是必须将 42 给 Carl，其可能给 Carl “23, 3, 1, 2, 42”中的任何一个值，他甚至可以将 67 给 Carl(你写入 42 后，Fred 让记数员写入 67)。如果 Carl 也查询 5 次，他告诉 Carl 的序列可能是“23 3, 3, 1, 67”，可以和你得到的值序列不一致。就好像记数员为每个人使用一个可移动的便利贴分别标记当前记数员告诉他的值是哪个值，如下图所示：<br />
</p>


<div id="org1e36e6f" class="figure">
<p><img src="./AsynchronousProgramming/05_03_02_relaxed-ordering-stickynote.jpg" alt="05_03_02_relaxed-ordering-stickynote.jpg" /><br />
</p>
</div>

<p>
多个原子变量的情况对应于多个小隔间，每个小隔间中都有记数员。每个变量都有自己的修改顺序(对应记事本上的值列表)，但是不同变量之间没有任何关系。假设每个查询者都是一个线程(you，Carl, Anne, Dave, and Fred)，所有操作都使用 memory_order_relaxed 时的情况就是这样。你和记数员的沟通还可以包含一些额外信息，例如：写下这个值并告诉我列表中最下面的值是什么（对应 exchange）; 或者 如果列表最下面的值是预期值则写下给定值，否则将列表最下面的值赋值给期望值（对应 compare_exchange_strong）。<br />
</p>
<ul class="org-ul">
<li>T exchange(T val);   写入新值 val，并返回原始值<br /></li>
<li>bool compare_exchange_strong(T&amp; expected, T val); 如果原子变量中的值和预期值相等，则写入 val，并返回 true;如果原子变量中的值和预期值不相等，则将原子变量中的值赋给 expected，并返回 false。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x_then_y</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(read_y_then_x);
    a.join();
    b.join();
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
}
</pre>
</div>
<p>
考虑上面代码，write_x_then_y 就好比是某个人给“记数员 x”打电话让他写入 true，然后又打电话给“记数员 y”让他写入 true。执行 read_y_then_x 的线程不断给“记数员 y”打电话，直到其告诉你 y 的值为 true，然后再打电话给“记数员 x”询问 x 的值。“记数员 x” 没有任何责任告诉你其记事本上的某个特定的值，其完全可以和你说 x 的值为 false。<br />
</p>

<p>
从上面可以看出，relaxed 原子操作很难处理。他们必须和有更强排序语义特性的原子操作结合使用，才能使得线程间操作得到同步。我强烈建议最好不要使用 relaxed 的原子操作，除非必要，而且使用时一定要倍加谨慎。<br />
</p>
</div>
</li>
<li><a id="org28b109c"></a>Acquire-release ordering<br />
<div class="outline-text-7" id="text-org28b109c">
<p>
Acquire-release ordering 是 relaxed ordering 的提升。多个操作依然没有完全唯一的顺序，但依然引入了一些同步。在该模型下，原子 loads 是 acquire 操作(memory_order_acquire), 原子 stores 为 release 操作(memory_order_release)，原子 read-modify-write 操作(如 fetch_add() exchange()) 既可以只是 acquire，也可以只是 release，还可以是 acquire 和 release（memory_order_acq_rel）。线程间的同步是成对的，执行 release 的线程和执行 acquire 的线程相同步。一个 release 操作和一个 acquire 操作(acquire 操作读取 release 写入的值)相同步。不同线程依然可以看到不同的排序，但是这些顺序是有限制的。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_release); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_y</span>()
{
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_release); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_x_then_y</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>x.load(<span style="color: #a45bad;">std</span>::memory_order_acquire)); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(y.load(<span style="color: #a45bad;">std</span>::memory_order_acquire))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_acquire)); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_acquire))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(write_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">c</span>(read_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">d</span>(read_y_then_x);
    a.join();
    b.join();
    c.join();
    d.join();
    assert(z.load()!=0); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
}
</pre>
</div>
<p>
上面(7)处的 assert 可能触发(和使用 relaxed-ordering 时一样)，因为(2)处读取 x 和(1)处读取 y 可能都会返回 false。x 和 y 的写操作是由不同线程执行的，从 release 到 acquire 的排序对于其他线程上的操作是没影响的(3 和 5 会同步，4和 6 会同步；但是 4 和 1 不会同步，3和 2 也不会同步)。下图展示了一种执行顺序，因为没有 happens-before 关系来进行强制排序，因此此执行顺序是有可能发生的：<br />
<img src="./AsynchronousProgramming/05_03_02_acq-rel-unordering.jpg" alt="05_03_02_acq-rel-unordering.jpg" /><br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x_then_y</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 </span>
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_acquire));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#33258;&#26059;&#65292;&#31561;&#24453;y&#34987;&#35774;&#32622;&#20026;true</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(read_y_then_x);
    a.join();
    b.join();
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
}
</pre>
</div>

<p>
上面(5)处的 assert 不会被触发。通过循环判断，(3)处最终会看到(2)处写入 y 的 true。而(2)使用了 memory_order_release，(3)使用 memory_order_acquire，因此(2)和(3)就是 store 和 load 相同步。(1)和(2)又在同一个线程中，所以(1)happens-before (2)，因此(1)happens before(3)，(1)也就 happens before (4)。这样(4)读到的 x 的值就一定是 true，(5)处的 assert 就不会被触发。如果(3)处对 y 的读取没有使用 while 循环，情况就不一样了，此时 3 处读取的 y 可能是 false，此时就不能确定 4 处 x 读到的值了。为了达到线程之间的同步，acquire 操作和 release 操作必须配对，被 release 操作写入的值必须被 acquire 操作读取到(即，3必须看到 2 写入的 true)。如果 2 和 3 任何一个使用了 relaxed ordering，则对 x 的访问将不会被排序，也就不能保证 4 处读取的 x 返回 true，assert 就有可能被触发。<br />
</p>

<p>
你依然可以使用小隔间的记数员来类比 acquire-release ordering，但是需要增加一些限制。首先，每次写入操作都是某个更新批次的一部分。当你叫记数员写下一个数字时，你同时会告诉他这次写入所属的批次编号。例如，“请写入 99，其属于 423 批次”。某个批次的最后一次写入也需要通知给记数员：“请写入 147，其为 423 批次的最后一次写入”。记数员会将这些信息都记录下来。你再次让记数员写下数字时，你需要增加批次编号：“请写入 41，其属于 424 批次”。当你查询某个值时，你可以简单查询变量的值(relaxed load）此时记数员只是给你一个列表中的值，你还可以查询变量的值和相关的信息(load-acquire 模型，相关的信息为获取到的值是否为某个批次中最后一个写入的值)。例如，记数员给你的消息可能是，"您查询的值为 987，其为一个普通值"，如果查询到的值为批次中最后一次写入的值时，消息可能是，“您查询的值为 987，其为 956 批次的最后写入的值(956 批次对应于 Anne 让记数员写入的值)”。以前面描述做基础，可以描述 acquire-release 的语义为：你查询一个变量的值时，告诉记数员你所知道的所有的批次，他将会在他的值列表中查找一个最下面的值且该值属于你知道的批次，他可能会将查找到的值返回给你也可能将该值下面的值返回给你。<br />
</p>

<p>
用这种比拟方式来看上面代码：线程 a 执行 write_x_then_u 相当于 a 对记数员 x 说：“请写入 true，其属于来自 a 的批次 1”，然后，a对记数员 y 说：“请写入 true，其属于来自 a 的批次 1”。同时，线程 b 执行 read_y_then_x。线程 b 通过提供 batch 信息不停地向记数员 y 查询，直到返回 true。此时，记数员 y 不只是说 y 的值为 true，其还指出"这是批次 1 的最后一次写入，该批次来自 a"。线程 b 继续向记数员 x 查询值，这好比在说“我知道来自 a 的批次 1，请给我 x 的值”。此时，记数员 x 会查询他的值列表，从下到上查找标记为批次 1 的值，得到的值为 true，并且其也是记数员 x 列表中最下面的值，因此，只能返回 true。<br />
</p>
</div>
</li>
<li><a id="org0d8e31f"></a>Transitive synchronization with acquire-release ordering<br />
<div class="outline-text-7" id="text-org0d8e31f">
<p>
前面介绍过，如果 A inter-thread-happens-before B，并且 B inter-thread-happens-before C，则 A inter-thread-happens-before C。由此 acquire-release ordering 可用于在多个线程之间同步数据，即使是中间线程不碰数据的情况下，也可行。<br />
第一个线程对某些共享变量进行修改，并对其中一个变量的修改使用 store-release。第二个线程使用 load-accquire 读取第一个线程使用 store-release 写入的值，并对第二个共享变量执行 store-release 操作。最后，第三个线程使用 load-accquire 读取第二个线程使用 store-release 写入第二个共享变量的值。为了保证同步关系，只要 load-acquire 操作看到被 store-release 操作写入的值，第三个线程就可以读到其他变量的值(该值由第一个线程写入)，即使中间线程没有访问任何其中一个数据。下面代码就展示了这种情况：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">data</span>[5];
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">sync1</span>(<span style="color: #a45bad;">false</span>),<span style="color: #7590db;">sync2</span>(<span style="color: #a45bad;">false</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_1</span>()
{
    data[0].store(42,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    data[1].store(97,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    data[2].store(17,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    data[3].store(-141,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    data[4].store(2003,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    sync1.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1.&#35774;&#32622;sync1</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_2</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>sync1.load(<span style="color: #a45bad;">std</span>::memory_order_acquire));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2.&#30452;&#21040;sync1&#35774;&#32622;&#21518;&#65292;&#24490;&#29615;&#32467;&#26463;</span>
    sync2.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3.&#35774;&#32622;sync2</span>
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_3</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>sync2.load(<span style="color: #a45bad;">std</span>::memory_order_acquire));   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4.&#30452;&#21040;sync1&#35774;&#32622;&#21518;&#65292;&#24490;&#29615;&#32467;&#26463;</span>
    assert(data[0].load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==42);
    assert(data[1].load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==97);
    assert(data[2].load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==17);
    assert(data[3].load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==-141);
    assert(data[4].load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==2003);
}
</pre>
</div>
<p>
你还可以通过使用 read-modify-write 操作(用 memory_order_acq_rel 内存模型)用一个 sync 变量来代替 sync1 和 sync2 两个变量。如下面代码所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">sync</span>(0);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_1</span>()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    sync.store(1,<span style="color: #a45bad;">std</span>::memory_order_release);
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_2</span>()
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">expected</span>=1;
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>sync.compare_exchange_strong(expected, 2, <span style="color: #a45bad;">std</span>::memory_order_acq_rel))
        expected=1;
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">thread_3</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(sync.load(<span style="color: #a45bad;">std</span>::memory_order_acquire)&lt;2);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>
<p>
使用 read-modify-write 操作时，挑选你期望的语义很重要。在上面代码中，你既需要 acquire 语义也需要 release 语义，因此 memory_order_acq_rel 是合适的选择。而一个使用了 memory_order_acquire 语义的 fetch_sub 操作不会同步任何操作，尽管其写入了一个值，但是其不是 release 操作。类似地，一个 store 操作无法和使用了 memory_order_release 语义的 fetch_or 的相同步，因为 fetch_or 读操作的部分不是 acquire 操作。<br />
</p>

<p>
如果你混合使用 acquire-relase 操作和 sequentially-consistent 操作，sequentially-consistent loads 的行为将和 acquire 语义的 loads 一样，sequentially-consistent stores 的行为将和 release 语义的 stores 一样，sequentially-consistent read-modify-write 操作的行为将同时具有 acquire 和 release 语义。Relaxed 操作依然是 relaxed，但是通过使用 acquire-release 语义引入的 synchronizes-with 和 happens-before 关系会限制 Relaxed 操作。<br />
</p>

<p>
尽管不是太直观，使用锁的人也需要处理相同的顺序问题：对互斥量上锁是一个 acquire 操作，对互斥量解锁是一个 release 操作。必须确保读取值时锁住的互斥锁和修改值时锁住的互斥锁是同一个互斥锁。对于原子操作也一样，为了确保顺序，acquire 操作和 release 操作必须作用在同一个变量上。如果使用互斥锁保护数据，互斥锁的互斥性质意味着结果是顺序一致的，而上锁和解锁是否使用了顺序一致性操作则是无法确定的（TODO 不确定翻译是否正确）。同样地，如果在原子变量上使用 acquire 和 release orderings 来构建一个简单的锁，从使用锁的角度看，代码的行为是顺序一致的，尽管内部操作可能并非如此。<br />
</p>

<p>
如果你的原子操作不需要严格的 sequentially consistent ordering，那么 acquire-release ordering 的成对同步可能会比需要全局顺序的 sequentially consistent ordering 操作的同步成本低得多。这里需要权衡的是为了确保操作顺序正确，以及确保多个线程上非直观的行为没有问题而付出的脑力成本。<br />
</p>
</div>
</li>
<li><a id="org36b54e8"></a>Data dependency with acquire-release ordering and memory_order_consume<br />
<div class="outline-text-7" id="text-org36b54e8">
<p>
memory_order_consume 也属于 acquire-relase ordering 模型，但是其比较特殊：其和数据依赖相关，其在 inter-thread-happens-before 关系中引入了数据依赖的细微差别。另外，C++17 标准中显示地建议不要使用该选项。<br />
</p>

<p>
数据依赖的概念很直白：两个操作中，如果第二个操作的输入是第一个操作的结果，则称他们之间有数据依赖。对应有两种关系：dependency-ordered-before 和 carries-a-dependeny-to。类似 sequenced-before 和 carries-a-dependency-to 被严格应用于单个线程时，建模操作之间的数据依赖。如果操作 A 的结果被操作 B 使用，则 A 携带了到 B 的依赖。如果 A 的结果是一个标量类型的值（如 int 类型的值），该值被存储在一个变量中，B使用了该变量，则 A 和 B 之间的关系依然成立。这种关系也具有传递性，如 A 携带了到 B 的依赖，B携带了到 C 的依赖，则 A 携带了到 C 的依赖。<br />
</p>

<p>
dependency-ordered-before 关系可被用于多个线程之间。原子 load 操作被标记为 memory_order_consume 即可引入该关系。其相当于使用 memory_order_acquire 时，限制同步的数据需要具有数据依赖。当操作 A 被标记为 memory_order_release, memory_order_acq_rel,或 memory_order_seq_cst，操作 B 被标记为 memory_order_consume，且操作 B 读取 A 写入的值，则 A dependency-ordered-before B。如果 dependency-ordered-before 不影响 inter-thread happens-before 关系，则对于同步没有任何用处，然而，如果 A dependency-ordered-before B，A 就会 inter-thread-happens-before B。<br />
</p>

<p>
memory_order_consume 模型适用于原子操作 loads 一个指向某个数据的指针的情况。写入指针的操作 store 使用 memory_order_release，读取指针的操作 load 使用 memory_order_consume，你就可以保证指针指向的数据被正确同步，而不需要强加其他任何同步到其他任何不相关的数据上。下面代码展示了这种情况：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">s</span>;
};

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">X</span>*&gt; <span style="color: #7590db;">p</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">a</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">create_x</span>()
{
    <span style="color: #ce537a; font-weight: bold;">X</span>* <span style="color: #7590db;">x</span>=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">X</span>;
    x-&gt;i=42;
    x-&gt;s=<span style="color: #2d9574;">"hello"</span>;
    a.store(99,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    p.store(x,<span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">use_x</span>()
{
    <span style="color: #ce537a; font-weight: bold;">X</span>* <span style="color: #7590db;">x</span>;
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>(x=p.load(<span style="color: #a45bad;">std</span>::memory_order_consume)))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::sleep(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::microseconds(1));
    assert(x-&gt;i==42);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 assert&#19981;&#20250;&#35302;&#21457;</span>
    assert(x-&gt;s==<span style="color: #2d9574;">"hello"</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5 assert&#19981;&#20250;&#35302;&#21457;</span>
    assert(a.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed)==99);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6 assert&#21487;&#33021;&#35302;&#21457;</span>
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t1</span>(create_x);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">t2</span>(use_x);
    t1.join();
    t2.join();
}
</pre>
</div>
<p>
尽管(1)在(2)之前，并且 store 操作(2)被标记为 memory_order_release，load 操作(3) 被标记为 memory_order_concume ，但是，(1) 只 happens-before 那些依赖于从 p 中取值的操作。因此，(4)(5)处的 assert 不会被触发，p 的 load 操作携带了到(4)和(5)的数据依赖。另一方面，(6)处的 assert 则可能被触发。<br />
</p>

<p>
有时候你不想要携带依赖带来的额外开销。你希望编译器可以在寄存器中缓存值并且对操作顺序进行重排从而优化代码，而不是为了依赖而忙乱。这种情况下，你可以使用 std::kill_dependency() 来显示地将依赖链给切断。该函数是一个简单模板函数，其会将参数的值 copy 到返回值，并且将依赖链切断。例如：假设有一个全局的 read-only 数组，在另一个线程使用 memory_order_consume 来获得数组的索引，你可以使用 std::kill_dependency() 来告诉编译器，不需要重新读取该数组元素的内容。下面代码展示了这种情况：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">global_data</span>[]={ &#8230; };
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">index</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">f</span>()
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>=index.load(<span style="color: #a45bad;">std</span>::memory_order_consume);
    do_something_with(global_data[<span style="color: #a45bad;">std</span>::kill_dependency(i)]);
}
</pre>
</div>
<p>
在实际代码中，你应该总是在可能试图使用 memory_order_consume 的地方使用 memory_order_acquire，并且 std::kill_dependency 是不必要的。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org00a8a77" class="outline-5">
<h5 id="org00a8a77">Release sequences and synchronizes-with</h5>
<div class="outline-text-5" id="text-org00a8a77">
<p>
原子变量的 store 操作可以和另一个线程上该原子变量上的 load 操作相同步，即使在 store 和 load 之间有一系列的 read-modify-write 操作，只要所有操作都被适当标记就没问题。如果 store 操作被标记为 memory_order_release，memory_order_acq_rel 或 memory_order_seq_cst，load 操作被标记为 memory_order_consum，memory_order_acquire 或 memory_order_seq_cst，并且链上的每个操作加载的值都是被前面操作写入的值，则整个操作链组成了一个 release sequence 并且初始的 store 操作和最终的 load 操作相同步。该操作链中任意一个 read-modify-write 操作都可以使用任意内存顺序，包括 memory_order_relaxed.<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">queue_data</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">count</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">populate_queue</span>()
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">number_of_items</span>=20;
    queue_data.clear();
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;number_of_items;++i)
    {
        queue_data.push_back(i);
    }

    count.store(number_of_items, <span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#21021;&#22987;&#21270;&#23384;&#20648;</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">consume_queue_items</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">item_index</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span>((item_index=count.fetch_sub(1,<span style="color: #a45bad;">std</span>::memory_order_acquire))&lt;=0)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#19968;&#20010;&#8220;&#35835;-&#25913;-&#20889;&#8221;&#25805;&#20316;</span>
        {
            wait_for_more_items();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#31561;&#24453;&#26356;&#22810;&#20803;&#32032;</span>
            <span style="color: #4f97d7; font-weight: bold;">continue</span>;
        }
        process(queue_data[item_index-1]);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 &#23433;&#20840;&#35835;&#21462;queue_data</span>
    }
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(populate_queue);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(consume_queue_items);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">c</span>(consume_queue_items);
    a.join();
    b.join();
    c.join();
}
</pre>
</div>
<p>
(1)处执行 count.store(number_of_items, std::memory_order_release); 让其他线程知道有数据可用。消费队列中数据项的消费者线程会在读取共享缓存(4)之前在(2)处执行 count.fetch_sub(1,std::memory_order_acquire) 从队列中获取一个数据项。一旦 count 变为 0，说明没有更多的数据项了，线程在(3)处就必须执行等待。<br />
</p>

<p>
如果只有一个消费者线程，上面代码可以很好工作(只有 a、b 两个线程的时候)；此时，fetch_sub()的读操作具有 memory_order_acquire 语义，(1)处的写操作具有 memory_order_release 语义，因此，store 同步于 load，线程可以从共享缓存中读取数据项。如果有两个消费者线程，第二个线程的 fetch_sub() A 将会看到第一个线程的 fetch_sub() B 写入的值而不是(1)写入的值。如果没有 release sequence, 第二个线程和第一个线程之间就不会有 happens-before 关系，读取共享内存就会不安全，除非第一个 fetch_sub()也具有 memory_order_release 语义。如果 release sequence 不存在或 fetch_sub()没有 memory_order_release 语义，则第二个线程对 存入 queue_data 中的值的可见性没有任何要求，这样就会导致 data race。幸好第一个线程的 fetch_sub() 确实参与到了 release sequence 中，所以(1)处的 store()可以和第二个线程的 fetch_sub()相同步。而两个消费线程之间依然没有 synchronizes-with 关系。如下图所示：<br />
<img src="./AsynchronousProgramming/05_03_04_release-sequence.jpg" alt="05_03_04_release-sequence.jpg" /><br />
</p>

<p>
操作链中可以有任意数量的链接，他们必须是 read-modify-write 类型的操，如 fetch_sub()，store()仍然会与标记为 memory_order_acquire 的每个操作同步。上面这个例子中所有链接都是一样的，并且都是 acquire 操作，但实际上它们可以是具有不同内存顺序语义的不同操作的混合。<br />
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/38565650/what-does-release-sequence-mean">https://stackoverflow.com/questions/38565650/what-does-release-sequence-mean</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1fca3a4" class="outline-5">
<h5 id="org1fca3a4">Fences</h5>
<div class="outline-text-5" id="text-org1fca3a4">
<p>
没有栅栏(fences)原子操作库是不完整的。有一些操作可以不修改任何数据而强制实施内存顺序约束(memory-ordering constrains)。通常会将使用 memory_order_relaxed 的原子操作和他们合并使用。栅栏(Fences)属于全局操作，其会影响执行该栅栏的线程中的原子操作的排序。通常也会将栅栏称作内存屏障(memory barriers)，其得名于它会在代码中放置一条线，特定的操作不能跨越这条线。不同变量上的 relaxed 操作通常会被编译器或硬件任意地重新排序。栅栏限制了这种自由，并引入 happens-before 和 synchronizes-with 关系。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">x</span>,<span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x_then_y</span>()
{
    x.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #a45bad;">std</span>::atomic_thread_fence(<span style="color: #a45bad;">std</span>::memory_order_release);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    <span style="color: #a45bad;">std</span>::atomic_thread_fence(<span style="color: #a45bad;">std</span>::memory_order_acquire);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        ++z;
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(read_y_then_x);
    a.join();
    b.join();
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
}
</pre>
</div>
<p>
(4)处读取 y 的操作读取了(3)处写入 y 的值，因此 release fence(2)和 acquire fence(5)相同步。这意味着(1)处写入 x 的操作 happens before (6)处读取 x 的操作，因此，(7)处的 assert 不会被触发。如果没有栅栏，x的 store 操作和 load 操作就不会同步，assert 就会被触发。需要注意的是上面代码中两个栅栏都是必须的：你需要一个 release 栅栏在一个线程中，以及一个 acquire 栅栏在另一个线程中，才能得到 synchronizes-with 关系。<br />
</p>

<p>
栅栏的总体理念为：如果 acquire 操作看到发生在 release 栅栏之后的 store 操作的结果，栅栏会和 acquire 操作相同步;如果发生在 acquire 栅栏之前的 load 操作看到了一个 release 操作的结果，则 release 操作和 acquire 栅栏相同步。你也可以在两边都使用栅栏(如同上面代码)，如果发生在 acquire 栅栏之前的 load 操作看到发生在 release 栅栏之后的 store 操作写入的值，则 release 栅栏和 acquire 栅栏相同步。<br />
</p>

<p>
虽然栅栏的同步依赖于栅栏前后执行的读值写值操作，但是同步点是栅栏自身。如果你将上面代码中的(1)移到(2)下面，虽然(1)依然在(3)前面（写入 x 在写入 y 之前），但是 assert 还是有可能被触发。这两个操作不再被栅栏分开，也就不再有先后顺序了。只有栅栏在写入 x 和写入 y 之间才能保证排序。栅栏的存在与否对于 happens-before 关系中的强制排序没有任何影响。<br />
</p>
</div>
</div>

<div id="outline-container-org2077aab" class="outline-5">
<h5 id="org2077aab">Ordering non-atomic operations with atomics</h5>
<div class="outline-text-5" id="text-org2077aab">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;atomic&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;thread&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;assert.h&gt;</span>

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">x</span>=<span style="color: #a45bad;">false</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x&#29616;&#22312;&#26159;&#19968;&#20010;&#38750;&#21407;&#23376;&#21464;&#37327;</span>
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">y</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">z</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">write_x_then_y</span>()
{
    x=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#22312;&#26629;&#26639;&#21069;&#23384;&#20648;x</span>
    <span style="color: #a45bad;">std</span>::atomic_thread_fence(<span style="color: #a45bad;">std</span>::memory_order_release);
    y.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#22312;&#26629;&#26639;&#21518;&#23384;&#20648;y</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">read_y_then_x</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>y.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#22312;#2&#20889;&#20837;&#21069;&#65292;&#25345;&#32493;&#31561;&#24453;</span>
    <span style="color: #a45bad;">std</span>::atomic_thread_fence(<span style="color: #a45bad;">std</span>::memory_order_acquire);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(x)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 &#36825;&#37324;&#35835;&#21462;&#21040;&#30340;&#20540;&#65292;&#26159;#1&#20013;&#20889;&#20837;</span>
        ++z;
}
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    x=<span style="color: #a45bad;">false</span>;
    y=<span style="color: #a45bad;">false</span>;
    z=0;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">a</span>(write_x_then_y);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">b</span>(read_y_then_x);
    a.join();
    b.join();
    assert(z.load()!=0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5 &#26029;&#35328;&#23558;&#19981;&#20250;&#35302;&#21457;</span>
}
</pre>
</div>
<p>
上一节例子中的 x 变量换为非原子变量，assert 依然不会被触发。栅栏会对 x 的写入(1)、y的写入(2)、y的读取(3)、x的读取(4)进行强制排序，并且 x 的写入(1)和 x 的读取(4)之间依然存在 happens-before 关系，因此(5)处的 assert 依然不会被触发。y的写入和读取必须是原子的，否则在 y 上就存在 data race 不过一旦读取线程看到 y 中存储的值，栅栏将会对 x 上的操作强制一个顺序。这里的强制顺序意味着，尽管 x 被一个线程修改并被另外一个线程读取，x上也不存在 data races 。<br />
</p>
</div>
</div>
<div id="outline-container-orgc2f511d" class="outline-5">
<h5 id="orgc2f511d">Ordering non-atomic operations</h5>
<div class="outline-text-5" id="text-orgc2f511d">
<p>
能够使用原子操作对非原子操作进行排序是 happens-before 中的 sequenced-before 部分显得非常重要的地方。如果非原子操作 A seqenced-before 原子操作 B，并且该原子操作 B happens-before 另一个线程中的操作 C，则非原子操作 A happens-before 操作 C。这是 c++标准库中所有高级同步工具(mutexes condition variables 等等)的基础。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">spinlock_mutex</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic_flag</span> <span style="color: #7590db;">flag</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">spinlock_mutex</span>(): <span style="color: #bc6ec5; font-weight: bold;">flag</span>(ATOMIC_FLAG_INIT) {}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>()
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26816;&#26597;flag&#26159;&#21542;&#34987;&#35774;&#32622;&#65288;&#21363;flag&#26159;&#21542;&#20026;true&#65289;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33509;&#34987;&#35774;&#32622;&#30452;&#25509;&#36820;&#22238;true&#65292;&#33509;&#27809;&#26377;&#35774;&#32622;&#21017;&#35774;&#32622;flag&#20026;true&#21518;&#20877;&#36820;&#22238;false</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(flag.test_and_set(<span style="color: #a45bad;">std</span>::memory_order_acquire));
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28165;&#38500;flag&#26631;&#24535;&#21363;flag=false</span>
        flag.clear(<span style="color: #a45bad;">std</span>::memory_order_release);
    }
};
</pre>
</div>
<p>
lock()是使用 std::memory_order_acquire 顺序的 flag.test_and_set()上的一个循环，并且 unlock()是使用 std::memory_order_release 顺序 flag.clear()的一个调用。第一个线程调用 lock()时，标志最初是 clear 状态，所以第一次调用 test_and_set()将会设置标志，并且返回 false，表示这个线程持有锁，并且结束循环。然后，线程可以自由的修改由互斥锁保护的数据。这时，任何调用 lock()的线程，将会看到已设置的标志，并且将阻塞在 test_and_set()的循环中。<br />
</p>

<p>
当持有锁的线程完成对保护数据的修改，它会调用 unlock()，这会调用带有 std::memory_order_release 语义的 flag.clear()。其和随后对 flag.test_and_set()的调用相同步，这个 flag.test_and_set()调用来源于另一个线程调用 lock()，并且这个调用具有 std::memory_order_acquire 语义。因为对保护数据的修改，必须 sequenced before unlock()调用，这些对保护数据的修改先 happens-before unlock()，然后 happens-before 第二个线程的 lock()调用 (因为 synchronizes with 关系是在 unlock()和 lock()之间)，并且也 happens-before 于第二个线程在获得锁后对保护数据的任何操作。<br />
</p>

<p>
尽管其他互斥锁的实现有不同的内部操作，但基本原理是一样的：lock()是一个内部内存位置上的 acquire 操作，而 unlock 是相同内存位置上的一个 release 操作。<br />
</p>

<p>
从 synchronizes-with 关系的角度看，每个在第 2、3、4 章中描述的同步机制都提供了顺序保障，这使你能够使用它们来同步你的数据，并提供顺序保障。以下是这些设施提供的同步关系：<br />
</p>
<ul class="org-ul">
<li>std::thread<br />
<ul class="org-ul">
<li>thread 构造函数完成 和 新线程对函数参数或可调用对象的调用 相同步。<br /></li>
<li>线程的结束和成功调用 join 的返回相同步<br /></li>
</ul></li>
<li>std::mutex,std::timed_mutex,std::recursive_mutex,std::recursive_timed_mutex<br />
<ul class="org-ul">
<li>对给定互斥锁对象的 lock 和 unlock 的调用，以及对 try_lock，try_lock_for 或 try_lock_until 的成功调用，构成单一全序：互斥锁的锁序。<br /></li>
<li>在给定的互斥锁对象上调用 unlock 和 随后对 lock 的调用或者随后对 try_lock，try_lock_for 或 try_lock_until 的成功调用相同步。<br /></li>
<li>对 try_lock，try_lock_for 或 try_lock_until 失败的调用，不参与任何同步关系。<br /></li>
</ul></li>
<li>std::shared_mutex,std::shared_timed_mutex<br />
<ul class="org-ul">
<li>在给定互斥锁对象上的 lock、unlock、lock_shared 和 unlock_shared 的调用，以及对 try_lock , try_lock_for , try_lock_until , try_lock_shared , try_lock_shared_for 或 try_lock_shared_until 的成功调用，构成单一全序：互斥锁的锁序。<br /></li>
<li>在给定的互斥锁对象上的 unlock 调用 和 随后对 lock 或 shared_lock 的调用，或是对 try_lock , try_lock_for, try_lock_until, try_lock_shared, try_lock_shared_for 或 try_lock_shared_until 的成功调用相同步。<br /></li>
<li>对 try_lock，try_lock_for，try_lock_until，try_lock_shared，try_lock_shared_for 或 try_lock_shared_until l 失败的调用，不参与任何同步关系。<br /></li>
</ul></li>
<li>std::promise,std::future and std::shared_future<br />
<ul class="org-ul">
<li>给定 std::promise 对象上调用 set_value 或 set_exception 成功完成和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
<li>析构给定 std::promise 对象会在共享异步状态中写入一个 std::future_error 异常，其和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
</ul></li>
<li>std::packaged_task, std::future and std::shared_future<br />
<ul class="org-ul">
<li>调用给定 std::packaged_task 对象的调用操作符成功完成和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
<li>析构给定 std::packaged_task 对象会在共享异步状态中写入一个 std::future_error 异常，其和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
</ul></li>
<li>std::async, std::future and std::shared_future<br />
<ul class="org-ul">
<li>使用 std::launch::async 策略调用 std::async 启动线程执行任务完成和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
<li>使用 std::launch::deferred 策略调用 std::async 启动线程执行任务完成和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
</ul></li>
<li>std::experimental::future , std::experimental::shared_future and continuations<br />
<ul class="org-ul">
<li>使异步共享状态变为就绪的事件和在该共享状态上的调度的 continuation 函数的调用相同步<br /></li>
<li>一个 continuation 函数和相关 future 对象上调用 wait 和 get，或 wait_for，wait_until 成功相同步（tips：wait_for wait_until 返回 std::future_status::ready 表示成功）<br /></li>
</ul></li>
<li>std::experimental::latch<br />
<ul class="org-ul">
<li>在给定 std::experimental::latch 实例上的 每个 count_down 或 count_down_and_wait 调用和每个在该锁存器上对 wait 或 count_down_and_wait 成功调用的完成相同步。<br /></li>
</ul></li>
<li>std::experimental::barrier<br />
<ul class="org-ul">
<li>在给定 std::experimental::barrier 实例上的每次 arrive_and_wait 或 arrive_and_drop 调用和每个随后在该屏障上对 arrive_and_wait 调用的完成相同步。<br /></li>
</ul></li>
<li>std::experimental::flex_barrier<br />
<ul class="org-ul">
<li>在给定 std::experimental::flex_barrier 实例上的每次 arrive_and_wait 或 arrive_and_drop 调用和每个随后在该屏障上对 arrive_and_wait 成功调用的完成相同步。<br /></li>
<li>在给定 std::experimental::flex_barrier 实例上的每次 arrive_and_wait 或 arrive_and_drop 调用和在该屏障上随后调用的完成函数相同步。<br /></li>
<li>在给定 std::experimental::flex_barrier 实例上从完成函数的返回和每个在该屏障上对 arrive_and_wait 调用的完成相同步，当完成函数被调用的时候，arrive_and_wait 会在这个屏障处阻塞等待。<br /></li>
</ul></li>
<li>std::condition_variable and std::condition_variable_any<br />
<ul class="org-ul">
<li>条件变量不提供任何同步关系。他们是对循环忙等的优化，所有的同步都是由相关的 mutex 操作提供的。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2547bae" class="outline-3">
<h3 id="org2547bae">06 designing lock-based concurrent data structures</h3>
<div class="outline-text-3" id="text-org2547bae">
<p>
对于编程问题来说，数据结构的选择是整个解决方案中的重要部分，对于并行编程问题也不例外。若多线程访问一个数据结构时，要么该数据是完全不变的，这样就不需要同步了，要么必须保证多个线程对数据的修改能被正确同步。一种方案是使用 mutex 对数据进行保护，另一种方案是设计一种数据结构，其自身允许并发访问。设计并发数据结构时，你可以利用多线程应用程序的基础构建块(如 mutexes、condition variables 等)。<br />
</p>
</div>
<div id="outline-container-orgc49fa6f" class="outline-4">
<h4 id="orgc49fa6f">What does it mean to design for concurrency? (197)</h4>
<div class="outline-text-4" id="text-orgc49fa6f">
<p>
设计一个并发的数据结构意味着多个线程可以并发访问该数据结构，多个线程可以同时执行相同的操作，也可以执行不同的操作，并且每个线程看到的数据结构是自洽的，没有数据被丢失或损坏，所有的不变性都被支持，并且没有错误的 race conditions 存在。这样的数据结构也被称为是线程安全的(thread-safe)。<br />
真正的并发意味着为多个线程访问数据结构提供并发的机会。而使用 mutex 保护数据结构，同一时间只允许一个线程对 mutex 进行上锁，其禁止了真正的并发访问。这被称为串行化：多个线程必须轮流访问被 mutex 保护的数据。因此，你必须仔细思考数据结构的设计，从而可以达到真正的并发访问。一些数据结构比另外一些数据结构有更好的并发空间，就普遍性来说：保护的区域越小，串行的操作越少，并发的机会就越大。<br />
</p>
</div>
<div id="outline-container-orgc76a0ea" class="outline-5">
<h5 id="orgc76a0ea">Guidelines for designing data structures for concurrency (198)</h5>
<div class="outline-text-5" id="text-orgc76a0ea">
<p>
设计并发访问的数据结构时，可以从两个角度来考虑：1 确保访问的多线程安全性。2 提高并发的可能性。<br />
本书第 3 章讲了多线程安全的一些准则：<br />
</p>
<ul class="org-ul">
<li>当一个线程破坏了数据结构的不变性时，确保其他线程无法观测到该情况。<br /></li>
<li>避免数据结构的接口存在固有的 race conditions。（如：将 stack 数据结构的 top()和 pop()函数合在一起）<br /></li>
<li>注意数据结构在出现异常时的行为，以确保不变性不被破坏。<br /></li>
<li>限制加锁的区域并尽量避免嵌套加锁，从而最小化死锁的机会。<br /></li>
</ul>

<p>
另外，你对使用数据结构的用户所加的限制对于线程安全也很重要。当一个线程使用特定函数访问数据结构时，其他线程调用哪些函数是安全的？ 通常构造函数和析构函数需要互斥访问数据结构，但是，只能由用户保证不在构造完成前访问数据结构，也不在析构开始后访问数据结构。如果数据结构支持赋值、swap()、copy 构造，则数据结构的设计者需要确定这些操作和其他操作是否可以并发执行，或者是否要求用户保证这些操作需要互斥执行。<br />
</p>

<p>
对于提高并发的可能性来说，无法提供可行的准则，但是设计者可以通过回答下面的问题得到一些帮助：<br />
</p>
<ul class="org-ul">
<li>加锁的区域是否可以被限制，从而让一部分操作在锁区域外执行？<br /></li>
<li>是否数据结构的不同部分可以使用不同的 mutexes？<br /></li>
<li>是否所有的操作都需要相同等级的保护？<br /></li>
<li>对数据结构的简单更改能否在不影响操作语义的情况下提高并发的机会？<br /></li>
</ul>

<p>
上面这些问题都基于一个理念：尽量减少必要的串行，最大化真正的并行。<br />
通常数据结构支持读取数据的多个线程并发访问，而修改数据的线程必须互斥访问数据结构（可以使用 std::shared_mutex 来实现）。类似地，通常数据结构支持多个线程的不同操作并发访问，而多个线程的相同操作则需要串行。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8572d74" class="outline-4">
<h4 id="org8572d74">Lock-based concurrent data structures (199)</h4>
<div class="outline-text-4" id="text-org8572d74">
<p>
基于锁设计并发数据结构需要保证访问数据时正确的 mutex 被上锁，并且上锁的持续时间能最小。当使用一个 mutex 保护数据结构时，你需要确保在 mutex 保护区域外不访问数据结构，并且接口之间不存在固有的 race conditions。当使用多个 mutex 保护数据结构时，如果某些操作需要对多个 mutex 上锁，你还需要确保处不出现死锁。因此，使用多个 mutex 时需要更加谨慎小心。<br />
</p>
</div>
<div id="outline-container-org1319d1a" class="outline-5">
<h5 id="org1319d1a">A thread-safe stack using locks (199)</h5>
<div class="outline-text-5" id="text-org1319d1a">
<p>
下面代码实现了类似 std::stack&lt;&gt; 的线程安全的数据结构。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;exception&gt;</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">empty_stack</span>: <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">exception</span>
{
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #bc6ec5; font-weight: bold;">what</span>() <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">throw</span>();
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">stack</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_stack</span>(){}
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_stack</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp; <span style="color: #7590db;">other</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(other.m);
        data=other.data;
    }

    <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_stack</span>&amp;) = <span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        data.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data.empty()) <span style="color: #4f97d7; font-weight: bold;">throw</span> empty_stack();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::move(data.top())));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        data.pop();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data.empty()) <span style="color: #4f97d7; font-weight: bold;">throw</span> empty_stack();
        value=<span style="color: #a45bad;">std</span>::move(data.top());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        data.pop();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data.empty();
    }
};
</pre>
</div>
<p>
按照前面提供的 Guidelines 进行分析：<br />
</p>
<ul class="org-ul">
<li>每个成员函数都使用 mutex m 来进行保护，其保证了任何一个时间点只有一个线程可以访问数据，因此每个成员函数都维持了数据的不变性，没有其他线程可以观察到不变性被破坏的情况。<br /></li>
<li>empty() 和 pop() 函数之间有潜在的 race condition，但是，pop 中显示检查了数据是否为空，因此，这里的 race condition 不会导致问题。此处的 pop() 函数还通过返回值或引用直接将 pop 的值返回，避免了 top()和 top()函数的 race condition。<br /></li>
<li>有些地方可能会抛出异常。<br />
<ul class="org-ul">
<li>对 mutex 上锁可能会抛出异常。这种情况极其少见(这表示 mutex 有问题或者缺少系统资源)，对 mutex 上锁的操作是所有成员函数的第一个操作，该操作发生时，数据还没被修改，因此就算发生异常也是安全的。<br /></li>
<li>对 mutex 解锁是不会失败的，其总是安全的，并且这里使用了 std::lock_guard&lt;&gt;，其保证退出成员函数后 mutex 总是会被解锁。<br /></li>
<li>(1)处的 data.push()可能会抛出异常。但是 std::stack&lt;&gt; 保证了安全性（即使发生异常，数据不会出问题），因此也不会导致问题。<br /></li>
<li>(2)处会抛出 empty_stack 的异常，但是，此时数据还没有被修改，因此也是安全的。<br /></li>
<li>(3)处也可能抛出异常，可能情况有两个：1-调用 make_shared 时没有足够内存；2-将数据 copying/moving 到新分配的内存时出错。这两种情况下，c++运行时和标准库都可以保证没有内存被泄露并且新创建的对象可以正确被销毁。此时数据还没有被修改，因此也是安全的。<br /></li>
<li>(4)处的代码不会抛出异常<br /></li>
<li>(5)处的 copy 赋值或 move 赋值操作符可能会抛出异常，但是，此时数据还没有被修改，因此也是安全的。<br /></li>
<li>(6)处的代码不会抛出异常<br /></li>
<li>empty()成员函数不修改任何数据，因此也是安全的。<br /></li>
</ul></li>
<li>上面成员函数对 mutex 加锁后，调用了用户的代码，因此可能会导致死锁。例如：(1)(3)(5)处的 copy 赋值操作符，move 赋值操作符，并且用户可能自定义了 new 操作符。如果这些函数或者调用了栈上的成员函数（而栈正在插入或移除数据项），或者需要任何类型的锁，而在调用栈成员函数时又持有了另一把锁，那么就有可能出现死锁。但明智的做法是要求栈的用户负责确保这一点；你不能期望在不拷贝或不为它分配内存的情况下将数据项添加到栈或从栈中删除。<br /></li>
</ul>

<p>
由于所有成员函数都使用 std::lock_guard&lt;&gt;保护数据，所以不管多少线程调用栈成员函数都是安全的。唯一不安全的成员函数是构造函数和析构函数，但这不是问题：对象只能被构造一次，也只能被销毁一次。不管并发与否，调用一个不完全构造的对象或是部分销毁的对象的成员函数永远都不可取。因此，用户必须确保其他线程直到栈完全构造才能访问它，并且必须确保在栈对象销毁前，所有线程都已经停止访问栈。虽然，多个线程可以并发调用栈的成员函数，但是，由于使用了 mutex，同一时间只有一个线程可以在栈上执行操作。多个线程的串行限制了应用程序的性能：当一个线程等待上锁时，其无法执行任何有意义的工作。而且，栈没有提供任何方法用于获取有 item 被添加到栈的消息，线程只能周期性的调用 empty()或 pop() 方法进行检查。当这样的需求出现时，该 stack 是一个非常不好的选项。因为等待线程必须消耗宝贵的资源检查数据或者编写额外的等待和通知代码（例如，使用条件变量），这就使内部上锁没有必要，因而造成浪费。<br />
</p>
</div>
</div>
<div id="outline-container-org48b1a8d" class="outline-5">
<h5 id="org48b1a8d">A thread-safe queue using locks and condition variables (202)</h5>
<div class="outline-text-5" id="text-org48b1a8d">
<p>
下面代码实现了类似 std::queue&lt;&gt; 的线程安全的数据结构。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">mut</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data_queue</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">data_cond</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>()
    {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">data</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_queue.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">data</span>));
        data_cond.notify_one();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        value=<span style="color: #a45bad;">std</span>::move(data_queue.front());
        data_queue.pop();
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::move(data_queue.front())));
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty())
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        value=<span style="color: #a45bad;">std</span>::move(data_queue.front());
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty()) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::move(data_queue.front())));
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data_queue.empty();
    }
};
</pre>
</div>

<p>
新的 wait_and_pop()函数解决了等待条目被添加的问题；等待线程没有持续调用 empty()进行判断，而是调用 wait_and_pop()函数，数据结构内部使用条件变量来处理等待。对 data_cond.wait()的调用，直到队列中至少有一个元素时才会返回，所以不用担心会出现空队列的情况，并且数据仍然被互斥锁保护。因此，这些函数不会添加任何新的 race conditions 或死锁的可能性，并且保持了数据结构的不变性。<br />
</p>

<p>
在异常安全性方面有一个细微的变化，当一个条目被推入队列时，如果有多个线程在等待，那么只有一个线程会被 data_cond.notify_one()唤醒。但是，如果这个线程在 wait_and_pop()中抛出一个异常，比如当构造新的 std::shared_ptr&lt;&gt;对象(4)时，那么没有其他线程被唤醒。如果这种情况不可接受，那么调用可以替换成 data_cond.notify_all()，它将唤醒所有的工作线程，代价就是大多线程发现队列依旧是空时，重新进入休眠状态。第二种替代方案是，有异常抛出时，让 wait_and_pop()函数调用 notify_one()，从而让另一个线程可以去尝试检索存储的值。第三种替代方案是，将 std::shared_ptr&lt;&gt;的初始化过程移到 push()中，并且存储 std::shared_ptr&lt;&gt;实例，而不是直接使用数据值。将 std::shared_ptr&lt;&gt;从内部 std::queue&lt;&gt;中拷出不会抛出异常，这样 wait_and_pop()又是安全的了。下面的程序清单，就是基于这种思路修改的。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">mut</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">data_queue</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">data_cond</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>()
    {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        value=<span style="color: #a45bad;">std</span>::move(*data_queue.front());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        data_queue.pop();
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty()) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        value=<span style="color: #a45bad;">std</span>::move(*data_queue.front());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_cond.wait(lk,[<span style="color: #4f97d7; font-weight: bold;">this</span>]{<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">!</span>data_queue.empty();});
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>=data_queue.front();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(data_queue.empty()) <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>=data_queue.front();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        data_queue.pop();
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>)));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        data_queue.push(data);
        data_cond.notify_one();
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(mut);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data_queue.empty();
    }
};
</pre>
</div>

<p>
通过 std::shared_ptr&lt;&gt;持有数据还有个好处：在 (5)处 push()中分配新实例可以在锁外面完成，而在清单 6.2 中（本节中第一个实现中），只能在 pop()持有锁时完成。因为内存分配是个典型的代价高昂的操作，这有利于队列的性能，因为它减少了持有互斥锁的时间，并允许其他线程同时在队列上执行操作。<br />
</p>

<p>
和栈示例一样，使用 mutex 保护整个数据结构限制了并发，尽管多个线程可以调用多个成员函数，但是同一时间只有一个线程可以工作。这样的限制源于使用了 std::queue&lt;&gt;, 使用标准库容器，你只能对一个容器数据整体进行加锁或不加锁控制；如果可以控制容器的实现细节，你就可以进行更加细粒度的加锁控制，从而提高并发性。<br />
</p>
</div>
</div>
<div id="outline-container-org12893ab" class="outline-5">
<h5 id="org12893ab">A thread-safe queue using fine-grained locks and condition variables (206)</h5>
<div class="outline-text-5" id="text-org12893ab">
<p>
在前面一节的示例中，你只有一个数据项需要被保护，因此只使用一个 mutex。为了更加细粒度地控制加锁，你需要控制 queue 的实现细节，为每个不同的数据项关联一个 mutex。最简单的 queue 数据结构如下图所示。其有一个 head 指针指向列表的第一个元素，列表中每个元素指向下一个元素，其还有一个 tail 指针指向列表的最后一个元素。删除元素时，将 head pointer 向下移动，并返回被删除的元素；增加元素时，将新元素添加在队列的尾端，并更新 tail 指向新元素；当列表为空时，head 和 tail 指针都为 null。<br />
<img src="./AsynchronousProgramming/06_02_03_queue.jpg" alt="06_02_03_queue.jpg" /><br />
</p>

<p>
下面代码实现了单线程版本的 queue：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">data</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;std::unique_ptr &#30830;&#20445;&#19981;&#20877;&#20351;&#29992;&#26102;&#65292;&#25968;&#25454;&#33021;&#34987;delete</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;

        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::move(data_)) {}
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">tail&#20351;&#29992;&#20102;&#21407;&#22987;&#25351;&#38024;&#65292;&#22240;&#20026;&#20854;&#25152;&#25351;node&#24050;&#32463;&#34987;std::unique_ptr&lt;node&gt; &#25152;&#25317;&#26377;</span>
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">tail</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">queue</span>()
    {}
    <span style="color: #bc6ec5; font-weight: bold;">queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>head)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
        }
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::move(head-&gt;data)));
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::move(head);
        head=<span style="color: #a45bad;">std</span>::move(old_head-&gt;next);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>head) tail=<span style="color: #a45bad;">nullptr</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">p</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>)));
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_tail</span>=p.get();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(tail)
        {
            tail-&gt;next=<span style="color: #a45bad;">std</span>::move(p);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            head=<span style="color: #a45bad;">std</span>::move(p);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        }
        tail=new_tail;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
};
</pre>
</div>

<p>
单线程版本 queue 逻辑分析如下：<br />
<img src="./AsynchronousProgramming/06_02_03_queue_detail.jpg" alt="06_02_03_queue_detail.jpg" /><br />
</p>

<p>
上面的实现在单线程情况下工作正常。考虑到你只有两个数据项(head 和 tail)，理论上应该使用两个 mutex，一个用于保护 head 一个用于保护 tail。但是这样会导致很多问题。最明显的问题是 push() 函数会同时修改 head 和 tail，因此你需要对两个 mutex 都上锁。更严重的问题是 push()和 pop()可能会访问同一个 node 的 next 指针: push()在(4)处会更新 tail-&gt;next, try_pop()在(3)处会读取 head-&gt;next。如果队列中只有一个 item，head 就会和 tail 相同，head-&gt;next 和 tail-&gt;next 是相同对象，因此需要对他们进行保护。不读取 head 和 tail，无法确定他们是否是相同对象，因此，需要在 push()和 try_pop()中对两个 mutex 都加锁，而这和前面一节中对整个 queue 上锁也没差别了。<br />
</p>
</div>

<div id="outline-container-org742556e" class="outline-6">
<h6 id="org742556e">ENABLING CONCURRENCY BY SEPARATING DATA</h6>
<div class="outline-text-6" id="text-org742556e">
<p>
你可以通过预先分配一个没有数据的傀儡节点(dummy node)来解决这个问题，以确保队列中至少有一个节点将头部访问的节点与尾部访问的节点分开。对一个空队列，head 和 tail 都指向傀儡节点，而非 NULL 指针。这很好，因为如果队列为空，try_pop()就不会访问 head-&gt;next 了。如果添加一个节点到队列中(所以有一个真实节点)，那 head 和 tail 现在会指向不同的节点，所以在 head-&gt;next 和 tail-&gt;next 上不会有竞争。但缺点是，为了允许虚拟节点的存在，需要增加额外的一层间接性——通过指针来存储数据。下面的代码展示了这个方案。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">tail</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#39044;&#20808;&#20998;&#37197;&#19968;&#20010;dummy node, head&#21644;tail&#37117;&#25351;&#21521;&#36825;&#20010;dummy node</span>
    <span style="color: #bc6ec5; font-weight: bold;">queue</span>(): head(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>),tail(head.get())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {}
    <span style="color: #bc6ec5; font-weight: bold;">queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(head.get()==tail)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
        }
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>(head-&gt;data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::move(head);
        head=<span style="color: #a45bad;">std</span>::move(old_head-&gt;next);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>)));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">p</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>);  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
        tail-&gt;data=new_data;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_tail</span>=p.get();
        tail-&gt;next=<span style="color: #a45bad;">std</span>::move(p);
        tail=new_tail;
    }
};
</pre>
</div>
<p>
下面是对这种队列的分析：<br />
<img src="./AsynchronousProgramming/06_02_03_queue_with_dummyNode.jpg" alt="06_02_03_queue_with_dummyNode.jpg" /><br />
经过上面修改后，push()只需要访问 tail 而不需要访问 head。try_pop()会同时访问 head 和 tial，但是 tail 只在一开始的比较操作处被使用，因此上锁持续时间短。最大的收获就是 try_pop() 和 push()永远都不会操作同一个节点，这样就不需要同一个 mutex 了，head 可以使用一个 mutex，而 tail 使用另外一个。下面代码实现了线程安全的 queue，且使用了两个 mutex:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">head_mutex</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">tail_mutex</span>;
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">tail</span>;

    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #bc6ec5; font-weight: bold;">get_tail</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">tail_lock</span>(tail_mutex);
        <span style="color: #4f97d7; font-weight: bold;">return</span> tail;
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop_head</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(head.get()==get_tail())
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">nullptr</span>;
        }
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::move(head);
        head=<span style="color: #a45bad;">std</span>::move(old_head-&gt;next);
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head;
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>(): head(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>),tail(head.get()) {}
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=pop_head();
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head?old_head-&gt;data:<span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>)));
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">p</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>);
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_tail</span>=p.get();
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">tail_lock</span>(tail_mutex);
        tail-&gt;data=new_data;
        tail-&gt;next=<span style="color: #a45bad;">std</span>::move(p);
        tail=new_tail;
    }
};
</pre>
</div>
<p>
下面按照前面列出的 Guideline 来分析上面实现。首先，我们先列出上面实现所包含的不变性：<br />
</p>
<ul class="org-ul">
<li>tail-&gt;next == nullptr<br /></li>
<li>tail-&gt;data == nullptr<br /></li>
<li>列表为空时，head==tail<br /></li>
<li>列表中只有一个元素时，head-&gt;next==tail<br /></li>
<li>对于列表中的任何一个节点 x，当 x!=tail 时，x-&gt;data 指向 T 类型的实例，并且 x-&gt;next 指向列表中下一个节点。x-&gt;next==tail 时，说明 x 为列表中最后一个节点。<br /></li>
<li>从 head 开始沿着 next 一定能得到 tail<br /></li>
</ul>

<p>
push() 函数对数据结构的修改都被 tail_mutex 保护，从而保持了数据结构的不变性，新的尾节点是一个空节点（傀儡节点），并且旧的尾节点的 data 和 next 都设置好了，这个旧尾节点现在是列表中最后一个真实节点（非傀儡节点）。<br />
try_pop()函数不仅需要使用 tail_mutex 来保护对 tail 的读取，其还要确保从 head 中读取数据时没有 data race。如果没有对两者都进行保护，当一个线程调用 try_pop 而另一个线程同步调用 push 时，这两个线程的操作之间的顺序将是未定义的。即使两个成员函数各自持有一个 mutex，他们依然有可能访问相同的数据；毕竟，队列中的所有数据都是由 push()函数调用而来的。如果没有定义多个线程访问相同数据的顺序，则可能存在 data race，进而导致未定义行为。因为 get_tail 和 push 对同一个 tail_mutex 进行了上锁，因此这两个函数的顺序是有定义的。当 get_tail()发生在 push()之前，get_tail 获得的是旧的 tail，当 get_tail()发生在 push()之后，get_tail 获得新的 tail。重要的是必须在对 head_mutex 上锁后调用 get_tail()，否则 pop_head()可能会卡在 get_tail()和 对 head_mutex 加锁之间，因为其他线程调用 try_pop()需要先对 tail_mutex 进行上锁，从而导致线程无法向前执行。（TODO：前面这句号没有理解）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;node&gt; <span style="color: #bc6ec5; font-weight: bold;">pop_head</span>() <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#26159;&#20010;&#26377;&#32570;&#38519;&#30340;&#23454;&#29616;</span>
{
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_tail</span>=get_tail();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#22312;head_mutex&#33539;&#22260;&#22806;&#33719;&#21462;&#26087;&#23614;&#33410;&#28857;&#30340;&#20540;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(head.get()==old_tail)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">nullptr</span>;
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::move(head);
    head=<span style="color: #a45bad;">std</span>::move(old_head-&gt;next);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> old_head;
}
</pre>
</div>
<p>
在这个有缺陷的场景下，(1)处在锁的外面调用 get_tail()，初始线程获得 head_mutex 锁时，也许会发现 head 和 tail 都发生了改变。并且，不光返回的 tail 节点不再是尾节点，甚至可能它都不在列表中了。这意味着即使 head 是最后一个节点，(2)处比较 head 和 old_tail 也会失败。此时，当(3)处更新 head 时，可能会将 head 越过 tail 并离开列表的尾端，这样的话数据结构就遭到了破坏。正确实现中(清单 6.6)，需要保证在 head_mutex 保护的范围内调用 get_tail()。就能保证没有其他线程对 head 进行修改，并且 tail 只会往后移动(当有新节点添加进来时)，这样就很安全了。head 永远无法穿过 get_tail()返回的值，所以不变性被保持。一旦 pop_head()通过更新 head 把节点从队列中删除时，互斥锁就被解锁，并且 try_pop()可以提取数据，并在有数据的时候删除一个节点(若没有数据，则返回 std::shared_ptr&lt;&gt;的 NULL 实例)，因为只有一个线程可以访问这个节点，所以这个操作是安全的。<br />
</p>

<p>
分析每个接口，可以得出他们之间不存在固有的 race condition。<br />
</p>

<p>
接下来分析异常。try_pop()中唯一可以抛出异常的地方在对 mutex 上锁时，此时数据还没有被修改，因此，try_pop()是异常安全的。push()函数 new 了一个 T 类型的实例，并且还 new 了一个 node 对象，这两次操作都可能抛出异常，但是他们分配出来的新对象都赋值给了智能指针，当抛出异常时，这些对象都能被正确释放。对互斥量上锁后，剩余的代码不会再抛出异常，因此 push()也是异常安全的。<br />
</p>

<p>
接下来分析死锁。因为没有修改任何接口，所以没有新的外部机会导致死锁。在实现内部也不会有死锁；唯一需要获取两个锁的是 pop_head()，这个函数都是先获取 head_mutex 然后 tail_mutex，所以永远不会死锁。<br />
</p>

<p>
接下来分析并发性。与清单 6.2 相比，这个数据结构具有更大的并发范围，因为锁的粒度更细，并且更多操作是在锁外完成的。比如，push()中新节点和新数据项的分配都不需要持有锁。这意味着多个线程可以并发的分配新节点和新数据项。虽然一次只有一个线程能将它的新节点添加到列表中，但完成这个工作的代码只是几个简单的指针赋值，所以相较于基于 std::queue&lt;&gt;的实现（整个内存分配操作都需要持有锁），这里持有锁的时间很短。同样，try_pop()持有 tail_mutex 来保护对 tail 读取的时间也很短。因此，try_pop()调用几乎完全可以和 push()调用一起并发发生。同样持有 head_mutex 的时候执行的操作也非常的少；昂贵的 delete（在 node 指针的析构函数中）在锁的外部。这将增加并发调用 try_pop()的次数；虽然一次只有一个线程调用 pop_head()，但是多个线程可以删除它们的旧节点以及安全地返回数据。<br />
</p>
</div>
</div>
<div id="outline-container-org402b242" class="outline-6">
<h6 id="org402b242">Waiting FOR AN ITEM TO POP</h6>
<div class="outline-text-6" id="text-org402b242">
<p>
上面的实现没有支持 wait_and_pop()，下面展示如何增加该函数：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">head_mutex</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">tail_mutex</span>;
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">tail</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span> <span style="color: #7590db;">data_cond</span>;
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #bc6ec5; font-weight: bold;">get_tail</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">tail_lock</span>(tail_mutex);
        <span style="color: #4f97d7; font-weight: bold;">return</span> tail;
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop_head</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#20462;&#25913;list&#26469;&#21024;&#38500;head item</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::move(head);
        head=<span style="color: #a45bad;">std</span>::move(old_head-&gt;next);
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head;
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_for_data</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#31561;&#24453;&#38431;&#21015;&#20013;&#26377;&#25968;&#25454;&#28155;&#21152;&#36827;&#26469;&#65292;&#36827;&#32780;&#21487;&#20197;&#34987;pop&#20986;&#21435;</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);
        data_cond.wait(head_lock,[&amp;]{<span style="color: #4f97d7; font-weight: bold;">return</span> head.get()!=get_tail();});
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::move(head_lock);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#36820;&#22238;head_lock&#23454;&#20363;, &#20445;&#35777;&#19979;&#38754;4&#21644;5&#22788;&#25345;&#26377;&#30456;&#21516;&#30340;&#38145;</span>
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_pop_head</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(wait_for_data());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> pop_head();
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_pop_head</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(wait_for_data());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        value=<span style="color: #a45bad;">std</span>::move(*head-&gt;data);
        <span style="color: #4f97d7; font-weight: bold;">return</span> pop_head();
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop_head</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(head.get()==get_tail())
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;();
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> pop_head();
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop_head</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(head.get()==get_tail())
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;();
        }
        value=<span style="color: #a45bad;">std</span>::move(*head-&gt;data);
        <span style="color: #4f97d7; font-weight: bold;">return</span> pop_head();
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>(): head(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>),tail(head.get()) {}
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=wait_pop_head();
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head-&gt;data;
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait_and_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=wait_pop_head(value);
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=try_pop_head();
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head?old_head-&gt;data:<span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=try_pop_head(value);
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head;
    }
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">head_lock</span>(head_mutex);
        <span style="color: #4f97d7; font-weight: bold;">return</span> (head.get()==get_tail());
    }
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_value</span>)));
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">p</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>);
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">tail_lock</span>(tail_mutex);
            tail-&gt;data=new_data;
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_tail</span>=p.get();
            tail-&gt;next=<span style="color: #a45bad;">std</span>::move(p);
            tail=new_tail;
        }
        data_cond.notify_one();
    }
};

</pre>
</div>
<p>
修改 push()是比较简单的，只需要在函数末尾添加 data_cond.notify_one()就可以了。但是，也不是非常简单；为了最大化并发的可能性，你需要细粒度地控制上锁。如果让 tail_mutex 的上锁区域覆盖 data_cond.notify_one(), 若被通知的线程在 tail_mutex 被解锁之前就被唤醒，此时线程只能阻塞等待 tail_mutex 被解锁。如果在调用 data_cond.notify_one()之前对 tail_mutex 进行解锁，线程唤醒后就不需要阻塞等待了。<br />
</p>

<p>
wait_and_pop()有点复杂，因为需要确定在哪等待，停止等待的条件是什么？以及要锁住哪个互斥锁？ 停止等待的条件是“队列非空”，也就是 head!=tail。但这么写的话，就需要同时锁住 head_mutex 和 tail_mutex，不过在清单 6.6 中已经明确了，只需要锁住 tail_mutex 来保护对 tail 的读取，比较操作本身不需要锁住 tail_mutex，所以这里也可以应用相同的逻辑。如果你让停止等待的条件变成 head!=get_tail()，就只需要持有 head_mutex，然后你可以使用 head_mutex 对 data_cond.wait()的调用进行保护。剩余的逻辑就和 try_pop()一样了。<br />
</p>

<p>
try_pop()和 wait_and_pop()的重载版本（返回值类型为 std::shared_ptr&lt;T&gt;的版本）的实现需要仔细斟酌。如果将返回 std::shared_ptr&lt;T&gt; 替换为给引用类型参数 value 赋值而返回，则可能会有异常不安全问题。此时，数据项已经从队列中删除，mutex 也已经解锁；只剩将数据返回给调用者。如果 copy 赋值抛出异常，则数据项就会被丢失。如果模板参数 T 的实参类型有不抛异常的 move-assignment 操作符或者不抛异常的 swap 操作，你可以使用这些操作，但是应该选择更通用的方案，其适用于任意的模板实参类型。这里，你需要将异常抛出操作放到加锁区域内，并且在节点从列表中移出前。因此你需要对 pop_head()进行重载，在列表修改之前，获得其中的值。<br />
</p>

<p>
上面的队列是一个无界队列；只要内存够用，即使没有元素被删除，线程也可以不断往队列中添加新的数据项。与之相对的是有界队列，有界队列在创建的时候最大长度就已经固定了。一旦有界队列已满，尝试往队列中添加更多元素要么会失败要么会阻塞到有一个元素从队列中弹出而腾出空间。当在线程间基于任务划分工作的时候，有界队列有助于工作的均匀分布(参见第 8 章)，这防止了填充队列的线程遥遥领先于从队列读取数据项的线程。在 push()函数中，执行条件变量等待，就可以将无界队列扩展为有界队列。不是等待队列中有数据，而是等待队列中的数据比允许的最大数量要少。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org38f4d3a" class="outline-4">
<h4 id="org38f4d3a">Designing more complex lock-based data structures (217)</h4>
<div class="outline-text-4" id="text-org38f4d3a">
<p>
stack 和 queue 比较简单，他们的接口都非常有限，并且他们都只适用于特定需求。有很多数据结构则比较复杂，他们支持很多种操作。原则上来讲，这会增加并发的机会，但是，因为需要考虑多种访问模式，这让数据的保护更难。<br />
</p>
</div>
<div id="outline-container-orga2ef6d3" class="outline-5">
<h5 id="orga2ef6d3">Writing a thread-safe lookup table using locks (217)</h5>
<div class="outline-text-5" id="text-orga2ef6d3">
<p>
查找表或字典实现了将一种类型的值(键类型)关联到另一种类型的值 (映射的类型)。一般情况下，这种结构允许查询与给定键关联的数据。在 C++标准库，这种设施通过关联容器提供：std::map&lt;&gt;，std::multimap&lt;&gt;，std::unordered_map&lt;&gt;和 std::unordered_multimap&lt;&gt;。<br />
</p>

<p>
查找表的使用模式不同于栈和队列。无论是添加还是删除一个元素，栈和队列上几乎每个操作都会以某种方式对它进行修改，但查找表很少被修改。清单 3.13 中的简单 DNS 缓存就是这样一个例子，只不过相较于 std::map&lt;&gt;削减了很多接口。正如你在栈和队列中看到的，当要从多个线程并发地访问数据结构时，标准容器的接口并不适用，因为接口设计中存在固有的 race conditions，因此需要删减和修改它们。<br />
</p>

<p>
从并发视角看，std::map&lt;&gt;接口最大的问题是迭代器。当其他线程访问（或修改）容器时，有可能让迭代器提供对容器的安全访问，但这是一个棘手的问题。正确处理迭代器需要你处理一些问题，例如另一个线程正在删除迭代器所引用的元素，这可能相当复杂。对线程安全查找表的第一次接口削减，会跳过迭代器。考虑到 std::map&lt;&gt;的接口(以及标准库中的其他关联容器)重度基于迭代器，有必要将它们放一边，并从头开始设计接口。<br />
</p>

<p>
查找表只有几个基本操作：<br />
</p>
<ul class="org-ul">
<li>添加一个新的键/值对<br /></li>
<li>修改给定键对应的值<br /></li>
<li>删除一个键及其关联的值<br /></li>
<li>通过给定键，获取对应的值（如果有的话）<br /></li>
</ul>
<p>
还有一些容器范围的操作可能很有用，比如检查容器是否为空、完整键列表的快照，或者键/值对的完整集合的快照。<br />
</p>

<p>
如果坚持简单的线程安全指南，例如：不要返回一个引用，并且用一个简单的互斥锁对每一个成员函数进行上锁，上面列出的这些所有操作都是安全的；他们要么在另一个线程的修改前要么在之后。当一个新的键/值对正在被添加时，最有可能发生 race condition；如果两个线程都添加一个新值，只有一个会先执行，然后后面那个就失败了。一种方式是合并添加和修改到一个成员函数，就像清单 3.13 对 DNS 缓存所做的那样。获取指定 key 关联的数据时，如果 key 不存在：一种方式是允许用户提供一个“默认”结果作为返回值，如下；<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">mapped_type</span> <span style="color: #bc6ec5; font-weight: bold;">get_value</span>(<span style="color: #ce537a; font-weight: bold;">key_type</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>, <span style="color: #ce537a; font-weight: bold;">mapped_type</span> <span style="color: #7590db;">default_value</span>);
</pre>
</div>
<p>
也可以扩展成返回一个 std::pair&lt;mapped_type, bool&gt;来代替 mapped_type 实例，其中 bool 代表键是否存在关联的值。另一个选择是返回一个智能指针引用关联的值，当指针的值是 NULL 时，表示没有值返回。<br />
</p>

<p>
一旦接口已经明确，(假设没有接口 race conditions)那么可以通过使用单一的互斥锁以及在成员函数周围使用一个简单的锁来保护底层数据结构，从而保证线程安全性。但这将浪费读取和修改数据结构的独立函数所提供的并发可能性。当使用一个支持多个读线程或单个写线程的互斥锁可以提高并发访问，比如清单 3.13 中使用的 std::shared_mutex。但是，也只有一个线程能修改数据结构。其实可以做到更好。<br />
</p>
</div>
<div id="outline-container-org2fb96cc" class="outline-6">
<h6 id="org2fb96cc">DESIGNING A MAP DATA STRUCTURE FOR FINE-GRAINED LOCKING</h6>
<div class="outline-text-6" id="text-org2fb96cc">
<p>
为了更加细粒度地上锁，你需要深入数据结构的细节，而不是包装已有的容器，如 std::map&lt;&gt;。有三种常用方法可以实现查找表这样的关联容器：<br />
</p>
<ul class="org-ul">
<li>二叉树，比如：红黑树<br /></li>
<li>有序数组<br /></li>
<li>哈希表<br /></li>
</ul>

<p>
二叉树并没有为增大并发机会提供太多空间；每一个查找或者修改操作都需要从访问根节点开始，因此，根节点需要上锁。虽然，随着访问线程沿着树向下移动，这个锁可以释放，但相比横跨整个数据结构的单一锁，这并没有好多少。<br />
</p>

<p>
有序数组更糟，因为你无法提前知道给定的数据值应该放哪，所以你需要一把锁用于整个数组。<br />
</p>

<p>
现在就剩哈希表了。假设有固定数量的桶，一个键属于哪个桶纯粹由键的属性以及哈希函数决定。这就意味着每个桶都可以有一个独立的锁。再使用支持多读者或单写者的互斥锁，就能将并发访问的可能性增加 N 倍，这里 N 是桶的数量。缺点是你需要为键选择一个好的哈希函数。C++标准库提供了 std::hash&lt;&gt;模板，可以用于这个用途。它已经针对基本数据类型比如 int，以及通用库类型 std::string，做了特化，并且用户可以很容易对其进行特化支持其他类型。如果遵循标准的无序容器的规则，将用于执行哈希的函数对象的类型作为模板参数，用户就可以选择是否用他们的键类型对 std::hash&lt;&gt;进行特化，还是提供一个单独的哈希函数。下面代码展示了线程安全的查找表的实现：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Key</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Value</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Hash</span>=<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">hash</span>&lt;<span style="color: #ce537a; font-weight: bold;">Key</span>&gt; &gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_lookup_table</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">bucket_type</span>
    {
    <span style="color: #4f97d7; font-weight: bold;">private</span>:
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">pair</span>&lt;<span style="color: #ce537a; font-weight: bold;">Key</span>,<span style="color: #ce537a; font-weight: bold;">Value</span>&gt; <span style="color: #ce537a; font-weight: bold;">bucket_value</span>;
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">bucket_value</span>&gt; <span style="color: #ce537a; font-weight: bold;">bucket_data</span>;
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">bucket_data</span>::<span style="color: #ce537a; font-weight: bold;">iterator</span> <span style="color: #ce537a; font-weight: bold;">bucket_iterator</span>;

        <span style="color: #ce537a; font-weight: bold;">bucket_data</span> <span style="color: #7590db;">data</span>;
        <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span> <span style="color: #7590db;">mutex</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

        <span style="color: #ce537a; font-weight: bold;">bucket_iterator</span> <span style="color: #bc6ec5; font-weight: bold;">find_entry_for</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::find_if(data.begin(),data.end(),
                                [&amp;](<span style="color: #ce537a; font-weight: bold;">bucket_value</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">item</span>)
                                {<span style="color: #4f97d7; font-weight: bold;">return</span> item.first==key;});
        }
    <span style="color: #4f97d7; font-weight: bold;">public</span>:
        <span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #bc6ec5; font-weight: bold;">value_for</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>,<span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">default_value</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span>&gt; <span style="color: #7590db;">lock</span>(mutex);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            <span style="color: #ce537a; font-weight: bold;">bucket_iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">found_entry</span>=find_entry_for(key);
            <span style="color: #4f97d7; font-weight: bold;">return</span> (found_entry==data.end())?
                default_value:found_entry-&gt;second;
        }

        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">add_or_update_mapping</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>,<span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">value</span>)
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span>&gt; <span style="color: #7590db;">lock</span>(mutex);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            <span style="color: #ce537a; font-weight: bold;">bucket_iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">found_entry</span>=find_entry_for(key);
            <span style="color: #4f97d7; font-weight: bold;">if</span>(found_entry==data.end())
            {
                data.push_back(bucket_value(key,value));
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                found_entry-&gt;second=value;
            }
        }

        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">remove_mapping</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>)
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_mutex</span>&gt; <span style="color: #7590db;">lock</span>(mutex);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            <span style="color: #ce537a; font-weight: bold;">bucket_iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">found_entry</span>=find_entry_for(key);
            <span style="color: #4f97d7; font-weight: bold;">if</span>(found_entry!=data.end())
            {
                data.erase(found_entry);
            }
        }
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">bucket_type</span>&gt; &gt; <span style="color: #7590db;">buckets</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    <span style="color: #ce537a; font-weight: bold;">Hash</span> <span style="color: #7590db;">hasher</span>;

    <span style="color: #ce537a; font-weight: bold;">bucket_type</span>&amp; <span style="color: #bc6ec5; font-weight: bold;">get_bucket</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">bucket_index</span>=hasher(key)%buckets.size();
        <span style="color: #4f97d7; font-weight: bold;">return</span> *buckets[bucket_index];
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #ce537a; font-weight: bold;">key_type</span>;
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #ce537a; font-weight: bold;">mapped_type</span>;

    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #ce537a; font-weight: bold;">Hash</span> <span style="color: #ce537a; font-weight: bold;">hash_type</span>;
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_lookup_table</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">num_buckets</span>=19,<span style="color: #ce537a; font-weight: bold;">Hash</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">hasher_</span>=Hash()):
        buckets(num_buckets),hasher(hasher_)
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;num_buckets;++i)
        {
            buckets[i].reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">bucket_type</span>);
        }
    }

    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_lookup_table</span>(<span style="color: #ce537a; font-weight: bold;">threadsafe_lookup_table</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">threadsafe_lookup_table</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">threadsafe_lookup_table</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #bc6ec5; font-weight: bold;">value_for</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>, <span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">default_value</span>=Value()) <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> get_bucket(key).value_for(key,default_value);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">add_or_update_mapping</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>,<span style="color: #ce537a; font-weight: bold;">Value</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">value</span>)
    {
        get_bucket(key).add_or_update_mapping(key,value);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">remove_mapping</span>(<span style="color: #ce537a; font-weight: bold;">Key</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">key</span>)
    {
        get_bucket(key).remove_mapping(key);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
    }
};

</pre>
</div>

<p>
上面实现(6)处使用了 std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; 来持有桶，它允许在构造函数中指定桶的数量。默认是 19 个，它可以是任意一个质数；在桶的数目为质数时，哈希表效果最佳。(1)处每一个桶由一个 std::shared_mutex 实例保护，它允许对每个桶进行多个线程的读或单个线程的写。因为桶的数量是固定的，因此可以不加锁调用(7)处 get_bucket()函数(如(8)(9)(10)处)，并且 bucket mutex 可以是共享所有权(只读，如(4)(5)处)，也可以是独占所有权(读写，如(3)处)。查找表的 3 个成员函数都使用(2)处 bucket 的成员函数 find_entry_for() 来确定一个数据项是否再 bucket 中。每个 bucket 只包含一个 std::list&lt;&gt;，其中每个元素存放了一个 key/value 对，因此，添加和移除元素很容易。<br />
</p>

<p>
接下来分析异常。value_for 不修改任何值，所以没什么问题；如果 value_for 抛出异常，也不会影响任何数据结构。remove_mapping 修改列表时，会调用 erase，不过这能保证没有异常抛出，所以也是安全的。 add_or_update_mapping 可能会在两个 if 分支上抛出异常：push_back 是异常安全的，如果有异常抛出，它也会将列表恢复成原来的状态，所以这个分支没有问题；唯一的问题是当你正在替换已存在的值时赋值；如果赋值抛出异常，你就依赖于让原始值不变。不过，总体来说这不会影响数据结构，并且它完全是用户提供类型的属性，因此可以放心的将问题交给用户去处理。<br />
</p>

<p>
查找表提供把当前状态的快照放入 std::map&lt;&gt;将是一个非常好的特性。这需要对整个容器进行上锁，即对所有 buckets 进行上锁，从而保证得到一个一致性的状态 copy。对于查找表的常见操作，一次只需要锁住一个桶，该特性是唯一一个需要锁住所有桶的操作。只要每次以相同的顺序进行上锁(例如，按桶的索引值递增顺序)，就不会产生死锁。该特性的实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">map</span>&lt;Key,Value&gt; <span style="color: #a45bad;">threadsafe_lookup_table</span>::<span style="color: #bc6ec5; font-weight: bold;">get_map</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::shared_mutex&gt; &gt; <span style="color: #7590db;">locks</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;buckets.size();++i)
    {
        locks.push_back(<span style="color: #a45bad;">std</span>::unique_lock&lt;<span style="color: #a45bad;">std</span>::shared_mutex&gt;(buckets[i].mutex));
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">map</span>&lt;Key,Value&gt; <span style="color: #7590db;">res</span>;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;buckets.size();++i)
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">bucket_iterator</span> <span style="color: #7590db;">it</span>=buckets[i].data.begin(); it!=buckets[i].data.end(); ++it)
        {
            res.insert(*it);
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>
<p>
上面查找表的实现中是对整个 bucket 进行上锁来保护数据的，更加细粒度地对单个 bucket 上锁可以更大程度增加并发机会。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge0e7e86" class="outline-5">
<h5 id="orge0e7e86">Writing a thread-safe list using locks (222)</h5>
<div class="outline-text-5" id="text-orge0e7e86">
<p>
列表是最基础的数据结构，下面讨论如何支持线程安全的列表。<br />
前面由于过于复杂，我们回避了迭代器的支持。STL 分格迭代器的主要问题在于迭代器持有了容器内部数据结构的引用，如果容器被其他线程修改，需要保证迭代器持有的引用依然有效，这就需要迭代器对数据结构的某个部分进行加锁。而 STL 分格迭代器的生命周期完全不受容器的控制，前面这种方式显然不是个好方法。另一种做法是提供迭代函数，例如将 for_each 作为容器本身的一部分。这能让容器直接负责迭代和上锁，不过这将违反第 3 章避免死锁的指南。为了让 for_each 做一些有用的事情，当持有内部锁的时候，必须调用用户提供的代码。不光这样，还需要传递每个数据项的引用到用户代码中，这样用户代码才能对容器中的元素进行操作。你可以传一份拷贝到用户代码中来避免这个问题，不过当数据很大时，代价很高。因此，将由用户来确保调用他们提供的代码不会导致死锁，以及在上锁区域外存储保护数据的引用不会导致 data races。查找表中使用列表这个例子是很安全的，因为你知道你不会做什么出格的事情。<br />
</p>

<p>
下面列出需要为列表提供的操作：<br />
</p>
<ul class="org-ul">
<li>添加一个项到列表<br /></li>
<li>从列表中删除满足某个条件的项<br /></li>
<li>从列表中查找满足某个条件的项<br /></li>
<li>更新列表中满足某个条件的项<br /></li>
<li>拷贝列表中的每一项到另一个容器中<br /></li>
</ul>

<p>
要使它成为一个优秀的通用列表容器，添加更多的操作，比如按位置插入，将会很有帮助，但这对于查找表是不必要的，此处略去。<br />
对链表进行细粒度上锁的基本思想是让每个节点都有一个互斥锁。如果列表变大，就会有很多互斥锁！这样做的好处是，对列表中不同部分的操作是真正并发的：每个操作只持有它感兴趣的节点上的锁，并在它移动到下一个节点时释放锁。下面展示了该列表的实现：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">threadsafe_list</span>
{
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">//  </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(): <span style="color: #bc6ec5; font-weight: bold;">next</span>() {}
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">value</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(value)) {}
    };

    <span style="color: #ce537a; font-weight: bold;">node</span> <span style="color: #7590db;">head</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_list</span>() {}
    ~<span style="color: #bc6ec5; font-weight: bold;">threadsafe_list</span>() { remove_if([](<span style="color: #ce537a; font-weight: bold;">node</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;){<span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;}); }

    <span style="color: #bc6ec5; font-weight: bold;">threadsafe_list</span>(<span style="color: #ce537a; font-weight: bold;">threadsafe_list</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">threadsafe_list</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">threadsafe_list</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push_front</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">new_node</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(value));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(head.m);
        new_node-&gt;next=<span style="color: #a45bad;">std</span>::move(head.next);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        head.next=<span style="color: #a45bad;">std</span>::move(new_node);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Function</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">for_each</span>(<span style="color: #ce537a; font-weight: bold;">Function</span> <span style="color: #7590db;">f</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">current</span>=&amp;head;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(head.m);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">next</span>=current-&gt;next.get())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">next_lk</span>(next-&gt;m);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
            lk.unlock();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
            f(*next-&gt;data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
            current=next;
            lk=<span style="color: #a45bad;">std</span>::move(next_lk);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">13</span>
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Predicate</span>&gt;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">find_first_if</span>(<span style="color: #ce537a; font-weight: bold;">Predicate</span> <span style="color: #7590db;">p</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">14</span>
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">current</span>=&amp;head;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(head.m);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">next</span>=current-&gt;next.get())
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">next_lk</span>(next-&gt;m);
            lk.unlock();
            <span style="color: #4f97d7; font-weight: bold;">if</span>(p(*next-&gt;data))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> next-&gt;data;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">16</span>
            }
            current=next;
            lk=<span style="color: #a45bad;">std</span>::move(next_lk);
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Predicate</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">remove_if</span>(<span style="color: #ce537a; font-weight: bold;">Predicate</span> <span style="color: #7590db;">p</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">17</span>
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">current</span>=&amp;head;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(head.m);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">next</span>=current-&gt;next.get())
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">next_lk</span>(next-&gt;m);
            <span style="color: #4f97d7; font-weight: bold;">if</span>(p(*next-&gt;data))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">18</span>
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_next</span>=<span style="color: #a45bad;">std</span>::move(current-&gt;next);
                current-&gt;next=<span style="color: #a45bad;">std</span>::move(next-&gt;next);
                next_lk.unlock();
            }  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">20</span>
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                lk.unlock();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">21</span>
                current=next;
                lk=<span style="color: #a45bad;">std</span>::move(next_lk);
            }
        }
    }
};
</pre>
</div>
<p>
下图展示了 list 操作的细节：<br />
<img src="./AsynchronousProgramming/06_03_03_list_pushfront.jpg" alt="06_03_03_list_pushfront.jpg" /><br />
</p>

<p>
threadsafe_list&lt;&gt;是一个单链表，每个条目是一个 node 结构①。一个默认构造的 node 作为列表的 head，开始时 next 指针②的值是 NULL。新节点通过 push_front()函数添加；首先会构造一个新节点④，它会在堆上分配内存③来存储数据，同时将 next 指针置为 NULL。然后，为了获取正确的 next 值⑤，需要获取 head 节点的互斥锁，并且通过设置 head.next 指向这个新节点⑥，这样就把节点插在链表的前面。目前一切良好：只需要锁住一个互斥锁，就能将新的数据项添加到列表，所以不存在死锁的风险。另外，较慢的内存分配操作发生在锁的外面，锁只用来保护需要更新的几个指针，这些操作也不会失败。<br />
</p>

<p>
for_each()⑦这个操作把某种类型的 Function 应用到列表中的每个元素；与大多数标准库算法一样，其会按值传递这个 Function，这样不管是真正的函数或者是重载了调用操作符的函数对象都能正常工作。在这里，函数必须接受类型为 T 的值作为唯一参数。这里有个交叉（hand-over-hand）上锁的过程。起初，需要锁住 head 节点⑧的互斥锁。然后，安全的获取指向下一个节点的指针(使用 get()获取，因为对这个指针没有所有权)。如果那个指针不为 NULL⑨，为了处理数据，就需要上锁那个节点的互斥锁⑩。一旦锁住了那个节点，就可以释放上一个节点的锁⑪，并调用指定的函数⑫。当函数执行完成时，就可以更新 current 指针指向刚处理过的节点，并将所有权从 next_lk 移出到 lk⑬。因为 for_each 直接传递每个数据项到 Function 中，你可以借此更新数据项（如果必要的话）或者把他们拷贝到另外一个容器，或者任何其他处理。如果函数行为良好，这种方式是安全的，因为整个调用期间数据项对应节点的互斥锁已经上锁。<br />
</p>

<p>
find_first_if()⑭和 for_each()类似；关键的区别在于谓词必须在匹配的时候返回 true，不匹配的时候返回 false⑮。一旦匹配，直接返回找到的数据⑯，而非继续查找。可以使用 for_each()来实现 find_first_if，不过它即使找到了一个匹配项，也会不必要地继续处理列表的剩余部分。<br />
</p>

<p>
remove_if()⑰稍有不同，因为这个函数需要更新列表；所以，不能使用 for_each()。如果(18)处谓词返回 true，通过更新 current-&gt;next⑲，将节点从列表移除。做完这些，就可以释放 next 节点对应的互斥锁。当 std::unique_ptr&lt;node&gt;超出作用域⑳时，你移动到这个变量中的节点会被删除。此处，不需要更新 current，因为你紧接着会检查新的 next 节点，从而依次处理每个节点。如果谓词返回 false，需要和之前一样往前迭代㉑。<br />
</p>

<p>
接下来分析列表的多线程安全性。只要提供的谓词和函数行为良好，上面这些函数肯定不会有死锁和 race conditions。迭代通常都是单向的，从 head 节点开始，并且总是在释放当前节点之前，锁住下一个互斥锁，所以不同线程肯定有相同的上锁顺序。唯一可能出现 race conditions 的地方就在 remove_if()⑳中删除已移除节点的时候。因为，操作在解锁互斥锁后进行(销毁已上锁的互斥锁是未定义的行为)。但稍加思索就可以确定这无疑是安全的，因为仍然持有前一个节点(current)的互斥锁，所以不会有新的线程尝试去获取正在删除节点的互斥锁。<br />
</p>

<p>
接下来分析并发性。细粒度上锁的全部意义在于提高在单个互斥锁上并发的可能性，同一时间内，不同线程可以在不同节点上工作，无论是用 for_each()对每一个节点进行处理，还是用 find_first_if()查找，亦或是使用 remove_if()删除一些元素。但是，互斥锁必须依次上锁，所以线程不能超越彼此。如果一个线程花费大量的时间处理一个特殊节点，其他线程到达这个特殊节点的时候就必须等待。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org70f7045" class="outline-3">
<h3 id="org70f7045">07 designing lock-free concurrent data structures</h3>
<div class="outline-text-3" id="text-org70f7045">
<p>
本章主要内容<br />
</p>

<ul class="org-ul">
<li>无锁并发数据结构的实现<br /></li>
<li>无锁数据结构中的内存管理技术<br /></li>
<li>帮助实现无锁数据结构的简单指南<br /></li>
</ul>

<p>
互斥锁是一种强大的机制，可以保证在多线程情况下安全的访问数据结构，而不会有 race conditions ，也不会破坏不变性。使用 mutex 的代码的行为也比较好理解：代码要么在保护数据的互斥锁上持有锁，要么没有。不过，这并非总是一帆风顺；你已经看到第 3 章中由于不正确的使用锁会导致死锁，并且在基于锁的队列和查找表例子中，你也看到了细粒度锁是如何影响真正并发的。如果能写出一个不用锁的并发数据结构，就可能避免这些问题。这样的数据结构称为无锁（lock-free）数据结构。<br />
</p>

<p>
本章我们将讨论第 5 章介绍的原子操作的内存顺序属性是如何用于构建无锁数据结构。掌握第 5 章中所有的内容对理解本章至关重要。设计这样的数据结构时要极其小心，因为这样的数据结构很难正确实现，并且导致其失败的条件很难复现。我们将从无锁数据结构的含义开始；然后介绍使用它们的理由，接着完成一些示例，最后拟定一些通用的指南。<br />
</p>
</div>

<div id="outline-container-org2cbc9d4" class="outline-4">
<h4 id="org2cbc9d4">7.1 Definitions and consequences (229)</h4>
<div class="outline-text-4" id="text-org2cbc9d4">
<p>
使用 mutexes，条件变量以及 futures 来同步数据的算法和数据结构被称为阻塞式数据结构和算法。应用程序调用库函数，库函数会暂停线程的执行，直到另一个线程执行了某个操作。这些库函数的调用被称为阻塞调用，因为线程无法通过阻塞点，直到阻塞被移除。通常 OS 会完全暂停一个阻塞的线程（并将时间片分配给其他线程），直到另外的线程执行适当的操作将该线程的阻塞解除，如解锁 mutex 或者通知条件变量或者使 future 的状态变为 ready。数据结构和算法没有使用阻塞的库函数被称为非阻塞式数据结构和算法。并不是所有的数据结构都可以是无锁的。<br />
</p>
</div>
<div id="outline-container-orgebbc23c" class="outline-5">
<h5 id="orgebbc23c">Types of nonblocking data structures (229)</h5>
<div class="outline-text-5" id="text-orgebbc23c">
<p>
第 5 章中使用 std::atomic_flag 实现了一个自旋锁，其代码如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">spinlock_mutex</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic_flag</span> <span style="color: #7590db;">flag</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">spinlock_mutex</span>(): <span style="color: #bc6ec5; font-weight: bold;">flag</span>(ATOMIC_FLAG_INIT) {}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(flag.test_and_set(<span style="color: #a45bad;">std</span>::memory_order_acquire));
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()
    {
        flag.clear(<span style="color: #a45bad;">std</span>::memory_order_release);
    }
};
</pre>
</div>
<p>
这段代码没有调用任何阻塞函数，lock()不断循环，直到 test_and_set()返回 false。这是它为什么叫自旋锁（spin lock）的原因——代码在循环中“旋转”。因为没有阻塞调用，所以任意使用这个互斥锁来保护共享数据的代码都是非阻塞的。不过，它不是无锁的。它仍然是个互斥锁，并且一次只能被一个线程锁住。因此，只知道“非阻塞的”的概念在大多数情况下是不够的。你需要知道哪个更明确的术语定义应该被应用于这里。更明确定义的术语如下：<br />
</p>
<ul class="org-ul">
<li>Obstruction-Free 无障碍的：如果所有其他线程都暂停了，任何给定的线程都将在有限的步骤内完成其操作。<br /></li>
<li>Lock-Free 无锁的：如果多个线程对一个数据结构进行操作，经过有限的步骤后，其中一个线程将完成它的操作。<br /></li>
<li>Wait-Free 无等待的：即使有其他线程也在对该数据结构进行操作，每个线程都将在有限步骤内完成其操作，而不管其他线程行为如何。。<br /></li>
</ul>

<p>
大多数情况下无障碍算法不是特别有用——很少有其他线程都暂停的情况，因此它更适合于刻画一个失败的无锁实现。让我们进一步了解这些特性包含哪些内容，我们首先从无锁开始，你可以了解到哪些类型的数据结构是 lock-free 的。<br />
</p>
</div>
</div>
<div id="outline-container-orge1c69be" class="outline-5">
<h5 id="orge1c69be">Lock-free data structures (230)</h5>
<div class="outline-text-5" id="text-orge1c69be">
<p>
一个可以称为无锁的数据结构，应该支持多个线程并发的访问数据结构。它们没有必要是相同的操作；一个无锁队列可能允许一个线程推入数据，另一个线程弹出数据，但是，如果有两个线程同时尝试推入元素时就需要打断。不仅如此，当其中一个正在访问数据的线程被调度器中途挂起时，其他线程必须仍能能够继续完成自己的工作，而无需等待挂起的线程。<br />
</p>

<p>
使用“比较/交换”操作的算法，通常都包含一个循环。使用“比较/交换”操作的原因是与此同时另一个线程可能已经修改了数据，这种情况下，在再次尝试“比较/交换”之前，代码需要重做部分操作。如果在其他线程挂起的情况下，“比较/交换”最终会成功，那么这样的代码仍然可以是无锁的。如果不是这样的话，就需要一个自旋锁，而这是“非阻塞的”但不是“无锁的”。<br />
</p>

<p>
带有循环的无锁算法可能导致一个线程处于“饥饿”状态。如果另一个线程在“错误”的时机执行操作，其他线程可能会向前执行，但是第一个线程需要不停的重试自己的操作。规避了这个问题的数据结构是“无等待”同时也是“无锁的”。<br />
</p>
</div>
</div>
<div id="outline-container-orgcb4e336" class="outline-5">
<h5 id="orgcb4e336">Wait-free data structures (231)</h5>
<div class="outline-text-5" id="text-orgcb4e336">
<p>
“无等待”数据结构是无锁数据结构，并且有额外的属性——每个线程都能在有限的步骤内完成操作，而不管其他线程行为如何。由于与其他线程发生冲突而可能陷入无限次重试的算法并不是无等待的。本章的大多数例子都有这个特性——它们有一个在 compare_exchange_weak 或 compare_exchange_strong 操作上的循环，并且循环次数没有上限。操作系统对线程进行调度，可能导致一个给定的线程可能循环非常多次，但其他线程可能循环次数就很少。这些操作不是“无等待”的。<br />
</p>

<p>
正确实现一个“无等待”数据结构极其困难。为了保证每个线程都能在有限的步骤内完成操作，你必须确保每次操作都一趟执行，并且当前线程中的操作不会导致另一个线程失败。这就会让各种操作的整体算法变的相当复杂。<br />
</p>

<p>
考虑到实现无锁或无等待的数据结构非常困难，所以需要充足的理由才值得去实现。由于需要确保收益要大于成本，因此，让我们检查一下影响平衡的那些点。<br />
</p>
</div>
</div>
<div id="outline-container-orga4acc34" class="outline-5">
<h5 id="orga4acc34">The pros and cons of lock-free data structures (231)</h5>
<div class="outline-text-5" id="text-orga4acc34">
<p>
归根结底，使用无锁结构的主要原因是将并发最大化。使用基于锁的容器，一个线程总是必须阻塞并等待另一个线程完成其操作，然后它才能继续；通过互斥防止并发是互斥锁的全部目的。在无锁数据结构中，某些线程每步都能取得进展。在无等待数据结构中，无论其他线程在做什么，每一个线程都可以向前运行，不需要等待。但是这种令人神往的属性难以实现。最后很容易变成本质上是自旋锁的实现。<br />
</p>

<p>
使用无锁数据结构的第二个原因是健壮性。如果一个线程在持有锁时死亡，那么数据结构将会被永久性的破坏。但是，如果一个线程在对无锁数据结构执行操作的中途死亡，那么除了线程的数据之外，没有什么会丢失；其他线程可以正常运行。<br />
</p>

<p>
另一方面，如果不能让线程互斥的访问数据结构，那你必须小心确保不变性被保持或选择其他的可被保持的不变性。同样，你必须关注施加在操作上的顺序约束。为了避免 data race 导致的未定义行为，必须在修改数据时使用原子操作。不过，这还不够；你必须确保修改以正确的顺序对其他线程可见。所有这些意味着为了实现线程安全的数据结构，不用锁的方式要比使用锁难多了。<br />
</p>

<p>
由于没有任何锁，无锁数据结构不可能发生死锁的问题，然而可能存在活锁。活锁（live lock）的产生是当两个线程同时尝试修改数据结构时，对每个线程而言，对方所做的修改都要求操作重新启动，所以两个线程会循环并重试。试想有两个人要通过狭窄的缝隙，如果他们同时出发，就会陷入僵局，因此他们必须出来然后重来，除非有人先到达(不管是商量好了，还是行动更迅速，亦或是走狗屎运)，否则循环将一直重复。在这种简单示例中，活锁的寿命都很短，因为其依赖于线程的精确调度。因此它们只会降低性能，不会引起长期问题，但仍然需要注意这种问题。根据定义，无等待的代码不会受到活锁的影响，因为执行操作的总步骤数是有上限的。<br />
</p>

<p>
另一方面，无等待的算法要比等待算法更复杂，且即使没有其他线程访问数据结构，也可能需要更多步骤来完成相应操作。这给我们带来了“无锁”和“无等待”代码的另一个缺点：虽然提高了操作并发的潜力并且减少了单个线程的等待时间，但是它可能会降低整体的性能。首先，无锁代码的原子操作比非原子操作要慢得多，而且很可能无锁数据结构中原子操作大大多于基于锁的数据结构中互斥锁锁住的代码。不仅如此，访问相同原子变量的硬件必须在线程间同步。第 8 章将看到“乒乓缓存”（cache ping-pong）与多个线程访问相同的原子变量相关，它会导致严重的性能消耗。与所有情况一样，不管怎样，在提交基于锁的数据结构和无锁数据结构之前，检查相关的性能表现(不管是最坏等待时间、平均等待时间、总体执行时间或其他指标)是很重要的。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb8b39c8" class="outline-4">
<h4 id="orgb8b39c8">7.2 Examples of lock-free data structures (232)</h4>
<div class="outline-text-4" id="text-orgb8b39c8">
<p>
为了演示一些在设计无锁数据结构中用到的技术，我们将研究一系列简单数据结构的无锁实现。不仅在每个例子中描述一个有用数据结构的实现，还将重点突出设计无锁数据结构特殊的地方。<br />
</p>

<p>
之前提过，无锁结构依赖原子操作和相关的内存顺序来确保数据以正确的顺序对其他线程可见。起初，我们所有的原子操作将用默认的 memory_order_seq_cst 内存顺序，因为它最好理解（请记住：所有的 memory_order_seq_cst 操作构成一个全序）。但后面的例子中将会减少一些顺序约束到 memory_order_acquire，memory_order_release，甚至 memory_order_relaxed。虽然例子中没有直接使用互斥锁，但值得谨记的是只有 std::atomic_flag 保证是无锁实现的。在一些平台上，C++标准库实现中看起来像无锁的代码可能内部使用了锁(更多细节请查阅第 5 章)。在这些平台上，简单的基于锁的数据结构可能更合适，但不止于此；在选择一种实现前，需要明确需求，并且对满足这些需求的各种选项进行性能分析。<br />
</p>

<p>
因此，让我们从最简单的数据结构开始：栈。<br />
</p>
</div>
<div id="outline-container-orgf134d02" class="outline-5">
<h5 id="orgf134d02">Writing a thread-safe stack without locks (233)</h5>
<div class="outline-text-5" id="text-orgf134d02">
<p>
栈的设定比较简单：获取节点的顺序和添加节点的顺序相反——先进先出(last in first out LIFO).因此一旦一个值入栈后，你要确保它立刻能被另一个线程安全的获得，并且确保只有一个线程能返回给定的值也同样重要。最简单的栈是链表，head 指针指向第一个节点(也就是下一个被获取的节点)，并且每个节点依次指向下一个节点。在这种方案下，添加一个新的节点比较简单：<br />
</p>
<ol class="org-ol">
<li>创建一个新节点。<br /></li>
<li>设置它的 next 指针指向当前的 head 节点。<br /></li>
<li>设置 head 节点指向新节点。<br /></li>
</ol>

<p>
这在单线程的环境中工作的很好，不过其他线程也需要修改栈时，就不行了。当有两个线程同时添加节点的时候，第 2 步和第 3 步之间会产生 race conditions：在你的线程执行第 2 步读取 head 的值和第 3 步更新 head 的值之间，第二个线程可能修改 head 的值。这会导致其他线程的修改被丢弃，或者造成更加严重的后果。在解决这个 race conditions 之前，还要注意：一旦 head 更新并指向了新节点，另一个线程就能读到这个节点。因此，在 head 设置为指向新节点前，新节点完全准备好就至关重要；因为之后就不能修改这个节点。为了避免前面提到的 race conditions，在第 3 步使用 compare/exchange 原子操作来保证自第二步修改后 head 没有被修改。如果 head 已经被修改，你需要循环重试。下面代码就展示了不用锁来实现线程安全的 push()函数。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">data</span>;
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">next</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): <span style="color: #bc6ec5; font-weight: bold;">data</span>(data_) {}
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>*&gt; <span style="color: #7590db;">head</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_node</span>=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(data); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        new_node-&gt;next=head.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node-&gt;next,new_node));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    }
};
</pre>
</div>
<p>
上面代码完美匹配之前所说的三个步骤：创建一个新节点②，设置新节点的 next 指针指向当前 head③，并设置 head 指针指向新节点④。通过 node 的构造函数把数据填充到其自身①，保证了节点在构造完成后随时可以被原子操作使用。之后使用 compare_exchange_weak()来保证 head 指针总是和存储到 new_node-&gt;next 的值一样，如果一样的话就把 new_node 设置给 head。这些代码也用到了“比较/交换”的特色功能：如果返回 false 意味着比较失败(例如，head 被另一个线程修改)，第一个参数(new_node-&gt;next)的值会被 head 中的内容更新。不需要在循环中每次都重新加载 head 指针，因为编译器会帮你做这件事。另外，因为在失败时直接进行循环，所以可以使用 compare_exchange_weak，在某些架构上，它可以产生比 compare_exchange_strong 更优的代码(参见第 5 章)。<br />
</p>

<p>
虽然现在还没有 pop()操作，但可以先快速检查一下 push()的实现是否遵守指南。唯一一个能抛出异常的地方就是在构造新 node 时①，不过它会自行清理，链表也没有被修改，所以非常安全。由于你把数据存储为 node 的一部分，并且使用 compare_exchange_weak()来更新 head 指针，所以这里没有有问题的 race conditions。一旦“比较/交换”成功时，节点就在链表中并且随时可以被取走。因为没有锁，所以不存在死锁，所以你的 push()函数非常棒。<br />
</p>

<p>
现在已经有了往栈中添加数据的方法，你需要一个删除数据的方法。表面看起来也非常简单：<br />
</p>
<ol class="org-ol">
<li>读取 head 的当前值保存到 node。<br /></li>
<li>读取 head-&gt;next。<br /></li>
<li>设置 head 为 head-&gt;next。<br /></li>
<li>返回 node 中的数据。<br /></li>
<li>删除 node 节点。<br /></li>
</ol>

<p>
但在多线程情况下，就没那么简单了。如果有两个线程要从栈中移除数据时，两个线程可能在步骤 1 中读取到相同的 head 值。其中一个线程处理到步骤 5 时，另一个线程还在处理步骤 2，第二个线程将会解引用一个悬垂指针。这是编写无锁代码时遇到的最大的问题之一，所以现在只好跳过步骤 5，让节点泄漏。但还是没有解决所有问题。还有另一个问题：如果两个线程读取到相同的 head 值时，它们将返回同一个节点。这违反了栈数据结构的意图，所以需要避免发生这种情况。可以像在 push()函数中解决 race conditions 那样来解决这个问题：使用比较/交换操作更新 head。当比较/交换操作失败时，不是一个新节点已被推入，就是另一个线程弹出了节点。无论是哪种情况，都得返回步骤 1(但比较/交换操作会为你重新读取 head)。一旦比较/交换成功，就可以确定当前线程是从栈上弹出指定节点的唯一线程，之后就可以放心的执行步骤 4 了。下面是第一次尝试实现 pop()的代码：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">pop</span>(<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">result</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(old_head,old_head-&gt;next));
        result=old_head-&gt;data;
    }
};
</pre>
</div>
<p>
尽管这段代码很简洁，但除了节点泄露之外还有几个问题。首先，这段代码在链表为空时没法工作：当 head 是空指针时，尝试访问 next 指针是未定义的行为。这很容易解决：在 while 循环检查是否为 nullptr，并在空栈上抛出一个异常，或者返回一个 bool 值来表明成功与否。<br />
第二个问题是异常安全。当我们在第 3 章中第一次引入线程安全的栈时，已经见识了按值返回对象会导致异常安全问题：在拷贝返回值时如果抛出异常，这个值会丢失。如果那样的话，传入引用是一种可以接受的解决方案，这样就能保证当有异常抛出时，栈不会发生改变。不幸的是，这对你来说是个奢望；一旦你知道你是唯一返回这个节点的线程时，你只能安全的拷贝数据，这意味着这个节点已经从栈上删除了。因此，通过引用获取返回值的方式不再有优势：你可能还是要按值返回。若想要安全的返回，必须使用第 3 章中的其他选项：返回指向数据值的(智能)指针。<br />
如果返回一个智能指针，你可以返回 nullptr 来表明没有值可返回，但这要求数据在堆上分配内存。如果将内存分配做为 pop()的一部分，问题还是没有改善，因为堆分配内存可能会抛出一个异常。相反，你可以在 push()操作中分配内存——反正要为 node 分配内存，在哪不一样呢？返回一个 std::shared_ptr&lt;&gt;不会抛出异常，所以 pop()是安全的。将这些放在一起，就得到如下的清单。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#25351;&#38024;&#25345;&#26377;&#25968;&#25454;</span>
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">next</span>;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#20026;&#26032;&#20998;&#37197;&#30340;T&#21019;&#24314;std::shared_ptr</span>
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_)) {}
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>*&gt; <span style="color: #7590db;">head</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_node</span>=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(data);
        new_node-&gt;next=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node-&gt;next,new_node));
    }
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head &amp;&amp; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#35299;&#24341;&#29992;&#21069;&#26816;&#26597;old_head&#26159;&#21542;&#20026;&#31354;&#25351;&#38024;</span>
              <span style="color: #a45bad;">!</span>head.compare_exchange_weak(old_head, old_head-&gt;next));
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head ? old_head-&gt;data : <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    }
};
</pre>
</div>
<p>
数据现在由指针持有①，所以 node 的构造函数必须在堆上为数据分配内存②。在 compare_exchage_weak()循环中③，解引用 old_head 之前，你也必须检查指针是否为 nullptr。最后，如果栈中有节点，将会返回节点中的数据；否则返回一个空指针④。注意，尽管结构是无锁的，但并不是无等待的，因为只要 compare_exchange_weak()保持失败，push()和 pop()函数中的 while 循环理论上可以无限循环下去。<br />
</p>

<p>
如果有一个垃圾收集机制帮助你(就像托管语言一样，比如 C#或 Java)，那到这就完事了；老的节点一旦它不再被任何线程访问，将被收集和循环利用。然而，有垃圾收集机制的 C++编译器并不是很多，所以通常需要自己实现一个。<br />
</p>
</div>
</div>
<div id="outline-container-orgaa8eefd" class="outline-5">
<h5 id="orgaa8eefd">Stopping those pesky leaks: managing memory in lock-free data structures (237)</h5>
<div class="outline-text-5" id="text-orgaa8eefd">
<p>
第一次研究 pop()的时候，当有线程删除一个节点的同时，另一个线程还持有指向该节点的指针并且要解引用，为了避免 race condition 选择泄露节点内存。对 C++程序而言，内存泄露是不可接受的，所以必须解决这个问题！<br />
</p>

<p>
基本的问题在于，当要释放一个节点时，需要确认没有其他线程持有这个节点。如果只有一个线程在一个特定的栈实例上调用 pop()，就不会有任何问题了。节点是在 push()中创建，push()并不访问现存节点的内容。能够访问给定节点的线程包括把节点添加到栈中的线程以及调用 pop 的线程。一旦节点入栈后，push()就不会再碰节点，所以只剩下调用 pop()的线程——如果只有一个这样的线程，那么调用 pop()的线程肯定是唯一能访问这个节点的线程，也就可以安全的删除这个节点。<br />
</p>

<p>
另一方面，如果你要处理在同一个栈实例上多线程调用 pop()的情况，你需要一些方法来追踪节点什么时候能被安全的删除。这意味着你需要为节点写一个专用的垃圾收集器。尽管听起来很棘手，但也没那么糟糕：你只需要检查节点，并且只需要检查那些被 pop()访问的节点。不用担心 push()中的节点，因为这些节点直到入栈以后才能被访问到，然而多线程通过 pop()可能访问相同的节点。<br />
</p>

<p>
如果没有线程调用 pop()时，就可以安全删除当前等待删除的节点。因此，如果你从 node 中提取数据后，将节点添加到等待删除的链表中，当没有线程调用 pop()时，就可以安全的删除所有这些节点了。那怎么知道没有线程调用 pop()呢？很简单，使用计数即可。如果你进入时递增计数，退出时递减计数，那么当计数器变为 0 时，从“等待删除”链表中删除节点就是安全的。这个计数器必须是原子的，这样才能安全的被多线程访问。下面的清单展示了修复后的 pop()函数，一些支持函数将在清单 7.5 中给出。<br />
</p>

<p>
清单 7.4 当没有线程执行 pop()时回收节点<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">threads_in_pop</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#21407;&#23376;&#21464;&#37327;</span>
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">try_reclaim</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>);
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        ++threads_in_pop;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#39318;&#20808;&#22686;&#21152;&#35745;&#25968;</span>
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head &amp;&amp; <span style="color: #a45bad;">!</span>head.compare_exchange_weak(old_head,old_head-&gt;next));
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(old_head)
        {
            res.swap(old_head-&gt;data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#20174;&#33410;&#28857;&#20013;&#25552;&#21462;&#25968;&#25454;&#65292;&#32780;&#38750;&#25335;&#36125;&#25351;&#38024;</span>
        }
        try_reclaim(old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 &#21487;&#20197;&#30340;&#35805;&#65292;&#22238;&#25910;&#21024;&#38500;&#30340;&#33410;&#28857;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }
};
</pre>
</div>
<p>
原子变量 threads_in_pop①用来记录有多少个线程试图弹出栈中的项。在 pop()②函数的开头，递增计数；调用 try_reclaim()时，递减计数，这个函数在节点被移除后调用④。由于会延迟删除节点本身，可以通过 swap()函数将数据从节点上移除③，而不是拷贝一份智能指针。这样的话，当不再需要这些数据的时候，这些数据会自动删除，否则数据会持续存在，因为还没删除的（not-yet-deleted）节点还有引用指向这个数据。接下来看一下 try_reclaim()是如何实现的。<br />
</p>

<p>
清单 7.5 采用引用计数的回收机制<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>*&gt; <span style="color: #7590db;">to_be_deleted</span>;
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">delete_nodes</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">nodes</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(nodes)
        {
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">next</span>=nodes-&gt;next;
            <span style="color: #4f97d7; font-weight: bold;">delete</span> nodes;
            nodes=next;
        }
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">try_reclaim</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(threads_in_pop==1)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">exchange &#20889;&#20837;&#26032;&#20540;&#65292;&#24182;&#36820;&#22238;&#21407;&#22987;&#20540;</span>
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">nodes_to_delete</span>=to_be_deleted.exchange(<span style="color: #a45bad;">nullptr</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#32034;&#21462;&#8220;&#24453;&#21024;&#38500;&#8221;&#38142;&#34920;</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>--threads_in_pop)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#24403;&#21069;&#26159;&#21542;&#26159;&#21807;&#19968;&#35843;&#29992;pop()&#30340;&#32447;&#31243;&#65311;</span>
            {
                delete_nodes(nodes_to_delete);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(nodes_to_delete)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            {
                chain_pending_nodes(nodes_to_delete);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">delete</span> old_head;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            chain_pending_node(old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
            --threads_in_pop;
        }
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">chain_pending_nodes</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">nodes</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">last</span>=nodes;
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">next</span>=last-&gt;next)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9 &#36319;&#30528;next&#25351;&#38024;&#36941;&#21382;&#21040;&#38142;&#34920;&#26411;&#23614;</span>
        {
            last=next;
        }
        chain_pending_nodes(nodes,last);
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">chain_pending_nodes</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">last</span>)
    {
        last-&gt;next=to_be_deleted;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>to_be_deleted.compare_exchange_weak(  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11 &#29992;&#24490;&#29615;&#26469;&#20445;&#35777;last-&gt;next&#30340;&#27491;&#30830;&#24615;</span>
                  last-&gt;next,first));
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">chain_pending_node</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">n</span>)
    {
        chain_pending_nodes(n,n);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
    }
};
</pre>
</div>
<p>
当你尝试回收节点时①，若 threads_in_pop 的值是 1，那你就是当前唯一在 pop()中的线程，这时在(7)处就可以安全的删除被移除的节点了，删除未决（pending）节点可能也是安全的。当数值不是 1 时，删除任何节点都不安全，所以需要把节点添加到未决链表⑧。<br />
</p>

<p>
假设某一时刻，threads_in_pop 的值为 1。就需要尝试回收未决节点，如果不回收的话，节点会保持未决状态直到整个栈被销毁。为了回收，首先要通过原子 exchange 操作索取②链表，并递减 threads_in_pop 的计数③。如果之后计数的值变为 0，就可以确定没有其他线程访问未决节点链表。虽然可能会有新的未决节点出现，不过现在你不需要为此烦恼，只要安全回收你的链表就好了，而后，可以调用 delete_nodes 对链表进行迭代，并将其删除④。<br />
</p>

<p>
如果计数在递减后不为 0，回收节点就不安全；因此如果存在未决节点⑤，就需要将其挂在未决删除链表之后⑥，这种情况会发生在多个线程并发访问数据结构的时候。其他线程在第一次测试 threads_in_pop①和获取 to_be_deleted 链表②之间调用 pop()，可能会添加一个新节点到未决链表，而这个节点仍被一个或多个线程访问。图 7.1 中，线程 C 添加节点 Y 到 to_be_deleted 链表，然而，线程 B 仍通过 old_head 引用它，并且尝试读它的 next 指针。因此线程 A 不能删除节点，只有这样才不至于导致线程 B 发生未定义的行为。<br />
</p>


<div id="org260d22b" class="figure">
<p><img src="./AsynchronousProgramming/07_02_02_lockfree_stack01.jpg" alt="07_02_02_lockfree_stack01.jpg" /><br />
</p>
</div>

<p>
为了把未决删除节点添加到未决链表，需要重用节点的 next 指针将它们链接在一起。当需要将现有链重新链接回链表时，需要遍历链找到尾部⑨，将最后一个节点的 next 指针替换为当前 to_be_deleted 指针⑩，并将链中第一个节点存储为新的 to_be_deleted 指针⑪。你必须在循环中使用 compare_exchange_weak 来保证其他线程添加进来的节点不会泄露。这样做有个好处——如果 to_be_deleted 发生改变，可以从链的尾部更新 next 指针。添加单个节点是种特殊情况，因为它既是第一个节点，也是最后一个节点⑫。<br />
</p>

<p>
在低负载的情况下，这种方式工作的相当好，因为总有合适的静止点没有线程运行 pop()。但这些点稍纵即逝，这也是在回收前，需要测试 threads_in_pop 计数为 0③的原因，也是这个测试发生在删除移除节点⑦之前的原因。删除节点是个耗时的操作，你肯定希望其他线程修改链表的时间窗口越小越好。从第一次发现 threads_in_pop 是 1 到尝试删除节点耗费的时间越长，就越有可能有另一个线程会调用 pop()，因而导致 threads_in_pop 不再等于 1，这样会阻止节点被删除。<br />
</p>

<p>
在高负载的情况下，可能永远也没有这种静止状态，因为起初在 pop()里面的线程全部离开之前，其他线程已经进入到 pop()，这种情况下 to_be_deleted 链表将会无限增长，这会再次泄漏内存。如果不存在任何静态的时间片，就需要一种替代机制来回收节点。关键是确定什么时候没有更多的线程访问特定节点，这样节点就能被回收。到目前为止，最好理解的机制是使用风险指针(hazard pointer)。<br />
</p>
</div>
</div>

<div id="outline-container-org86f8062" class="outline-5">
<h5 id="org86f8062">Detecting nodes that can’t be reclaimed using hazard pointers (241)</h5>
<div class="outline-text-5" id="text-org86f8062">
<p>
hazard pointers 这个术语引自 Maged Michael 发现的一项技术（发表于 Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes 论文）。之所以这样叫是因为删除一个可能仍被其他线程引用的节点是危险的。如果其他线程确实持有节点的引用，并继续通过该引用访问节点，就会出现未定义的行为。其基本思想是，如果一个线程准备访问另一个线程想要删除的对象，它首先会设置风险指针来引用这个对象，然后通知其他线程使用这个指针是危险的。一旦不再需要这个对象，就可以清除风险指针。如果你看过牛津/剑桥的划船比赛，那你肯定见过类似机制：每个船上的舵手可以举手示意他们还没有准备好。只要有舵手举手，裁判就不能开始比赛。当所有舵手把手放下后，比赛才能开始；不过舵手可以再次举手，只要比赛还未开始并且他们感觉情况有变。<br />
</p>

<p>
当线程想要删除一个对象时，就必须检查系统中属于其他线程的风险指针。如果没有风险指针引用这个对象，就可以安全的删除对象。否则只能稍后处理。然后周期性的检查留待稍后处理的对象链表以确定他们中是否有现在可以安全删除的对象。<br />
</p>

<p>
经过一番高层次的描述以后，听起来比较简单，那么在 C++中应该怎么做呢？<br />
</p>

<p>
首先，你需要用来存储指向访问对象的指针的空间，也就是风险指针本身。这个空间必须对所有线程可见，并且可能访问该数据结构的每个线程都需要一个这样的空间。正确并且高效的分配这个数据结构的确是一个挑战，所以稍后讨论，假设有一个 get_hazard_pointer_for_current_thread()函数，它返回风险指针的引用。然后，当你读取一个想解引用的指针时，你需要设置它——在这个例子中是链表中的 head 值：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;T&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>*&gt;&amp; <span style="color: #7590db;">hp</span>=get_hazard_pointer_for_current_thread();
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=head.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">temp</span>;
    <span style="color: #4f97d7; font-weight: bold;">do</span>
    {
        temp=old_head;
        hp.store(old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        old_head=head.load();
    } <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head!=temp); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>

<p>
必须使用 while 循环来确保 node 不会在读取老的 head 指针①和设置风险指针②之间被删除。在这个时间窗口，没有线程知道你正在访问这个特定的节点。幸运的是，老的 head 节点将要删除时，head 本身肯定改变了，所以需要对 head 进行检查并持续循环，直到 head 指针中的值与风险指针中的值相同③。像这样使用风险指针依赖于一个事实：当对象被删除后，使用指向该对象的指针的值是安全的。如果使用 new 和 delete 的默认实现，这在技术上是未定义的行为，因此需要确保你的实现支持这种用法，或者使用允许这种用法的自定义分配器。<br />
</p>

<p>
你已经设置了风险指针，从而确保其他线程不会在你的监视下删除你操作的节点（如果其他线程删除了节点，head 会被更新，循环中会将当前线程操作的节点设置为新的 head 节点），这样你就可以继续处理 pop()的其余部分。几乎每一次重新读取 old_head 后，在解引用最新读取到的指针值前，都需要更新对应的风险指针。一旦从链表中取出了一个节点，就可以清除风险指针。如果没有其他风险指针引用节点，就可以安全的删除节点；否则，必须将该节点添加到链表中，之后再进行删除。下面的代码展示了使用这种方案的完整 pop()实现。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;T&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>*&gt;&amp; <span style="color: #7590db;">hp</span>=get_hazard_pointer_for_current_thread();
    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=head.load();
    <span style="color: #4f97d7; font-weight: bold;">do</span>
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">temp</span>;
        <span style="color: #4f97d7; font-weight: bold;">do</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#19968;&#30452;&#24490;&#29615;&#65292;&#30452;&#21040;&#23558;&#39118;&#38505;&#25351;&#38024;&#35774;&#20026;head</span>
        {
            temp=old_head;
            hp.store(old_head);
            old_head=head.load();
        } <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head!=temp); 
    }
    <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head &amp;&amp; <span style="color: #a45bad;">!</span>head.compare_exchange_strong(old_head,old_head-&gt;next));
    hp.store(<span style="color: #a45bad;">nullptr</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#24403;&#21462;&#20986;&#22836;&#32467;&#28857;&#21518;&#65292;&#28165;&#38500;&#39118;&#38505;&#25351;&#38024;</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;T&gt; <span style="color: #7590db;">res</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span>(old_head)
    {
        res.swap(old_head-&gt;data);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#22312;&#21024;&#38500;&#20043;&#21069;&#26816;&#26597;&#26159;&#21542;&#26377;&#39118;&#38505;&#25351;&#38024;&#24341;&#29992;&#35813;&#33410;&#28857;&#65288;&#22240;&#20026;&#22312;&#19978;&#38754;&#37027;&#20010;&#20869;&#37096;&#24490;&#29615;&#20013;&#21487;&#33021;&#22810;&#20010;&#32447;&#31243;&#37117;&#25226;&#26576;&#20010;head&#35774;&#32622;&#20026;&#33258;&#24049;&#32447;&#31243;&#30340;&#39118;&#38505;&#25351;&#38024;&#65289;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(outstanding_hazard_pointers_for(old_head))
        {
            reclaim_later(old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">delete</span> old_head;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        }
        delete_nodes_with_no_hazards();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>

<p>
首先，设置风险指针的循环移到了外部循环里面，这个外部循环会在“比较/交换”操作失败的时候重新加载 old_head①。这里使用了 compare_exchange_strong()，因为在 while 循环内部有工作可做：当 compare_exchange_weak()伪失败后，会导致不必要的重新设置风险指针。这确保了风险指针在解引用 old_head 之前被正确的设置。一旦将一个节点声明为你的，就可以清除风险指针②。如果确实拿到一个节点，就需要检查其他线程上的风险指针，看它们是否引用了该节点③。如果引用了，现在还不能删除它，只能将它放到回收链表中，之后再进行回收④；否则，可以立刻删除节点⑤。最后你调用了一个函数来检查这些由 reclaim_later()收集的节点。如果没有任何风险指针引用这些节点，就可以安全的删除这些节点⑥。如果还有风险指针引用的话，这样的节点就会留给下一个调用 pop()的线程。<br />
</p>

<p>
还有很多细节隐藏在这些新函数中——get_hazard_pointer_for_current_thread(), reclaim_later(), outstanding_hazard_pointers_for(), 和 delete_nodes_with_no_hazards()——因此让我们揭开神秘的面纱，看看它们是如何工作的。<br />
</p>

<p>
get_hazard_pointer_for_current_thread()使用的分配风险指针实例的确切方案对程序逻辑（尽管会影响效率，你很快就会看到）并不重要。就现在而言，可以使用一个简单的结构：一个固定长度的数组，数组元素为线程 ID 和指针对。get_hazard_pointer_for_curent_thread()可以通过搜索这个数组来找到第一个空闲槽位，并将当前线程的 ID 设置为这个槽的 ID 部分的值。线程退出时，槽通过设置 ID 部分的值为默认构造的 std::thread::id()来释放槽位。如下面清单所示：<br />
</p>

<p>
清单 7.7 get_hazard_pointer_for_current_thread()的简单实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_hazard_pointers</span>=100;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">hazard_pointer</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::id&gt; <span style="color: #7590db;">id</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>*&gt; <span style="color: #7590db;">pointer</span>;
};
<span style="color: #ce537a; font-weight: bold;">hazard_pointer</span> <span style="color: #7590db;">hazard_pointers</span>[max_hazard_pointers];

<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">hp_owner</span>
{
    <span style="color: #ce537a; font-weight: bold;">hazard_pointer</span>* <span style="color: #7590db;">hp</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">hp_owner</span>(<span style="color: #ce537a; font-weight: bold;">hp_owner</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">hp_owner</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">hp_owner</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #bc6ec5; font-weight: bold;">hp_owner</span>(): hp(<span style="color: #a45bad;">nullptr</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;max_hazard_pointers;++i)
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::<span style="color: #ce537a; font-weight: bold;">id</span> <span style="color: #7590db;">old_id</span>;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(hazard_pointers[i].id.compare_exchange_strong(  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#23581;&#35797;&#32034;&#21462;&#39118;&#38505;&#25351;&#38024;&#30340;&#25152;&#26377;&#26435;</span>
                   old_id,<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::<span style="color: #ce537a; font-weight: bold;">get_id</span>()))
            {
                hp=&amp;hazard_pointers[i]; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                <span style="color: #4f97d7; font-weight: bold;">break</span>;
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>hp)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #a45bad;">std</span>::runtime_error(<span style="color: #2d9574;">"No hazard pointers available"</span>);
        }
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>*&gt;&amp; <span style="color: #bc6ec5; font-weight: bold;">get_pointer</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> hp-&gt;pointer;
    }

    ~<span style="color: #bc6ec5; font-weight: bold;">hp_owner</span>()
    {
        hp-&gt;pointer.store(<span style="color: #a45bad;">nullptr</span>);
        hp-&gt;id.store(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::<span style="color: #ce537a; font-weight: bold;">id</span>());
    }
};

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>*&gt;&amp; <span style="color: #bc6ec5; font-weight: bold;">get_hazard_pointer_for_current_thread</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
{
    <span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">hp_owner</span> <span style="color: #7590db;">hazard</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 &#27599;&#20010;&#32447;&#31243;&#37117;&#26377;&#33258;&#24049;&#30340;&#39118;&#38505;&#25351;&#38024;</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> hazard.get_pointer();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
}
</pre>
</div>

<p>
get_hazard_pointer_for_current_thread()的实现看起来很简单③：它有一个 hp_owner 类型的 thread_local 变量④，用来存储当前线程的风险指针。然后从这个对象返回风险指针⑤。它的工作原理如下：每个线程第一次调用这个函数时，一个新的 hp_owner 实例被创建。这个实例的构造函数①会通过查询“所有者线程 ID/指针”对的表来寻找一个没有被占用的条目。它使用 compare_exchange_strong()来检查某个条目没有所有者并索取这个条目②。如果 compare_exchange_strong()失败，说明另一个线程拥有这个条目，因此继续考察下一个。当交换成功，当前线程就拥有了这个条目，然后存储这个条目并停止搜索⑥。如果遍历完链表也没有找到空闲条目时⑦，说明有太多线程在使用风险指针，因此抛出一个异常。<br />
</p>

<p>
对一个给定的线程，一旦创建了 hp_owner 实例，后续访问会很快，因为指针已经缓存起来了，所以不必扫描表。<br />
</p>

<p>
当每个线程退出时，如果这个线程的 hp_owner 实例被创建的话，将会被销毁。析构函数会在设置拥有者线程 ID 为 std::thread::id()前，将指针重置为 nullptr，这样就允许另一个线程对这个条目进行复用。<br />
</p>

<p>
有了 get_hazard_pointer_for_current_thread()的实现后，outstanding_hazard_pointer_for()实现就简单了：扫描风险指针表查找对应条目。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">outstanding_hazard_pointers_for</span>(<span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">p</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;max_hazard_pointers;++i)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(hazard_pointers[i].pointer.load()==p)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
}
</pre>
</div>
<p>
甚至都不需要验证每个记录是否有一个所有者：没有所有者的条目会是一个空指针，所以比较会返回 false，这样简化了代码。<br />
</p>

<p>
reclaim_later()和 delete_nodes_with_no_hazards()在一个简单的链表上工作；reclaim_later()只是将节点添加到链表中，delete_nodes_with_no_hazards()扫描整个链表，并删除无风险指针的条目。下面的清单展示了相关实现。<br />
</p>

<p>
清单 7.8 回收函数的简单实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">do_delete</span>(<span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">p</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">delete</span> <span style="color: #4f97d7; font-weight: bold;">static_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>*&gt;(p);
}

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span>* <span style="color: #7590db;">data</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">function</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>(<span style="color: #ce537a; font-weight: bold;">void</span>*)&gt; <span style="color: #7590db;">deleter</span>;
    <span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>* <span style="color: #7590db;">next</span>;

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
    <span style="color: #bc6ec5; font-weight: bold;">data_to_reclaim</span>(<span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #7590db;">p</span>):  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        data(p), deleter(&amp;<span style="color: #ce537a; font-weight: bold;">do_delete</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;), next(0) {}

    ~<span style="color: #bc6ec5; font-weight: bold;">data_to_reclaim</span>()
    {
        deleter(data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    }
};

<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>*&gt; <span style="color: #7590db;">nodes_to_reclaim</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">add_to_reclaim_list</span>(<span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>* <span style="color: #7590db;">node</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
{
    node-&gt;next=nodes_to_reclaim.load();
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>nodes_to_reclaim.compare_exchange_weak(node-&gt;next,node));
}

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">reclaim_later</span>(<span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #7590db;">data</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
{
    add_to_reclaim_list(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>(data));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">delete_nodes_with_no_hazards</span>()
{
    <span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>* <span style="color: #7590db;">current</span>=nodes_to_reclaim.exchange(<span style="color: #a45bad;">nullptr</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    <span style="color: #4f97d7; font-weight: bold;">while</span>(current)
    {
        <span style="color: #ce537a; font-weight: bold;">data_to_reclaim</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">next</span>=current-&gt;next;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>outstanding_hazard_pointers_for(current-&gt;data))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">delete</span> current;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            add_to_reclaim_list(current);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
        }
        current=next;
    }
}
</pre>
</div>
<p>
首先，reclaim_later()是一个函数模板而不是个普通函数④。因为风险指针是一个通用方案，你肯定不想绑死在栈节点上。你已经使用 std::atomic&lt;void*&gt;对指针进行存储，因此需要处理任意指针类型。不过不能使用 void*形式，因为当要删除数据项时，delete 需要指针的具体类型。data_to_reclaim 的构造函数很好的处理了这个问题，你马上就能看到；reclaim_later()为你的指针创建了一个新的 data_to_reclaim 实例，并且将实例添加到回收链表中⑤。add_to_reclaim_list()③本身只是一个简单循环，其使用 compare_exchange_weak()将节点加到列表头上，这跟你以前看到的一样。<br />
</p>

<ul class="org-ul">
<li>关于 delete void* 为什么不可行 <a href="https://www.cnblogs.com/imjustice/p/how_shared_ptr_void_works.html">https://www.cnblogs.com/imjustice/p/how_shared_ptr_void_works.html</a><br /></li>
</ul>

<p>
回到 data_to_reclaim 的构造函数①：构造函数也是个模板。它把要删除的数据存储为 void*的数据成员，然后存储了一个指针，这个指针指向一个适当的实例化的 do_deltete()函数（do_deltete()函数为一个简单的模板函数，将 void*转换为选定的指针类型，然后删除指向的对象）。std::function&lt;&gt;安全的包装了这个函数指针，所以 data_to_reclaim 的析构函数可以通过调用存储的函数对数据进行删除②。<br />
</p>

<p>
当添加节点到链表时，data_to_reclaim 的析构函数不会被调用；当没有风险指针指向那个节点的时候才会调用析构函数，这是 delete_nodes_with_no_hazards()的责任。<br />
</p>

<p>
delete_nodes_with_no_hazards()使用 exchange()函数获取需要回收的整个链表⑥。这个简单但很关键的步骤确保了只有一个线程回收这个特定集合的节点。其他线程现在就能随意将更多节点添加到回收链表中，甚至尝试对节点进行回收，而不影响那个回收线程。<br />
</p>

<p>
然后，只要有节点存在于链表中，就需要依次检查每个节点，查看节点是否有未决的风险指针⑦。如果没有的话，就可以安全的将条目删除(并且清除存储的数据)⑧。否则，就只能将这个节点放回链表，后面再回收⑨。<br />
</p>

<p>
虽然这个简单的实现确实安全的回收了被删除的节点，不过开销增加了很多。扫描风险指针数组需要检查 max_hazard_pointers 个原子变量，并且每次 pop()调用都要做一次。原子操作本来就慢——在台式 CPU 上，原子操作比非原子操作慢 100 倍——这使得 pop()变成昂贵的操作。不仅删除节点时需要扫描风险指针链表，而且删除等待删除链表(nodes_to_reclaim)上的每个元素也要扫描风险指针链表。显然，这是个糟糕的主意。nodes_to_reclaim 中可能会有 max_hazard_pointers 个节点，然后你需要将每个节点和 hazard_pointers 数组中的 max_hazard_pointers 个风险指针做比较。天啊，这必须要有更好的办法才行。<br />
</p>
</div>
<div id="outline-container-org8d86e5a" class="outline-6">
<h6 id="org8d86e5a">BETTER RECLAMATION STRATEGIES USING HAZARD POINTERS</h6>
<div class="outline-text-6" id="text-org8d86e5a">
<p>
确实有更好的办法。这里只展示一个简单初级的风险指针实现，来帮助解释这个技术。首先可以用内存换性能。不同于每次调用 pop()都检查回收链表上的每个节点，除非有超过 max_hazard_pointer 数量的节点存在于链表上，否则不会尝试回收任何节点。这样的话可以保证你至少能回收一个节点。如果一直等到链表中的节点数量达到 max_hazard_pointers+1，其实也没好到哪去。一旦有 max_hazard_pointers 个节点，将为大多数 pop()调用尝试回收节点，所以这样也不是很好。不过，如果一直等到 2*max_hazard_pointers 个节点在链表中时，由于最多有 max_hazard_pointers 个节点是活跃的，这样就能保证至少有 max_hazard_pointers 个节点可以被回收，并且再次尝试回收任意节点前，至少会对 pop()有 max_hazard_pointers 次调用。这就好很多。比起每次 pop()调用检查大约 max_hazard_pointers 个节点(不一定能回收到节点)，每 max_hazard_pointers 次 pop()调用，检查 2*max_hazard_pointers 个节点，就会有 max_hazard_pointers 个节点可回收。这实际上就是每次 pop()调用检查两个节点，其中就有一个被回收。<br />
</p>

<p>
哪怕这个方法有个缺点(更大的回收链表不仅增加了内存占用，并且增大了潜在的可回收节点数量)：现在需要对回收链表上的节点进行计数，这意味着需要使用原子计数器，并且有多线程争竞争访问回收链表本身。如果内存充裕，可以使用更多内存的来实现更好的回收方案：每个线程通过线程局部变量，持有它自己的回收链表，这样就不需要原子计数和访问共享回收链表了。此时，需要分配 max_hazard_pointers*max_hazard_pointers 个节点。如果一个线程在它的所有节点被回收前退出，它的本地链表可以像之前一样存储到全局链表中，然后添加到下一个线程的回收链表中，让这个线程执行回收操作。<br />
</p>

<p>
风险指针的另一个缺点是受到 IBM 申请的专利所保护[2]。尽管我相信这个专利已经过期，但如果你在一个专利还在有效期的国家编写软件，你最好咨询专利律师或者确认已获得适当的许可。这在很多无锁内存回收技术中很常见；这是一个活跃的研究领域，所以很多大公司都尽可能申请专利。你可能会问，“为什么花这么大的篇幅来介绍一个大多数人可能都没办法使用的技术呢？”，这是个很好的问题。首先，使用这种技术可能不需要购买一个许可。比如，如果使用 GPL 下的免费软件许可来进行软件开发[3]，你的软件可能被 IBM 的不主张声明（statement of non-assertion）覆盖[4]。其次，最重要的是解释这个技术能够展示在编写无锁代码时很多需要重点考虑的东西，比如：原子操作的成本。最后，有一个提议将风险指针纳入到 C++标准的未来修订版中，因此，知道它们怎么工作也是有益处的，也许你希望将来能够使用你的编译器供应商的实现。<br />
</p>

<p>
那么，是否有非专利的内存回收技术可以用于无锁代码？幸好，的确有。引用计数就是这样一种机制。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org97337cb" class="outline-5">
<h5 id="org97337cb">Detecting nodes in use with reference counting (249)</h5>
<div class="outline-text-5" id="text-org97337cb">
<p>
回到 7.2.2 节，已经看到删除节点的问题是需要检测哪个节点还在被读线程访问。如果能安全并精确的识别节点是否还在被引用，以及什么时候没有线程访问这些节点，你就能删除它们。风险指针通过把使用中的节点存储到链表中来处理这个问题。而引用计数是通过统计每个节点上访问的线程数量来处理这个问题。<br />
</p>

<p>
这看起来很好很简单，但实际上很难管理：首先，你可能认为 std::shared_ptr&lt;&gt;可以胜任这个任务，毕竟它是有引用计数的指针。不幸的是，虽然 std::shared_ptr&lt;&gt;上有些操作是原子的，但不能保证是无锁的。尽管就其本身而言，std::shared_ptr&lt;&gt;对应的原子操作跟原子类型上的操作没有什么不同，但是 std::shared_ptr&lt;&gt;旨在用于多种上下文，使其对应的原子操作无锁可能会给所有 std::shared_ptr&lt;&gt;类的使用带来额外开销。如果平台提供的实现中，std::atomic_is_lock_free(&amp;some_shared_ ptr)返回 true，那么整个内存回收问题就消失了。如下面清单 7.9 所示，使用 std::shared_ptr&lt;node&gt; 来实现链表。注意，需要对弹出节点的 next 进行清除，以避免当引用该节点的最后一个 std::shared_ptr 被销毁时潜在的深度嵌套的节点销毁。<br />
</p>

<p>
清单 7.9 使用无锁 std::shared_ptr&lt;&gt;实现的无锁栈<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_)) {}
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_node</span>=<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;(data);
        new_node-&gt;next=<span style="color: #a45bad;">std</span>::atomic_load(&amp;head);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span><span style="color: #a45bad;">std</span>::atomic_compare_exchange_weak(&amp;head, &amp;new_node-&gt;next,new_node));
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=<span style="color: #a45bad;">std</span>::atomic_load(&amp;head);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head &amp;&amp; <span style="color: #a45bad;">!</span><span style="color: #a45bad;">std</span>::atomic_compare_exchange_weak(&amp;head, &amp;old_head,old_head-&gt;next));
        <span style="color: #4f97d7; font-weight: bold;">if</span> (old_head)
        {
            <span style="color: #a45bad;">std</span>::atomic_store(&amp;old_head-&gt;next, <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;());
            <span style="color: #4f97d7; font-weight: bold;">return</span> old_head-&gt;data;
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
    }

    ~<span style="color: #bc6ec5; font-weight: bold;">lock_free_stack</span>(){
        <span style="color: #4f97d7; font-weight: bold;">while</span>(pop());
    }
};
</pre>
</div>
<p>
不仅对 std::shared_ptr&lt;&gt;使用无锁原子操作的实现很少见，而且保证所有地方都使用原子操作也很难（很容易就忘记使用原子操作了）。Concurrency TS 可以提供帮助，它在头文件&lt;experimental/atomic&gt;中提供了 std::experimental::atomic_shared_ptr&lt;T&gt;。多数情况下这与 std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;等价，除非 std::shared_ptr&lt;T&gt; 不具有 nontrivial copy 语义，此时无法保证引用计数被正确处理，std::shared_ptr&lt;T&gt;也就不能用于 std::atomic&lt;&gt;。但是，std::experimental::atomic_shared_ptr&lt;T&gt;能正确的处理引用计数，同时仍然能保证操作是原子的。与第 5 章中的其他原子类型一样，在任何给定的实现上它可能是无锁的也可能不是。清单 7.10 是对清单 7.9 的重写。可以看出下面代码不需要刻意牢记使用 atomic_load 和 atomic_store 调用，这使得编码变得更简单了。<br />
</p>

<p>
清单 7.10 使用 std::experimental::atomic_shared_ptr&lt;&gt;实现的栈<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">atomic_shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">next</span>;
        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_)) {}
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">experimental</span>::<span style="color: #ce537a; font-weight: bold;">atomic_shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">head</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">new_node</span>=<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;(data);
        new_node-&gt;next=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node-&gt;next,new_node));
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt; <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(old_head &amp;&amp; <span style="color: #a45bad;">!</span>head.compare_exchange_weak(old_head,old_head-&gt;next.load()));
        <span style="color: #4f97d7; font-weight: bold;">if</span>(old_head)
        {
            old_head-&gt;next=<span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">node</span>&gt;();
            <span style="color: #4f97d7; font-weight: bold;">return</span> old_head-&gt;data;
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
    }

    ~<span style="color: #bc6ec5; font-weight: bold;">lock_free_stack</span>(){
        <span style="color: #4f97d7; font-weight: bold;">while</span>(pop());
    }
};
</pre>
</div>
<p>
很可能你的 std::shared_ptr&lt;&gt;实现不是无锁的，并且你的实现也没有提供一份无锁的 std::experimental::atomic_shared_ptr&lt;T&gt;，这样的话就需要手动管理引用计数。<br />
</p>

<p>
一种可能的技术是对每个节点使用两个而不是一个引用计数：一个内部计数和一个外部计数。两个值的和就是对这个节点的引用总数。外部计数与指向节点的指针组成一对一起保存，并且每次读取指针的时候外部计数增加。当读线程使用完节点后，递减内部计数。一个简单的读指针操作完成后，外部计数将加 1，内部计数会减 1<br />
</p>

<p>
当不再需要外部计数/指针对时(从多个线程可访问的位置，不可再访问该节点)，内部计数会被加上外部计数减一的值，并且外部计数会被丢弃。一旦内部计数等于 0，就没有对该节点未完成的引用了，就可以将该节点安全删除。使用原子操作来更新共享数据仍然很重要。现在让我们来看一下使用这种技术实现的无锁栈，它确保节点只在安全的情况下才会被回收。<br />
</p>

<p>
下面的清单展示了内部数据结构，以及 push()的实现，非常简单明了。<br />
</p>

<p>
清单 7.11 使用分离的引用计数把一个节点推入到无锁栈<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>;

    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">external_count</span>;
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">ptr</span>;
    };

    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">internal_count</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">next</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>

        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_)), internal_count(0)
        {}
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&gt; <span style="color: #7590db;">head</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    ~<span style="color: #bc6ec5; font-weight: bold;">lock_free_stack</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(pop());
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_node</span>;
        new_node.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(data);
        new_node.external_count=1;
        new_node.ptr-&gt;next=head.load();
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node.ptr-&gt;next,new_node));
    }
};
</pre>
</div>
<p>
首先，外部计数和节点指针一起包装在 counted_node_ptr 结构中①，然后可以将其用于 node 结构体的 next 指针③，以此同时还有内部计数②。因为 counted_node_ptr 是一个简单的结构体，因此可以和 std::atomic&lt;&gt;模板一起用作链表的 head④。<br />
</p>

<p>
在支持“双字比较和交换”操作的平台上，由于这个结构体足够小，所以 std::atomic&lt;counted_node_ptr&gt;由于足够小而可以是无锁的。如果平台不支持的话，最好使用清单 7.9 中的 std::shared_ptr&lt;&gt;版本；因为当类型的体积对平台的原子指令来讲太大的话，std::atomic&lt;&gt;将使用互斥锁来保证其操作的原子性(致使你的“无锁”算法变成“基于锁”的算法)。或者，如果你愿意限制计数器的大小，并且你知道你的平台在指针上有空闲的 bit 位(比如，地址空间只有 48 位，而一个指针占 64 位。译注：intel 平台就是这个情况)，可以将计数存在一个指针的空闲位中，这样就可以塞进一个机器字当中。这样的技巧需要平台特定的知识，因而超出本书讨论的范围。<br />
</p>

<p>
push()相对简单⑤，你构造了一个 counted_node_ptr 实例，其引用新分配出来带有相关数据的 node，并将 node 的 next 指针设置为当前 head。之后你就可以使用 compare_exchange_weak()对 head 的值进行设置，跟之前清单一样。计数就建立起来了，这时 internal_count 为 0，并且 external_count 是 1。因为这是一个新节点所以当前只有一个外部引用指向它(也就是 head 指针本身)。<br />
</p>

<p>
和往常一样，复杂性来自于 pop()的实现，展示如下。<br />
</p>

<p>
<a id="orgfb7dfa5"></a> 使用分离的引用计数从无锁栈中弹出一个节点<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increase_head_count</span>(<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&amp; <span style="color: #7590db;">old_counter</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_counter</span>;
        <span style="color: #4f97d7; font-weight: bold;">do</span>
        {
            new_counter=old_counter;
            ++new_counter.external_count;
        }
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_strong(old_counter,new_counter));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

        old_counter.external_count=new_counter.external_count;
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_head_count(old_head);
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ptr</span>=old_head.ptr;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#20010;&#20998;&#25903;&#27809;&#26377;&#31649;&#21069;&#38754;&#22686;&#21152;&#20102;&#22806;&#37096;&#35745;&#25968;&#65292;&#23545;&#31354;&#38142;&#34920;&#20498;&#26080;&#25152;&#35859;&#65292;&#22240;&#20026;&#35745;&#25968;&#26159;&#38024;&#23545;&#25968;&#25454;&#30340;&#65292;&#27809;&#26377;&#30495;&#27491;&#25351;&#21521;&#25968;&#25454;&#65292;&#35745;&#25968;&#26159;&#22810;&#23569;&#37117;&#26080;&#25152;&#35859;&#65292;&#20005;&#35880;&#28857;&#24212;&#35813;&#20943;&#23569;&#35745;&#25968;</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>ptr)
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
            }

            <span style="color: #4f97d7; font-weight: bold;">if</span>(head.compare_exchange_strong(old_head,ptr-&gt;next))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>;
                res.swap(ptr-&gt;data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#33410;&#28857;&#24050;&#32463;&#20174;&#21015;&#34920;&#20013;&#21024;&#38500;&#65292;&#22806;&#37096;&#24341;&#29992;&#38656;&#35201;&#20943;1&#65288;&#35813;&#33410;&#28857;&#19968;&#24320;&#22987;&#34987;&#21152;&#20837;&#21015;&#34920;&#26102;&#65292;&#22806;&#37096;&#24341;&#29992;&#20026;1&#65289;</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#21069;&#32447;&#31243;&#19981;&#20877;&#35775;&#38382;&#35813;&#33410;&#28857;&#65292;&#22806;&#37096;&#24341;&#29992;&#38656;&#35201;&#20943;1&#65288;&#19978;&#38754;increase_head_count&#23558;&#22806;&#37096;&#24341;&#29992;&#22686;&#21152;&#20102;1&#65289;</span>
                <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">count_increase</span>=old_head.external_count-2;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr-&gt;internal_count.fetch_add(count_increase)==  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                   -count_increase)
                {
                    <span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;
                }
                <span style="color: #4f97d7; font-weight: bold;">return</span> res;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
            }
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#21069;&#32447;&#31243;&#19981;&#20877;&#35775;&#38382;&#35813;&#33410;&#28857;&#65292;&#20869;&#37096;&#24341;&#29992;&#20943;1&#65288;&#19978;&#38754;increase_head_count&#23558;&#22806;&#37096;&#24341;&#29992;&#22686;&#21152;&#20102;1&#65289;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#26377;&#19978;&#38754;&#30340;6&#21457;&#29983;&#26102;&#65292;&#27492;&#22788;&#20869;&#37096;&#24341;&#29992;fetch_sub(1)&#25165;&#20250;&#26377;&#21487;&#33021;&#36820;&#22238;1&#65288;6&#20043;&#21518;&#27809;&#21024;&#38500;&#33410;&#28857;&#65292;&#27492;&#22788;&#23601;&#38656;&#35201;&#21024;&#38500;&#65289;</span>
            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr-&gt;internal_count.fetch_sub(1)==1)
            {
                <span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
            }
        }
    }
};
</pre>
</div>
<p>
一旦加载了 head 的值，首先必须增加对 head 节点的外部引用计数，以表明正在引用这个节点并且确保解引用是安全的。如果在引用计数增加前解引用指针，另一个线程可能在你访问这个节点之前释放它，从而使你持有一个悬垂指针。这就是使用分离的引用计数的主要原因：通过增加外部引用计数，保证了指针在访问期间是有效的。递增操作是通过 compare_exchange_strong()的循环①完成的，其通过比较和设置整个结构体来确保指针不会在同一时间内被另一个线程修改。<br />
</p>

<p>
一旦计数增加就能安全的解引用 head 值的 ptr 字段，以便访问指向的节点②。如果指针是空指针，说明到了链表的结尾：链表为空。如果指针非空，就能尝试对 head 调用 compare_exchange_strong()来移除这个节点③。<br />
</p>

<p>
如果 compare_exchange_strong()成功，你就拥有节点的所有权，可以换出 data 以备返回④。使用 swap 将该节点的 data 换出确保了即使其他访问栈的线程恰好有指针指向该节点，数据也可以不保持存活状态（即数据可以被释放）。然后可以使用原子操作 fetch_add⑥将这个节点的外部计数加到内部计数。如果现在引用计数为 0，那么之前的值(fetch_add 返回的值)是你增加值的负数，这种情况下就可以删除节点。这里需要重点注意的是，增加的值要比外部引用计数少 2⑤；因为当节点已经从链表中删除时，就要将计数减一，然后不再从当前线程访问该节点，所以还要再减一。无论是否删除节点，操作都已经完成，所以可以将数据返回⑦。<br />
</p>

<p>
如果“比较/交换”③失败，就说明另一个线程在你之前把节点移除了，或者另一个线程添加了一个新的节点到栈中。无论是哪种情况，都需要用“比较/交换”返回的新的 head 值再次启动操作。不过，首先需要递减尝试移除的节点上的引用计数。因为这个线程不会再访问这个节点。如果当前线程是最后一个持有引用(因为另一个线程已经将这个节点从栈上移除了)的线程，那么内部引用计数将会是 1，所以减一的操作将会让计数变为 0。这样，就能在循环之前删除这个节点⑧。<br />
</p>

<p>
到目前为止，一直使用默认的 std::memory_order_seq_cst 内存顺序用于所有的原子操作。在大多数系统上，这些内存顺序在执行时间和同步开销方面比其他内存顺序更昂贵，并且在某些系统上执行时间和开销会非常大。现在你已经有了正确的数据结构逻辑，可以考虑放松一些内存顺序的要求；毕竟不希望给栈的用户增加任何不必要的开销。在离开栈，转而设计无锁队列之前，让我们检查一下栈操作，并问自己，我们能否对某些操作使用更宽松的内存顺序，同时仍然获得相同的安全级别?<br />
</p>
</div>
</div>
<div id="outline-container-org3441d37" class="outline-5">
<h5 id="org3441d37">Applying the memory model to the lock-free stack (255)</h5>
<div class="outline-text-5" id="text-org3441d37">
<p>
在修改内存顺序之前，需要检查一下操作并且确定它们之间所需的关系。然后再去确定提供所需关系的最小内存顺序。为了做到这一点，需要在几种不同的场景中从线程的视角查看相关情况。最简单的场景是一个线程将数据项推入栈，然后另一个线程在一段时间过后弹出数据项，因此我们将从这开始。<br />
</p>

<p>
在这个简单的例子中，涉及到三个重要的数据。第一个是 counted_node_ptr 用于转移数据：head。第二个是 head 引用的 node 结构，第三个是节点所指向的数据项。<br />
</p>

<p>
执行 push()的线程，会先构造数据项和 node，再设置 head。执行 pop()的线程，会先加载 head 的值，然后在 head 上执行“比较/交换”循环来增加引用计数，再读取 node 结构获取 next 的值。这里可以看到一个必须的关系；next 的值是普通的非原子对象，所以为了安全地读取它，必须在存储(push 线程)和加载(pop 线程)之间有一个 happens-before 关系。因为 push()中唯一的原子操作是 compare_exchange_weak()，并且需要一个 release 操作来获得一个线程间的 happens-before 关系，compare_exchange_weak()必须是 std::memory_order_release 或更严格的内存顺序。如果 compare_exchange_weak()调用失败，什么都不会改变，并且继续循环，所以失败时使用 std::memory_order_relaxed 就足够了。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data</span>)
{
    <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_node</span>;
    new_node.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(data);
    new_node.external_count=1;
    new_node.ptr-&gt;next=head.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node.ptr-&gt;next,new_node,
                                      <span style="color: #a45bad;">std</span>::memory_order_release,<span style="color: #a45bad;">std</span>::memory_order_relaxed));
}
</pre>
</div>
<p>
pop()的代码呢？为了获得你需要的 happens-before 关系，必须在访问 next 之前使用 std::memory_order_acquire 或更严格的内存顺序的操作。在 increase_head_count()中使用 compare_exchange_strong()读取到 head 的旧值，通过该旧值的 ptr 字段可以得到 node 指针进而进一步访问到 node 的 next 字段，所以需要把这个内存顺序用在交换成功的时候。和 push()调用一样，当交换失败，循环会继续，所以可以在失败时使用 relaxed ordering：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increase_head_count</span>(<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&amp; <span style="color: #7590db;">old_counter</span>)
{
    <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_counter</span>;
    <span style="color: #4f97d7; font-weight: bold;">do</span>
    {
        new_counter=old_counter;
        ++new_counter.external_count;
    }
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_strong(old_counter,new_counter,
                                        <span style="color: #a45bad;">std</span>::memory_order_acquire,<span style="color: #a45bad;">std</span>::memory_order_relaxed));
    old_counter.external_count=new_counter.external_count;
}
</pre>
</div>
<p>
如果 compare_exchange_strong()调用成功，将 old_counter 的 ptr 设置为读取到的 head 的 ptr 的值。由于 push()中的存储操作是个释放操作，并且这个 compare_exchange_strong()操作是个获得操作，所以存储与加载同步，你获得一个 happens-before 关系。因此，push()中存储 ptr 字段的操作发生在 pop()中对 ptr-&gt;next 的访问之前，所以操作是安全的。<br />
</p>

<p>
注意，初始 head.load() 中的内存顺序对分析没有影响，所以可以安全地使用 std::memory_order_relaxed。<br />
</p>

<p>
接下来考虑 compare_exchange_strong()将 old_head.ptr-&gt;next 设置给 head。是否需要对这个操作做些什么来保证这个线程的数据完整性吗？如果 compare_exchange_strong 成功，随后会访问 ptr-&gt;data，所以需要确保在 push()线程中对 ptr-&gt;data 的存储发生在此处的加载之前。但你已经保证了这一点：increase_head_count()中的获得操作和 push()线程中的存储操作之间有一个 synchronizes-with 关系。又因为 push()线程中对数据的存储 sequenced-before 对 head 的存储，并且调用 increase_head_count() 的操作 sequenced-before 对 ptr-&gt;data 的加载，这样，push()中对 ptr-&gt;data 的写入和 pop()中对 ptr-&gt;data 的读取之间就有了 happens-before 关系，即使 pop()中这个 compare_exchange_strong() 操作使用 std::memory_order_relaxed，一切也都正常。其他对 ptr-&gt;data 进行修改的地方就只有 swap()调用了，并且此时没有其他线程对同一节点进行操作；这就是 compare/exchange 操作的意义所在（译注：因为“比较/交换”操作使得没有别的线程有机会操作这个节点）。<br />
</p>

<p>
如果 compare_exchange_strong()失败，直到下一次循环 old_head 才会碰到新值，并且已经明确了在 increase_head_count()中使用 std::memory_order_acquire 内存顺序就够了，因此这里使用 std::memory_order_relaxed 就好了。<br />
</p>

<p>
其他线程呢？是否需要更强的内存顺序来保证其他线程的安全？答案是不需要。因为，head 只会被 compare/exchange 操作改变。这些都是“读-改-写”操作，它们是 release sequence 的组成部分，该 release sequence 的头部是 push()中的 compare/exchange 操作。因此，即使同时有很多其他线程对 head 进行修改，push()中的 compare_exchange_weak()与 increase_head_count()中的 compare_exchange_strong()(其读取了 push()中 compare_exchange_weak()操作存储的值)也相同步。<br />
</p>

<p>
现在已经接近完成了：只剩用于修改引用计数的 fetch_add()操作需要处理了。从这个节点返回数据的线程可以继续执行，因为没有其他线程可以修改这个节点的数据。不过，任何没有成功检索到数据的线程也可以知道有另外一个线程修改了节点数据；成功了的线程会使用 swap()来提取引用的数据项。为了避免 data races ，需要保证 swap()发生在 delete 前面。一种简单的做法是让成功返回分支的 fetch_add()使用 std::memory_order_release 内存顺序，而让再次循环分支的 fetch_add()使用 std::memory_order_qcquire 内存顺序。但还是有点过头了：只有一个线程会 delete(将引用计数设置为 0 的线程)，所以只有这个线程需要获得操作。庆幸的是，因为 fetch_add()是一个“读-改-写”操作，它是 release sequence 的一部分，所以可以使用一个额外的 load()来处理。如果再次循环分支递减引用计数到 0，它可以使用 std::memory_order_acquire 重新加载引用计数，从而确保所需的 synchronizes-with 关系；并且 fetch_add()本身可以使用 std::memory_order_relaxed。使用新版 pop()的最终栈实现如下。<br />
</p>

<p>
清单 7.13 使用引用计数和宽松原子操作的无锁栈<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_stack</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>;
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">external_count</span>;
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">ptr</span>;
    };
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">internal_count</span>;
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">next</span>;

        <span style="color: #bc6ec5; font-weight: bold;">node</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">data_</span>): data(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(data_)), internal_count(0) {}
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increase_head_count</span>(<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&amp; <span style="color: #7590db;">old_counter</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_counter</span>;
        <span style="color: #4f97d7; font-weight: bold;">do</span>
        {
            new_counter=old_counter;
            ++new_counter.external_count;
        }
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_strong(old_counter,new_counter,
                                            <span style="color: #a45bad;">std</span>::memory_order_acquire,
                                            <span style="color: #a45bad;">std</span>::memory_order_relaxed));
        old_counter.external_count=new_counter.external_count;
    }
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    ~<span style="color: #bc6ec5; font-weight: bold;">lock_free_stack</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(pop());
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #7590db;">push</span>(T <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; data)
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_node</span>;
        new_node.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>(data);
        new_node.external_count=1;
        new_node.ptr-&gt;next=head.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>head.compare_exchange_weak(new_node.ptr-&gt;next,new_node,
                                          <span style="color: #a45bad;">std</span>::memory_order_release,
                                          <span style="color: #a45bad;">std</span>::memory_order_relaxed));
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_head</span>=head.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_head_count(old_head);
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ptr</span>=old_head.ptr;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>ptr)
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
            }
            <span style="color: #4f97d7; font-weight: bold;">if</span>(head.compare_exchange_strong(old_head,ptr-&gt;next, <span style="color: #a45bad;">std</span>::memory_order_relaxed))
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">res</span>;
                res.swap(ptr-&gt;data);

                <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">count_increase</span>=old_head.external_count-2;
                <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr-&gt;internal_count.fetch_add(count_increase,<span style="color: #a45bad;">std</span>::memory_order_release)==
                   -count_increase)
                {
                    <span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;
                }
                <span style="color: #4f97d7; font-weight: bold;">return</span> res;
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr-&gt;internal_count.fetch_add(-1, <span style="color: #a45bad;">std</span>::memory_order_relaxed)==1)
            {
                <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">TODO: Why?</span>
                ptr-&gt;internal_count.load(<span style="color: #a45bad;">std</span>::memory_order_acquire);
                <span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;
            }
        }
    }
};
</pre>
</div>
<p>
虽历经磨难，但我们终究到达了终点，实现了一个更好的栈。在深思熟虑后通过使用更多的宽松操作，实现了在不影响正确性的情况下提升了性能。如你所见，pop()的实现现在有 37 行，而等价的栈实现，在清单 6.1 中基于锁的实现只有 8 行，在清单 7.2 中没有内存管理的基本无锁实现更是只有 7 行。当我们继续研究如何编写无锁队列时，将看到一个类似的模式：无锁代码中的许多复杂性来自于管理内存。<br />
</p>
</div>
</div>
<div id="outline-container-org73d012e" class="outline-5">
<h5 id="org73d012e">Writing a thread-safe queue without locks (259)</h5>
<div class="outline-text-5" id="text-org73d012e">
<p>
队列相比栈的挑战有些不同，因为 push()和 pop()在队列中，操作的是数据结构不同的部分，而栈访问的是相同的头结点。因此，对同步的需求不一样。需要确保对一端的修改对另一端的访问是正确可见的。不过清单 6.6 中队列的 try_pop()结构与清单 7.2 中简单无锁栈的 pop()结构相差不大，因此你可以合理地假设无锁代码也不会有太大差异。让我们来看看怎么做。<br />
</p>

<p>
如果以清单 6.6 作为基础，你需要两个 node 指针：用于表头的 head 和表尾的 tail。由于需要在多线程访问这些指针，因此它们最好是原子的，这样的话就可以不用互斥锁。让我们从一些小改动开始，然后看一下它能给我们带来什么。下面的清单展示了结果。<br />
</p>

<p>
<a id="org18ac582"></a> 一个单生产者，单消费者的无锁队列<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">next</span>;

        <span style="color: #bc6ec5; font-weight: bold;">node</span>(): next(<span style="color: #a45bad;">nullptr</span>) {}
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>*&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node</span>*&gt; <span style="color: #7590db;">tail</span>;

    <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #bc6ec5; font-weight: bold;">pop_head</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=head.load();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(old_head==tail.load())  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">nullptr</span>;
        }
        head.store(old_head-&gt;next);
        <span style="color: #4f97d7; font-weight: bold;">return</span> old_head;
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">lock_free_queue</span>(): head(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>),tail(head.load()) {}

    <span style="color: #bc6ec5; font-weight: bold;">lock_free_queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    ~<span style="color: #bc6ec5; font-weight: bold;">lock_free_queue</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_head</span>=head.load())
        {
            head.store(old_head-&gt;next);
            <span style="color: #4f97d7; font-weight: bold;">delete</span> old_head;
        }
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">old_head</span>=pop_head();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>old_head)
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::shared_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
        }

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>(old_head-&gt;data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #4f97d7; font-weight: bold;">delete</span> old_head;
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #a45bad;">std</span>::make_shared&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(new_value));
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">p</span>=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_tail</span>=tail.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        old_tail-&gt;data.swap(new_data);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        old_tail-&gt;next=p;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        tail.store(p);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
    }
};
</pre>
</div>
<p>
第一眼瞥过去，这个实现还不错，如果一次只有一个线程调用 push()，并且只有一个线程调用 pop()的话，这个队列就很完美。在这种单生产者单消费者情况下，push()和 pop()之间的 happens-before 关系很重要，其确保了获取数据是安全的。对 tail 的存储⑦和对 tail 的加载①相同步，对前面节点的 data 指针的存储⑤ sequenced-before 指针 tail 的存储；并且，tail 的加载 sequenced-before data 指针的加载 ②，所以对 data 的存储要 happens-before 对 data 的加载，这样一切也是正常的。因此，这是一个完美的单生产者，单消费者(SPSC, single-producer, single-consume)队列。<br />
</p>

<p>
当多个线程并发调用 push()或多个线程并发调用 pop()时，就会有问题。我们先看一下 push()：如果有两个线程并发调用 push()，它们都会分配新节点作为新的虚拟节点③，都会读取到相同的 tail 值④，因此，当设置 data 和 next 指针时，都会更新同一个节点的数据成员⑤⑥。这是典型的 data race！<br />
</p>

<p>
pop_head()也有类似的问题。如果两个线程并发调用，这两个线程会读取到相同的 head 值，并且会用相同的 next 指针去覆盖旧值。现在，两个线程都认为它们获取到同一个节点—这会后患无穷。你不仅必须确保只有一个线程在给定的 item 上使用 pop()，还要保证其他线程可以安全的访问 head 节点中的 next 成员。这正是你在无锁栈 pop()中看到的问题，所以那里的任何方案都可以用在这。<br />
</p>

<p>
假设 pop()的问题解决了，那么 push()呢？ 问题在于为了获得 push()和 pop()之间的 happens-before 关系，需要在更新 tail 之前设置虚拟节点的数据项。但这意味着对 push()的多个并发调用会在这些相同的数据项上竞争，因为它们读取了相同的 tail 指针。<br />
</p>
</div>

<div id="outline-container-org0e52a59" class="outline-6">
<h6 id="org0e52a59">HANDLING MULTIPLE THREADS IN PUSH()</h6>
<div class="outline-text-6" id="text-org0e52a59">
<p>
一个选择是在真实节点间添加一个虚拟节点。这样的话，当前 tail 节点唯一需要更新的是 next 指针，因此这个操作可以是原子的。如果一个线程成功地将 next 指针从 nullptr 改成了它的新节点，那么它就成功地添加了指针；否则，就需要重新开始并再次读取 tail。这需要对 pop()做微小的更改，以便丢弃带有空数据指针的节点并再次循环。这里的缺点是每个 pop()调用通常都必须删除两个节点，而且内存分配的数量是原来的两倍。<br />
</p>

<p>
第二个选择是让 data 指针是原子的，并通过“比较/交换”操作对其进行设置。如果调用成功，此处获得的 tail 节点就是你的 tail 节点，你可以安全的设置它的 next 指针为你的新节点，然后更新 tail。如果“比较/交换”操作失败（因为另一个线程存储了数据），就要继续循环，重新读取 tail ，再来一遍。如果 std::shared_ptr&lt;&gt;上的原子操作是无锁的，就大功告成了。如果不是的话，就需要一个替代方案。一种可能的方案是让 pop()返回一个 std::unique_ptr&lt;&gt;(毕竟，它是对象的唯一引用)，并将数据作为普通指针存储在队列中。这样你就可以将 data 存储为 std::atomic&lt;T*&gt;，从而让 data 支持了必要的 compare_exchange_strong()调用。如果你正在使用 <a href="#orgfb7dfa5">清单 7.12</a> 中的引用计数方案来处理 pop()中的多个线程，那么 push()现在看起来像这样。<br />
</p>

<p>
<a id="orga047b60"></a> 修正 push()的(有问题的)第一次尝试<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">T</span>(new_value));
    <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_next</span>;
    new_next.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>;
    new_next.external_count=1;

    <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">old_tail</span>=tail.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        <span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #7590db;">old_data</span>=<span style="color: #a45bad;">nullptr</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(old_tail-&gt;data.compare_exchange_strong(
               old_data,new_data.get()))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        {
            old_tail-&gt;next=new_next;
            tail.store(new_next.ptr);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            new_data.release();
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }
    }
}
</pre>
</div>
<p>
使用引用计数方案可以避免这个特殊的 race，但它不是 push()中唯一的 race。如果查看清单 7.15 中 push()的修订版，将看到栈中见过的模式：加载一个原子指针①，并解引用该指针②。同时，另一个线程可能更新该指针③，最终到该节点被释放(在 pop()中)。如果在解引用指针前节点被释放，就会有未定义的行为。一个很有诱惑力的做法是，像在 head 中一样，给 tail 添加一个外部计数，但是每个节点已经有一个外部计数在队列中前一个节点的 next 指针中。同一个节点有两个外部计数就需要对引用计数方案进行修改，从而避免过早删除节点。你也可以在 node 结构中计算外部计数器的数量，并在每个外部计数器被销毁时减少该数量(也就是把对应的外部计数加到内部计数)来定位该问题。当内部计数是 0，且没有外部计数器时，节点就可以被安全的删除。这是我在 Joe Seigh 的“Atomic Ptr Plus”项目（<a href="http://atomic-ptr-plus.sourceforge.net/">http://atomic-ptr-plus.sourceforge.net/</a>） 中第一次遇到的技术。下面的清单展示了这种方案下 push()的实现。<br />
</p>

<p>
<a id="org640cae4"></a> 使用带有引用计数的 tail，实现无锁队列的 push()<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>;
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">external_count</span>;
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #7590db;">ptr</span>;
    };
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&gt; <span style="color: #7590db;">head</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&gt; <span style="color: #7590db;">tail</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node_counter</span>
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">internal_count</span>:30;
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">external_counters</span>:2;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    };
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>*&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">node_counter</span>&gt; <span style="color: #7590db;">count</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">next</span>;

        <span style="color: #bc6ec5; font-weight: bold;">node</span>()
        {
            <span style="color: #ce537a; font-weight: bold;">node_counter</span> <span style="color: #7590db;">new_count</span>;
            new_count.internal_count=0;
            new_count.external_counters=2;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            count.store(new_count);

            next.ptr=<span style="color: #a45bad;">nullptr</span>;
            next.external_count=0;
        }
    };

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">T</span>(new_value));
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_next</span>;
        new_next.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>;
        new_next.external_count=1;
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_tail</span>=tail.load();

        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_external_count(tail,old_tail);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>

            <span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #7590db;">old_data</span>=<span style="color: #a45bad;">nullptr</span>;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(old_tail.ptr-&gt;data.compare_exchange_strong(old_data,new_data.get())) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            {
                old_tail.ptr-&gt;next=new_next;
                old_tail=tail.exchange(new_next);
                free_external_counter(old_tail);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
                new_data.release();
                <span style="color: #4f97d7; font-weight: bold;">break</span>;
            }
            old_tail.ptr-&gt;release_ref(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25191;&#34892;&#21644;5&#30340;&#21453;&#25805;&#20316;&#65292;&#19981;&#36807;&#26159;&#20943;&#23569;&#20869;&#37096;&#35745;&#25968;&#65292;&#21644;&#26080;&#38145;&#26632;&#24046;&#19981;&#22810;</span>
        }
    }
};
</pre>
</div>
<p>
清单 7.16 中，tail 和 head 一样都是 atomic&lt;counted_node_ptr&gt;类型①，并且 node 结构体中用 count 成员替换了之前的 internal_count③。count 成员变量包括了 internal_count 和额外的 external_counters 成员②。注意，external_counters 只需要 2 比特，因为最多就两个计数器（译注：你最多被队列中前面一个节点的 next 成员引用，以及当你在队尾时被 tail 引用）。通过使用位域，并将 internal_count 指定为 30 比特的值，就能保证计数器的总大小是 32 比特。这为大型内部计数值提供了足够的空间，同时确保了整个结构适合放入 32 位和 64 位机器上的一个机器字中。稍后你将看到，为了避免 race conditions，将这些计数作为单个实体一起更新是很重要的。同时将结构放入一个机器字内，可以使原子操作在许多平台上更有可能是无锁的。<br />
</p>

<p>
node 初始化时，internal_count 设置为 0，external_counter 设置为 2④，因为每个新节点一旦加入到队列中，都会被 tail 和前一个节点的 next 指针所引用。push()本身与清单 7.15 中的实现类似，不同之处在于，在⑥处之前（此处使用从 tail 读取的 old_tail，在 old_tail 所指节点上的 data 成员上调用 compare_exchange_strong()）在⑤处调用了新的 increase_external_count()函数以增加计数。随后又在旧的尾部节点 old_tail 上调用 free_external_counter()⑦。<br />
</p>

<p>
处理完 push()后，再来看一下 pop()。下面展示的代码将清单 7.12 中 pop()的引用计数逻辑与 7.14 中队列弹出逻辑融合在一起。<br />
</p>

<p>
<a id="orgc624867"></a> 使用带有引用计数的 tail，从无锁队列中弹出节点<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">release_ref</span>();
    };
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_head</span>=head.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_external_count(head,old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ptr</span>=old_head.ptr;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr==tail.load().ptr)
            {
                ptr-&gt;release_ref();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
            }
            <span style="color: #4f97d7; font-weight: bold;">if</span>(head.compare_exchange_strong(old_head,ptr-&gt;next))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            {
                <span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>=ptr-&gt;data.exchange(<span style="color: #a45bad;">nullptr</span>);
                free_external_counter(old_head);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(res);
            }
            ptr-&gt;release_ref();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        }
    }
};
</pre>
</div>
<p>
在进入循环之前①，以及增加外部计数之前②，以加载 head 得到 old_head 作为开始。如果 head 节点和 tail 节点相同，说明队列中没有数据，因此可以释放引用计数③并且返回一个空指针。如果队列中还有数据，可以尝试使用 compare_exchange_strong()来索取数据④。与 7.12 中的栈一样，将外部计数和指针做为一个整体做比较；如果任何一个变化了，你需要在释放了引用后⑥，再次循环。如果交换成功时，说明已经索取到节点中的数据，为已弹出节点释放外部计数器后⑤，就可以把数据返回给调用函数了。一旦两个外部引用计数都被释放，且内部计数降为 0 时，节点本身就可以被删除。处理这一切的引用计数函数展示在清单 7.18，7.19 和 7.20 中。<br />
</p>

<p>
<a id="orgfc79a31"></a> 在无锁队列中释放一个节点引用<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">release_ref</span>()
        {
            <span style="color: #ce537a; font-weight: bold;">node_counter</span> <span style="color: #7590db;">old_counter</span>=count.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
            <span style="color: #ce537a; font-weight: bold;">node_counter</span> <span style="color: #7590db;">new_counter</span>;
            <span style="color: #4f97d7; font-weight: bold;">do</span>
            {
                new_counter=old_counter;
                --new_counter.internal_count;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>count.compare_exchange_strong(  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
                      old_counter,new_counter,
                      <span style="color: #a45bad;">std</span>::memory_order_acquire,<span style="color: #a45bad;">std</span>::memory_order_relaxed));
            <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>new_counter.internal_count &amp;&amp; <span style="color: #a45bad;">!</span>new_counter.external_counters)
            {
                <span style="color: #4f97d7; font-weight: bold;">delete</span> <span style="color: #4f97d7; font-weight: bold;">this</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            }
        }
    };
};
</pre>
</div>
<p>
与 <a href="#orgfb7dfa5">清单 7.12</a> 中 lock_free_stack::pop()实现中的等价代码相比，node::release_ref()的实现只做了轻微的改变。不过，清单 7.12 中的代码只需要处理单个外部计数，所以只需要简单的 fetch_sub，但现在即使你只想更新 internal_count 字段①，也必须原子地更新整个 count 结构。因此，需要一个 compare/exchange 循环②。一旦递减了 internal_count，如果内部和外部计数都为 0 时，说明这是最后一个引用，就可以删除这个节点了③。<br />
</p>

<p>
<a id="org3ddb727"></a> 获取无锁队列中节点的新引用<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increase_external_count</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;counted_node_ptr&gt;&amp; <span style="color: #7590db;">counter</span>,
                                        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span>&amp; <span style="color: #7590db;">old_counter</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_counter</span>;
        <span style="color: #4f97d7; font-weight: bold;">do</span>
        {
            new_counter=old_counter;
            ++new_counter.external_count;
        }
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>counter.compare_exchange_strong(
                  old_counter,new_counter,
                  <span style="color: #a45bad;">std</span>::memory_order_acquire,<span style="color: #a45bad;">std</span>::memory_order_relaxed));
        old_counter.external_count=new_counter.external_count;
    }
};
</pre>
</div>
<p>
清单 7.19 展示的是另一方面。这次不是释放引用，而是获得一个新的引用，并增加外部计数。increase_external_count()和清单 7.13 中的 increase_head_count()很相似，不同的是 increase_external_count()这里作为静态成员函数，这个函数以要更新的外部计数器作为第一个参数，而不是操作一个固定的计数器。<br />
</p>

<p>
清单 7.20 无锁队列中释放节点对应的一个外部计数器<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">free_external_counter</span>(<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> &amp;<span style="color: #7590db;">old_node_ptr</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ptr</span>=old_node_ptr.ptr;
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">count_increase</span>=old_node_ptr.external_count-2;
        <span style="color: #ce537a; font-weight: bold;">node_counter</span> <span style="color: #7590db;">old_counter</span>=ptr-&gt;count.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #ce537a; font-weight: bold;">node_counter</span> <span style="color: #7590db;">new_counter</span>;
        <span style="color: #4f97d7; font-weight: bold;">do</span>
        {
            new_counter=old_counter;
            --new_counter.external_counters;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
            new_counter.internal_count+=count_increase;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>ptr-&gt;count.compare_exchange_strong(  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
                  old_counter,new_counter,
                  <span style="color: #a45bad;">std</span>::memory_order_acquire,<span style="color: #a45bad;">std</span>::memory_order_relaxed));

        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>new_counter.internal_count &amp;&amp; <span style="color: #a45bad;">!</span>new_counter.external_counters)
        {
            <span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        }
    }
};
</pre>
</div>
<p>
与 increase_external_count()对应的是 free_external_counter()。这和清单 7.12 中 lock_free_stack::pop()的等价代码类似，但是做了修改来处理 external_counters 计数。它在整个 count 结构体上使用单个 compare_exchange_strong()来更新两个计数器③，这跟之前在 release_ref()中递减 internal_count 一样。internal_count 值的更新方式和清单 7.12 中一样②，并且 external_counters 的值会减一①。如果两者的值都为 0，就意味着没有更多的引用指向这个节点，所以节点可以被安全的删除④。这需要在单个动作中完成(因此需要 compare/exchange 循环)来避免 race conditions。如果它们被分别更新，两个线程可能都认为它们是最后一个引用节点的线程，并且都会删除节点，最终导致未定义的行为。<br />
</p>

<p>
尽管现在队列能工作并且也是 race free 的，但仍然有性能问题。当有一个线程成功完成 old_tail.ptr-&gt;data 上的 compare_ exchange_strong()，从而启动 push()操作 (<a href="#org640cae4">清单 7.16</a> 中的⑥)，没有其他线程能执行 push()操作。任何尝试的线程将看到新值而不是 nullptr，这将导致 compare_exchange_strong()调用失败，然后线程继续循环。这是一个忙等待，它消耗 CPU 周期，但没有任何进展。因此，这实际上是一个锁。第一个 push()调用会阻塞其他线程，直到它完成为止，因此这段代码不再是无锁的。不仅如此，如果有阻塞的线程，操作系统可以给持有互斥锁的线程优先权，但在本例中做不到，所以阻塞的线程将浪费 CPU 周期，直到第一个线程完成。这就需要无锁锦囊中的下一个技巧：等待线程可以帮助执行 push()的线程。<br />
</p>
</div>
</div>
<div id="outline-container-org465d63c" class="outline-6">
<h6 id="org465d63c">MAKING THE QUEUE LOCK-FREE BY HELPING OUT ANOTHER THREAD</h6>
<div class="outline-text-6" id="text-org465d63c">
<p>
为了恢复代码无锁的属性，即使执行 push()的线程停滞了，你也需要找到一种方法让等待的线程继续前进。一种方法是帮停滞的线程执行它的工作。<br />
</p>

<p>
这种情况下，你确切的知道应该做什么：尾节点的 next 指针需要设置为一个新的虚拟节点，然后 tail 指针本身也必须更新。因为虚拟节点都是等价的，所以你的虚拟节点是哪个线程创建的都不重要。如果节点中的 next 指针是原子的，就可以使用 compare_exchange_strong()来设置 next 指针。一旦设置了 next 指针，就可以使用 compare_exchange_weak()循环设置 tail(<a href="#org2aaf7c8">清单 7.22 (2)处</a>)，同时确保它仍然引用的原始节点(<a href="#org2aaf7c8">清单 7.22 (15)处</a>)。否则的话，说明其他人已经更新了它，可以停止尝试并再次循环。为了加载 next 指针，这里也需要对 pop()做微小的改动；如下面的清单所示。<br />
</p>

<p>
<a id="org2e96bbd"></a> pop()修改为允许帮助 push()端<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">node</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>*&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;node_counter&gt; <span style="color: #7590db;">count</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;counted_node_ptr&gt; <span style="color: #7590db;">next</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    };
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">pop</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_head</span>=head.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_external_count(head,old_head);
            <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">ptr</span>=old_head.ptr;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(ptr==tail.load().ptr)
            {
                ptr-&gt;release_ref(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21407;&#20070;&#27809;&#26377;&#36825;&#21477;&#65292;&#20250;&#23548;&#33268;&#20869;&#23384;&#27844;&#28431;&#65292;&#22240;&#20026;&#21069;&#38754;&#22686;&#21152;&#35745;&#25968;&#65292;&#27809;&#26377;&#20943;&#25481;</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;();
            }
            <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">next</span>=ptr-&gt;next.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span>(head.compare_exchange_strong(old_head,next))
            {
                <span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">res</span>=ptr-&gt;data.exchange(<span style="color: #a45bad;">nullptr</span>);
                free_external_counter(old_head);
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;(res);
            }
            ptr-&gt;release_ref();
        }
    }
};
</pre>
</div>

<p>
之前提过，这里的修改很简单：next 指针现在是原子的①，所以 load②也是原子的。在这个例子中，使用了默认的 memory_order_seq_cst 内存顺序，所以这里可以省略对 load()的显式调用（即 load 不用显示指定 memory_order_seq_cst 内存顺序），并依赖 load 返回的值隐式转换为 counted_node_ptr，不过放入显式的调用可以用来提醒稍后在哪里需要添加显示的内存顺序。<br />
</p>

<p>
push()的代码比较复杂，展示如下。<br />
</p>

<p>
<a id="org2aaf7c8"></a> 带有帮助的示例 push()用于无锁队列<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">lock_free_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set_new_tail</span>(<span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> &amp;<span style="color: #7590db;">old_tail</span>, <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #4f97d7; font-weight: bold;">const</span> &amp;<span style="color: #7590db;">new_tail</span>) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #ce537a; font-weight: bold;">node</span>* <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">current_tail_ptr</span>=old_tail.ptr;
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>tail.compare_exchange_weak(old_tail,new_tail) &amp;&amp;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
              old_tail.ptr==current_tail_ptr); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(old_tail.ptr==current_tail_ptr)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            free_external_counter(old_tail);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #4f97d7; font-weight: bold;">else</span>
            current_tail_ptr-&gt;release_ref();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">new_value</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_data</span>(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">T</span>(new_value));
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">new_next</span>;
        new_next.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>;
        new_next.external_count=1;
        <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_tail</span>=tail.load();

        <span style="color: #4f97d7; font-weight: bold;">for</span>(;;)
        {
            increase_external_count(tail,old_tail);

            <span style="color: #ce537a; font-weight: bold;">T</span>* <span style="color: #7590db;">old_data</span>=<span style="color: #a45bad;">nullptr</span>;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(old_tail.ptr-&gt;data.compare_exchange_strong(old_data, new_data.get())) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            {
                <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_next</span>={0};
                <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>old_tail.ptr-&gt;next.compare_exchange_strong(old_next,new_next)) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
                {
                    <span style="color: #4f97d7; font-weight: bold;">delete</span> new_next.ptr;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
                    new_next=old_next;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
                }
                set_new_tail(old_tail, new_next);
                new_data.release();
                <span style="color: #4f97d7; font-weight: bold;">break</span>;
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
            {
                <span style="color: #ce537a; font-weight: bold;">counted_node_ptr</span> <span style="color: #7590db;">old_next</span>={0};
                <span style="color: #4f97d7; font-weight: bold;">if</span>(old_tail.ptr-&gt;next.compare_exchange_strong(old_next,new_next)) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
                {
                    old_next=new_next;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
                    new_next.ptr=<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">node</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">13</span>
                }
                set_new_tail(old_tail, old_next);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">14</span>
            }
        }
    }
};
</pre>
</div>
<p>
这与 <a href="#org640cae4">清单 7.16</a> 中的原始 push()类似，但有几个关键的区别。如果设置 data 指针⑥，就需要处理另一个线程帮助你的情况，现在有一个 else 子句用来提供这个帮助⑩。<br />
</p>

<p>
设置节点的 data 指针成功后⑥，这个新版的 push()会使用 compare_exchange_strong()更新 next 指针⑦。使用 compare_exchange_strong()是为了避免循环。如果交换失败，说明另外一个线程已经设置了 next 指针，也就不需要在开头分配的新节点了，就可以直接删除这个节点了⑧。接下来，使用其他线程帮忙设置的 next 值来更新 tail⑨。<br />
</p>

<p>
对 tail 指针的更新逻辑已经抽离到 set_new_tail()函数①。如果其他线程尝试 push()一个新节点，external_count 部分可能已经改变，并且你不想弄丢它，所以，这里使用一个 compare_exchange_weak()循环②来更新 tail。但是还需要注意，如果另一个线程已经成功地修改了该值，你就不能替换它；否则，你可能会在队列中出现循环，这是做相当糟糕。因此，如果 compare/exchange 操作失败，需要保证 old_tail.ptr==current_tail_ptr。如果在循环退出后 ptr 是相同的③，那么你肯定已经成功设置了 tail，因此你需要释放旧的外部计数器④。如果 ptr 值不一样，那么另一个线程将释放计数器，所以只需要对该线程持有的单个引用进行释放即可⑤。<br />
</p>

<p>
如果调用 push()的线程在循环中这次设置 data 指针失败，它可以帮助成功的线程完成更新。首先，尝试更新 next 指针，让其指向该线程分配出来的新节点⑪。如果更新成功，使用这个分配的新节点作为新的 tail 节点⑫。预计到下一次循环将 item 添加到队列的操作，需要分配另外一个新节点⑬。然后，在再次循环之前，可以尝试通过调用 set_new_tail 来设置 tail 节点⑭。<br />
</p>

<p>
你可能已经注意到，这么短一段代码，其包含了大量的 new 和 delete 调用，因为新节点是在 push()中分配，并且在 pop()中销毁。因此，内存分配器的效率对这个代码的性能有相当大的影响；一个糟糕的分配器可以完全破坏像这样的无锁容器的可扩展属性。选择和实现这类分配器，超出了本书的范围，但是重要的是要记住，识别分配器好坏的唯一方法就是试用它，并对比前后的性能。优化内存分配的常见技术包括在每个线程上有一个单独的内存分配器，并使用空闲链表回收节点，而不是将它们返回给分配器。<br />
</p>

<p>
到目前为止已经看到足够多的例子；现在，让我们从示例中提取一些编写无锁数据结构的指南。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7eca738" class="outline-4">
<h4 id="org7eca738">7.3 Guidelines for writing lock-free data structures (271)</h4>
<div class="outline-text-4" id="text-org7eca738">
<p>
如果你已经完成了本章的所有示例，就能领会正确实现无锁代码所涉及的复杂性。如果打算设计自己的数据结构，提供一些需要关注的指南会很有帮助。第 6 章开始时关于并发数据结构的通用指南仍然适用，但这里需要的更多。我从示例中提取了一些有用的指南，可以在设计自己的无锁数据结构时参考它们。<br />
</p>
</div>
<div id="outline-container-orgae83897" class="outline-5">
<h5 id="orgae83897">Guideline: use std::memory_order_seq_cst for prototyping (271)</h5>
<div class="outline-text-5" id="text-orgae83897">
<p>
std::memory_order_seq_cst 比起其他内存顺序更容易理解，因为所有操作构成一个全序。本章的所有例子，都是从 std::memory_order_seq_cst 开始，并且只有当基本操作正常工作的时候，才放宽内存顺序的约束。从这个意义上讲，使用其他内存顺序就是优化，因此，你需要避免过早地这样做。通常，只有在看到可以对数据结构的内部进行操作的完整代码集时，才能确定哪些操作可以放松。试图乱来的话会让你更加艰难。这里的复杂性在于，测试的时候代码可能是正常工作的，但不能保证代码就是没问题的。除非你有一个算法检查器，可以系统地测试线程可见性的所有组合，这些组合与指定的顺序保证一致 (这些东西确实存在)，否则只运行代码的测试是不够的。<br />
</p>
</div>
</div>
<div id="outline-container-org89d1059" class="outline-5">
<h5 id="org89d1059">Guideline: use a lock-free memory reclamation scheme (271)</h5>
<div class="outline-text-5" id="text-org89d1059">
<p>
无锁代码最大的困难之一就是内存管理。当其他线程可能仍然引用对象时，必须避免删除它们，但你仍然希望尽快删除对象，从而避免过多的内存消耗。本章介绍了三种技术来确保内存可以被安全的回收：<br />
</p>

<ul class="org-ul">
<li>等待直到没有线程访问数据结构时，删除所有等待删除的对象。<br /></li>
<li>使用风险指针来标识一个线程正在访问一个特定对象。<br /></li>
<li>引用计数对象，直到没有未完成的引用时才删除它们。<br /></li>
</ul>

<p>
在所有情况下，核心思想都是使用某种方法来跟踪有多少线程正在访问某个特定对象，并且只在不再从任何地方引用时删除每个对象。在无锁数据结构中，还有许多其他回收内存的方法。例如，这是使用垃圾回收器的理想场景。如果你知道垃圾回收器将在节点不再使用时(而不是之前)释放它们，那么编写算法就会容易得多。<br />
</p>

<p>
另一种方法是回收节点，并且只在数据结构销毁时完全释放它们。由于节点被重用，内存永远不会失效，因此避免未定义行为的一些困难就消失了。不利的一面是，另一个问题变得更加普遍。这就是所谓的“ABA 问题”。<br />
</p>
</div>
</div>
<div id="outline-container-org1051cb1" class="outline-5">
<h5 id="org1051cb1">Guideline: watch out for the ABA problem (272)</h5>
<div class="outline-text-5" id="text-org1051cb1">
<p>
任何基于“比较/交换”的算法都要小心 ABA 问题。它是这样的：<br />
</p>

<ol class="org-ol">
<li>线程 1 读取原子变量 x，并且发现其值是 A。<br /></li>
<li>线程 1 基于这个值进行一些操作，比如，解引用(如果它是个指针)，或做查找，或者别的什么操作。<br /></li>
<li>线程 1 被操作系统暂停。<br /></li>
<li>另一个线程对 x 执行一些操作，将它的值改为 B。<br /></li>
<li>然后某个线程更改与值 A 相关联的数据，使线程 1 持有的值不再有效。这可能与释放指向的内存或更改关联值一样激烈。<br /></li>
<li>然后某个线程根据这个新数据将 x 修改回 A。如果这是一个指针，它可能是一个碰巧与旧对象共享相同地址的新对象。<br /></li>
<li>线程 1 继续对 x 执行比较/交换操作，与 A 做比较。比较/交换会成功(因为值确实是 A)，但这是错误的 A 值。因为最初在步骤 2 中读取的数据不再有效，但是线程 1 无从得知，并将破坏数据结构。<br /></li>
</ol>

<p>
这里的算法都不会遇到这个问题，但很容易编写碰到这个问题的无锁算法。避免这个问题最常见的方法是在变量 x 旁边包含一个 ABA 计数器，然后在 x 带上计数器的组合结构（作为一个单元）上执行比较/交换操作。每次值被替换时，计数器就会增加，所以即使 x 有相同的值，如果另一个线程修改了 x，比较/交换将失败。<br />
</p>

<p>
ABA 问题在使用空闲链表或回收节点而不是将它们返回给分配器的算法中尤为普遍。<br />
</p>
</div>
</div>
<div id="outline-container-org68944c8" class="outline-5">
<h5 id="org68944c8">Guideline: identify busy-wait loops and help the other thread (272)</h5>
<div class="outline-text-5" id="text-org68944c8">
<p>
在最后的队列实例中，你看到了线程在执行 push 操作时，必须等待另一个也在执行 push 的线程完成它的操作才能继续。如果放任不管的话，这将是一个忙等循环，等待线程在无法继续时会浪费 CPU 时间。如果最终使用了忙等循环，你相当于使用了一个阻塞操作，这跟使用互斥锁也差不多。通过修改算法，若等待线程在原始线程完成操作之前被调度，让等待线程执行未完成的步骤，这样你就可以去掉忙等，并且操作也不再阻塞。队列示例中需要将一个数据成员更改为一个原子变量，而不是使用非原子变量，并且使用“比较/交换”操作来设置它；不过在更复杂的数据结构中，需要更多修改。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7e4bb73" class="outline-3">
<h3 id="org7e4bb73">08 designing concurrent code</h3>
<div class="outline-text-3" id="text-org7e4bb73">
</div>
<div id="outline-container-org12addf9" class="outline-4">
<h4 id="org12addf9">本章主要内容</h4>
<div class="outline-text-4" id="text-org12addf9">
<ul class="org-ul">
<li>线程间划分数据的技术<br /></li>
<li>影响并发代码性能的因素<br /></li>
<li>性能因素是如何影响数据结构的设计<br /></li>
<li>多线程代码中的异常安全<br /></li>
<li>可扩展性<br /></li>
<li>几个并行算法的示例实现<br /></li>
</ul>

<p>
前面大部分章节都集中在 C++工具箱中用于编写并发代码的工具上。第 6、7 章中考察了如何使用这些工具来设计基本的数据结构，这些数据结构能够安全地被多线程并发访问。就像一个木匠要做一个橱柜或桌子，需要知道的不只是如何制作铰链或接头，设计并发代码也比设计和使用基本数据结构需要知道的更多。你现在需要考虑更广泛的上下文，以便构建更大的结构来执行有用的工作。我将使用 C++标准库算法的多线程实现作为例子，不过同样的原则也适用所有规模的应用程序。<br />
</p>

<p>
和任何编程项目一样，仔细考虑并发代码的设计至关重要。但对于多线程代码，需要考虑的因素比顺序代码更多。不仅要考虑一般性因素，例如封装，耦合和内聚(这些在很多软件设计书籍中有充分描述)，还要考虑共享哪些数据，如何同步访问数据，哪些线程需要等待其他线程完成某种操作，等等。<br />
</p>

<p>
本章我们将重点讨论这些问题，从高层次(但也是最根本的)的考虑使用多少线程，哪些代码在哪个线程执行，以及这如何影响代码的清晰性，到低层次细节：如何为最优性能构建共享数据。<br />
</p>

<p>
让我们从如何在线程间划分工作的技术开始。<br />
</p>
</div>
</div>
<div id="outline-container-org4adcd4e" class="outline-4">
<h4 id="org4adcd4e">8.1 Techniques for dividing work between threads (275)</h4>
<div class="outline-text-4" id="text-org4adcd4e">
<p>
想象一下，你被要求建造一座房子。为了完成工作，需要挖地基、砌墙、安装管道、接入电线等等。理论上，只要经过足够的培训你全都可以自己干，但是这可能花费很长时间，并且需要不断的切换任务。或者，你可以雇佣一些人来帮忙。现在你需要决定雇多少人，以及他们需要什么样的技能。比如，你可以雇几个通用技能的人，这几个人什么都干。现在你还得不断的切换任务，不过因为现在有更多跟你一样的人，因此可以更快的完成。<br />
</p>

<p>
或者，你可以雇佣一个专业团队：瓦工，木匠，电工和水管工。你的专业人员只做他擅长的，所以当没有管道施工时，水管工会坐在那喝茶或咖啡。事情还是能够比以前完成的更快，因为人多，并且电工接通厨房电源的时候，水管工可以投入厕所的工作，但是当没有更多工作给特定专业人员时，会有更多等待。即使有空闲时间，你可能还是能感觉到专业团队要比雇佣一帮什么都能干的杂工快。因为专业人员不需要频繁更换工具，并且每个人都比一般人员更快的完成任务。当然事实是否如此取决于特定的情况——必须试一下才知道。<br />
</p>

<p>
即使雇佣专业人员，你仍然可以选择不同工种的人数。比如，可能砖瓦工的数量需要超过电工。同样，如果建造不止一座房子，团队的组成和整体的效率可能也会发生变化。可能对任何要建的一座房子来说，水管工没有太多的工作要做，但是，若你在同时建造很房子，水管工就可能总是处于忙碌的状态。并且，当他们没有工作可做时，如果你不用给他们钱，你可能有能力整体上负担起一个更大的团队，即使在任何时候只让相同数量的人在工作。<br />
</p>

<p>
好了，建造的例子说的够多了；这一切跟线程有什么关系？好吧，这些问题也会发生在线程上。你需要决定使用多少个线程，并且这些线程应该完成什么任务。还需要决定是使用“通才”线程什么都做，还是使用“专才”线程做好一件事，或将两种方法混合。不管使用并发的动因是什么你需要做这些选择，并且如何做选择会对性能和代码的清晰性产生关键的影响。因此理解这些选项至关重要，这样在设计应用程序的结构的时候就能做出明智的决定。本节中，将考察几个划分任务的技术，先从线程间划分数据开始。<br />
</p>
</div>
<div id="outline-container-orge931b30" class="outline-5">
<h5 id="orge931b30">8.1.1 Dividing data between threads before processing begins (276)</h5>
<div class="outline-text-5" id="text-orge931b30">
<p>
最容易并行的算法，是诸如 std::for_each 这样的简单算法，它会对一个数据集中每个元素执行一个操作。为了让算法并行，你可以把每个元素指派到其中一个处理线程。如何划分才能获得最佳的性能，取决于数据结构实现的细节，你将在本章后面当我们着手性能问题的时候看到。<br />
</p>

<p>
最简单的数据分配方法是第一组 N 个元素分配一个线程，下一组 N 个元素再分配一个线程，以此类推，如图 8.1 所示，但也可以使用其他分配模式。不管数据怎么分，每个线程都会对分配给它的元素进行操作，不会和其他线程通信，直到处理完成。<br />
</p>


<div id="org922a7e9" class="figure">
<p><img src="./AsynchronousProgramming/08_01_01_divide_data_01.jpg" alt="08_01_01_divide_data_01.jpg" /><br />
</p>
</div>

<p>
使用过消息传递接口 (MPI, Message Passing Interface，<a href="http://www.mpi-forum.org/">http://www.mpi-forum.org/</a>)或者 OpenMP(<a href="http://www.openmp.org/">http://www.openmp.org/</a>)框架的人对这个结构一定很熟悉：一个任务被分割成多个并发任务，工作线程独立的运行这些任务，结果会在一个最终的归约（reduction）步骤组合起来。这是在 2.4 节中的 accumulate 例子中使用过的方法；这个例子中，所有并行任务和最终的归约步骤都是累加操作。对于简单的 for_each 来说，最终的步骤是个空操作，因为没有结果需要归约。<br />
</p>

<p>
把最后一步认定为归约是十分重要的；像清单 2.9 中那种初级的实现，会把归约当成一个最终串行的步骤来执行。但这一步通常也能并行化；accumulate 是一个归约操作，所以清单 2.9 能被改为，当线程数量大于一个线程上最小处理项数时，递归调用自身。或者，工作线程在完成它自己的任务时执行一些归约步骤而不是每次都生成新的线程。<br />
</p>

<p>
虽然这个技术很强大，但并不适用于所有情况。有时候数据不能预先的整齐地划分，因为只有对数据进行处理后，才能进行明确的划分。像快速排序这种递归算法尤其明显；因此它们需要一种不同的方法。<br />
</p>

<ul class="org-ul">
<li>归约 <a href="https://baike.baidu.com/item/%E5%BD%92%E7%BA%A6/3479602">https://baike.baidu.com/item/%E5%BD%92%E7%BA%A6/3479602</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org87862dc" class="outline-5">
<h5 id="org87862dc">8.1.2 Dividing data recursively (277)</h5>
<div class="outline-text-5" id="text-org87862dc">
<p>
快速排序算法有两个基本的步骤：将数据按照最终排序顺序划分为主元之前或之后的两半，然后递归的对这两半排序。这里不能通过预先对数据划分来并行，因为只有在处理后才知道要分到哪一半。如果要对这种算法进行并行化，你需要利用递归的性质。每一级的递归都会多次调用 quick_sort 函数，因为必须对主元前后的元素都要排序。这些递归调用是完全独立的，因为它访问的是不同的数据集，所以是并发执行的首选。图 8.2 展示了这样的递归划分。<br />
</p>


<div id="org37b9640" class="figure">
<p><img src="./AsynchronousProgramming/08_01_02_divide_data_01.jpg" alt="08_01_02_divide_data_01.jpg" /><br />
</p>
</div>

<p>
第 4 章中已经见过这种实现，当时没有对较大值数据块和较小值数据块执行两个递归的调用，而是使用 std::async()在每个阶段生成较小值数据块的异步任务。通过使用 std::async()，你让 C++线程库决定何时在一个新线程上执行任务（何时在当前线程执行任务)，以及何时同步地执行任务（何时延迟执行）。<br />
</p>

<p>
这很重要：如果你对一个很大的数据集进行排序时，每次递归都产生一个新线程，会导致产生大量的线程。当我们考察性能的时候你将看到，如果有太多的线程存在，可能会拖慢应用程序。如果数据集过于庞大，也可能耗尽线程。像这样用递归的方式划分全局任务是个不错的主意；你只需要看紧线程的数量。std::async()可以处理这种简单的情况，但它不是唯一选择。<br />
</p>

<p>
另一种选择是使用 std::thread::hardware_concurrency()函数来确定线程的数量，就像清单 2.9 中并行版 accumulate()一样。然后，不为递归调用启动一个新线程，而是，将需要排序的数据块推到线程安全的栈上，如第 6、7 章中的栈。如果一个线程无所事事，要么是已经完成了对自己数据块的处理，要么是在等待一个需要排序的数据块；它可以从栈上取一个数据块，并对其排序。<br />
</p>

<p>
下面的清单展示了使用这种技术的示例实现。与大多数示例一样，只是为了演示想法，而不是产品级代码。如果你使用的是 C++17 编译器并且库支持的话，你最好使用标准库提供的并行算法，第 10 章会覆盖这个话题。<br />
</p>

<p>
清单 8.1 使用待排序数据块栈的并行快速排序<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">sorter</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
{
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">chunk_to_sort</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">data</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">promise</span>;
    };

    <span style="color: #ce537a; font-weight: bold;">thread_safe_stack</span>&lt;<span style="color: #ce537a; font-weight: bold;">chunk_to_sort</span>&gt; <span style="color: #7590db;">chunks</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_thread_count</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">end_of_data</span>;

    <span style="color: #bc6ec5; font-weight: bold;">sorter</span>(): max_thread_count(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency()-1), end_of_data(<span style="color: #a45bad;">false</span>) {}

    ~<span style="color: #bc6ec5; font-weight: bold;">sorter</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    {
        end_of_data=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>

        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;threads.size();++i)
        {
            threads[i].join();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        }
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">try_sort_chunk</span>()
    {
        <span style="color: #a45bad;">boost</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">chunk_to_sort</span> &gt; <span style="color: #7590db;">chunk</span>=chunks.pop();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(chunk)
        {
            sort_chunk(chunk);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
        }
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">do_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;&amp; <span style="color: #7590db;">chunk_data</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(chunk_data.empty())
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> chunk_data;
        }

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">result</span>;
        result.splice(result.begin(),chunk_data,chunk_data.begin());
        <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">partition_val</span>=*result.begin();

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
        <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;::<span style="color: #ce537a; font-weight: bold;">iterator</span> <span style="color: #7590db;">divide_point</span>=<span style="color: #a45bad;">std</span>::partition(chunk_data.begin(),
                                        chunk_data.end(),
                                        [&amp;](<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">val</span>){<span style="color: #4f97d7; font-weight: bold;">return</span> val&lt;partition_val;});

        <span style="color: #ce537a; font-weight: bold;">chunk_to_sort</span> <span style="color: #7590db;">new_lower_chunk</span>;
        new_lower_chunk.data.splice(new_lower_chunk.data.end(),
                                    chunk_data,chunk_data.begin(),
                                    divide_point);

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">new_lower</span>= new_lower_chunk.promise.get_future();
        chunks.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_lower_chunk</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(threads.size()&lt;max_thread_count)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
        {
            threads.push_back(<span style="color: #a45bad;">std</span>::thread(&amp;<span style="color: #a45bad;">sorter</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;::sort_thread,<span style="color: #4f97d7; font-weight: bold;">this</span>));
        }

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_higher</span>(do_sort(chunk_data));

        result.splice(result.end(),new_higher);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(new_lower.wait_for(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::seconds(0))!=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">future_status</span>::ready)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">13</span>
        {
            try_sort_chunk();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">14</span>
        }

        result.splice(result.begin(),new_lower.get());
        <span style="color: #4f97d7; font-weight: bold;">return</span> result;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort_chunk</span>(<span style="color: #a45bad;">boost</span>::<span style="color: #ce537a; font-weight: bold;">shared_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">chunk_to_sort</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">chunk</span>)
    {
        chunk-&gt;promise.set_value(do_sort(chunk-&gt;data));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort_thread</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>end_of_data)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">16</span>
        {
            try_sort_chunk();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">17</span>
            <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">18</span>
        }
    }
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">parallel_quick_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">input</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">19</span>
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(input.empty())
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> input;
    }
    <span style="color: #ce537a; font-weight: bold;">sorter</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">s</span>;

    <span style="color: #4f97d7; font-weight: bold;">return</span> s.do_sort(input);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">20</span>
}
</pre>
</div>
<p>
这里，parallel_quick_sort 函数⑲委托了大部分功能给 sorter 类①，这个类提供了简单的方法来组织栈上没有排序的数据块②，以及线程集③。主要的工作在 do_sort 成员函数完成⑨，它对数据做了分割⑩。这次没有对每一个数据块产生一个新的线程，而是把数据块推入栈上⑪；并在仍然有多余处理器⑫的时候，才生成新的线程。因为较小值数据块可能被另一个线程处理，于是必须等待它就绪⑬。为了让事情顺利完成(当只有一个线程或其他所有线程都在忙碌的时候)，当你等待的时候⑭，你会尝试在当前线程处理栈上的数据。try_sort_chunk 从栈上弹出一个数据块⑦，并对它排序⑧，存储结果到 promise 中，准备好被另一个线程取回(该取回线程就是将这个数据块数据块发布到栈上的线程)⑮。<br />
</p>

<p>
当 end_of_data 没有被设置时⑯，新生成的线程位于一个循环中尝试排序栈上的数据块⑰。在检查间隙，它们会出让出执行权给其他线程⑱，以便给它们机会将更多的工作放入栈中，这里的代码依赖于 sorter 类④的析构函数来清理这些线程。当所有数据都排好序，do_sort 将会返回(即使工作线程仍在运行)，这样主线程将会从 parallel_quick_sort⑳中返回，接着销毁 sorter 对象。sorter 的析构函数会设置 end_of_data 标记⑤，并等待所有线程结束⑥。设置标记会终止线程函数的循环⑯。<br />
</p>

<p>
使用这个方案，不用为 spawn_task 产生不受限制的线程所困扰，也不用再依赖 C++线程库来为你选择线程的数量（就像 std::async()所做的那样）。相反这里通过 std::thread::hardware_concurrency()的值限制线程的数量，这样就能避免过度的任务切换。然而，有另一个潜在的问题：线程管理和线程间通讯给代码增加了很多复杂性。同样，尽管线程处理独立的数据元素，但它们都要访问栈来添加数据块或者弹出数据块。这个严重的竞争会降低性能，即使你使用无锁栈（因此是非阻塞），原因很快会看到。<br />
</p>

<p>
这种方法是一个特化版本的线程池（thread pool）——一系列线程从一个待处理工作的列表获取工作，完成工作，然后回到列表获取更多任务。线程池的一些潜在问题(包括对工作列表的竞争)以及解决方法将在第 9 章介绍。将应用程序扩展到多处理器的问题将在本章后面更详细地讨论(详见 8.2.1)。<br />
</p>

<p>
在考察划分数据的方法时，不管是处理前划分数据还是递归划分都需要事先保证数据本身是固定的。但情况并非总是如此；如果数据是动态生成，或是来自外部输入，这些方法就没法工作了。这种情况下，基于任务类型的划分方式比基于数据的划分方式更有意义。<br />
</p>
</div>
</div>
<div id="outline-container-org6b48fd0" class="outline-5">
<h5 id="org6b48fd0">8.1.3 Dividing work by task type (281)</h5>
<div class="outline-text-5" id="text-org6b48fd0">
<p>
在线程间通过分配不同的数据块给每个线程(不管提前划分还是递归划分)来划分工作仍然停留在一个假设：线程在每个数据块上做相同的工作。另一种划分工作的方法是让线程做专门的工作，也就是每个线程执行不同的任务，就像水管工和电工在建造一所屋子的时候执行不同的任务。线程可能会也可能不会工作在相同的数据上，即便是相同的数据，那也是为了不同的目的。<br />
</p>

<p>
这种分工起因于使用并发分离关注点；每个线程都有不同的任务，其独立于其他线程执行。其他线程偶尔会向某个线程传递数据，或是触发事件让它处理；不过通常，每个线程只专注做好一件事情。就其本身而言，这是良好的设计：每段代码都应该有单一的职责。<br />
</p>
</div>
<div id="outline-container-org353c95f" class="outline-6">
<h6 id="org353c95f">DIVIDING WORK BY TASK TYPE TO SEPARATE CONCERNS</h6>
<div class="outline-text-6" id="text-org353c95f">
<p>
在有多个任务需要持续运行一段时间的地方，或在需要及时处理到来的事件(比如用户按键或进来的网络数据)的地方（甚至当其他任务还在运行的时候），单线程应用程序必须处理与单一职责原则的冲突。在单线程的世界中，你最终需要手工编写代码执行一点 A 任务，执行一点 B 任务，检查按键，检查进来的网络包，然后再循环回去，执行另一点任务 A。这将会使得任务 A 复杂化，因为需要存储它的状态，并且定期返回控制到主线程。如果你添加太多的任务到循环，程序将会慢很多；并且用户可能会发现需要很长时间才会响应按键。我确定你已经见过以这种极端形式运转的应用程序：你让它完成一些任务，然后发现界面冻结了，直到任务完成。<br />
</p>

<p>
这就是线程大显身手的地方。如果你让每个任务运行在独立的线程，剩下的操作系统会帮你处理好。在任务 A 的代码中，你可以专注于执行任务，而不用在执行之前担心需要保存状态再返回到主循环也不用在执行任务之前考虑执行任务需要花费多长时间。操作系统会自动保存状态，并且在合适的时候切换到任务 B 或 C。如果目标系统有多核或多处理器，任务 A 和任务 B 很可能真正的并发运行。处理按键或网络包的代码也能及时运行。这是个多赢的局面：用户得到了及时的响应；而作为开发者的你，可以使用更简单的代码，因为每个线程可以专注于和它职责直接相关的操作，而不用将控制分支和用户交互混杂在一起。<br />
</p>

<p>
这听起来令人心驰神往。真的是那样吗？一切取决于细节。如果每个任务都是独立的，并且线程间不需要互相通信，那还真就这么简单。不幸的是，现实总是残酷的。后台那些优雅的任务经常做一些用户请求的事情，并且当它们完成的时候，需要以某种方式更新用户界面，从而让用户知晓。或者，用户可能想要取消任务，就需要用户界面以某种方式发送一条消息给后台任务，让它停止运行。这两种情况都需要认真考虑、设计、以及适当的同步，但关注点仍然是分离的。用户界面线程还是处理用户界面，但当其他线程请求它要做什么的时候，用户界面线程需要更新用户界面。同样，运行后台任务的线程仍然关注该任务所需的操作；只是碰巧其中的一个是“允许任务被另一个线程停止”。无论哪种情况，后台线程都不关心请求来自哪里，它们只关注那种本来就是给它们或者和它们责任直接相关的请求。<br />
</p>

<p>
多线程下分离关注点有两大危险。第一个是分离了错误的关注点。要检查的症状是线程之间共享了大量数据，或者不同的线程最终相互等待，这两种情况都归结为线程间有太多通信。如果发生这种情况，那就值得考虑一下需要这么多通信的原因。如果所有的通信都和同一个问题相关，很可能它应该是单个线程的核心职责，因此需要把它从所有引用它的线程中抽出来。或者如果两个线程相互频繁通信，但跟其他线程又不怎么通信的话，也许它们应该合并成一个线程。<br />
</p>

<p>
当按任务类型跨线程划分工作时，没必要完全隔离。 如果多组输入数据需要应用相同的操作序列，您可以划分工作，以便每个线程执行整个序列中的一个阶段。<br />
</p>
</div>
</div>
<div id="outline-container-org3f5041a" class="outline-6">
<h6 id="org3f5041a">DIVIDING A SEQUENCE OF TASKS BETWEEN THREADS</h6>
<div class="outline-text-6" id="text-org3f5041a">
<p>
如果任务会应用相同操作序列到许多独立的数据项，就可以使用流水线(pipeline)来利用系统的可用并发。好比一个物理管道：数据流从管道一端进入，进行一系列操作后，从管道另一端出去。<br />
</p>

<p>
使用这种方式划分工作，可以为流水线中的每一阶段创建一个独立的线程——序列上的每个操作对应一个线程。当操作完成，数据元素会放入一个队列中，以供下一阶段的线程拾取。这就允许当流水线上的第二个线程正在处理第一个元素时，执行序列中第一个操作的线程开始处理下一个数据元素。<br />
</p>

<p>
这就是 8.1.1 节描述的线程间划分数据的一种替代方案，这种方式适合于当操作启动后，对输入数据本身知之甚少的情况。例如，数据可能来自网络，或者序列中的第一个操作可能是通过扫描文件系统来确定要处理的文件。<br />
</p>

<p>
流水线对于序列中每个操作都很耗时的情况也很适合；通过在线程间划分任务而不是数据，你会改变性能表现。假设有 20 个数据项，在 4 个核上处理，并且每一个数据项需要 4 个步骤，每一步需要 3 秒来完成。如果在四个线程间划分数据，那么每个线程上就有五个数据项要处理。假设没有其他的处理会影响计时，在 12 秒后有 4 个数据项处理完成，24 秒后 8 个数据项处理完成，以此类推。所有 20 个数据项将在 1 分钟后完成。如果使用流水线，事情就不一样了，四步中的每一步可以交给一个处理核，现在第一个数据项需要被每一个核处理，所以它仍然会消耗全部的 12 秒。确实，在 12 秒后你只得到一个处理过的数据项，这还不如数据划分。不过，一旦流水线装填好了，事情的进展就有点不同；在第一个核处理了第一个数据项后，数据项就会交给下一个核，所以一旦最后那个核处理了第一个数据项后，它可以对第二个数据项进行处理。现在每 3 秒就可以得到一个已处理的数据项，而不是每隔 12 秒完成 4 个数据项。<br />
</p>

<p>
现在整批处理的总时间更长了，这是因为最后一个核在开始处理第一个元素时，需要等待 9 秒。但在某些情况下，更平滑、更规律的处理是有益的。例如，考虑一个观看高清数字视频的系统。为了让视频可以观看，至少要保证每秒 25 帧，当然越多越好。另外，这些帧需要均匀分布，才能给观看者留有连续播放的印象；如果要暂停一秒的话，然后播放 100 帧，接着暂停另一秒，再播放另外 100 帧，那么应用程序即使可以每秒解码 100 帧仍然没什么用。另一方面，观看者乐于接受在开始观看视频的时候延迟几秒。这种情况下，并行使用流水线以稳定的速率输出帧更可取。<br />
</p>

<p>
在了解了各种多线程间划分工作的技术后，让我们来看一下哪些因素会影响多线程系统的性能，以及这些因素是如何影响技术选型的。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8030472" class="outline-4">
<h4 id="org8030472">8.2 Factors affecting the performance of concurrent code (283)</h4>
<div class="outline-text-4" id="text-org8030472">
<p>
在多处理器系统上，如果你正在使用并发提升代码的性能，你需要了解一下有哪些因素会影响性能。即使已经使用多线程来分离关注点，还需要确保它不会对性能造成负面影响。如果你的应用程序在新的 16 核机器上跑的比老式的单核机器还慢，用户肯定得骂娘。<br />
</p>

<p>
你马上就会看到，很多因素会影响多线程代码的性能——甚至修改哪些调换每个线程处理的数据元素这样简单的事情(其他条件一样)对性能都有戏剧性的影响。言归正传，让我们来看一下这些因素吧，先从明显的开始：目标系统有多少个处理器？<br />
</p>
</div>
<div id="outline-container-org14c7e1c" class="outline-5">
<h5 id="org14c7e1c">8.2.1 How many processors? (284)</h5>
<div class="outline-text-5" id="text-org14c7e1c">
<p>
处理器个数（和结构）是影响多线程应用性能的第一个重要因素，也是至关重要的一个因素。某些情况下，你确切知道目标硬件，设计的时候也会将其考虑在内，并在目标系统或等同环境中进行了实际测试。如果是这样的话，你是幸运的；一般来讲，你不会碰到这么好的情况。你可能在一个相似的系统上进行开发，但差异是至关重要的。例如，你可能会在一个双核或四核的系统上做开发，不过你用户的系统可能就只有一个多核处理器(有任意数量的核)，或多个单核处理器，或甚至是多个多核处理器。在这些不同的情况下，并发程序的行为和性能特征会有很大的不同，所以需要仔细考虑有什么影响,可能的话最好做一些测试。<br />
</p>

<p>
大体上，一个 16 核的处理器和 4 个四核或 16 个单核处理器相同：每种情况下，系统都能并发运行 16 个线程。如果你想充分利用它们，你的应用程序最少要有 16 个线程。如果不足 16 个，会有处理器处于空闲状态(除非系统同时也运行其他应用，不过我们暂时忽略这种可能性)。另一方面，当有多于 16 个线程可以运行的时候(没有阻塞或等待)，应用将会浪费处理器时间用于切换线程，如第 1 章所述。这种情况发生时，这就是所谓的超订(oversubscription)。<br />
</p>

<p>
为了允许应用程序改变线程数量从而和硬件支持的并发线程数量保持一致，C++标准线程库提供了 std::thread::hardware_concurrency()。你已经看到过如何使用这个函数来改变线程数量以匹配硬件线程数量了。<br />
</p>

<p>
直接使用 std::thread::hardware_concurrency()需要注意；因为代码不会考虑运行在系统上的其他线程，除非你显式的分享了那个信息。所以在最坏的情况下，如果同一时间多个线程同时调用一个使用 std::thread::hardware_concurrency()的函数来扩展线程数量，这将导致巨大的超订。而 std::async()就能避免这个问题，因为标准库知道所有的调用，会对它们进行适当的安排。小心的使用线程池也可以避免这个问题。<br />
</p>

<p>
不过，即使已经考虑了应用中运行的所有线程，程序还是要受制于同时运行的其他应用。尽管单用户系统中同时使用多个 CPU 密集型应用程序很少见，但在某些领域这种情况更常见。虽然应对这种场景的系统通常提供相关机制允许应用选择线程数量，但这种机制已经超出 C++标准的范围。一种选择是使用像 std::async()这样的设施，在选择线程数量的时候考虑所有应用程序运行的异步任务的总数。另一个选择是限制应用可以使用的处理器核数。在这些平台上，我会期望这种限制能反映到 std::thread::hardware_concurrency()的返回值上，尽管没有保证一定是这样的。如果你需要处理这种情况，请查阅你的系统文档看是否有什么方法可用。<br />
</p>

<p>
这种情况的另一个转折是，与处理单元的数量相比，问题的理想算法取决于问题的大小。 如果您有一个包含许多处理单元的大规模并行系统，则总体上执行更多操作的算法可能比执行较少操作的算法完成得更快，因为每个处理器只执行几个操作。<br />
</p>

<p>
随着处理器数量的增加，另一个问题的可能性和性能影响也随之增加：多个处理器试图访问相同的数据。<br />
</p>
</div>
</div>
<div id="outline-container-org9e08aad" class="outline-5">
<h5 id="org9e08aad">8.2.2 Data contention and cache ping-pong (285)</h5>
<div class="outline-text-5" id="text-org9e08aad">
<p>
当两个线程在不同处理器上并发的执行，并且读取同一数据，这通常不会出现问题；因为数据将会拷贝到每个线程的缓存中，并且两个处理器都可以继续执行。不过，如果有一个线程修改了数据，这个修改就需要传播到其他核的缓存中去，这要耗费一定的时间。取决于两个线程上操作的性质，以及操作使用的内存顺序，这个修改可能会让第二个处理器在它的处理轨迹上停下来，等待这个修改通过内存硬件传播过来。就 CPU 指令而言，尽管确切的时间主要取决于硬件的物理结构，但这可能是一个非常慢的操作，相当于数百条单独的指令。<br />
</p>

<p>
考虑下面这个简单的代码片段：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span>&gt; <span style="color: #7590db;">counter</span>(0);
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">processing_loop</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(counter.fetch_add(1,<span style="color: #a45bad;">std</span>::memory_order_relaxed)&lt;100000000)
    {
        do_something();
    }
}
</pre>
</div>
<p>
counter 是全局变量，所以任何调用 processing_loop()的线程都是修改同一个变量。因此，对每次递增操作，处理器必须确保最新的 counter 拷贝在它的缓存中，修改这个值，然后发布到其他处理器上。尽管使用 std::memory_order_relaxed，从而编译器不用同步任何数据，但 fetch_add 是一个“读-改-写”操作，其需要获取最新的值。如果另一个线程在另一个处理器上运行相同的代码，那么 counter 的数据需要在两个处理器及他们对应缓存之间来回传递，从而在 counter 执行递增操作时，每个处理器才能得到最新的 counter 值。如果 do_something()足够短，或有很多处理器运行这个代码，这些处理器可能会发现他们在互相等待；一个处理器准备更新这个值，但另一个处理器正在修改这个值，所以它必须等待，直到第二个处理器完成更新并且这个修改已经传播出来。这种情况称为高竞争(high contention)。如果处理器很少需要互相等待，你就处于低竞争(low contention)。<br />
</p>

<p>
在这样的循环中，counter 的数据将在缓存间来回传递很多次。这叫做乒乓缓存(cache ping-pong)，它将严重影响应用程序的性能。如果一个处理器因为必须等待缓存传输而停顿，在此期间它不能做任何工作，即使有其他线程在等待可以做有用的工作，所以这对整个应用程序来说是个坏消息。<br />
</p>

<p>
你可能会想，这种情况不会发生在你身上；因为你没有这种循环。你确定吗？互斥锁呢？如果需要在循环中获取一个互斥锁，那么从数据访问的角度看，你的代码和前面的代码是类似的。为了锁住互斥锁，另一个线程必须将组成互斥锁的数据转移到它所在的处理器上，然后修改它。完事之后，解锁操作将会再次对互斥锁进行修改，同时互斥锁数据将会转移到下一个获取互斥锁的线程上去。这个转移时间是在第二个线程需要等待第一个线程释放互斥锁的时间基础上额外增加的：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
<span style="color: #ce537a; font-weight: bold;">my_data</span> <span style="color: #7590db;">data</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">processing_loop_with_mutex</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(done_processing(data)) <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
}
</pre>
</div>
<p>
现在来看下最糟糕的部分：如果数据和互斥锁被多个线程访问，然后你添加更多的核和处理器到系统中，你很可能看到高竞争，以及一个处理器需要等待其他处理器的情况。如果你使用多线程来加速数据处理，线程间会对数据进行竞争，从而也会对同一个互斥锁进行竞争。线程越多，它们在同一时间尝试获取互斥锁或者访问原子变量等等的可能性也更大。<br />
</p>

<p>
互斥锁竞争的影响通常不同于原子操作竞争的影响，这是因为互斥锁是在操作系统级别而不是处理器级别将线程串行化。如果有足够的可运行线程，当某个线程在等待互斥锁时，操作系统会调度另一个线程运行，然而处理器暂停则会阻止任何线程在它上面运行。但它仍会影响这些竞争互斥锁的线程的性能；毕竟，这些线程中同一时间只能有一个线程在运行。<br />
</p>

<p>
回顾第 3 章，你已经见过一个很少被更新的数据结构可以被一个单一写者，多个读者互斥锁(详见 3.3.2 节)保护。如果工作负载不利，缓存乒乓效应会抵消此互斥锁带来的收益，因为所有访问数据的线程(即使是读者线程)仍然需要修改互斥锁本身。随着访问数据的处理器数量增加，对互斥锁的竞争就会增加，包含互斥锁的缓存行必须在核之间进行转移，这可能会将获取和释放锁所需的时间增加到不希望的水平。有些技术通过将互斥锁底层组件分散开，跨越多个缓存行来改善这个问题，但是除非你实现自己的互斥锁，否则你只能受制于系统提供什么样的实现。<br />
</p>

<p>
如果这个缓存乒乓不好，怎么避免呢？ 本章后面你看到，答案与提高并发潜力的一般准则很好地联系在一起：尽你所能减少两个线程竞争同一内存位置的可能性<br />
</p>

<p>
尽管事情没那么简单，事情从来也没简单过。即使特定内存位置总是只被一个线程所访问，可能还是会因为伪共享(false sharing)的影响而遇到乒乓缓存。<br />
</p>
</div>
</div>
<div id="outline-container-org1c855a8" class="outline-5">
<h5 id="org1c855a8">8.2.3 False sharing (287)</h5>
<div class="outline-text-5" id="text-org1c855a8">
<p>
处理器缓存通常不会和单个内存位置打交道，取而代之，打交道的对象是称为缓存行(cache lines)的内存块。这些内存块的大小通常是 32 或 64 字节，但确切的细节依赖于所使用的特定处理器模型。因为缓存硬件只和缓存行大小的内存块打交道，所以相邻内存位置上的小数据项将属于同一缓存行。有时这样是有益的：当线程要访问的一组数据是在同一缓存行中，对于应用的性能来说就要好于同一组数据分布在多个缓存行中。不过，如果在同一缓存行存储的是无关数据，并且需要被不同线程访问，这可能成为性能问题的主要原因。<br />
</p>

<p>
假设你有一个 int 类型的数组，并且有一组线程，它们分别访问数组中属于自己的条目，但访问会不断重复，其中包括更新操作。因为 int 类型的大小通常要小于一个缓存行，同一个缓存行中可以存储多个数据项。因此，即使每个线程都只访问它们自己的数组条目，缓存硬件还是会产生乒乓缓存。每次线程访问 0 号条目需要对其值进行更新时，缓存行的所有权就需要转移给执行该线程的处理器，仅仅因为负责条目 1 的线程需要更新它的数据项，缓存就需要传送到运行这个线程的处理器。缓存行是共享的，尽管没有需要共享的数据也是如此，这就是术语伪共享（false sharing）的由来。解决的办法就是构造数据，让同一线程访问的数据项在内存中紧挨着(因而更大概率在同一缓存行中)，对不同线程访问的数据在内存中尽量远离，从而大概率在不同的缓存行。本章接下来的内容中可以看到，这种思路对代码和数据设计的影响。C++17 标准在&lt;new&gt;头文件中定义了 std::hardware_destructive_interference_size，它指定了当前编译目标可能受到伪共享的最大连续字节数。如果能确保不同线程访问的两个数据间隔不小于这个字节数，就不存在伪共享。<br />
</p>

<p>
如果多线程访问同一缓存行是糟糕的，那么被单个线程访问的数据的内存布局对性能有什么样的影响呢？<br />
</p>

<ul class="org-ul">
<li>C++性能榨汁机之伪共享 <a href="https://zhuanlan.zhihu.com/p/37069591">https://zhuanlan.zhihu.com/p/37069591</a><br /></li>
</ul>
<pre class="example" id="org44fc72c">
何谓伪共享？上面我们提过CPU的缓存是以缓存行为单位进行的，即除了本身所需读写的数据之外还会缓存与该数据在同一缓存行的数据，假设缓存行大小是32字节，内存中有“abcdefgh”八个int型数据，当CPU读取“d”这个数据时，CPU会将“abcdefgh”八个int数据组成一个缓存行加入到CPU缓存中。假设计算机有两个CPU：CPU1和CPU2，CPU1只对“a”这个数据进行频繁读写，CPU2只对“b”这个数据进行频繁读写，按理说这两个CPU读写数据没有任何关联，也就不会产生任何竞争，不会有性能问题，但是由于CPU缓存是以缓存行为单位进行存取的，也是以缓存行为单位失效的，即使CPU1只更改了缓存行中“a”数据，也会导致CPU2中该缓存行完全失效，同理，CPU2对“b”的改动也会导致CPU1中该缓存行失效，由此引发了该缓存行在两个CPU之间“乒乓”，缓存行频繁失效，最终导致程序性能下降，这就是伪共享。
</pre>
</div>
</div>
<div id="outline-container-orgc4a53df" class="outline-5">
<h5 id="orgc4a53df">8.2.4 How close is your data? (288)</h5>
<div class="outline-text-5" id="text-orgc4a53df">
<p>
尽管伪共享发生的原因是一个线程所要访问的数据过于靠近另一线程访问的数据，但另一个与数据布局相关的陷阱会直接影响单线程的性能。这个问题是数据邻近度：如果被单线程访问的数据散落在内存中，那么它们很可能位于不同的缓存行上。另一方面，如果单线程访问的数据在内存中紧挨着，它们很可能位于相同的缓存行上。因此，如果数据是分散的，将有更多的缓存行从内存加载到处理器的缓存中，这会增加访问内存的延时，相比数据紧挨着的布局，性能也会降低。<br />
</p>

<p>
同样的，如果数据是分散的，给定缓存行上不仅包含当前线程需要的数据，同时包含本线程无关数据的机会也在增加。极端情况下，缓存中存储的大部分是你不想要的数据。这会浪费宝贵的缓存空间，增加处理器缓存不命中的情况，即使这个数据项曾在缓存中存在过，还是需要从主存中获取它，因为为了给其他数据项腾出空间，它已经从缓存中移除。<br />
</p>

<p>
既然这对单线程代码很重要，那我为啥要在这里提及呢？原因就是任务切换(task switching)。如果系统中的线程数量多于核的数量，每个核上将会运行多个线程。这就会增加缓存的压力，因为为了避免伪共享，不同线程需要访问不同的缓存行。因此，当处理器切换线程时，如果每个线程使用的数据散落在多个缓存行，它需要重新加载缓存行的可能性就比数据在同一个缓存行中紧挨着的情况要大。C++17 同样在头文件&lt;new&gt;中指定了一个常量 std::hardware_constructive_interference_size，它代表保证在同一缓存行上的最大连续字节数(当然这里假设首地址已经适当对齐)。如果你能将需要的数据放一起并且不多于这个字节数，就能潜在的减少缓存不命中的情况。<br />
</p>

<p>
缓存行是缓存的最小单位，下面是 CPU-Z 软件所展示的 CPU 信息，L1Data 16*32KB 表示 L1 数据缓存有 16 个缓存行，L1Inst 16*32KB 表示 L1 指令缓存有 16 个缓存行：<br />
<img src="./AsynchronousProgramming/08_02_04_cache_line.jpg" alt="08_02_04_cache_line.jpg" /><br />
</p>

<p>
如果线程数量多于核或处理器的数量，操作系统可能也会选择在某个时间片将一个线程调度到一个核上，然后在下一个时间片再安排给另一个核。因此要求将线程数据对应的缓存行从第一个核的缓存中转移到第二个核上；越多的缓存行需要转移，也就会消耗越多的时间。尽管操作系统通常会尽可能避免这种情况的发生，但它还是会发生，并且的确会影响性能。<br />
</p>

<p>
当许多线程准备运行而非等待的时候，任务切换问题相当普遍。这个问题我们之前已经接触过：超订。<br />
</p>
</div>
</div>
<div id="outline-container-org7f401b7" class="outline-5">
<h5 id="org7f401b7">8.2.5 Oversubscription and excessive task switching (289)</h5>
<div class="outline-text-5" id="text-org7f401b7">
<p>
在多线程系统中，除非你运行在大规模并行(massively parallel)硬件上，通常线程的数量要多于处理器的数量。但线程经常会花费时间来等待外部 I/O 完成，或被互斥锁阻塞，或等待条件变量等等，因此这不是问题。可以让应用程序使用额外的线程来执行有用的工作，而不是在线程等待的时候，让处理器处于闲置状态。<br />
</p>

<p>
但这也并非总是好事，如果有太多额外的线程，就可能有多于处理器数量的线程准备运行，然后操作系统就会深陷任务切换中，以确保它们都能获得公平的时间片。如第 1 章所见，这将增加任务切换的开销同时也会混合因为数据邻近度不够导致的缓存问题。当任务无节制的产生新线程，超订就会加剧，就像第 4 章的递归快速排序那样，或者在通过任务类型进行划分的地方，线程数量大于处理器数量，并且任务是计算密集型而非 I/O 密集型。<br />
</p>

<p>
如果是因为数据划分而生成太多的线程，你可以限定工作线程的数量，正如在 8.1.2 节中看到的那样。如果超订是对工作的自然划分而产生，除了选择不同的划分方式外，没有其他更好的办法来改善这个问题。那种情况下，选择一个恰当的划分需要对目标平台有更多的了解，并且也只有在性能无法接受的情况下才值得这么多，而且可以通过观察改变工作划分是否改进了性能来验证它。<br />
</p>

<p>
其他因素也会影响多线程代码的性能，例如，乒乓缓存的开销在两个单核处理器和在一个双核处理器上会非常不同，即使他们是相同的 CPU 型号和时钟频率，但这些是产生明显影响的主要因素。现在让我们看一下这些因素如何影响代码与数据结构的设计。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgac7e2cc" class="outline-4">
<h4 id="orgac7e2cc">8.3 Designing data structures for multithreaded performance (289)</h4>
<div class="outline-text-4" id="text-orgac7e2cc">
<p>
在 8.1 节中，我们了解了各种划分工作的方法；并且在 8.2 节，了解了影响代码性能的各种因素。在设计数据结构的时候，如何使用这些信息提高多线程代码的性能呢？这个问题与第 6、7 章中解决的问题不同，之前是关于如何设计能够安全并发访问的数据结构。在 8.2 节中已经看到，即使数据并未与其他线程进行共享，单线程中使用的数据布局可能会对性能产生影响。<br />
</p>

<p>
当为多线程性能而设计数据结构的时候，要记住的关键事情是竞争(contention)，伪共享(false sharing)和数据邻近度(data proximity)。所有这三个因素对于性能都有着重大的影响，并且通常可以通过改变数据布局，或者更改哪些数据元素分配给哪个线程来改善性能。首先，让我们来看一个简单的场景：线程间划分数组元素。<br />
</p>
</div>
<div id="outline-container-org7caa2fd" class="outline-5">
<h5 id="org7caa2fd">8.3.1 Dividing array elements for complex operations (290)</h5>
<div class="outline-text-5" id="text-org7caa2fd">
<p>
假设你正在做一些繁重的数学运算，需要将两个大的方阵相乘。要将矩阵相乘，需要将第一个矩阵第一行的每个元素与第二个矩阵第一列的相应元素相乘，然后将乘积相加，得到结果的左上角元素。然后，重复此操作，第二行和第一列，以产生结果的第一列上的第二个元素，第一行和第二列，以产生结果的第二列的第一个元素，以此类推。如图 8.3 所示，高亮展示的是第一个矩阵的第二行与第二个矩阵的第三列产生结果的第二行第三列条目的过程。<br />
</p>


<div id="org9ef08c5" class="figure">
<p><img src="./AsynchronousProgramming/08_03_01_matrix_mul.jpg" alt="08_03_01_matrix_mul.jpg" /><br />
</p>
</div>

<p>
现在，让我们假设这些是具有几千行和几千列的大型矩阵，以便值得使用多线程来优化乘法。通常，非稀疏矩阵在内存中可以用一个大数组来表示，第一行的所有元素后跟第二行的所有元素，以此类推。要将矩阵相乘，你需要三个这样的大数组。为了获得最佳性能，你需要仔细注意数据访问模式，特别是对第三个数组的写入。<br />
</p>

<p>
线程间划分工作有很多种方式。假设矩阵的行或列数量大于可用处理器的数量，可以让每个线程计算结果矩阵中若干列的值，或者让每个线程计算若干行的结果，甚至让每个线程计算矩阵的一个矩形子集的结果。<br />
</p>

<p>
回顾一下 8.2.3 和 8.2.4 节，从一个数组中访问连续的元素要比访问到处散落的值要好，因为这将会减少缓存的占用并减少伪共享的机会。如果让每个线程计算一组列(假设为 N 列)，它需要从第一个矩阵中读取每个值，并从第二个矩阵中读取相应列的值，但你只需要写入对应列的值。假设矩阵存储在连续的行中，这意味着你将从第一行访问 N 个元素，从第二行访问 N 个元素，以此类推(其中 N 是你所处理的列数)。因为其他线程将访问每一行的其他元素，很明显，你应该访问相邻的列，这样每一行的 N 个元素是相邻的，这样就可以最小化伪共享。如果 N 个元素所占用的空间正好是缓存行的倍数，那么就不会有伪共享，因为线程将在单独的缓存行上工作。（Tips: 修改数据才会导致缓存行失效，进而才能导致伪共享）<br />
</p>

<p>
另一方面，如果让每个线程计算一组行，那么它需要从第二个矩阵读取每个值，并从第一个矩阵的相应行读取值，但它只需要写入对应行的值。因为矩阵存储在连续的行中，你现在写入的是 N 行的所有元素。如果你再次选择相邻行，这意味着这个线程现在是唯一写这 N 行的线程；它有一个连续的内存块，不会被任何其他线程触碰。与让每个线程计算一组列相比，这可能是一种改进，因为伪共享的唯一可能是一个块的最后几个元素和下一个块的前几个元素，但是值得在目标体系结构上测定时间来确认。<br />
</p>

<p>
第三个选择怎么样——将矩阵分成矩形块？这可以看作先对列进行划分，再对行进行划分。因此，它潜在的和按列划分有相同的伪共享的问题。如果可以选择块中的列数来避免这种可能性，则从读取端进行矩形划分有一个好处：你不需要读取任何一个源矩阵的全部内容。你只需要读取与目标矩形的行和列对应的值。为了具体地看一下，考虑将两个 1000 行 1000 列的矩阵相乘。那是 1 百万个元素。如果你有 100 个处理器，这样就可以每个处理 10 行数据，也就是 10,000 个元素。但是为了计算这 10,000 个元素的结果，他们需要访问第二个矩阵的全部(100 万个元素)加上第一个矩阵中相应行的 10000 个元素，总共有 1010,000 个元素。另一方面，如果每个线程计算 100*100 个元素的块(仍然是 10,000 个元素总数)，它们需要访问第一个矩阵的 100 行(100 x 1,000 = 100,000 个元素)和第二个矩阵的 100 列(另一个 100,000)的值。这仅仅是 200,000 个元素，这将读取的元素数量减少了 5 倍。如果读取更少的元素，那么缓存不命中的几率就越小，潜在性能也越好。<br />
</p>

<p>
Tips: 上面并不是说，使用分块乘的方法来优化矩阵乘。而是依然使用原来矩阵乘法，只是每个线程计算的结果只是结果矩阵的一块，而不是一整行或一整列。<br />
下图表示了使用分块乘的方法来优化矩阵乘的原理：<br />
<img src="./AsynchronousProgramming/08_03_01_matrix_mul_block.jpg" alt="08_03_01_matrix_mul_block.jpg" /><br />
</p>

<p>
因此，最好将结果矩阵分成小的、正方形的或接近正方形的块，而不是让每个线程计算一小部分行的全部。你可以在运行时调整每个块的大小，这取决于矩阵的大小和可用的处理器数量。和以往一样，如果性能很重要，那么分析目标架构上的各种选项至关重要，同时请查阅与该领域相关的文献——如果你正在做矩阵乘法，我不认为这些是惟一的或最好的选择。<br />
</p>

<p>
你可能不是在做矩阵乘法，那这对你有什么用呢？同样的原则也适用于需要在线程间划分大数据块的任何情况：仔细查看数据访问模式的所有方面，并确定导致性能下降的潜在原因。在你的问题域中可能存在类似的情况，在这些地方改变工作的划分就可以提高性能，而不需要对基本算法做任何更改。<br />
</p>

<p>
好了，我们已经了解了数组的访问模式是如何对性能产生影响的。那其他类型的数据结构呢？<br />
</p>
</div>
</div>
<div id="outline-container-org8bda13d" class="outline-5">
<h5 id="org8bda13d">8.3.2 Data access patterns in other data structures (292)</h5>
<div class="outline-text-5" id="text-org8bda13d">
<p>
从根本上讲，当尝试优化其他数据结构的数据访问模式时，需要考虑和优化数组访问相同的问题：<br />
</p>

<ul class="org-ul">
<li>尝试调整数据在线程间的分布，这样邻近的数据就可以被同一个线程处理。<br /></li>
<li>尽量减少任何给定线程所需的数据。<br /></li>
<li>尝试确保由不同线程访问的数据之间的距离足够远，以避免伪共享，可以使用 std::hardware_destructive_interference_size 作为指导。<br /></li>
</ul>

<p>
应用到其他数据结构上并不容易。例如，除了子树之外，二叉树天生很难细分为任何单位，分解为子树可能有用也可能没用，这取决于树的平衡程度以及你需要将它划分成多少个部分。同样，树的的属性决定了其节点是动态分配的，因而位于堆的不同位置。<br />
</p>

<p>
现在，将数据放在堆的不同位置本身并不是一个特别的问题，但它确实意味着处理器必须在缓存中保存更多的东西。但这是有益的。如果多个线程需要遍历树，那么它们都需要访问树节点，但是如果树节点只包含指向该节点上保存的实际数据的指针，那么处理器只需要在需要时从内存中加载数据。如果数据被需要它的线程修改，这可以避免节点数据本身和提供树结构的数据之间伪共享的性能损失。<br />
</p>

<p>
由互斥锁保护的数据也有类似的问题。假设你有一个简单的类，包含一些数据项和一个用于保护从多线程访问数据的互斥锁。如果互斥锁和数据项在内存紧挨着，对于一个需要获取互斥锁的线程来说比较理想：它需要的数据可能已经在处理器的缓存中，因为为了修改互斥锁时，这些缓存就被加载了。不过，还有一个缺点：当第一个线程还持有锁时，如果其他线程尝试锁住互斥锁，它们需要访问互斥锁所在内存。互斥锁上锁通常实现为在互斥锁内部内存位置上的“读-改-写”原子操作，如果互斥锁已经锁住，紧接着会调用操作系统内核。这个“读-改-写”操作，可能会导致持有互斥锁的线程在缓存中持有的数据失效。就互斥锁而言，这不是个问题；该线程在解锁互斥锁之前不会触碰它。不过，如果互斥锁和线程要使用的数据共享同一缓存行时，持有互斥锁的线程将会有性能损失，因为另一个线程尝试锁住互斥锁。<br />
</p>

<p>
测试这种伪共享是否是个问题的一种方法是在数据元素之间添加大量填充，不同的线程可以并发地访问这些数据元素。例如，你可以使用下面结构体来测试互斥锁竞争问题：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">protected_data</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#20320;&#30340;&#32534;&#35793;&#22120;&#19981;&#25903;&#25345;std::hardware_destructive_interference_size&#65292;&#21487;&#20197;&#20351;&#29992;&#31867;&#20284;65536&#23383;&#33410;&#65292;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36825;&#20010;&#25968;&#23383;&#32943;&#23450;&#36229;&#36807;&#19968;&#20010;&#32531;&#23384;&#34892;</span>
    <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">padding</span>[65536];
    <span style="color: #ce537a; font-weight: bold;">my_data</span> <span style="color: #7590db;">data_to_protect</span>;
};
</pre>
</div>
<p>
可以使用下面结构体来测试数组数据中的伪共享。如果按照下面这样设计结构体能够提高性能，你就知道伪共享确实是个问题，然后你可以保留填充，也可以通过重新安排数据访问，以另一种方式消除伪共享。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">my_data</span>
{
    <span style="color: #ce537a; font-weight: bold;">data_item1</span> <span style="color: #7590db;">d1</span>;
    <span style="color: #ce537a; font-weight: bold;">data_item2</span> <span style="color: #7590db;">d2</span>;
    <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">padding</span>[<span style="color: #a45bad;">std</span>::hardware_destructive_interference_size];
};
<span style="color: #ce537a; font-weight: bold;">my_data</span> <span style="color: #7590db;">some_array</span>[256];
</pre>
</div>

<p>
当设计并发的时候，需要考虑的不只是数据访问模式，所以让我们看看其他注意事项。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org66d58dc" class="outline-4">
<h4 id="org66d58dc">8.4 Additional considerations when designing for concurrency (293)</h4>
<div class="outline-text-4" id="text-org66d58dc">
<p>
本章中我们已经了解了很多线程间划分工作的方法，影响性能的因素，以及这些因素是如何影响你选择数据访问模式和数据结构的。但是，为并发设计代码还有更多的工作要做。还需要考虑异常安全性和可扩展性等问题。如果性能随着系统中处理核数的增加而增长 (无论是降低了执行时间，还是增加吞吐量)，那这样的代码称为“可扩展”的。理想状态下，性能增长是线性的，因此一个拥有 100 个处理器的系统比一个处理器的系统好 100 倍。<br />
</p>

<p>
尽管代码即使不是可扩展的也能正常工作——例如，一个单线程应用肯定无法扩展——但异常安全是正确性问题。如果代码不是异常安全的，最终会破坏不变性，或是导致 race condition，或者你的应用可能意外终止，因为某个操作抛出了一个异常。记住这一点后，我们将首先看看异常安全问题。<br />
</p>
</div>
<div id="outline-container-org4b7e287" class="outline-5">
<h5 id="org4b7e287">8.4.1 Exception safety in parallel algorithms (294)</h5>
<div class="outline-text-5" id="text-org4b7e287">
<p>
异常安全是高质量 C++代码必须具备的，并发代码也不例外。事实上，相比串行算法，并行算法通常需要更小心地处理异常。如果一个操作在串行算法中抛出一个异常，算法只需要确保在它自己之后进行清理，以避免资源泄漏和破坏不变性，它可以欣然允许异常传播给调用者，让它们来处理。相比之下，在并行算法中，许多操作将在单独的线程上运行。这种情况下，不允许传播异常，因为异常在错误的调用栈上。如果函数在新创建的线程上带着异常退出，应用程序将终止。<br />
</p>

<p>
作为一个具体的例子，让我们回顾一下清单 2.9 中的 parallel_accumulate 函数，复制如下：<br />
</p>

<p>
<a id="org4d5c757"></a> std::accumulate 的初级并行版本(源于清单 2.9)<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">accumulate_block</span>
{
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span>&amp; <span style="color: #7590db;">result</span>)
    {
        result=<span style="color: #a45bad;">std</span>::accumulate(first,last,result);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    }
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span> init;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">results</span>(num_threads);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        threads[i]=<span style="color: #a45bad;">std</span>::thread(accumulate_block&lt;Iterator,T&gt;(),
                               block_start,block_end,<span style="color: #a45bad;">std</span>::ref(results[i]));
        block_start=block_end;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    }
    accumulate_block()(block_start,last,results[num_threads-1]);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>

    <span style="color: #a45bad;">std</span>::for_each(threads.begin(),threads.end(),
                  <span style="color: #a45bad;">std</span>::mem_fn(&amp;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::join));

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::accumulate(results.begin(),results.end(),init);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
}
</pre>
</div>
<p>
现在，让我们仔细检查并确定可以抛出异常的位置：任何调用可抛出异常的函数的地方都可以抛出异常，或者，在用户自定义类型上执行某个操作时也可能抛出异常。<br />
</p>

<p>
首先，调用了 distance②，它会在用户提供的迭代器类型上执行操作。因为还没有做任何工作，并且这是在调用线程上，所以没有问题。接下来，分配了 results③和 threads④的 vector。同样，这些都在调用线程上，并且没有做任何工作或创建任何线程，所以还是没有问题。如果 threads 的构造函数抛出异常，为 results 分配的内存就必须被清理，不过析构函数会帮你打理好一切。<br />
</p>

<p>
可以跳过 block_start⑤的初始化，因为其同样是安全的。然后来到了生成新线程的循环⑥⑦⑧。一旦在⑦处完成了第一个线程的创建，如果抛出任何异常就会有问题，因为新的 std::thread 对象的析构函数，将调用 std::terminate 来终止程序的运行。这可不是什么好地方。<br />
</p>

<p>
accumulate_block⑨的调用可能抛出异常，并产生类似的后果：线程对象将会被销毁，并且调用 std::terminate。另一方面，最终调用 std::accumulate⑩可能会抛出异常，不过不会造成什么困难，因为所有的线程在这个点已经被连接了。<br />
</p>

<p>
主线程分析完了，但还有更多地方：在新线程上调用 accumulate_block 可能会在①抛出异常。由于没有任何 catch 块，所以这个异常不会被处理，并且导致库调用 std::terminater()来终止应用程序。<br />
</p>

<p>
这里它并不是很明显，但这段代码不是异常安全的。<br />
</p>
</div>
<div id="outline-container-org242bc53" class="outline-6">
<h6 id="org242bc53">ADDING EXCEPTION SAFETY</h6>
<div class="outline-text-6" id="text-org242bc53">
<p>
好了，我们已经确定了所有可能的抛出点，并且分析了异常所带来的恶劣后果。你能做些什么呢？让我们从解决新线程上抛出异常的问题开始。<br />
</p>

<p>
在第 4 章中遇到过用于这项工作的工具。如果你仔细查看试图用新线程实现的目标，很明显，你正在尝试返回计算的结果，同时允许代码可能抛出异常。这正是 std::packaged_task 和 std::future 这对组合设计的目的。如果重新安排代码以使用 std::packaged_task，将得到以下代码。<br />
</p>

<p>
<a id="org655341a"></a> 使用 std::packaged_task 的并行版 std::accumulate<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">accumulate_block</span>
{
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::accumulate(first,last,<span style="color: #ce537a; font-weight: bold;">T</span>());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    }
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span> init;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">futures</span>(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;T(<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span>)&gt; <span style="color: #7590db;">task</span>(accumulate_block&lt;Iterator,T&gt;());
        futures[i]=task.get_future();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        threads[i]=<span style="color: #a45bad;">std</span>::thread(<span style="color: #a45bad;">std</span>::move(task),block_start,block_end);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        block_start=block_end;
    }
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">last_result</span>=accumulate_block()(block_start,last);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>

    <span style="color: #a45bad;">std</span>::for_each(threads.begin(),threads.end(),<span style="color: #a45bad;">std</span>::mem_fn(&amp;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::join));

    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">result</span>=init;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        result+=futures[i].get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
    }
    result += last_result;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>
<p>
第一个变化是 accumulate_block 的函数调用操作符现在直接返回结果，而非使用引用存储它①。由于你正在使用 std::packaged_task 和 std::future 来实现异常安全，因此也可以使用它们来传输结果。在 std::accumulate 调用中，要求显式地传递一个默认构造的 T，而不是重用提供的 result 值，不过这是个小改动。<br />
</p>

<p>
下一个变化是使用一个存储 future 的 vector 来为每个创建的线程存储一个 std::future&lt;T&gt;③，而不是使用 vector 直接存储结果值。在创建线程循环中，首先为 accumulate_block 创建一个任务④。std::packaged_task&lt;T(Iterator,Iterator)&gt;声明了一个任务，这个任务需要两个 Iterators 参数并返回 T。然后，该任务获取 future⑤，紧接着创建新的线程，传入要处理数据块的开始和结束⑥迭代器，并在新的线程上运行该任务。当任务运行时，结果将会在期望中捕获，任何抛出的异常也会捕获。<br />
</p>

<p>
因为已经使用了 futures，所以没有结果数组，因此你必须将来自最后那个块的结果存储在变量中⑦，而不是放入一个数组的槽中。同样，因为必须从 future 中获取值，现在使用基本的 for 循环比使用 std::accumulate 更简单，从提供的初始值开始⑧，并且累加每个 future 上的结果⑨。如果相关的任务抛出一个异常，这必将被期望捕捉，并且现在被 get()调用再次抛出。最后，在返回全部结果给调用者之前，加上最后一个数据块的结果⑩。<br />
</p>

<p>
这消除了一个潜在的问题：在工作线程中抛出的异常会在主线程中重新抛出。如果有多个工作线程抛出异常，则只会传播一个，不过这没什么大不了的。如果它很重要，可以使用类似 std::nested_exception 的类来捕获所有异常并抛出它来代替原来的异常。<br />
</p>

<p>
剩下的问题是，如果在生成第一个线程和连接所有线程之间抛出异常，则会导致线程泄漏。最简单的解决方案是捕获任何异常，连接仍然是 joinable()的线程，并重新抛出异常：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">try</span>
{
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... &#21644;&#20043;&#21069;&#19968;&#26679;</span>
    }
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">last_result</span>=accumulate_block()(block_start,last);
 
    <span style="color: #a45bad;">std</span>::for_each(threads.begin(),threads.end(), <span style="color: #a45bad;">std</span>::mem_fn(&amp;<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::join));
}
<span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
{
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_thread-1);++i)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(threads[i].joinable())
            thread[i].join();
    }
    <span style="color: #4f97d7; font-weight: bold;">throw</span>;
}
</pre>
</div>
<p>
现在可以了。无论代码是怎么离开块的，所有的线程都将被连接。但是 try-catch 块很丑陋，并且有重复的代码：在正常控制流和 catch 块中，你都执行了 joining 线程的操作。重复的代码很少是好事，因为它意味着有更多的地方需要更改。我们将它提取到对象的析构函数中；毕竟，这是 C++中清理资源的惯用手法。这是你的类：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">join_threads</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt;&amp; <span style="color: #7590db;">threads</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">join_threads</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt;&amp; <span style="color: #7590db;">threads_</span>): <span style="color: #bc6ec5; font-weight: bold;">threads</span>(threads_) {}
    ~<span style="color: #bc6ec5; font-weight: bold;">join_threads</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;threads.size();++i)
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span>(threads[i].joinable())
                threads[i].join();
        }
    }
};
</pre>
</div>
<p>
这和清单 2.3 中的 thread_guard 类很相似，只是它为整个线程 vector 做了扩展。代码可以简化如下：<br />
</p>

<p>
清单 8.4 异常安全的并发版 std::accumulate<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length)
        <span style="color: #4f97d7; font-weight: bold;">return</span> init;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">futures</span>(num_threads-1);
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>(threads);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;T(<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span>)&gt; <span style="color: #7590db;">task</span>(accumulate_block&lt;Iterator,T&gt;());
        futures[i]=task.get_future();
        threads[i]=<span style="color: #a45bad;">std</span>::thread(<span style="color: #a45bad;">std</span>::move(task),block_start,block_end);
        block_start=block_end;
    }
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">last_result</span>=accumulate_block()(block_start,last);
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">result</span>=init;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        result+=futures[i].get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    }
    result += last_result;
    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>
<p>
一旦创建了线程容器，就对新类创建一个实例①以在退出的时候连接所有线程。然后，可以移除显式的连接循环而无须担心，因为无论函数怎么退出，线程都会被连接。注意对 futures[i].get()②的调用将会阻塞线程，直到结果准备就绪，所以在这个点不需要显式连接线程。这和 <a href="#org4d5c757">清单 8.2</a> 中的原始代码不同：原始代码中需要连接线程，以确保 results 的 vector 被正确填充。现在不仅得到异常安全的代码，而且函数也更短，因为将连接代码抽到了新(可复用)类中。<br />
</p>
</div>
</div>
<div id="outline-container-org2fbdd24" class="outline-6">
<h6 id="org2fbdd24">EXCEPTION SAFETY WITH STD::ASYNC()</h6>
<div class="outline-text-6" id="text-org2fbdd24">
<p>
现在已经了解了，当需要显式管理线程的时候，需要为异常安全做什么。那现在让我们来看一下使用 std::async()是怎么样实现异常安全的。你已经看到了，在本例中，库负责为你管理线程，当期望就绪时，意味着创建的任何线程都已完成。关于异常安全需要注意的关键一点是，如果你在没有等待它的情况下销毁期望，future 的析构函数将等待线程完成。这巧妙地避免了泄漏线程的问题，这些线程仍然在执行并持有对数据的引用。下一个清单显示了使用 std::async()的异常安全的实现。<br />
</p>

<p>
<a id="org4e3c05c"></a> 使用 std::async()的异常安全的并行版 std::accumulate<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_chunk_size</span>=25;
    <span style="color: #4f97d7; font-weight: bold;">if</span>(length&lt;=max_chunk_size)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::accumulate(first,last,init);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">mid_point</span>=first;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Increments given iterator mid_point by length/2 elements.</span>
        <span style="color: #a45bad;">std</span>::advance(mid_point,length/2);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">first_half_result</span>= <span style="color: #a45bad;">std</span>::async(parallel_accumulate&lt;Iterator,T&gt;,
                                                     first,mid_point,init);
        <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">second_half_result</span>=parallel_accumulate(mid_point,last,T());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> first_half_result.get()+second_half_result;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
}
</pre>
</div>
<p>
这个版本使用数据的递归划分，而不是预先计算数据块的划分，但它比之前的版本简单了很多，并且仍然是异常安全的。和之前一样，首先找到序列的长度①，如果它小于最大块的大小，直接调用 std::accumulate②。如果元素的数量超出了数据块大小，就需要找到中点③，然后再生成一个异步任务来处理这一半数据④。第二半的数据直接使用递归调用来处理⑤，然后将两个块的结果加和到一起⑥。标准库能确保 std::async 调用能够充分的利用硬件线程，而不会创建大量的线程，一些“异步”调用是在 get()⑥调用中同步执行的。<br />
</p>

<p>
这里的妙处在于，它不仅可以充分利用硬件并发，而且还可以保证异常安全。如果有异常在递归调用⑤中抛出，从调用 std::async④创建的 future 将会在异常传播时销毁。这将依次等待异步任务的完成，因此避免了悬垂线程的出现。另一方面，如果异步调用抛出异常，期望会捕获它，并且对 get()⑥的调用的时候会再次抛出这个异常。<br />
</p>

<p>
在设计并发代码时，你还需要考虑哪些其他因素？让我们来看一下可扩展性 (scalability)。如果将代码移动到有更多处理器的系统中，性能有多少提升？<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org6734afd" class="outline-5">
<h5 id="org6734afd">8.4.2 Scalability and Amdahl’s law (300)</h5>
<div class="outline-text-5" id="text-org6734afd">
<p>
可扩展性其实就是确保你的应用可以利用系统中额外的处理器。一个极端是单线程应用程序完全不可扩展；即使添加了 100 个处理器到你的系统中，应用的性能也不会变化。另一个极端是像 SETI@Home（<a href="http://setiathome.ssl.berkeley.edu/">http://setiathome.ssl.berkeley.edu/</a>） 项目一样，它的设计目标是可以利用数千个额外的处理器(以用户添加个人电脑到网络中的形式)。<br />
</p>

<p>
对任意给定的多线程程序，执行有用工作的线程数量会随着程序的运行而变化。即使每个线程在它存在的整个过程中都在做有用的工作，应用程序最初可能只有一个线程，然后该线程将承担生成所有其他线程的任务。但即使是这样的情况也极不可能发生。更普遍的情况是线程经常花时间等待彼此或等待 I/O 操作完成。<br />
</p>

<p>
每当一个线程必须等待某个事件(无论这个事件是什么)，除非有另一个线程准备在处理器上取代它，否则就有一个处理器处于空闲状态，而它本来可以做一些有用的工作。<br />
</p>

<p>
一种简化的方法是将程序分为“串行”部分，其中只有一个线程在工作，以及“并行”部分，所有可用的处理器都可以同时工作。如果在有更多处理的系统上运行应用程序，“并行”部分理论上会完成的更快，因为工作可以在更多的处理器之间划分，而“串行”部分仍然是串行的。在这样一组简化的假设下，你可以评估通过增加处理器数量来获得的潜在性能增益：如果“串行”部分构成程序的一部分为 fs，那么使用 N 个处理器的性能增益 P 可以评估为:<br />
<img src="./AsynchronousProgramming/08_04_01_amdahl_law.jpg" alt="08_04_01_amdahl_law.jpg" /><br />
</p>

<p>
这就是 Amdahl 定律，当讨论并发代码性能的时候经常被引用。如果每行代码都能并行化，那么串行部分是 0，加速比就是 N。或者，如果串行部分是 1/3，即使有无限数量的处理器，也无法获得超过 3 的加速比。<br />
</p>

<p>
但这描绘了一幅天真的画面，因为任务很少能被无限地划分成等式所要求的那样，而且也很少说所有的东西都像假设的那样是 CPU 密集型的。正如你所看到的，线程在执行的时候可能会等待很多事件。<br />
</p>

<p>
Amdahl 定律比较明确的一点是，当你使用并发提高性能时，有必要查看应用程序的整体设计，以最大化并发的潜力，并确保处理器总是有有用的工作要做。如果可以减少“串行”部分的大小或减少线程等待的可能性，在有更多处理器的系统上，就可以增大获得性能提升的可能性。或者，如果你能提供更多的数据供系统处理，这样就可以让并行部分保持工作饱满，这样你就可以减少串行占比并增加性能增益，P。<br />
</p>

<p>
可扩展性是指当增加更多的处理器后，可以减少执行一个动作所需的时间，或者可以增加在给定时间内处理的数据量。有时这些是等价的(如果每个元素处理的更快，就可以处理更多的数据)，但并不总是这样。在选择划分工作的方案(为多个线程划分工作的技术方案)前，确定可扩展性的哪些方面对你很重要，哪些方面不重要，是非常重要的。<br />
</p>

<p>
在本节开头我提到过，线程并非总有有用的工作可做。有时，它们必须等待其他线程，或者等待 I/O 完成，或是等待其他事件。如果在等待期间，让系统做一些有用的事情，就可以有效的“隐藏”等待。<br />
</p>
</div>
</div>
<div id="outline-container-orgaedaaa3" class="outline-5">
<h5 id="orgaedaaa3">8.4.3 Hiding latency with multiple threads (302)</h5>
<div class="outline-text-5" id="text-orgaedaaa3">
<p>
在大多数关于多线程代码性能的讨论中，我们一直假定线程正在“全速”运行，并且当它们运行在处理器上时总是有有用的工作要做。但事实并非如此；在应用程序代码中，线程在等待时经常会阻塞。例如，他们可能正在等待 I/O 完成，等待获得一个互斥锁，等待另一个线程完成某个操作并通知一个条件变量或填充一个 future，甚至是线程直接休眠了一段时间。<br />
</p>

<p>
不论等待的理由是什么，如果只有和系统中物理单元相同数量的线程，那么线程阻塞就意味着浪费 CPU 时间。本应运行阻塞线程的处理器现在什么也不做。因此，如果知道一个线程可能会花费相当多的时间等待，那么可以通过运行一个或多个额外的线程来利用空闲的 CPU 时间。<br />
</p>

<p>
考虑一个病毒扫描程序，它使用流水线在线程间划分工作。第一个线程在文件系统中搜索要检查的文件，并将它们放入队列中。同时，另一个线程从队列中获取文件名，加载文件，之后对它们进行病毒扫描。你知道在文件系统中搜索要扫描的文件的线程肯定是 I/O 密集型操作，因此可以通过运行一个额外的扫描线程来利用“空闲”CPU 时间。然后，你将有一个文件搜索线程以及和系统中物理核或处理器数量相同的扫描线程。因为扫描线程为了扫描文件，可能还必须从磁盘读取文件的大部分内容，所以可能需要更多的扫描线程。但是在某一时刻会有太多的线程，然后系统会再次变慢，因为它会花费越来越多的时间来切换任务，如 8.2.5 节所述。<br />
</p>

<p>
和之前一样，这也是个优化，测量线程数量修改前后的性能很重要；线程的最佳数量将高度依赖于正在完成的工作的性质以及线程花费在等待上的时间百分比。<br />
</p>

<p>
根据应用程序的不同，有可能在不运行额外线程的情况下用完这些空闲的 CPU 时间。例如，如果一个线程因为等待 I/O 操作完成而阻塞，使用异步 I/O 就会比较有意义，然后当 I/O 在后台执行的时候，这个线程可以执行其他有用的工作。在其他情况下，如果一个线程等待其他线程去执行一个操作，不同于阻塞，等待线程自身可以执行那个操作，就像在第 7 章中看到的无锁队列那样。在极端情况下，如果一个线程正在等待一个任务完成，而该任务还没有被任何线程启动，那么等待的线程可能会完整地执行该任务，或者执行另一个未完成的任务。你在清单 8.1 中看到了这样一个示例，其中只要 sort 函数需要的块还没有排序，它就会反复尝试对尚未排序的块进行排序。<br />
</p>

<p>
不同于添加线程以确保所有可用的处理器都被使用，有时需要添加线程以确保外部事件能被及时处理从而提高系统的响应能力。<br />
</p>
</div>
</div>
<div id="outline-container-org724dccc" class="outline-5">
<h5 id="org724dccc">8.4.4 Improving responsiveness with concurrency (303)</h5>
<div class="outline-text-5" id="text-org724dccc">
<p>
大多数现代图形用户界面框架都是事件驱动的(event-driven)，用户通过按键或移动鼠标在用户界面上执行操作，这将产生一系列需要应用处理的事件或消息。系统本身也可能产生消息或事件。为了确保所有的事件和消息都能被正确处理，应用程序通常会有一个事件循环，看起来像这样：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
{
    <span style="color: #ce537a; font-weight: bold;">event_data</span> <span style="color: #7590db;">event</span>=get_event();
    <span style="color: #4f97d7; font-weight: bold;">if</span>(event.type==quit)
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    process(event);
}
</pre>
</div>

<p>
显然，API 中的细节会有所不同，不过结构通常是一样的：等待一个事件，对其做必要的处理，然后等待下一个事件。如果你有一个单线程的应用程序，这会使长时间运行的任务难以编写，就如 8.1.3 节所述。为了确保用户输入被及时处理，不管应用程序正在做什么，get_event()和 process()都必须以合理的频率调用。这就意味着要么任务自身被周期性的挂起，并且返回控制到事件循环中，要么必须在代码中方便的点调用 get_event()/ process()代码。这两个选项都会使任务的实现变得复杂。<br />
</p>

<p>
通过使用并发分离关注点，可以将这个冗长的任务放在一个全新的线程上，并委托一个专用的 GUI 线程来处理事件。然后，线程可以通过简单的机制进行通信，而不必以某种方式将事件处理代码与任务代码混在一起。下面的清单展示了这种分离的一个简单轮廓。<br />
</p>

<p>
<a id="orgd042326"></a> 将 GUI 线程从任务线程中分离<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">task_thread</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">task_cancelled</span>(<span style="color: #a45bad;">false</span>);

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">gui_thread</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">event_data</span> <span style="color: #7590db;">event</span>=get_event();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(event.type==quit)
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        process(event);
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">task</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>task_complete() &amp;&amp; <span style="color: #a45bad;">!</span>task_cancelled)
    {
        do_next_operation();
    }
    <span style="color: #4f97d7; font-weight: bold;">if</span>(task_cancelled)
    {
        perform_cleanup();
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        post_gui_event(task_complete);
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">process</span>(<span style="color: #ce537a; font-weight: bold;">event_data</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">event</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">switch</span>(event.type)
    {
    <span style="color: #4f97d7; font-weight: bold;">case</span> start_task:
        task_cancelled=<span style="color: #a45bad;">false</span>;
        task_thread=<span style="color: #a45bad;">std</span>::thread(task);
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">case</span> stop_task:
        task_cancelled=<span style="color: #a45bad;">true</span>;
        task_thread.join();
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">case</span> task_complete:
        task_thread.join();
        display_results();
        <span style="color: #4f97d7; font-weight: bold;">break</span>;
    <span style="color: #4f97d7; font-weight: bold;">default</span>:
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
    }
}
</pre>
</div>
<p>
通过这种方式分离关注点，用户线程总能及时响应事件，哪怕任务需要花费很长时间。在使用应用程序时，这种响应能力通常是用户体验的关键；不管什么时候执行某个特定操作（不管是什么操作），如果应用程序完全锁住的话，使用起来就会很不方便。通过提供专门的事件处理线程，GUI 可以处理 GUI 相关的消息(如调整大小或重新绘制窗口)，而不用中断耗时处理的执行，同时如果有影响长时间运行任务的消息时，仍然可以将其传递给长时间运行的任务。<br />
</p>

<p>
到目前为止，在本章中，你已经彻底了解了设计并发代码时需要考虑的问题。总的来说，这些可能非常难以应对，但是当你习惯使用你的“多线程编程帽”时，它们中的大多数将会成为你的习惯。如果这些注意事项对你来说是新的，那么希望随着你了解了它们是如何影响一些具体的多线程代码示例以后，它们会变得更加清楚明了。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org12274dd" class="outline-4">
<h4 id="org12274dd">8.5 Designing concurrent code in practice (305)</h4>
<div class="outline-text-4" id="text-org12274dd">
<p>
当为一个特殊的任务设计并发代码时，在多大程度上考虑前面描述的每个问题取决于任务。为了演示它们如何应用，我们将看看 C++标准库中三个函数的并行版本的实现。这将为你提供一个熟悉的构建基础，同时提供一个研究问题的平台。作为奖励，我们还将提供这些函数的可用实现，这些实现可用于帮助并行处理更大的任务。<br />
</p>

<p>
选择这些实现主要是为了演示特定的技术而不是做成最先进的实现；更好地利用硬件并发的更高级的实现可以在并行算法的学术文献中找到，或者在专业的多线程库中找到，比如 Intel 的线程构建块(<a href="http://threadingbuildingblocks.org/">http://threadingbuildingblocks.org/</a>)。<br />
</p>

<p>
从概念上讲，最简单的并行算法是 std::for_each 的并行版本，因此我们将从它开始。<br />
</p>
</div>
<div id="outline-container-org7d3633d" class="outline-5">
<h5 id="org7d3633d">8.5.1 A parallel implementation of std::for_each (305)</h5>
<div class="outline-text-5" id="text-org7d3633d">
<p>
std::for_each 概念上很简单：依次对某个范围中的每个元素调用用户提供的函数。并行和串行调用的最大区别是函数的调用顺序。std::for_each 用范围中的第一个元素调用函数，接着是第二个，以此类推，然而在并行实现中对每个元素的处理顺序并没有保证，并且它们可能(事实上，我们希望如此)被并发处理。<br />
</p>

<p>
为了实现这个函数的并行版本，需要把范围划分成每个线程上处理的元素集合。由于事先知道元素的数量，所以可以在处理前对数据进行划分(8.1.1 节)。我们假设这是唯一正在运行的并行任务，因此可以使用 std::thread::hardware_concurrency()来确定线程的数量。你还知道元素可以被完全独立地处理，因此可以使用连续块来避免伪共享(8.2.3 节)。<br />
</p>

<p>
这个算法概念上类似于 8.4.1 节中并行版的 std::accumulate，但不同于计算每个元素的和，这里仅仅需要应用指定的函数。尽管你可能想象这会大大简化代码，因为不需要返回结果，但如果希望传递异常给调用者，就需要使用 std::packaged_task 和 std::future 机制在线程间转移异常。这里展示一个样例实现。<br />
</p>

<p>
<a id="orgf8d372a"></a> 并行版 std::for_each<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Func</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_for_each</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">Func</span> <span style="color: #7590db;">f</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; &gt; <span style="color: #7590db;">futures</span>(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>(threads);

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>(<span style="color: #ce537a; font-weight: bold;">void</span>)&gt; <span style="color: #7590db;">task</span>(  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
            [=]()
            {
                <span style="color: #a45bad;">std</span>::for_each(block_start,block_end,f);
            });
        futures[i]=task.get_future();
        threads[i]=<span style="color: #a45bad;">std</span>::thread(<span style="color: #a45bad;">std</span>::move(task));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        block_start=block_end;
    }
    <span style="color: #a45bad;">std</span>::for_each(block_start,last,f);

    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        futures[i].get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    }
}
</pre>
</div>
<p>
代码的基本结构与清单 8.4 相同，这也并不奇怪。关键的不同在于 vector 中存储的 future 类型为 std::future&lt;void&gt;①，因为工作线程不会返回值，并且简单的 lambda 函数会在从 block_start 到 block_end 的范围上调用函数 f②。这避免了必须传入范围到线程的构造函数中③。因为工作线程不需要返回值，调用 futures[i].get()④只是提供了一种获取工作线程抛出异常的方法；如果不想传递异常，你可以忽略这个。<br />
</p>

<p>
就像 std::accumulate 的并行实现使用 std::async 可以简单代码，parallel_for_each 也可以。这个实现如下。<br />
</p>

<p>
<a id="orgfc119f5"></a> 使用 std::async 的并行版 std::for_each<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Func</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_for_each</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">Func</span> <span style="color: #7590db;">f</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;

    <span style="color: #4f97d7; font-weight: bold;">if</span>(length&lt;(2*min_per_thread))
    {
        <span style="color: #a45bad;">std</span>::for_each(first,last,f);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">mid_point</span>=first+length/2;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">first_half</span>=<span style="color: #a45bad;">std</span>::async(&amp;<span style="color: #ce537a; font-weight: bold;">parallel_for_each</span>&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">Func</span>&gt;,
                                                first,mid_point,f);
        parallel_for_each(mid_point,last,f);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        first_half.get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    }
}

</pre>
</div>
<p>
和清单 8.5 中基于 std::async 的 parallel_accumulate 一样，分割数据是运行时递归的进行而不是在执行前，因为不知道要使用多少个线程。和之前一样，在每个阶段把数据一分为二，异步执行一半②，另一半则直接执行③，直到剩下的数据太小而不值得继续划分，这种情况下遵从 std::for_each①的处理方式。同样，使用 std::async 和 std::future 的 get()成员函数④提供了异常传播语义。<br />
</p>

<p>
让我们从必须对每个元素执行相同操作的算法 (其中有几个；std::count 和 std::replace 首先浮现在脑海中)转向一个稍微复杂一点的形如 std::find 的示例。<br />
</p>
</div>
</div>
<div id="outline-container-orgdcb693a" class="outline-5">
<h5 id="orgdcb693a">8.5.2 A parallel implementation of std::find (307)</h5>
<div class="outline-text-5" id="text-orgdcb693a">
<p>
std::find 是接下来要考虑的一个有用的算法，因为它是几个不需要每个元素都处理就可以完成的算法之一。例如，如果范围中第一个元素就匹配查找标准，就没有必要检查其他元素。你很快会看到，这对性能是个重要属性，并且对设计并行实现有直接的影响。这是数据访问模式是如何影响代码设计的特定示例(8.3.2 节)。这种类型的其他算法包括 std::equal 和 std::any_of。<br />
</p>

<p>
假如你和你的搭档在阁楼上的纪念品盒子里寻找一张旧照片，如果你找到了照片，就不会让他们继续查找。相反，你应该让他们知道你找到了照片(也许通过大喊一声：“找到了!”)，这样他们就可以停止搜索，然后去干别的。由于很多算法的性质要求他们处理每一个元素，所以它们不能大喊一声“找到了！”，对 std::find 这样的算法，能够提早完成的能力是一个重要属性而不是用来挥霍的东西。因此，需要设计代码来利用它——在答案已知时以某种方式中断其他任务，这样代码就不必等待其他工作线程处理剩下的元素。<br />
</p>

<p>
如果不中断其他线程，那么串行版本可能胜过并行实现，因为一旦找到一个匹配，串行算法就可以停止查找并返回。例如，如果系统能支持四个并发线程，那么每个线程将必须检查范围中 1/4 的元素，并且初级并发实现大概会花费单线程检查每个元素所需时间的 1/4。如果匹配的元素位于第一个 1/4 范围，串行算法将首先返回，因为它不需要检查剩下的元素。<br />
</p>

<p>
中断其他线程的一种方法是使用原子变量作为标志，并在处理每个元素后检查该标志。如果设置了标志，说明其他线程中的一个已经找到了匹配，因此可以停止处理并返回。通过这种方式中断线程，你保留了不必处理每个值的属性，并且与串行版本相比，在更多的情况下提高了性能。但这样做的缺点是，原子加载可能是缓慢的操作，因此这可能会妨碍每个线程的进度。<br />
</p>

<p>
现在，对于如何返回值和如何传播异常，有两种选择。你可以使用一个 future 数组和 std::packaged_task 来传递值和异常，然后在主线程中处理结果；或者你可以使用 std::promise 直接从工作线程设置最终结果。这完全依赖于想怎么处理工作线程上的异常。如果想停止在第一个异常上(即使还没有处理所有元素)，可以使用 std::promise 同时设置值和异常。另一方面，如果希望允许其他工作线程继续查找，可以使用 std::packaged_task，存储所有的异常，然后在没有找到匹配的情况下重新抛出其中一个异常。<br />
</p>

<p>
这种情况下，我会选择 std::promise，因为它的行为和 std::find 更为接近。这里需要注意的一件事是，要搜索的元素不在提供的范围内。因此，需要等待所有线程完成，然后才能从 future 获得结果。如果你阻塞在 future 上，要是值不存在的话，你将永远等待下去。代码如下:<br />
</p>

<p>
清单 8.9 并行 find 算法实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">MatchType</span>&gt;
<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_find</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">MatchType</span> <span style="color: #7590db;">match</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">find_element</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">begin</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">end</span>, <span style="color: #ce537a; font-weight: bold;">MatchType</span> <span style="color: #7590db;">match</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>&gt;* <span style="color: #7590db;">result</span>,
                        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt;* <span style="color: #7590db;">done_flag</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">try</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">for</span>(;(begin!=end) &amp;&amp; <span style="color: #a45bad;">!</span>done_flag-&gt;load();++begin)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
                {
                    <span style="color: #4f97d7; font-weight: bold;">if</span>(*begin==match)
                    {
                        result-&gt;set_value(begin);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
                        done_flag-&gt;store(<span style="color: #a45bad;">true</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                        <span style="color: #4f97d7; font-weight: bold;">return</span>;
                    }
                }
            }
            <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">try</span>
                {
                    result-&gt;set_exception(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">current_exception</span>());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                    done_flag-&gt;store(<span style="color: #a45bad;">true</span>);
                }
                <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
                {}
            }
        }
    };

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span> last;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>&gt; <span style="color: #7590db;">result</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">done_flag</span>(<span style="color: #a45bad;">false</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);
    {  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
        <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>(threads);
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
        {
            <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
            <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
            threads[i]=<span style="color: #a45bad;">std</span>::thread(find_element(),  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
                                   block_start,block_end,match,
                                   &amp;result,&amp;done_flag);
            block_start=block_end;
        }
        find_element()(block_start,last,match,&amp;result,&amp;done_flag);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>done_flag.load())  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">13</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> last;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> result.get_future().get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">14</span>
}

</pre>
</div>
<p>
清单 8.9 中的函数主体与之前的例子相似。这次，工作由局部类 find_element①的函数调用操作符完成。这个循环遍历给定数据块中的元素，每一步都会检查标志②。如果找到了一个匹配，设置最终结果值到 promise 中③，然后在返回前设置 done_flag④。<br />
</p>

<p>
如果抛出一个异常，就会被捕获所有异常的处理器⑤捕获，并在设置 done_flag 前，尝试将异常存储在 promise 中⑥。如果 promise 已经被设置，在承诺上设置值可能会抛出一个异常，因此，你可以捕获并丢弃这里发生的任何异常⑦。<br />
</p>

<p>
这意味着，如果调用 find_element 的线程找到了一个匹配或抛出异常，所有其他线程都将看到 done_flag 标志设置并停止。如果多个线程同时找到一个匹配或抛出异常，它们将在 promise 中竞争来设置结果。不过这是一个良性 race conditions；无论哪个成功，名义上都是第一个，因此是一个可以接受的结果。<br />
</p>

<p>
回到 parallel_find 主函数本身，使用 promise⑧和标志⑨来停止搜索，它们都将与要搜索的范围一起传递给新线程⑪。主线程也使用 find_element 来搜索剩下的元素⑫。如前所述，在检查结果之前需要等待所有线程完成，因为可能没有任何匹配的元素。可以通过把线程的启动和连接代码封装在一个块中来实现这一点⑩，因此当你检查标志来查看是否找到一个匹配的时候，所有线程都已经被连接⑬。如果找到一个匹配，可以通过调用 future（该 future 从 promise 获得）的 get()来获得结果或抛出存储的异常⑭。<br />
</p>

<p>
同样，这个实现假设你将使用所有可用的硬件线程，或者你有一些其他机制来确定线程数量，以便在线程之间预先划分工作。与前面一样，你可以使用 std::async 和递归数据划分来简化你的实现，同时使用 C++标准库的自动扩展设施（std::async 可以自适应硬件可用的线程）。下面的清单显示了使用 std::async 的 parallel_find 实现。<br />
</p>

<p>
<a id="orgbc78b07"></a> 使用 std::async 实现的并行 find 算法<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">MatchType</span>&gt;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_find_impl</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">MatchType</span> <span style="color: #7590db;">match</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt;&amp; <span style="color: #7590db;">done</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">try</span>
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(length&lt;(2*min_per_thread))
        {<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            <span style="color: #4f97d7; font-weight: bold;">for</span>(;(first!=last) &amp;&amp; <span style="color: #a45bad;">!</span>done.load();++first)
            { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span>(*first==match)
                {
                    done=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                    <span style="color: #4f97d7; font-weight: bold;">return</span> first;
                }
            }
            <span style="color: #4f97d7; font-weight: bold;">return</span> last;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">mid_point</span>=first+(length/2);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>&gt; <span style="color: #7590db;">async_result</span>= <span style="color: #a45bad;">std</span>::async(&amp;<span style="color: #ce537a; font-weight: bold;">parallel_find_impl</span>&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">MatchType</span>&gt;,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
                                                           mid_point,last,match,<span style="color: #a45bad;">std</span>::ref(done));
            <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">direct_result</span>= parallel_find_impl(first,mid_point,match,done);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
            <span style="color: #4f97d7; font-weight: bold;">return</span> (direct_result==mid_point)? async_result.get():direct_result;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
    {
        done=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
        <span style="color: #4f97d7; font-weight: bold;">throw</span>;
    }
}

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">MatchType</span>&gt;
<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_find</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">MatchType</span> <span style="color: #7590db;">match</span>)
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">done</span>(<span style="color: #a45bad;">false</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> parallel_find_impl(first,last,match,done);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
}
</pre>
</div>
<p>
如果希望在找到匹配的时候提前结束，就意味着需要引入一个在所有线程之间共享的标志，以表明找到了匹配。因此，这需要传递给所有的递归调用。实现这一点最简单的方法是委托给实现函数①，它带一个额外的参数——一个 done 标志的引用，这个引用通过程序的主入口点传入⑫。<br />
</p>

<p>
核心实现沿着熟悉的路线继续进行。与这里的许多实现一样，你设置了在单个线程上处理的最小项数②；如果数据大小不足最小项数的两倍，那么直接在当前线程运行③。该算法是一个简单的循环，遍历指定的范围，直到到达范围的末尾或 done 标志被设置④。如果找到匹配项，标识 done 就会在返回前进行设置⑤。无论是因为到达列表的末尾，还是因为另一个线程设置了 done 标志，都会停止搜索，否则返回 last 以标示这里没有找到匹配⑥。<br />
</p>

<p>
如果范围可以划分，首先在使用 std::async 对范围的第二半进行搜索前⑧，找到中点⑦，然后小心使用 std::ref 来传递 done 标志的引用。同时，可以通过对范围的第一半直接执行递归调用来搜索。如果原始范围足够大的话，异步调用和直接的递归都会导致进一步的划分。<br />
</p>

<p>
如果直接搜索返回的是 mid_point，这就意味着没有找到一个匹配，所以需要从异步搜索中获取结果。如果在这一半中没有找到结果的话，结果将是 last，这是一个正确的返回值表明没有找到指定的值⑩。如果“异步”调用被推迟而不是真正的异步，它会在调用 get()的地方运行；在这些情况下，如果搜索范围的下半部分成功了，就会跳过搜索范围的上半部分。如果异步搜索在另一个线程上运行，async_result 变量的析构函数将会等待该线程完成，所以这里不会有线程泄漏。<br />
</p>

<p>
和之前一样，使用 std::async 可以给你提供异常安全和异常传播特性。如果直接递归抛出异常，future 的析构函数将确保执行异步调用的线程在函数返回之前已经结束，并且如果异步调用抛出异常，这个异常将会通过对 get()调用进行传播⑩。使用 try/catch 块环绕整个代码只是为了在异常上设置 done 标志，并确保所有线程在抛出异常时迅速终止⑪。没有它，实现仍然是正确的，但会一直搜索元素，直到每个线程都完成。<br />
</p>

<p>
这个算法的两个实现与你所见过的其他并行算法有一个相同的关键特性：不再保证 items 按照你从 std::find 获得的顺序进行处理。如果要将算法并行化，这点很重要。如果顺序很重要，就不能并发地处理元素。如果元素是独立的，这对 parallel_for_each 就无关紧要，但这意味着 parallel_find 可能会返回一个靠近范围末尾的元素，即使有一个靠近开始的匹配，如果你没有预料到的话，这可能会让你感到惊讶。<br />
</p>

<p>
好了，你已经成功的并行化 std::find 了。正如我在本节开头所述，还有其他类似的算法可以在不处理每个数据元素的情况下完成，这些算法也可以使用相同的技术。我们还将在第 9 章中进一步研究中断线程的问题。<br />
</p>

<p>
为了完成我们的三个示例，我们将从不同的方向来研究 std::partial_sum。这个算法并没有得到太多的关注，但它是一个有趣的并行算法，并突出了一些额外的设计选择。<br />
</p>
</div>
</div>
<div id="outline-container-orgebe1cd0" class="outline-5">
<h5 id="orgebe1cd0">8.5.3 A parallel implementation of std::partial_sum (313)</h5>
<div class="outline-text-5" id="text-orgebe1cd0">
<p>
std::partial_sum 会计算一个范围内的连续总数，所以每个元素都被替换为这个元素和原序列中在它之前的所有元素的和。因此序列 1，2，3，4，5，变成 1，(1+2)=3，(1+2+3)=6，(1+2+3+4)=10，(1+2+3+4+5)=15。将它并行化会很有趣，因为你不能仅仅将范围划分为块并独立计算每个块。例如，第一个元素的初始值需要添加给其他每个元素。<br />
</p>

<p>
确定范围“部分和”的一种方法是计算各个块的部分和，然后将第一个块中最后一个元素的结果值加到下一个块中的元素上，依此类推。如果有元素 1，2，3，4，5，6，7，8，9，然后把它分为三块，在第一个实例中得到{1，3，6}，{4，9，15}，{7，15，24}。然后将 6(第一块中最后一个元素的和)加到第二个块中，那么就得到{1，3，6}，{10，15，21}，{7，15，24}。然后再将第二块的最后一个元素 21 加到第三块中，然后最后一块就得到最终结果：{1，3，6}，{10，15，21}，{28，36，55}。<br />
</p>

<p>
和原始的块划分一样，前一个块的“部分和”的加法也可以并行化。如果首先更新每个块的最后一个元素，那么块中的其余元素可以由一个线程更新，而第二个线程更新下一块，依此类推。当列表中的元素比处理核多很多时，这种方法可以很好地工作，因为每个核在每个阶段都有合理数量的元素需要处理。<br />
</p>

<p>
如果有很多的处理核(与元素的数量相同或更多)，这种方式就工作的不是很好。如果将工作分配给多个处理器，那么在第一步你将以成对的元素来完成工作。在这些条件下，结果的正向传播意味着有许多处理器等待，因此需要为它们找一些工作去做。当然你可以采取不同的方法来解决这个问题。你可以进行部分传播，而不是从一个数据块到下一个数据块进行完整的前向传播：首先像之前一样对相邻的元素求和，然后将这些和加到两个元素之外，然后将下一组结果加到四个元素之外的结果，以此类推。如果你从相同的初始 9 个元素开始（1，2，3，4，5，6，7，8，9），在第一轮之后你得到 1，3，5，7，9，11，13，15，17，这将给你前两个元素的最终结果，第二轮后得到 1，3，6，10，14，18, 22，26，30，这对前四个元素是正确的。第三轮后得到 1, 3, 6, 10, 15, 21, 28, 36, 44，这对前八个元素是正确的。第四轮后得到 1, 3, 6, 10, 15, 21, 28, 36, 45，这就是最终的结果。虽然总步骤比第一种方法多，但如果有很多处理器，并行的空间就更大；每个处理器可以每个步骤更新一个条目。整个处理流程如下图所示：<br />
</p>


<div id="org14696e6" class="figure">
<p><img src="./AsynchronousProgramming/08_05_03_partial_sum.jpg" alt="08_05_03_partial_sum.jpg" /><br />
</p>
</div>

<p>
总的来说，第二种方法需要 log2(N)步，每步大约进行 N 次操作(每个处理器执行一次操作)，其中 N 是列表中元素的数量。这与第一个算法相比，在第一个算法中，每个线程必须对分配给它的块的初始“部分和”执行 N/k 个操作，然后进一步 N/k 个操作来进行前向传播，其中 k 是线程数。因此，从总的操作数量来讲，第一种方法的时间复杂度为 O(N)，而第二种方法的时间复杂度为 O(Nlog(N))。但是如果列表元素的数量和处理器数量一样，第二种方法只需要每个处理器执行 log(N)个操作，而第一种方法由于前向传播，在 k 变大时会串行化操作。对于少量的处理单元，第一种方法将因此完成得更快，而对于大规模并行系统，第二种方法将完成得更快。这是 8.2.1 节中讨论的问题的一个极端例子。<br />
</p>

<p>
不管怎样，先不考虑效率问题，让我们来看一些代码。下面的清单显示了第一种方法。<br />
</p>

<p>
清单 8.11 通过划分问题来并行计算部分和<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_partial_sum</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">Iterator</span>::<span style="color: #ce537a; font-weight: bold;">value_type</span> <span style="color: #ce537a; font-weight: bold;">value_type</span>;
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">process_chunk</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">begin</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt;* <span style="color: #7590db;">previous_end_value</span>,
                        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt;* <span style="color: #7590db;">end_value</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">try</span>
            {
                <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">end</span>=last;
                ++end;
                <span style="color: #a45bad;">std</span>::partial_sum(begin,end,begin);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
                <span style="color: #4f97d7; font-weight: bold;">if</span>(previous_end_value)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
                {
                    <span style="color: #ce537a; font-weight: bold;">value_type</span>&amp; <span style="color: #7590db;">addend</span>=previous_end_value-&gt;get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                    *last+=addend;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                    <span style="color: #4f97d7; font-weight: bold;">if</span>(end_value)
                    {
                        end_value-&gt;set_value(*last);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                    }
                    <span style="color: #a45bad;">std</span>::for_each(begin,last,[<span style="color: #a45bad;">addend</span>](<span style="color: #ce537a; font-weight: bold;">value_type</span>&amp; <span style="color: #7590db;">item</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
                    {
                        item+=addend;
                    });
                }
                <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(end_value)
                {
                    end_value-&gt;set_value(*last);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
                }
            }
            <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">if</span>(end_value)
                {
                    end_value-&gt;set_exception(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">current_exception</span>());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
                }
                <span style="color: #4f97d7; font-weight: bold;">else</span>
                {
                    <span style="color: #4f97d7; font-weight: bold;">throw</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
                }
            }
        }
    };

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);

    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span> last;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">min_per_thread</span>=25;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">max_threads</span>=(length+min_per_thread-1)/min_per_thread;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">hardware_threads</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_threads</span>=<span style="color: #a45bad;">std</span>::min(hardware_threads!=0?hardware_threads:2,max_threads);
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=length/num_threads;

    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">Iterator</span>::<span style="color: #ce537a; font-weight: bold;">value_type</span> <span style="color: #ce537a; font-weight: bold;">value_type</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">13</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt;&gt; <span style="color: #7590db;">end_values</span>(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">14</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt;&gt; <span style="color: #7590db;">previous_end_values</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">15</span>
    previous_end_values.reserve(num_threads-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">16</span>
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>(threads);

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_threads-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_last</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_last,block_size-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">17</span>
        threads[i]=<span style="color: #a45bad;">std</span>::thread(process_chunk(),  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">18</span>
                               block_start,block_last,
                               (i!=0)?&amp;previous_end_values[i-1]:0,
                               &amp;end_values[i]);
        block_start=block_last;
        ++block_start;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">19</span>
        previous_end_values.push_back(end_values[i].get_future());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">20</span>
    }
    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">final_element</span>=block_start;
    <span style="color: #a45bad;">std</span>::advance(final_element,<span style="color: #a45bad;">std</span>::distance(block_start,last)-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">21</span>
    process_chunk()(block_start,final_element,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">22</span>
                    (num_threads&gt;1)?&amp;previous_end_values.back():0,
                    0);
}

</pre>
</div>
<p>
在本例中，大体结构与前面的算法相同：将问题划分为块，每个线程有最小的块大小⑫。本例中，除了线程的 vector 外⑬，还有 promise 的 vector⑭，用来存储块中的最后一个元素的值，以及一个 future 的 vector⑮，用于检索前一个块的最后一个值。可以为 future 提前预留空间⑯以避免生成新线程时，再分配内存，因为你明确知道会有多少个期望。<br />
</p>

<p>
主循环和之前一样，不过这次是让迭代器指向了每个数据块的最后一个元素，而不是通常的最后一个元素后面的一个位置⑰，这样就可以对每个范围内的最后一个元素进行前向传播。处理是在 process_chunk 函数对象中完成的，我们很快就会看到；该块的开始迭代器和结束迭代器作为参数传入，同时传入前一个范围的结尾值的 future(如果有的话)以及保存该范围的结尾值的 promise⑱。<br />
</p>

<p>
在生成线程之后，可以更新块的起始迭代器，注意记得将它前进到最后一个元素之后⑲，并将当前块中最后一个值的期望存储到期望的 vector 中，这样在下一次循环中它将被捡起⑳。<br />
</p>

<p>
处理最后一个数据块前，需要获取最后一个元素的迭代器㉑，这样就可以将其作为参数传入 process_chunk 中㉒。std::partial_sum 不会返回一个值，所以一旦最后一个数据块被处理后，不需要做任何事情。一旦所有线程的操作完成，操作就算完成了。<br />
</p>

<p>
好了，现在来看一下 process_chunk 函数对象①，它完成了所有的工作。首先为整个块调用 std::partial_sum，包括最后一个元素②，不过接着需要知道当前块是否是第一块③。如果不是第一块，就会有一个来自前面块的 previous_end_value 值，所以需要等待这个值④。为了让算法的并行最大化，首先更新最后一个元素⑤，这样就能将这个值传递给下一个数据块(如果有下一个数据块的话)⑥。一旦完成最后一个元素的处理，就可以使用 std::for_each 和简单的 lambda 函数⑦对范围内剩余的元素进行更新。<br />
</p>

<p>
如果没有 previous_end_value，那么你就是第一个数据块，所以只需要为下一个数据块更新 end_value⑧(同样，如果有下一个数据块的话——因为你可能是唯一的数据块)。<br />
</p>

<p>
最后，如果有任意一个操作抛出异常，可以将其捕获⑨，并且存储到 future 中⑩，因此，如果下一个数据块尝试获取前一个数据块的最后一个值时④，异常会传播给下一个数据块。这将传播所有的异常到最后一个数据块，因为知道此时正运行在主线程上，因此将异常重新抛出⑪。<br />
</p>

<p>
因为线程间需要同步，这段代码不适合用 std::async 重写。任务在中途等待结果可用，而可用的结果是通过其他任务的执行的到的，因此所有任务必须并发运行。<br />
</p>

<p>
在解决了基于块的前向传播方法之后，让我们看看计算范围“部分和”的第二种方法。<br />
</p>
</div>
<div id="outline-container-orgc5fde41" class="outline-6">
<h6 id="orgc5fde41">IMPLEMENTING THE INCREMENTAL PAIRWISE ALGORITHM FOR PARTIAL SUMS</h6>
<div class="outline-text-6" id="text-orgc5fde41">
<p>
第二种通过增量相加元素来计算“部分和”的方法在处理器锁步(lockstep)执行加法时效果最好。这种情况下，没有进一步同步的必要了，因为所有中间结果都直接传播到下一个需要它们的处理器上。但实践中，除了单个处理器可以同时在少量数据元素上同时执行相同指令的情况外（这就是所谓的单指令-多数据流(SIMD)指令），很少有这样的系统供使用。因此，你必须为一般情况设计代码，并在每一步显式地同步线程。<br />
</p>

<p>
一种方法是使用屏障(barrier)——一种同步机制，它会导致线程等待，直到指定数量的线程到达屏障。一旦所有的线程都到达了屏障，它们就会被解除阻塞，可以继续运行。C++ 11 线程库没有直接提供这个设施，所以必须自己设计一个。<br />
</p>

<p>
想象一下游乐场里的过山车。如果有相当数量的人在等待，游乐场的工作人员会确保在过山车离开站台之前每个座位都有人。屏障的工作原理也是一样的：你预先指定“座位”的数量，线程必须等待，直到所有的“座位”都被填满。一旦有足够的等待线程，它们都可以继续进行；屏障被重置并开始等待下一批线程。通常，这种结构是在循环中使用的，在循环中，相同的线程出现并等待下一次。这样做的目的是让线程保持步调一致，这样，一个线程就不会跑到其他线程的前面，从而打乱节奏。对于像这样的算法，如果出现这种情况将是灾难性的，因为失控的线程可能会修改其他线程仍在使用的数据或使用尚未正确更新的数据。<br />
</p>

<p>
下面的清单展示了屏障的简单实现。<br />
</p>

<p>
<a id="orgf39a9cc"></a> 简单的屏障类<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">barrier</span>
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">count</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">spaces</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">generation</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">explicit</span> <span style="color: #bc6ec5; font-weight: bold;">barrier</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">count_</span>):  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        count(count_),spaces(count),generation(0) {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">my_generation</span>=generation;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>--spaces)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        {
            spaces=count;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            ++generation;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">while</span>(generation==my_generation)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        }
    }
};
</pre>
</div>
<p>
有了这个实现，就可以用“座位”的数量构造一个屏障①，这个数量存储在 count 变量中。起初，屏障中的 spaces 与 count 相等。当每个线程等待时，spaces 的数量递减③。当它变为 0 时，spaces 会重置为 count④，并且 generation 会递增以向其他线程发出信号，它们可以继续⑤。如果 spaces 没有到达 0，线程必须等待。这个实现使用了一个简单的自旋锁⑥，根据在 wait()开头检索到的值检查 generation②。因为 generation 只会在所有线程都到达栅栏的时候更新⑤，在等待的时候调用 yield()⑦，因此等待线程不会在忙等待中占用 CPU。<br />
</p>

<p>
当我说这个实现很简单时，我是认真的：它使用了自旋等待，因此对于线程可能等待很长时间的情况并不理想，而且如果在任何时候有超过 count 的线程可以潜在地调用 wait()，它就没法工作。如果需要处理这些场景中的任何一种，则必须使用更健壮(但更复杂)的实现来代替。我也一直坚持在原子变量上的使用 sequentially consistent 的操作，因为这使事情更易思考，但你可能有机会放松一些顺序约束。这种全局同步在大规模并行架构上是昂贵的，因为保持屏障状态的缓存行必须在所有涉及的处理器之间来回穿梭(参阅 8.2.2 节中关于乒乓缓存的讨论)，因此你必须非常小心地确保这是这里的最佳选择。如果你的 C++标准库提供了 Concurrency TS 中的设施，你可以使用 std::experimental::barrier，详见第 4 章。<br />
</p>

<p>
这就是你需要的：有固定数量的线程需要在一个同步循环中运行。嗯，它几乎是固定数量的线程。你可能还记得，列表开头的项经过几个步骤后获得它们的最终值。这意味着，要么必须保持这些线程循环，直到处理完整个范围，要么需要允许屏障处理线程退出并递减 count。我选择后一个选项，因为它避免让线程做不必要的工作：一直循环直到完成最后一步。<br />
</p>

<p>
这意味着你必须将 count 更改为一个原子变量，这样就可以从多个线程更新它，而不需要外部同步。初始化保持不变，不过当重置 spaces 的时候，需要显式的对 count 进行 load()操作。这些是在 wait()前面需要的所有更改；现在需要一个新的成员函数来递减 count。让我们叫它 done_waiting()，因为调用该函数表示一个线程正在声明它已经完成了等待：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">done_waiting</span>()
{
    --count;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>--spaces)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {
        spaces=count.load();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        ++generation;
    }
}
</pre>
</div>
<p>
做的第一件事是递减 count①，这样的话，下一次重置 spaces 时，它将反映新的更少数量的等待线程。然后，需要递减 spaces 的值②。如果不这样做，其他线程将永远等待，因为 spaces 被初始化为旧的、更大的值。如果你是这批的最后一个线程，则需要重置计数器并递增 generation③，就像在 wait()里面做的那样。这里的关键区别在于，如果你是批次中的最后一个线程，则不必等待。<br />
</p>

<p>
现在可以编写“部分和”的第二种实现了。在每个步骤中，每个线程都调用屏障上的 wait()来确保线程一起完成步骤，一旦每个线程完成，它就调用屏障上的 done_waiting()来减少计数。如果和原始范围一起使用第二个缓冲区，屏障将提供所需的所有同步。在每一步中，线程从原始范围或缓冲区中读取值，并将新值写入另一边的相应元素。如果线程在一个步骤中从原始范围中读取数据，那么它们将在下一个步骤中从缓冲区中读取数据，反之亦然。这确保了不同线程的读写操作之间没有 race conditions。线程完成循环后，必须确保将正确的最终值写入原始范围。下面的清单将这一切整合在一起。<br />
</p>

<p>
清单 8.13 partial_sum 的并行实现：通过成对更新<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">barrier</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">count</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">spaces</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">unsigned</span>&gt; <span style="color: #7590db;">generation</span>;

    <span style="color: #bc6ec5; font-weight: bold;">barrier</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">count_</span>): count(count_),spaces(count_),generation(0) {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">gen</span>=generation.load();
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>--spaces)
        {
            spaces=count.load();
            ++generation;
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">while</span>(generation.load()==gen)
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
            }
        }
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">done_waiting</span>()
    {
        --count;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>--spaces)
        {
            spaces=count.load();
            ++generation;
        }
    }
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_partial_sum</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">Iterator</span>::<span style="color: #ce537a; font-weight: bold;">value_type</span> <span style="color: #ce537a; font-weight: bold;">value_type</span>;

    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">process_element</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    {
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt;&amp; <span style="color: #7590db;">buffer</span>, <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>,<span style="color: #ce537a; font-weight: bold;">barrier</span>&amp; <span style="color: #7590db;">b</span>)
        {
            <span style="color: #ce537a; font-weight: bold;">value_type</span>&amp; <span style="color: #7590db;">ith_element</span>=*(first+i);
            <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">update_source</span>=<span style="color: #a45bad;">false</span>;

            <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">step</span>=0,<span style="color: #7590db;">stride</span>=1;stride&lt;=i;++step,stride*=2)
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
                <span style="color: #ce537a; font-weight: bold;">value_type</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">source</span>=(step%2)? buffer[i]:ith_element;

                <span style="color: #ce537a; font-weight: bold;">value_type</span>&amp; <span style="color: #7590db;">dest</span>=(step%2) ? ith_element : buffer[i];
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
                <span style="color: #ce537a; font-weight: bold;">value_type</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">addend</span>=(step%2)? buffer[i-stride] : *(first+i-stride);

                dest=source+addend;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
                update_source=<span style="color: #a45bad;">!</span>(step%2);
                b.wait();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">if</span>(update_source)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            {
                ith_element=buffer[i];
            }
            b.done_waiting();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
        }
    };

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(length&lt;=1) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">value_type</span>&gt; <span style="color: #7590db;">buffer</span>(length);
    <span style="color: #ce537a; font-weight: bold;">barrier</span> <span style="color: #7590db;">b</span>(length);

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>(length-1);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>(threads);

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(length-1);++i)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
        threads[i]=<span style="color: #a45bad;">std</span>::thread(process_element(),first,last, <span style="color: #a45bad;">std</span>::ref(buffer),i,<span style="color: #a45bad;">std</span>::ref(b));
    }
    process_element()(first,last,buffer,length-1,b);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
}
</pre>
</div>
<p>
到目前为止，代码的主体结构应该很熟悉了。你有一个带有函数调用操作符(process_element)的类来完成这项工作①，它在一堆线程上运行⑨，这些线程对象存储在 vector 中⑧，同时你也从主线程调用这个函数对象⑩。这次关键的区别是，线程的数量依赖于列表中项的个数，而不是 std::thread::hardware_concurrency。正如我已经说过，除非你是在一个线程很廉价的大型并行机器上，否则这可能是个坏主意，但它展示了整体结构。使用更少的线程是可能的，只要让每个线程处理来自源范围的几个值，但总会有一个点，当线程足够少时，它比正向传播算法的效率要低。<br />
</p>

<p>
主要的工作都是在 process_element 的函数调用操作符中完成的。在每一步中，你要么从原始范围中取出第 i 个元素，要么从缓冲区中取出第 i 个元素②，并将它加到前面相隔 stride 距离对应元素的值上③，如果是从原始范围开始，就把它存储在缓冲区中，如果是从缓冲区开始，就存回到原始范围中④。然后，开始下一步之前，在屏障上等待⑤。当 stride 将你带离范围的起点时，说明你已经完成了工作，在这种情况下，如果最终结果存储在缓冲区中，你需要更新原始范围中的元素⑥。最后，你通过 done_waiting()函数告诉屏障完成等待⑦。<br />
</p>

<p>
注意这个解决方案并不是异常安全的。如果某个工作线程在 process_element 中抛出一个异常，它会终止应用程序。可以通过使用 std::promise 存储异常来处理这个问题，就像你对清单 8.9 中的 parallel_find 实现所做的那样，或者甚至使用由互斥锁保护的 std::exception_ptr。<br />
</p>

<p>
我们的三个例子到此结束。希望它们有助于明确 8.1、8.2、8.3 和 8.4 节中强调的一些设计考量，并演示了如何将这些技术应用到实际代码中。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org55328f8" class="outline-3">
<h3 id="org55328f8">09 advanced thread management</h3>
<div class="outline-text-3" id="text-org55328f8">
</div>
<div id="outline-container-org9f53db3" class="outline-4">
<h4 id="org9f53db3">本章主要内容</h4>
<div class="outline-text-4" id="text-org9f53db3">
<ul class="org-ul">
<li>线程池<br /></li>
<li>处理线程池中任务间的依赖<br /></li>
<li>为线程池中的线程窃取工作<br /></li>
<li>中断线程<br /></li>
</ul>

<p>
之前的章节中，我们通过为每个线程创建 std::thread 对象来显式的管理线程。但在某些地方，你已经看到这种方式不太可取，因为你必须管理线程对象的生命周期，根据当前的硬件和要解决的问题来确定合适的线程数量，等等诸如此类的问题。理想的场景是将代码分成可以并发执行的最小块，之后交给编译器和库，让它们以最优的性能并行执行。我们将在第 10 章中看到，有些情况可以这么做：如果你需要并行的代码可以用标准库算法的调用来表示，那么大多数情况下，你可以让库帮你搞定并发。<br />
</p>

<p>
另一个在一些例子中反复出现的主题是：你可能使用一些线程来解决问题，但某些条件达成的时候需要提前结束。这可能是因为结果已经确定，或者发生了错误，又或是用户明确的要求终止操作。无论是哪种原因，都需要给线程发送“请停止”请求，让它们放弃给它们的任务，清理相关资源，然后尽快结束。<br />
</p>

<p>
本章我们将讨论管理线程和任务的机制，让我们从自动管理线程的数量和在线程间划分任务开始。<br />
</p>
</div>
</div>
<div id="outline-container-org5abe77b" class="outline-4">
<h4 id="org5abe77b">9.1 Thread pools (324)</h4>
<div class="outline-text-4" id="text-org5abe77b">
<p>
在很多公司里，员工大部分时间是在办公室上班，但偶尔也会外出拜访客户或供应商，或是出席贸易展览或会议。尽管这些出行很有必要，并且在任何一天可能有好几个人出行，但对特定员工来说，出行的频率可能是几个月一次甚至几年一次。由于给每个员工都配一辆公车太过昂贵也不切实际，取而代之公司通常提供 car pool；car pool 中有有限数量的车来供所有员工使用。当员工需要外出时，他们就可以在合适的时间从 car pool 中预定一辆，并在返回公司的时候把车交还给别人使用。如果某天没有闲置的共用车辆，员工就得延后出行。<br />
</p>

<p>
线程池就是一种类似的想法，只不过共享的是线程而不是车。在大多数系统中，为每个可以并发的任务分配一个单独的线程是不切实际的，不过你还是想尽可能利用可用的并发。线程池就允许你达成这个目标，你可以把并发执行的任务提交到一个线程池中，也就是把它们放到待处理工作队列。工作线程从队列中取出任务,然后执行，之后又循环到线程池中获取另一个任务。<br />
</p>

<p>
构建一个线程池时，会遇到几个关键性的设计问题，比如：使用多少线程，最有效地给线程分配任务的方式，以及是否需要等待一个任务完成。本节我们将看看解决这些设计问题的一些线程池实现，让我们从最简单的线程池开始吧。<br />
</p>
</div>
<div id="outline-container-org2d32a58" class="outline-5">
<h5 id="org2d32a58">The simplest possible thread pool (324)</h5>
<div class="outline-text-5" id="text-org2d32a58">
<p>
最简单的情况下，线程池是固定数量的处理工作的工作线程(通常工作线程数量与 std::thread::hardware_concurrency()返回值相同)。当有工作可做时，可以调用函数将它放入待处理工作队列。每个工作线程都会从队列上获取工作，然后运行指定的任务，最后再回到队列获取更多的工作。最简单的线程池中，没有方法等待任务完成。如果需要等待，就需要自己管理同步。<br />
</p>

<p>
下面的清单展示了一个线程池的示例实现。<br />
</p>

<p>
清单 9.1 简单的线程池<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">thread_pool</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic_bool</span> <span style="color: #7590db;">done</span>;
    <span style="color: #ce537a; font-weight: bold;">thread_safe_queue</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">function</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt; &gt; <span style="color: #7590db;">work_queue</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">worker_thread</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">function</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt; <span style="color: #7590db;">task</span>;
            <span style="color: #4f97d7; font-weight: bold;">if</span>(work_queue.try_pop(task))  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            {
                task();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
            }
        }
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">thread_pool</span>(): done(<span style="color: #a45bad;">false</span>),joiner(threads)
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">thread_count</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>

        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;thread_count;++i)
            {
                threads.push_back(<span style="color: #a45bad;">std</span>::thread(&amp;<span style="color: #a45bad;">thread_pool</span>::worker_thread,<span style="color: #4f97d7; font-weight: bold;">this</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
        {
            done=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
            <span style="color: #4f97d7; font-weight: bold;">throw</span>;
        }
    }

    ~<span style="color: #bc6ec5; font-weight: bold;">thread_pool</span>()
    {
        done=<span style="color: #a45bad;">true</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">submit</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>)
    {
        work_queue.push(<span style="color: #a45bad;">std</span>::function&lt;<span style="color: #ce537a; font-weight: bold;">void</span>()&gt;(<span style="color: #7590db;">f</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
    }
};
</pre>
</div>
<p>
这个实现中有一个工作线程的 vector②，并且使用第 6 章中的线程安全队列①来管理工作队列。这里用户没法等待任务，并且它们也没法返回任何值，所以可以使用 std::function&lt;void()&gt;对任务进行封装。submit()会将任何函数或可调用对象包装成一个 std::function&lt;void()&gt;实例，并将其推入到队列中⑫。<br />
</p>

<p>
线程在构造函数中启动：使用 std::thread::hardware_concurrency()来获取硬件支持多少个并发线程⑧，然后创建这么多数量的线程运行 worker_thread()成员函数⑨。<br />
</p>

<p>
当有异常抛出时，线程启动就会失败，所以你需要保证任何已启动的线程都能停止，并正确的清理。当有异常抛出时，这是通过 try-catch 块设置 done 标志来实现的⑩，配套还有来自于第 8 章的 join_threads 类实例③来连接所有线程。这也适用于析构函数：析构函数设置 done 标志⑪，并且 join_threads 确保所有线程在线程池销毁前全部执行完成。注意成员声明的顺序很重要：done 标志和 worker_queue 必须在 threads vector 之前声明，而数组必须在 joiner 前声明。这就能确保成员以正确的顺序销毁；例如，所有线程都停止运行时，队列就可以安全的销毁。<br />
</p>

<p>
worker_thread 函数本身很简单：它一直循环直到 done 标志被设置④,不断从队列上拉取任务⑤，同时执行它们⑥。如果任务队列上没有任务，函数会调用 std::this_thread::yield()让线程短暂停歇⑦，从而给予其他线程向队列上推送任务的机会。<br />
</p>

<p>
对许多用途而言，这个简单的线程池就足够了，特别当任务完全独立，并且没有返回值，也不会执行任何阻塞操作时。不过，还有很多情况下这样简单的线程池无法满足你的需求，还有些地方可能会出现诸如死锁的问题。同样，在简单情况下使用 std::async 是个更好的选择，就像第 8 章中的例子。贯穿本章，我们将研究更加复杂的线程池实现，它们有额外的特性用来满足用户需求或减少潜在问题。首先，从等待已提交的任务开始说起。<br />
</p>
</div>
</div>
<div id="outline-container-org52bb67b" class="outline-5">
<h5 id="org52bb67b">Waiting for tasks submitted to a thread pool (326)</h5>
<div class="outline-text-5" id="text-org52bb67b">
<p>
在第 8 章的例子中，线程间的工作划分完成后，代码会显式生成新线程，主线程总是等待新线程结束，从而确保在返回调用之前所有任务都完成。使用线程池的话，需要等待提交给线程池的任务完成，而不是工作线程本身完成。这和第 8 章中基于 std::async 的例子等待 future 的方法类似，使用清单 9.1 中的简单线程池，你需要手工使用第 4 章中提到的技术：条件变量和 future，来实现等待任务结束。这虽然会增加代码的复杂度，但如果能直接等待任务线程池会更好。<br />
</p>

<p>
通过把复杂性转移到线程池本身，你就可以直接等待任务完成。你可以让 submit()函数返回某种描述的任务句柄，然后用它来等待任务的完成。任务句柄会包装条件变量或 future 的使用，从而简化使用线程池的代码。<br />
</p>

<p>
需要等待生成任务完成的一种特殊情况是主线程需要任务的计算结果。本书已经出现了多个这样的例子，比如第 2 章中的 parallel_accumulate()。这种情况下，需要用 future 来等待并获取最终结果。清单 9.2 展示了对简单线程池的修改，从而允许等待任务完成，然后从任务传递返回值给等待线程，由于 std::packaged_task&lt;&gt;实例是不可拷贝的，只能移动，所以不能把 std::function&lt;&gt;用作队列条目，因为 std::function&lt;&gt;需要存储可拷贝构造的函数对象。取而代之，需要使用一个自定义函数包装器，用来处理只可移动的类型。该自定义函数包装器是个简单的带有调用操作符的类型擦除类。由于只需要处理没有输入参也无返回值的函数，所以实现中是个简单的虚函数调用。<br />
</p>

<p>
<a id="org56ec3ff"></a> 带有可等待任务的线程池<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">function_wrapper</span>
{
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">impl_base</span> {
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">call</span>()=0;
        <span style="color: #4f97d7; font-weight: bold;">virtual</span> ~<span style="color: #bc6ec5; font-weight: bold;">impl_base</span>() {}
    };

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">impl_base</span>&gt; <span style="color: #7590db;">impl</span>;
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">F</span>&gt;
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">impl_type</span>: <span style="color: #ce537a; font-weight: bold;">impl_base</span>
    {
        <span style="color: #ce537a; font-weight: bold;">F</span> <span style="color: #7590db;">f</span>;
        <span style="color: #bc6ec5; font-weight: bold;">impl_type</span>(<span style="color: #ce537a; font-weight: bold;">F</span>&amp;&amp; <span style="color: #7590db;">f_</span>): f(<span style="color: #a45bad;">std</span>::move(f_)) {}
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">call</span>() { f(); }
    };
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">F</span>&gt;
    <span style="color: #bc6ec5; font-weight: bold;">function_wrapper</span>(<span style="color: #ce537a; font-weight: bold;">F</span>&amp;&amp; <span style="color: #7590db;">f</span>): impl(<span style="color: #4f97d7; font-weight: bold;">new</span> impl_type&lt;<span style="color: #ce537a; font-weight: bold;">F</span>&gt;(<span style="color: #a45bad;">std</span>::move(f))) {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>() { impl-&gt;call(); }

    <span style="color: #bc6ec5; font-weight: bold;">function_wrapper</span>() = <span style="color: #4f97d7; font-weight: bold;">default</span>;

    <span style="color: #bc6ec5; font-weight: bold;">function_wrapper</span>(<span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp;&amp; <span style="color: #7590db;">other</span>): impl(<span style="color: #a45bad;">std</span>::move(other.impl)) {}

    <span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp;&amp; <span style="color: #7590db;">other</span>)
    {
        impl=<span style="color: #a45bad;">std</span>::move(other.impl);
        <span style="color: #4f97d7; font-weight: bold;">return</span> *<span style="color: #4f97d7; font-weight: bold;">this</span>;
    }

    <span style="color: #bc6ec5; font-weight: bold;">function_wrapper</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #bc6ec5; font-weight: bold;">function_wrapper</span>(<span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&amp;)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
};

<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">thread_pool</span>
{
    <span style="color: #ce537a; font-weight: bold;">thread_safe_queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">function_wrapper</span>&gt; <span style="color: #7590db;">work_queue</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;function_wrapper&#65292;&#32780;&#38750;std::function</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">worker_thread</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)
        {
            <span style="color: #ce537a; font-weight: bold;">function_wrapper</span> <span style="color: #7590db;">task</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;function_wrapper&#65292;&#32780;&#38750;std::function</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span>(work_queue.try_pop(task))
            {
                task();
            }
            <span style="color: #4f97d7; font-weight: bold;">else</span>
            {
                <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
            }
        }
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span>&gt;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #bc6ec5; font-weight: bold;">submit</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span> <span style="color: #ce537a; font-weight: bold;">result_type</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;result_type()&gt; <span style="color: #7590db;">task</span>(<span style="color: #a45bad;">std</span>::move(f));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">result_type</span>&gt; <span style="color: #7590db;">res</span>(task.get_future());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        work_queue.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">task</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21097;&#19979;&#30340;&#21644;&#20043;&#21069;&#19968;&#26679;</span>
};
</pre>
</div>
<p>
首先，修改的 submit()函数①返回一个保存任务返回值的 std::future&lt;&gt;，并且允许调用者等待任务完成。因为需要知道函数 f 的返回类型，这就是使用 std::result_of&lt;&gt;的原因：std::result_of&lt;FunctionType()&gt;::type 是调用 FunctionType(如 f)类型实例的返回值的类型，这个类型没有参数。函数中对 result_type typedef②也使用了 std::result_of&lt;&gt;表达式。<br />
</p>

<p>
然后，将 f 包装到 std::packaged_task&lt;result_type()&gt;③，因为 f 是一个无参数的函数或可调用对象，并且返回 result_type 类型的实例。在把任务推入队列⑤前，你现在可以从 std::packaged_task&lt;&gt;中获取 future④，然后返回 future⑥。注意，要将任务推送到队列中时，只能使用 std::move()，因为 std::packaged_task&lt;&gt;是不可拷贝的。为了处理这种情况，队列里面存放的是 function_wrapper 对象，而非 std::function&lt;void()&gt;对象。<br />
</p>

<p>
这个线程池允许等待任务，并且返回它们的结果。下面的清单展示了 parallel_accumuate 是怎么使用线程池的。<br />
</p>

<p>
<a id="orgad6689d"></a> parallel_accumulate 使用一个带可等待任务的线程池<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #bc6ec5; font-weight: bold;">parallel_accumulate</span>(<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">first</span>,<span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">last</span>,<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">init</span>)
{
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">length</span>=<span style="color: #a45bad;">std</span>::distance(first,last);
    <span style="color: #4f97d7; font-weight: bold;">if</span>(<span style="color: #a45bad;">!</span>length) <span style="color: #4f97d7; font-weight: bold;">return</span> init;

    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">block_size</span>=25;
    <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">num_blocks</span>=(length+block_size-1)/block_size;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">futures</span>(num_blocks-1);
    <span style="color: #ce537a; font-weight: bold;">thread_pool</span> <span style="color: #7590db;">pool</span>;

    <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_start</span>=first;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_blocks-1);++i)
    {
        <span style="color: #ce537a; font-weight: bold;">Iterator</span> <span style="color: #7590db;">block_end</span>=block_start;
        <span style="color: #a45bad;">std</span>::advance(block_end,block_size);
        futures[i]=pool.submit([=]{
            accumulate_block&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">T</span>&gt;()(block_start,block_end);
        }); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        block_start=block_end;
    }
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">last_result</span>=accumulate_block&lt;<span style="color: #ce537a; font-weight: bold;">Iterator</span>,<span style="color: #ce537a; font-weight: bold;">T</span>&gt;()(block_start,last);
    <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #7590db;">result</span>=init;
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #7590db;">i</span>=0;i&lt;(num_blocks-1);++i)
    {
        result+=futures[i].get();
    }
    result += last_result;
    <span style="color: #4f97d7; font-weight: bold;">return</span> result;
}
</pre>
</div>
<p>
与清单 8.4 相比，需要注意几件事。首先，你根据使用的块数(num_blocks)①，而不是线程数来工作。为了充分利用线程池的可扩展性，需要将工作划分为值得并行处理的最小工作块。当线程池中线程不多时，每个线程将会处理多个工作块，不过随着硬件可用线程数量的增长，并发处理的块也会随着增长。<br />
</p>

<p>
当选择“值得并行处理的最小工作块”时，需要仔细斟酌。将一个任务提交给线程池有固有的开销；让工作线程运行这个任务，并通过 std::future&lt;&gt;传输返回值，对于太小的任务，这样的开销不划算。如果任务块太小，使用线程池的运行速度可能比单线程要慢。<br />
</p>

<p>
假设块的大小合理，那就没必要担心打包任务、获取 future 或存储 std::thread 对象以供后面连接用；使用线程池的时候会妥善处理这些。你需要做的就是调用 submit()来提交任务②。<br />
</p>

<p>
线程池也是异常安全的。任何抛出的异常都会通过 submit()返回的期望值传递。如果函数因为异常退出，线程池的析构函数会终止那些没有完成的任务，并等待线程池中的线程结束。<br />
</p>

<p>
像这种简单的例子，这个线程池工作的很好，因为任务都是相互独立的。不过，当任务队列中的任务有依赖关系时，这个线程池就不能胜任了。<br />
</p>
</div>
</div>
<div id="outline-container-org9802089" class="outline-5">
<h5 id="org9802089">Tasks that wait for other tasks (330)</h5>
<div class="outline-text-5" id="text-org9802089">
<p>
快速排序算法是一个贯穿本书的示例。它概念上很简单：需要排序的数据根据主元项，分区为排在前面和后面的两个集合。这两个集合会递归排序，然后缝合在一起组成一个全排序序列。当要将算法并行起来的时候，需要确保递归调用能够使用可用的并发。<br />
</p>

<p>
回到第 4 章，当我第一次介绍这个例子的时候，我们使用 std::async 来运行每一阶段的递归调用，让库来选择是在新线程上运行，还是当调用相关的 get()时同步运行。这种方式工作的很好，因为每一个任务要么在它自己的线程上运行，要么在需要的时候被调用。<br />
</p>

<p>
当我们回顾第 8 章中的实现，可以看到使用了一个和硬件并发相关的固定线程数量的结构体。这种情况下，使用栈来处理要排序的数据块。当每个线程对其正在排序的数据进行分区时，它会将其中一组数据组成一个新块添加到栈中，然后直接对另一组数据进行排序。此时直接等待其他线程完成排序会造成死锁，因为这时候你消耗了有限线程中的一个来等待。很容易就会出现一种情况：所有线程都在等某一个数据块被排序，但没有线程在做排序。当线程等待的特定块没有排好序的时候，我们通过让它们拉取栈上数据块并对数据块进行排序，来解决这个问题。<br />
</p>

<p>
如果用本章截止目前看到的简单线程池替换第 4 章中的 std::async，你会碰到同样的问题。现在只有有限数量的线程，而且，由于没有空闲线程，它们可能最终都在等待未被调度的任务。因此，需要和第 8 章中类似的解决方案：当等待某个数据块完成时，去处理未完成的数据块。如果你正在使用线程池管理任务列表和列表对应的线程——毕竟这是使用线程池的主要原因——你没有权限去访问任务列表，因此也不必管理它。你需要做的就是修改线程池来自动管理。<br />
</p>

<p>
最简单的方法就是在 thread_pool 中添加一个新函数来运行队列上的任务，并且自己管理循环，因此我们会采用这种方法。高级的线程池实现可能会添加逻辑到等待函数或额外的等待函数来处理这种情况，并可能让等待的任务按优先级排序。下面清单中的实现，展示了一个新的 run_pending_task()函数，使用它的修改过的快速排序在清单 9.5 中展示。<br />
</p>

<p>
清单 9.4 run_pending_task()函数实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">thread_pool</span>::<span style="color: #bc6ec5; font-weight: bold;">run_pending_task</span>()
{
    <span style="color: #ce537a; font-weight: bold;">function_wrapper</span> <span style="color: #7590db;">task</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span>(work_queue.try_pop(task))
    {
        task();
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
    }
}
</pre>
</div>
<p>
run_pending_task()的实现直接取自 worker_thread()函数的主循环，现在可以修改它来调用提取出的 run_pending_task()。它尝试从队列获取任务，有的话就运行，要是没有的话让出 CPU 从而允许操作系统重新调度线程。清单 9.5 中的快速排序算法要比清单 8.1 中的版本简单很多，因为所有线程管理逻辑都被移入到线程池。<br />
</p>

<p>
<a id="org0eb063e"></a> 基于线程池的快速排序实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">sorter</span>  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
{
    <span style="color: #ce537a; font-weight: bold;">thread_pool</span> <span style="color: #7590db;">pool</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">do_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;&amp; <span style="color: #7590db;">chunk_data</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(chunk_data.empty())
        {
            <span style="color: #4f97d7; font-weight: bold;">return</span> chunk_data;
        }

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">result</span>;
        result.splice(result.begin(),chunk_data,chunk_data.begin());
        <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">partition_val</span>=*result.begin();

        <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;::<span style="color: #ce537a; font-weight: bold;">iterator</span> <span style="color: #7590db;">divide_point</span>=<span style="color: #a45bad;">std</span>::partition(chunk_data.begin(), chunk_data.end(), [&amp;](<span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp; <span style="color: #7590db;">val</span>){<span style="color: #4f97d7; font-weight: bold;">return</span> val&lt;partition_val;});

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_lower_chunk</span>;
        new_lower_chunk.splice(new_lower_chunk.end(),
                               chunk_data,chunk_data.begin(),
                               divide_point);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; &gt; <span style="color: #7590db;">new_lower</span>= pool.submit(<span style="color: #a45bad;">std</span>::bind(&amp;<span style="color: #a45bad;">sorter</span>::do_sort,<span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">new_lower_chunk</span>)));

        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">new_higher</span>(do_sort(chunk_data));

        result.splice(result.end(),new_higher);
        <span style="color: #4f97d7; font-weight: bold;">while</span>(new_lower.wait_for(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::seconds(0)) != <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">future_status</span>::ready)
        {
            pool.run_pending_task();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        }

        result.splice(result.begin(),new_lower.get());
        <span style="color: #4f97d7; font-weight: bold;">return</span> result;
    }
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">parallel_quick_sort</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">list</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">input</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(input.empty())
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> input;
    }
    <span style="color: #ce537a; font-weight: bold;">sorter</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt; <span style="color: #7590db;">s</span>;

    <span style="color: #4f97d7; font-weight: bold;">return</span> s.do_sort(input);
}
</pre>
</div>
<p>
和清单 8.1 一样，这里将实际工作委托给 sorter 类模板的 do_sort()成员函数①，尽管这里这个类只是包装了一下 thread_pool 实例②。<br />
</p>

<p>
线程和任务管理现在减少到只需要提交任务到线程池③，以及等待的时候运行待处理的任务④。这比清单 8.1 简单很多，在那里需要显式的管理线程以及栈上要排序的数据块。当要提交任务到线程池中，使用 std::bind()绑定 this 指针到 do_sort()上，并提供要排序的数据块。这种情况下，在 new_lower_chunk 上调用 std::move()，来确保移动数据而非拷贝。<br />
</p>

<p>
虽然，这解决了因为等待其他任务而引起的死锁问题，但这个线程池还很不理想。首先，每次对 submit()和 run_pending_task()的调用，访问的都是同一个队列。第 8 章中你已经看到让多线程去修改一个单一的数据集，对性能有不利影响，所以需要解决这个问题。<br />
</p>
</div>
</div>
<div id="outline-container-orgbf13beb" class="outline-5">
<h5 id="orgbf13beb">Avoiding contention on the work queue (333)</h5>
<div class="outline-text-5" id="text-orgbf13beb">
<p>
线程每次调用线程池的 submit()函数，都会推送一个新的任务到唯一的工作队列中。同样，工作线程为了运行任务会持续从队列中弹出任务。这意味着随着处理器的增加，任务队列上的竞争也会增加，这会让性能下降。即使使用无锁队列，从而没有明显的等待，但乒乓缓存会带来大量时间消耗。<br />
</p>

<p>
为了避免乒乓缓存，一种方法是每个线程使用独立的工作队列。每个线程会将新任务放在自己的队列上，并且只有当线程上的队列没有工作时，才去全局的工作队列中获取工作。下面的清单展示了使用一个 thread_local 变量来保证每个线程都拥有自己的任务列表，当然还有全局队列。<br />
</p>

<p>
<a id="orgf1ca6f0"></a> 使用线程局部工作队列的线程池<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">thread_pool</span>
{
    <span style="color: #ce537a; font-weight: bold;">thread_safe_queue</span>&lt;function_wrapper&gt; <span style="color: #7590db;">pool_work_queue</span>;

    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;function_wrapper&gt; <span style="color: #ce537a; font-weight: bold;">local_queue_type</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #ce537a; font-weight: bold;">local_queue_type</span>&gt; <span style="color: #7590db;">local_work_queue</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">worker_thread</span>()
    {
        local_work_queue.reset(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">local_queue_type</span>);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)
        {
            run_pending_task();
        }
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span>&gt;
    <span style="color: #bc6ec5; font-weight: bold;">submit</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span> <span style="color: #ce537a; font-weight: bold;">result_type</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;result_type()&gt; <span style="color: #7590db;">task</span>(f);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">result_type</span>&gt; <span style="color: #7590db;">res</span>(task.get_future());
        <span style="color: #4f97d7; font-weight: bold;">if</span>(local_work_queue)
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            local_work_queue-&gt;push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">task</span>));
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            pool_work_queue.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">task</span>));  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">run_pending_task</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">function_wrapper</span> <span style="color: #7590db;">task</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(local_work_queue &amp;&amp; <span style="color: #a45bad;">!</span>local_work_queue-&gt;empty())
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            task=<span style="color: #a45bad;">std</span>::move(local_work_queue-&gt;front());
            local_work_queue-&gt;pop();
            task();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(pool_work_queue.try_pop(task))
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
            task();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
        }
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21097;&#19979;&#21644;&#20043;&#21069;&#19968;&#26679;</span>
};
</pre>
</div>
<p>
因为不希望非线程池中的线程也拥有一个任务队列，所以使用 std::unique_ptr&lt;&gt;持有线程局部工作队列②；这个指针在 worker_thread()函数循环处理之前进行初始化③。std:unique_ptr&lt;&gt;的析构函数会保证在线程退出的时候，工作队列被销毁。<br />
</p>

<p>
然后 submit()会检查当前线程是否拥有一个工作队列④。如果有，它就是线程池中的线程，可以将任务放入线程的局部队列中；否则，就像之前一样将这个任务放在线程池队列中⑤。<br />
</p>

<p>
run_pending_task()⑥中也有类似检查，只是这次还要检查局部队列是否有任务。如果有的话，就从前面取一个来处理；注意局部任务队列可以是一个普通的 std::queue&lt;&gt;①，因为这个队列只会被一个线程访问。如果局部队列上没有任务，就和之前一样，尝试从线程池队列上获取任务⑦。<br />
</p>

<p>
这对减少竞争很有用，不过当工作分配不均时，很容易导致某个线程局部队列中有很多任务，同时其他线程无事可做。例如，在快速排序的例子中，只有最顶层的数据块能放入到线程池队列中，因为剩余数据块会放在工作线程的局部队列上进行处理。这就违背使用线程池的目的。<br />
</p>

<p>
好在这个问题有解决方案：如果局部工作队列和全局工作队列上没有任务时,允许线程可以从彼此的队列中窃取工作。<br />
</p>
</div>
</div>
<div id="outline-container-org99cae67" class="outline-5">
<h5 id="org99cae67">Work stealing (334)</h5>
<div class="outline-text-5" id="text-org99cae67">
<p>
为了让没有工作的线程能从另一个队列满的线程中获取工作，就需要这个队列可以被窃取线程访问，窃取线程会在 run_pending_tasks()中执行窃取动作。这需要每个线程在线程池中注册它的队列，或由线程池提供队列。同样，还需要确保工作队列中的数据有适当的同步和保护，这样队列的不变性就会受到保护。<br />
</p>

<p>
实现一个无锁队列是可能的，让其所属线程在一端推入或弹出工作的同时其他线程从另一端窃取工作，不过，这种队列的实现超出了本书的讨论范围。为了演示这个想法，我们将坚持使用一个互斥锁来保护队列中的数据。我们希望窃取工作是罕见的事件，这样在互斥锁上只有很少的竞争，因此这个简单队列的开销应该很小。一个简单的基于锁的实现如下。<br />
</p>

<p>
<a id="org2a6384f"></a> 用于工作窃取的基于锁的队列<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>
{
<span style="color: #4f97d7; font-weight: bold;">private</span>:
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #ce537a; font-weight: bold;">function_wrapper</span> <span style="color: #ce537a; font-weight: bold;">data_type</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">deque</span>&lt;<span style="color: #ce537a; font-weight: bold;">data_type</span>&gt; <span style="color: #7590db;">the_queue</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">the_mutex</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">work_stealing_queue</span>() {}
    <span style="color: #bc6ec5; font-weight: bold;">work_stealing_queue</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;
    <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>&amp; <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">=</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>&amp; <span style="color: #7590db;">other</span>)=<span style="color: #4f97d7; font-weight: bold;">delete</span>;

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">push</span>(<span style="color: #ce537a; font-weight: bold;">data_type</span> <span style="color: #7590db;">data</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(the_mutex);
        the_queue.push_front(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">data</span>));
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">empty</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(the_mutex);
        <span style="color: #4f97d7; font-weight: bold;">return</span> the_queue.empty();
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_pop</span>(<span style="color: #ce537a; font-weight: bold;">data_type</span>&amp; <span style="color: #7590db;">res</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(the_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(the_queue.empty()) {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        }
        res=<span style="color: #a45bad;">std</span>::move(the_queue.front());
        the_queue.pop_front();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">try_steal</span>(<span style="color: #ce537a; font-weight: bold;">data_type</span>&amp; <span style="color: #7590db;">res</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lock</span>(the_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(the_queue.empty()) {
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
        }
        res=<span style="color: #a45bad;">std</span>::move(the_queue.back());
        the_queue.pop_back();
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
    }
};
</pre>
</div>
<p>
这个队列是对 std::deque&lt;fuction_wrapper&gt;的简单包装①，这样就能使用一个互斥锁对所有访问进行保护。push()②和 try_pop()③都工作在队列的前部，与此同时 try_steal()④工作在队列后部。<br />
</p>

<p>
这意味着“队列”是它所属线程的一个后进先出栈，最新推入的任务又会第一个弹出。从缓存视角来看，这将有助于提升性能，因为相比于早前推入到队列的线程相关的数据，最近推入的数据很可能仍在缓存中。而且，它很好的映射到譬如快速排序这样的算法。之前的实现中，每次调用 do_sort()都会推送一个任务到栈上，并且等待这个任务结束。通过首先处理最近推入的任务，就可以保证当前调用需要的数据块在其他分支需要的数据块之前被处理，从而可以减少活跃任务的数量以及对栈的使用量。相对于 try_pop()，try_steal()从队列另一端获取任务是为了让竞争最小化；可以使用在第 6、7 章中的讨论的技术来让 try_pop()和 try_steal()并发执行。<br />
</p>

<p>
好了，现在有了一个很赞的支持窃取的工作队列；怎么在线程池中使用呢？这里是个可能的实现。<br />
</p>

<p>
<a id="org67df079"></a> 使用任务窃取的线程池<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">thread_pool</span>
{
    <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #ce537a; font-weight: bold;">function_wrapper</span> <span style="color: #ce537a; font-weight: bold;">task_type</span>;

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic_bool</span> <span style="color: #7590db;">done</span>;
    <span style="color: #ce537a; font-weight: bold;">thread_safe_queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">task_type</span>&gt; <span style="color: #7590db;">pool_work_queue</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_ptr</span>&lt;work_stealing_queue&gt; &gt; <span style="color: #7590db;">queues</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::thread&gt; <span style="color: #7590db;">threads</span>;
    <span style="color: #ce537a; font-weight: bold;">join_threads</span> <span style="color: #7590db;">joiner</span>;

    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>* <span style="color: #7590db;">local_work_queue</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">my_index</span>;

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">worker_thread</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">my_index_</span>)
    {
        my_index=my_index_;
        local_work_queue=queues[my_index].get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)
        {
            run_pending_task();
        }
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">pop_task_from_local_queue</span>(<span style="color: #ce537a; font-weight: bold;">task_type</span>&amp; <span style="color: #7590db;">task</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> local_work_queue &amp;&amp; local_work_queue-&gt;try_pop(task);
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">pop_task_from_pool_queue</span>(<span style="color: #ce537a; font-weight: bold;">task_type</span>&amp; <span style="color: #7590db;">task</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> pool_work_queue.try_pop(task);
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">pop_task_from_other_thread_queue</span>(<span style="color: #ce537a; font-weight: bold;">task_type</span>&amp; <span style="color: #7590db;">task</span>)  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;queues.size();++i)
        {
            <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">index</span>=(my_index+i+1)%queues.size();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span>(queues[index]-&gt;try_steal(task))
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">false</span>;
    }

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">thread_pool</span>(): done(<span style="color: #a45bad;">false</span>),joiner(threads)
    {
        <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #7590db;">thread_count</span>=<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">thread</span>::hardware_concurrency();
        <span style="color: #4f97d7; font-weight: bold;">try</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;thread_count;++i)
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                queues.push_back(<span style="color: #a45bad;">std</span>::unique_ptr&lt;<span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>&gt;(<span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">work_stealing_queue</span>));
                threads.push_back(<span style="color: #a45bad;">std</span>::thread(&amp;<span style="color: #a45bad;">thread_pool</span>::worker_thread,<span style="color: #4f97d7; font-weight: bold;">this</span>,i));
            }
        }
        <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
        {
            done=<span style="color: #a45bad;">true</span>;
            <span style="color: #4f97d7; font-weight: bold;">throw</span>;
        }
    }
    ~<span style="color: #bc6ec5; font-weight: bold;">thread_pool</span>()
    {
        done=<span style="color: #a45bad;">true</span>;
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span>&gt; <span style="color: #bc6ec5; font-weight: bold;">submit</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">typedef</span> <span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">result_of</span>&lt;FunctionType()&gt;::<span style="color: #ce537a; font-weight: bold;">type</span> <span style="color: #ce537a; font-weight: bold;">result_type</span>;
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">packaged_task</span>&lt;result_type()&gt; <span style="color: #7590db;">task</span>(f);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">result_type</span>&gt; <span style="color: #7590db;">res</span>(task.get_future());
        <span style="color: #4f97d7; font-weight: bold;">if</span>(local_work_queue)
        {
            local_work_queue-&gt;push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">task</span>));
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            pool_work_queue.push(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">move</span>(<span style="color: #7590db;">task</span>));
        }
        <span style="color: #4f97d7; font-weight: bold;">return</span> res;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">run_pending_task</span>()
    {
        <span style="color: #ce537a; font-weight: bold;">task_type</span> <span style="color: #7590db;">task</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span>(pop_task_from_local_queue(task) ||  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
           pop_task_from_pool_queue(task) ||  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
           pop_task_from_other_thread_queue(task))
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>
            task();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">this_thread</span>::yield();
        }
    }
};
</pre>
</div>
<p>
这段代码与清单 9.6 类似。第一个不同点是每个线程都有一个 work_stealing_queue，而非普通的 std::queue&lt;&gt;②。当每个线程被创建时，并不分配属于自己的工作队列，而是线程池的构造函数为它分配一个⑥，然后存储到线程池的工作队列列表中①。列表中队列的索引，会传递给线程函数，然后使用索引来检索指向队列的指针③。这就意味着当没有工作可做的线程尝试窃取任务的时候，线程池可以访问这个队列。run_pending_task()现在将尝试从线程自己对应的队列中取出一个任务⑦，从线程池队列中获取一个任务⑧，或从其他线程的队列中获取一个任务⑨。<br />
</p>

<p>
pop_task_from_other_thread_queue()④会遍历线程池中所有线程的任务队列，然后依次尝试窃取一个任务。为了避免每个线程都尝试从列表中的第一个线程上窃取任务，每一个线程都会从自己对应的序号的下一个偏移开始探测。<br />
</p>

<p>
现在有了一个可行的线程池，对很多使用场景都有帮助。当然对于特定的用途，还有无数方法可以提升它，不过这就留给读者作为练习吧。有个还没探索的方向是可以动态调整大小的线程池，它用来确保最优的 CPU 使用率，即使当线程阻塞等待 I/O 或互斥锁时也是如此。<br />
</p>

<p>
下一个“高级”线程管理的技术是中断线程。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc2318ab" class="outline-4">
<h4 id="orgc2318ab">9.2 Interrupting threads (338)</h4>
<div class="outline-text-4" id="text-orgc2318ab">
<p>
在很多情况下，你希望能发信号给一个长时间运行的线程，告诉它是时候停止了。这种线程可能是因为它是某个线程池的工作线程，并且线程池现在要被销毁，或是用户显式的取消了线程上的工作，或其他各种原因。不管是什么原因，想法都一样：需要从一个线程发信号告诉另一个线程在它自然结束前需要停止运行。这需要一种方法让线程优雅的结束，而非粗暴地中断。<br />
</p>

<p>
在需要这么做的地方，你可能会给每种情况量身定做一种机制，但这样有些过犹不及了。使用通用的机制不仅会让后面的场合编码更容易，而且允许你写的代码可中断，并且不用担心代码用在哪（因为是通用的方案）。C++11 标准没有提供这样的机制(尽管有个积极的提案希望在以后的 C++标准中添加对中断的支持<a href="#orga68dda7">A Cooperatively Interruptible Joining Thread</a>)，不过实现这样的机制比较简单。让我们看下如何实现这种机制，我们首先从启动和中断一个线程的接口视角开始，而非被中断线程视角。<br />
</p>

<ul class="org-ul">
<li>P0660: <a id="orga68dda7"></a> , Rev 3, Nicolai Josuttis, Herb Sutter, Anthony Williams <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r3.pdf</a><br /></li>
</ul>
</div>
<div id="outline-container-org42ea2b7" class="outline-5">
<h5 id="org42ea2b7">Launching and interrupting another thread (339)</h5>
<div class="outline-text-5" id="text-org42ea2b7">
<p>
首先看一下外部接口，对可中断线程有什么需求？最起码需要和 std::thread 有相同的接口，以及一个额外的 interrupt()函数：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">interruptible_thread</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #bc6ec5; font-weight: bold;">interruptible_thread</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>);
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">join</span>();
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">detach</span>();
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">joinable</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interrupt</span>();
};
</pre>
</div>
<p>
内部可以使用 std::thread 来管理线程本身，并且使用一些自定义数据结构来处理中断。现在，从线程自身的角度来看呢？ 起码你要能说“我可以在这里中断”——你需要一个可以中断的时间点（interruption point）。为了在不传递额外数据的情况下使用它，它需要是一个无需任何参数即可调用的简单函数：interruption_point()。这意味着中断相关的数据结构需要通过 thread_local 变量访问，并在线程启动时，对其进行设置，因此当线程调用 interruption_point()函数时，会去检查当前运行线程的数据结构。我们将在后面看到 interruption_point()的实现。<br />
</p>

<p>
这个 thread_local 标志是不能使用普通的 std::thread 管理线程的主要原因；需要使用某种方法来分配该 thread_local 标记，使得 interruptible_thread 实例和新启动的线程都可以访问它。你可以在构造函数中，对提供的函数进行封装来实现该需求，然后在将封装后的函数传递给 std::thread，如下所示。<br />
</p>

<p>
<a id="org46ac066"></a> interruptible_thread 的基本实现<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>
{
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set</span>();
    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">is_set</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>;
};
<span style="color: #4f97d7; font-weight: bold;">thread_local</span> <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span> <span style="color: #7590db;">this_thread_interrupt_flag</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">interruptible_thread</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span> <span style="color: #7590db;">internal_thread</span>;
    <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>* <span style="color: #7590db;">flag</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">FunctionType</span>&gt;
    <span style="color: #bc6ec5; font-weight: bold;">interruptible_thread</span>(<span style="color: #ce537a; font-weight: bold;">FunctionType</span> <span style="color: #7590db;">f</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>*&gt; <span style="color: #7590db;">p</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        internal_thread=<span style="color: #a45bad;">std</span>::thread([<span style="color: #a45bad;">f</span>,&amp;<span style="color: #7590db;">p</span>]{  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            p.set_value(&amp;this_thread_interrupt_flag);
            f();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
        });
        flag=p.get_future().get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interrupt</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(flag)
        {
            flag-&gt;set();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
        }
    }
};
</pre>
</div>
<p>
提供的函数 f 包装在一个 lambda 函数中③，这个 lambda 持有 f 的拷贝和局部 promise p 的引用②。在调用提供函数的副本拷贝前，lambda 函数为新线程设置 promise 变量的值为 this_thread_interrupt_flag(该变量被声明为 thread_local①)的地址④。调用线程会等待与 promise 相关的 future 变成就绪状态，并将结果存入到 flag 成员变量中⑤。注意到即使 lambda 函数在新线程上执行，有个悬垂引用指向局部变量 p 是没有问题的，因为在返回之前，interruptible_thread 构造函数会一直等待，直到变量 p 不再被新线程引用。注意，实现没有考虑连接或分离线程，所以需要确保 flag 变量在线程退出或分离时被清理，以避免悬垂指针。<br />
</p>

<p>
interrupt()函数就相对简单：如果你有一个有效的指针指向一个中断标志，你就有一个线程可以被中断，所以可以设置标志⑥。这时就依赖于被中断的线程怎么处理中断。让我们接下来探索这个问题。<br />
</p>
</div>
</div>
<div id="outline-container-orga18d27c" class="outline-5">
<h5 id="orga18d27c">Detecting that a thread has been interrupted (341)</h5>
<div class="outline-text-5" id="text-orga18d27c">
<p>
现在你可以设置中断标志，但是如果线程不检查它是否被中断，就没什么卵用。最简单的情况下，你可以使用 interruption_point()函数来检查；在你觉得可以安全中断的地方调用这个函数，如果标记已经设置，就可以抛出一个 thread_interrupted 异常：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruption_point</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(this_thread_interrupt_flag.is_set())
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> thread_interrupted();
    }
}
</pre>
</div>

<p>
你可以在代码中方便的地方使用这个函数：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>done)
    {
        interruption_point();
        process_next_item();
    }
}
</pre>
</div>

<p>
尽管这行得通，但并不理想。中断线程最佳的地方是它阻塞等待的时候，这意味着线程不是为了调用 interruption_point()函数而运行的！这里你需要某种方法以可中断的方式等待。<br />
</p>
</div>
</div>
<div id="outline-container-orgf42b814" class="outline-5">
<h5 id="orgf42b814">Interrupting a condition variable wait (341)</h5>
<div class="outline-text-5" id="text-orgf42b814">
<p>
好了，通过显式调用 interruption_point()，你可以在代码中仔细选择的位置检测中断，不过当线程在阻塞等待时，这种办法就帮不上忙了，例如等待条件变量的通知。你需要一个新的函数——interruptible_wait()——然后你可以为各种你希望等待的对象重载它，这样就可以解决如何中断等待。我之前提到，你可能在等待条件变量，所以让我们从它开始：为了能中断一个等待的条件变量，需要做哪些事情呢？最简单的方式是，一旦设置中断标志就通知条件变量，并在等待后面立即安放中断点。但要让它起作用，必须通知所有等待对应条件变量的线程，从而确保你关心的线程能够唤醒。不管怎样，等待线程都要处理伪唤醒，所以其他线程对这个唤醒当做伪唤醒来处理——两者之间没什么区别。interrupt_flag 结构需要存储一个指向条件变量的指针，这样调用 set()就能被通知到。为条件变量实现的 interruptible_wait()看起来可能像下面的清单。<br />
</p>

<p>
<a id="orgba61ce0"></a> 为 std::condition_variable 实现的有问题的 interruptible_wait<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruptible_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>&amp; <span style="color: #7590db;">cv</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt;&amp; <span style="color: #7590db;">lk</span>)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
    cv.wait(lk);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    this_thread_interrupt_flag.clear_condition_variable();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
    interruption_point();
}
</pre>
</div>
<p>
假设设置和清除与中断标志相关联的条件变量的函数已经实现，这个代码很好很简单。它检查中断，将条件变量关联到当前线程的 interrupt_flag①，等待条件变量②，清理相关的条件变量③，并再次检查中断。如果线程在等待条件变量期间被中断，中断线程将广播条件变量，并把你从等待中唤醒，这样你就可以检查中断了。不幸的是，代码有问题：有两个问题。如果你想要异常安全，第一个问题就比较明显：std::condition_variable 可以抛出异常，因此你可能退出函数，但没有清理中断标志关联的条件变量。这个问题很容易通过一个结构在析构函数中移除关联来解决。<br />
</p>

<p>
第二个问题不太明显，这里存在 race condition。如果在开始的 interruption_point()被调用后，但在调用 wait()前线程被中断，这时候条件变量和相关中断标志是否关联无关紧要，因为线程不是等待状态，所以无法通过通知条件变量的方式唤醒。你需要确保线程不会在上一次中断检查和调用 wait()之间被通知(通知先于 wait 导致打断无法生效)。不探究 std::condition_variable 内部结构的话，你只有一种方法做这个事情：使用 lk 持有的互斥锁对线程进行保护，这就需要将 lk 传递到 set_condition_variable()函数中去。不幸的是，这又会产生它自己的问题：需要传递一个互斥锁(它的生命周期未知)的引用，到另一个线程中去(这个线程做中断操作)，这个互斥锁被该线程用来上锁(在 interrupt()调用中)，当它调用 interrupt()的时候不知道那个线程是否已经锁住了互斥锁。因此这里可能会死锁，并且可能访问到一个已经销毁的互斥锁，所以这种方法行不通。如果不能可靠地中断条件变量等待，那它的限制就太大了——即使没有特殊的 interruptible_wait()，你几乎已经做到和有特殊的 interruptible_wait()一样了——那你还有别的选择吗？一个选择就是给等待设置超时，使用 wait_for()而不是 wait()并带有一个比较小的超时(比如 1ms)。在线程看到中断前，给线程设置了一个等待的上限(受限于时钟计次粒度)。如果这样做的话，等待线程将会看到更多因为超时造成的伪唤醒，但又无法轻易避免。下面的清单展示了这个实现，随之一起的还有 interrupt_flag 的实现。<br />
</p>

<p>
<a id="org01ab264"></a> 为 std::condition_variable 在 interruptible_wait 中使用超时<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span> {
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">flag</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>* <span style="color: #7590db;">thread_cond</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">set_clear_mutex</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">interrupt_flag</span>() : thread_cond(0) {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set</span>()
    {
        flag.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(set_clear_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(thread_cond) {
            thread_cond-&gt;notify_all();
        }
    }

    <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">is_set</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> flag.load(<span style="color: #a45bad;">std</span>::memory_order_relaxed);
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set_condition_variable</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>&amp; <span style="color: #7590db;">cv</span>)
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(set_clear_mutex);
        thread_cond=&amp;cv;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">clear_condition_variable</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(set_clear_mutex);
        thread_cond=0;
    }

    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">clear_cv_on_destruct</span> {
        ~<span style="color: #bc6ec5; font-weight: bold;">clear_cv_on_destruct</span>()
        {
            this_thread_interrupt_flag.clear_condition_variable();
        }
    };
};

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruptible_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>&amp; <span style="color: #7590db;">cv</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt;&amp; <span style="color: #7590db;">lk</span>)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);
    <span style="color: #a45bad;">interrupt_flag</span>::<span style="color: #ce537a; font-weight: bold;">clear_cv_on_destruct</span> <span style="color: #7590db;">guard</span>;
    interruption_point();
    cv.wait_for(lk,<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::milliseconds(1));
    interruption_point();
}
</pre>
</div>
<p>
如果有等待的谓词，那么 1ms 的超时可以完全隐藏在谓词循环中：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Predicate</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruptible_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>&amp; <span style="color: #7590db;">cv</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt;&amp; <span style="color: #7590db;">lk</span>, <span style="color: #ce537a; font-weight: bold;">Predicate</span> <span style="color: #7590db;">pred</span>)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);
    <span style="color: #a45bad;">interrupt_flag</span>::<span style="color: #ce537a; font-weight: bold;">clear_cv_on_destruct</span> <span style="color: #7590db;">guard</span>;
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>this_thread_interrupt_flag.is_set() &amp;&amp; <span style="color: #a45bad;">!</span>pred())
    {
        cv.wait_for(lk,<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::milliseconds(1));
    }
    interruption_point();
}
</pre>
</div>
<p>
这将导致比其他情况更频繁的检查谓词，不过可以很容易用它替换普通的 wait()调用。带有超时的变体很容易实现：要么等待指定时间，或者 1ms，以最短时间为准。好了，对于 std::condition_variable 的等待可以处理了；那 std::condition_variable_any 又如何？是跟现在一样处理？还是说能做的更好？<br />
</p>
</div>
</div>
<div id="outline-container-org0946a7c" class="outline-5">
<h5 id="org0946a7c">Interrupting a wait on std::condition_variable_any (344)</h5>
<div class="outline-text-5" id="text-org0946a7c">
<p>
std::condition_variable_any 与 std::condition_variable 的不同在于，std::condition_variable_any 可以使用任意类型的锁，而不只是 std::unique_lock&lt;std::mutex&gt;。这让事情更简单，也使得使用 std::condition_variable_any 可以比 std::condition_variable 做的更好。因为它能与任意类型的锁一起工作，于是你可以构建自己的锁类型，lock/unlock 操作既可以用于 interrupt_flag 的内部互斥锁 set_clear_mutex，也可以用于提供给调用 wait 的锁((6)处的 lk)，如下所示。<br />
</p>

<p>
<a id="org1ef1e54"></a> 用于 std::condition_variable_any 的 interruptible_wait<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">atomic</span>&lt;<span style="color: #ce537a; font-weight: bold;">bool</span>&gt; <span style="color: #7590db;">flag</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable</span>* <span style="color: #7590db;">thread_cond</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable_any</span>* <span style="color: #7590db;">thread_cond_any</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">set_clear_mutex</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">interrupt_flag</span>(): thread_cond(0),thread_cond_any(0) {}

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">set</span>()
    {
        flag.store(<span style="color: #a45bad;">true</span>,<span style="color: #a45bad;">std</span>::memory_order_relaxed);
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(set_clear_mutex);
        <span style="color: #4f97d7; font-weight: bold;">if</span>(thread_cond)
        {
            thread_cond-&gt;notify_all();
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span>(thread_cond_any)
        {
            thread_cond_any-&gt;notify_all();
        }
    }

    <span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Lockable</span>&gt;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable_any</span>&amp; <span style="color: #7590db;">cv</span>,<span style="color: #ce537a; font-weight: bold;">Lockable</span>&amp; <span style="color: #7590db;">lk</span>) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">custom_lock</span>
        {
            <span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>* <span style="color: #7590db;">self</span>;
            <span style="color: #ce537a; font-weight: bold;">Lockable</span>&amp; <span style="color: #7590db;">lk</span>;

            <span style="color: #bc6ec5; font-weight: bold;">custom_lock</span>(<span style="color: #ce537a; font-weight: bold;">interrupt_flag</span>* <span style="color: #7590db;">self_</span>, <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable_any</span>&amp; <span style="color: #7590db;">cond</span>, <span style="color: #ce537a; font-weight: bold;">Lockable</span>&amp; <span style="color: #7590db;">lk_</span>):
                self(self_),lk(lk_)
            {
                self-&gt;set_clear_mutex.lock();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
                self-&gt;thread_cond_any=&amp;cond;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
            }

            <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
            {
                lk.unlock();
                self-&gt;set_clear_mutex.unlock();
            }

            <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>()
            {
                <span style="color: #a45bad;">std</span>::lock(self-&gt;set_clear_mutex,lk);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            }

            ~<span style="color: #bc6ec5; font-weight: bold;">custom_lock</span>()
            {
                self-&gt;thread_cond_any=0;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                self-&gt;set_clear_mutex.unlock();
            }
        };
        <span style="color: #ce537a; font-weight: bold;">custom_lock</span> <span style="color: #7590db;">cl</span>(<span style="color: #4f97d7; font-weight: bold;">this</span>,cv,lk);
        interruption_point();
        cv.wait(cl);
        interruption_point();
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21097;&#19979;&#30340;&#21644;&#20043;&#21069;&#19968;&#26679;</span>
};

<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">Lockable</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruptible_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">condition_variable_any</span>&amp; <span style="color: #7590db;">cv</span>, <span style="color: #ce537a; font-weight: bold;">Lockable</span>&amp; <span style="color: #7590db;">lk</span>)
{
    this_thread_interrupt_flag.wait(cv,lk);
}
</pre>
</div>
<p>
自定义的锁类型在构造的时候，需要锁住内部 set_clear_mutex①，然后设置 thread_cond_any 指针指向传入构造函数中的 std::condition_variable_any 引用②。保存的 Lockable 引用会在后面用到，它必须已经被锁住。现在可以安心的检查中断，不用担心竞争了。如果中断标志在这时候已经设置，那么标志是在锁住 set_clear_mutex 之前设置的。在 wait()中，当条件变量调用你的 unlock()函数时，解锁 Lockable 对象以及 set_clear_mutex③。一旦进入 wait()调用（而不是在之前），这就允许尝试中断你的线程获得 set_clear_mutex 的锁并检查 thread_cond_any 指针（译注：这里的意思是现在用锁消除了前面提到的第二个关于 race conditions 的问题，只有在你的线程进入到 cv.wait 里面了，才会解锁 set_clear_mutex，然后中断你的线程才有机会给它上锁并给你发信号通知）。这正是使用 std::condition_variable 所追求的(但那时没法做到)。一旦 wait()结束等待(要么被通知，要么被伪唤醒)，它将调用你的 lock()函数，并再次获取内部 set_clear_mutex 以及 Lockable 对象上的锁④。在你的 custom_lock 析构函数⑤清理 thread_cond_any 指针，以及解锁 set_clear_mutex 之前，现在可以再次对发生在 wait()调用期间的中断进行检查。<br />
</p>
</div>
</div>
<div id="outline-container-org35b0790" class="outline-5">
<h5 id="org35b0790">Interrupting other blocking calls (346)</h5>
<div class="outline-text-5" id="text-org35b0790">
<p>
虽然搞定了中断条件变量的等待，但是其他类型的阻塞等待又如何呢：互斥锁，等待 future，以及诸如此类？通常情况下，你需要使用用于 std::condition_variable 的超时选项，因为不访问互斥锁或者 future 的内部构件的话，除非满足了等待的条件，否则无法中断等待。但是对于其他这些阻塞等待，你知道自己在等待什么，因此可以在 interruptible_wait()函数中进行循环。作为一个例子，这里为 std::future&lt;&gt;重载了 interruptible_wait()的实现：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">typename</span> <span style="color: #ce537a; font-weight: bold;">T</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">interruptible_wait</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">T</span>&gt;&amp; <span style="color: #7590db;">uf</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">!</span>this_thread_interrupt_flag.is_set())
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(uf.wait_for(lk,<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">chrono</span>::milliseconds(1))==<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">future_status</span>::ready)
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
    }
    interruption_point();
}
</pre>
</div>
<p>
等待会在中断标志设置好或者期望是就绪状态时停止，每次在期望上阻塞等待 1ms。这就意味着，假设采用高精度时钟，在确认中断请求前，平均需要大约 0.5ms。通常 wait_for 至少会等待一整个时钟计次，所以如果你的时钟每 15ms 计次一次，那么最终等待大约 15ms，而不是 1ms。是否可接受，要看情况而定。如果有必要(并且时钟支持)，你总是可以减少超时。但减少超时时间的缺点是：将会让线程频繁醒来检查标志，并且增加任务切换的开销。<br />
</p>

<p>
好了，我们已经了解了如何使用 interruption_point()和 interruptible_wait()函数检测中断。但怎么处理中断呢？<br />
</p>
</div>
</div>
<div id="outline-container-org0bf9d45" class="outline-5">
<h5 id="org0bf9d45">Handling interruptions (347)</h5>
<div class="outline-text-5" id="text-org0bf9d45">
<p>
从被中断线程的角度看，一个中断就是一个 thread_interrupted 异常，因此可以像处理其他异常那样进行处理。特别地，你可以使用标准 catch 块对其进行捕获：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">try</span>
{
    do_something();
}
<span style="color: #4f97d7; font-weight: bold;">catch</span>(thread_interrupted&amp;)
{
    handle_interruption();
}
</pre>
</div>
<p>
这意味着你可以捕获中断，用某种方法进行处理，然后继续。如果你这么做，并且另一个线程再次调用 interrupt()时，线程将会在下一次调用中断点时再次被中断。如果线程执行的是一系列独立的任务的话，你可能希望这么做；中断一个任务会导致这个任务被丢弃，然后该线程会继续执行列表中的下一个任务。<br />
</p>

<p>
因为 thread_interrupted 是一个异常，当调用可中断代码时，所有通常线程安全的防范措施都必须采用，就为了确保资源不会泄露，并且你的数据结构保持一致状态。通常，让中断终止线程是可取的，这样你就可以让异常向上传播。不过，如果你让异常传播到传递给 std::thread 构造函数的线程函数的外面，那么 std::terminate()会被调用，这样整个程序将会终止。为了避免这种情况，必须记住安置一个捕获（thread_interrupted）的处理器在每个你传给 interruptible_thread 的函数中，你可以把 catch 块放入你用来初始化 interrupt_flag 的包装器中。这样就允许中断异常不经过处理传播出去是安全的，因为它随后会终止那个线程。interruptible_thread 构造函数中对线程的初始化现在看起来如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp">internal_thread=<span style="color: #a45bad;">std</span>::thread([<span style="color: #a45bad;">f</span>,&amp;<span style="color: #7590db;">p</span>]
{
    p.set_value(&amp;this_thread_interrupt_flag);
    <span style="color: #4f97d7; font-weight: bold;">try</span>
    {
        f();
    }
    <span style="color: #4f97d7; font-weight: bold;">catch</span>(<span style="color: #ce537a; font-weight: bold;">thread_interrupted</span> <span style="color: #4f97d7; font-weight: bold;">const</span>&amp;)
    {}
});
</pre>
</div>

<p>
让我们来看个具体的例子，这个例子中中断是很有用的。<br />
</p>
</div>
</div>
<div id="outline-container-org4e87774" class="outline-5">
<h5 id="org4e87774">Interrupting background tasks on application exit (348)</h5>
<div class="outline-text-5" id="text-org4e87774">
<p>
考虑一个桌面搜索应用。不光要与用户互动，应用还需要监控文件系统的状态，识别任何变化并更新索引。为了避免影响 GUI 的响应能力，通常会将处理线程放在后台运行。在整个应用的生命周期，后台线程需要一直执行；后台线程会作为应用启动的一部分被启动，并且在应用关闭的时候停止运行。通常这样的应用只有在机器关闭时才退出，因为应用需要一直运行从而维护一个最新的索引。在任何情况下，当应用被关闭，需要使用有序的方式将后台线程关闭，其中一种方式就是中断它们。<br />
</p>

<p>
接下来的清单展示了这个系统线程管理部分的一个示例实现。<br />
</p>

<p>
<a id="org1be9890"></a> 在后台监视文件系统<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">config_mutex</span>;
<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;interruptible_thread&gt; <span style="color: #7590db;">background_threads</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">background_thread</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">disk_id</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">while</span>(<span style="color: #a45bad;">true</span>)
    {
        interruption_point();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
        <span style="color: #ce537a; font-weight: bold;">fs_change</span> <span style="color: #7590db;">fsc</span>=get_fs_changes(disk_id);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span>(fsc.has_changes())
        {
            update_index(fsc);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        }
    }
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">start_background_processing</span>()
{
    background_threads.push_back(interruptible_thread(background_thread,disk_1));
    background_threads.push_back(interruptible_thread(background_thread,disk_2));
}

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    start_background_processing();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    process_gui_until_exit();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span>&gt; <span style="color: #7590db;">lk</span>(config_mutex);
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;background_threads.size();++i)
    {
        background_threads[i].interrupt();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;background_threads.size();++i)
    {
        background_threads[i].join(); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
    }
}
</pre>
</div>
<p>
启动时，后台线程就被启动④。然后主线程继续处理 GUI⑤。当用户请求应用程序退出时，后台进程将会被中断⑥，主线程在退出前会等待每一个后台线程结束。后台线程运行在一个循环中，检查磁盘的变化②，并且更新索引③。每次在循环过程中通过调用 interruption_point()函数①对中断进行检查。<br />
</p>

<p>
为什么在等待任何线程前中断所有线程？为什么不先中断一个，然后等待它，之后再处理下一个？答案就是“并发”。线程被中断后，不大可能马上结束，因为它们必须继续运行到下一个中断点，然后在退出之前运行任何必需的析构函数调用和异常处理代码。通过立即连接每个线程，将导致中断线程等待，即使它仍有有用的工作可做——中断其他线程。只有当你没有更多工作可做（所有线程已经被中断）时才等待。这也允许所有被中断的线程并行处理他们的中断，因而潜在的可以更快的完成。<br />
</p>

<p>
可以很容易地对这种中断机制进行扩展，以添加更多的可中断调用，或禁用跨特定代码块的中断，不过这个就留给读者作为练习吧。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga4622fb" class="outline-3">
<h3 id="orga4622fb">10 parallel algorithms</h3>
<div class="outline-text-3" id="text-orga4622fb">
</div>
<div id="outline-container-orgc51360d" class="outline-4">
<h4 id="orgc51360d">本章主要内容</h4>
<div class="outline-text-4" id="text-orgc51360d">
<ul class="org-ul">
<li>使用 C++17 并行算法<br /></li>
</ul>

<p>
上一章我们介绍了高级线程管理和线程池，在第 8 章中，我们使用一些算法的并行版本作为例子来研究设计并发代码。在本章，我们将看看 C++17 标准提供的并行算法，所以闲话少说，让我们开始吧。<br />
</p>
</div>
</div>
<div id="outline-container-org940e0e4" class="outline-4">
<h4 id="org940e0e4">10.1 Parallelizing the standard library algorithms (350)</h4>
<div class="outline-text-4" id="text-org940e0e4">
<p>
C++17 标准添加了并行算法（parallel algorithms）的概念到 C++标准库中。它们是在范围上操作的许多函数的额外重载，如 std::find、std::transform 和 std::reduce。并行版本与“普通”单线程版本具有相同的签名，除了添加了一个新的第一个参数，该参数指定要使用的执行策略（execution policy）。例如：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">my_data</span>;
<span style="color: #a45bad;">std</span>::sort(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,my_data.begin(),my_data.end());
</pre>
</div>

<p>
std::execution::par 的执行策略向标准库表明，它允许以并行算法的形式，使用多个线程执行这个调用。注意！这是一个许可，不是一个要求——如果愿意的话，库仍然可以在单线程上执行代码。还需要重点注意的是，通过指定执行策略，对算法复杂度的要求也发生了变化，并且通常比普通串行版的算法要宽松。这是因为并行算法为了利用系统的并行，通常会做更多的工作——如果将工作划分到 100 个处理器，即便完成的总工作量是原先的的 2 倍，仍然能获得 50 倍的加速。<br />
</p>

<p>
在讨论算法本身之前，让我们先看看执行策略。<br />
</p>
</div>
</div>
<div id="outline-container-org89ff22a" class="outline-4">
<h4 id="org89ff22a">10.2 Execution policies (351)</h4>
<div class="outline-text-4" id="text-org89ff22a">
<p>
标准指定了三种执行策略：<br />
</p>
<ul class="org-ul">
<li>std::execution::sequenced_policy<br /></li>
<li>std::execution::parallel_policy<br /></li>
<li>std::execution::parallel_unsequenced_policy<br /></li>
</ul>

<p>
这些类都定义在&lt;execution&gt;头文件中。这个头文件中也定义了三个对应的策略对象可以传给算法：<br />
</p>

<p>
std::execution::seq<br />
std::execution::par<br />
std::execution::par_unseq<br />
除了复制这三种类型的对象外，你不能依赖于自己能够从这些策略类构造对象，因为它们可能有一些特殊的初始化要求。实现可能还会定义一些其他的执行策略，这些策略有实现相关的行为。你不能定义自己的执行策略。<br />
</p>

<p>
这些策略对算法行为的影响在 10.2.1 节描述。任何给定的实现也允许提供额外的执行策略，带有它们想要的任何语义。现在，让我们看看使用一种标准执行策略的影响，首先从所有算法重载（这些重载带有一个执行策略）的一般改变开始。<br />
</p>
</div>
<div id="outline-container-org972bcdc" class="outline-5">
<h5 id="org972bcdc">General effects of specifying an execution policy (351)</h5>
<div class="outline-text-5" id="text-org972bcdc">
<p>
如果将执行策略传递给标准算法库中的算法，算法的行为就由执行策略控制。这会影响行为的几个方面：<br />
</p>

<ul class="org-ul">
<li>算法的复杂度<br /></li>
<li>抛出异常时的行为<br /></li>
<li>执行算法步骤的位置、方式和时间<br /></li>
</ul>
</div>

<div id="outline-container-org3921c18" class="outline-6">
<h6 id="org3921c18">算法复杂度影响</h6>
<div class="outline-text-6" id="text-org3921c18">
<p>
如果给算法提供了执行策略，那么算法的复杂度可能会发生变化：除了管理并行执行的调度开销外，很多并行算法会执行更多的算法核心操作(无论是交换，比较，还是所提供函数对象的应用)，目的是在总运行时间方面提供全面的性能改进。<br />
</p>

<p>
复杂度变化的精确细节会随着每个算法而变化，不过一般的策略是，如果一个算法指定了一些事情恰好发生 some-expression（某个表达式）次，或者至多 some-expression 次，那么执行策略的重载将把这个要求放松到 O(some-expression)。这意味着，相比于不带执行策略的版本，带有执行策略的重载可能会执行数倍于它的操作，而这个倍数将取决于库和平台的内部实现，而不是提供给算法的数据。<br />
</p>
</div>
</div>

<div id="outline-container-org99aa54f" class="outline-6">
<h6 id="org99aa54f">异常行为</h6>
<div class="outline-text-6" id="text-org99aa54f">
<p>
如果在执行带有执行策略的算法期间抛出异常，那么结果由执行策略确定。如果有未被捕获的异常，那么所有标准提供的执行策略都会调用 std::terminate。使用标准执行策略调用标准库算法可能抛出的唯一异常是 std::bad_alloc，如果标准库不能为其内部操作获得足够的内存资源，则会抛出该异常。例如，没有执行策略的情况下，以下对 std::for_each 的调用会将异常进行传播。<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(v.begin(),v.end(),[](<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">x</span>){ <span style="color: #4f97d7; font-weight: bold;">throw</span> my_exception(); });
</pre>
</div>

<p>
然而具有执行策略的对应调用，将会终止程序：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(
    <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::seq,v.begin(),v.end(),
    [](<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">x</span>){ <span style="color: #4f97d7; font-weight: bold;">throw</span> my_exception(); }
);
</pre>
</div>

<p>
这就是使用 std::execution::seq 执行策略和不提供执行策略间的关键区别。<br />
</p>
</div>
</div>

<div id="outline-container-org38b1d4c" class="outline-6">
<h6 id="org38b1d4c">算法步骤执行的位置和时间</h6>
<div class="outline-text-6" id="text-org38b1d4c">
<p>
这是执行策略的基本方面，也是标准执行策略之间唯一不同的方面。策略指定了使用哪个执行代理来执行算法步骤，这些执行代理可以是“普通”线程、向量流、GPU 线程，或其他任何东西。执行策略还将指定是否有任何顺序约束用于算法步骤的运行：算法步骤是否以特定的顺序运行，部分单独的算法步骤是否可以相互交错或并行运行，等等。<br />
</p>

<p>
每个标准执行策略的详细信息见 10.2.2，10.2.3 和 10.2.4 节，让我们先从最基本的策略 std::execution::sequenced_policy 开始。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3e037dc" class="outline-5">
<h5 id="org3e037dc">std::execution::sequenced_policy (353)</h5>
<div class="outline-text-5" id="text-org3e037dc">
<p>
sequenced_policy 不是并行策略：使用它强制实现在调用函数的线程上执行所有操作，因此没有并行。但它仍然是一个执行策略，因此对算法的复杂度和异常影响与其他标准执行策略相同。<br />
</p>

<p>
不仅所有的操作必须在同一个线程上执行，而且它们必须按照确定的顺序执行，所以它们不是交错的。但具体的顺序是未指定的，并且可能在不同的函数调用之间有所不同。特别是，不能保证操作的执行顺序与相应没有执行策略的重载的执行顺序相同。例如：下面对 std::for_each 的调用，以未指定的顺序将 1-1000 填充到 vector 中。这就与没有执行策略的重载形成对比，它将顺序存储数字：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">v</span>(1000);
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">count</span>=0;
<span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::seq,
              v.begin(),
              v.end(),
              [&amp;](<span style="color: #ce537a; font-weight: bold;">int</span>&amp; <span style="color: #7590db;">x</span>){ x=++count; }
);
</pre>
</div>

<p>
数字可能按顺序存储，但你不能依赖它。<br />
</p>

<p>
这意味着顺序策略对算法使用的迭代器、值和可调用对象没有什么要求：它们可以自由使用同步机制，并且可以依赖在同一线程上调用的所有操作，尽管它们不能依赖这些操作的顺序。<br />
</p>
</div>
</div>
<div id="outline-container-org794a0e5" class="outline-5">
<h5 id="org794a0e5">std::execution::parallel_policy (353)</h5>
<div class="outline-text-5" id="text-org794a0e5">
<p>
parallel_policy 提供了跨多个线程的基本并行执行。操作可以在调用算法的线程上执行，也可以在库创建的多个线程上执行。在给定线程上执行的操作必须以确定的顺序执行，不能交错执行，但具体的顺序是未指定的，并且在不同的调用之间可能会有所不同。一个给定的操作将在其整个持续时间内运行在一个固定的线程上。<br />
</p>

<p>
这对顺序策略上算法使用的迭代器、值和可调用对象施加了额外的要求：如果并行调用，它们不能导致 data race，并且不能依赖于会和其他操作在同一个线程上运行，或者依赖于会其他操作不在同一个线程上运行。<br />
</p>

<p>
在使用没有执行策略的标准库算法的大多数情况下，你都可以使用并行执行策略。只有元素之间需要特定的排序，或存在对共享数据的非同步访问时，才会有问题。对 vector 中的所有值进行递增操作可以并行完成：<br />
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,v.begin(),v.end(),[](<span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">x</span>){ ++x; });
</pre>
</div>

<p>
如果使用并行执行策略，前面填充 vector 的例子就有问题；具体来说，它是未定义的行为：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,v.begin(),v.end(), [&amp;](<span style="color: #ce537a; font-weight: bold;">int</span>&amp; <span style="color: #7590db;">x</span>){ x=++count; });
</pre>
</div>

<p>
这里每次调用 lambda 表达式都会对 count 进行修改，因此，如果库跨越多个线程执行 lambda 表达式，这里就会出现 data race，从而导致未定义行为。std::execution::parallel_policy 的要求先于这一点：进行前面的调用是未定义的行为，即使库没有为此调用使用多个线程。是否展示未定义行为是调用的静态属性，而不是依赖于库的实现细节。但是，函数调用之间的同步是允许的，因此可以通过将 count 设置为 std::atomic&lt;int&gt;而不是普通的 int，或者使用互斥锁，再次让它成为已定义的行为。在这种情况下，这可能会破坏使用并行执行策略的意义，因为这将串行化所有调用，但在一般情况下，允许对共享状态进行同步访问。<br />
</p>
</div>
</div>
<div id="outline-container-orgac310fe" class="outline-5">
<h5 id="orgac310fe">std::execution::parallel_unsequenced_policy (354)</h5>
<div class="outline-text-5" id="text-orgac310fe">
<p>
parallel_unsequenced_policy 为库提供了最大程度的算法并行，作为交换它对算法使用的迭代器、值和可调用对象也施加了最严格的要求。<br />
</p>

<p>
使用 parallel_unsequenced_policy 策略调用的算法，可以在任意线程上执行算法步骤，这些线程彼此间是无序的。这意味着操作现在可以在一个线程上相互交错，这样，在第一个操作完成之前，第二个操作就在同一个线程上启动了，并且可能在线程间迁移，因此一个给定的操作可能会在一个线程启动，在第二个线程继续运行，并在第三个线程上完成。<br />
</p>

<p>
如果使用 parallel_unsequenced_policy 策略，在提供给该算法的迭代器、值和可调用对象上调用的操作就一定不能使用任何形式的同步，也不能调用任何与其他函数同步的函数或调用任何与其他代码同步的函数。<br />
</p>

<p>
这意味着操作只能操作相关的元素，或者基于该元素可以访问的任何数据，并且不能修改线程之间或元素之间共享的任何状态。<br />
</p>

<p>
稍后我们将用一些例子来充实这些内容。现在，让我们来看看并行算法本身。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2e1a2d7" class="outline-4">
<h4 id="org2e1a2d7">10.3 The parallel algorithms from the C++ Standard Library (354)</h4>
<div class="outline-text-4" id="text-org2e1a2d7">
<p>
&lt;algorithm&gt;和&lt;numeric&gt;头文件中大多数算法都有带一个执行策略的重载。这包括：all_of，any_of，none_of，for_each，for_each_n，find，find_if，find_end，find_first_of，adjacent_find，count，count_if，mismatch，equal，search，search_n，copy，copy_n，copy_if，move，swap_ranges，transform，replace，replace_if，replace_copy，replace_copy_if，fill，fill_n，generate，generate_n，remove，remove_if，remove_copy，remove_copy_if，unique，unique_copy，reverse，reverse_copy，rotate，rotate_copy，is_partitioned，partition，stable_partition，partition_copy，sort，stable_sort，partial_sort，partial_sort_copy，is_sorted，is_sorted_until，nth_element，merge，inplace_merge，includes，set_union，set_intersection，set_difference，set_symmetric_difference，is_heap，is_heap_until，min_element，max_element，minmax_element，lexicographical_compare，reduce，transform_reduce，exclusive_scan，inclusive_scan，transform_exclusive_scan，transform_inclusive_scan 和 adjacent_difference 。<br />
</p>

<p>
相当长的一个清单；C++标准库中几乎所有可以并行化的算法都在这个列表中。明显的例外是 std::accumulate，它是严格意义上的串行累加，但其广义相对物 std::reduce 确实出现在列表中——标准中有一个适当的警告：如果归约操作既不是可结合的也不是可交换的，那么由于操作未指定顺序，结果可能是不确定的。<br />
</p>

<p>
对于列表中的每个算法，每个“普通”重载都有一个新的变体，它将执行策略作为第一个参数——“普通”重载的相应参数随后出现在执行策略之后。例如，std::sort 有两个没有执行策略的“普通”重载：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort</span>(<span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">last</span>);
 
<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Compare</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort</span>(<span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">last</span>, <span style="color: #ce537a; font-weight: bold;">Compare</span> <span style="color: #7590db;">comp</span>);
</pre>
</div>

<p>
因此，它还有两个带执行策略的重载：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort</span>(<span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>&amp;&amp; <span style="color: #7590db;">exec</span>,
          <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">last</span>);
 
<span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Compare</span>&gt;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">sort</span>(<span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>&amp;&amp; <span style="color: #7590db;">exec</span>,
          <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">RandomAccessIterator</span> <span style="color: #7590db;">last</span>, <span style="color: #ce537a; font-weight: bold;">Compare</span> <span style="color: #7590db;">comp</span>);
</pre>
</div>

<p>
带和不带执行策略参数的签名有一个重要的区别，它只会影响一些算法：如果“普通”算法允许输入迭代器或输出迭代器，那带执行策略的重载则需要前向迭代器。这是因为输入迭代器从根本上是单趟的：只能访问当前元素，而不能存储指向前面元素的迭代器。类似地，输出迭代器只允许写入当前元素：不能通过向后移动迭代器来写入后面的元素，也不能向前移动迭代器来写入前面的元素。<br />
</p>

<pre class="example" id="org17e4e36">
C++标准库中的迭代器类别

C++标准库定义了五种类型的迭代器：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。

输入迭代器是用于获取值的单趟迭代器。通常从控制台或网络进行输入，或生成序列时使用。前移输入迭代器会使该迭代器的任何副本失效。

输出迭代器是用于写入值的单趟迭代器。通常用于输出到文件或向容器添加值。前移输出迭代器会使该迭代器的任何副本失效。

前向迭代器是用于对持久数据进行单向迭代的多趟迭代器。虽然不能让迭代器返回到前面的元素，但可以存储副本并使用它们引用前面的元素。前向迭代器返回对元素的实际引用，因此既可用于读也可用于写(如果目标不是常量的话)。

双向迭代器是像前向迭代器一样的多趟迭代器，但是它也可以后退访问之前的元素。

随机访问迭代器是可以像双向迭代器一样前进和后退的多趟迭代器，但它前进和后退的步伐可以大于一个元素，并且可以使用数组索引运算符，直接访问偏移位置的元素。
</pre>

<p>
给定 std::copy 的“普通”签名：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">InputIterator</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">OutputIterator</span>&gt;
<span style="color: #ce537a; font-weight: bold;">OutputIterator</span> <span style="color: #bc6ec5; font-weight: bold;">copy</span>(<span style="color: #ce537a; font-weight: bold;">InputIterator</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">InputIterator</span> <span style="color: #7590db;">last</span>, <span style="color: #ce537a; font-weight: bold;">OutputIterator</span> <span style="color: #7590db;">result</span>);
</pre>
</div>

<p>
带有执行策略的重载是<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">template</span>&lt;<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>,<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ForwardIterator1</span>, <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ForwardIterator2</span>&gt;
<span style="color: #ce537a; font-weight: bold;">ForwardIterator2</span> <span style="color: #bc6ec5; font-weight: bold;">copy</span>(<span style="color: #ce537a; font-weight: bold;">ExecutionPolicy</span>&amp;&amp; <span style="color: #7590db;">policy</span>,
                      <span style="color: #ce537a; font-weight: bold;">ForwardIterator1</span> <span style="color: #7590db;">first</span>, <span style="color: #ce537a; font-weight: bold;">ForwardIterator1</span> <span style="color: #7590db;">last</span>,
                      <span style="color: #ce537a; font-weight: bold;">ForwardIterator2</span> <span style="color: #7590db;">result</span>);
</pre>
</div>
<p>
虽然，模板参数的命名从编译器的角度没有带来任何直接影响，但从 C++标准的角度确实有影响：标准库算法的模板参数的名称表示类型的语义约束，并且算法将依赖于那些约束（具有指定的语义）所隐含的操作。对比输入迭代器和前向迭代器，前者允许解引用迭代器以返回代理类型，该代理类型可转换为迭代器的值类型，而后者要求对迭代器的解引用返回对该值的实际引用，并且所有相等的迭代器返回对相同值的引用。<br />
</p>

<p>
这对于并行很重要：这意味着迭代器可以自由地复制，并等价地使用。此外，递增前向迭代器不会使其他副本失效也很重要，因为这意味着不同的线程可以操作各自的迭代器副本，需要的时候递增迭代器，不必担心使其他线程持有的迭代器失效。如果带有执行策略的重载允许使用输入迭代器，这将迫使任何线程串行访问用于从源序列读取的唯一迭代器，这显然限制了并行的潜力。<br />
</p>

<p>
让我们看一些具体的例子。<br />
</p>
</div>
<div id="outline-container-org757ea3d" class="outline-5">
<h5 id="org757ea3d">Examples of using parallel algorithms (357)</h5>
<div class="outline-text-5" id="text-org757ea3d">
<p>
最简单的例子肯定是并行循环：为容器的每个元素做一些事情。这是一个并行场景的经典例子：每个项都是独立的，因此你有最大的并行可能性。如果使用支持 OpenMP 的编译器，你可以这样写：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#pragma</span> omp parallel <span style="color: #4f97d7; font-weight: bold;">for</span>
<span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #7590db;">i</span>=0;i&lt;v.size();++i)
{
    do_stuff(v[i]);
}
</pre>
</div>

<p>
使用 C++标准库算法，可以这样写：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #a45bad;">std</span>::for_each(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,v.begin(), v.end(), do_stuff);
</pre>
</div>

<p>
这将在库创建的内部线程之间划分范围内的元素，并在范围内的每个元素 x 上调用 do_stuff(x)。但如何在线程间划分元素是一个实现细节。<br />
</p>
</div>
<div id="outline-container-orgdc0dcdd" class="outline-6">
<h6 id="orgdc0dcdd">CHOICE OF EXECUTION POLICY</h6>
<div class="outline-text-6" id="text-orgdc0dcdd">
<p>
除非你的实现提供了更适合你的非标准策略，否则 std::execution::par 是最常用的策略。如果代码适合并行化，那应该与 std::execution::par 一起工作。某些情况下，可以使用 std::execution::par_unseq 代替。这可能一点用也没有(没有一个标准的执行策略会对并行达到的水平做出保证)，但是，通过重新排序和交叉任务，它可能会给库提供额外的范围来提高代码的性能，当然也会换来对代码更严格的要求。这些更严格的要求中最值得注意的是，在访问元素或对元素执行操作时不能使用同步。这意味着不能使用互斥锁或原子变量，或前面章节中描述的任何其他机制，以确保多线程的访问是安全的；必须依赖算法本身不会从多个线程访问相同的元素，并在对并行算法的调用之外使用外部同步来防止其他线程访问数据。<br />
</p>

<p>
清单 10.1 中的示例显示了一些可以与 std::execution::par 一起使用，但不能与 std::execution::par_unseq 一起使用的代码。使用内部互斥锁进行同步意味着尝试使用 std::execution::par_unseq 将是未定义的行为。<br />
</p>

<p>
<a id="org48df3cf"></a> 类（有内部同步）上的并行算法<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span>
{
    <span style="color: #4f97d7; font-weight: bold;">mutable</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">data</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">X</span>():data(0){}
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">get_value</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span> <span style="color: #7590db;">guard</span>(m);
        <span style="color: #4f97d7; font-weight: bold;">return</span> data;
    }
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increment</span>()
    {
        <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span> <span style="color: #7590db;">guard</span>(m);
        ++data;
    }
};
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increment_all</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">X</span>&gt;&amp; <span style="color: #7590db;">v</span>)
{
    <span style="color: #a45bad;">std</span>::for_each(
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par,v.begin(),v.end(),
        [](<span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">x</span>){x.increment();}
        );
}
</pre>
</div>
<p>
下一个清单显示了一种可用于 std::execution::par_unseq 的替代方法。在本例中，内部的每个元素的互斥锁被替换为整个容器的互斥锁。<br />
</p>

<p>
<a id="org40b6b60"></a> 类（没有内部同步）上的并行算法<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Y</span>
{
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">data</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">Y</span>():data(0){}
    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">get_value</span>() <span style="color: #4f97d7; font-weight: bold;">const</span>{<span style="color: #4f97d7; font-weight: bold;">return</span> data;}
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increment</span>()
    {
        ++data;
    }
};
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ProtectedY</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">mutex</span> <span style="color: #7590db;">m</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">Y</span>&gt; <span style="color: #7590db;">v</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">lock</span>()
    {
        m.lock();
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">unlock</span>()
    {
        m.unlock();
    }

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #ce537a; font-weight: bold;">Y</span>&gt;&amp; <span style="color: #bc6ec5; font-weight: bold;">get_vec</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">return</span> v;
    }
};

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">increment_all</span>(<span style="color: #ce537a; font-weight: bold;">ProtectedY</span>&amp; <span style="color: #7590db;">data</span>){
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">lock_guard</span> <span style="color: #7590db;">guard</span>(data);
    <span style="color: #4f97d7; font-weight: bold;">auto</span>&amp; <span style="color: #7590db;">v</span>=data.get_vec();
    <span style="color: #a45bad;">std</span>::for_each(
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par_unseq,v.begin(),v.end(),
        [](<span style="color: #ce537a; font-weight: bold;">Y</span>&amp; <span style="color: #7590db;">y</span>){ y.increment(); }
        );
}
</pre>
</div>
<p>
清单 10.2 中的元素访问现在没有同步，使用 std::execution::par_unseq 是安全的。但缺点是来自并行算法调用之外的其他线程的并发访问现在必须等待整个操作完成，而不是清单 10.1 中的每个元素粒度。<br />
</p>

<p>
现在让我们来看一个更现实的例子，看看并行算法是如何使用的：统计网站的访问量。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge0f2773" class="outline-5">
<h5 id="orge0f2773">Counting visits (359)</h5>
<div class="outline-text-5" id="text-orge0f2773">
<p>
假设你经营一个繁忙的网站，日志有数百万条目，并且你希望对这些日志进行处理以便查看汇总数据：每个页面有多少访问量，这些访问来自哪里，使用哪些浏览器访问的网站，等等。分析日志包含两个部分：处理每一行以提取相关信息，以及将结果合计在一起。这是使用并行算法的理想场景，因为每一行都可以完全独立的处理，并且只要最终的总数是正确的，结果就可以逐步合计。<br />
</p>

<p>
特别地，transform_reduce 就是专门为这类任务设计的。下面的清单显示了如何将它用于此任务。<br />
</p>

<p>
<a id="org3ee8238"></a> 使用 transform_reduce 来统计网站页面的访问量<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;vector&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;string&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;unordered_map&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;numeric&gt;</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">log_info</span>
{
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">page</span>;
    <span style="color: #ce537a; font-weight: bold;">time_t</span> <span style="color: #7590db;">visit_time</span>;
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">browser</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">any other fields</span>
};

<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">log_info</span> <span style="color: #bc6ec5; font-weight: bold;">parse_log_line</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #4f97d7; font-weight: bold;">const</span> &amp;<span style="color: #7590db;">line</span>); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #ce537a; font-weight: bold;">visit_map_type</span>= <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unordered_map</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>, <span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">long</span> <span style="color: #ce537a; font-weight: bold;">long</span>&gt;;
<span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #bc6ec5; font-weight: bold;">count_visits_per_page</span>(<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">vector</span>&lt;<span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #4f97d7; font-weight: bold;">const</span> &amp;<span style="color: #7590db;">log_lines</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">combine_visits</span>
    {
        <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #7590db;">lhs</span>, <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #7590db;">rhs</span>) <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span>(lhs.size() &lt; rhs.size())
                <span style="color: #a45bad;">std</span>::swap(lhs, rhs);
            <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #4f97d7; font-weight: bold;">const</span> &amp;<span style="color: #7590db;">entry</span> : rhs)
            {
                lhs[entry.first]+= entry.second;
            }
            <span style="color: #4f97d7; font-weight: bold;">return</span> lhs;
        }

        <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">log_info</span> <span style="color: #7590db;">log</span>,<span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #7590db;">map</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
            ++map[log.page];
            <span style="color: #4f97d7; font-weight: bold;">return</span> map;
        }

        <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #7590db;">map</span>,<span style="color: #ce537a; font-weight: bold;">log_info</span> <span style="color: #7590db;">log</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
            ++map[log.page];
            <span style="color: #4f97d7; font-weight: bold;">return</span> map;
        }

        <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #4f97d7; font-weight: bold;">operator</span><span style="color: #bc6ec5; font-weight: bold;">()</span>(<span style="color: #ce537a; font-weight: bold;">log_info</span> <span style="color: #7590db;">log1</span>,<span style="color: #ce537a; font-weight: bold;">log_info</span> <span style="color: #7590db;">log2</span>) <span style="color: #4f97d7; font-weight: bold;">const</span>
        { <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
            <span style="color: #ce537a; font-weight: bold;">visit_map_type</span> <span style="color: #7590db;">map</span>;
            ++map[log1.page];
            ++map[log2.page];
            <span style="color: #4f97d7; font-weight: bold;">return</span> map;
        }
    };

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">std</span>::transform_reduce( <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
        <span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">execution</span>::par, log_lines.begin(), log_lines.end(),
        visit_map_type(), combine_visits(), parse_log_line
        );
}
</pre>
</div>
<p>
假设已经有一个函数 parse_log_line 从日志条目中提取相关信息①，count_visits_per_page 函数是对 std::transform_reduce 调用的简单包装②。复杂度来源于归约（reduction）操作：需要能够组合两个 log_info 结构体来生成一个 map，组合一个 log_info 结构体和一个 map(或者相反)生成一个 map，或组合两个 map 生成一个 map。因此这意味着 combine_visits 函数对象需要重载 4 个函数调用操作符，③④⑤和⑥，这就排除了用一个简单的 lambda 来实现它，哪怕这四个重载的实现很简单。<br />
</p>

<p>
std::transform_reduce 的实现将使用可用的硬件并行来执行这个计算(因为你传递了 std::execution::par)。正如我们在前一章中看到的那样，手工编写这个算法并不简单，因此这允许你将实现并行的苦差事委托给标准库的实现者，这样你就可以专注于所需的结果。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge48266f" class="outline-3">
<h3 id="orge48266f">11 testing and debugging multithreaded applications</h3>
<div class="outline-text-3" id="text-orge48266f">
</div>
<div id="outline-container-org9dc6b37" class="outline-4">
<h4 id="org9dc6b37">本章主要内容</h4>
<div class="outline-text-4" id="text-org9dc6b37">
<ul class="org-ul">
<li>并发相关的 bug<br /></li>
<li>通过测试和代码评审定位 bug<br /></li>
<li>设计多线程测试<br /></li>
<li>测试多线程代码的性能<br /></li>
</ul>

<p>
到目前为止，我主要关注编写并发代码所涉及的内容——可用的工具、如何使用它们，以及代码的总体设计和结构。但是有一个软件开发的关键部分还没有解决：测试和调试。如果你正在阅读这一章，希望找到一种简单的方法来测试并发代码，那你将会非常失望。因为测试和调试并发代码是非常困难的。而我将呈献给你的也只是让事情变得更简单的一些技术，以及一些值得思考的重要问题。<br />
</p>

<p>
测试和调试就像硬币的两面——你让你的代码进行测试，以便找到可能存在的 bug，然后你对它进行调试，以消除这些 bug。如果幸运的话，你只需要移除你自己测试发现的 bug，而不是应用程序的最终用户发现的 bug。在我们讨论测试或调试之前，理解可能出现的问题是很重要的，所以让我们来看看这些问题。<br />
</p>
</div>
</div>
<div id="outline-container-org86cdada" class="outline-4">
<h4 id="org86cdada">11.1 Types of concurrency-related bugs (363)</h4>
<div class="outline-text-4" id="text-org86cdada">
<p>
你可以在并发代码中碰到任何类型的错误；在这方面它并不特别。但有些类型的 bug 与并发的使用直接相关，因此与本书息息相关。通常，这些与并发相关的 bug 可以分为两类：<br />
</p>

<ul class="org-ul">
<li>不必要的阻塞<br /></li>
<li>race conditions<br /></li>
</ul>

<p>
这些都是很宽泛的类别，所以我们把它们稍微划分一下。首先，让我们看看不必要的阻塞。<br />
</p>
</div>
<div id="outline-container-org6bc5669" class="outline-5">
<h5 id="org6bc5669">Unwanted blocking (363)</h5>
<div class="outline-text-5" id="text-org6bc5669">
<p>
我说的不必要的阻塞是什么意思？当线程因为等待某些东西而无法继续时，它就会被阻塞。等待的东西通常是一个互斥锁、一个条件变量或一个 future，但它也可能是在等待 I/O。这是多线程代码的自然组成部分，但有时候并不希望阻塞——这就是不必要的阻塞问题。这就引出了下一个问题：为什么这种阻塞是不必要的？通常，这是因为其他一些线程也在等待被阻塞的线程执行某个动作，因此该线程也被阻塞。这一主题有几种变体：<br />
</p>

<ul class="org-ul">
<li>死锁——正如你在第 3 章看到的，在死锁的情况下，一个线程会等待另一个，而另一个又会等待第一个。如果你的线程死锁，它们应该做的任务就无法完成。在最明显的情况下，所涉及的线程之一是负责用户界面的线程，在这种情况下，界面将停止响应。在其他情况下，界面将保持响应，但一些所需的任务不会完成，例如搜索不返回或文档不打印。<br /></li>

<li>活锁——活锁与死锁类似，一个线程在等待另一个线程，而另一个线程又在等待第一个线程。这里的关键区别在于，等待不是阻塞等待，而是一个活跃的检查循环，比如自旋锁。在严重的情况下，症状与死锁相同(应用程序不会有任何进展)，只是 CPU 使用率很高，因为线程仍然在运行，但彼此阻塞。在不太严重的情况下，由于随机调度，活锁最终会解决，但是在被卷入活锁的任务中会有很长的延迟，在此延迟期间会有很高的 CPU 使用量。<br /></li>

<li>阻塞在 I/O 或外部输入上——如果线程在等待外部输入时被阻塞，它就不能继续执行，甚至等待的输入永远不会出现。 因此，让一个线程阻塞在外部输入上，而其他线程又可能等待它执行任务是不可取的。<br /></li>
</ul>

<p>
这里简要介绍了不必要的阻塞。那么 race conditions 呢？<br />
</p>
</div>
</div>
<div id="outline-container-org7197a88" class="outline-5">
<h5 id="org7197a88">Race conditions (364)</h5>
<div class="outline-text-5" id="text-org7197a88">
<p>
race conditions 是多线程代码中最常见的问题原因——许多死锁与活锁只在 race conditions 下出现。并非所有 race conditions 都有问题——当行为依赖于不同线程中操作的相对调度时，race conditions 就会发生。很多 race conditions 完全是良性的；例如，哪个工作线程处理任务队列中的下一个任务在很大程度上是不相关的。但是许多并发 bug 是由于 race conditions 造成的。特别地，race conditions 经常会导致以下类型的问题：<br />
</p>

<ul class="org-ul">
<li>data races ——data races 是一种特定类型的 race conditions，由于对共享内存位置的非同步并发访问，它会导致未定义的行为。我在第 5 章中讨论 C++内存模型的时候介绍了 data races 。data races 通常是由于不正确地使用原子操作来同步线程或访问共享数据时没有锁住适当的互斥锁而发生的。<br /></li>

<li>破坏的不变性——它们可以表现为悬垂指针(因为另一个线程删除了被访问的数据)、随机内存崩溃(由于部分更新导致线程读取了不一致的值)和双重释放内存 (例如，当两个线程从队列中弹出相同的值时，它们都会删除某个相关的数据)。被破坏的不变性可以是基于时间的——也可以是基于值的。如果单独线程上的操作需要按照特定的顺序执行，不正确的同步可能会导致 race conditions，在这里有时会违反所需的顺序。<br /></li>

<li>生命周期问题——尽管可以将这些问题与破坏的不变量捆绑在一起，但这是一个单独的类别。这类 bug 的基本问题是线程比它所访问的数据寿命长，因此它正在访问已删除或以其他方式销毁的数据，而且存储空间可能会被另一个对象重用。在线程函数完成之前，线程引用了超出作用域的局部变量，这通常会导致生命周期问题，但它们并不仅限于该场景。每当线程的生命周期和它所操作的数据没有以某种方式绑定在一起时，数据就有可能在线程完成之前被销毁，然后线程函数就万劫不复了。如果为了等待线程完成而手动调用 join()，则需要确保在抛出异常时不会跳过对 join()的调用。这是应用于线程的基本异常安全。<br /></li>
</ul>

<p>
有问题的 race conditions 是罪魁祸首。使用死锁和活锁时，应用程序看起来会挂起，变得完全没有响应，或者需要很长时间才能完成任务。通常，可以将调试器附到正在运行的进程上，以确定哪些线程涉及死锁或活锁，以及它们正在争夺哪些同步对象。对于 data races ，破坏的不变量，以及生命周期问题，问题的明显症状(比如随机崩溃或不正确的输出)可以出现在代码的任何地方——代码可能会覆盖系统另一部分使用的内存，而这些内存直到很久以后才被使用。然后，错误将在与错误代码的位置完全无关的代码中出现，很可能是在程序执行很靠后的时候。这是共享内存系统的真正祸根——无论如何限制哪个线程可以访问哪些数据，以及尝试确保使用了正确的同步，任何线程都可能覆盖应用程序中任何其他线程正在使用的数据。<br />
</p>

<p>
现在，我们已经简单地确定了要查找的问题种类，让我们看看如何定位代码中的任何实例，以便修复它们。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org17fc0e3" class="outline-4">
<h4 id="org17fc0e3">11.2 Techniques for locating concurrency-related bugs (365)</h4>
<div class="outline-text-4" id="text-org17fc0e3">
<p>
在前一节中，我们了解了可能看到的与并发相关的 bug 类型，以及它们在代码中是如何出现的。有了这些基础以后，你就可以查看代码，了解 bug 可能存在的位置，并且尝试确定特定部分中是否存在 bug。<br />
</p>

<p>
也许最明显和最直接的方法是查看代码。虽然这看起来显而易见，但却很难彻底做到这一点。因为当你阅读自己编写的代码时，很容易陷入自己的思维逻辑中，而不是客观的审查代码本身。同样地，在审查别人写的代码时，很容易被蜻蜓点水般通读一遍所诱惑，然后仅仅对照编码规范进行检查，并突出任何明显的问题。但我们真正需要做的是花时间仔细梳理代码，思考并发问题——以及非并发问题。(当你审查代码的时候，索性也会审查非并发问题。毕竟，bug 就是 bug，不管是否是并发问题)稍后我们将介绍在评审代码时需要考虑的具体事项。<br />
</p>

<p>
即使在彻底评审代码之后，仍然可能遗漏一些 bug，并且在任何情况下，你都需要确认它确实可以工作，别的不说，主要为了让你安心。因此，我们将继续从评审代码到一些在测试多线程代码时使用的技术。<br />
</p>
</div>
<div id="outline-container-orgf246d73" class="outline-5">
<h5 id="orgf246d73">Reviewing code to locate potential bugs (365)</h5>
<div class="outline-text-5" id="text-orgf246d73">
<p>
正如我已经提到的，当评审多线程代码以检查与并发相关的 bug 时，彻底评审它很重要。如果可能的话，可以找别人来评审。因为不是他们写的代码，他们将不得不仔细思考它是如何工作的，这将有助于发现任何可能存在的 bug。重要的是，评审者要有足够的时间进行恰当的评审——不是随意的瞄几眼，而是恰当的、经过深思熟虑的评审。大多数并发 bug 不只是快速一瞥就能发现——它们的出现，通常依赖于微妙的时序问题。<br />
</p>

<p>
如果你让你的同事来评审代码，他们会重新开始。因此，他们会从不同的角度看待事物，可能会发现你看不到的东西。如果你没有同事可以邀请，可以邀请朋友，甚至把代码贴在网上(小心不要惹恼你公司的律师)。如果实在没人帮你评审代码，或者他们没找到问题，不用担心——还有很多事情可以做。对初学者来说，暂时不去管代码可能是值得的——处理应用程序的另一部分、读书或散步。如果你休息一下，你的潜意识可以在你有意识地专注于其他事情的时候在后台处理这个问题。此外，当你再次回来的时候，对代码可能会相对生疏——你自己可能会设法从不同的角度来看待它。<br />
</p>

<p>
让别人检查代码的另一种方法是自己检查。一个有用的技巧是试着向别人详细解释它是如何工作的。他们甚至不需要亲自到那里——许多团队都有一只熊或橡皮鸡来做这个，并且我个人发现写详细的笔记会非常有益。在你解释的时候，请思考每一行代码，可能发生什么，它访问哪些数据，等等。问自己一些关于代码的问题，并解释答案。我发现这是一个非常强大的技巧——通过问自己这些问题并仔细思考答案，问题往往会自己显现出来。这些问题对任何代码评审都有帮助，而不仅仅是在评审你自己的代码时。<br />
</p>
</div>

<div id="outline-container-orgbf548b6" class="outline-6">
<h6 id="orgbf548b6">QUESTIONS TO THINK ABOUT WHEN REVIEWING MULTITHREADED CODE</h6>
<div class="outline-text-6" id="text-orgbf548b6">
<p>
正如我已经提到的，对于一个评审者(不管是代码的作者还是其他人)来说，思考与被评审的代码相关的特定问题是很有用的。这些问题可以将评审者的注意力集中在代码的相关细节上，并有助于识别潜在的问题。我喜欢问的问题包括如下，尽管这绝对不是一个详尽的列表。你可能会发现其他问题可以帮助你更好地集中注意力。这里是我的问题列表：<br />
</p>

<ul class="org-ul">
<li>需要保护哪些数据不受并发访问的影响？<br /></li>
<li>如何确保数据受到了保护？<br /></li>
<li>此刻其他线程可能在代码的什么地方？<br /></li>
<li>这个线程持有哪些互斥锁？<br /></li>
<li>其他线程可能持有哪些互斥锁？<br /></li>
<li>这个线程完成的操作和另一个线程完成的操作之间是否有顺序要求？这些要求是如何执行的？<br /></li>
<li>这个线程加载的数据仍然有效吗？它可能被其他线程修改过吗？<br /></li>
<li>如果你假设另一个线程可能正在修改数据，那么这意味着什么？如何确保这种情况永远不会发生？<br /></li>
</ul>

<p>
最后一个问题是我最喜欢的，因为它让我思考线程之间的关系。通过假设存在与特定代码行相关的 bug，你就可以充当侦探并跟踪原因。为了让自己确信没有 bug，你必须考虑每一个边界情况和可能的顺序。当数据在其生命周期内受到多个互斥锁的保护时，这一点特别有用，例如在第 6 章中的线程安全队列中，队列的头部和尾部有单独的互斥锁：为了确信在持有一个互斥锁的时候，访问是安全的，你必须确保持有另一个互斥锁的线程不能也访问相同的元素。它还清楚地表明，公有数据，或其他代码可以轻易获得指针或引用的数据，必须接受特别的审查。<br />
</p>

<p>
列表中倒数第二个问题也很重要，因为它解决了一个很容易犯的错误：如果释放一个互斥锁，然后再重新获得它，则必须假定其他线程可能已经修改了共享数据。尽管这是显而易见的，但如果互斥锁不是立即可见的——可能是因为它们位于对象的内部——你可能在不知不觉中就这样做了。在第 6 章中，你看到了在线程安全数据结构上提供的函数粒度太细的情况下，它是如何导致 race conditions 和 bug 的。然而对于一个非线程安全的栈，让 top()和 pop()操作分离是有意义的，对一个可能被多个线程同时访问的栈，现在情况不再是这样，因为内部互斥锁在两次调用之间被释放，所以另一个线程可以修改栈。正如你在第 6 章中看到的，解决方案是将这两个操作结合起来，使它们都在同一个互斥锁的保护下执行，从而消除潜在的竞争条件。<br />
</p>

<p>
好了，你已经评审了代码(或者让其他人评审了代码)。确信没有 bug。常言道，布丁好不好，吃了才知道——如何测试你的代码来证实或反驳你对它没有 bug 的信念呢？<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcbe42ff" class="outline-5">
<h5 id="orgcbe42ff">Locating concurrency-related bugs by testing (367)</h5>
<div class="outline-text-5" id="text-orgcbe42ff">
<p>
在开发单线程应用程序时，测试应用程序是相对简单的，只是比较耗时。原则上，可以确定所有可能的输入数据集(或者至少是所有有趣的用例)，并在应用程序中运行它们。如果应用程序产生了正确的行为和输出，你就知道它在给定的输入集上没有问题。测试错误状态，例如处理磁盘错误，要复杂得多，但思路是一样的：设置初始条件并允许应用程序运行。<br />
</p>

<p>
测试多线程代码要困难一个数量级，因为线程的精确调度是不确定的，并且可能会随着运行而变化。因此，即使你使用相同的输入数据运行应用程序，它也可能在某些时候正常工作，而在其他时候，如果有 race conditions 潜伏在代码中，则会失败。并且具有潜在的 race conditions 并不意味着代码总是会失败，只是有时可能会失败。<br />
</p>

<p>
鉴于再现并发相关 bug 的固有困难，仔细设计测试是划算的。你肯定希望每个测试运行最少量的代码就可以潜在的证明一个问题，这样，如果测试失败，你可以最好地隔离出错的代码——最好直接测试并发队列，以验证并发推送和弹出是否有效，而不是通过使用该队列的整个代码块进行测试。如果你在设计代码时就考虑代码应该如何测试，将会很有帮助——请参阅本章后面关于可测试性设计的一节。<br />
</p>

<p>
为了验证问题是否与并发相关，从测试中消除并发也是值得的。当所有的东西都在一个线程中运行时，如果你遇到了问题，那这就是一个常见的 bug，而不是并发相关的 bug。当试图追踪“野外”（译注：这里指在测试环境之外的场景，比如在线上服务时）发生的 bug 而不是在测试工具中被检测到的 bug 时，这一点尤为重要。仅仅因为 bug 发生在应用程序的多线程部分并不意味着它就自动是并发相关的。如果你正在使用线程池来管理并发级别，那么通常可以设置一个配置参数来指定工作线程的数量。如果你手动管理线程，则必须修改代码以使用单个线程进行测试。无论采用哪种方式，如果可以将应用程序减少到单个线程，就可以消除并发这一原因。另一方面，如果这个问题在单核系统上消失(即使有多个线程运行)，但在多核系统或多处理器系统上又出现了，那么就存在一个 race conditions，很可能是一个同步或内存顺序问题。<br />
</p>

<p>
测试并发代码不仅仅是测试代码的结构；测试的结构和测试环境同样重要。如果你继续测试一个并发队列的例子，你必须考虑各种不同的场景：<br />
</p>

<ul class="org-ul">
<li>一个线程自己调用 push()或 pop()，以验证队列是否在基本层面上正常工作<br /></li>
<li>一个线程在空队列上调用 push()，同时另一个线程调用 pop()<br /></li>
<li>多个线程在一个空队列上调用 push()<br /></li>
<li>多个线程在一个满队列上调用 push()<br /></li>
<li>多个线程在一个空队列上调用 pop()<br /></li>
<li>多个线程在一个满队列上调用 pop()<br /></li>
<li>多个线程在一个部分满的队列上（但队列中的项数不够所有线程消费）调用 pop()<br /></li>
<li>多个线程调用 push()，同时一个线程在一个空队列上调用 pop()<br /></li>
<li>多个线程调用 push()，同时一个线程在一个满队列上调用 pop()<br /></li>
<li>多个线程调用 push()，同时多个线程在一个空队列上调用 pop()<br /></li>
<li>多个线程调用 push()，同时多个线程在一个满队列上调用 pop()<br /></li>
</ul>

<p>
考虑所有这些甚至更多场景后，然后你需要考虑测试环境的其他因素：<br />
</p>

<ul class="org-ul">
<li>“多线程”在每种情况下是什么意思？(是 3 个，4个，还是 1024 个？)<br /></li>
<li>系统中是否有足够的处理核让每个线程都运行在它自己的核上<br /></li>
<li>测试应该运行在哪种处理器架构上<br /></li>
<li>如何确保对测试的“同时”部分进行适当的调度<br /></li>
</ul>

<p>
具体到你的特定情况，还有一些额外的因素需要考虑。在这四个环境因素中，第一个和最后一个因素影响测试本身的结构(在 11.2.5 节中讨论)，而另外两个因素则与正在使用的物理测试系统有关。要使用的线程数量与要测试的特定代码相关，但是有各种不同的方法构建测试以获得适当的调度。在研究这些技术之前，让我们先看看如何设计更易于测试的应用程序代码。<br />
</p>
</div>
</div>

<div id="outline-container-org2bf0dc9" class="outline-5">
<h5 id="org2bf0dc9">Designing for testability (369)</h5>
<div class="outline-text-5" id="text-org2bf0dc9">
<p>
测试多线程代码很困难，所以你想要做的是使它变得更容易。你能做的最重要的一件事就是为可测试性设计代码。关于单线程代码可测试性设计的论述有很多，并且其中很多建议仍然适用。通常，如果应用以下因素，代码可能更容易测试：<br />
</p>

<ul class="org-ul">
<li>每个函数和类的职责清晰。<br /></li>
<li>函数短小精悍。<br /></li>
<li>测试可以完全控制被测代码周围的环境。<br /></li>
<li>执行被测试的特定操作的代码是紧挨在一起的，而不是分散在整个系统中。<br /></li>
<li>在编写代码之前，考虑如何测试代码。<br /></li>
</ul>

<p>
所有这些对多线程代码仍然适用。实际上，我认为关注多线程代码的可测试性比关注单线程代码的可测试性更重要，因为它天生就更难测试。最后一点很重要：即使你没有在编写代码之前编写测试，在编写代码之前考虑如何测试代码也是值得的——需要使用什么输入，哪些情况可能会有问题，如何以可能有问题的方式刺激代码，等等。<br />
</p>

<p>
设计用于测试的并发代码的最佳方法之一是消除并发。如果可以将代码分解为负责线程间通信路径的部分和操作单个线程中通信数据的部分，那就可以大幅削减问题。应用程序中对仅由该线程访问的数据进行操作的那些部分可以使用普通的单线程技术进行测试。而难以测试的并发代码（它们处理线程之间的通信，并且确保每次只有一个线程访问特定的数据块）现在也小得多，因此测试也更容易处理。<br />
</p>

<p>
例如，如果应用程序被设计为多线程状态机，那么可以将其分成几个部分。可以使用单线程技术独立地测试每个线程的状态逻辑(它确保转换和操作对于每个可能的输入事件集都是正确的)，并使用测试工具提供可能来自其他线程的输入事件。之后，核心状态机和消息路由的代码（确保事件以正确的顺序被正确交付到正确的线程）可以被独立测试，但需要使用多个并发线程和专门为测试设计的简单状态逻辑。<br />
</p>

<p>
另外，如果可以将代码划分为多个读取共享数据/转换数据/更新共享数据的块，那就可以使用所有常用的单线程技术来测试转换数据的部分，因为现在这是单线程代码。所以测试多线程转换的困难问题将简化为测试共享数据的读取和更新，这就简单很多。<br />
</p>

<p>
需要注意的一点是，库调用可以使用内部变量来存储状态，如果多个线程使用同一组库调用，状态就会成为共享的。这可能是一个问题，因为代码访问共享数据并不是显而易见的。但随着时间的推移，你会了解到这些可能有问题的库调用是哪写库调用，它们会很突出。然后，你可以添加适当的保护和同步，或者使用对多个线程并发访问安全的替代函数。<br />
</p>

<p>
为了可测试性而设计多线程代码，不仅仅是构建代码以尽量减少处理并发相关问题所需的代码量以及注意使用非线程安全的库调用。记住 11.2.1 节中评审代码时要问自己的问题也很有帮助。虽然这些问题并不是直接关于测试和可测试性的，但是如果带着“测试帽”来思考这些问题，并考虑如何测试代码，它将会影响你所做的设计选择，并使测试变得更容易。<br />
</p>

<p>
现在我们已经研究了设计代码来简化测试，并可能修改代码把“并发”部分(如线程安全的容器或状态机事件逻辑)和“单线程”部分(仍然可以通过并发块与其他线程交互)分开，接下来让我们看一下测试并发感知代码的技术。<br />
</p>
</div>
</div>
<div id="outline-container-org2f41a46" class="outline-5">
<h5 id="org2f41a46">Multithreaded testing techniques (370)</h5>
<div class="outline-text-5" id="text-org2f41a46">
<p>
你已经透彻思考了要测试的场景，并编写了少量代码来练习要测试的函数。为了验证 bugs 都被清楚了，如何确保任何可能有问题的调度序列都被执行了？<br />
</p>

<p>
有几种方法可以解决这个问题，我们从暴力测试或压力测试开始。<br />
</p>
</div>
<div id="outline-container-org5ffb814" class="outline-6">
<h6 id="org5ffb814">BRUTE-FORCE TESTING</h6>
<div class="outline-text-6" id="text-org5ffb814">
<p>
暴力测试背后的想法是给代码加压，看看它是否崩溃。这通常意味着运行代码很多次，可能同时运行很多线程。如果有一个 bug 只在线程以特定方式调度时才显现，那么代码运行次数越多，这个 bug 出现的可能性就越大。如果只运行一次测试，并且测试通过了，那么可能会对代码能够正常工作有一点信心。如果你连续跑十次，每次都通过了，你可能会更有信心。如果你运行这个测试 10 亿次，并且每次都通过了，就会信心爆棚。<br />
</p>

<p>
对结果的信心取决于每次测试所测试的代码数量。如果测试非常细粒度，就像前面为线程安全队列概述的测试一样，那么这种暴力测试可以让你对代码有高度的信心。另一方面，如果要测试的代码相当大，那么可能的调度排列的数量是如此之大，以至于即使运行 10 亿次测试也可能产生低等级的可信度。<br />
</p>

<p>
暴力测试的缺点是它可能会给你错误的信心。如果编写测试的方式意味着有问题的情况不会发生，那么你可以任意多次运行测试，测试也不会失败，即使它在稍有不同的情况中每次都会失败。最糟糕的例子是，由于正在测试的特定系统的运行方式，有问题的情况不会在测试系统上发生。除非代码只在与被测试的系统相同的系统上运行，否则特定的硬件和操作系统组合可能不允许出现导致问题的情况。<br />
</p>

<p>
这里的经典示例是在单处理器系统上测试多线程应用程序。因为每个线程都必须在相同的处理器上运行，所以所有的东西都是自动串行的，在真正的多处理器系统中可能遇到的许多 race conditions 和乒乓缓存问题都消失了。不过，这并不是唯一的变量；不同的处理器架构提供了不同的同步和顺序设施。例如，在 x86 和 x86-64 架构上，原子加载操作总是相同的，无论标记为 memory_order_relaxed 还是 memory_order_seq_cst(参见第 5.3.3 节)。这意味着使用宽松内存顺序编写的代码可以在 x86 架构的系统上工作，而在使用更细粒度内存顺序指令(如 SPARC)的系统上就会失败。<br />
</p>

<p>
如果需要你的应用程序可以跨一系列目标系统移植，那么在这些系统的代表性实例上测试它是很重要的。这就是为什么我在 11.2.2 节中将用于测试的处理器架构列为要考虑的问题。<br />
</p>

<p>
避免潜在的错误信心是成功的蛮力测试的关键。这需要仔细考虑测试设计，不仅要考虑到被测试代码单元的选择，还要考虑到测试工具的设计和测试环境的选择。你需要确保尽可能多地测试代码路径和可能的线程交互。不仅如此，还需要知道哪些选项覆盖了，哪些选项未被测试。<br />
</p>

<p>
尽管暴力测试确实让你对代码有了一定程度的信心，但它不能保证找到所有的问题。有一种技术可以保证找到问题，如果你有时间将其应用于你的代码和合适的软件的话。我称之为组合模拟测试（combination simulation testing）。<br />
</p>
</div>
</div>
<div id="outline-container-orgac823a5" class="outline-6">
<h6 id="orgac823a5">COMBINATION SIMULATION TESTING</h6>
<div class="outline-text-6" id="text-orgac823a5">
<p>
这有点拗口，所以我会解释我的意思。其理念是使用一个特殊的软件来运行代码，该软件模拟代码的真实运行环境。你可能知道一些软件允许在一台物理计算机上运行多个虚拟机，这里虚拟机的特性和它的硬件是通过监测软件来模拟的。这里的思想是类似的，除了不是模拟系统，模拟软件记录来自每个线程的数据访问、锁和原子操作的序列。然后，它使用 C++内存模型的规则对每一个允许的操作组合重复运行，并识别竞争条件和死锁。<br />
</p>

<p>
虽然这个详尽的组合测试保证找到所有系统设计用于检测的问题，但除了最简单的程序，它将花费大量的时间，因为组合的数量随着线程的数量和每个线程执行的操作的数量呈指数增加。这种技术最好用于对个别代码片段进行细粒度测试，而不是整个应用程序。另一个明显的缺点是，它依赖于模拟软件（可以处理代码中使用的操作）的可用性。<br />
</p>

<p>
因此，你有一种技术，它涉及到在正常条件下多次运行你的测试，但可能会遗漏问题，并且你有一种技术，涉及到在特殊条件下多次运行你的测试，但更有可能发现存在的任何问题。还有其他选择吗？<br />
</p>

<p>
第三种选择是使用一个库，在运行测试时检测问题。<br />
</p>
</div>
</div>
<div id="outline-container-org5b84a69" class="outline-6">
<h6 id="org5b84a69">DETECTING PROBLEMS EXPOSED BY TESTS WITH A SPECIAL LIBRARY</h6>
<div class="outline-text-6" id="text-org5b84a69">
<p>
尽管这个选项没有提供组合模拟测试的详尽检查，但是可以通过使用库同步原语(如互斥锁、锁和条件变量)的特殊实现来识别许多问题。例如，通常要求对共享数据块的所有访问都要锁住一个特定的互斥锁。如果可以检查访问数据时锁住了哪些互斥锁，就可以验证访问数据时调用线程确实锁住了适当的互斥锁，如果不是这样，就报告失败。通过以某种方式标记共享数据，可以允许库为你检查这一点。<br />
</p>

<p>
如果一个特定线程同时持有多个互斥锁，这个库实现还可以记录锁的序列。如果另一个线程以不同的顺序锁住了相同的互斥锁，那么即使测试在运行时没有死锁，这也可能被记录为潜在的死锁。<br />
</p>

<p>
在测试多线程代码时，可以使用另一种类型的专用库，这个库的线程原语(如互斥锁和条件变量)的实现让测试的作者控制当多个线程正在等待时哪个线程获得锁，或者哪个线程被条件变量上的 notify_one()调用通知。这将允许你建立特定的场景，并验证你的代码在这些场景中是否按照预期工作。<br />
</p>

<p>
其中一些测试设施作为 C++标准库实现的一部分提供，而其他测试设施可以构建在标准库之上，作为你测试工具的一部分。<br />
</p>

<p>
在了解了执行测试代码的各种方法之后，现在让我们看看构建代码以实现你想要的调度的方法。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org79b1cb1" class="outline-5">
<h5 id="org79b1cb1">Structuring multithreaded test code (373)</h5>
<div class="outline-text-5" id="text-org79b1cb1">
<p>
回到 11.2.2 节中，我说过为测试“同时”的部分你需要找到方法来提供适当的调度。现在是时候看看其中涉及的问题了。<br />
</p>

<p>
基本问题是，你需要安排一组线程，每个线程在指定的时间执行选定的代码段。在最基本的情况下，你有两个线程，但这可以很容易地扩展到更多线程。在第一步中，你需要确定每个测试的不同部分：<br />
</p>

<ul class="org-ul">
<li>必须在任何操作之前执行的通用设置代码<br /></li>
<li>必须在每个线程上运行的线程特定的设置代码<br /></li>
<li>你希望为每个线程并发运行的代码<br /></li>
<li>要在并发执行完成后运行的代码，可能包括对代码状态的断言<br /></li>
</ul>

<p>
为了进一步解释，让我们考虑 11.2.2 节测试列表中的一个具体示例：一个线程在空队列上调用 push()，同时另一个线程调用 pop()。<br />
</p>

<p>
通用设置代码比较简单：必须创建队列。执行 pop()的线程没有线程特定的设置代码。执行 push()的线程的线程特定的设置代码取决于队列的接口和所存储的对象类型。如果要存储对象的构造成本很高，或者必须进行堆分配，那么你希望将此作为线程特定的设置的一部分，这样就不会影响测试。另一方面，如果队列只是存储普通的 int，那么在设置代码中构造 int 并不能获得任何好处。被测试的代码相对简单——从一个线程调用 push()，从另一个线程调用 pop()——但“完成后”的代码呢？<br />
</p>

<p>
在本例中，这取决于你希望 pop()做什么。如果它应该在有数据之前阻塞，那么显然你希望看到返回的数据是提供给 push()调用的数据，并且之后队列为空。如果 pop()不是阻塞的，并且即使队列是空的也可以完成，那么你需要测试两种可能：要么 pop()返回提供给 push()的数据项并且队列为空，要么 pop()表示没有数据，并且队列有一个元素。其中一个必须为真；你想要避免的场景是 pop()示意了“没有数据”但是队列是空的，或者 pop()返回了值，队列仍然非空。为了简化测试，假设你有一个阻塞的 pop()。因此，最终的代码是一个断言，即弹出的值是推入的值，且队列为空。<br />
</p>

<p>
现在，在确定了不同的代码块之后，你需要尽最大努力确保一切都按计划运行。一种方法是当一切准备就绪时，使用一组 std::promise 来指示。每个线程都设置一个 promise 来表示它已经准备好了，然后等待从第三个 std::promise 获得的 std::shared_future（拷贝）；主线程等待来自所有线程的所有 promise 被设置，然后触发线程开始（go）。这可以确保每个线程都已经启动，并且出现在应该并发运行的代码块之前；任何线程特定的设置都应该在设置那个线程的承诺之前完成。最后，主线程等待线程完成并检查最终状态。你还需要注意异常，并确保当开始（go）信号不会发生的时候，没有任何线程会等待这个信号。下面的清单显示了构建这个测试的一种方法。<br />
</p>

<p>
<a id="org937a81e"></a> 对一个队列并发调用 push()和 pop()的测试用例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">test_concurrent_push_and_pop_on_empty_queue</span>()
{
    <span style="color: #ce537a; font-weight: bold;">threadsafe_queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">q</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1</span>

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">promise</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">go</span>,<span style="color: #7590db;">push_ready</span>,<span style="color: #7590db;">pop_ready</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">shared_future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">ready</span>(go.get_future());  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3</span>

    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>&gt; <span style="color: #7590db;">push_done</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4</span>
    <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">future</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>&gt; <span style="color: #7590db;">pop_done</span>;

    <span style="color: #4f97d7; font-weight: bold;">try</span>
    {
        push_done=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">5</span>
                             [&amp;<span style="color: #7590db;">q</span>,<span style="color: #a45bad;">ready</span>,&amp;<span style="color: #7590db;">push_ready</span>]()
                             {
                                 push_ready.set_value();
                                 ready.wait();
                                 q.push(42);
                             }
            );

        pop_done=<span style="color: #a45bad;">std</span>::async(<span style="color: #a45bad;">std</span>::<span style="color: #a45bad;">launch</span>::async,  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">6</span>
                            [&amp;<span style="color: #7590db;">q</span>,<span style="color: #a45bad;">ready</span>,&amp;<span style="color: #7590db;">pop_ready</span>]()
                            {
                                pop_ready.set_value();
                                ready.wait();
                                <span style="color: #4f97d7; font-weight: bold;">return</span> q.pop();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">7</span>
                            }
            );

        push_ready.get_future().wait();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">8</span>
        pop_ready.get_future().wait();
        go.set_value();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">9</span>

        push_done.get();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">10</span>
        assert(pop_done.get()==42);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">11</span>
        assert(q.empty());
    }
    <span style="color: #4f97d7; font-weight: bold;">catch</span>(...)
    {
        go.set_value();  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">12</span>
        <span style="color: #4f97d7; font-weight: bold;">throw</span>;
    }
}
</pre>
</div>
<p>
代码结构与前面描述的基本相同。首先，创建空队列作为通用设置的一部分①。然后，为“就绪”信号创建所有承诺②，并且为 go 信号获取一个 std::shared_future③。再后，创建 future 用来表示线程已经结束④。这些都必须放在 try 块外面，这样你就可以在异常上设置 go 信号，而不必等待测试线程完成(这将导致死锁——测试代码中的死锁并不理想)。<br />
</p>

<p>
然后在 try 块中可以启动线程⑤和⑥——使用 std::launch::async 保证每个任务运行在自己的线程上。注意，使用 std::async 使异常安全任务比使用普通的 std::thread 更容易，因为 future 的析构函数将会连接线程。lambda 捕获指定了每个任务将引用队列和用于通知就绪的 promise，同时使用一个从 go 变量中获得的 ready 变量的拷贝。<br />
</p>

<p>
如前所述，每个任务设置自己的就绪信号，然后在运行测试代码之前等待通用的 ready 信号。主线程则执行相反的操作——在信号通知他们开始真正的测试之前⑨，它等待来自两个线程的信号⑧。<br />
</p>

<p>
最后，主线程在来自异步调用的 future 上调用 get()来等待任务结束⑩⑪，并检查结果。注意 pop 任务通过 future 返回检索值⑦，所以你可以使用它来为断言获取结果⑪。<br />
</p>

<p>
如果有异常抛出，可以设置 go 信号，以避免出现悬垂线程，并重新抛出异常⑫。任务对应的 future④最后声明，所以它们首先被销毁，并且如果它们还没有就绪，它们的析构函数会等待任务完成。<br />
</p>

<p>
尽管为了测试两个简单的调用，这似乎是相当多的样板，但为了有最好的时机测试你想要测试的内容，使用类似的东西是有必要的。例如，启动一个线程可能是一个非常耗时的过程，所以如果你没有让线程等待 go 信号，那么 push 线程可能在 pop 线程开始之前就已经完成了，这将完全违背测试的目的。以这种方式使用 future 可以确保两个线程在同一个 future 上运行和阻塞。解除阻塞的 future 允许两个线程运行。一旦你熟悉了这个结构，在相同的模式中创建新的测试应该是相对简单的。对于需要两个以上线程的测试，这个模式很容易扩展到额外的线程。<br />
</p>

<p>
到目前为止，我们一直在研究多线程代码的正确性。尽管这是最重要的问题，但它不是你进行测试的唯一原因：测试多线程代码的性能也很重要，所以让我们接下来看看这个问题。<br />
</p>
</div>
</div>
<div id="outline-container-org4288bfb" class="outline-5">
<h5 id="org4288bfb">Testing the performance of multithreaded code (375)</h5>
<div class="outline-text-5" id="text-org4288bfb">
<p>
选择在应用程序中使用并发的主要原因之一是利用越来越流行的多核处理器来提高应用程序的性能。因此，正如你对任何其他优化尝试所做的那样，测试你的代码来确定性能确实提高了就很重要。<br />
</p>

<p>
为了提高性能而使用并发的一个特殊问题是可扩展性——在其他条件相同的情况下，你希望代码在 24 核机器上的运行速度大约是单核机器的 24 倍，或者处理的数据大约是单核机器的 24 倍。你不希望代码在双核机器上运行速度是单核机器的两倍，但在 24 核机器上运行速度更慢。正如在 8.4.2 节中看到的，如果代码的重要部分只在一个线程上运行，这可能会限制潜在的性能增益。因此，在开始测试之前，有必要看一下代码的整体设计，这样你就知道是有希望得到 24 倍的改进，还是代码的串行部分意味着你被限制在 3 倍的最大值。<br />
</p>

<p>
正如你在前面的章节中已经看到的，处理器之间竞争访问数据结构可能会对性能产生很大的影响。当处理器数量很小时，可以很好地随处理器数量扩展的东西，在当处理器数量很大时，可能由于竞争的大量增加表现得很差。<br />
</p>

<p>
因此，在测试多线程代码的性能时，最好在具有尽可能多不同配置的系统上检查性能，这样你就可以对可扩展性做到心中有数。至少，你应该在一个单处理器系统和一个拥有尽可能多的处理核的系统上进行测试。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3bc08f6" class="outline-2">
<h2 id="org3bc08f6">c++ 多线程编程</h2>
<div class="outline-text-2" id="text-org3bc08f6">
</div>
<div id="outline-container-orgb49f7d3" class="outline-3">
<h3 id="orgb49f7d3">实例分析</h3>
<div class="outline-text-3" id="text-orgb49f7d3">
</div>
<div id="outline-container-org37146c6" class="outline-4">
<h4 id="org37146c6">cocos2dx CCTextureCache 多线程使用</h4>
<div class="outline-text-4" id="text-org37146c6">
<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20027;&#32447;&#31243;&#35843;&#29992;&#19979;&#38754;&#20989;&#25968;&#65292;&#35831;&#27714;&#24322;&#27493;&#21152;&#36733;&#22270;&#29255;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#35831;&#27714;&#23553;&#35013;&#20026; AsyncStruct &#23545;&#35937;&#25918;&#20837;&#38431;&#21015; _asyncStructQueue&#65288;&#23545;&#35813;&#38431;&#21015;&#30340;&#25805;&#20316;&#38656;&#35201;&#20351;&#29992;&#20114;&#26021;&#37327;&#21152;&#38145;&#65289;&#20013;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">_sleepCondition.notify_one() &#36890;&#30693;&#24037;&#20316;&#23376;&#32447;&#31243;&#65292;&#24320;&#22987;&#24322;&#27493;&#21152;&#36733;&#22270;&#29255;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">TextureCache</span>::<span style="color: #bc6ec5; font-weight: bold;">addImageAsync</span>(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> &amp;<span style="color: #7590db;">path</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">function</span>&lt;<span style="color: #ce537a; font-weight: bold;">void</span>(<span style="color: #ce537a; font-weight: bold;">Texture2D</span>*)&gt;&amp; <span style="color: #7590db;">callback</span>)
  {
      <span style="color: #ce537a; font-weight: bold;">Texture2D</span> *<span style="color: #7590db;">texture</span> = <span style="color: #a45bad;">nullptr</span>;

      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">fullpath</span> = <span style="color: #a45bad;">FileUtils</span>::getInstance()-&gt;fullPathForFilename(path);

      <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">it</span> = _textures.find(fullpath);
      <span style="color: #4f97d7; font-weight: bold;">if</span>( it != _textures.end() )
          texture = it-&gt;second;

      <span style="color: #4f97d7; font-weight: bold;">if</span> (texture != <span style="color: #a45bad;">nullptr</span>)
      {
          callback(texture);
          <span style="color: #4f97d7; font-weight: bold;">return</span>;
      }

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lazy init</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span> (_asyncStructQueue == <span style="color: #a45bad;">nullptr</span>)
      {
          _asyncStructQueue = <span style="color: #4f97d7; font-weight: bold;">new</span> queue&lt;<span style="color: #ce537a; font-weight: bold;">AsyncStruct</span>*&gt;();
          _imageInfoQueue   = <span style="color: #4f97d7; font-weight: bold;">new</span> deque&lt;<span style="color: #ce537a; font-weight: bold;">ImageInfo</span>*&gt;();

          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a new thread to load images</span>
          _loadingThread = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">thread</span>(&amp;<span style="color: #a45bad;">TextureCache</span>::loadImage, <span style="color: #4f97d7; font-weight: bold;">this</span>);

          _needQuit = <span style="color: #a45bad;">false</span>;
      }

      <span style="color: #4f97d7; font-weight: bold;">if</span> (0 == _asyncRefCount)
      {
          <span style="color: #a45bad;">Director</span>::getInstance()-&gt;getScheduler()-&gt;schedule(CC_SCHEDULE_SELECTOR(<span style="color: #a45bad;">TextureCache</span>::addImageAsyncCallBack), <span style="color: #4f97d7; font-weight: bold;">this</span>, 0, <span style="color: #a45bad;">false</span>);
      }

      ++_asyncRefCount;

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">generate async struct</span>
      <span style="color: #ce537a; font-weight: bold;">AsyncStruct</span> *<span style="color: #7590db;">data</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> (<span style="color: #a45bad;">std</span>::nothrow) <span style="color: #ce537a; font-weight: bold;">AsyncStruct</span>(fullpath, callback);

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">add async struct into queue</span>
      _asyncStructQueueMutex.lock();
      _asyncStructQueue-&gt;push(data);
      _asyncStructQueueMutex.unlock();

      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">_sleepCondition &#30340;&#31867;&#22411;&#20026; std::condition_variable</span>
      _sleepCondition.notify_one();
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24037;&#20316;&#32447;&#31243;&#65292;&#21028;&#26029;_asyncStructQueue &#20013;&#26159;&#21542;&#20026;&#31354;&#65292;&#22914;&#26524;&#31354;&#65292;&#21017;&#35843;&#29992;_sleepCondition.wait(lk)&#25346;&#36215;&#31561;&#24453;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#20027;&#32447;&#31243;&#23558;&#24037;&#20316;&#32447;&#31243;&#21796;&#37266;&#21518;&#65292;&#24037;&#20316;&#32447;&#31243;&#24320;&#22987;&#21152;&#36733;&#22270;&#29255;&#65292;&#21152;&#36733;&#23436;&#25104;&#21518;&#65292;&#23558;&#22270;&#29255;&#20449;&#24687;&#25918;&#21040;_imageInfoQueue &#38431;&#21015;&#20013;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">TextureCache</span>::<span style="color: #bc6ec5; font-weight: bold;">loadImage</span>()
  {
      <span style="color: #ce537a; font-weight: bold;">AsyncStruct</span> *<span style="color: #7590db;">asyncStruct</span> = <span style="color: #a45bad;">nullptr</span>;

      <span style="color: #4f97d7; font-weight: bold;">while</span> (<span style="color: #a45bad;">true</span>)
      {
          <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">queue</span>&lt;<span style="color: #ce537a; font-weight: bold;">AsyncStruct</span>*&gt; *<span style="color: #7590db;">pQueue</span> = _asyncStructQueue;
          _asyncStructQueueMutex.lock();
          <span style="color: #4f97d7; font-weight: bold;">if</span> (pQueue-&gt;empty())
          {
              _asyncStructQueueMutex.unlock();
              <span style="color: #4f97d7; font-weight: bold;">if</span> (_needQuit) {
                  <span style="color: #4f97d7; font-weight: bold;">break</span>;
              }
              <span style="color: #4f97d7; font-weight: bold;">else</span> {
                  <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">unique_lock</span>&lt;<span style="color: #a45bad;">std</span>::mutex&gt; <span style="color: #7590db;">lk</span>(_sleepMutex);
                  _sleepCondition.wait(lk);
                  <span style="color: #4f97d7; font-weight: bold;">continue</span>;
              }
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          {
              asyncStruct = pQueue-&gt;front();
              pQueue-&gt;pop();
              _asyncStructQueueMutex.unlock();
          }

          <span style="color: #ce537a; font-weight: bold;">Image</span> *<span style="color: #7590db;">image</span> = <span style="color: #a45bad;">nullptr</span>;
          <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">generateImage</span> = <span style="color: #a45bad;">false</span>;

          <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">it</span> = _textures.find(asyncStruct-&gt;filename);
          <span style="color: #4f97d7; font-weight: bold;">if</span>( it == _textures.end() )
          {
              _imageInfoMutex.lock();
              <span style="color: #ce537a; font-weight: bold;">ImageInfo</span> *<span style="color: #7590db;">imageInfo</span>;
              <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">pos</span> = 0;
              <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #7590db;">infoSize</span> = _imageInfoQueue-&gt;size();
              <span style="color: #4f97d7; font-weight: bold;">for</span> (; pos &lt; infoSize; pos++)
              {
                  imageInfo = (*_imageInfoQueue)[pos];
                  <span style="color: #4f97d7; font-weight: bold;">if</span>(imageInfo-&gt;asyncStruct-&gt;filename.compare(asyncStruct-&gt;filename) == 0)
                      <span style="color: #4f97d7; font-weight: bold;">break</span>;
              }
              _imageInfoMutex.unlock();
              <span style="color: #4f97d7; font-weight: bold;">if</span>(infoSize == 0 || pos == infoSize)
                  generateImage = <span style="color: #a45bad;">true</span>;
          }

          <span style="color: #4f97d7; font-weight: bold;">if</span> (generateImage)
          {
              <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&amp; <span style="color: #7590db;">filename</span> = asyncStruct-&gt;filename;
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">generate image</span>
              image = <span style="color: #4f97d7; font-weight: bold;">new</span> (<span style="color: #a45bad;">std</span>::nothrow) <span style="color: #ce537a; font-weight: bold;">Image</span>();
              <span style="color: #4f97d7; font-weight: bold;">if</span>(image){
                  <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #a45bad;">!</span>image-&gt;initWithImageFileThreadSafe(filename))
                  {
                      CC_SAFE_RELEASE(image);
                      image = <span style="color: #a45bad;">nullptr</span>;
                      CCLOG(<span style="color: #2d9574;">"can not load %s"</span>, filename.c_str());
                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">@yuxiaofei, whether success or not, send main thread message</span>
                      <span style="color: #2aa1ae; background-color: #292e34;">//                </span><span style="color: #2aa1ae; background-color: #292e34;">continue;</span>
                  }
                  <span style="color: #4f97d7; font-weight: bold;">else</span>{
                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">load success, try load sub image for pvr file</span>
                      <span style="color: #4f97d7; font-weight: bold;">if</span> (filename.size() &gt; 4 &amp;&amp;
                          filename[filename.size() - 4] == <span style="color: #2d9574;">'.'</span> &amp;&amp;
                          filename[filename.size() - 3] == <span style="color: #2d9574;">'p'</span> &amp;&amp;
                          filename[filename.size() - 2] == <span style="color: #2d9574;">'v'</span> &amp;&amp;
                          filename[filename.size() - 1] == <span style="color: #2d9574;">'r'</span>) {
                          <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">subTexPath</span> = filename;
                          subTexPath.insert(subTexPath.size() - 4, <span style="color: #2d9574;">".alpha"</span>);

                          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">check if sub tex exist</span>
                          <span style="color: #ce537a; font-weight: bold;">Image</span>* <span style="color: #7590db;">subImage</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> (<span style="color: #a45bad;">std</span>::nothrow) <span style="color: #ce537a; font-weight: bold;">Image</span>();
                          <span style="color: #4f97d7; font-weight: bold;">if</span> (subImage) {
                              <span style="color: #a45bad;">cocos2d</span>::log(<span style="color: #2d9574;">"addImage load sub image %s"</span>, subTexPath.c_str());

                              <span style="color: #4f97d7; font-weight: bold;">if</span>(subImage-&gt;initWithImageFile(subTexPath)){
                                  image-&gt;setSubImage(subImage);
                                  <span style="color: #2aa1ae; background-color: #292e34;">//                                </span><span style="color: #2aa1ae; background-color: #292e34;">Texture2D* subTex = new (std::nothrow) Texture2D();</span>
                                  <span style="color: #2aa1ae; background-color: #292e34;">//                                </span><span style="color: #2aa1ae; background-color: #292e34;">subTex-&gt;autorelease();</span>
                                  <span style="color: #2aa1ae; background-color: #292e34;">//                                </span><span style="color: #2aa1ae; background-color: #292e34;">if (subTex-&gt;initWithImage(subImage)) {</span>
                                  <span style="color: #2aa1ae; background-color: #292e34;">//                                    </span><span style="color: #2aa1ae; background-color: #292e34;">texture-&gt;setSubTexture(subTex);</span>
                                  <span style="color: #2aa1ae; background-color: #292e34;">//                                </span><span style="color: #2aa1ae; background-color: #292e34;">}</span>
                              }
                              CC_SAFE_RELEASE(subImage);
                          }
                      }

                  }
              }
          }

          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">generate image info</span>
          <span style="color: #ce537a; font-weight: bold;">ImageInfo</span> *<span style="color: #7590db;">imageInfo</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> (<span style="color: #a45bad;">std</span>::nothrow) <span style="color: #ce537a; font-weight: bold;">ImageInfo</span>();
          imageInfo-&gt;asyncStruct = asyncStruct;
          imageInfo-&gt;image = image;

          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">put the image info into the queue</span>
          _imageInfoMutex.lock();
          _imageInfoQueue-&gt;push_back(imageInfo);
          _imageInfoMutex.unlock();
      }

      <span style="color: #4f97d7; font-weight: bold;">if</span>(_asyncStructQueue != <span style="color: #a45bad;">nullptr</span>)
      {
          <span style="color: #4f97d7; font-weight: bold;">delete</span> _asyncStructQueue;
          _asyncStructQueue = <span style="color: #a45bad;">nullptr</span>;
          <span style="color: #4f97d7; font-weight: bold;">delete</span> _imageInfoQueue;
          _imageInfoQueue = <span style="color: #a45bad;">nullptr</span>;
      }
  }

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20027;&#32447;&#31243;&#36890;&#36807; schedule &#26469;&#24490;&#29615;&#21028;&#26029;&#65292;&#26159;&#21542;&#26377;&#21152;&#36733;&#22909;&#30340;&#22270;&#29255;&#65292;&#22914;&#26524;&#26377;&#21017;&#35843;&#29992;&#23545;&#24212;&#30340;&#22238;&#35843;&#20989;&#25968;</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">TextureCache</span>::<span style="color: #bc6ec5; font-weight: bold;">addImageAsyncCallBack</span>(<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">dt</span>)
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the image is generated in loading thread</span>
      <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">deque</span>&lt;<span style="color: #ce537a; font-weight: bold;">ImageInfo</span>*&gt; *<span style="color: #7590db;">imagesQueue</span> = _imageInfoQueue;

      _imageInfoMutex.lock();
      <span style="color: #4f97d7; font-weight: bold;">if</span> (imagesQueue-&gt;empty())
      {
          _imageInfoMutex.unlock();
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          <span style="color: #ce537a; font-weight: bold;">ImageInfo</span> *<span style="color: #7590db;">imageInfo</span> = imagesQueue-&gt;front();
          imagesQueue-&gt;pop_front();
          _imageInfoMutex.unlock();

          <span style="color: #ce537a; font-weight: bold;">AsyncStruct</span> *<span style="color: #7590db;">asyncStruct</span> = imageInfo-&gt;asyncStruct;
          <span style="color: #ce537a; font-weight: bold;">Image</span> *<span style="color: #7590db;">image</span> = imageInfo-&gt;image;

          <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #a45bad;">std</span>::<span style="color: #ce537a; font-weight: bold;">string</span>&amp; <span style="color: #7590db;">filename</span> = asyncStruct-&gt;filename;

          <span style="color: #ce537a; font-weight: bold;">Texture2D</span> *<span style="color: #7590db;">texture</span> = <span style="color: #a45bad;">nullptr</span>;
          <span style="color: #4f97d7; font-weight: bold;">if</span> (image)
          {
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">generate texture in render thread</span>
              texture = <span style="color: #4f97d7; font-weight: bold;">new</span> (<span style="color: #a45bad;">std</span>::nothrow) <span style="color: #ce537a; font-weight: bold;">Texture2D</span>();

              texture-&gt;initWithImage(image);

<span style="color: #bc6ec5;">  #if</span> CC_ENABLE_CACHE_TEXTURE_DATA
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cache the texture file name</span>
              <span style="color: #a45bad;">VolatileTextureMgr</span>::addImageTexture(texture, filename);
<span style="color: #bc6ec5;">  #endif</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cache the texture. retain it, since it is added in the map</span>
              _textures.insert( <span style="color: #a45bad;">std</span>::make_pair(filename, texture) );
              texture-&gt;retain();

              texture-&gt;autorelease();
          }
          <span style="color: #4f97d7; font-weight: bold;">else</span>
          {
              <span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #7590db;">it</span> = _textures.find(asyncStruct-&gt;filename);
              <span style="color: #4f97d7; font-weight: bold;">if</span>(it != _textures.end())
                  texture = it-&gt;second;
          }

          <span style="color: #4f97d7; font-weight: bold;">if</span> (asyncStruct-&gt;callback)
          {
              asyncStruct-&gt;callback(texture);
          }

          <span style="color: #4f97d7; font-weight: bold;">if</span>(image)
          {
              image-&gt;release();
          }
          <span style="color: #4f97d7; font-weight: bold;">delete</span> asyncStruct;
          <span style="color: #4f97d7; font-weight: bold;">delete</span> imageInfo;

          --_asyncRefCount;
          <span style="color: #4f97d7; font-weight: bold;">if</span> (0 == _asyncRefCount)
          {
              <span style="color: #a45bad;">Director</span>::getInstance()-&gt;getScheduler()-&gt;unschedule(CC_SCHEDULE_SELECTOR(<span style="color: #a45bad;">TextureCache</span>::addImageAsyncCallBack), <span style="color: #4f97d7; font-weight: bold;">this</span>);
          }
      }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org0b3124d" class="outline-4">
<h4 id="org0b3124d">semaphore 信号量的实现</h4>
<div class="outline-text-4" id="text-org0b3124d">
<p>
信号量允许主线程和子线程进行同步。<br />
</p>

<p>
以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。<br />
在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。<br />
</p>

<p>
<a href="https://stackoverflow.com/questions/4792449/c0x-has-no-semaphores-how-to-synchronize-threads">https://stackoverflow.com/questions/4792449/c0x-has-no-semaphores-how-to-synchronize-threads</a><br />
<a href="https://segmentfault.com/a/1190000006818772">https://segmentfault.com/a/1190000006818772</a><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">&lt;mutex&gt;</span>
<span style="color: #bc6ec5;">  #include</span> <span style="color: #2d9574;">&lt;condition_variable&gt;</span>

  <span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">Semaphore</span> {
   <span style="color: #a45bad;">public</span>:
      Semaphore (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">count_</span> = 0) : count(count_) {}

      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">release</span>()
      {
          std::unique_lock&lt;std::mutex&gt; lock(mtx);
          count++;
          cv.notify_one();
      }

      <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">acquire</span>()
      {
          std::unique_lock&lt;std::mutex&gt; lock(mtx);

          <span style="color: #4f97d7; font-weight: bold;">while</span>(count == 0){
              cv.wait(lock);
          }
          count--;
      }

   <span style="color: #a45bad;">private</span>:
      std::mutex mtx;
      std::condition_variable cv;
      <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">count</span>;
  };
</pre>
</div>
</div>
</div>
<div id="outline-container-org4ced0a6" class="outline-4">
<h4 id="org4ced0a6">多线程下载文件</h4>
<div class="outline-text-4" id="text-org4ced0a6">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">dw hh_HttpClient.h</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Send &#30340;&#26102;&#20505;&#65292;&#23558; HttpRequest &#25918;&#20837; s_requestQueue &#20013;,&#28982;&#21518;&#65292;&#36890;&#36807;&#20449;&#21495;&#37327;&#36890;&#30693;&#24037;&#20316;&#32447;&#31243;&#24037;&#20316;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">HttpClient</span>::Send( <span style="color: #ce537a; font-weight: bold;">HttpRequest</span>* <span style="color: #7590db;">pRequest</span> )
{
    <span style="color: #4f97d7; font-weight: bold;">if</span>(s_pSem == <span style="color: #a45bad;">NULL</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> ;
    <span style="color: #4f97d7; font-weight: bold;">if</span> ( pRequest == <span style="color: #a45bad;">NULL</span> ) <span style="color: #4f97d7; font-weight: bold;">return</span>;

    s_requestQueueMutex.lock();
    s_requestQueue.push_back( pRequest );
    s_requestQueueMutex.unlock();

    s_pSem-&gt;signal();
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#65292;&#24037;&#20316;&#32447;&#31243;&#35843;&#29992; s_pSem-&gt;wait()&#20808;&#30452;&#25509;&#38459;&#22622;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34987;&#20027;&#32447;&#31243;&#21796;&#37266;&#21518;&#65292;&#24037;&#20316;&#32447;&#31243;&#20174; s_requestQueue &#20013;&#21462;&#20986;&#19968;&#20010; Http &#35831;&#27714;&#36827;&#34892;&#22788;&#29702;,&#22788;&#29702;&#23436;&#25104;&#21518;&#65292;&#23558;&#23545;&#24212;&#30340; response &#25918;&#20837; s_responseQueue &#20013;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">HttpClient</span>::NetworkThread(  )
{
    <span style="color: #ce537a; font-weight: bold;">char</span> <span style="color: #7590db;">bufferError</span>[128] = {0};
    <span style="color: #ce537a; font-weight: bold;">HttpRequest</span>* <span style="color: #7590db;">request</span> = <span style="color: #a45bad;">NULL</span>;

    <span style="color: #4f97d7; font-weight: bold;">while</span> (<span style="color: #a45bad;">true</span>)
    {
        s_pSem-&gt;wait();
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( need_quit ) <span style="color: #4f97d7; font-weight: bold;">break</span>;

        request = <span style="color: #a45bad;">NULL</span>;
        s_requestQueueMutex.lock();
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( s_requestQueue.size() &gt; 0 )
        {
            request = s_requestQueue.front();
            s_requestQueue.pop_front();
        }
        s_requestQueueMutex.unlock();

        <span style="color: #4f97d7; font-weight: bold;">if</span>( request == <span style="color: #a45bad;">NULL</span> ) <span style="color: #4f97d7; font-weight: bold;">continue</span>;
        <span style="color: #ce537a; font-weight: bold;">HttpResponse</span>* <span style="color: #7590db;">response</span> = new HttpResponse( request );

        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">responseCode</span> = -1, <span style="color: #7590db;">retValue</span> = 0;
        memset( s_errorBuffer, 0, <span style="color: #4f97d7; font-weight: bold;">sizeof</span>( s_errorBuffer ) );

        <span style="color: #4f97d7; font-weight: bold;">switch</span> ( request-&gt;GetType() )
        {
        <span style="color: #4f97d7; font-weight: bold;">case</span> HttpRequest::E_HTTP_GET:

            retValue = processGetTask(
                request,
                WriteData,
                (<span style="color: #ce537a; font-weight: bold;">void</span> *)response-&gt;GetResponseData(),
                &amp;responseCode );
            <span style="color: #4f97d7; font-weight: bold;">break</span>;

        <span style="color: #4f97d7; font-weight: bold;">case</span> HttpRequest::E_HTTP_POST:

            retValue = processPostTask(
                request,
                WriteData,
                (<span style="color: #ce537a; font-weight: bold;">void</span> *)response-&gt;GetResponseData(),
                &amp;responseCode );

            <span style="color: #4f97d7; font-weight: bold;">break</span>;

        <span style="color: #4f97d7; font-weight: bold;">default</span>:
            snprintf( bufferError , 128 ,<span style="color: #2d9574;">"HttpClient: Unknown request type[%d]"</span>, request-&gt;GetType() );
            DOWNLOAD_ERROR(  bufferError);
            IME_ERROR( bufferError);
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }
        response-&gt;SetResponseCode( responseCode );

        <span style="color: #4f97d7; font-weight: bold;">if</span> ( retValue != 0 )
        {
            response-&gt;SetSucceed( <span style="color: #a45bad;">false</span> );
            response-&gt;SetErrorMsg( s_errorBuffer );
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            response-&gt;SetSucceed( <span style="color: #a45bad;">true</span> );
        }


        s_responseQueueMutex.lock();
        s_responseQueue.push_back( response );
        s_responseQueueMutex.unlock();
    }

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">quit. cleanup here</span>

    s_responseQueueMutex.lock();
    <span style="color: #4f97d7; font-weight: bold;">for</span> ( std::list&lt; HttpResponse* &gt;::iterator it = s_responseQueue.begin();
          it != s_responseQueue.end(); ++it )
    {
        <span style="color: #ce537a; font-weight: bold;">delete</span> *<span style="color: #7590db;">it</span>;
    }
    s_responseQueue.clear();
    s_responseQueueMutex.unlock();


    s_requestQueueMutex.lock();
    <span style="color: #4f97d7; font-weight: bold;">for</span> ( std::list&lt; HttpRequest* &gt;::iterator it = s_requestQueue.begin();
          it != s_requestQueue.end(); ++it )
    {
        <span style="color: #ce537a; font-weight: bold;">delete</span> *<span style="color: #7590db;">it</span>;
    }
    s_requestQueue.clear();
    s_requestQueueMutex.unlock();

}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#20027;&#32447;&#31243;&#20013;&#65292;&#36890;&#36807; update &#26469;&#35843;&#29992;&#19979;&#38754;&#30340;&#26041;&#27861;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27599;&#27425;&#25191;&#34892;&#65292;&#20174; s_responseQueue &#20013;&#21462;&#20986;&#19968;&#20010; response&#65292;&#28982;&#21518;&#35843;&#29992;&#23545;&#24212;&#30340;&#22238;&#35843;&#20989;&#25968;&#36827;&#34892;&#22788;&#29702;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">HttpClient</span>::DispatchResponse()
{
    <span style="color: #ce537a; font-weight: bold;">HttpResponse</span>* <span style="color: #7590db;">response</span> = <span style="color: #a45bad;">NULL</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span>( need_quit <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">|| s_responseQueueMutex == NULL</span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>){
        <span style="color: #4f97d7; font-weight: bold;">return</span>;
    }

    <span style="color: #4f97d7; font-weight: bold;">while</span> ( <span style="color: #a45bad;">true</span> )
    {
        response = <span style="color: #a45bad;">NULL</span>;

        s_responseQueueMutex.lock();
        <span style="color: #4f97d7; font-weight: bold;">if</span> ( s_responseQueue.size() )
        {
            response = s_responseQueue.front();
            s_responseQueue.pop_front();
        }
        s_responseQueueMutex.unlock();

        <span style="color: #4f97d7; font-weight: bold;">if</span> ( response )
        {
            <span style="color: #ce537a; font-weight: bold;">HttpRequest</span>* <span style="color: #7590db;">request</span> = response-&gt;GetRequest();
            HttpRequest::ResponseCallback fctCallback = request-&gt;GetCallback();

            (*fctCallback)( request-&gt;GetTarget(), response );

            <span style="color: #ce537a; font-weight: bold;">delete</span> <span style="color: #7590db;">request</span>;
            <span style="color: #ce537a; font-weight: bold;">delete</span> <span style="color: #7590db;">response</span>;
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">break</span>;
        }

        <span style="color: #4f97d7; font-weight: bold;">if</span>( need_quit <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">|| s_responseQueueMutex == NULL</span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>){
            <span style="color: #4f97d7; font-weight: bold;">return</span>;
        }

    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org5a59cdc" class="outline-2">
<h2 id="org5a59cdc">参考资料</h2>
<div class="outline-text-2" id="text-org5a59cdc">
<ul class="org-ul">
<li>Cpp Concurrency in Action-2ed cn <a href="https://www.zhihu.com/column/c_1307735602880331776">https://www.zhihu.com/column/c_1307735602880331776</a><br /></li>
<li>Cpp Concurrency in Action-2ed Errata <a href="http://www.cplusplusconcurrencyinaction.com/errata.html">http://www.cplusplusconcurrencyinaction.com/errata.html</a><br /></li>
<li>Cpp Concurrency in Action 作者主页 <a href="https://www.justsoftwaresolutions.co.uk/blog/">https://www.justsoftwaresolutions.co.uk/blog/</a><br /></li>
<li><a href="https://github.com/taskflow/taskflow">https://github.com/taskflow/taskflow</a><br /></li>
<li><a href="https://taskflow.github.io/taskflow/index.html">https://taskflow.github.io/taskflow/index.html</a><br /></li>
<li>TaskFlow DAG 部分源码阅读 <a href="https://www.jianshu.com/p/12d416d37dd8">https://www.jianshu.com/p/12d416d37dd8</a><br /></li>
<li>cpp-taskflow 源码分析 <a href="https://blog.csdn.net/yockie/article/details/104190147">https://blog.csdn.net/yockie/article/details/104190147</a><br /></li>
<li>并发吹剑录（一）：CPU 缓存一致性协议 MESI <a href="https://zhuanlan.zhihu.com/p/351550104">https://zhuanlan.zhihu.com/p/351550104</a><br /></li>
<li>并发吹剑录（二）：指令重排序与内存屏障 <a href="https://zhuanlan.zhihu.com/p/359093580">https://zhuanlan.zhihu.com/p/359093580</a><br /></li>
<li>高并发编程&#x2013;多处理器编程中的一致性问题(上) <a href="https://zhuanlan.zhihu.com/p/48157076">https://zhuanlan.zhihu.com/p/48157076</a><br /></li>
<li>高并发编程&#x2013;多处理器编程中的一致性问题(下) <a href="https://zhuanlan.zhihu.com/p/48161056">https://zhuanlan.zhihu.com/p/48161056</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
