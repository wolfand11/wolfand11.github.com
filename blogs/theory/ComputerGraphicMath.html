<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-01 周二 23:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ComputerGraphicMath</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.gitee.io/res/blog-tools.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">ComputerGraphicMath</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga23382b">3D Math Primer for Graphics and Game Development</a>
<ul>
<li><a href="#org0013b09">Chapter1 Cartesian Coordinate Systems</a>
<ul>
<li><a href="#orge8ac554">3D Cartesian Space</a>
<ul>
<li><a href="#org115779c">Left-handed vs Right-handed Coordinate Spaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge89d13f">Chapter2 Vectors</a>
<ul>
<li><a href="#orgf01e2bd">Vector Cross Product</a></li>
</ul>
</li>
<li><a href="#org837826c">Chapter3 Multiple Coordinate Spaces</a></li>
<li><a href="#orge3e8fb6">Chapter4 Introduction to Matrix</a>
<ul>
<li><a href="#org92dc9c2">Matrix 的数学定义</a>
<ul>
<li><a href="#orgdc3f1a1">矩阵的维度和表示</a></li>
<li><a href="#orgb987458">Matrix 运算</a>
<ul>
<li><a href="#orgbcc7969">矩阵转置</a></li>
<li><a href="#orga2e4982">矩阵和标量相乘</a></li>
<li><a href="#orgb7d9354">矩阵乘矩阵</a></li>
<li><a href="#org32e802c">行向量和列向量对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8ef163a">矩阵的几何解释</a></li>
</ul>
</li>
<li><a href="#org804c1ae">Chapter5 Matrices and Linear Transformations</a>
<ul>
<li><a href="#orgdd6c558">Rotation</a>
<ul>
<li><a href="#org331ca98">Rotation in 2D</a></li>
<li><a href="#orgc530568">Rotaion in 3D</a></li>
</ul>
</li>
<li><a href="#org1244ce4">Scale</a></li>
<li><a href="#org29f1b61">Orthographic Projection</a></li>
<li><a href="#orgb068959">Reflection</a></li>
<li><a href="#org6568419">Shearing</a></li>
<li><a href="#org1750738">Combining Transformations</a></li>
<li><a href="#orgc13fe62">Classes of Transformations</a></li>
</ul>
</li>
<li><a href="#org33302af">Chapter6 More on Matrix</a>
<ul>
<li><a href="#orgee65fad">Determinant of a Matrix</a>
<ul>
<li><a href="#orgaf39711">Determinant of 2x2 and 3x3 matrices</a></li>
<li><a href="#org8f89bb3">Minors and Cofactors</a></li>
<li><a href="#orge0a41ff">Determinants of Arbitrary nxn Matrices</a></li>
<li><a href="#org4c39793">Geometric Interpretation of Determinant</a>
<ul>
<li><a href="#orgb11171b">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3bb5425">Inverse of a Matrix</a>
<ul>
<li><a href="#org6d00fab">The Classical Adjoint</a></li>
<li><a href="#org2602227">Matrix Inverse</a></li>
<li><a href="#org303551e">Matrix Inverse(Geometric Interpretation)</a></li>
</ul>
</li>
<li><a href="#orgfc1e7ce">Orthogonal Matrices</a></li>
<li><a href="#org97b6023">4x4 Homogeneous Matrices</a>
<ul>
<li><a href="#org19a1399">4x4 Translation Matrix</a></li>
</ul>
</li>
<li><a href="#org60c60b3">4x4 Matrices and Perspecitive Projection</a>
<ul>
<li><a href="#org6bb1f75">A Pinhole Camera</a></li>
<li><a href="#org24352a9">Perspective Projection Matrices</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaa58103">Chapter8 Rotation in Three Dimensions</a>
<ul>
<li><a href="#org0b4fce5">Orientation Vs Angular Displacement</a></li>
<li><a href="#org8d8130d">Matrix Form</a>
<ul>
<li><a href="#org901eb0a">矩阵形式的优点</a></li>
<li><a href="#org24ddfeb">矩阵形式的缺点</a></li>
</ul>
</li>
<li><a href="#orgfafaf67">Euler Angles</a>
<ul>
<li><a href="#orgfbf925e">EulerAngles 优点</a></li>
<li><a href="#org91e64ee">EulerAngles 缺点</a></li>
</ul>
</li>
<li><a href="#orgd307074">Axis-Angle And Exponential Map Representations</a></li>
<li><a href="#org387c6eb">Quaternions</a>
<ul>
<li><a href="#orge49bb26">Quaternions 和 Axis-Angle 的关系</a></li>
<li><a href="#org197aaed">Quaternions 的基本属性和操作</a>
<ul>
<li><a href="#orge87cae7">四元数取反</a></li>
<li><a href="#org818bfa4">单位四元数</a></li>
<li><a href="#org85d9d8b">四元数 Magnitude （模长）</a></li>
<li><a href="#org49ecd6d">四元数的共轭 四元数的逆</a></li>
<li><a href="#orga9aa59b">四元数乘法</a></li>
<li><a href="#orgd1fe5dd">四元数点积</a></li>
<li><a href="#orgaed9bdf">四元数 log exp(Exponential) power(Exponentiation) 标量的乘法</a></li>
</ul>
</li>
<li><a href="#org1586461">四元数 Slerp</a></li>
<li><a href="#org787544f">四元数优缺点</a>
<ul>
<li><a href="#orgf2f060e">优点</a></li>
<li><a href="#org9082583">缺点</a></li>
</ul>
</li>
<li><a href="#orgf9fa308">四元数和复数</a></li>
</ul>
</li>
<li><a href="#orge125208">Comparison of Methods</a>
<ul>
<li><a href="#org80fc49c">将点在坐标系之间转换 （物体和世界坐标系）</a></li>
<li><a href="#orgc1d23f4">串联旋转</a></li>
<li><a href="#orgef82201">旋转求逆</a></li>
<li><a href="#org5958c9c">插值</a></li>
<li><a href="#orgb6f00ba">易于人类理解</a></li>
<li><a href="#orga485890">存储效率</a></li>
<li><a href="#org48fbead">对与给定的旋转有唯一的表示</a></li>
<li><a href="#org65ae041">可能变为非法的表示</a></li>
</ul>
</li>
<li><a href="#org35f8d58">Converting between Representations</a>
<ul>
<li><a href="#org71aa2e6">EulerAngle 和 Matrix 之间的转换</a></li>
<li><a href="#org90a04ac">Quaternion 和 Matrix 之间的转换</a></li>
<li><a href="#orgefa32a4">Quaternion 和 EulerAngle 之间的转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org352697d">Chapter9 Geometric Primitives</a>
<ul>
<li><a href="#org7849c0c">Representation Techniques</a>
<ul>
<li><a href="#org958eecb">隐式方式</a></li>
<li><a href="#org7d14737">参数方式</a></li>
<li><a href="#org635b8a9">直接的方式</a></li>
<li><a href="#org5071b4d">Common</a></li>
</ul>
</li>
<li><a href="#orga99ef0d">Lines and Rays</a>
<ul>
<li><a href="#orgdd1b475">Rays</a></li>
<li><a href="#org4583531">Special 2D Representations of Lines</a></li>
<li><a href="#orgbe737fc">Converting between Representations</a></li>
</ul>
</li>
<li><a href="#org3d882f6">Planes</a>
<ul>
<li><a href="#org0c880ed">The Plane Equation: An Implicit Definition of a Plane</a></li>
<li><a href="#org5e698f0">Defining a Plane by Using Three Points</a></li>
<li><a href="#org8ec738c">Best Fit Plane for More than Three Points</a></li>
<li><a href="#orgeaf2573">Distance From Point to Plane</a></li>
</ul>
</li>
<li><a href="#org49a16f5">Triangles</a>
<ul>
<li><a href="#org564fb67">Notation</a></li>
<li><a href="#org19bb8da">Area of a Triangle</a>
<ul>
<li><a href="#org3d37eeb">已知三条边长求面积：使用 Heron 公式</a></li>
<li><a href="#orgf2cee1f">已知三顶点坐标求面积</a></li>
</ul>
</li>
<li><a href="#org9f697d8">Barycentric Space</a></li>
<li><a href="#org277a9bc">Calculating Barycentric Coordinates</a></li>
<li><a href="#org5395942">Special Points</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org506b5f0">Chapter10 Mathematical Topics from 3D Graphics</a>
<ul>
<li><a href="#org44fccab">How Graphics Work</a>
<ul>
<li><a href="#org6280fab">确定可见表面</a></li>
<li><a href="#orgb8667a4">确定光</a></li>
<li><a href="#org0fb5fe3">辐射度学和色度学</a></li>
<li><a href="#orgf29f919">渲染方程</a></li>
</ul>
</li>
<li><a href="#org57f1d43">Viewing in 3D</a>
<ul>
<li><a href="#org8c731ba">指定输出窗口</a></li>
<li><a href="#orged3492e">Pixel Aspect Ratio 像素宽高比</a></li>
<li><a href="#org8f0dfb4">The View Frustum 视景体</a></li>
<li><a href="#orgd6919fc">Field of View and Zoom</a></li>
<li><a href="#org6d8407c">Orthographic Projection</a></li>
</ul>
</li>
<li><a href="#org8b9f519">Coordinate Spaces</a>
<ul>
<li><a href="#org6f88059">Clip Space and the Clip Matrix</a></li>
<li><a href="#org001bf90">The Clip Matrix: Preparing For Projection</a>
<ul>
<li><a href="#org48d7355">透视投影矩阵</a></li>
<li><a href="#orge8dd22b">正交投影矩阵</a></li>
</ul>
</li>
<li><a href="#orgf8add3e">The Clip Matrix: Applying Zoom and Preparing for Clipping</a>
<ul>
<li><a href="#org7ba6545">透视投影矩阵</a></li>
<li><a href="#orgf657573">正交投影矩阵</a></li>
<li><a href="#orgbb83ed3">OpenGL 裁剪矩阵</a></li>
</ul>
</li>
<li><a href="#orgeafeea8">Screen Space</a>
<ul>
<li><a href="#orgac13f38">透视除法(NDC 坐标系)</a></li>
<li><a href="#org2d29c48">viewport 变换</a></li>
<li><a href="#org5e5e854">插值透视矫正</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5eb25fc">Polygon Meshes</a></li>
<li><a href="#org7a9d466">Texture Mapping</a></li>
<li><a href="#org129b40b">The Standard Local Lighting Model</a></li>
<li><a href="#orgc79ef61">Light Sources</a></li>
<li><a href="#orgec92fde">Skeletal Animation</a></li>
<li><a href="#orgce23a8b">Bump Mapping</a>
<ul>
<li><a href="#org3011ef4">Tangent Space</a></li>
<li><a href="#org40b1d1f">Calculating Tangent Space Basis Vectors</a></li>
</ul>
</li>
<li><a href="#orgae62e71">The RealTimeGraphics Pipeline</a></li>
</ul>
</li>
<li><a href="#org9a9c3db">Chapter13 Curves in 3D</a></li>
</ul>
</li>
<li><a href="#org40d7f7b">向量点乘</a></li>
<li><a href="#org7d59835">矩阵和线性变换</a>
<ul>
<li><a href="#org94efd50">变换物体和变换坐标系</a>
<ul>
<li><a href="#orga28e119">矩阵旋转变换实例</a></li>
<li><a href="#orgb0d9bf7">矩阵平移变换实例</a></li>
</ul>
</li>
<li><a href="#org58f58ba">投影变换</a>
<ul>
<li><a href="#orgcb0c2b1">投影变换推导</a></li>
<li><a href="#org279b750">投影变换及其逆变换推导</a>
<ul>
<li><a href="#org79dbe10">为什么离 near plane 越远，depth 精度越小？</a></li>
</ul>
</li>
<li><a href="#orga27ba87">Clip Space 是怎样的？</a></li>
<li><a href="#orgd5600c1">自己做深度剔除</a></li>
<li><a href="#org486a281">如何从深度缓冲区中重建世界空间位置?</a>
<ul>
<li><a href="#org1f406c1">使用投影矩阵逆矩阵</a></li>
<li><a href="#org2edaf21">使用摄像机</a></li>
</ul>
</li>
<li><a href="#orgd00821d">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd453ade">Clipping</a></li>
<li><a href="#org1aeb25f">参考资料</a></li>
</ul>
</div>
</div>
<p>
3D Math Primer for Graphics and Game Development, 2nd Edition 翻译。<br />
Mathematics for 3D Game Programming and Computer Graphics, 3rd Edition 翻译。<br />
</p>
<div class="HTML" id="orgec69dbb">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orga23382b" class="outline-2">
<h2 id="orga23382b">3D Math Primer for Graphics and Game Development</h2>
<div class="outline-text-2" id="text-orga23382b">
<p>
该部分内容，引用自《3D Math Primer for Graphics and Game Development, 2nd Edition》。<br />
</p>
<ul class="org-ul">
<li><a href="https://book.douban.com/subject/10471246/">https://book.douban.com/subject/10471246/</a><br /></li>
</ul>
</div>

<div id="outline-container-org0013b09" class="outline-3">
<h3 id="org0013b09">Chapter1 Cartesian Coordinate Systems</h3>
<div class="outline-text-3" id="text-org0013b09">
</div>
<div id="outline-container-orge8ac554" class="outline-4">
<h4 id="orge8ac554">3D Cartesian Space</h4>
<div class="outline-text-4" id="text-orge8ac554">
</div>
<div id="outline-container-org115779c" class="outline-5">
<h5 id="org115779c">Left-handed vs Right-handed Coordinate Spaces</h5>
<div class="outline-text-5" id="text-org115779c">

<div id="orgc88fc97" class="figure">
<p><img src="./ComputerGraphicMath/00_01_03_left_right_hand_rule.jpg" alt="00_01_03_left_right_hand_rule.jpg" /><br />
</p>
</div>

<p>
<a id="orgedd68e4"></a><br />
本书的默认惯例，坐标系为左手坐标系，向量为行向量。<br />
PhysicalBasedRendering  坐标系为左手坐标系，向量为列向量<br />
Direct 坐标系为左手坐标系，向量为行向量。<br />
OpenGL 坐标系为右手坐标系，向量为列向量。<br />
GRaster 坐标系为左手坐标系，向量为列向量。<br />
</p>

<p>
Unity 坐标系为左手坐标系。<br />
UE4   坐标系为左手坐标系。<br />
</p>

<ul class="org-ul">
<li><a href="#org32e802c">行向量和列向量对比</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge89d13f" class="outline-3">
<h3 id="orge89d13f">Chapter2 Vectors</h3>
<div class="outline-text-3" id="text-orge89d13f">
</div>
<div id="outline-container-orgf01e2bd" class="outline-4">
<h4 id="orgf01e2bd">Vector Cross Product</h4>
<div class="outline-text-4" id="text-orgf01e2bd">
<p>
向量叉积所得向量的方向和左右手坐标系有关。<br />
<img src="./ComputerGraphicMath/00_02_12_vector_cross.jpg" alt="00_02_12_vector_cross.jpg" /><br />
</p>

<ul class="org-ul">
<li>向量叉积 <a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF">https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org837826c" class="outline-3">
<h3 id="org837826c">Chapter3 Multiple Coordinate Spaces</h3>
</div>
<div id="outline-container-orge3e8fb6" class="outline-3">
<h3 id="orge3e8fb6">Chapter4 Introduction to Matrix</h3>
<div class="outline-text-3" id="text-orge3e8fb6">
</div>
<div id="outline-container-org92dc9c2" class="outline-4">
<h4 id="org92dc9c2">Matrix 的数学定义</h4>
<div class="outline-text-4" id="text-org92dc9c2">
</div>
<div id="outline-container-orgdc3f1a1" class="outline-5">
<h5 id="orgdc3f1a1">矩阵的维度和表示</h5>
<div class="outline-text-5" id="text-orgdc3f1a1">
<p>
在线性代数中，矩阵是一个矩形数据网格，这个网格由 rows 行 columns 列数字排列组成。<br />
</p>

<p>
下面是数学中矩阵的书面表示，其为 4x3 的矩阵(4 行 3 列)，矩阵通常使用大写字幕表示<br />
</p>
<pre class="example" id="orga4166e9">
    m11 m12 m13
M = m21 m22 m23
    m31 m32 m33
    m41 m42 m43
</pre>

<p>
当行数和列数相同时，称矩阵为方矩阵。如下 3x3 方阵：<br />
</p>
<pre class="example" id="org5f9815e">
m11 m12 m13
m21 m22 m23
m31 m32 m33
</pre>

<p>
方阵中行数和列数相同的元素被称为对角线元素。<br />
当方阵中除了对角线元素外其他元素都为 0，称这种方阵为对角方阵。如下 4x4 对角矩阵：<br />
</p>
<pre class="example" id="orga98f8fe">
3 0 0 0
0 1 0 0
0 0 5 0
0 0 0 1
</pre>

<p>
当对角方阵的对角线元素都为 1 时，称其为单位矩阵（记作 I）。如下 3x3 单位矩阵：<br />
</p>
<pre class="example" id="org8c38f46">
1 0 0 
0 1 0
0 0 1
</pre>
</div>
</div>

<div id="outline-container-orgb987458" class="outline-5">
<h5 id="orgb987458">Matrix 运算</h5>
<div class="outline-text-5" id="text-orgb987458">
</div>
<div id="outline-container-orgbcc7969" class="outline-6">
<h6 id="orgbcc7969">矩阵转置</h6>
<div class="outline-text-6" id="text-orgbcc7969">
<pre class="example" id="orgcbf2bc4">
=转置=&gt;
a b c    a d g j
d e f    b e h k
g h i    c f i l
j k l
</pre>
<p>
4x3 矩阵经过转置运算后变为 3x4 矩阵<br />
</p>
</div>
</div>
<div id="outline-container-orga2e4982" class="outline-6">
<h6 id="orga2e4982">矩阵和标量相乘</h6>
<div class="outline-text-6" id="text-orga2e4982">
<pre class="example" id="org0f86ef0">
       m11 m12 m13 m14    km11 km12 km13 km14
kM = k m21 m22 m23 m24 =  km21 km22 km23 km24
       m31 m32 m33 m34    km31 km32 km33 km34
</pre>
</div>
</div>
<div id="outline-container-orgb7d9354" class="outline-6">
<h6 id="orgb7d9354">矩阵乘矩阵</h6>
<div class="outline-text-6" id="text-orgb7d9354">
<p>
矩阵相乘运算方法如下，矩阵相乘需要两个矩阵的行数列数相匹配，第一个矩阵的列数必须和第二个矩阵的行数相同，否则两个矩阵无法相乘。<br />
<img src="./ComputerGraphicMath/20_03_26_matrixMul.png" alt="20_03_26_matrixMul.png" /><br />
</p>

<p>
下面是矩阵乘法运算满足的一些规则：<br />
<img src="./ComputerGraphicMath/04_02_MatrixMulRule.png" alt="04_02_MatrixMulRule.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org32e802c" class="outline-6">
<h6 id="org32e802c">行向量和列向量对比</h6>
<div class="outline-text-6" id="text-org32e802c">
<p>
同一个向量，被当作行向量和列向量时，与矩阵运算的结果不同。所以当涉及矩阵运算时，区别向量是行向量还是列向量很重要。如下面：<br />
</p>

<p>
向量[x, y, z]做为行向量时，矩阵每一行对应变换后新坐标空间的基向量(使用当前坐标系表示)，平移量在第 4 行。<br />
</p>
<pre class="example" id="orgb1d2a41">
           m11 m12 m13
[x, y, z]  m21 m22 m23  =  [xm11+ym21+zm31, xm12+ym22+zm32, xm13+ym23+zm33]
           m31 m32 m33
</pre>

<p>
向量[x, y, z]做为列向量时，矩阵每一列对应变换后新坐标空间的基向量(使用当前坐标系表示)，平移量在第 4 列。<br />
</p>
<pre class="example" id="org851c0f9">
m11 m12 m13   x     xm11+ym12+zm13
m21 m22 m23 * y  =  xm21+ym22+zm23
m31 m32 m33   z     xm31+ym32+zm33
</pre>

<p>
向量 v 依次按照矩阵 A,B,C 做变换。使用行向量形式表达时，记作 vABC。使用列向量形式表达时，记作 CBAv。<br />
</p>

<p>
Unity Shader 中使用了列向量，矩阵的每一列表示新坐标系的坐标轴的基向量，平移矩阵中平移量在第 4 列。<br />
DirectX 使用行向量<br />
OpenGL  使用列向量<br />
线性代数中使用列向量<br />
本书中使用了行向量, 矩阵的每一行表示新坐标系的坐标轴的基向量，平移矩阵中平移量在第 4 行。<br />
</p>

<p>
如果某本书中使用了列向量的形式，那么和本书相比相同的方程中，对应的矩阵需要被转置，这样才能使行向量形式和列向量形式的向量与矩阵相乘得到的向量的各个分量相一致。此时矩阵的每一列表示新坐标系的坐标轴的基向量。<br />
</p>
<pre class="example" id="org88f6600">
           m11 m12 m13
[x, y, z]  m21 m22 m23  =  [xm11+ym21+zm31, xm12+ym22+zm32, xm13+ym23+zm33]   // 行向量 
           m31 m32 m33
</pre>

<pre class="example" id="orgb12cfaf">
m11 m21 m31   x     xm11+ym21+zm31
m12 m22 m32 * y  =  xm12+ym22+zm32                                            // 列向量 矩阵转置
m13 m23 m33   z     xm13+ym23+zm33
</pre>

<ul class="org-ul">
<li>OpenGL 中矩阵的行主序与列主序 <a href="https://www.jianshu.com/p/bfc8327eaad3">https://www.jianshu.com/p/bfc8327eaad3</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org8ef163a" class="outline-4">
<h4 id="org8ef163a">矩阵的几何解释</h4>
<div class="outline-text-4" id="text-org8ef163a">
<p>
通常来说方阵可以表示任意的线性变换，线性变换可以拉伸或压缩坐标空间，但是不会让坐标空间扭曲。<br />
</p>

<p>
<img src="./ComputerGraphicMath/04_02_baseVMulMatrix.png" alt="04_02_baseVMulMatrix.png" /><br />
坐标系基向量（i,j,k）分别和矩阵 M 相乘后，变为了新坐标系下坐标轴的基向量，这些新的基向量就是矩阵对应的行（新的基向量使用当前坐标系表示）。<br />
</p>

<p>
<img src="./ComputerGraphicMath/04_02_VMulMatrix.png" alt="04_02_VMulMatrix.png" /><br />
向量 v 和矩阵 M 相乘有两种解释：<br />
</p>
<ol class="org-ol">
<li>向量 v 经过矩阵 M 变换后，成为新的向量 vM。<br /></li>
<li>向量 v 所在的坐标系(i,j,k)经过矩阵 M 变换后，变为新的坐标系(iM, jM, kM)。<br />
新的坐标系使用原始坐标系表示，其坐标轴向量为 \((iM, jM, kM)\)<br />
  向量 v 使用新的坐标系表示，其各个分量的值然为 \((v_x, v_y, v_z)\)<br /></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org804c1ae" class="outline-3">
<h3 id="org804c1ae">Chapter5 Matrices and Linear Transformations</h3>
<div class="outline-text-3" id="text-org804c1ae">
</div>
<div id="outline-container-orgdd6c558" class="outline-4">
<h4 id="orgdd6c558">Rotation</h4>
<div class="outline-text-4" id="text-orgdd6c558">
</div>
<div id="outline-container-org331ca98" class="outline-5">
<h5 id="org331ca98">Rotation in 2D</h5>
<div class="outline-text-5" id="text-org331ca98">
<p>
二维坐标系下，只有绕某个点的旋转变换。<br />
</p>


<div id="orgcefd540" class="figure">
<p><img src="./ComputerGraphicMath/05_01_2dRotation.png" alt="05_01_2dRotation.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc530568" class="outline-5">
<h5 id="orgc530568">Rotaion in 3D</h5>
<div class="outline-text-5" id="text-orgc530568">
<p>
绕坐标轴旋转的矩阵：<br />
<img src="./ComputerGraphicMath/05_01_3DAxisRotation.png" alt="05_01_3DAxisRotation.png" /><br />
</p>

<p>
绕任意向量 n 旋转向量 v 的矩阵：<br />
<img src="./ComputerGraphicMath/05_01_3DAxisRotation2.png" alt="05_01_3DAxisRotation2.png" /><br />
向量 v 绕向量 n 旋转 \(\Theta\) 角度变为向量 v'。将向量 v 分解为平行与向量 n 的向量和垂直与 n 的向量，按照上面步骤即可推出绕任意向量旋转矩阵。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org1244ce4" class="outline-4">
<h4 id="org1244ce4">Scale</h4>
<div class="outline-text-4" id="text-org1244ce4">
<p>
沿坐标轴的缩放<br />
<img src="./ComputerGraphicMath/05_01_3DAxisScale.png" alt="05_01_3DAxisScale.png" /><br />
</p>

<p>
沿任意方向 n 对向量 v 缩放 k 倍<br />
<img src="./ComputerGraphicMath/05_01_3DAxisScale2.png" alt="05_01_3DAxisScale2.png" /><br />
向量 v 沿着向量 n 方向缩放 k 变为向量 v'。将向量 v 分解为平行于向量 n 的向量和垂直于 n 的向量，按照上面步骤即可推出沿任意方向缩放矩阵。<br />
</p>
</div>
</div>

<div id="outline-container-org29f1b61" class="outline-4">
<h4 id="org29f1b61">Orthographic Projection</h4>
<div class="outline-text-4" id="text-org29f1b61">
<p>
投影到坐标轴<br />
<img src="./ComputerGraphicMath/05_03_OrthographicAxis.png" alt="05_03_OrthographicAxis.png" /><br />
投影到坐标轴所在的平面<br />
<img src="./ComputerGraphicMath/05_03_OrthographicAxisPlane.png" alt="05_03_OrthographicAxisPlane.png" /><br />
投影到任意直线或平面<br />
<img src="./ComputerGraphicMath/05_03_OrthographicX.png" alt="05_03_OrthographicX.png" /><br />
沿任意方向投影可以转化为沿该方向缩放 0.<br />
投影到任意直线可以转化为沿垂直于该直线的方向缩放 0.<br />
投影到任意平面可以转化为沿垂直于该平面的方向缩放 0.<br />
</p>
</div>
</div>
<div id="outline-container-orgb068959" class="outline-4">
<h4 id="orgb068959">Reflection</h4>
<div class="outline-text-4" id="text-orgb068959">
<p>
反射变换又称为镜像变换，这种变换将物体相对一条直线或一个平面进行翻转。<br />
</p>

<p>
相对一条直线的反射变换:<br />
<img src="./ComputerGraphicMath/05_04_ReflectionLine.png" alt="05_04_ReflectionLine.png" /><br />
相对一条直线的反射变换，可以转化为沿垂直于该直线方向缩放-1 的变换。<br />
相对于一个平面的反射变换：<br />
<img src="./ComputerGraphicMath/05_04_ReflectionPlane.png" alt="05_04_ReflectionPlane.png" /><br />
相对于一个平面的反射变换，可以转化为沿垂直与该平面的方向缩放-1 的变换。<br />
</p>

<p>
Tips:<br />
上面描述的相对于一个平面的反射变换中，平面必须经过原点。对于不经过原点的情况，需要考虑原点到平面的距离。具体原理参考下图：<br />
<img src="./ComputerGraphicMath/plane_reflection_01.jpg" alt="plane_reflection_01.jpg" /><br />
<a href="./ComputerGraphicMath/plane_reflection_01.ggb">./ComputerGraphicMath/plane_reflection_01.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org6568419" class="outline-4">
<h4 id="org6568419">Shearing</h4>
<div class="outline-text-4" id="text-org6568419">
<p>
切变是一种可以将坐标空间拉伸的变换。角度会发生变化，但是面积和体积不会变。切变中一个坐标分量不变，将这个坐标分量乘一个值然后加到另一个分量,如 x' = x + sy.<br />
</p>

<p>
二维空间中沿 x 坐标方向的切变<br />
<img src="./ComputerGraphicMath/05_05_Shear2DX.png" alt="05_05_Shear2DX.png" /><br />
二维空间中沿 y 坐标方向的切变<br />
<img src="./ComputerGraphicMath/05_05_Shear2DY.png" alt="05_05_Shear2DY.png" /><br />
三维空间中的切变<br />
<img src="./ComputerGraphicMath/05_05_Shear3D.png" alt="05_05_Shear3D.png" /><br />
</p>

<p>
在 unitycatlikecoding\Rendering\Assets\MyTest\02ShearingTransform 工程中，使用 unity 展示了三维的切变变换。<br />
</p>
</div>
</div>
<div id="outline-container-org1750738" class="outline-4">
<h4 id="org1750738">Combining Transformations</h4>
</div>
<div id="outline-container-orgc13fe62" class="outline-4">
<h4 id="orgc13fe62">Classes of Transformations</h4>
</div>
</div>
<div id="outline-container-org33302af" class="outline-3">
<h3 id="org33302af">Chapter6 More on Matrix</h3>
<div class="outline-text-3" id="text-org33302af">
</div>
<div id="outline-container-orgee65fad" class="outline-4">
<h4 id="orgee65fad">Determinant of a Matrix</h4>
<div class="outline-text-4" id="text-orgee65fad">
<p>
每个方矩阵对应一个特殊的标量，该标量被称为行列式。<br />
</p>
</div>
<div id="outline-container-orgaf39711" class="outline-5">
<h5 id="orgaf39711">Determinant of 2x2 and 3x3 matrices</h5>
<div class="outline-text-5" id="text-orgaf39711">
<p>
方阵 M 对应的行列式记为|M|，有些书中也记为 det M 。矩阵不是方阵时，其行列式是未定义的。<br />
</p>

<p>
按照下列方法计算 2x2 3x3 矩阵的行列式：<br />
<img src="./ComputerGraphicMath/00_06_01_matrix_det_3x3_2x2.jpg" alt="00_06_01_matrix_det_3x3_2x2.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8f89bb3" class="outline-5">
<h5 id="org8f89bb3">Minors and Cofactors</h5>
<div class="outline-text-5" id="text-org8f89bb3">
<ul class="org-ul">
<li>minor 的定义<br />
方阵 M 移除第 i 行和第 j 列后，所得的子矩阵的行列式记为 \(M^{ij}\) ，其就是一个 M 的 minor。<br />
<img src="./ComputerGraphicMath/00_06_01_matrix_minor_example.jpg" alt="00_06_01_matrix_minor_example.jpg" /><br /></li>
<li>cofactor(代数余子式) 的定义<br />
minor 依据下面图示规则取正负号就是 cofactor<br />
<img src="./ComputerGraphicMath/00_06_01_matrix_cofactor.jpg" alt="00_06_01_matrix_cofactor.jpg" /><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge0a41ff" class="outline-5">
<h5 id="orge0a41ff">Determinants of Arbitrary nxn Matrices</h5>
<div class="outline-text-5" id="text-orge0a41ff">
<ul class="org-ul">
<li>首先，任意选择矩阵的一行或一列；<br /></li>
<li>其次，将该行或该列的每个原始和该元素对应的 cofactor 相乘；<br /></li>
<li>最后，将上一步得到的值相加，得到的就是该矩阵的行列式；<br /></li>
</ul>


<div id="orge46b52d" class="figure">
<p><img src="./ComputerGraphicMath/00_06_01_matrix_determinant_nxn.jpg" alt="00_06_01_matrix_determinant_nxn.jpg" /><br />
</p>
</div>

<p>
下面为矩阵行列式的一些重要性质：<br />
</p>
<pre class="example" id="org0808186">
1. 单位矩阵的行列式为1 .     
|I| = 1      
2. 矩阵积行列式等于矩阵行列式的积
|AB| = |A||B| 
|M1M2M3...| = |M1||M2||M3|...
3. 矩阵的行列式和矩阵转置的行列式相等
|M^T| = |M|
4. 如果矩阵任意一行或任意一列的元素都为0，则该矩阵的行列式为0
5. 任意互换矩阵的两行或两列元素，其行列式取反
6. 将矩阵某行元素乘常量k加到另一行元素上，其行列式不变
</pre>
</div>
</div>
<div id="outline-container-org4c39793" class="outline-5">
<h5 id="org4c39793">Geometric Interpretation of Determinant</h5>
<div class="outline-text-5" id="text-org4c39793">
<p>
在 2D 空间，矩阵的行列式等于其基向量围成的平行四边形的有符号面积。如果平行四边形的朝向和坐标系朝向对立，则符号为负，否则为正。<br />
在 3D 空间，矩阵的行列式等于其基向量围成的平行六面体的体积。如果平行六面体的朝向和坐标系朝向对立，则符号为负，否则为正。<br />
</p>

<p>
矩阵的行列式和矩阵表示的变换引起的尺寸改变有关:<br />
detM = 0, 表示变换不可逆，物体会被缩为一个点或一条直线。<br />
0&lt;detM&lt;1, 表示变换使物体尺寸缩小。<br />
detM &gt; 1, 表示变换使物体尺寸放大。<br />
</p>

<p>
矩阵的行列式可用于对矩阵表示的变换进行分类：<br />
</p>
<ol class="org-ol">
<li>如果矩阵的行列式为 0，则矩阵包含投影；<br /></li>
<li>如果矩阵的行列式为 1，则矩阵表示的变换不会使物体变形。（例如：旋转变换）<br /></li>
<li>如果矩阵的行列式为负数，则矩阵包含反射（即：镜像）；<br /></li>
</ol>
</div>
<div id="outline-container-orgb11171b" class="outline-6">
<h6 id="orgb11171b">参考资料</h6>
<div class="outline-text-6" id="text-orgb11171b">
<ul class="org-ul">
<li>行列式的本质是什么？ <a href="https://www.matongxue.com/madocs/247/">https://www.matongxue.com/madocs/247/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org3bb5425" class="outline-4">
<h4 id="org3bb5425">Inverse of a Matrix</h4>
<div class="outline-text-4" id="text-org3bb5425">
<p>
另一个只可以应用于方阵的操作是求矩阵的逆矩阵。<br />
矩阵 M 的逆矩阵记为 \(M^{-1}\) ，矩阵和其逆矩阵的积为单位矩阵。<br />
</p>

<p>
不是所有的矩阵都可以求逆矩阵。很显然的一个例子是，如果矩阵的某行或某列的元素都为 0，则其逆矩阵不存在。如果一个矩阵的逆矩阵存在，则称该矩阵可逆(invertible)或非奇异(nonsingular).<br />
可逆矩阵的每一行和每一列之间都是线性无关的。<br />
奇异矩阵的行列式为 0，非奇异矩阵(可逆矩阵)的行列式不为 0。<br />
</p>
</div>
<div id="outline-container-org6d00fab" class="outline-5">
<h5 id="org6d00fab">The Classical Adjoint</h5>
<div class="outline-text-5" id="text-org6d00fab">
<p>
矩阵 M 的伴随矩阵可用于求矩阵 M 的逆矩阵。<br />
矩阵 M 的伴随矩阵记为 adj M, 其为矩阵 M 代数余子式的转置。<br />
<img src="./ComputerGraphicMath/00_06_02_matrix_adjoint.jpg" alt="00_06_02_matrix_adjoint.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org2602227" class="outline-5">
<h5 id="org2602227">Matrix Inverse</h5>
<div class="outline-text-5" id="text-org2602227">
<p>
通过下面的公式可以利用伴随矩阵计算矩阵的逆矩阵：<br />
<img src="./ComputerGraphicMath/00_06_02_matrix_inverse.jpg" alt="00_06_02_matrix_inverse.jpg" /><br />
</p>

<p>
下面为逆矩阵相关的一些重要性质：<br />
</p>
<ol class="org-ol">
<li>逆矩阵求逆得到原矩阵<br />
\((M^{-1})^{-1} = M\)<br /></li>
<li>单位矩阵的逆矩阵是单位矩阵自己<br />
\(I^{-1} = I\)<br /></li>
<li>矩阵转置的逆等于矩阵逆的转置<br />
\((M^{T})^{-1} = (M^{-1})^{T}\)<br /></li>
<li>矩阵积的逆<br />
\((AB)^{-1} = B^{-1}A^{-1}\)<br />
\((M1M2M3...)^{-1} = ...M3^{-1}M2^{-1}M1^{-1}\)<br /></li>
<li>逆矩阵的行列式<br />
\(|M^{-1}| = 1/|M|\)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org303551e" class="outline-5">
<h5 id="org303551e">Matrix Inverse(Geometric Interpretation)</h5>
<div class="outline-text-5" id="text-org303551e">
<p>
逆矩阵表示逆变换。<br />
 \((vM)M^{-1} = v(MM^{-1}) = vI = v\)<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfc1e7ce" class="outline-4">
<h4 id="orgfc1e7ce">Orthogonal Matrices</h4>
</div>
<div id="outline-container-org97b6023" class="outline-4">
<h4 id="org97b6023">4x4 Homogeneous Matrices</h4>
<div class="outline-text-4" id="text-org97b6023">
</div>
<div id="outline-container-org19a1399" class="outline-5">
<h5 id="org19a1399">4x4 Translation Matrix</h5>
</div>
</div>
<div id="outline-container-org60c60b3" class="outline-4">
<h4 id="org60c60b3">4x4 Matrices and Perspecitive Projection</h4>
<div class="outline-text-4" id="text-org60c60b3">
</div>
<div id="outline-container-org6bb1f75" class="outline-5">
<h5 id="org6bb1f75">A Pinhole Camera</h5>
<div class="outline-text-5" id="text-org6bb1f75">

<div id="orga83a5eb" class="figure">
<p><img src="./ComputerGraphicMath/20_06_10_pinhole_camera.jpg" alt="20_06_10_pinhole_camera.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org24352a9" class="outline-5">
<h5 id="org24352a9">Perspective Projection Matrices</h5>
<div class="outline-text-5" id="text-org24352a9">
<p>
<a id="org29b05ad"></a><br />
</p>

<pre class="example" id="orgd003342">
p′ = [dx/z dy/z d] = [dx/z dy/z dz/z] = [x y z] / (z/d)

          | 1 0 0 0   |
          | 0 1 0 0   |
[x y z 1] | 0 0 1 1/d | = [x y z z/d]
          | 0 0 0 1   |
</pre>

<p>
关于上面投影矩阵，需要注意以下几点：<br />
</p>
<ol class="org-ol">
<li>乘该矩阵并没有执行透视变换，它只是将适当的分母放到了 w 分量中。透视除法发生在将 4D 坐标转化为 3D 坐标时。<br /></li>
<li>投影矩阵有很多种变体。例如我们可以将投影平面放在 z=0 的位置，将焦点(投影中心点)放在[0,0,-d]的位置，这会得到一个略微不同的矩阵。<br /></li>
<li>使用矩阵形式看起来过于复杂了。直接使用除法比使用矩阵显得更简单一些。使用矩阵的原因有：<br />
<ul class="org-ul">
<li>4x4 矩阵提供了一种将投影表示为变换的方法。这样就可以和其他变换连接在一起了。<br /></li>
<li>矩阵可以表示投影到非轴对称的平面<br /></li>
</ul></li>
<li>在真实的图形几何管线中，投影矩阵不只是将 z 复制到 w 分量中。它和我们导出的投影矩阵有两方面的不同：<br />
<ul class="org-ul">
<li>大多数图形系统会应用归一化的缩放值，使得远平面上的 w=1。这保证了对于渲染的场景来说用于深度缓存的值是恰当地分布的，从而最大化深度缓存的精度。<br /></li>
<li>图形系统的投影矩阵还依据 fov 对 x 和 y 做相应的缩放。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orgaa58103" class="outline-3">
<h3 id="orgaa58103">Chapter8 Rotation in Three Dimensions</h3>
<div class="outline-text-3" id="text-orgaa58103">
</div>
<div id="outline-container-org0b4fce5" class="outline-4">
<h4 id="org0b4fce5">Orientation Vs Angular Displacement</h4>
<div class="outline-text-4" id="text-org0b4fce5">
<p>
Orientation 和 Angular Displacement 之间的关系和 Point 与 Vector 之间的关系类似。<br />
</p>
</div>
</div>

<div id="outline-container-org8d8130d" class="outline-4">
<h4 id="org8d8130d">Matrix Form</h4>
<div class="outline-text-4" id="text-org8d8130d">
</div>
<div id="outline-container-org901eb0a" class="outline-5">
<h5 id="org901eb0a">矩阵形式的优点</h5>
<div class="outline-text-5" id="text-org901eb0a">
<ul class="org-ul">
<li>可以旋转向量。其他形式的旋转表示方法无法旋转向量。<br /></li>
<li>图形 API 使用矩阵来表示旋转。<br /></li>
<li>矩阵支持多个角位移串联起来。<br /></li>
<li>使用矩阵求逆来得到相反的角位移。因为旋转矩阵是正交的，求逆矩阵只需要转置旋转矩阵就可以了。<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org24ddfeb" class="outline-5">
<h5 id="org24ddfeb">矩阵形式的缺点</h5>
<div class="outline-text-5" id="text-org24ddfeb">
<ul class="org-ul">
<li>矩阵需要更多的内存空间<br /></li>
<li>对于人类使用不友好。人类天生更倾向于使用角度来表示朝向，但是矩阵是使用向量来表示朝向的。<br /></li>
<li>矩阵可能是不合法的。矩阵使用 9 个数字表示旋转，其中只有 3 个数字是必要的，另外 6 个数字是冗余的。一个表示旋转的合法矩阵必须满足 6 个约束，矩阵一行必须是单位向量，所有行之间必须是互相垂直的。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfafaf67" class="outline-4">
<h4 id="orgfafaf67">Euler Angles</h4>
<div class="outline-text-4" id="text-orgfafaf67">
<p>
Euler angles 将角位移定义为一个按照一定顺序的 3 个旋转分别绕 3 个互相垂直的轴的旋转。yaw-pitch-roll 对应于 yAxis-xAxis-zAxis<br />
Euler Angles 系统中，旋转是相对于物体当前坐标轴的，每一次旋转后，物体的坐标轴都会变化。<br />
Fixed-axis 系统中，旋转是相对于固定的坐标轴的，每一次旋转后，坐标轴是不会变化的。<br />
EulerAngles 系统和 Fixed-Axis 系统是等价的，Fixed-Axis 按照 EulerAngles 系统的逆序进行旋转得到的结果和 EulerAngles 相同。<br />
Unity 中使用的是 Fixed-Axis 系统。其旋转顺序为 zAxis-xAxis-yAxis。具体内容参考：<a href="../unity/UnityNote.html#orgf444aed">../unity/UnityNote.html#orgf444aed</a><br />
</p>
</div>
<div id="outline-container-orgfbf925e" class="outline-5">
<h5 id="orgfbf925e">EulerAngles 优点</h5>
<div class="outline-text-5" id="text-orgfbf925e">
<ul class="org-ul">
<li>对人类来说易于使用<br /></li>
<li>只使用了 3 个数值来表示 Orientation。这种方式占用内存少，另外以 EulerAngles 保存数据更利于压缩，可以用更少的位数和固定的精度来表示角度，由于压缩导致的精度丢失对于各个分量是均匀的。<br /></li>
<li>表示旋转的 3 个数值都是有效的。随机选择 3 个数值组成一组有效的 EulerAngles，其可表示一个有效的旋转。也就是说不存在不合法的 EulerAngles。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org91e64ee" class="outline-5">
<h5 id="org91e64ee">EulerAngles 缺点</h5>
<div class="outline-text-5" id="text-org91e64ee">
<ul class="org-ul">
<li>对于一个给定的朝向，EulerAngles 不是唯一的。<br />
<ul class="org-ul">
<li>旋转 x 和 x+k*360 是等价的。可以通过限制旋转角度解决该问题。<br /></li>
</ul></li>
<li>第二个旋转角度为 90 时，会产生万向锁问题。该问题无法解决。<br /></li>
<li>EulerAngles 的三个分量在空间中是独立的，不连续的。<br />
<ul class="org-ul">
<li>物体小的朝向变化，可能导致分量中很大的变化。<br /></li>
<li>插值 EulerAngles 会导致奇怪的旋转路径。 可以参考 unitycatlikecoding\RenderingAndAdvancedR\Assets\MyTest\07EulerAnglesRotation 工程中的演示。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd307074" class="outline-4">
<h4 id="orgd307074">Axis-Angle And Exponential Map Representations</h4>
<div class="outline-text-4" id="text-orgd307074">
<p>
欧拉旋转定理：任何三维角位移可以通过绕某个轴的单个旋转来完成。更精确的来说，给定两个朝向 R1 和 R2,存在一个轴 n，绕该轴进行一次旋转就可以从 R1 朝向变为 R2 朝向。<br />
由欧拉旋转定理可知，我们可以使用一个轴 n 和一个角度 &Theta; 来表示旋转，这种表示方式被称为 Axis-Angle 形式。<br />
n 取单位向量，则 \(e=n\Theta\) 此时就可以用一个向量来表示旋转了，旋转围绕的轴为将 e 单位化后的向量，旋转的角度为 |e|，这种表示方式被称为 ExponentialMap 形式。<br />
ExponentialMap 形式通常用于存储角速度，因为这种形式求微分非常容易(这和其具有良好的插值属性有关系)并且可以容易地表示多个旋转。<br />
这两种方式也有和 EulerAngles 一样的奇异点:<br />
</p>
<ul class="org-ul">
<li>对于 Axis-Angle，当 &Theta; 为 0 时，n 有无线多个选择。对于 ExponentialMap，当&Theta; 为 0 时，e为零向量。<br /></li>
<li>对于 Axis-Angle，(&Theta;,n) 和 (-&Theta;,-n)为相同的旋转。对于 ExponentialMap，(n&Theta;)=(-n-&Theta;)=e。<br /></li>
<li>对于 Axis-Angle 和 ExponentialMap，n 不变，k360+&Theta; 会产生相同的旋转。当然，这也不是缺点，当表示角速度时，能够区分 0，360 是很重要的。当然，也可以通过限制 &Theta;&lt;360 来避免不唯一的问题。<br /></li>
</ul>

<p>
ExponentialMap 形式非常适用于表示角速度，当旋转角度非常小时，ExponentialMap 就可以当作矢量相加了，而不需要关心矢量的顺序。<br />
</p>
</div>
</div>
<div id="outline-container-org387c6eb" class="outline-4">
<h4 id="org387c6eb">Quaternions</h4>
<div class="outline-text-4" id="text-org387c6eb">
</div>
<div id="outline-container-orge49bb26" class="outline-5">
<h5 id="orge49bb26">Quaternions 和 Axis-Angle 的关系</h5>
<div class="outline-text-5" id="text-orge49bb26">
<p>
[w v] = [cos(&Theta;/2) sin(&Theta;/2)n]<br />
[w (x y z)] = [cos(&Theta;/2) (sin(&Theta;/2)nx sin(&Theta;/2)ny sin(&Theta;/2)nz)]<br />
</p>


<div id="orgfa4f460" class="figure">
<p><img src="./ComputerGraphicMath/20_05_11_QAxisAngleRelationShip.jpg" alt="20_05_11_QAxisAngleRelationShip.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org197aaed" class="outline-5">
<h5 id="org197aaed">Quaternions 的基本属性和操作</h5>
<div class="outline-text-5" id="text-org197aaed">
</div>
<div id="outline-container-orge87cae7" class="outline-6">
<h6 id="orge87cae7">四元数取反</h6>
<div class="outline-text-6" id="text-orge87cae7">
<p>
-q = -[w (x y z)]=[-w (-x -y -z)]<br />
</p>

<p>
q 和-q 表示相同的角位移。同一个角位移有两个不同的四元数表示形式，这两种形式互为相反四元数。<br />
</p>
</div>
</div>
<div id="outline-container-org818bfa4" class="outline-6">
<h6 id="org818bfa4">单位四元数</h6>
<div class="outline-text-6" id="text-org818bfa4">
<p>
[1 (0 0 0)] 和 [-1 (0 0 0)]<br />
</p>

<p>
代数中，只有一个单位四元数，其为[1 (0 0 0)] 任何一个四元数 q 和[1 (0 0 0)]相乘得到 q 本身。而 q 和[-1 (0 0 0)]相乘得到-q。<br />
几何上，-q 和 q 表示相同的角位移，所以[-1 (0 0 0)]也为单位四元数<br />
</p>
</div>
</div>

<div id="outline-container-org85d9d8b" class="outline-6">
<h6 id="org85d9d8b">四元数 Magnitude （模长）</h6>
<div class="outline-text-6" id="text-org85d9d8b">
<p>
模长为 1 的四元数被称为单位四元数。<br />
我们用于表示 Orientation 的四元数全部是单位四元数。<br />
</p>


<div id="org58cf456" class="figure">
<p><img src="./ComputerGraphicMath/20_05_11_QuaternionMagnitude.jpg" alt="20_05_11_QuaternionMagnitude.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org49ecd6d" class="outline-6">
<h6 id="org49ecd6d">四元数的共轭 四元数的逆</h6>
<div class="outline-text-6" id="text-org49ecd6d">

<div id="org7cc1c28" class="figure">
<p><img src="./ComputerGraphicMath/20_05_11_QuaternionConjugateAndInverse.jpg" alt="20_05_11_QuaternionConjugateAndInverse.jpg" /><br />
</p>
</div>

<p>
q  表示绕 n 旋转  &Theta;<br />
q* 表示绕 n 旋转 -&Theta;<br />
</p>

<p>
对四元数的 w 取反，也可以达到旋转方向取反的目的。<br />
</p>
</div>
</div>

<div id="outline-container-orga9aa59b" class="outline-6">
<h6 id="orga9aa59b">四元数乘法</h6>
<div class="outline-text-6" id="text-orga9aa59b">
<p>
<img src="./ComputerGraphicMath/20_05_11_QuaternionMulti.jpg" alt="20_05_11_QuaternionMulti.jpg" /><br />
从上图可以看出，四元数乘法和向量叉积有相似之处。<br />
上图中 qpq* 可用来旋转点的证明可以参考下面文章的描述：<br />
</p>
<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/41485992">https://www.zhihu.com/question/41485992</a><br /></li>
</ul>

<p>
<a id="org0eaf265"></a><br />
给定两个 Orientation a 和 b，使用 d 来表示从 a 旋转到 b。<br />
<img src="./ComputerGraphicMath/20_05_11_QuaternionDiff.jpg" alt="20_05_11_QuaternionDiff.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd1fe5dd" class="outline-6">
<h6 id="orgd1fe5dd">四元数点积</h6>
<div class="outline-text-6" id="text-orgd1fe5dd">
<p>
<img src="./ComputerGraphicMath/20_05_11_QuaternionDot.jpg" alt="20_05_11_QuaternionDot.jpg" /><br />
从上图可以看出，四元数点积和向量点积有相似之处。<br />
</p>

<p>
从 <a href="#org0eaf265">No description for this link</a> 得知 d=ba^(-1)，因为是单位四元数，所以 d=ba*，将 ba*展开可以发现 d 的 w 分量为 a.b。而四元数的 w 分量为 cos(&Theta;/2)，由此可见四元数的点积和向量的点积有相似的几何意义。即，点积越大表示 a 和 b 的朝向相差越小。<br />
</p>
</div>
</div>
<div id="outline-container-orgaed9bdf" class="outline-6">
<h6 id="orgaed9bdf">四元数 log exp(Exponential) power(Exponentiation) 标量的乘法</h6>
<div class="outline-text-6" id="text-orgaed9bdf">

<div id="org4ecfbe1" class="figure">
<p><img src="./ComputerGraphicMath/20_05_11_QuaternionLogExp.jpg" alt="20_05_11_QuaternionLogExp.jpg" /><br />
</p>
</div>

<p>
下面的解释比书中内容更容易理解：<br />
<img src="./ComputerGraphicMath/20_05_11_QuaternionExpLogPower.jpg" alt="20_05_11_QuaternionExpLogPower.jpg" /><br />
</p>

<p>
四元数求幂的意义和实数求幂的意义相似。<br />
四元数求幂允许我们从一个角位移分离出一个分数角位移如：q^(1/3)<br />
</p>

<p>
四元数求幂的定义： q^(t) = exp(tlogq)<br />
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#22235;&#20803;&#25968;&#24130;&#30340;&#31639;&#27861;</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Quaternion ( input and output )</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">w</span>, <span style="color: #7590db;">x</span> , <span style="color: #7590db;">y</span> , <span style="color: #7590db;">z</span> ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Input exponent</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">exponent</span> ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Check for the case of an identity quaternion .</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">This will protect against divide by zero</span>
  <span style="color: #4f97d7; font-weight: bold;">if</span>(fabs (w) &lt; .9999 f ) {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Extract the half angle alpha ( alpha = t h e t a /2)</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">alpha</span> = acos(w);
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute new alpha value</span>
      flo a <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">newAlpha</span> = alpha &#8727; exponent ;
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute new w value</span>
      w=cos (newAlpha);
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute new xyz value s</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">mult</span> = sin(newAlpha) / sin (alpha) ;
      x &#8727;= mult;
      y &#8727;= mult;
      z &#8727;= mult;
   }
</pre>
</div>

<ul class="org-ul">
<li>为什么复数可以用自然对数的底 e 和三角函数来表示？ <a href="https://www.zhihu.com/question/345358560">https://www.zhihu.com/question/345358560</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1586461" class="outline-5">
<h5 id="org1586461">四元数 Slerp</h5>
<div class="outline-text-5" id="text-org1586461">
<p>
<img src="./ComputerGraphicMath/20_05_12_QuaternionSlerp.jpg" alt="20_05_12_QuaternionSlerp.jpg" /><br />
Tips: 将上面 2D 的几何推导推广到四元数空间就是四元数的 Slerp.<br />
</p>

<p>
Slerp 需要解决的两个问题:<br />
</p>
<ul class="org-ul">
<li>q 和-q 表示相同的 Orientation，但是做为 slerp 的参数时，会得到不同的结果。在 2D 和 3D 空间中，不会有该问题，但是在 4D 空间下会有该问题。<br />
<ul class="org-ul">
<li>解决办法是，选择 q0 和 q1 的正负号，使得 q0.q1 为非负数。这样从 q0 到 q1 始终都会选最短路径<br /></li>
</ul></li>
<li>当 q0 和 q1 非常接近时,sin(w)会非常小，这会导致除 0 的问题。<br />
<ul class="org-ul">
<li>解决办法是，当 w 非常小时，使用线性插值来代替 Slerp。<br /></li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">The two input quaternions</span>
  floa <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">w0</span>, <span style="color: #7590db;">x0</span> , <span style="color: #7590db;">y0</span> , <span style="color: #7590db;">z0</span> ;
  floa <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">w1</span>, <span style="color: #7590db;">x1</span> , <span style="color: #7590db;">y1</span> , <span style="color: #7590db;">z1</span> ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">The interpolation parameter</span>
  floa <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">t</span> ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">The output quaternion will be computed here</span>
  floa <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">w</span>, <span style="color: #7590db;">x</span> , <span style="color: #7590db;">y</span> , <span style="color: #7590db;">z</span> ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute the cosine of the angle between the</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">quaternions , using the dot product</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">cosOmega</span> = w0&#8727;w1 + x0&#8727;x1 + y0&#8727;y1 + z0&#8727;z1 ;
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">If negative dot , negate one of the input</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">quaternions , to take the shorter 4D arc</span>
  <span style="color: #4f97d7; font-weight: bold;">if</span> ( cosOmega &lt; 0.0 f )
  {
      w1 = &#8722;w1;
      x1 = &#8722;x1 ;
      y1 = &#8722;y1 ;
      z1 = &#8722;z1 ;
      cosOmega = &#8722;cosOmega ;
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Check if they are very c lose together , to protect</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">against divide&#8722;by&#8722;zero</span>
  <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">k0</span> , <span style="color: #7590db;">k1</span> ;
  <span style="color: #4f97d7; font-weight: bold;">if</span> ( cosOmega &gt; 0.9999 f )
  {
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Very close &#8722; just use linear interpolation</span>
      k0 = 1.0 f&#8722;t ;
      k1 = t ;
  }
  <span style="color: #4f97d7; font-weight: bold;">else</span>
  {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute the s i n of the angle us ing the</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">trig identity sin&#710;2( omega) + cos &#710; 2 ( omega) = 1</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">sinOmega</span> = sqrt ( 1.0f &#8722; cosOmega&#8727;cosOmega ) ;
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute the angle from i t s s i n e and cos ine</span>
      flo a <span style="color: #ce537a; font-weight: bold;">t</span> <span style="color: #7590db;">omega</span> = atan2 ( sinOmega , cosOmega ) ;
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute i n v e r s e of denominator , so we only have</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">to divide once</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">oneOverSinOmega</span> = 1.0 f / sinOmega ;
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Compute interpolation parameter s</span>
      k0 = sin ( (1.0f &#8722; t ) &#8727; omega ) &#8727; oneOverSinOmega ;
      k1 = sin ( t &#8727; omega ) &#8727; oneOverSinOmega ;
  }
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Interpolate</span>
  w = w0&#8727;k0 + w1&#8727;k1;
  x = x0&#8727;k0 + x1&#8727;k1;
  y = y0&#8727;k0 + y1&#8727;k1;
  z = z0&#8727;k0 + z1&#8727;k1;
</pre>
</div>
</div>
</div>
<div id="outline-container-org787544f" class="outline-5">
<h5 id="org787544f">四元数优缺点</h5>
<div class="outline-text-5" id="text-org787544f">
</div>
<div id="outline-container-orgf2f060e" class="outline-6">
<h6 id="orgf2f060e">优点</h6>
<div class="outline-text-6" id="text-orgf2f060e">
<ul class="org-ul">
<li>平滑的插值。其他的形式都无法提供提供平滑的插值。<br /></li>
<li>通过使用四元数叉乘可以将一个角位移序列转化为当个角位移。同样的操作，矩阵所涉及的标量运算会更多。<br /></li>
<li>四元数共轭提供了简单计算逆角位移的方式，矩阵形式也只需要通过转置就可以了，EulerAngles 计算逆角位移则比较难。<br /></li>
<li>四元数到矩阵的转变非常高效。<br /></li>
<li>只使用了四个数字。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9082583" class="outline-6">
<h6 id="org9082583">缺点</h6>
<div class="outline-text-6" id="text-org9082583">
<ul class="org-ul">
<li>比 EulerAngles 占用内存要多 33%. 四元数的值在[-1,+1]区间内不是均匀分布的，所以将四元数压缩到一个固定精度的数值中很难，而 EulerAngles 和 ExponentialMap 比较容易。<br /></li>
<li>有可能变为无效的四元数。<br />
<ul class="org-ul">
<li>我们通过将四元数标准化，使其模长为 1，来避免该问题。<br /></li>
</ul></li>
<li>对人类使用不友好。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf9fa308" class="outline-5">
<h5 id="orgf9fa308">四元数和复数</h5>
<div class="outline-text-5" id="text-orgf9fa308">
<p>
下图是 2 维空间下，复数和矩阵的联系：<br />
<img src="./ComputerGraphicMath/20_05_12_ComplexNumberAndMatrix.jpg" alt="20_05_12_ComplexNumberAndMatrix.jpg" /><br />
</p>

<p>
通常将复数的虚部 i 解释为 -1 的平方根，另一种理解复数的方式是，将复数 a+bi 理解为一种包含两个自由度的数学实体，这种实体的乘法采用一种特殊的方式。实部 a 为主自由度，虚部 b 为第二自由度。这这两个自由度之间互相正交。<br />
</p>

<p>
下图是 4 维空间下，复数和矩阵的联系：<br />
<img src="./ComputerGraphicMath/20_05_13_QuaternionComplexNumber.jpg" alt="20_05_13_QuaternionComplexNumber.jpg" /><br />
</p>

<p>
qpq* 可用来旋转点的证明可以参考下面文章的描述：<br />
</p>
<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/41485992">https://www.zhihu.com/question/41485992</a><br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge125208" class="outline-4">
<h4 id="orge125208">Comparison of Methods</h4>
<div class="outline-text-4" id="text-orge125208">
</div>
<div id="outline-container-org80fc49c" class="outline-5">
<h5 id="org80fc49c">将点在坐标系之间转换 （物体和世界坐标系）</h5>
<div class="outline-text-5" id="text-org80fc49c">
<ul class="org-ul">
<li>Matrix 可以，并且可以通过 SIMD 进行加速<br /></li>
<li>EulerAngles 不可以，必须转化为 Matrix 后进行<br /></li>
<li>ExponentialMap 不可以，必须转化为 Matrix 后进行<br /></li>
<li>Quaternion 理论上可行，但通常计算机中部这么做，依然是转化为 Matrix 后进行<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc1d23f4" class="outline-5">
<h5 id="orgc1d23f4">串联旋转</h5>
<div class="outline-text-5" id="text-orgc1d23f4">
<ul class="org-ul">
<li>Matrix 可以，并且可以通过 SIMD 进行加速，需要注意多次计算后累积产生的错误<br /></li>
<li>EulerAngles 不可以<br /></li>
<li>ExponentialMap 不可以<br /></li>
<li>Quaternion 可以。比矩阵乘法使用更少的计算量，但可能无法利用 SIMD 优势。需要注意多次计算后累积产生的错误<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgef82201" class="outline-5">
<h5 id="orgef82201">旋转求逆</h5>
<div class="outline-text-5" id="text-orgef82201">
<ul class="org-ul">
<li>Matrix 可以只需要转置操作<br /></li>
<li>EulerAngles 比较难<br /></li>
<li>ExponentialMap 容易，只需要向量取反<br /></li>
<li>Quaternion 容易，只需要四元数共轭操作<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org5958c9c" class="outline-5">
<h5 id="org5958c9c">插值</h5>
<div class="outline-text-5" id="text-org5958c9c">
<ul class="org-ul">
<li>Matrix 非常不容易<br /></li>
<li>EulerAngles 可以但是万向锁问题会导致旋转失效<br /></li>
<li>ExponenialMap 可以，但是有一些奇异点问题（360x 形式的旋转量表示相同旋转）<br /></li>
<li>Quaternion 可以，并且 Slerp 提供圆滑的插值<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgb6f00ba" class="outline-5">
<h5 id="orgb6f00ba">易于人类理解</h5>
<div class="outline-text-5" id="text-orgb6f00ba">
<ul class="org-ul">
<li>Matrix 难<br /></li>
<li>EulerAngles 比较容易<br /></li>
<li>ExponentialMap 非常难<br /></li>
<li>Quaternion 非常难<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orga485890" class="outline-5">
<h5 id="orga485890">存储效率</h5>
<div class="outline-text-5" id="text-orga485890">
<ul class="org-ul">
<li>Matrix 9 个数字<br /></li>
<li>EulerAngles 3 个数字并且易于压缩，压缩后精度损失分布平均<br /></li>
<li>ExponentialMap 3 个数字，不易于压缩。<br /></li>
<li>Quaternion 4 个数字。可以通过假设 w=0 或四元数模长=1 减少为 3 个数字。但不易于压缩。<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org48fbead" class="outline-5">
<h5 id="org48fbead">对与给定的旋转有唯一的表示</h5>
<div class="outline-text-5" id="text-org48fbead">
<ul class="org-ul">
<li>Matrix 是<br /></li>
<li>EulerAngles 否<br /></li>
<li>ExponentialMap 否<br /></li>
<li>Quaternion 有两种不同的表示，这两种形式互为相反。<br /></li>
</ul>
</div>
</div>

<div id="outline-container-org65ae041" class="outline-5">
<h5 id="org65ae041">可能变为非法的表示</h5>
<div class="outline-text-5" id="text-org65ae041">
<ul class="org-ul">
<li>Matrix 是 矩阵可能是缩放 平移等等<br /></li>
<li>EulerAngles 否 任意三个数字都可以解释为旋转<br /></li>
<li>ExponentialMap 否 任意三个数字都可以解释为旋转<br /></li>
<li>Quaternion 是 必须为单位四元数<br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org35f8d58" class="outline-4">
<h4 id="org35f8d58">Converting between Representations</h4>
<div class="outline-text-4" id="text-org35f8d58">
</div>
<div id="outline-container-org71aa2e6" class="outline-5">
<h5 id="org71aa2e6">EulerAngle 和 Matrix 之间的转换</h5>
<div class="outline-text-5" id="text-org71aa2e6">

<div id="orgde864bb" class="figure">
<p><img src="./ComputerGraphicMath/20_05_13_EulerAngleToMatrix.jpg" alt="20_05_13_EulerAngleToMatrix.jpg" /><br />
</p>
</div>

<p>
矩阵转化为 EulerAngle 需要注意一下几点：<br />
</p>
<ul class="org-ul">
<li>需要知道旋转矩阵是 object-to-world 还是 world-to-object，这两个旋转矩阵互为转置，但是不同<br /></li>
<li>给定一个角位移 EulerAngle 有无数多个表示，为了唯一化，做如下限制 -180&lt;heading&lt;=180  -180&lt;bank&lt;=180  -90&lt;pitch&lt;=90<br /></li>
<li>有些矩阵是错误的形式，而且也必须忍受浮点数精度不够的问题。<br /></li>
</ul>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Extracting EulerAnagles from an object-to-world matrix</span>
  <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ExtractEulerAngle</span>()
  {
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Assume the matrix is stored in these variables:</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">m11</span>,<span style="color: #7590db;">m12</span>,<span style="color: #7590db;">m13</span>;
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">m21</span>,<span style="color: #7590db;">m22</span>,<span style="color: #7590db;">m23</span>;
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">m31</span>,<span style="color: #7590db;">m32</span>,<span style="color: #7590db;">m33</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">We will compute the Euler angle value s in radians</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">and store them here :</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">h</span> , <span style="color: #7590db;">p</span> , <span style="color: #7590db;">b</span>;
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Extract pitch from m32, being careful for domain errors with</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">asin(). We could have values slightly out of range due to</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">floating point arithmetic .</span>
      <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">sp</span> = &#8722;m32;
      <span style="color: #4f97d7; font-weight: bold;">if</span>(sp &lt;= &#8722;1.0 f )
      {
          p = &#8722;1.570796 f ; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#8722;pi /2</span>
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7; font-weight: bold;">if</span> ( sp &gt;= 1.0 f )
      {
          p = 1.570796 f ; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pi /2</span>
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          p = asin ( sp ) ;
      }
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Check f o r the Gimbal lock case , giving a slight tolerance</span>
      <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">for numerical imprecision</span>
      <span style="color: #4f97d7; font-weight: bold;">if</span>( fabs ( sp ) &gt; 0.9999 f )
      {
          <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">We are looking straight up or down .</span>
          <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Slam bank to zero and just set heading</span>
          b=0.0 f ;
          h=atan2(&#8722;m13, m11 ) ;
      }
      <span style="color: #4f97d7; font-weight: bold;">else</span>
      {
          <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute heading from m13 and m33</span>
          h=atan2 (m31, m33 ) ;
          <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Compute bank from m21 and m22</span>
          b=atan2 (m12, m22 ) ;
      }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org90a04ac" class="outline-5">
<h5 id="org90a04ac">Quaternion 和 Matrix 之间的转换</h5>
</div>
<div id="outline-container-orgefa32a4" class="outline-5">
<h5 id="orgefa32a4">Quaternion 和 EulerAngle 之间的转换</h5>
</div>
</div>
</div>
<div id="outline-container-org352697d" class="outline-3">
<h3 id="org352697d">Chapter9 Geometric Primitives</h3>
<div class="outline-text-3" id="text-org352697d">
</div>
<div id="outline-container-org7849c0c" class="outline-4">
<h4 id="org7849c0c">Representation Techniques</h4>
<div class="outline-text-4" id="text-org7849c0c">
</div>
<div id="outline-container-org958eecb" class="outline-5">
<h5 id="org958eecb">隐式方式</h5>
<div class="outline-text-5" id="text-org958eecb">
<p>
定义一个隐式形式的 Boolean 函数 f(x,y,z)，对于几何单元上的所有点该函数返回 true，而其他点则返回 false。<br />
例如： x^2 + y^2 + z^2 = 1 表示球心在原点，半径为 1 的球。<br />
</p>

<p>
圆锥曲线是典型的通过隐式表示的几何形状。圆锥曲线是平面和圆锥体相交形成的 2D 形状。其包含圆，椭圆，抛物线，双曲线，所有这些图形都可以通过下面的隐式方式表示：<br />
Ax^2 + Bxy + Cy^2 + D = 0<br />
</p>

<p>
Metaballs 是用于表示液体和有机器官形状的方法。通过一组模糊的球来定义体积。每个球定义一个三维的标量密度函数，其密度基于到球心的距离，球心密度最大，距离越远密度越小。空间中任意一点的密度为所有球在该点密度的和。液体或有机器官的体积被定义为密度大于某个阙值(该值不为 0)的部分。也就是说，这些球的范围是模糊的，当这些球是分离开的，那么这些球的一部分会在整体体积之外。当两个或更多球靠在一起时，模糊的区域会叠加增强，从而在两个球之间得到一个优美的固体。Marching Cube 算法是一种典型的算法，其可以将隐式形式的表面转化多边形 mesh。<br />
</p>
</div>
</div>
<div id="outline-container-org7d14737" class="outline-5">
<h5 id="org7d14737">参数方式</h5>
<div class="outline-text-5" id="text-org7d14737">
<p>
参数方式，是另一种表示形状的通用方法。<br />
例如： x(t) = cos(2πt)  y(t)=sin(2πt)，t即为参数，其从 0 变化为 1，其表示一个圆形在原点，半径为 1 的圆。<br />
通常会使用归一化的参数，即参数范围为[0,1]。也可以根据情况任意选择参数 t 的范围。<br />
</p>

<p>
当我们的函数使用一个参数来表示，我们称该函数是单变量的。单变量函数描绘出的是一个 1D 曲线。<br />
双变量函数接受两个参数，通常使用 s,t 来表示。双变量函数描绘出的是一个表面而不是一条线。<br />
</p>
</div>
</div>
<div id="outline-container-org635b8a9" class="outline-5">
<h5 id="org635b8a9">直接的方式</h5>
<div class="outline-text-5" id="text-org635b8a9">
<p>
最后一种表示方式是直接方式。所有直接利用形状自身的重要的、明显的信息来表示形状的专用方法都属于该类方式。<br />
例如： 为了表示一条线段，我们可以直接使用线段的两端点。可以使用球心和半径来表示一个球体。<br />
</p>
</div>
</div>
<div id="outline-container-org5071b4d" class="outline-5">
<h5 id="org5071b4d">Common</h5>
<div class="outline-text-5" id="text-org5071b4d">
<p>
不考虑几何单元的表示方式，任意一个几何单元都有其固有的自由度。假设其自由度为 n，则最少需要 n 个数字才能清楚表示该几何单元。对于同一个几何单元，不同的表示法所需的数字可能不同。多于自由度数量的数字，都是冗余的。<br />
例如：平面上的圆有 3 个自由度: 圆心为（xc,yc），半径为 r，其参数方程为 x(t) = xc + rcos(2πt) y(t) = yc + rsin(2πt). 参数表示法中里面使用了 4 个数字(xc,yc,r,t). 使用隐式方式表示该圆，则为 (x-xc)^2 + (y-yc)^2 = r^2<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga99ef0d" class="outline-4">
<h4 id="orga99ef0d">Lines and Rays</h4>
<div class="outline-text-4" id="text-orga99ef0d">
</div>
<div id="outline-container-orgdd1b475" class="outline-5">
<h5 id="orgdd1b475">Rays</h5>
<div class="outline-text-5" id="text-orgdd1b475">
<p>
直接方式 (Po, Pe)<br />
参数方式 p(t) = p0 + td<br />
分离的参数方式：<br />
x(t) = x0 + tdx<br />
y(t) = y0 + tdy<br />
tips: d = (dx, dy)<br />
</p>

<p>
2D 的射线有 4 个自由度(x0, y0, dx, dy)<br />
</p>
</div>
</div>
<div id="outline-container-org4583531" class="outline-5">
<h5 id="org4583531">Special 2D Representations of Lines</h5>
<div class="outline-text-5" id="text-org4583531">
<p>
斜截式(隐式方式)<br />
y = mx + b   m 为斜率，b为截距<br />
<img src="./ComputerGraphicMath/00_09_02_line_slope_intercept.jpg" alt="00_09_02_line_slope_intercept.jpg" /><br />
</p>

<p>
2D 直线只有两个自由度(m, b)。一个自由度用于旋转，一个自由度用于移动。<br />
</p>

<p>
当直线为竖直时，其斜率为无穷大，上面的表示方法将无法使用。我们可以使用如下隐式方法来表示：<br />
ax + by = d<br />
假设直线的法向量 n=[a, b], 用向量表示上面方程：<br />
</p>
<pre class="example" id="org34c1ef1">
      |a |
|x y| |b | = d
</pre>
<p>
上面表示中有三个自由度，其包含一些冗余。<br />
上面方程两边可以同时乘任意非零常数，这样我们就可以自由选择法线的长度，选择法线 n 的长度为 1，此时法线 n 为垂直于直线的单位法向量，d为直线到原点的最近有符号距离。<br />
<img src="./ComputerGraphicMath/00_09_02_line_normal.jpg" alt="00_09_02_line_normal.jpg" /><br />
n 描述了直线的朝向，d描述了直线的位置。另一种表示直线位置的方法是，给定直线上一点 q。下图展示了这种表示方法的原理：<br />
<img src="./ComputerGraphicMath/00_09_02_line_normal_point.jpg" alt="00_09_02_line_normal_point.jpg" /><br />
<a href="./ComputerGraphicMath/00_09_02_line_normal_point.ggb">./ComputerGraphicMath/00_09_02_line_normal_point.ggb</a><br />
<img src="./ComputerGraphicMath/00_09_02_line_normal_point_01.jpg" alt="00_09_02_line_normal_point_01.jpg" /><br />
</p>

<p>
下面方式使用两个点来表示直线，到这两个点的距离相等的点都在该直线上。<br />
<img src="./ComputerGraphicMath/00_09_02_line_two_point.jpg" alt="00_09_02_line_two_point.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgbe737fc" class="outline-5">
<h5 id="orgbe737fc">Converting between Representations</h5>
<div class="outline-text-5" id="text-orgbe737fc">
<p>
两点表示法与参数表示法互相转化：<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3d882f6" class="outline-4">
<h4 id="org3d882f6">Planes</h4>
<div class="outline-text-4" id="text-org3d882f6">
</div>
<div id="outline-container-org0c880ed" class="outline-5">
<h5 id="org0c880ed">The Plane Equation: An Implicit Definition of a Plane</h5>
<div class="outline-text-5" id="text-org0c880ed">
<p>
在 3D 空间中，给定一个 P 点和一个法线向量 n，经过 P 点并且和法线 n 垂直的平面 p 可以被定义为一系列点 Q，Q 满足 dot(n, Q-P) = 0。<br />
平面的方程为 ax + by + cz = d, 其中(a, b, c)为法线 n; d = dot(n, P-O)，d为平面到原点的距离. 可以将平面方程的意义理解为 OP 向量投影到平面法线 n 方向后的长度为 d。<br />
可以使用(a, b, c, -d) 来表示平面，(ka, kb, kc, -kd) 和 (a, b, c, -d)表示同一个平面。<br />
当 d=0 时，表示平面经过原点；<br />
当 d&lt;0 时，表示平面法线指向靠近原点；原点在平面前面<br />
当 d&gt;0 时，表示平面法线指向背离原点；原点在平面后面<br />
</p>

<p>
设点 P'=(x,y,z,1)，平面 p=(a,b,c,-d)，若 dot(P', p)=0，则点 P'在平面 p 上。<br />
<img src="./ComputerGraphicMath/plane_illustrate01.jpg" alt="plane_illustrate01.jpg" /><br />
<a href="./ComputerGraphicMath/plane_illustrate01.ggb">./ComputerGraphicMath/plane_illustrate01.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org5e698f0" class="outline-5">
<h5 id="org5e698f0">Defining a Plane by Using Three Points</h5>
<div class="outline-text-5" id="text-org5e698f0">
<p>
给定三个不共线的点，可以确定一个平面。<br />
<img src="./ComputerGraphicMath/plane_3point.jpg" alt="plane_3point.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8ec738c" class="outline-5">
<h5 id="org8ec738c">Best Fit Plane for More than Three Points</h5>
<div class="outline-text-5" id="text-org8ec738c">
<p>
由一组多边形的 n 个顶点，得到这组顶点对应的平面。一个简单的方案是任意取 3 个顶点来求平面，但是，这三个顶点有可能共线，另外多边形可能是凹多边形，此时任取三个顶点得到的平面的法线方向可能是反向的。<br />
按照下面方法可以得到正确的平面:<br />
<img src="./ComputerGraphicMath/plane_multi_point.jpg" alt="plane_multi_point.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgeaf2573" class="outline-5">
<h5 id="orgeaf2573">Distance From Point to Plane</h5>
<div class="outline-text-5" id="text-orgeaf2573">
<p>
dot(n, q-O) 为 q 点在 n 方向上到原点的距离，d为平面到原点的距离，因此，q点到平面的距离 a = dot(n, q-O) - d;<br />
<img src="./ComputerGraphicMath/plane_point_to_plane.jpg" alt="plane_point_to_plane.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org49a16f5" class="outline-4">
<h4 id="org49a16f5">Triangles</h4>
<div class="outline-text-4" id="text-org49a16f5">
</div>
<div id="outline-container-org564fb67" class="outline-5">
<h5 id="org564fb67">Notation</h5>
<div class="outline-text-5" id="text-org564fb67">
<p>
一个三角形由按顺序列出的三个顶点组成。这三个顶点的顺序是非常重要的。在左手坐标系中，当我们从三角形的正面看时，我们通常按照顺时针的方向列出这三个顶点。<br />
按照下图的方式标记三角形的内角，顺时针边向量，边的长度：<br />
<img src="./ComputerGraphicMath/00_09_06_triangle_notation_01.jpg" alt="00_09_06_triangle_notation_01.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org19bb8da" class="outline-5">
<h5 id="org19bb8da">Area of a Triangle</h5>
<div class="outline-text-5" id="text-org19bb8da">
</div>
<div id="outline-container-org3d37eeb" class="outline-6">
<h6 id="org3d37eeb">已知三条边长求面积：使用 Heron 公式</h6>
<div class="outline-text-6" id="text-org3d37eeb">
<p>
下面文件展示了 sine law, cos law, Heron formula 的证明：<br />
<img src="./ComputerGraphicMath/00_09_06_triangle_law_01.jpg" alt="00_09_06_triangle_law_01.jpg" /><br />
</p>

<p>
下面文件展示了三角形的内切圆：<br />
<a href="./ComputerGraphicMath/00_09_06_triangle_area_01.ggb">./ComputerGraphicMath/00_09_06_triangle_area_01.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-orgf2cee1f" class="outline-6">
<h6 id="orgf2cee1f">已知三顶点坐标求面积</h6>
<div class="outline-text-6" id="text-orgf2cee1f">
<p>
计算每条边和 x 轴围成的梯形区域的面积，并给面积赋予正负号，边的方向从左指向右为正，相反为负。<br />
<img src="./ComputerGraphicMath/00_09_06_triangle_area_01.jpg" alt="00_09_06_triangle_area_01.jpg" /><br />
</p>

<p>
这种方式计算的结果和使用向量叉乘计算结果是等价的。<br />
</p>
<ul class="org-ul">
<li>叉乘计算三角形面积 <a href="../graphics/PhysicallyBasedRendering.html#orgdb9df99">../graphics/PhysicallyBasedRendering.html#orgdb9df99</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9f697d8" class="outline-5">
<h5 id="org9f697d8">Barycentric Space</h5>
<div class="outline-text-5" id="text-org9f697d8">
<p>
即使我们确实是在 3D 空间中使用三角形，但是三角形的表面是在同一平面上的，其天生就是 2D 的对象。当我们不关心三角形在 3D 空间中具体的朝向，只对三角形本身进行研究时，我们可以使用重心空间。重心空间是和三角形表面相关的，其独立于三角形所在的 3D 空间。<br />
</p>

<p>
可以利用重心坐标来解决插值和求交点的问题。13 章 <a href="#org9a9c3db">Chapter13 Curves in 3D</a> 是重心空间更一般的形式。<br />
</p>

<p>
三角形所在面上的任意一点都可以表示为三个顶点的加权平均。这些权重就是重心坐标。使用下面公式可以将重心坐标转化为标准 3D 空间坐标：<br />
(b1, b2, b3) 对应的 3D 坐标为 b1v1 + b2v2 + b3v3<br />
其中 b1 + b2 + b3 = 1, 这样的归一化约束去掉了一个自由度，这就是为什么尽管这里有 3 个坐标，但是其依然为一个 2D 空间。<br />
</p>

<p>
重心空间将平面细分（tessellates）为多个和原始三角形大小相同的三角形：<br />
<img src="./ComputerGraphicMath/00_09_06_barycentric_space_tessellate.jpg" alt="00_09_06_barycentric_space_tessellate.jpg" /><br />
</p>

<p>
<img src="./ComputerGraphicMath/00_09_06_barycentric_space_reduce_freedom.jpg" alt="00_09_06_barycentric_space_reduce_freedom.jpg" /><br />
上面的推导，更加明确了，重心空间只有两个自由度。在重心空间中，我们完全可以只使用两个坐标来表示一个点。空间的秩不是由样本点的维度，也不是由样本点的个数决定的。例如，如果我们有两个样本点，重心坐标的维度为 2，此时其表达的是线。需要注意的是，这条线可以是 1D 的线（也就是对标量的插值），也可以是 2D 的线，或者是 3D 或更高维的线。<br />
</p>
</div>
</div>

<div id="outline-container-org277a9bc" class="outline-5">
<h5 id="org277a9bc">Calculating Barycentric Coordinates</h5>
<div class="outline-text-5" id="text-org277a9bc">

<div id="org6a62887" class="figure">
<p><img src="./ComputerGraphicMath/00_09_06_barycentric_coord_calc.jpg" alt="00_09_06_barycentric_coord_calc.jpg" /><br />
</p>
</div>

<p>
如果三角形的 3 个顶点共线，则三角形的面积就会为 0，上面计算公式中的分母就会为 0，此时无法计算重心坐标。<br />
计算 3D 空间中任意一点 p 的重心坐标要比 2D 空间要复杂。此时，我们有如下等式：<br />
b1x1 + b2x2 + b3x3 = px<br />
b1y1 + b2y2 + b3y3 = py<br />
b1z1 + b2z2 + b3z3 = pz<br />
b1 + b2 + b3 = 1<br />
p 有可能不在三角形所在的平面上，此时 p 的重心坐标是未定义的。<br />
我们可以通过直接忽略 x,y 或 z 其中一个分量，将三角形和 P 点投影到某个坐标平面上，然后再求重心坐标。<br />
为了避免投影后的三角形顶点共线，选择投影后面积最大的坐标平面为投影平面。可以比较三角形所在面的 normal 的各个分量的绝对值，直接忽略绝对值最大的分量，得到的投影面积最大。<br />
</p>

<p>
利用叉乘计算 Barycentric Coordinates 的另一种解释:<br />
<img src="./ComputerGraphicMath/00_09_06_barycentric_coord_calc_001.jpg" alt="00_09_06_barycentric_coord_calc_001.jpg" /><br />
</p>

<p>
下面文件图形化展示了其原理：<br />
<a href="./ComputerGraphicMath/00_09_06_barycentric_coord_calc_001.ggb">./ComputerGraphicMath/00_09_06_barycentric_coord_calc_001.ggb</a><br />
</p>

<ul class="org-ul">
<li>重心坐标（Barycentric coordinates）<a href="https://zhuanlan.zhihu.com/p/58199366">https://zhuanlan.zhihu.com/p/58199366</a><br /></li>
<li>三角形重心坐标 <a href="https://zhuanlan.zhihu.com/p/65495373">https://zhuanlan.zhihu.com/p/65495373</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5395942" class="outline-5">
<h5 id="org5395942">Special Points</h5>
<div class="outline-text-5" id="text-org5395942">

<div id="orgcd17d54" class="figure">
<p><img src="./ComputerGraphicMath/00_09_06_special_points.jpg" alt="00_09_06_special_points.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org506b5f0" class="outline-3">
<h3 id="org506b5f0">Chapter10 Mathematical Topics from 3D Graphics</h3>
<div class="outline-text-3" id="text-org506b5f0">
</div>
<div id="outline-container-org44fccab" class="outline-4">
<h4 id="org44fccab">How Graphics Work</h4>
<div class="outline-text-4" id="text-org44fccab">
<p>
渲染的最终目的是获得一张位图或一组按顺序排列的位图（用于制作动画）。一张位图是一个矩形颜色数组，数组的每个元素为像素（pixel 是 picture element 的简写）。位图也被称为 frame buffer，当我们将位图 copy 到最终的位图输出时，通常会执行附加的后处理。<br />
我们如何确定每个像素的颜色？这就是渲染要考虑的最基础问题。<br />
通过对自然界的分析（人之所以能看到物体是因为光进入了人的眼睛），以上问题可以转化为：从像素对应的方向进入到摄像机的光的颜色是什么？考虑进入摄像机的光，一共有以下两种情况：<br />
</p>
<ol class="org-ol">
<li>光直接从光源进入摄像机<br /></li>
<li>光从光源到达其他物体，然后经过物体的一次或多次反射再进入摄像机<br /></li>
</ol>
<p>
我们可以将上面的问题分解为两个任务，本书将这两个任务称为渲染算法：<br />
</p>
<ol class="org-ol">
<li>确定可见表面（Visible surface determination）. 找到在像素对应方向上最靠近摄像机的表面。<br /></li>
<li>确定光（Lighting）. 确定从该表面发射和反射到摄像机的光。<br /></li>
</ol>
</div>
<div id="outline-container-org6280fab" class="outline-5">
<h5 id="org6280fab">确定可见表面</h5>
<div class="outline-text-5" id="text-org6280fab">
<p>
确定可见表面一共有两种方案：<br />
</p>
<ol class="org-ol">
<li>射线追踪（Ray tracing）<br /></li>
<li>深度缓冲区 （Depth buffering）<br /></li>
</ol>

<p>
<img src="./ComputerGraphicMath/20_06_10_raytracing_depth_buffering.jpg" alt="20_06_10_raytracing_depth_buffering.jpg" /><br />
<img src="./ComputerGraphicMath/20_06_10_deferred_rendering.jpg" alt="20_06_10_deferred_rendering.jpg" /><br />
</p>
</div>
</div>

<div id="outline-container-orgb8667a4" class="outline-5">
<h5 id="orgb8667a4">确定光</h5>
<div class="outline-text-5" id="text-orgb8667a4">
<p>
当给定颜色的光从给定的入射方向照射到表面，有多少光从特定的方向反射出来？BRDF 可以回答该问题。<br />
BRDF 需要满足如下条件从而保证在物理上是合理的：<br />
</p>
<ol class="org-ol">
<li>在任何方向上不会有负的光被反射<br /></li>
<li>总的反射量不会大于所有的入射量<br /></li>
<li>入射方向和反射方向互换，BRDF 不变<br /></li>
</ol>
</div>
</div>

<div id="outline-container-org0fb5fe3" class="outline-5">
<h5 id="org0fb5fe3">辐射度学和色度学</h5>
<div class="outline-text-5" id="text-org0fb5fe3">
<p>
图形学其实就是测量光。如何测量光的颜色？如何测量光的亮度？<br />
</p>

<p>
复合可见光可以由任何数量的任意波长的单频可见光组合而成。<br />
颜色只是人类的感觉，其和频率不是同一事物。人类无法区别无限的单频可见光组合，不同的复合光可以产生相同的颜色感觉，这被称为条件等色。<br />
</p>

<p>
电磁波谱的可见部分是连续的，所以 BRDF(f(x, ˆωin, ˆωout, λ)) 表达式中的λ理论上也是连续的。实践中，我们制作图形给人类看，我们将无数不同的波长减少为 3 个特定波长。<br />
下图是辐射度学和色度学中测量光亮度使用的物理量：<br />
</p>


<div id="orgc1a9f88" class="figure">
<p><img src="./ComputerGraphicMath/20_06_10_radiometry_photometry_quntity.jpg" alt="20_06_10_radiometry_photometry_quntity.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf29f919" class="outline-5">
<h5 id="orgf29f919">渲染方程</h5>
<div class="outline-text-5" id="text-orgf29f919">
<p>
考虑光所有可能的入射方向，会得到一个以 x 点为中心的半圆，该半圆朝向表面法线 normal 指向的方向。对于每个可能的入射方向ωin，我们测量入射方向上光的颜色。BRDF 可以告诉我们ωin 方向上的入射辐射率有多少被反射到ˆωout 方向从而进入我们眼睛。将所有反射到ˆωout 方向上的辐射率加起来就可以得到总的反射进入我们眼睛的辐射率。然后再加上所有从表面直接发射到我们眼睛的辐射率，就得到总的辐射率。这就是渲染方程：<br />
</p>


<div id="org2e39b94" class="figure">
<p><img src="./ComputerGraphicMath/20_06_10_rendering_equation.jpg" alt="20_06_10_rendering_equation.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org57f1d43" class="outline-4">
<h4 id="org57f1d43">Viewing in 3D</h4>
<div class="outline-text-4" id="text-org57f1d43">
<p>
在渲染场景之前，需要选择一个摄像机和一个窗口。也就是说我们需要确定从哪儿渲染(视图的位置旋转和缩放)，以及要渲染到哪儿(屏幕上的矩形区域)。<br />
</p>
</div>
<div id="outline-container-org8c731ba" class="outline-5">
<h5 id="org8c731ba">指定输出窗口</h5>
<div class="outline-text-5" id="text-org8c731ba">
<p>
有时候我们不会将图片渲染到整个屏幕上。下图展示了指定的输出窗口：<br />
</p>


<div id="org0c988d5" class="figure">
<p><img src="./ComputerGraphicMath/20_06_10_output_windows.jpg" alt="20_06_10_output_windows.jpg" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orged3492e" class="outline-5">
<h5 id="orged3492e">Pixel Aspect Ratio 像素宽高比</h5>
<div class="outline-text-5" id="text-orged3492e">
<p>
pixPhysx/pixPhysy = (devPhysx/devPhysy) * (devResy/devResx)<br />
</p>

<p>
pixPhys 表示像素的物理尺寸<br />
devPhys 表示显示设备的物理尺寸<br />
devRes  表示显示设备的像素数量，也就是通常说的分辨率(Resolution)<br />
</p>

<p>
通常 pixel ratio 为 1:1，即像素是正方形的<br />
</p>
</div>
</div>
<div id="outline-container-org8f0dfb4" class="outline-5">
<h5 id="org8f0dfb4">The View Frustum 视景体</h5>
<div class="outline-text-5" id="text-org8f0dfb4">
<p>
视景体是摄像机可见区域的体积，其由 6 个裁剪平面包围而成。top、left、bottom、right 平面对应于输出窗口。near、far 平面对应于摄像机空间中的 z 值。<br />
</p>
</div>
</div>

<div id="outline-container-orgd6919fc" class="outline-5">
<h5 id="orgd6919fc">Field of View and Zoom</h5>
<div class="outline-text-5" id="text-orgd6919fc">
<p>
摄像机像其他物体一样也有位置和朝向，但是，它还有一个额外的属性 FOV。另一个你可能知道的概念是缩放或变焦(Zoom).当镜头向前推进（Zoom in）屏幕上显示的你正在看的物体会变大，镜头拉远(Zoom out)屏幕上显示的物体会变小。<br />
</p>

<p>
FOV 是视景体截取的角度。事实上我们需要两个角度来描述，水平 FOV 和竖直 FOV。<br />
</p>

<p>
变焦倍数描述的是物体显示尺寸相对于 FOV=90 时的比率. 例如，变焦倍数为 2 时，物体的显示尺寸为 FOV=90 时的两倍。下图为 Zoom 的几何表示：<br />
<img src="./ComputerGraphicMath/20_06_10_zoom_geometry.jpg" alt="20_06_10_zoom_geometry.jpg" /><br />
</p>

<p>
Zoom 和 FOV 的关系如下:<br />
zoom = 1 / tan (fov/2)<br />
fov = 2 arctan (1/zoom)<br />
</p>

<p>
我们需要两个不同的 FOV，一个水平方向的 HFOV，一个竖直方向的 VFOV。我们可以任意选择这两个 FOV 值，但是如果这两个值不满足特定的比例关系，则最后渲染的图片会被拉伸。为了维持特定的比例，变焦倍数的比例必须和输出窗口的物理区域比例相同：<br />
zoomy/zoomx = winPhysx/winPhysy = window aspect ratio<br />
zoomy/zoomx = winPhysx/winPhysy = winResx/winResy * pixPhysx/pixPhysy = winResx/winResy * devPhysx/devPhysy * devResy/devResx<br />
</p>
<ul class="org-ul">
<li>zoom 为摄像机变焦倍数<br /></li>
<li>winPhys 为输出窗口的物理尺寸<br /></li>
<li>winRes 为输出窗口的像素分辨率<br /></li>
<li>pixPhy 为一个像素的尺寸<br /></li>
<li>devPhy 为输出设备的物理尺寸。通常我们不知道具体尺寸，但是我们知道其长宽比。<br /></li>
<li>devRes 为输出设备的分辨率<br /></li>

<li><a href="https://baike.baidu.com/item/%E4%BA%BA%E7%9C%BC%E8%A7%86%E5%BA%A6">https://baike.baidu.com/item/%E4%BA%BA%E7%9C%BC%E8%A7%86%E5%BA%A6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6d8407c" class="outline-5">
<h5 id="org6d8407c">Orthographic Projection</h5>
<div class="outline-text-5" id="text-org6d8407c">
<p>
正交投影没有 FOV，因为正交投影的视景体为正方体。我们没有使用两个角度来定义视景体 x 和 y 方向上的尺寸, 而是通过视景体的宽和高来定义。变焦倍数也有不同的意义，其和视景体的尺寸相关：<br />
zoom = 2/size;<br />
size = 2/zoom;<br />
和透视投影一样，有两个 Zoom 值，他们之间的比值需要和渲染窗口的宽高比要一致，否则画面会被拉伸。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8b9f519" class="outline-4">
<h4 id="org8b9f519">Coordinate Spaces</h4>
<div class="outline-text-4" id="text-org8b9f519">
</div>
<div id="outline-container-org6f88059" class="outline-5">
<h5 id="org6f88059">Clip Space and the Clip Matrix</h5>
<div class="outline-text-5" id="text-org6f88059">
<p>
在摄像机坐标系下，顶点会被变换到 clip space（裁剪坐标系），也被称为 canonical view volume space（标准视景体坐标系）。对应的变换矩阵被称为 clip matrix(裁剪矩阵)，也被称为投影矩阵。<br />
裁剪矩阵提供了两个主要的功能：<br />
</p>
<ol class="org-ol">
<li>为投影做准备<br />
将 w 分量中放入恰当的值，从而使得齐次除法可以得到希望的投影。对于典型的透视投影来说，意味着将 z 放到 w 分量。<br /></li>
<li>应用变焦并且为裁剪做准备<br />
缩放 x,y,z 从而可以将缩放后的 x,y,z 和 w 进行比较来进行裁剪。因为变焦倍数影响了视景体的形状，从而会影响到裁剪，所以缩放同时也考虑了变焦。<br /></li>
</ol>
</div>
</div>

<div id="outline-container-org001bf90" class="outline-5">
<h5 id="org001bf90">The Clip Matrix: Preparing For Projection</h5>
<div class="outline-text-5" id="text-org001bf90">
</div>
<div id="outline-container-org48d7355" class="outline-6">
<h6 id="org48d7355">透视投影矩阵</h6>
<div class="outline-text-6" id="text-org48d7355">
<pre class="example" id="org5a2a48f">
          | 1 0 0 0 |
          | 0 1 0 0 |
[x y z 1] | 0 0 1 1 | = [x y z z] ==&gt; [x/z y/z 1]
          | 0 0 0 0 |
</pre>
</div>

<ul class="org-ul">
<li><a id="org89f9672"></a>为什么使用齐次坐标系？<br />
<div class="outline-text-7" id="text-org89f9672">
<ol class="org-ol">
<li>齐次坐标可以更自然地表示广泛的摄像机规格<br />
正交摄像机不需要特殊对待<br />
视景体平面不需要关于摄像机中心朝向对称<br /></li>
<li>齐次坐标使得 z-clipping 和 x-y-clipping 完全一样。对于某些硬件，向量处理单元可以被并行地用于处理裁剪测试。<br /></li>
<li>大多数 API 需要齐次坐标。<br /></li>
</ol>
</div>
</li>


<li><a id="org823d4ff"></a>为什么上面矩阵没有 d?<br />
<div class="outline-text-7" id="text-org823d4ff">
<p>
在 <a href="#org29b05ad">No description for this link</a> 中我们推导出的投影矩阵中包含 d，而上面的投影矩阵中没有 d。<br />
d 表示投影平面到焦点（投影中心点）的距离。上面之所以没有使用 d，是因为 d 的选取是不重要的，而为了方便我们选择 d=1。<br />
在真实的摄像机中，增加焦点到投影平面的距离会让投影的物体变大，减小则会让投影的物体变小。下图从左到右 d 逐渐增大：<br />
<img src="./ComputerGraphicMath/20_06_10_real_camera_zoom_effect.jpg" alt="20_06_10_real_camera_zoom_effect.jpg" /><br />
需要注意的是上图中胶片的尺寸是固定的，增大 d，胶片远离焦点平面，视景体对应的 FOV 变小。减小 d，胶片靠近焦点平面，视景体对应的 FOV 变大。当视景体变小时，视景体中的物体占用了可视区域的一大部分，导致其投影的像会变大。<br />
在计算机中，胶片是投影平面和视景体相交的部分。当我们增大焦距时，投影的像也会对应增大，就像真实摄像机中发生的一样。但是，在计算机中，胶片也以对应的比例增大，而视景体大小则没有变换。因为投影的像和胶片增大相同的比例，所以最终显示在图片上的物体的大小没有变化。<br />
总的来说，变焦是通过改变视景体形状来完成的。对于真实摄像机来说，改变焦距会改变视景体的形状，因为胶片大小保持不变。在计算机中，改变焦距不会影响渲染的图片，因为胶片尺寸也会对应增大，而视景体形状没有改变。所以上面矩阵中 d 的选择是无关紧要的。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orge8dd22b" class="outline-6">
<h6 id="orge8dd22b">正交投影矩阵</h6>
<div class="outline-text-6" id="text-orge8dd22b">
<p>
正交投影时，我们不希望执行透视除法，所以其投影矩阵如下：<br />
</p>
<pre class="example" id="orgbb074b8">
          | 1 0 0 0 |
          | 0 1 0 0 |
[x y z 1] | 0 0 1 0 | = [x y z 1] ==&gt; [x y z]
          | 0 0 0 1 |
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8add3e" class="outline-5">
<h5 id="orgf8add3e">The Clip Matrix: Applying Zoom and Preparing for Clipping</h5>
<div class="outline-text-5" id="text-orgf8add3e">
</div>
<div id="outline-container-org7ba6545" class="outline-6">
<h6 id="org7ba6545">透视投影矩阵</h6>
<div class="outline-text-6" id="text-org7ba6545">
<p>
裁剪矩阵的第二个目标是缩放 x,y,z 分量，使得六个裁剪平面有简单的形式。如下图所示，注意如果两个摄像机的 near 和 far 分别相等，那么这两个摄像机的视景体被变换到裁剪空间后是完全相同的，但是变换所使用的矩阵各不相同。<br />
<img src="./ComputerGraphicMath/20_03_17_perspective.jpg" alt="20_03_17_perspective.jpg" /><br />
</p>

<pre class="example" id="org2f1565f">
// 缩放后，满足如下任何一个不等式的点在视景体外面：
Bottom   y &lt; −w
Top      y &gt; w
Left     x &lt; −w
Right    x &gt; w
Near     z &lt; −w
Far      z &gt; w
// 缩放后，满足如下所有不等式的点在视景体内：
−w ≤ x ≤ w
−w ≤ y ≤ w
−w ≤ z ≤ w
</pre>

<p>
我们通过将 x 和 y 按照摄像机的变焦倍数进行缩放，从而将 top left right bottom 这 4 个裁剪平面放置到正确位置。下图显示了其中的变换原理：<br />
<a href="./ComputerGraphicMath/20_06_11_clip_matrix.ggb">./ComputerGraphicMath/20_06_11_clip_matrix.ggb</a><br />
<img src="./ComputerGraphicMath/20_06_11_clip_matrix_xy.jpg" alt="20_06_11_clip_matrix_xy.jpg" /><br />
</p>

<p>
对于 near 和 far 裁剪平面，缩放后近平面的 z 值变为-near，远平面的 z 值变为 far，这样执行透视除法后，z的范围变为[-1,1]。由此可得到 z 和 z'的关系为：<br />
</p>
<pre class="example" id="org2f28f15">
Z'  = AZ+B
-Zn = AZn+B
Zf  = AZf+B
A = (Zf+Zn)/(Zf-Zn)
B = -2ZnZf/(Zf-Zn)

由此可得最终的裁剪矩阵为：

zoomx 0       0              0
0     zoomy   0              0
0     0       (f+n)/(f-n)    1
0     0       −2nf/(f−n)     0

// 坐标经过上面的裁剪矩阵变换后得到的坐标
// 在视景体近平面上的点
(0, 0,   n, 1) * Mproj = (0, 0, -n, n) 
// 在视景体近平面前面的点 
(0, 0, n/2, 1) * Mproj = (0, 0, n(n-3f)/(2(f-n)), n/2)

DirectX 规定裁剪变换后视景体的 z 值范围为 0&lt;=z&lt;=w，其对应的投影矩阵为：
zoomx 0       0              0
0     zoomy   0              0
0     0       (f)/(f-n)      1
0     0       −nf/(f−n)      0
</pre>
</div>
<ul class="org-ul">
<li><a id="org56a2244"></a>Q&amp;A: 当 z 为 0 时，透视除法不是会出现除 0 的问题么？<br />
<div class="outline-text-7" id="text-org56a2244">
<p>
在执行投影变换之前会先执行 View 变换，将物体从世界坐标系转换为摄像机坐标系下，此时 z 为物体到摄像机原点的距离，摄像机设置了近平面 near，z 小于 near 的物体都会被裁剪掉，后续就不会发生除 0 的情况了。<br />
</p>
<pre class="example" id="org5d464b9">
// 下面为摄像机坐标系下(0,0,0)点 执行透视投影的过程
              zoomx 0      0            0
              0     zoomy  0            0
0, 0, 0, 1    0     0      (f+n)/(f-n)  1   =  0, 0, -2nf/(f-n), 0                   -2nf/(f-n) 为z，0为w，其不满足−w ≤ z ≤ w，所以被剔除掉了，后续就不会发生除0的情况了
              0     0      -2nf/(f-n)   0

// 下面为摄像机坐标系下(0,0,-1)点 执行透视投影的过程
              zoomx 0      0            0
              0     zoomy  0            0
0, 0, -1, 1   0     0      (f+n)/(f-n)  1   =  0, 0, -(f+n)/(f-n)-2nf/(f-n), -1      -(f+n)/(f-n)-2nf/(f-n)为z，-1为w，其不满足−w ≤ z ≤ w，所以被剔除掉了，后续就不会发生除0的情况了
              0     0      -2nf/(f-n)   0
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf657573" class="outline-6">
<h6 id="orgf657573">正交投影矩阵</h6>
<div class="outline-text-6" id="text-orgf657573">
<p>
正交投影时，因为其没有透视除法，所以裁剪变换后的 x,y,z 的范围直接就是[-1,1] 。如下图所示，由此可得到 p 和 p'的关系为：<br />
<img src="./ComputerGraphicMath/20_03_17_orthographic.jpg" alt="20_03_17_orthographic.jpg" /><br />
</p>
<pre class="example" id="org161836f">
w 为视景体的宽 h为视景体的高

X' = AX+B
-1 = -Aw/2+B
1 = Aw/2+B
A = 2/w = zoomx
B = 0

Z' = AZ+B
-1 = AZn+B
1  = AZf+B
A = 2/(f-n)
B = -(f+n)/(f-n)

由此可得到最终的裁剪矩阵为：
zoomx 0       0              0
0     zoomy   0              0
0     0       2/(f-n)        0
0     0       −(f+n)/(f−n)   1

DirectX 规定裁剪变换后视景体的z值范围为[0, 1]，其对于的投影矩阵为：
zoomx 0       0              0
0     zoomy   0              0
0     0       1/(f-n)        0
0     0       n/(f−n)        1
</pre>
</div>
</div>
<div id="outline-container-orgbb83ed3" class="outline-6">
<h6 id="orgbb83ed3">OpenGL 裁剪矩阵</h6>
<div class="outline-text-6" id="text-orgbb83ed3">
<pre class="example" id="org4d3d467">
上面的裁剪矩阵基于本书的默认惯例，即坐标系为左手坐标系，向量为行向量。
Direct坐标系为左手坐标系，向量为行向量。
OpenGL坐标系为右手坐标系，向量为列向量。
将上面的裁剪矩阵转化为OpenGL使用的形式，首先需要将矩阵转置，其次，由于右手坐标系摄像机空间中-z指向屏幕内，而其裁剪空间+z指向屏幕内(OpenGL的裁剪空间其实为左手坐标系)。因此需要将输入的z值取反。

Tips: 为何OpenGL的NDC坐标系为左手？
为了将NDC坐标系原点和屏幕坐标原点一致。
如果NDC坐标系依然为右手，为了让z缓冲区中越小的值表示越近，越大的值表示越远，需要让坐标系正z方向指向屏幕内，即需要绕y旋转180度，此时坐标系的原点变为了右下角。
如果NDC坐标系转换为左手，此时坐标系正z方向指向屏幕内，且NDC坐标系原点在左下角。

由此可得OpenGL的透视投影矩阵为：
zoomx 0       0              0
0     zoomy   0              0
0     0       -(f+n)/(f-n)   −2nf/(f−n)
0     0       -1             0

对应的OpenGL的正交投影矩阵为：
zoomx 0       0              0
0     zoomy   0              0
0     0       -2/(f-n)       −(f+n)/(f−n)
0     0       0              1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeafeea8" class="outline-5">
<h5 id="orgeafeea8">Screen Space</h5>
<div class="outline-text-5" id="text-orgeafeea8">
</div>
<div id="outline-container-orgac13f38" class="outline-6">
<h6 id="orgac13f38">透视除法(NDC 坐标系)</h6>
<div class="outline-text-6" id="text-orgac13f38">
<p>
执行齐次除法即透视除法（OpenGL 中将齐次除法后的结果称为标准设备坐标）<br />
<a href="./ComputerGraphicMath/00_10_03_04_world-to-ndc.webm">./ComputerGraphicMath/00_10_03_04_world-to-ndc.webm</a><br />
</p>

<ul class="org-ul">
<li>上面视频文件来自该文章 <a href="https://jsantell.com/3d-projection/">https://jsantell.com/3d-projection/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2d29c48" class="outline-6">
<h6 id="org2d29c48">viewport 变换</h6>
<div class="outline-text-6" id="text-org2d29c48">
<p>
当我们将几何体裁剪后，它将被投影到屏幕空间。首先执行齐次除法即透视除法（OpenGL 中将齐次除法后的结果称为标准设备坐标）。然后，将 x、y 坐标缩放到输出窗口。如下为公式表示：<br />
screenx = clipx · winResx / (2 · clipw) + winCenterx<br />
screeny = -clipy · winResx / (2 · clipw) + winCenterx<br />
<img src="./ComputerGraphicMath/20_06_11_screenSpace.jpg" alt="20_06_11_screenSpace.jpg" /><br />
</p>

<p>
上面 clipY 需要取反，是由于 DirectX 规定屏幕空间中左上角为坐标原点。<br />
OpenGL 则规定屏幕空间中右下角为坐标原点，其 clipY 不需要取反。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8370808"></a>clipX、clipY 转化为了屏幕坐标，那么 clipZ clipW 呢？<br />
<div class="outline-text-7" id="text-org8370808">
<p>
传统的方法是齐次除法后，clipZ/clipW 会被标准化，并将其值存储到深度缓存区中。具体的细节由哪种类型的裁剪值被用于裁剪以及哪种类型的深度值被存入深度缓存区。例如，OpenGL 中，概念上的惯例是 -1&lt;=clipZ/clipW&lt;=1，但是这可能对于深度缓存不够友好。驱动提供商需要将 API 的惯例转化为对硬件最友好的。<br />
</p>

<p>
令一种策略被称为 w-buffering，其使用 clipW 作为深度值。大多数情况下 clipW 为摄像机空间 z 坐标值的缩放版本。当深度缓冲区使用有限精度的顶点数表示时，这种方式使得精度分布更平均。传统的以 clipZ/clipW 为深度值的方式，会导致近处的精度高，而远处的精度低。如果深度缓存区使用浮点数表示时，则这个问题就不会太重要。需要注意的是，w-buffering 不支持正交投影，因为其 w 值始终输出为 1.<br />
</p>

<p>
在光栅化阶段，clipW 还被用于对贴图坐标，颜色以及其他顶点层次数据的插值做透视矫正。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5e5e854" class="outline-6">
<h6 id="org5e5e854">插值透视矫正</h6>
<div class="outline-text-6" id="text-org5e5e854">
<p>
下图展示了透视插值矫正的推导：<br />
<img src="./ComputerGraphicMath/00_10_03_04_perspective_correct_01.jpg" alt="00_10_03_04_perspective_correct_01.jpg" /><br />
另一种思路是推导出屏幕空间中 lerp 参数(screenLerp)和世界空间中 lerp 参数(worldLerp)的关系，光栅化时，直接使用 screenLerp 求出 worldLerp，然后使用 worldLerp 进行插值。这种思路的推导，请参考下面链接：<br />
</p>
<ul class="org-ul">
<li><a href="https://github.com/ssloy/tinyrenderer/wiki/Technical-difficulties-linear-interpolation-with-perspective-deformations">https://github.com/ssloy/tinyrenderer/wiki/Technical-difficulties-linear-interpolation-with-perspective-deformations</a><br /></li>
</ul>

<p>
下面文件为透视矫正原理的图形展示：<br />
<a href="./ComputerGraphicMath/00_10_03_04_perspective_correct_02.ggb">./ComputerGraphicMath/00_10_03_04_perspective_correct_02.ggb</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org5eb25fc" class="outline-4">
<h4 id="org5eb25fc">Polygon Meshes</h4>
</div>
<div id="outline-container-org7a9d466" class="outline-4">
<h4 id="org7a9d466">Texture Mapping</h4>
</div>
<div id="outline-container-org129b40b" class="outline-4">
<h4 id="org129b40b">The Standard Local Lighting Model</h4>
</div>
<div id="outline-container-orgc79ef61" class="outline-4">
<h4 id="orgc79ef61">Light Sources</h4>
</div>
<div id="outline-container-orgec92fde" class="outline-4">
<h4 id="orgec92fde">Skeletal Animation</h4>
</div>
<div id="outline-container-orgce23a8b" class="outline-4">
<h4 id="orgce23a8b">Bump Mapping</h4>
<div class="outline-text-4" id="text-orgce23a8b">
</div>
<div id="outline-container-org3011ef4" class="outline-5">
<h5 id="org3011ef4">Tangent Space</h5>
</div>
<div id="outline-container-org40b1d1f" class="outline-5">
<h5 id="org40b1d1f">Calculating Tangent Space Basis Vectors</h5>
<div class="outline-text-5" id="text-org40b1d1f">
<p>
下面文件展示了计算 Tangent Space 基向量的原理：<br />
<a href="./ComputerGraphicMath/00_10_09_calc_tangent_space_basis_vector.ggb">./ComputerGraphicMath/00_10_09_calc_tangent_space_basis_vector.ggb</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgae62e71" class="outline-4">
<h4 id="orgae62e71">The RealTimeGraphics Pipeline</h4>
</div>
</div>
<div id="outline-container-org9a9c3db" class="outline-3">
<h3 id="org9a9c3db">Chapter13 Curves in 3D</h3>
</div>
</div>
<div id="outline-container-org40d7f7b" class="outline-2">
<h2 id="org40d7f7b">向量点乘</h2>
<div class="outline-text-2" id="text-org40d7f7b">
<ul class="org-ul">
<li>点积和叉乘的出现背景是什么？ <a href="https://www.zhihu.com/question/349692615">https://www.zhihu.com/question/349692615</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7d59835" class="outline-2">
<h2 id="org7d59835">矩阵和线性变换</h2>
<div class="outline-text-2" id="text-org7d59835">
</div>
<div id="outline-container-org94efd50" class="outline-3">
<h3 id="org94efd50">变换物体和变换坐标系</h3>
<div class="outline-text-3" id="text-org94efd50">
<p>
有些情况下需要进行物体变换，另外一些情况下则需要进行坐标系变换。但是，这两种变换实际上是等价的，将物体变换一个量等价于将坐标系变换一个相反的量。<br />
变换坐标系，其实就是将以该坐标系表示的所有物体都进行和该坐标系相同的变换。<br />
</p>
</div>

<div id="outline-container-orga28e119" class="outline-4">
<h4 id="orga28e119">矩阵旋转变换实例</h4>
<div class="outline-text-4" id="text-orga28e119">
<p>
逆时针旋转 &Theta; 的变换矩阵为<br />
 cos(&Theta;) sin(&Theta;)<br />
-sin(&Theta;) cos(&Theta;)<br />
</p>

<p>
其逆矩阵(顺时针旋转 &Theta; 的矩阵)为<br />
cos(&Theta;) -sin(&Theta;)<br />
sin(&Theta;)  cos(&Theta;)<br />
</p>

<p>
假定 &Theta; 为 30 度, 世界坐标系下点 W(2, 2) 通过上面的矩阵变换变为了 (cos(30), sin(30)) 点<br />
Aw = [2, 2]<br />
Ao = [2, 2] [cos(30), -sin(30)] = [2cos(30)+2sin(30), 2cos(30)-2sin(30)]<br />
            [sin(30),  cos(30)]<br />
物体坐标系下 Ao 的坐标和世界坐标系下 Aw 的坐标重合<br />
</p>

<p>
假定 &Theta; 为 30 度, 物体坐标系下点 B(1, 1) 通过上面的矩阵变换变为了 (sin(30), cos(30))<br />
Bo = [1, 1]<br />
Bw = [1, 1] [ cos(30), sin(30)] = [cos(30)-sin(30), cos(30)+sin(30)]<br />
            [-sin(30), cos(30)]<br />
物体坐标系下 Bo 的坐标和世界坐标系下 Bw 的坐标重合<br />
</p>

<p>
下面的文件中表示了上面的变换过程：<br />
<a href="./ComputerGraphicMath/20_05_08_RotationTrans.ggb">./ComputerGraphicMath/20_05_08_RotationTrans.ggb</a><br />
</p>

<p>
下图是上面文件对应的截图：<br />
<img src="./ComputerGraphicMath/20_05_08_RotationTrans.jpg" alt="20_05_08_RotationTrans.jpg" /><br />
</p>

<p>
Tips: 需要注意的是通过新的物体坐标系的基向量和坐标原点构建的变换矩阵是新坐标系到世界坐标系的变换，其逆矩阵才是世界坐标系到新的物体坐标系的变换。<br />
</p>
</div>
</div>

<div id="outline-container-orgb0d9bf7" class="outline-4">
<h4 id="orgb0d9bf7">矩阵平移变换实例</h4>
<div class="outline-text-4" id="text-orgb0d9bf7">

<div id="org75e8de2" class="figure">
<p><img src="ComputerGraphicMath/8_1_transform_obj_coordidate.jpg" alt="8_1_transform_obj_coordidate.jpg" /><br />
</p>
</div>

<p>
世界坐标系到物体坐标系的矩阵表示为：<br />
o = (0,0)<br />
xAxis = (1, 0)<br />
yAxis = (0, 1)<br />
</p>

<p>
1,  0,  0<br />
0,  1,  0<br />
-3, -1, 0<br />
</p>

<p>
物体坐标系到世界坐标系的矩阵表示为：<br />
o = (3, 1)<br />
xAxis = (1, 0)<br />
yAxis = (0, 1)<br />
</p>

<p>
1, 0, 0<br />
0, 1, 0<br />
3, 1, 1<br />
</p>

<p>
下面 ggb 文件，展示了 \(A_w\) 的坐标变换:<br />
<a href="./ComputerGraphicMath/20_03_29_A_wTrans.ggb">./ComputerGraphicMath/20_03_29_A_wTrans.ggb</a><br />
需要注意的是平移变换通过额外的维度来实现的，所以上面文件中，\(A_o\) 只在二维坐标系中正确，在三维坐标系中其正确的坐标应该是 (-1,1,2)<br />
</p>

<p>
下面 ggb 文件，展示了 \(a_o\) 的坐标变换:<br />
<a href="./ComputerGraphicMath/20_03_29_a_oTrans.ggb">./ComputerGraphicMath/20_03_29_a_oTrans.ggb</a><br />
需要注意的是平移变换通过额外的维度来实现的，所以上面文件中，\(a_o\) 只在二维坐标系中正确，在三维坐标系中其正确的坐标应该是 (4,2,2)<br />
</p>

\begin{align}  
&如上图，世界坐标系 W 通过向 x 正方向平移 3 向 y 正方向平移 1 可以变换为物体坐标系 O \nonumber\\
&向 x 正方形平移 3，向 y 正方形平移 1 的变换矩阵为：\nonumber\\
&\left[
\begin{matrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  3 & 1 & 1
\end{matrix}
\right]\nonumber\\
&该矩阵的逆矩阵为：\nonumber \\
&\left[
\begin{matrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  -3 & -1 & 1\\
\end{matrix}
\right]\nonumber\\
&A_w=(2,2)为用世界坐标系 W 表示的一个点, a_o=(1,1)为用物体坐标系 O 表示的一个点\\
&A_o 为在物体坐标系 O 中表示 A_w 点，a_w 为在世界坐标系中表示 a_o 点\\
&A_w = 
\left[2, 2, 1\right]
\,
\left[
\begin{matrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  -3 & -1 & 1\\
\end{matrix}
\right] =
\left[-1, 1, 1\right] = A_o \nonumber\\
&A_w = 
\left[2, 2, 1, 1\right]
\,
\left[
\begin{matrix}
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
  -3 & -1 & 1 & 1\\
\end{matrix}
\right] =
\left[-1, 1, 2, 1\right] = A_o \nonumber\\
&a_o = 
\left[1, 1, 1\right]
\,
\left[
\begin{matrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  3 & 1 & 1\\
\end{matrix}
\right] =
\left[4, 2, 1\right] = a_w \nonumber\\
&a_o = 
\left[1, 1, 1, 1\right]
\,
\left[
\begin{matrix}
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
  3 & 1 & 1 & 1\\
\end{matrix}
\right] =
\left[4, 2, 2, 1\right] = a_w \nonumber\\
\end{align} 
</div>
</div>
</div>
<div id="outline-container-org58f58ba" class="outline-3">
<h3 id="org58f58ba">投影变换</h3>
<div class="outline-text-3" id="text-org58f58ba">
</div>
<div id="outline-container-orgcb0c2b1" class="outline-4">
<h4 id="orgcb0c2b1">投影变换推导</h4>
<div class="outline-text-4" id="text-orgcb0c2b1">
<p>
摄像机坐标系下，未执行投影变换时，Z值范围为[-f, -n]。<br />
NDC 坐标的 Z 值范围为[-1,1]<br />
ZBuffer 中存储[0,1]范围的 Z 值<br />
</p>


<div id="org92237ce" class="figure">
<p><img src="./ComputerGraphicMath/20_01_06_projMatrix.png" alt="20_01_06_projMatrix.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org279b750" class="outline-4">
<h4 id="org279b750">投影变换及其逆变换推导</h4>
<div class="outline-text-4" id="text-org279b750">
<p>
<img src="./ComputerGraphicMath/21_01_11_projMatrix001.jpg" alt="21_01_11_projMatrix001.jpg" /><br />
<img src="./ComputerGraphicMath/21_01_11_projMatrix002.jpg" alt="21_01_11_projMatrix002.jpg" /><br />
<img src="./ComputerGraphicMath/depthToEyeZ_LinearZ.jpg" alt="depthToEyeZ_LinearZ.jpg" /><br />
</p>
</div>
<div id="outline-container-org79dbe10" class="outline-5">
<h5 id="org79dbe10">为什么离 near plane 越远，depth 精度越小？</h5>
<div class="outline-text-5" id="text-org79dbe10">
<p>
GeoGebra 软件打开下面文件，可以动态改变 near 和 far 的值:<br />
<a href="./ComputerGraphicMath/21_01_11_zfighting.ggb">./ComputerGraphicMath/21_01_11_zfighting.ggb</a><br />
</p>


<div id="orgd091b33" class="figure">
<p><img src="./ComputerGraphicMath/21_01_11_projMatrix003.jpg" alt="21_01_11_projMatrix003.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga27ba87" class="outline-4">
<h4 id="orga27ba87">Clip Space 是怎样的？</h4>
<div class="outline-text-4" id="text-orga27ba87">
<p>
<img src="./ComputerGraphicMath/20_03_17_clipSpace.png" alt="20_03_17_clipSpace.png" /><br />
<img src="./ComputerGraphicMath/20_03_17_orthographic.jpg" alt="20_03_17_orthographic.jpg" /><br />
<img src="./ComputerGraphicMath/20_03_17_perspective.jpg" alt="20_03_17_perspective.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgd5600c1" class="outline-4">
<h4 id="orgd5600c1">自己做深度剔除</h4>
<div class="outline-text-4" id="text-orgd5600c1">
<div class="org-src-container">
<pre class="src src-shader">  vertexOutput <span style="color: #bc6ec5; font-weight: bold;">vert</span>(vertexInput input)
  {
      vertexOutput output;
      output.pos = UnityObjectToClipPos(input.vertex);
      output.texCoord = input.texCoord;

      output.screenPos = ComputeScreenPos(output.pos);
      output.linearDepth = -(UnityObjectToViewPos(input.vertex).z * <span style="color: #7590db;">_ProjectionParams</span>.w);

      <span style="color: #4f97d7; font-weight: bold;">return</span> output;
  }

  <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(vertexOutput input) : <span style="color: #a45bad;">COLOR</span>
  {
      <span style="color: #ce537a; font-weight: bold;">float4</span> c = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 0, 1);

      <span style="color: #ce537a; font-weight: bold;">float2</span> uv = input.screenPos.xy / input.screenPos.w; 
      <span style="color: #ce537a; font-weight: bold;">float</span> camDepth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, uv);
      camDepth = Linear01Depth (camDepth); 

      <span style="color: #ce537a; font-weight: bold;">float</span> diff = <span style="color: #4f97d7;">saturate</span>(input.linearDepth - camDepth);
      c =<span style="color: #4f97d7;">lerp</span>(c, <span style="color: #ce537a; font-weight: bold;">float4</span>(1, 0, 0, 1),diff  &lt; 1);

      <span style="color: #4f97d7; font-weight: bold;">return</span> c;
  }
</pre>
</div>

<ul class="org-ul">
<li><a href="https://www.wonderm.cc/2019/03/04/CommandBuffer-01/">https://www.wonderm.cc/2019/03/04/CommandBuffer-01/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org486a281" class="outline-4">
<h4 id="org486a281">如何从深度缓冲区中重建世界空间位置?</h4>
<div class="outline-text-4" id="text-org486a281">
</div>
<div id="outline-container-org1f406c1" class="outline-5">
<h5 id="org1f406c1">使用投影矩阵逆矩阵</h5>
<div class="outline-text-5" id="text-org1f406c1">
<ul class="org-ul">
<li>Unity 从深度缓冲重建世界空间位置<br /></li>
<li>求投影矩阵的逆矩阵 <a href="https://www.cnblogs.com/back-to-the-past/p/12293520.html">https://www.cnblogs.com/back-to-the-past/p/12293520.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2edaf21" class="outline-5">
<h5 id="org2edaf21">使用摄像机</h5>
</div>
</div>
<div id="outline-container-orgd00821d" class="outline-4">
<h4 id="orgd00821d">参考资料</h4>
<div class="outline-text-4" id="text-orgd00821d">
<ul class="org-ul">
<li>OpenGL Projection Matrix <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a><br /></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd453ade" class="outline-2">
<h2 id="orgd453ade">Clipping</h2>
<div class="outline-text-2" id="text-orgd453ade">
<p>
<a href="./ComputerGraphicMath/01_clipping_using_homogeneous_coord.ggb">./ComputerGraphicMath/01_clipping_using_homogeneous_coord.ggb</a><br />
</p>

<p>
<img src="./ComputerGraphicMath/01_clipping_using_homogeneous_001.jpg" alt="01_clipping_using_homogeneous_001.jpg" /><br />
<img src="./ComputerGraphicMath/01_clipping_using_homogeneous_002.jpg" alt="01_clipping_using_homogeneous_002.jpg" /><br />
<img src="./ComputerGraphicMath/01_clipping_using_homogeneous_003.jpg" alt="01_clipping_using_homogeneous_003.jpg" /><br />
</p>

<p>
下面图片补充说明齐次空间透视投影矩阵产生的效果：<br />
<img src="./ComputerGraphicMath/01_clipping_using_homogeneous_004.jpg" alt="01_clipping_using_homogeneous_004.jpg" /><br />
</p>

<p>
顶点经过过透视投影变换后，到了齐次裁剪空间，假设原始顶点 x,y 都为 0，此时裁剪空间的顶点可以使用 2D 坐标系描述，下面文件展示了该情况下，齐次空间的顶点。从下图可以看出，对线段 P0P1 进行裁剪时，无论如何 P0P1 和裁剪平面的交点都不会在 w=0 的线上，给定 near 和 far 值后，齐次空间的点(0,0,z',w')都会在直线 P0P1 上，改变 near 和 far 值会改变直线的斜率，但是斜率永远在(0,1)范围。因此，如果绘制的模型都是三角形、线段、点则不需要 w 裁剪平面。<br />
</p>


<div id="orgcd5e783" class="figure">
<p><img src="./ComputerGraphicMath/w_clipping_plane.jpg" alt="w_clipping_plane.jpg" /><br />
</p>
</div>

<p>
<a href="./ComputerGraphicMath/w_clip_plane.ggb">./ComputerGraphicMath/w_clip_plane.ggb</a><br />
</p>

<p>
下面文章中都应用了 W Clipping Plane，Why？<br />
</p>

<ul class="org-ul">
<li><a href="https://fabiensanglard.net/polygon_codec/">https://fabiensanglard.net/polygon_codec/</a><br /></li>
<li><a href="https://fabiensanglard.net/polygon_codec/clippingdocument/p245-blinn.pdf">https://fabiensanglard.net/polygon_codec/clippingdocument/p245-blinn.pdf</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1aeb25f" class="outline-2">
<h2 id="org1aeb25f">参考资料</h2>
<div class="outline-text-2" id="text-org1aeb25f">
<ul class="org-ul">
<li>GeoGebra 数学工具 <a href="https://www.geogebra.org/geometry">https://www.geogebra.org/geometry</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
