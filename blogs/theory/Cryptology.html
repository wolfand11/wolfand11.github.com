<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-07-07 周二 20:19 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cryptology</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">Cryptology</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd8b62a4">密码学理论</a>
<ul>
<li><a href="#orgcf7f014">数学</a>
<ul>
<li><a href="#org92348d8">时钟运算</a>
<ul>
<li><a href="#org9529408">加法</a></li>
<li><a href="#orgef45f61">减法</a></li>
<li><a href="#org3cbaf03">乘法</a></li>
<li><a href="#org5d21c33">除法</a></li>
<li><a href="#org8a5dc87">乘方</a></li>
<li><a href="#org0ec97bb">对数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf068c4c">密码</a>
<ul>
<li><a href="#orgc6ae565">密码学概述</a>
<ul>
<li><a href="#org3724198">密码学术语</a></li>
<li><a href="#orgdd5ffc4">密码与信息安全常识</a></li>
</ul>
</li>
<li><a href="#org059f8ec">历史上的密码</a>
<ul>
<li><a href="#orge72386b">凯撒密码</a>
<ul>
<li><a href="#orgec43a77">破解方法</a></li>
</ul>
</li>
<li><a href="#orgb1ad829">简单替换密码</a>
<ul>
<li><a href="#orgdd22770">破解方法</a></li>
</ul>
</li>
<li><a href="#org3a38306">Enigma</a></li>
</ul>
</li>
<li><a href="#orge858c19">对称密码</a>
<ul>
<li><a href="#org5df459d">基础概念</a>
<ul>
<li><a href="#org62e478c">编码</a></li>
<li><a href="#org720cc9d">XOR 运算</a></li>
</ul>
</li>
<li><a href="#orge6cde57">一次性密码本</a></li>
<li><a href="#org5d18d30">DES</a>
<ul>
<li><a href="#orgf276bf6">概述</a></li>
<li><a href="#orge517924">DES 的结构（Feistel 网络）</a></li>
</ul>
</li>
<li><a href="#org4a564aa">三重 DES</a>
<ul>
<li><a href="#org77f093b">概述</a></li>
<li><a href="#org00c8bce">3DES 的机制</a></li>
</ul>
</li>
<li><a href="#org1511842">AES</a>
<ul>
<li><a href="#orgc1559a3">概述</a></li>
<li><a href="#org61f7a0f">Rijndael</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga1d283e">分组密码的模式</a>
<ul>
<li><a href="#org0079901">基础概念</a></li>
<li><a href="#org737bdfb">ECB 模式</a>
<ul>
<li><a href="#orgf7a49d6">ECB 模式的特点</a></li>
</ul>
</li>
<li><a href="#orgc431365">CBC 模式</a>
<ul>
<li><a href="#orgff7437e">CBC 模式的特点</a></li>
</ul>
</li>
<li><a href="#org92f10be">CFB 模式</a>
<ul>
<li><a href="#org7b9fb80">CFB 模式的特点</a></li>
</ul>
</li>
<li><a href="#orgbba264b">OFB 模式</a>
<ul>
<li><a href="#org30a094e">OFB 模式的特点</a></li>
</ul>
</li>
<li><a href="#orgae9fb11">CTR 模式</a>
<ul>
<li><a href="#org8586609">CTR 模式的特点</a></li>
</ul>
</li>
<li><a href="#org4e94f9b">模式选择</a></li>
</ul>
</li>
<li><a href="#orgc20d54c">公钥密码</a>
<ul>
<li><a href="#org86f13db">密钥配送问题</a>
<ul>
<li><a href="#orge4f2cf6">通过事先共享密钥来解决</a></li>
<li><a href="#orgc2a5db9">通过密钥分配中心来解决</a></li>
<li><a href="#org5fe45b5">通过 Diffie-Hellman 密钥交换来解决</a></li>
<li><a href="#org1a74626">通过公钥密码来解决</a></li>
</ul>
</li>
<li><a href="#org1203494">公钥密码</a>
<ul>
<li><a href="#orgb7eeb57">公钥密码通讯流程</a></li>
<li><a href="#org2590260">缺点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3fc0acd">RSA</a>
<ul>
<li><a href="#orgb6bd115">RSA 加密</a></li>
<li><a href="#orgfd11a10">RSA 解密</a></li>
<li><a href="#orge817ac7">生成密钥对</a>
<ul>
<li><a href="#org65a392f">求 N</a></li>
<li><a href="#orgc27b09e">求 L（L 是仅在生成密钥对的过程中使用的数）</a></li>
<li><a href="#org7870a2d">求 E</a></li>
<li><a href="#org6d74312">求 D</a></li>
<li><a href="#org29209a3">RSA 生成密钥对图解</a></li>
</ul>
</li>
<li><a href="#org8eaf4ad">对 RSA 的攻击</a>
<ul>
<li><a href="#org394fd98">通过密文来求明文</a></li>
<li><a href="#org7881b4d">通过暴力破解来找出 D</a></li>
<li><a href="#org2869cbb">通过 E 和 N 求出 D</a></li>
<li><a href="#orgab681ec">中间人攻击</a></li>
</ul>
</li>
<li><a href="#org965d247">其他公钥密码</a>
<ul>
<li><a href="#org665a90d">EIGamal 方式</a></li>
<li><a href="#orga2e90a1">Rabin 方式</a></li>
<li><a href="#orge85f504">椭圆曲线密码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org148ab43">混合密码系统</a>
<ul>
<li><a href="#org68d6515">加密</a></li>
<li><a href="#org9736255">解密</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfca0a87">认证</a>
<ul>
<li><a href="#orge17c05c">单向散列函数</a>
<ul>
<li><a href="#orge0986dd">单向散列函数的性质</a>
<ul>
<li><a href="#org3d6bc2e">根据任意长度的消息计算初固定长度的散列值</a></li>
<li><a href="#org113288a">消息不同散列值也不同</a></li>
<li><a href="#orge25ab90">具备单向性</a></li>
</ul>
</li>
<li><a href="#orgfc1a0bb">单向散列函数的应用</a>
<ul>
<li><a href="#orgac78a42">检测软件是否被篡改</a></li>
<li><a href="#org01b2eb3">基于口令的加密</a></li>
<li><a href="#org89161cf">消息认证码</a></li>
<li><a href="#orgd418137">数字签名</a></li>
<li><a href="#org32bc22d">伪随机数生成器</a></li>
<li><a href="#orgab276e6">一次性口令</a></li>
</ul>
</li>
<li><a href="#orgdbcfc33">单向散列函数的具体实例</a>
<ul>
<li><a href="#org20fdc39">MD4 MD5</a></li>
<li><a href="#org540b841">SHA-1 SHA-256 SHA-384 SHA-512</a></li>
<li><a href="#orgae1369f">RIPEMD-160</a></li>
<li><a href="#orgc2182bb">ASH 与 SHA-3</a></li>
</ul>
</li>
<li><a href="#orgcc0a479">单向散列函数 SHA-1</a>
<ul>
<li><a href="#org6d0d8fd">填充</a></li>
<li><a href="#org102c586">计算 W0-W79</a></li>
<li><a href="#org01da42a">分组处理</a></li>
<li><a href="#org0c64868">单步处理</a></li>
</ul>
</li>
<li><a href="#org0d5188e">对单向散列函数的攻击</a>
<ul>
<li><a href="#org21a4d70">暴力破解</a></li>
<li><a href="#org2241b29">生日攻击</a></li>
</ul>
</li>
<li><a href="#org30db6e1">单向散列函数无法解决的问题</a></li>
</ul>
</li>
<li><a href="#org65f9c0b">消息认证码</a>
<ul>
<li><a href="#org795e9aa">什么是消息认证码</a></li>
<li><a href="#org42dc0f8">消息认证码的使用步骤</a></li>
<li><a href="#org25a864b">消息认证码的实现方法</a>
<ul>
<li><a href="#orgcd60d78">利用单向散列函数可以实现消息认证码</a></li>
<li><a href="#org7376755">使用分组密码实现</a></li>
<li><a href="#orga97d896">其他实现方法</a></li>
</ul>
</li>
<li><a href="#org0209c7b">HMAC</a>
<ul>
<li><a href="#org333e54d">1 密钥填充</a></li>
<li><a href="#orgcc67020">2 填充后的密钥与 ipad 的 XOR</a></li>
<li><a href="#orgd6a37a1">3 与消息组合</a></li>
<li><a href="#orge27568d">4 计算散列值</a></li>
<li><a href="#orgd8535ef">5 填充后的密钥与 opad 的 XOR</a></li>
<li><a href="#orgfc3bb65">6 将 第 4 步 的散列值拼在 opadkey 后面</a></li>
<li><a href="#orgdd985c3">7 计算散列值</a></li>
</ul>
</li>
<li><a href="#org357018d">对消息认证码的攻击</a>
<ul>
<li><a href="#orge5a165e">重放攻击</a></li>
<li><a href="#orga7465e4">密钥推测攻击</a></li>
</ul>
</li>
<li><a href="#orge24c247">消息认证码无法解决的问题</a>
<ul>
<li><a href="#org8f9269d">对第三方证明</a></li>
<li><a href="#orgb080e68">防止否认</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf4bfc3c">数字签名</a></li>
<li><a href="#orgdb59eb1">证书</a></li>
</ul>
</li>
<li><a href="#org29ff7e4">密码学应用</a>
<ul>
<li><a href="#org080405b">密钥-秘密的精华</a></li>
<li><a href="#org9e44260">随机数-不可预测性的源泉</a></li>
<li><a href="#orgf2fe920">PGP</a></li>
<li><a href="#org3fbcd39">SSL/TLS</a></li>
<li><a href="#org2bc2b0b">密码技术与现实社会</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5a47567">密码学实践</a></li>
<li><a href="#org10b6fe2">参考资料</a></li>
</ul>
</div>
</div>
<div class="HTML">
<p>
密码学相关的一些笔记。<br />
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgd8b62a4" class="outline-2">
<h2 id="orgd8b62a4">密码学理论</h2>
<div class="outline-text-2" id="text-orgd8b62a4">
</div>
<div id="outline-container-orgcf7f014" class="outline-3">
<h3 id="orgcf7f014">数学</h3>
<div class="outline-text-3" id="text-orgcf7f014">
</div>
<div id="outline-container-org92348d8" class="outline-4">
<h4 id="org92348d8">时钟运算</h4>
<div class="outline-text-4" id="text-org92348d8">
</div>
<div id="outline-container-org9529408" class="outline-5">
<h5 id="org9529408">加法</h5>
<div class="outline-text-5" id="text-org9529408">
<p>
时钟指针向前（顺时针）转 x 刻度会指向几？<br />
new = (old + x) / 12 取余数<br />
</p>
</div>
</div>
<div id="outline-container-orgef45f61" class="outline-5">
<h5 id="orgef45f61">减法</h5>
<div class="outline-text-5" id="text-orgef45f61">
<p>
时钟指针向后（逆时针）转 x 刻度会指向几？<br />
减法可以通过下面方法转化为加法<br />
如果 0&lt;x&lt;12<br />
new = (old + (12 - x)) / 12 取余数<br />
如果 x&gt;12<br />
x = x/12 取余数<br />
new = (old + (12 - x)) / 12 取余数<br />
</p>
</div>
</div>
<div id="outline-container-org3cbaf03" class="outline-5">
<h5 id="org3cbaf03">乘法</h5>
<div class="outline-text-5" id="text-org3cbaf03">
<p>
时钟指针向前（顺时针）转 x 刻度 y 次会指向几？<br />
乘法可以通过下面方法转化为加法<br />
new = (x * y)/12 取余数<br />
</p>
</div>
</div>
<div id="outline-container-org5d21c33" class="outline-5">
<h5 id="org5d21c33">除法</h5>
<div class="outline-text-5" id="text-org5d21c33">
<p>
将"向前（顺时针）转 x 个刻度的操作"重复几次指针会指向 1 呢？<br />
除法可以通过互为倒数的概念转化为乘法(除以一个数等于乘以它的倒数)<br />
</p>

<p>
1 = (x*y)/12 取余数<br />
以 x=7 为例，求 y 的值<br />
<img src="Cryptology/18_mode_division_eg1.jpg" alt="18_mode_division_eg1.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org8a5dc87" class="outline-5">
<h5 id="org8a5dc87">乘方</h5>
<div class="outline-text-5" id="text-org8a5dc87">
<p>
乘方也称为指数运算，乘方可以转化为乘法的多次重复。<br />
new = (x * x * x * &#x2026;)/12 取余数<br />
</p>
</div>
</div>
<div id="outline-container-org0ec97bb" class="outline-5">
<h5 id="org0ec97bb">对数</h5>
<div class="outline-text-5" id="text-org0ec97bb">
<p>
乘方的逆运算称为对数运算。时钟运算中的对数称为离散对数。<br />
<img src="Cryptology/18_mode_log_eg1.jpg" alt="18_mode_log_eg1.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf068c4c" class="outline-3">
<h3 id="orgf068c4c">密码</h3>
<div class="outline-text-3" id="text-orgf068c4c">
</div>
<div id="outline-container-orgc6ae565" class="outline-4">
<h4 id="orgc6ae565">密码学概述</h4>
<div class="outline-text-4" id="text-orgc6ae565">
</div>
<div id="outline-container-org3724198" class="outline-5">
<h5 id="org3724198">密码学术语</h5>
<div class="outline-text-5" id="text-org3724198">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">发送者</td>
<td class="org-left">发送信息的人</td>
</tr>

<tr>
<td class="org-left">接收者</td>
<td class="org-left">接收信息的人</td>
</tr>

<tr>
<td class="org-left">窃听者</td>
<td class="org-left">偷看信息的人</td>
</tr>

<tr>
<td class="org-left">消息</td>
<td class="org-left">被发送的信息</td>
</tr>

<tr>
<td class="org-left">密码</td>
<td class="org-left">密码是一种能够让消息内容变得无法解读的技术</td>
</tr>

<tr>
<td class="org-left">明文</td>
<td class="org-left">加密之前的消息</td>
</tr>

<tr>
<td class="org-left">密文</td>
<td class="org-left">加密之后的消息</td>
</tr>

<tr>
<td class="org-left">解密</td>
<td class="org-left">正当接收者将密文还原为明文</td>
</tr>

<tr>
<td class="org-left">密码破译、密码分析</td>
<td class="org-left">接收者以外的其他人试图将密文还原为明文</td>
</tr>

<tr>
<td class="org-left">破译者</td>
<td class="org-left">进行破译的人</td>
</tr>

<tr>
<td class="org-left">加密算法</td>
<td class="org-left">从明文生成密文的步骤，即加密的步骤</td>
</tr>

<tr>
<td class="org-left">解密算法</td>
<td class="org-left">解密的步骤</td>
</tr>

<tr>
<td class="org-left">密码算法</td>
<td class="org-left">加密、解密的算法合在一起统称为密码算法</td>
</tr>

<tr>
<td class="org-left">密钥</td>
<td class="org-left">密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中会作为输入的参数</td>
</tr>

<tr>
<td class="org-left">对称密码</td>
<td class="org-left">在加密和解密时使用同一密钥的方式</td>
</tr>

<tr>
<td class="org-left">公钥密码</td>
<td class="org-left">在加密和解密时使用不同密钥的方式，也称为非对称密码</td>
</tr>

<tr>
<td class="org-left">混合密码系统</td>
<td class="org-left">将对称密码和公钥密码结合起来的密码方式</td>
</tr>

<tr>
<td class="org-left">单向散列函数</td>
<td class="org-left">把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。一种保证完整性的密码技术</td>
</tr>

<tr>
<td class="org-left">散列值</td>
<td class="org-left">用单向散列函数计算出来的数值</td>
</tr>

<tr>
<td class="org-left">消息认证码</td>
<td class="org-left">一种能够保证完整性和提供认证的密码技术</td>
</tr>

<tr>
<td class="org-left">数字签名</td>
<td class="org-left">能够防止伪装、篡改和否认等威胁的技术</td>
</tr>

<tr>
<td class="org-left">伪随机数生成器</td>
<td class="org-left">一种能够模拟产生随机数列的算法</td>
</tr>
</tbody>
</table>


<div class="figure">
<p><img src="Cryptology/0_cryptographer_toolkit.jpg" alt="0_cryptographer_toolkit.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgdd5ffc4" class="outline-5">
<h5 id="orgdd5ffc4">密码与信息安全常识</h5>
<div class="outline-text-5" id="text-orgdd5ffc4">
<ul class="org-ul">
<li>不要使用保密的密码算法<br /></li>
<li>使用低强度的密码比不进行任何加密更危险<br /></li>
<li>任何密码总有一天都会被破解<br /></li>
<li>密码只是信息安全的一部分<br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org059f8ec" class="outline-4">
<h4 id="org059f8ec">历史上的密码</h4>
<div class="outline-text-4" id="text-org059f8ec">
</div>
<div id="outline-container-orge72386b" class="outline-5">
<h5 id="orge72386b">凯撒密码</h5>
<div class="outline-text-5" id="text-orge72386b">
<p>
凯撒密码是通过将明文中所使用的字母表按照一定的字数平移来进行加密的。<br />
</p>

<p>
例如：所有字母平移 2 位来进行加密。guodong &#x2013;（加密）&#x2013;&gt;iwqfqpi. 此处 2 相当于密钥<br />
</p>
</div>
<div id="outline-container-orgec43a77" class="outline-6">
<h6 id="orgec43a77">破解方法</h6>
<div class="outline-text-6" id="text-orgec43a77">
<p>
因为密钥空间比较小，只有 26，可以使用暴力破解来破译这种密码.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb1ad829" class="outline-5">
<h5 id="orgb1ad829">简单替换密码</h5>
<div class="outline-text-5" id="text-orgb1ad829">
<p>
将明文中所使用的字母表替换为另一套字母表的密码称为简单替换密码。<br />
</p>


<div class="figure">
<p><img src="Cryptology/1_simple_passwordlist.jpg" alt="1_simple_passwordlist.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-orgdd22770" class="outline-6">
<h6 id="orgdd22770">破解方法</h6>
<div class="outline-text-6" id="text-orgdd22770">
<p>
使用频率分析的密码破译方法可以破解简单替换密码<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3a38306" class="outline-5">
<h5 id="org3a38306">Enigma</h5>
<div class="outline-text-5" id="text-org3a38306">
<p>
德国纳粹时期，德国国防军采用了 Enigma。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge858c19" class="outline-4">
<h4 id="orge858c19">对称密码</h4>
<div class="outline-text-4" id="text-orge858c19">
</div>
<div id="outline-container-org5df459d" class="outline-5">
<h5 id="org5df459d">基础概念</h5>
<div class="outline-text-5" id="text-org5df459d">
</div>
<div id="outline-container-org62e478c" class="outline-6">
<h6 id="org62e478c">编码</h6>
<div class="outline-text-6" id="text-org62e478c">
<p>
将现实世界中的东西映射为比特序列的操作称为编码。例如，常见的字符编码有 ASCII UTF8 等编码<br />
</p>
</div>
</div>
<div id="outline-container-org720cc9d" class="outline-6">
<h6 id="org720cc9d">XOR 运算</h6>
<div class="outline-text-6" id="text-org720cc9d">
<p>
全称为 exclusive or,译作异或运算。<br />
XOR 运算规则如下:<br />
0 XOR 0 = 0<br />
0 XOR 1 = 1<br />
1 XOR 0 = 1<br />
1 XOR 1 = 0<br />
</p>

<p>
将 0 理解为偶数，将 1 理解为奇数，就可以将 XOR 和一般的加法运算等同起来。<br />
偶数 0 + 偶数 0 = 偶数 0<br />
偶数 0 + 奇数 1 = 奇数 1<br />
奇数 1 + 偶数 0 = 奇数 1<br />
奇数 1 + 奇数 1 = 偶数 0<br />
</p>

<p>
将一个棋子保持原状（不翻转）看做 0，将一个棋子翻转到另一面看做 1，那么 XOR 运算就相当于将黑白棋的一个棋子进行翻转的操作进行连接<br />
不翻转 0 + 不翻转 0 = 不翻转 0<br />
不翻转 0 + 翻转 1 = 翻转 0<br />
翻转 1 + 不翻转 0 = 翻转 0<br />
翻转 1 + 翻转 1 = 不翻转 0<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge6cde57" class="outline-5">
<h5 id="orge6cde57">一次性密码本</h5>
<div class="outline-text-5" id="text-orge6cde57">
<p>
一次性密码本是将明文与一串随机的比特序列进行 XOR 运算。<br />
一次性密码本是无法破译的。因为密钥和明文的长度相同，使用暴力破解法会枚举出所有明文长度的可能信息，无法判断真正的明文是哪个。<br />
</p>
</div>
</div>
<div id="outline-container-org5d18d30" class="outline-5">
<h5 id="org5d18d30">DES</h5>
<div class="outline-text-5" id="text-org5d18d30">
</div>
<div id="outline-container-orgf276bf6" class="outline-6">
<h6 id="orgf276bf6">概述</h6>
<div class="outline-text-6" id="text-orgf276bf6">
<p>
DES 全称 Data Encryption Standard,1999 年 DES ChallengeIII 中用了 22 小时 15 分破解了 DES 加密的密文。目前已经不再使用该加密算法.<br />
DES 是以 64 比特的明文为一个单位来进行加密的，这个 64 比特的单位称为分组。以分组为单位进行处理的密码算法称为分组密码。<br />
DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代，而迭代的具体方式就称为模式。<br />
</p>
</div>
</div>
<div id="outline-container-orge517924" class="outline-6">
<h6 id="orge517924">DES 的结构（Feistel 网络）</h6>
<div class="outline-text-6" id="text-orge517924">
<p>
在 Feistel 网络中，加密的各个步骤称为轮，整个加密过程就是进行若干次轮的循环。DES 是一种 16 轮循环的 Feistel 网络。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0d1924d"></a>Feistel 的加密<br />
<div class="outline-text-7" id="text-org0d1924d">

<div class="figure">
<p><img src="Cryptology/2_feistel_network_1times.jpg" alt="2_feistel_network_1times.jpg" /><br />
</p>
</div>

<p>
一轮的具体计算步骤：<br />
</p>
<ul class="org-ul">
<li>将输入的数据等分为左右两部分<br /></li>
<li>将输入的右侧直接发送到输出的右侧<br /></li>
<li>将输入的右侧发送到轮函数<br /></li>
<li>轮函数根据右侧数据和子密钥，计算初一串看上去是随机的比特序列<br /></li>
<li>将上一步得到的比特序列与左侧的数据进行 XOR 运算，并将结果作为加密后的左侧<br /></li>
</ul>

<p>
中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用不同的子密钥。由于子密钥只在一轮中使用，它只是一个局部密钥，因此才称为子密钥。<br />
</p>

<p>
<img src="Cryptology/3_feistel_network_3times.jpg" alt="3_feistel_network_3times.jpg" /><br />
在一轮运算中，“右侧”根本没有被加密，因此需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧数据对调。<br />
</p>
</div>
</li>
<li><a id="org9e33b59"></a>Feistel 的解密<br />
<div class="outline-text-7" id="text-org9e33b59">
<p>
<img src="Cryptology/4_feistel_network_decryption_1times.jpg" alt="4_feistel_network_decryption_1times.jpg" /><br />
<img src="Cryptology/5_feistel_network_decryption_3times.jpg" alt="5_feistel_network_decryption_3times.jpg" /><br />
</p>
</div>
</li>
<li><a id="orgd1f7c46"></a>Feistel 网络的性质<br />
<div class="outline-text-7" id="text-orgd1f7c46">
<ul class="org-ul">
<li>Feistel 网络的轮数可以任意增加<br /></li>
<li>加密时无论使用任何函数作为轮函数都可以正确解密<br /></li>
<li>加密和解密可以用完全相同的结构来实现<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4a564aa" class="outline-5">
<h5 id="org4a564aa">三重 DES</h5>
<div class="outline-text-5" id="text-org4a564aa">
</div>
<div id="outline-container-org77f093b" class="outline-6">
<h6 id="org77f093b">概述</h6>
<div class="outline-text-6" id="text-org77f093b">
<p>
三重 DES 是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。<br />
</p>
</div>
</div>
<div id="outline-container-org00c8bce" class="outline-6">
<h6 id="org00c8bce">3DES 的机制</h6>
<div class="outline-text-6" id="text-org00c8bce">
<p>
<img src="Cryptology/6_3des_cryption.jpg" alt="6_3des_cryption.jpg" /><br />
3DES 之所以设计为 加密-&gt;解密-&gt;加密 的过程是为了兼容普通的 DES。<br />
<img src="Cryptology/7_3des_des_cryption.jpg" alt="7_3des_des_cryption.jpg" /><br />
<img src="Cryptology/8_3des_decryption.jpg" alt="8_3des_decryption.jpg" /><br />
</p>

<p>
3DES 目前还被银行等机构使用，但其处理速度不高。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1511842" class="outline-5">
<h5 id="org1511842">AES</h5>
<div class="outline-text-5" id="text-org1511842">
</div>
<div id="outline-container-orgc1559a3" class="outline-6">
<h6 id="orgc1559a3">概述</h6>
<div class="outline-text-6" id="text-orgc1559a3">
<p>
AES (Advanced Encrytion Standard)是取代其前任标准 DES 而成为新标准的一种对称密码算法。<br />
</p>
</div>
</div>
<div id="outline-container-org61f7a0f" class="outline-6">
<h6 id="org61f7a0f">Rijndael</h6>
<div class="outline-text-6" id="text-org61f7a0f">
<p>
Rijndael 算法在 2000 年被选为新一代标准密码算法——AES。Rijndael 的分组长度为 128 比特，密钥长度可以以 32 比特为单位在 128 比特到 256 比特的范围内进行选择（在 AES 的规格中，密钥长度只有 128,193,256 比特三种）。<br />
它也是由多个轮构成的，其使用了 SPN 结构。<br />
</p>

<p>
<img src="Cryptology/9_aes_cryption.jpg" alt="9_aes_cryption.jpg" /><br />
<img src="Cryptology/10_aes_decryption.jpg" alt="10_aes_decryption.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga1d283e" class="outline-4">
<h4 id="orga1d283e">分组密码的模式</h4>
<div class="outline-text-4" id="text-orga1d283e">
</div>
<div id="outline-container-org0079901" class="outline-5">
<h5 id="org0079901">基础概念</h5>
<div class="outline-text-5" id="text-org0079901">
<p>
密码算法可以分为分组密码和流密码两种。<br />
</p>
<ul class="org-ul">
<li>分组密码<br /></li>
</ul>
<p>
每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组。一个分组的比特数就称为分组长度。<br />
</p>
<ul class="org-ul">
<li>流密码<br /></li>
</ul>
<p>
对数据流进行连续处理的一类密码算法。<br />
</p>
<ul class="org-ul">
<li>分组密码的模式<br /></li>
</ul>
<p>
分组密码算法只能加密固定长度的分组，当需要加密的明文长度超过分组密码的分组长度，就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式。<br />
</p>
<ul class="org-ul">
<li>分组密码模式的分类<br />
<ul class="org-ul">
<li>ECB 模式：Electronic CodeBook mode 电子密码本模式<br /></li>
<li>CBC 模式：Cipher Block Channing mode 密码分组链接模式<br /></li>
<li>CFB 模式：Cipher FeedBack mode 密文反馈模式<br /></li>
<li>OFB 模式：Output FeedBack mode 输出反馈模式<br /></li>
<li>CTR 模式：CounTeR mode 计数器模式<br /></li>
</ul></li>
<li>明文分组<br /></li>
</ul>
<p>
明文分组是指分组密码算法中作为加密对象的明文。明文分组的长度和分组密码算法的分组长度是相等的。<br />
</p>
<ul class="org-ul">
<li>密文分组<br /></li>
</ul>
<p>
密文分组是指使用分组密码算法将明文分组加密之后所生成的密文。<br />
</p>
</div>
</div>
<div id="outline-container-org737bdfb" class="outline-5">
<h5 id="org737bdfb">ECB 模式</h5>
<div class="outline-text-5" id="text-org737bdfb">
<p>
在 ECB 模式中，将明文分组加密之后的结果将直接成为密文分组。<br />
<img src="Cryptology/11_ecb_mode.jpg" alt="11_ecb_mode.jpg" /><br />
</p>
</div>
<div id="outline-container-orgf7a49d6" class="outline-6">
<h6 id="orgf7a49d6">ECB 模式的特点</h6>
<div class="outline-text-6" id="text-orgf7a49d6">
<p>
相同的明文分组会被转换为相同的密文分组。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc431365" class="outline-5">
<h5 id="orgc431365">CBC 模式</h5>
<div class="outline-text-5" id="text-orgc431365">
<p>
在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密<br />
<img src="Cryptology/12_cbc_mode.jpg" alt="12_cbc_mode.jpg" /><br />
</p>
</div>
<div id="outline-container-orgff7437e" class="outline-6">
<h6 id="orgff7437e">CBC 模式的特点</h6>
<div class="outline-text-6" id="text-orgff7437e">
<p>
明文在加密之前回合前一个密文分组进行 XOR 运算，所以相同的明文分组对应的密文也不一样。<br />
有一个密文分组损坏会影响该密文分组以及下一个密文分组的明文，但是下下的密文分组不会受到影响。<br />
<img src="Cryptology/12_cbc_mode_error.jpg" alt="12_cbc_mode_error.jpg" /><br />
如果能够对初始化向量中的任意比特进行反转，则第一个明文分组中相应的比特也会被反转。<br />
<img src="Cryptology/12_cbc_mode_crack.jpg" alt="12_cbc_mode_crack.jpg" /><br />
CBC 模式也可以被重放攻击<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org92f10be" class="outline-5">
<h5 id="org92f10be">CFB 模式</h5>
<div class="outline-text-5" id="text-org92f10be">
<p>
在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。<br />
<img src="Cryptology/13_cfb_mode.jpg" alt="13_cfb_mode.jpg" /><br />
</p>
</div>
<div id="outline-container-org7b9fb80" class="outline-6">
<h6 id="org7b9fb80">CFB 模式的特点</h6>
<div class="outline-text-6" id="text-org7b9fb80">
<p>
CFB 模式中，密码算法的输出相当于一次性密码本中的随机比特序列。密码算法就相当于用来生成密钥流的伪随机生成器，而初始化向量就相当于伪随机数生成器的种子。<br />
CFB 模式可以被重放攻击<br />
<img src="Cryptology/13_cfb_mode_crack.jpg" alt="13_cfb_mode_crack.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgbba264b" class="outline-5">
<h5 id="orgbba264b">OFB 模式</h5>
<div class="outline-text-5" id="text-orgbba264b">
<p>
在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中。<br />
<img src="Cryptology/14_ofb_mode.jpg" alt="14_ofb_mode.jpg" /><br />
</p>
</div>
<div id="outline-container-org30a094e" class="outline-6">
<h6 id="org30a094e">OFB 模式的特点</h6>
<div class="outline-text-6" id="text-org30a094e">
<p>
OFB 模式中，XOR 所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。<br />
OFB 模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgae9fb11" class="outline-5">
<h5 id="orgae9fb11">CTR 模式</h5>
<div class="outline-text-5" id="text-orgae9fb11">
<p>
CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。<br />
<img src="Cryptology/15_ctr_mode.jpg" alt="15_ctr_mode.jpg" /><br />
</p>
</div>
<div id="outline-container-org8586609" class="outline-6">
<h6 id="org8586609">CTR 模式的特点</h6>
<div class="outline-text-6" id="text-org8586609">
<p>
CTR 模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由 nonce 和分组序号直接计算出来。<br />
CTR 模式的密文分组中由一个比特被反转了，则解密后明文分组中仅由与之对应的比特会被翻转，这一错误不会放大。但是，攻击者也可以利用该特性来反转密文分组的某些比特，来引起明文中相应比特的反转。<br />
CTR 模式避免了 OFB 中加密前后一致导致的问题。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4e94f9b" class="outline-5">
<h5 id="org4e94f9b">模式选择</h5>
<div class="outline-text-5" id="text-org4e94f9b">

<div class="figure">
<p><img src="Cryptology/16_block_cipher_mode.jpg" alt="16_block_cipher_mode.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc20d54c" class="outline-4">
<h4 id="orgc20d54c">公钥密码</h4>
<div class="outline-text-4" id="text-orgc20d54c">
</div>
<div id="outline-container-org86f13db" class="outline-5">
<h5 id="org86f13db">密钥配送问题</h5>
<div class="outline-text-5" id="text-org86f13db">
<p>
密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题。<br />
</p>
</div>
<div id="outline-container-orge4f2cf6" class="outline-6">
<h6 id="orge4f2cf6">通过事先共享密钥来解决</h6>
<div class="outline-text-6" id="text-orge4f2cf6">
<p>
需要用一种安全的方式将密钥交给对方。例如，直接将密钥保存在 U 盘中，然后亲手将 U 盘交给对方。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9fe262d"></a>缺点<br />
<div class="outline-text-7" id="text-org9fe262d">
<p>
当人数很多时，通信需要的密钥数量会增大。1000 名员工彼此加密通讯需要 1000*999/2 = 499500 个密钥<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc2a5db9" class="outline-6">
<h6 id="orgc2a5db9">通过密钥分配中心来解决</h6>
<div class="outline-text-6" id="text-orgc2a5db9">
<p>
密钥中心为每次会话生成会话密钥，然后，用参与会话的人的密钥加密会话密钥，将加密后的会话密钥发给参与会话的人。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org49907f0"></a>缺点<br />
<div class="outline-text-7" id="text-org49907f0">
<p>
每次会话都需要密钥中心进行处理，密钥中心负荷随通话增多而增多。<br />
密钥中心瘫痪后，整个加密通讯就瘫痪了。<br />
密钥中心被攻破，全公司的所有加密通讯都会被破译。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5fe45b5" class="outline-6">
<h6 id="org5fe45b5">通过 Diffie-Hellman 密钥交换来解决</h6>
<div class="outline-text-6" id="text-org5fe45b5">
<p>
根据所交换的信息，双方可以各自生成相同的密钥，而窃听者却无法生成相同的密钥。<br />
</p>
</div>
</div>
<div id="outline-container-org1a74626" class="outline-6">
<h6 id="org1a74626">通过公钥密码来解决</h6>
<div class="outline-text-6" id="text-org1a74626">
<p>
公钥密码中，密钥分为加密密钥和解密密钥，它们是不同的。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。只要拥有加密密钥，任何人都可以进行加密，但是没有解密密钥是无法解密的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1203494" class="outline-5">
<h5 id="org1203494">公钥密码</h5>
<div class="outline-text-5" id="text-org1203494">
<p>
在公钥密码中，加密密钥一般时公开的。因此该密钥被称为公钥。<br />
在公钥密码中，解密密钥是绝对不能公开的，这个密钥只能自己来使用，因此该密钥被称为私钥。<br />
公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对。<br />
</p>
</div>
<div id="outline-container-orgb7eeb57" class="outline-6">
<h6 id="orgb7eeb57">公钥密码通讯流程</h6>
<div class="outline-text-6" id="text-orgb7eeb57">

<div class="figure">
<p><img src="Cryptology/17_public_key_communication.jpg" alt="17_public_key_communication.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2590260" class="outline-6">
<h6 id="org2590260">缺点</h6>
<div class="outline-text-6" id="text-org2590260">
<p>
公钥密码带来了公钥认证问题，需要判断得到的公钥是否正确合法。<br />
公钥密码的处理速度比对称密码要慢很多.<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3fc0acd" class="outline-4">
<h4 id="org3fc0acd">RSA</h4>
<div class="outline-text-4" id="text-org3fc0acd">
<p>
RSA 是一种公钥密码算法，RSA 可被用于公钥密码和数字签名。<br />
</p>
</div>
<div id="outline-container-orgb6bd115" class="outline-5">
<h5 id="orgb6bd115">RSA 加密</h5>
<div class="outline-text-5" id="text-orgb6bd115">
<p>
RSA 的密文是代表明文的数字的 E 次方求 mod N 的结果。也就是说将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。<br />
E 和 N 的组合就是公钥。(E 表示 Encryption，N 表示 Number)<br />
</p>
</div>
</div>
<div id="outline-container-orgfd11a10" class="outline-5">
<h5 id="orgfd11a10">RSA 解密</h5>
<div class="outline-text-5" id="text-orgfd11a10">
<p>
RSA 的对表示密文的数字的 D 次方求 mod N 的结果。也就是说将密文和自己做 D 次乘法，然后将其结果除以 N 求余数，这个余数就是明文。<br />
D 和 N 的组合就是私钥。(D 表示 Decryption，N 表示 Number)<br />
</p>
</div>
</div>
<div id="outline-container-orge817ac7" class="outline-5">
<h5 id="orge817ac7">生成密钥对</h5>
<div class="outline-text-5" id="text-orge817ac7">
<p>
求 E、D、N 这三个数就是生成密钥对。RAS 密钥对的生成步骤如下：<br />
</p>
</div>
<div id="outline-container-org65a392f" class="outline-6">
<h6 id="org65a392f">求 N</h6>
<div class="outline-text-6" id="text-org65a392f">
<p>
准备两个很大的质数：p 和 q<br />
N = p * q<br />
</p>
</div>
</div>
<div id="outline-container-orgc27b09e" class="outline-6">
<h6 id="orgc27b09e">求 L（L 是仅在生成密钥对的过程中使用的数）</h6>
<div class="outline-text-6" id="text-orgc27b09e">
<p>
L 是 p-1 和 q-1 的最小公倍数<br />
L = lcm(p-1, q-1)<br />
</p>
</div>
</div>
<div id="outline-container-org7870a2d" class="outline-6">
<h6 id="org7870a2d">求 E</h6>
<div class="outline-text-6" id="text-org7870a2d">
<p>
E 和 L 之间存在下列关系：<br />
1&lt; E &lt;L<br />
gcd(E,L) = 1 (E 和 L 的最大公约数为 1 E 和 L 互质,该条件保证一定存在解密时需要使用的数 D)<br />
</p>
</div>
</div>
<div id="outline-container-org6d74312" class="outline-6">
<h6 id="org6d74312">求 D</h6>
<div class="outline-text-6" id="text-org6d74312">
<p>
D、E、L 之间必须具备下列关系：<br />
1&lt;D&lt;L<br />
E*D mod L = 1<br />
</p>
</div>
</div>
<div id="outline-container-org29209a3" class="outline-6">
<h6 id="org29209a3">RSA 生成密钥对图解</h6>
<div class="outline-text-6" id="text-org29209a3">

<div class="figure">
<p><img src="Cryptology/19_rsa.jpg" alt="19_rsa.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8eaf4ad" class="outline-5">
<h5 id="org8eaf4ad">对 RSA 的攻击</h5>
<div class="outline-text-5" id="text-org8eaf4ad">
<ul class="org-ul">
<li>密码破译者知道的信息：<br />
<ul class="org-ul">
<li>密文：可以通过窃听来获取<br /></li>
<li>数 E 和 N:公钥是公开的信息<br /></li>
</ul></li>
<li>密码破译者不知道的信息：<br />
<ul class="org-ul">
<li>明文:需要破译的内容<br /></li>
<li>数字 D:私钥中至少 D 是不知道的信息<br /></li>
<li>其他：密码破译者不知道生成密钥对时所使用的 p、q 和 L<br /></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org394fd98" class="outline-6">
<h6 id="org394fd98">通过密文来求明文</h6>
<div class="outline-text-6" id="text-org394fd98">
<p>
密文 = 明文^E mode N<br />
目前还没有发现求离散对数的高效算法，所以通过明文求密文非常困难。<br />
</p>
</div>
</div>
<div id="outline-container-org7881b4d" class="outline-6">
<h6 id="org7881b4d">通过暴力破解来找出 D</h6>
<div class="outline-text-6" id="text-org7881b4d">
<p>
RSA 中所使用的 p 和 q 的长度都是 512 比特以上，N 的长度为 1024 比特以上。由于 E 和 D 的长度可以和 N 差不多，因此要找出 D，就需要进行 1024 比特以上的暴力破解，这也非常困难。<br />
</p>
</div>
</div>
<div id="outline-container-org2869cbb" class="outline-6">
<h6 id="org2869cbb">通过 E 和 N 求出 D</h6>
<div class="outline-text-6" id="text-org2869cbb">
<p>
D 和 E 的关系如下：<br />
E x D mod L = 1<br />
L = lcm(p-1, q-1)<br />
N = p * q<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org365c666"></a>对 N 进行质因数分解攻击<br />
<div class="outline-text-7" id="text-org365c666">
<p>
由 N 求 p 和 q 可以通过将 N 进行质因数分解来完成。所以一旦发现了对大整数进行质因数分解的高效算法，RSA 就能够被破译。<br />
目前还没有发现对大整数进行质因数分解的高效算法，也没有证明质因数分解是否真的是非常困难的问题，也不知道是否存在一种分解质因数的简单方法。<br />
</p>
</div>
</li>
<li><a id="org19b8040"></a>通过推测 p 和 q 进行攻击<br />
<div class="outline-text-7" id="text-org19b8040">
<p>
由于 p 和 q 是通过伪随机数生成器产生的，如果伪随机数生成器的算法很差，密码破译者就有可能推测出来 p 和 q。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgab681ec" class="outline-6">
<h6 id="orgab681ec">中间人攻击</h6>
<div class="outline-text-6" id="text-orgab681ec">

<div class="figure">
<p><img src="Cryptology/19_rsa_middleman_crack.jpg" alt="19_rsa_middleman_crack.jpg" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org965d247" class="outline-5">
<h5 id="org965d247">其他公钥密码</h5>
<div class="outline-text-5" id="text-org965d247">
</div>
<div id="outline-container-org665a90d" class="outline-6">
<h6 id="org665a90d">EIGamal 方式</h6>
<div class="outline-text-6" id="text-org665a90d">
<p>
EIGamal 方式利用了 mod N 下求离散对数的困难度。<br />
EIGamal 方式的一个缺点是，经过加密的密文长度会变为明文的两倍。<br />
</p>
</div>
</div>
<div id="outline-container-orga2e90a1" class="outline-6">
<h6 id="orga2e90a1">Rabin 方式</h6>
<div class="outline-text-6" id="text-orga2e90a1">
<p>
Rabin 方式利用了 mod N 下求平方根的困难度。<br />
</p>
</div>
</div>
<div id="outline-container-orge85f504" class="outline-6">
<h6 id="orge85f504">椭圆曲线密码</h6>
<div class="outline-text-6" id="text-orge85f504">
<p>
椭圆曲线密码的特点是所需密钥长度比 RSA 短。<br />
椭圆曲线密码是通过将椭圆曲线上的特定点进行特殊的乘法运算来实现的，它利用了这种乘法运算的逆运算非常困难这一特性。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org148ab43" class="outline-4">
<h4 id="org148ab43">混合密码系统</h4>
<div class="outline-text-4" id="text-org148ab43">
</div>
<div id="outline-container-org68d6515" class="outline-5">
<h5 id="org68d6515">加密</h5>
<div class="outline-text-5" id="text-org68d6515">

<div class="figure">
<p><img src="Cryptology/20_hybird_encrypt.jpg" alt="20_hybird_encrypt.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9736255" class="outline-5">
<h5 id="org9736255">解密</h5>
<div class="outline-text-5" id="text-org9736255">

<div class="figure">
<p><img src="Cryptology/20_hybird_decrypt.jpg" alt="20_hybird_decrypt.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfca0a87" class="outline-3">
<h3 id="orgfca0a87">认证</h3>
<div class="outline-text-3" id="text-orgfca0a87">
</div>
<div id="outline-container-orge17c05c" class="outline-4">
<h4 id="orge17c05c">单向散列函数</h4>
<div class="outline-text-4" id="text-orge17c05c">
<p>
单向散列函数有一个输入和一个输出，其中输入称为消息，输出称为散列值。单向散列函数可以根据消息的内容计算出散列值，散列值可以被用来检查消息的完整性。<br />
</p>
</div>
<div id="outline-container-orge0986dd" class="outline-5">
<h5 id="orge0986dd">单向散列函数的性质</h5>
<div class="outline-text-5" id="text-orge0986dd">
</div>
<div id="outline-container-org3d6bc2e" class="outline-6">
<h6 id="org3d6bc2e">根据任意长度的消息计算初固定长度的散列值</h6>
</div>
<div id="outline-container-org113288a" class="outline-6">
<h6 id="org113288a">消息不同散列值也不同</h6>
<div class="outline-text-6" id="text-org113288a">
<p>
两个不同的消息产生同一个散列值的情况称为碰撞.<br />
难以发现碰撞的性质称为抗碰撞性。<br />
弱抗碰撞性：当给定某条消息的散列值时，单向散列函数必须确保要找到和该条消息具备相同散列值的另外一条消息是非常困难的。<br />
强抗碰撞性：要找到散列值相同的两条不同的消息时非常困难的，这里的散列值可以是任意值。<br />
</p>
</div>
</div>
<div id="outline-container-orge25ab90" class="outline-6">
<h6 id="orge25ab90">具备单向性</h6>
<div class="outline-text-6" id="text-orge25ab90">
<p>
无法通过散列值反算出消息的内容。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfc1a0bb" class="outline-5">
<h5 id="orgfc1a0bb">单向散列函数的应用</h5>
<div class="outline-text-5" id="text-orgfc1a0bb">
</div>
<div id="outline-container-orgac78a42" class="outline-6">
<h6 id="orgac78a42">检测软件是否被篡改</h6>
<div class="outline-text-6" id="text-orgac78a42">
<p>
用户下载到软件后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。<br />
</p>
</div>
</div>
<div id="outline-container-org01b2eb3" class="outline-6">
<h6 id="org01b2eb3">基于口令的加密</h6>
<div class="outline-text-6" id="text-org01b2eb3">
<p>
基于口令的加密（PBE password based encrytion）的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后，将这个散列值作为加密的密钥。通过这样的方法能够预防针对口令的字典攻击。<br />
</p>
</div>
</div>
<div id="outline-container-org89161cf" class="outline-6">
<h6 id="org89161cf">消息认证码</h6>
<div class="outline-text-6" id="text-org89161cf">
<p>
使用单向散列函数可以构造消息认证码。消息认证码是将“发送者和接收者之间的共享密钥”和“信息”进行混合后计算出的散列值。<br />
</p>
</div>
</div>
<div id="outline-container-orgd418137" class="outline-6">
<h6 id="orgd418137">数字签名</h6>
<div class="outline-text-6" id="text-orgd418137">
<p>
数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。<br />
</p>
</div>
</div>
<div id="outline-container-org32bc22d" class="outline-6">
<h6 id="org32bc22d">伪随机数生成器</h6>
<div class="outline-text-6" id="text-org32bc22d">
<p>
密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。<br />
</p>
</div>
</div>
<div id="outline-container-orgab276e6" class="outline-6">
<h6 id="orgab276e6">一次性口令</h6>
<div class="outline-text-6" id="text-orgab276e6">
<p>
一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次，因此即使窃听者窃取了口令，也无法使用。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgdbcfc33" class="outline-5">
<h5 id="orgdbcfc33">单向散列函数的具体实例</h5>
<div class="outline-text-5" id="text-orgdbcfc33">
</div>
<div id="outline-container-org20fdc39" class="outline-6">
<h6 id="org20fdc39">MD4 MD5</h6>
<div class="outline-text-6" id="text-org20fdc39">
<p>
MD 是消息摘要（Message Digest）的缩写。MD4 和 MD5 目前都已经不安全了。<br />
</p>
</div>
</div>
<div id="outline-container-org540b841" class="outline-6">
<h6 id="org540b841">SHA-1 SHA-256 SHA-384 SHA-512</h6>
<div class="outline-text-6" id="text-org540b841">
<p>
SHA-1 的强抗碰撞性已于 2005 年被攻破。<br />
</p>
</div>
</div>
<div id="outline-container-orgae1369f" class="outline-6">
<h6 id="orgae1369f">RIPEMD-160</h6>
<div class="outline-text-6" id="text-orgae1369f">
<p>
RIPEMD-160 是 RIPEMD 的修订版。RIPEMD 的强抗碰撞性已经于 2004 年被攻破。<br />
</p>
</div>
</div>
<div id="outline-container-orgc2182bb" class="outline-6">
<h6 id="orgc2182bb">ASH 与 SHA-3</h6>
<div class="outline-text-6" id="text-orgc2182bb">
<p>
SHA-3 用于取代 SHA-1。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。<br />
2012 年 10 月 2 日，期盼已久的 SHA-3 获胜算法终于揭开了她的面纱，她就是 Keccak 算法！Keccak 算法由意法半导体的 Guido Bertoni、Joan Daemen（AES 算法合作者）和 Gilles Van Assche，以及恩智浦半导体的 Michaël Peeters 联合开发。NIST 计算机安全专家 Tim Polk 说，Keccak 的优势在于它与 SHA-2 设计上存在极大差别，适用于 SHA-2 的攻击方法将不能作用于 Keccak。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcc0a479" class="outline-5">
<h5 id="orgcc0a479">单向散列函数 SHA-1</h5>
<div class="outline-text-5" id="text-orgcc0a479">

<div class="figure">
<p><img src="Cryptology/21_sha1_overview.jpg" alt="21_sha1_overview.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org6d0d8fd" class="outline-6">
<h6 id="org6d0d8fd">填充</h6>
<div class="outline-text-6" id="text-org6d0d8fd">
<p>
对消息进行填充处理，使其长度为 512 比特的整数倍。这里 512 比特称为一个输入分组。<br />
输入 SHA-1 的消息长度应大于 0 比特小于 2^64 比特。<br />
SHA-1 的填充过程如下：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8d08735"></a>添加 1<br />
<div class="outline-text-7" id="text-org8d08735">
<p>
在消息末尾添加一个 1 比特的数值“1”，这样消息的长度就增加了 1 比特。<br />
</p>
</div>
</li>
<li><a id="org335a78a"></a>添加 0<br />
<div class="outline-text-7" id="text-org335a78a">
<p>
在消息的末尾继续添加 0，直到消息的长度达到 512 比特的整数倍。但是，最后一个分组的最后 64 比特需要空出来以便保存原始的消息长度。<br />
</p>
</div>
</li>
<li><a id="org46f36fb"></a>添加消息长度<br />
<div class="outline-text-7" id="text-org46f36fb">
<p>
在最后一个分组的最后 64 比特中保存原始消息的长度。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org102c586" class="outline-6">
<h6 id="org102c586">计算 W0-W79</h6>
<div class="outline-text-6" id="text-org102c586">
<p>
根据输入分组的 512 比特计算出 80 个 32 比特的值（W0-W79）<br />
首先，输入分组的 512 比特分成 32 比特*16 组，并将它们命名为 W0-W15.<br />
然后，剩下的 W16-W79 的计算方法如下。<br />
W16 = （W0 xor W2 xor W8 xor W13） 循环左移 1 比特<br />
Wt = W(t-16) xor W(t-14) xor W(t-8) xor W(t-3) 循环左移 1 比特<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org46cea95"></a>循环左移 1 比特操作图如下：<br />
<div class="outline-text-7" id="text-org46cea95">

<div class="figure">
<p><img src="Cryptology/21_sha1_shiftleft1.jpg" alt="21_sha1_shiftleft1.jpg" /><br />
</p>
</div>
</div>
</li>
<li><a id="orgeefba1c"></a>计算 W0-W79 操作图如下：<br />
<div class="outline-text-7" id="text-orgeefba1c">

<div class="figure">
<p><img src="Cryptology/21_sha1_calcW.jpg" alt="21_sha1_calcW.jpg" /><br />
</p>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org01da42a" class="outline-6">
<h6 id="org01da42a">分组处理</h6>
<div class="outline-text-6" id="text-org01da42a">
<p>
对输入分组一次进行 80 个步骤的处理，计算 5 个 32 比特的值（A-E）作为 SHA-1 的内部状态。对所有的分组都要进行这一操作。<br />
160 比特的内部状态是通过名为 ABCDE 的 5 个 32 比特的缓冲区来表示的，80 个步骤所完成的操作，就是将输入分组的 512 比特的数据，与 SHA-1 所保持的 160 比特的内部状态（5 个缓冲区）进行混合。通过上述 80 个步骤的反复执行，SHA-1 就能够将已经过填充的消息全部混入这 160 比特的内部状态中，而 SHA-1 所输出的散列值，就是所有处理结束之后最终的内部状态（160 比特）。<br />
<img src="Cryptology/21_sha1_processblock.jpg" alt="21_sha1_processblock.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org0c64868" class="outline-6">
<h6 id="org0c64868">单步处理</h6>
<div class="outline-text-6" id="text-org0c64868">
<p>
分组处理是由 80 个步骤的处理组成的，其中每个步骤都是基于 W0-W79 使内部状态进行复杂变化的处理。<br />
在一个步骤完成后，缓冲区 ABCD 的内容会被分别复制到 BCDE 中（其中 B 要循环左移 30 比特之后再复制），而缓冲区 E 的内容则会与其他缓冲区的内容以及 Wt，Kt 相加之后再被复制到缓冲区 A 中。<br />
由于上述处理要循环 80 个步骤，因此输入分组中 1 个比特的变化，就会影响到散列值中几乎所有的比特，通过这样的方式，我们就能够实现单向散列函数所应具备的性质。<br />
<img src="Cryptology/21_sha1_onestep.jpg" alt="21_sha1_onestep.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0d5188e" class="outline-5">
<h5 id="org0d5188e">对单向散列函数的攻击</h5>
<div class="outline-text-5" id="text-org0d5188e">
</div>
<div id="outline-container-org21a4d70" class="outline-6">
<h6 id="org21a4d70">暴力破解</h6>
<div class="outline-text-6" id="text-org21a4d70">
<p>
寻找和特定消息具备相同散列值的另一条不同的消息。这是一种试图破解单向散列函数的“弱抗碰撞性”的攻击<br />
</p>
</div>
</div>
<div id="outline-container-org2241b29" class="outline-6">
<h6 id="org2241b29">生日攻击</h6>
<div class="outline-text-6" id="text-org2241b29">
<p>
寻找散列值相同的两条消息，散列值可以是任意值。这是一种试图破解单向散列函数的“强抗碰撞性”的攻击<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org30db6e1" class="outline-5">
<h5 id="org30db6e1">单向散列函数无法解决的问题</h5>
<div class="outline-text-5" id="text-org30db6e1">
<p>
单向散列函数可以辨别出“篡改”，但无法辨别出“伪装”<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org65f9c0b" class="outline-4">
<h4 id="org65f9c0b">消息认证码</h4>
<div class="outline-text-4" id="text-org65f9c0b">
</div>
<div id="outline-container-org795e9aa" class="outline-5">
<h5 id="org795e9aa">什么是消息认证码</h5>
<div class="outline-text-5" id="text-org795e9aa">
<p>
消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称 MAC。<br />
消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。<br />
根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，而消息认证码中则需要使用发送者和接收者之间共享的密钥。<br />
要计算 MAC 必须持有共享密钥，没有共享密钥的人就无法计算 MAC 值，消息认证码正式利用这一性质来完成认证的。<br />
和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化，MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。<br />
<img src="Cryptology/22_mac_vs_sha.jpg" alt="22_mac_vs_sha.jpg" /><br />
</p>
</div>
</div>
<div id="outline-container-org42dc0f8" class="outline-5">
<h5 id="org42dc0f8">消息认证码的使用步骤</h5>
<div class="outline-text-5" id="text-org42dc0f8">

<div class="figure">
<p><img src="Cryptology/22_mac.jpg" alt="22_mac.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org25a864b" class="outline-5">
<h5 id="org25a864b">消息认证码的实现方法</h5>
<div class="outline-text-5" id="text-org25a864b">
</div>
<div id="outline-container-orgcd60d78" class="outline-6">
<h6 id="orgcd60d78">利用单向散列函数可以实现消息认证码</h6>
</div>
<div id="outline-container-org7376755" class="outline-6">
<h6 id="org7376755">使用分组密码实现</h6>
<div class="outline-text-6" id="text-org7376755">
<p>
使用 DES，AES 之类的分组密码可以实现消息认证码。具体做法为，将分组密码的密钥作为消息认证码的共享密钥来使用，并使用 CBC 模式将消息全部加密。由于消息认证码中不需要解密，因此将除最后一个分组以外的密文部分全部丢弃，而将最后一个分组作为 MAC 值。由于 CBC 模式的最后一个分组会受到整个消息以及密钥的双重影响，因此可以将它用作消息认证码。<br />
</p>
</div>
</div>
<div id="outline-container-orga97d896" class="outline-6">
<h6 id="orga97d896">其他实现方法</h6>
<div class="outline-text-6" id="text-orga97d896">
<p>
使用流密码和公钥密码也可以实现消息认证码。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0209c7b" class="outline-5">
<h5 id="org0209c7b">HMAC</h5>
<div class="outline-text-5" id="text-org0209c7b">
<p>
HMAC 是一种使用单向散列函数来构造消息认证码的方法，其中 HMAC 的 H 就是 Hash 的意思。HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC。<br />
<img src="Cryptology/22_mac_hmac.jpg" alt="22_mac_hmac.jpg" /><br />
</p>
</div>
<div id="outline-container-org333e54d" class="outline-6">
<h6 id="org333e54d">1 密钥填充</h6>
<div class="outline-text-6" id="text-org333e54d">
<p>
如果密钥比单向散列函数的分组长度要短，就需要在末尾填充 0，直到其长度达到单向散列函数的分组长度为止。<br />
如果密钥比单向散列函数的分组要长，则要用单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC 的密钥。<br />
</p>
</div>
</div>
<div id="outline-container-orgcc67020" class="outline-6">
<h6 id="orgcc67020">2 填充后的密钥与 ipad 的 XOR</h6>
<div class="outline-text-6" id="text-orgcc67020">
<p>
将填充后的密钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 00110110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner（内部）的意思。<br />
XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和密钥相关的比特序列。这里我们将这个比特序列称为 ipadkey<br />
</p>
</div>
</div>
<div id="outline-container-orgd6a37a1" class="outline-6">
<h6 id="orgd6a37a1">3 与消息组合</h6>
<div class="outline-text-6" id="text-orgd6a37a1">
<p>
随后，将 ipadkey 与消息进行组合，也就是将密钥相关的比特序列（ipadkey）附加在消息的开头。<br />
</p>
</div>
</div>
<div id="outline-container-orge27568d" class="outline-6">
<h6 id="orge27568d">4 计算散列值</h6>
<div class="outline-text-6" id="text-orge27568d">
<p>
将第 3 步的结果输入单向散列函数，并计算初散列值。<br />
</p>
</div>
</div>
<div id="outline-container-orgd8535ef" class="outline-6">
<h6 id="orgd8535ef">5 填充后的密钥与 opad 的 XOR</h6>
<div class="outline-text-6" id="text-orgd8535ef">
<p>
将填充后的密钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 进制的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer（外部）的意思。<br />
XOR 运算所得到的值，这里我们将其称为 opadkey<br />
</p>
</div>
</div>
<div id="outline-container-orgfc3bb65" class="outline-6">
<h6 id="orgfc3bb65">6 将 第 4 步 的散列值拼在 opadkey 后面</h6>
</div>
<div id="outline-container-orgdd985c3" class="outline-6">
<h6 id="orgdd985c3">7 计算散列值</h6>
<div class="outline-text-6" id="text-orgdd985c3">
<p>
将第 6 步的结果输入单向散列函数，并计算出散列值。这个散列值就是最终的 MAC 值。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org357018d" class="outline-5">
<h5 id="org357018d">对消息认证码的攻击</h5>
<div class="outline-text-5" id="text-org357018d">
</div>
<div id="outline-container-orge5a165e" class="outline-6">
<h6 id="orge5a165e">重放攻击</h6>
<div class="outline-text-6" id="text-orge5a165e">
<p>
将正确的 MAC 值保持下来重复利用，这种攻击方式称为重放攻击。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgec90e95"></a>序号<br />
<div class="outline-text-7" id="text-orgec90e95">
<p>
约定每次都对发送的消息赋予一个递增的编号（序号），并且计算 MAC 值时将序号也包含在消息中。这种方法虽然有效，但是对每个通信对象都需要记录最后一个消息的序号。<br />
</p>
</div>
</li>
<li><a id="orgc0d3b2a"></a>时间戳<br />
<div class="outline-text-7" id="text-orgc0d3b2a">
<p>
约定在消息发送时包含当前的时间，如果收到以前的消息，即便 MAC 值正确也将其当做错误的消息来处理。这种方法需要保证发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，依然还有重放攻击的可能。<br />
</p>
</div>
</li>
<li><a id="org468254c"></a>nonce<br />
<div class="outline-text-7" id="text-org468254c">
<p>
在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。该方法虽然有效，但通信的数据量会有所增加。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga7465e4" class="outline-6">
<h6 id="orga7465e4">密钥推测攻击</h6>
<div class="outline-text-6" id="text-orga7465e4">
<p>
对于消息认证码来说，应保证不能根据 MAC 值推测出通信双方所使用的密钥。HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出密钥的。<br />
此外，在生成消息认证码所使用的密钥时，必须使用密码学安全的、高强度的伪随机数生成器。如果密钥是人为选定的，则会增加密钥被推测的风险。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge24c247" class="outline-5">
<h5 id="orge24c247">消息认证码无法解决的问题</h5>
<div class="outline-text-5" id="text-orge24c247">
</div>
<div id="outline-container-org8f9269d" class="outline-6">
<h6 id="org8f9269d">对第三方证明</h6>
</div>
<div id="outline-container-orgb080e68" class="outline-6">
<h6 id="orgb080e68">防止否认</h6>
</div>
</div>
</div>
<div id="outline-container-orgf4bfc3c" class="outline-4">
<h4 id="orgf4bfc3c">数字签名</h4>
</div>
<div id="outline-container-orgdb59eb1" class="outline-4">
<h4 id="orgdb59eb1">证书</h4>
</div>
</div>
<div id="outline-container-org29ff7e4" class="outline-3">
<h3 id="org29ff7e4">密码学应用</h3>
<div class="outline-text-3" id="text-org29ff7e4">
</div>
<div id="outline-container-org080405b" class="outline-4">
<h4 id="org080405b">密钥-秘密的精华</h4>
</div>
<div id="outline-container-org9e44260" class="outline-4">
<h4 id="org9e44260">随机数-不可预测性的源泉</h4>
</div>
<div id="outline-container-orgf2fe920" class="outline-4">
<h4 id="orgf2fe920">PGP</h4>
</div>
<div id="outline-container-org3fbcd39" class="outline-4">
<h4 id="org3fbcd39">SSL/TLS</h4>
</div>
<div id="outline-container-org2bc2b0b" class="outline-4">
<h4 id="org2bc2b0b">密码技术与现实社会</h4>
</div>
</div>
</div>
<div id="outline-container-org5a47567" class="outline-2">
<h2 id="org5a47567">密码学实践</h2>
<div class="outline-text-2" id="text-org5a47567">
<p>
实践项目 <a href="https://github.com/wolfand11/cryptology">https://github.com/wolfand11/cryptology</a><br />
</p>
<ul class="org-ul">
<li>DES 实现<br /></li>
<li>AES 实现<br />
下面 flash 详细描述了 AES 加密过程<br />
<a href="https://coolshell.cn/wp-content/uploads/2010/10/rijndael_ingles2004.swf">https://coolshell.cn/wp-content/uploads/2010/10/rijndael_ingles2004.swf</a><br /></li>
<li>TEA 实现<br /></li>
<li>RSA 实现<br /></li>
<li>sha-1 实现<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org10b6fe2" class="outline-2">
<h2 id="org10b6fe2">参考资料</h2>
<div class="outline-text-2" id="text-org10b6fe2">
<ul class="org-ul">
<li>TEA <a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm">https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm</a><br /></li>
</ul>
</div>
</div>
</div>
</body>
</html>
