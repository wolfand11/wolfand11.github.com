<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-08-06 周四 16:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UnityCatLikeCoding</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">UnityCatLikeCoding</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb413225">UnityCatLikeCoding</a>
<ul>
<li><a href="#orgd26fc1a">Rendering</a>
<ul>
<li><a href="#orge9bbf17">Shader Fundamentals</a>
<ul>
<li><a href="#orgaadafde">基础知识</a>
<ul>
<li><a href="#org06211c4">MatrixType</a></li>
<li><a href="#org6204438">SV 含义</a></li>
<li><a href="#org3e8dac3">ST 含义</a></li>
<li><a href="#orgab79e27">贴图坐标系</a></li>
<li><a href="#org9e4b42f">MipMap 和 FilterMode</a></li>
<li><a href="#org5b1b147">TRANSFORM_TEX</a></li>
<li><a href="#org4db8015">tex2Dbias tex2Dlod</a></li>
<li><a href="#org63edc06">lerp 函数意义</a></li>
<li><a href="#org5e3672a">ddx ddy</a></li>
<li><a href="#org0b9e57f">fwidth</a></li>
<li><a href="#orgdae11d1">smoothstep</a></li>
</ul>
</li>
<li><a href="#org6b01817">Shader Semantics</a>
<ul>
<li><a href="#orgc7e83c0">Screen space pixel position: VPOS</a></li>
<li><a href="#org0bf2bc3">Face orientation: VFACE</a></li>
<li><a href="#orga87da47">参考资料</a></li>
</ul>
</li>
<li><a href="#orgc38edea">Unity 定义的变量</a></li>
<li><a href="#org744fcef">Unity Shader 定义的宏</a></li>
<li><a href="#orga4a2d30">Unity Shader Compiler</a></li>
<li><a href="#org32379c8">Unity shader 预编译命令</a></li>
<li><a href="#orgf3d8821">D3D11 汇编命令</a></li>
</ul>
</li>
<li><a href="#orgbaa1cc4">Combining Textures</a>
<ul>
<li><a href="#orgf384c76">Linear Color Space</a>
<ul>
<li><a href="#org305567d">Linear Color Space 原理</a></li>
<li><a href="#orgfecc5e9">DetailTex 叠加到 MainTex 上为什么需要乘二？</a></li>
<li><a href="#orgc8945da">SetVector SetColor</a></li>
<li><a href="#orgc993876">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org41de4cf">The First Light</a>
<ul>
<li><a href="#org1bfc9ac">normal 从物体空间到世界空间的变换</a></li>
<li><a href="#org05e29f1">Tags LightMode=ForwardBase</a></li>
<li><a href="#org1b664a6">BlinnPhong</a></li>
<li><a href="#orgba1b054">Energy Conservation</a></li>
<li><a href="#org1696503">Specular / Metallic Workflow</a>
<ul>
<li><a href="#org5da876b">Specular Workflow</a></li>
<li><a href="#orge2552ca">Metallic Workflow</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0441654">Multi Lights</a>
<ul>
<li><a href="#org87e3e84">Light Coord</a></li>
<li><a href="#org8fb7075">Light Attenuation</a>
<ul>
<li><a href="#org10a566a">Point Light</a></li>
</ul>
</li>
<li><a href="#org3d65484">Mixing Lights</a></li>
<li><a href="#orgd5fda50">Cookies</a></li>
<li><a href="#org162035f">Vertex Lights</a></li>
<li><a href="#org56bdd8e">Spherical Harmonics</a>
<ul>
<li><a href="#org105801c">相关数学概念</a></li>
<li><a href="#org2f03b5f">原理概述</a></li>
<li><a href="#org3ed044d">Spherical Harmonics Bands</a></li>
<li><a href="#orgcb919f5">ShadeSH9</a></li>
<li><a href="#orgdb56ec7">环境光和 LightProbe</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb25af05">Bumpiness</a>
<ul>
<li><a href="#org2415d68">高度图转 normal map 的方法</a>
<ul>
<li><a href="#org65940d2">方案 1</a></li>
<li><a href="#orgc7abfe5">方案 2</a></li>
</ul>
</li>
<li><a href="#org052d351">Normal 向量的插值</a></li>
<li><a href="#orgfa770a7">Normal 贴图存储惯例</a></li>
<li><a href="#org4e40379">DXT5nm 存储 normal 贴图</a></li>
<li><a href="#org2439223">缩放 Normal</a></li>
<li><a href="#org4fb76b0">Blending Normals</a></li>
</ul>
</li>
<li><a href="#orgbb8b28a">Shadows</a>
<ul>
<li><a href="#org063e6df">方向光阴影</a>
<ul>
<li><a href="#orgcf8167e">ShadowBias</a></li>
<li><a href="#orgc5b7f87">开启屏幕空间阴影</a></li>
<li><a href="#org7df3e80">关闭屏幕空间阴影</a></li>
<li><a href="#orgb97eafd">ShadowQuality</a></li>
<li><a href="#orgb0cc079">ForwardAddPass 阴影支持</a></li>
<li><a href="#org8385bed">参考资料</a></li>
</ul>
</li>
<li><a href="#orgc18faea">Spot Light Shadow</a></li>
<li><a href="#orgfaf2973">相关宏定义</a></li>
<li><a href="#orgdcd0be7">参考资料</a></li>
</ul>
</li>
<li><a href="#org6b6f538">Reflection</a>
<ul>
<li><a href="#orgb29cd7c">Environment Mapping</a>
<ul>
<li><a href="#orged62eca">缺少 Indirect Specular Lighting</a></li>
<li><a href="#org427ac3c">Indirect Specular Lighting 特点</a></li>
</ul>
</li>
<li><a href="#org52421aa">Imperfect Reflections</a>
<ul>
<li><a href="#orgdd94a4d">Metals VS Nonmetals</a></li>
<li><a href="#org549e3fd">Mirrors and Shadows</a></li>
</ul>
</li>
<li><a href="#org273ff62">Box Projection</a></li>
<li><a href="#org5405186">Blending Reflection Probes</a></li>
<li><a href="#org175c057">Bouncing Reflections</a></li>
</ul>
</li>
<li><a href="#orgb31218d">ComplexMaterials &amp; More Complexity</a>
<ul>
<li><a href="#org7541232">Emission</a></li>
<li><a href="#org1cb4bb1">Smoothness &amp; Metallic Map</a></li>
<li><a href="#org7000f1c">Occlusion</a></li>
</ul>
</li>
<li><a href="#org00a77ee">Transparency</a>
<ul>
<li><a href="#org8d7c0f8">Cutout</a></li>
<li><a href="#org083834a">Semitransparent</a></li>
<li><a href="#orgc504db6">RenderType tag</a></li>
<li><a href="#org73f1155">Fading vs Transparency</a></li>
</ul>
</li>
<li><a href="#org891f211">Semitransparent Shadows</a>
<ul>
<li><a href="#orgdd7456b">Cutout Shadow</a></li>
<li><a href="#org737838f">Transparenct Shadow</a></li>
</ul>
</li>
<li><a href="#orgbaee981">Deferred Shading</a>
<ul>
<li><a href="#org41d6021">Forward Path vs Deferred Path</a>
<ul>
<li><a href="#org4442c36">DrawCall 对比</a></li>
<li><a href="#orgb14260b">GBuffer 内容</a></li>
<li><a href="#org46b1398">Rendering Lights</a></li>
<li><a href="#org9ffbd28">Light Range</a></li>
<li><a href="#org521e665">Mixing Rendering Modes</a></li>
</ul>
</li>
<li><a href="#org35b13c3">Support Deferred Path</a>
<ul>
<li><a href="#org343a040">创建 deferred pass</a></li>
<li><a href="#orgd86fc27">deferred pass frag output</a></li>
<li><a href="#org3981aab">gbufer0123</a></li>
<li><a href="#orgdf6508a">support LDR</a></li>
</ul>
</li>
<li><a href="#org35e5f94">Deferred Reflections</a>
<ul>
<li><a href="#org4354cf3">Unity 内置的屏幕空间反射</a></li>
<li><a href="#org0605cab">延迟渲染使用非屏幕空间反射</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3eb94b5">Fog</a>
<ul>
<li><a href="#org886e345">Forward Fog</a>
<ul>
<li><a href="#orgce217af">Linear Fog</a></li>
<li><a href="#org88e453c">Exponential Fog</a></li>
<li><a href="#orgff4cf0e">Exponential Squared Fog</a></li>
<li><a href="#orgac64bce">Depth-Based Fog</a></li>
<li><a href="#orgebada73">代码实现</a></li>
</ul>
</li>
<li><a href="#org963bb07">Deferred Fog</a>
<ul>
<li><a href="#orga36f85d">Shader Source Code</a></li>
<li><a href="#org0a522a2">Depth-Based Fog</a></li>
<li><a href="#org25a8c2b">Distance Based Fog</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org193b5d1">Deferred Lights</a>
<ul>
<li><a href="#org892adb8">Q&amp;A</a>
<ul>
<li><a href="#org0f2e50a"><span class="todo TODO">TODO</span> 为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？</a></li>
<li><a href="#org399bdc1">为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？</a></li>
<li><a href="#org03f6610">为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc1f2489">Static Lighting</a>
<ul>
<li><a href="#org76a4669">Lightmapping 光照贴图</a>
<ul>
<li><a href="#org07ad597">简介</a></li>
<li><a href="#orgd263f9d">Unity 中使用光照贴图的步骤</a></li>
<li><a href="#orgdd64fde">Lightmapping Settings</a></li>
<li><a href="#org3e9539e">Indirect Light</a></li>
<li><a href="#org3ffbf5e">Transparency</a></li>
</ul>
</li>
<li><a href="#org856b934">使用光照贴图</a></li>
<li><a href="#orga2db716">创建光照贴图</a>
<ul>
<li><a href="#org6cb12a3">lightmapper 默认规则</a></li>
<li><a href="#org4decf97">通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper</a></li>
</ul>
</li>
<li><a href="#org8d0f0c8">Directional Lightmaps 具有方向的光照贴图</a>
<ul>
<li><a href="#org90f04ee">简介</a></li>
<li><a href="#orgfec2e02">方向性</a></li>
<li><a href="#org90c67fa">使用烘培的方向贴图</a></li>
</ul>
</li>
<li><a href="#org1f6cefd">Light Probes</a>
<ul>
<li><a href="#org7234506">为什么 SceneView 中不显示 LightProbe？</a></li>
<li><a href="#org65b943d">为什么 LightProb 对于动态物体不生效？</a></li>
</ul>
</li>
<li><a href="#org1e14a42">Q&amp;A</a>
<ul>
<li><a href="#org2209830">使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？</a></li>
<li><a href="#orgbb99a98">什么错误导致 lightmap 中不包含 Emission 颜色？</a></li>
<li><a href="#orgf7bc968">Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8b8c1f0">Mixed Lighting</a>
<ul>
<li><a href="#orgd31cd8c">烘培光照贴图的优缺点</a>
<ul>
<li><a href="#org76c232a">缺点</a></li>
<li><a href="#orgfc6aa3e">优点</a></li>
</ul>
</li>
<li><a href="#orge72fd66">Baking Indirect Light</a></li>
<li><a href="#orga74f0af">Using a Shadowmask</a>
<ul>
<li><a href="#org1af958f">Sampling the Shadowmask</a></li>
<li><a href="#org476c3c2">Support Deferred Path</a></li>
<li><a href="#org16cc4da">Distance Shadowmask Mode</a></li>
<li><a href="#org2383d54">Multiple Lights</a></li>
</ul>
</li>
<li><a href="#org294822e">Subtractive Shadows</a>
<ul>
<li><a href="#org700693d">简介</a></li>
<li><a href="#org5f929ae">实现</a></li>
</ul>
</li>
<li><a href="#orgaa5cc02">总结</a></li>
<li><a href="#org18028c2">Q&amp;A</a>
<ul>
<li><a href="#orge273f47"><span class="todo TODO">TODO</span> 如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？</a></li>
<li><a href="#orgf121e74">烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？</a></li>
<li><a href="#org2981309">ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图</a></li>
<li><a href="#org3c21efa">Deferred Path 模式下的间接光照计算是怎样的？</a></li>
<li><a href="#orgf849f48">Error: 阴影轮廓处有光晕</a></li>
<li><a href="#orga6c6dbf">Error: Subtractive 模式下动态物体的阴影很淡</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org701ca69">RealtimeGI ProbeVolumes LOD Groups</a>
<ul>
<li><a href="#orgbda86b2">Realtime Globall Illumination</a>
<ul>
<li><a href="#org8a1ed55">简介</a></li>
<li><a href="#org53e80a3">Baking Realtime GI</a></li>
<li><a href="#org64f567e">Sampling Realtime Lightmaps</a></li>
<li><a href="#orgbe6c70c">Emissive Light</a></li>
</ul>
</li>
<li><a href="#org2953505">Light Probe Proxy Volumes</a></li>
<li><a href="#org0d9725b">LOD Groups</a>
<ul>
<li><a href="#org85f0fef">Baked GI and Lod Group</a></li>
<li><a href="#org6293ddf">Realtime GI and Lod Group</a></li>
<li><a href="#orgf404f1e">Cross-fading Between Lod Levels</a></li>
<li><a href="#org66028d3">Q&amp;A</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf1559da">GPU Instancing</a>
<ul>
<li><a href="#org915d4a7">Batching Instances</a>
<ul>
<li><a href="#org2ed2b7f">简介</a></li>
<li><a href="#org4087eda">Support GPU Instancing</a></li>
<li><a href="#org2f425f4">Batch Size</a></li>
</ul>
</li>
<li><a href="#org5dab1a8">Mixing Material Properties</a></li>
</ul>
</li>
<li><a href="#org3882fcb">Parallax</a>
<ul>
<li><a href="#org1f986b9">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org982d00e">Advanced Rendering</a>
<ul>
<li><a href="#org9d60a92">Flat and Wireframe Shading</a>
<ul>
<li><a href="#org0a9b99d">Barycentric Coordinates</a></li>
<li><a href="#org658eb34">Q&amp;A</a>
<ul>
<li><a href="#org78bff50">为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5863c6e">Tessellation</a>
<ul>
<li><a href="#org5c74cbc">Q&amp;A</a>
<ul>
<li><a href="#org38ed3eb">ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;</a></li>
<li><a href="#org37ce392">ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7ae509d">Surface Displacement</a></li>
<li><a href="#orgc6241cc">Bloom</a>
<ul>
<li><a href="#org1f9c251">利用 Downsampling Upsampling 模糊图片的原理</a></li>
<li><a href="#orgc0949e1">Q&amp;A</a>
<ul>
<li><a href="#org0576c75"><span class="todo TODO">TODO</span> 自定义的 Bloom 如何放到 Builtin Uber 中一起计算？在 Builtin Uber 中一起计算的好处是什么？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdf337d2">Depth of Field</a>
<ul>
<li><a href="#orgbd11ad0">Bokeh</a></li>
<li><a href="#orge77f17e">Q&amp;A</a>
<ul>
<li><a href="#org113003b"><span class="todo TODO">TODO</span> 为什么开启 MSAA 的时候，DOF 效果会错误？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6160ec3">FXAA</a>
<ul>
<li><a href="#org2dc801f">SSAA MSAA</a>
<ul>
<li><a href="#org445bc75">Q&amp;A</a></li>
<li><a href="#org9da6269">参考资料</a></li>
</ul>
</li>
<li><a href="#orge5f001b">参考资源</a></li>
</ul>
</li>
<li><a href="#orgbc3a765">Triplanar Mapping</a>
<ul>
<li><a href="#org58d1745">求解 Normal</a>
<ul>
<li><a href="#org48b1060">TangentNormal</a></li>
<li><a href="#org6a63b0f">TangentNormalToWorldNormal WorldNormalToTangentNormal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae474a1">CustomSRP</a></li>
</ul>
</li>
<li><a href="#org4775f5b">MyTest</a>
<ul>
<li><a href="#org2b1c321">TestReplaceShader</a>
<ul>
<li><a href="#org3d95766">SetReplacementShader VS RenderWithShader</a></li>
<li><a href="#org5d9b0b6">Q&amp;A</a>
<ul>
<li><a href="#org2c6791d">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3d80cdc">BilinearFiltering</a></li>
<li><a href="#org2414a76">SphereMapping</a>
<ul>
<li><a href="#org64b1bf3">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb0329e0">Q&amp;A</a>
<ul>
<li><a href="#org5bd851b">如何判断投影矩阵是否为透视投影？</a></li>
<li><a href="#orgba699cb">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</a></li>
<li><a href="#org2e2c4fa">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</a></li>
<li><a href="#orgc77a5a1">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</a></li>
<li><a href="#org95836b7">为什么点光源阴影需要绘制场景 6 次？</a></li>
<li><a href="#orgbe40455">Renderer.receiveShadows 是如何控制关闭接收阴影的？</a></li>
<li><a href="#org0f186c7">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</a></li>
</ul>
</li>
<li><a href="#orgb9f9731">参考资料</a></li>
</ul>
</div>
</div>
<p>
UnityCatLikeCoding note.<br />
</p>
<div class="HTML">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-orgb413225" class="outline-2">
<h2 id="orgb413225">UnityCatLikeCoding</h2>
<div class="outline-text-2" id="text-orgb413225">
</div>
<div id="outline-container-orgd26fc1a" class="outline-3">
<h3 id="orgd26fc1a">Rendering</h3>
<div class="outline-text-3" id="text-orgd26fc1a">
</div>
<div id="outline-container-orge9bbf17" class="outline-4">
<h4 id="orge9bbf17">Shader Fundamentals</h4>
<div class="outline-text-4" id="text-orge9bbf17">
</div>
<div id="outline-container-orgaadafde" class="outline-5">
<h5 id="orgaadafde">基础知识</h5>
<div class="outline-text-5" id="text-orgaadafde">
</div>
<div id="outline-container-org06211c4" class="outline-6">
<h6 id="org06211c4">MatrixType</h6>
<div class="outline-text-6" id="text-org06211c4">
<p>
可以参考 unitycatlikecoding\Rendering\Assets\MyTest\03TestShaderMatrix 工程中的展示效果。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Properties</span>
{
    <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
    [Enum(NotDefineM,0,DefineM,1,DefineMWithVect,2)] DefineMatrix(<span style="color: #2d9574;">"DefineMatrix"</span>, <span style="color: #4f97d7; font-weight: bold;">Float</span>) = 0
}
v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    <span style="color: #ce537a; font-weight: bold;">float4</span> translatedVertex = v.vertex + 0.5;
    <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix != 0)
    {
        <span style="color: #ce537a; font-weight: bold;">float4x4</span> translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );
        <span style="color: #4f97d7; font-weight: bold;">if</span> (DefineMatrix == 1)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity shader&#20013;&#21521;&#37327;&#20026;&#21015;&#21521;&#37327;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30697;&#38453;&#27599;&#19968;&#21015;&#34920;&#31034;&#21464;&#25442;&#21518;&#26032;&#22352;&#26631;&#31995;&#30340;&#22522;&#22352;&#26631;&#36724;</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">xAxis = &#65288;2,1,0)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">yAxis = &#65288;1,1,0)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zAxis = &#65288;0,0,2)</span>
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30452;&#25509;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
            translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(
                2, 1, 0, 0,
                1, 1, 0, 0,
                0, 0, 2, 0,
                0, 0, 0, 1
            );
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5; font-weight: bold;">if</span> (DefineMatrix == 2)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#21521;&#37327;&#21021;&#22987;&#21270;&#30697;&#38453;</span>
            <span style="color: #ce537a; font-weight: bold;">float4</span> row0 = <span style="color: #ce537a; font-weight: bold;">float4</span>(2, 1, 0, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row1 = <span style="color: #ce537a; font-weight: bold;">float4</span>(1, 1, 0, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 2, 0);
            <span style="color: #ce537a; font-weight: bold;">float4</span> row3 = <span style="color: #ce537a; font-weight: bold;">float4</span>(0, 0, 0, 1);
            translateM = <span style="color: #ce537a; font-weight: bold;">float4x4</span>(row0,row1,row2,row3);
        }
        translatedVertex = <span style="color: #4f97d7;">mul</span>(translateM, translatedVertex);
    }
    o.wNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
    o.vertex = UnityObjectToClipPos(translatedVertex);
    o.uv = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : <span style="color: #a45bad;">SV_Target</span>
{
    <span style="color: #ce537a; font-weight: bold;">fixed4</span> col = 1;
    <span style="color: #ce537a; font-weight: bold;">float3x3</span> colM = <span style="color: #ce537a; font-weight: bold;">float3x3</span>(
        1, 1, 0,
        0, 1, 0,
        0, 0, 1
    );
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">colM[0]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;0&#34892;&#30340;&#25968;&#25454;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">colM[2]&#21462;&#20986;&#30340;&#25968;&#25454;&#26159;&#30697;&#38453;&#31532;2&#34892;&#30340;&#25968;&#25454;</span>
    col.rgb = colM[0];
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightDir = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col*<span style="color: #4f97d7;">dot</span>(lightDir, i.wNormal);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return col;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6204438" class="outline-6">
<h6 id="org6204438">SV 含义</h6>
<div class="outline-text-6" id="text-org6204438">
<p>
SV_POSITION、SV_TARGET 中 SV 表示 System Value<br />
SV_TARGET 表示 fragment shader 写入最终颜色值的默认目标对象，其实就是帧缓冲区对象<br />
</p>
</div>
</div>
<div id="outline-container-org3e8dac3" class="outline-6">
<h6 id="org3e8dac3">ST 含义</h6>
<div class="outline-text-6" id="text-org3e8dac3">
<p>
贴图附加的 Tiling 和 Offset 属性。ST 表示 Scale 和 Translation.<br />
</p>
</div>
</div>
<div id="outline-container-orgab79e27" class="outline-6">
<h6 id="orgab79e27">贴图坐标系</h6>
<div class="outline-text-6" id="text-orgab79e27">
<p>
OpenGL 坐标原点在左下角<br />
D3D 坐标原点在左上角<br />
</p>
</div>
</div>

<div id="outline-container-org9e4b42f" class="outline-6">
<h6 id="org9e4b42f">MipMap 和 FilterMode</h6>
<div class="outline-text-6" id="text-org9e4b42f">
<p>
MipMap       用于处理贴图图元密度大于像素密度的情况，一个像素对应多个贴图图元时，如果没有 mipmap，在多个贴图图元中采用一个图元而丢弃其他。有 mipmap 时，则使用更低分辨率的贴图让 像素密度和贴图密度相接近。<br />
FilterMode   用于处理贴图图元密度小于像素密度的情况，采样器会对靠近采样点的图元进行采样，然后对这些图元进行插值，来得到最终颜色值。<br />
</p>

<p>
Bilinear texture filtering  会对靠近采样点的四个图元进行加权平均。<br />
</p>

<p>
<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/bilinear-texture-filtering</a><br />
</p>
</div>
</div>
<div id="outline-container-org5b1b147" class="outline-6">
<h6 id="org5b1b147">TRANSFORM_TEX</h6>
<div class="outline-text-6" id="text-org5b1b147">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#26041;&#27861;&#23450;&#20041;&#22312; UnityCG.cginc</span>
<span style="color: #bc6ec5;">#define</span> TRANSFORM_TEX(tex,name) (tex.xy * name##<span style="color: #7590db;">_ST</span>.xy + name##<span style="color: #7590db;">_ST</span>.zw)
</pre>
</div>
</div>
</div>
<div id="outline-container-org4db8015" class="outline-6">
<h6 id="org4db8015">tex2Dbias tex2Dlod</h6>
<div class="outline-text-6" id="text-org4db8015">
<p>
tex2Dbias(s, t) : Samples a 2D texture after biasing the mip level by t.w.<br />
tex2Dlod(s, t)  : Samples a 2D texture with mipmaps. The mipmap LOD is specified in t.w.<br />
</p>

<ul class="org-ul">
<li>tex2Dbias <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dbias</a><br /></li>
<li>tex2Dlod <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod</a><br /></li>
<li><a href="https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/">https://forum.unity.com/threads/tex2dlod-vs-tex2dbias.249140/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org63edc06" class="outline-6">
<h6 id="org63edc06">lerp 函数意义</h6>
<div class="outline-text-6" id="text-org63edc06">

<div class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp.png" alt="00_lerp.png" /><br />
</p>
</div>

<p>
x = 0 时，y = p; x = 1 时，y = q;<br />
lerp(p, q, x) lerp(p(1-x), q, x) lerp(p(1-x)^2, q, x) 三个函数，依次减弱 p 的效果。<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/00_lerp_func.png" alt="00_lerp_func.png" /><br />
</p>
</div>

<p>
<a href="./UnityCatLikeCoding/00_lerp_func.ggb">./UnityCatLikeCoding/00_lerp_func.ggb</a><br />
</p>
</div>
</div>
<div id="outline-container-org5e3672a" class="outline-6">
<h6 id="org5e3672a">ddx ddy</h6>
<div class="outline-text-6" id="text-org5e3672a">
<p>
ddx(var_i) 求出 var_i 变量在当前像素块 x 方向的变化量<br />
ddy(var_i) 求出 var_i 变量在当前像素块 y 方向的变化量<br />
</p>

<ul class="org-ul">
<li><a href="http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104">http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0b9e57f" class="outline-6">
<h6 id="org0b9e57f">fwidth</h6>
<div class="outline-text-6" id="text-org0b9e57f">
<p>
fwidth(var_i) = abs(ddx(var_i)) + abs(ddy(var_i))<br />
</p>
</div>
</div>
<div id="outline-container-orgdae11d1" class="outline-6">
<h6 id="orgdae11d1">smoothstep</h6>
<div class="outline-text-6" id="text-orgdae11d1">
<p>
smoothstep(a, b, c) 在 a-b 范围进行插值，c&lt;=a 返回 0，c&gt;=b 返回 1<br />
</p>

<p>
t = (c-a)/(b-a)<br />
t = saturate(t)<br />
result = 3t^2 - 2t^3<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/00_smoothstep.png" alt="00_smoothstep.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org6b01817" class="outline-5">
<h5 id="org6b01817">Shader Semantics</h5>
<div class="outline-text-5" id="text-org6b01817">
</div>
<div id="outline-container-orgc7e83c0" class="outline-6">
<h6 id="orgc7e83c0">Screen space pixel position: VPOS</h6>
<div class="outline-text-6" id="text-orgc7e83c0">
<p>
VPOS 输出的变量中保存的是屏幕像素点坐标，坐标值为整数值。<br />
VPOS 和 SV_POSITION 不能同时出现在 vout 中，需要使用 fin 将两者分离。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Screen Position"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Texture"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"white"</span> {}
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0
<span style="color: #bc6ec5;">            #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
            <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata 
            {
                <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
            };

            <span style="color: #4f97d7; font-weight: bold;">struct</span> vout {
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                <span style="color: #ce537a; font-weight: bold;">float4</span> outpos : <span style="color: #a45bad;">SV_POSITION</span>;
            };

            <span style="color: #4f97d7; font-weight: bold;">struct</span> fin 
            {
                <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
                UNITY_VPOS_TYPE screenPos : <span style="color: #a45bad;">VPOS</span>;
            };

<span style="color: #bc6ec5;">            #define</span> vert_out vout
<span style="color: #bc6ec5;">            #define</span> frag_in fin

            vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata i)
            {
                vert_out o;
                o.uv = i.uv;
                o.outpos = UnityObjectToClipPos(i.vertex);
                <span style="color: #4f97d7; font-weight: bold;">return</span> o;
            }

            <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (frag_in i) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">screenPos.xy will contain pixel integer coordinates.</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return i.screenPos.x &lt; _ScreenParams.x/2 ? 0 : 1;</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use them to implement a checkerboard pattern that skips rendering</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4x4 blocks of pixels</span>

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">checker value will be negative for 4x4 blocks of pixels</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in a checkerboard pattern</span>
                i.screenPos.xy = <span style="color: #4f97d7;">floor</span>(i.screenPos.xy * 0.25) * 0.5;
                <span style="color: #ce537a; font-weight: bold;">float</span> checker = -<span style="color: #4f97d7;">frac</span>(i.screenPos.r + i.screenPos.g);

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">clip HLSL instruction stops rendering a pixel if value is negative</span>
                <span style="color: #4f97d7;">clip</span>(checker);

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">for pixels that were kept, read the texture and output it</span>
                <span style="color: #ce537a; font-weight: bold;">fixed4</span> c = <span style="color: #4f97d7;">tex2D</span> (<span style="color: #7590db;">_MainTex</span>, i.uv);
                <span style="color: #4f97d7; font-weight: bold;">return</span> c;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0bf2bc3" class="outline-6">
<h6 id="org0bf2bc3">Face orientation: VFACE</h6>
<div class="outline-text-6" id="text-org0bf2bc3">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Unlit/Face Orientation"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_ColorFront</span> (<span style="color: #2d9574;">"Front Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (1,0.7,0.7,1)
        <span style="color: #7590db;">_ColorBack</span> (<span style="color: #2d9574;">"Back Color"</span>, <span style="color: #4f97d7; font-weight: bold;">Color</span>) = (0.7,1,0.7,1)
    }
    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">turn off backface culling</span>

            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag
<span style="color: #bc6ec5;">            #pragma</span> target 3.0

            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">vert</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>) : <span style="color: #a45bad;">SV_POSITION</span>
            {
                <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
            }

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorFront</span>;
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #7590db;">_ColorBack</span>;

            <span style="color: #ce537a; font-weight: bold;">fixed4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (<span style="color: #ce537a; font-weight: bold;">fixed</span> facing : <span style="color: #a45bad;">VFACE</span>) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">VFACE input positive for frontbaces,</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">negative for backfaces. Output one</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of the two colors depending on that.</span>
                <span style="color: #4f97d7; font-weight: bold;">return</span> facing &gt; 0 ? <span style="color: #7590db;">_ColorFront</span> : <span style="color: #7590db;">_ColorBack</span>;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga87da47" class="outline-6">
<h6 id="orga87da47">参考资料</h6>
<div class="outline-text-6" id="text-orga87da47">
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN</a><br /></li>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">https://docs.unity3d.com/Manual/SL-ShaderSemantics.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc38edea" class="outline-5">
<h5 id="orgc38edea">Unity 定义的变量</h5>
<div class="outline-text-5" id="text-orgc38edea">
<p>
_WorldSpaceLightPos0      世界空间 Light 位置<br />
_LightColor0              Light 颜色<br />
_WorldSpaceCameraPos      世界坐标摄像机位置<br />
_LightTexture0            Light 没有使用 Cookie 时，该变量存储衰减贴图。使用了 Cookie 时，存储 Cookie 贴图。 (Directional Light 没有衰减贴图)<br />
_LightTextureB0           Light 使用了 Cookie 时，该变量存储衰减贴图。 (Directional Light 没有衰减贴图)<br />
</p>

<p>
unity_WorldToShadow       float4x4[4]	用于 spot lights 或 方向光的 4 级级联阴影<br />
</p>

<p>
_LightShadowData          // 参考有道笔记 UnitySourceCode.md<br />
</p>

<p>
_ProjectionParams         <i>/ x=1 or -1  y=near z=far w=1/far<br />
_ScreenParams             /</i> x=widthPixels y=heightPixels z=1.0+1.0/width w=1.0+1.0/height<br />
_ZBufferParams 						<i>/ 用于线性化 ZBuffer 中的值，<br />
                          /</i> x=1-far/near<br />
                          <i>/ y=far/near<br />
                          /</i> z=x/far=(1-far)/(near*far)<br />
                          // w=y/far=(1/near)<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">zc0</span>, <span style="color: #7590db;">zc1</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL would be this:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc0 = (1.0 - m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">zc1 = (1.0 + m_FarClip / m_NearClip) / 2.0;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">D3D is this:</span>
zc0 = 1.0 - m_FarClip / m_NearClip;
zc1 = m_FarClip / m_NearClip;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">now set _ZBufferParams with (zc0, zc1, zc0/m_FarClip, zc1/m_FarClip);</span>
</pre>
</div>

<p>
unity_SpecCube0_ProbePosition   第一个反射探针的位置，如果场景中不存在反射探针，则默认传递环境反射(Lighting / Environment Reflections / Source 下可以设置环境反射)的数据，环境反射。<br />
unity_SpecCube0_BoxMin          第一个反射探针对应的 Box 在世界空间中坐标最小值，反射探针为环境反射时，该值为 (Infinity, Infinity, Infinity, 1)<br />
unity_SpecCube0_BoxMax          第一个反射探针对应的 Box 在世界空间中坐标最大值，反射探针为环境反射时，该值为 (-Infinity, -Infinity, -Infinity, 1)<br />
unity_SpecCube0_BoxMin.w        存储了第一个反射探针和第二个反射探针的插值比例，1 表示全部使用第一个反射探针，0 表示全部使用第二个反射探针.(只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合)<br />
unity_SpecCube0_HDR.r           存储了反射探针的强度，对应反射探针的 Runtime setting/Intensity 和 Lighting/Scene/EnvironmentReflections/IntensityMultiplier(IntensityMultiplier 只是 Intensity 的系数，所以 FrameDebug 中看到的值和该值并不同)<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_08re_default_env_reflection_data.png" alt="01_08re_default_env_reflection_data.png" /><br />
</p>
</div>


<p>
<a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a><br />
</p>
<ul class="org-ul">
<li>_ZBufferParams values? <a href="https://forum.unity.com/threads/_zbufferparams-values.39332/">https://forum.unity.com/threads/_zbufferparams-values.39332/</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org744fcef" class="outline-5">
<h5 id="org744fcef">Unity Shader 定义的宏</h5>
<div class="outline-text-5" id="text-org744fcef">
<p>
UNITY_COMPILER_HLSL                            使用 HLSL 编译时，定义该宏(for D3D or GLCore/GLES3/GLES platforms)<br />
UNITY_COMPILER_HLSL2GLSL                       使用 hlsl2glsl 编译时，定义该宏<br />
UNITY_COMPILER_CG                              使用 NVIDIA 的 Cg<br />
</p>

<p>
<a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a><br />
<a href="https://docs.unity3d.com/Manual/SL-ShadingLanguage.html">https://docs.unity3d.com/Manual/SL-ShadingLanguage.html</a><br />
</p>

<p>
UNITY_ENABLE_REFLECTION_BUFFERS                TODO-How?  延迟渲染模式下，延迟渲染反射球时会设置该变量开启。延迟渲染模式下，默认该变量是开启的，在 Graphics Settings 中将 DeferredReflections 选项选为 NoSupport 即可关闭。<br />
<a href="https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html">https://docs.unity3d.com/ScriptReference/Rendering.BuiltinShaderDefine.html</a><br />
</p>

<p>
UNITY_USE_NATIVE_HDR                           查看 2019 版本的源代码发现相关代码被注释掉了，UNITY_USE_NATIVE_HDR 应该永远都不会被开启<br />
</p>
<ul class="org-ul">
<li>UNITY_USE_NATIVE_HDR <a href="https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6">https://forum.unity.com/threads/feedback-wanted-lightweight-render-pipeline.562291/page-6</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga4a2d30" class="outline-5">
<h5 id="orga4a2d30">Unity Shader Compiler</h5>
<div class="outline-text-5" id="text-orga4a2d30">
<ul class="org-ul">
<li>Windows &amp; Microsoft platforms (DX11, DX12 and Xbox One) all use Microsoft’s HLSL compiler (currently d3dcompiler_47).<br /></li>
<li>OpenGL Core , OpenGL ES 3, OpenGL ES 2.0 and Metal use Microsoft’s HLSL followed by bytecode translation into GLSL or Metal, using HLSLcc.<br /></li>
<li>OpenGL ES 2.0 can use source level translation via hlsl2glslfork and glsl optimizer. This is enabled by adding #pragma prefer_hlsl2glsl gles<br /></li>
<li>Other console platforms use their respective compilers (e.g. PSSL on PS4).<br /></li>
<li>Surface Shaders use Cg 2.2 and MojoShader for code generation analysis step.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org32379c8" class="outline-5">
<h5 id="org32379c8">Unity shader 预编译命令</h5>
</div>
<div id="outline-container-orgf3d8821" class="outline-5">
<h5 id="orgf3d8821">D3D11 汇编命令</h5>
<div class="outline-text-5" id="text-orgf3d8821">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mul result opt1 opt2</td>
<td class="org-left">opt1 乘 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">add result opt1 opt2</td>
<td class="org-left">opt1 加 opt2 保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mad result opt1 opt2 opt3</td>
<td class="org-left">opt1 乘 opt2 再加 opt3 保存结果到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">mov result opt1</td>
<td class="org-left">将 opt1 数据保存到 result</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_sampler s0, mode_default</td>
<td class="org-left">创建贴图采样对象 s0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dcl_resource_texture2d(float,float,float,float) t0</td>
<td class="org-left">创建 2D 贴图资源 t0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">sample result.xyzw, uv.xyxx, t0.xyzw, s0</td>
<td class="org-left">使用 s0 采样器以 uv 为贴图坐标，对贴图资源 t0 进行采样将结果保存到 result 中</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgbaa1cc4" class="outline-4">
<h4 id="orgbaa1cc4">Combining Textures</h4>
<div class="outline-text-4" id="text-orgbaa1cc4">
</div>
<div id="outline-container-orgf384c76" class="outline-5">
<h5 id="orgf384c76">Linear Color Space</h5>
<div class="outline-text-5" id="text-orgf384c76">
</div>
<div id="outline-container-org305567d" class="outline-6">
<h6 id="org305567d">Linear Color Space 原理</h6>
<div class="outline-text-6" id="text-org305567d">
<p>
Gamma space 是指经过 gamma 矫正的颜色。gamma 矫正是对光照亮度的调整。最简单的方式是提升原始值某次幂，如 \(originalValue^{gamma}\) 。<br />
gamma=1 表示没有改变。gamma=2 表示对原始值求平方。<br />
</p>

<p>
这种转换原本是为了适应非线性的 CRT 显示器的。一个附加的好处是这种转换刚好和我们眼睛对不同光强度的敏感程度相一致。人眼对不同的暗的颜色要比不同的亮的颜色更加敏感。所以使用更多位数字存储暗颜色是很有意义的，求幂运算可以实现该需求，它会将比较小的值扩展到一个更大的范围，同时将较大的值压缩到一个小的范围。<br />
</p>

<p>
运用最广泛的图片颜色格式是 sRGB.<br />
</p>
<ul class="org-ul">
<li>Encoding with gamma 1/2.2 即 \(originalValue^{\frac{1}{2.2}} = originalValue^{0.45}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear-to-gamma.png" alt="01_03ct_linear-to-gamma.png" /><br /></li>
<li>Decoding with gamma 2.2 即 \(originalValue^{2.2}\)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma-to-linear.png" alt="01_03ct_gamma-to-linear.png" /><br /></li>
<li>伽马矫正函数图示<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_correct.png" alt="01_03ct_gamma_correct.png" /><br /></li>
</ul>

<p>
横坐标为编码前的颜色值，纵坐标为编码后的颜色值。蓝色的线表示线性编码前后颜色值不变。红色的线表示 Gamma 编码前后颜色值变大。以 0.5 为分界线，Gamma 编码后，[0-0.5] 被扩展到了 [0-0.7297&#x2026;] [0.5-1] 被压缩到了 [0.7297&#x2026; - 1]。Gamma 编码的图片要比 Linear 编码的图片亮度高。<br />
</p>

<p>
下面的 HTML 可用于 GammaToLinear 转换<br />
</p>
<div class="org-src-container">
<pre class="src src-html"><span style="color: #2d9574;">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
    &lt;<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;<span style="font-weight: bold; font-style: italic; text-decoration: underline;">&#39068;&#33394;&#36716;&#25442;</span>&lt;/<span style="color: #bc6ec5; font-weight: bold;">h2</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"originColor"</span>&gt;
            TD &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oR"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oG"</span> value =<span style="color: #2d9574;">"128"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"oB"</span> value =<span style="color: #2d9574;">"64"</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span>&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">form</span> <span style="color: #7590db;">action</span>=<span style="color: #2d9574;">""</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"newColor"</span>&gt;
            Qin &#39068;&#33394;
            R: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nR"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            G: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nG"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
            B: &lt;<span style="color: #bc6ec5; font-weight: bold;">input</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text"</span> <span style="color: #7590db;">id</span>=<span style="color: #2d9574;">"nB"</span> value =<span style="color: #2d9574;">""</span> <span style="color: #7590db;">size</span>=<span style="color: #2d9574;">"4"</span> disabled&gt;
        &lt;/<span style="color: #bc6ec5; font-weight: bold;">form</span>&gt;
        &lt;<span style="color: #bc6ec5; font-weight: bold;">br</span>&gt;

        &lt;<span style="color: #bc6ec5; font-weight: bold;">button</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"button"</span> <span style="color: #7590db;">onclick</span>=<span style="color: #2d9574;">'convertColor()'</span>&gt;&#36716;&#25442;&lt;/<span style="color: #bc6ec5; font-weight: bold;">button</span>&gt;
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">body</span>&gt;

    &lt;<span style="color: #bc6ec5; font-weight: bold;">script</span> <span style="color: #7590db;">type</span>=<span style="color: #2d9574;">"text/javascript"</span>&gt;
     function convertColor()
     {
         var r = document.getElementById("oR").value / 255;
         var g = document.getElementById("oG").value / 255;
         var b = document.getElementById("oB").value / 255;

         //window.alert("test = " + r + b + g);
         document.getElementById("nR").value = Math.round(Math.pow(r, 1/2.2) * 255);
         document.getElementById("nG").value = Math.round(Math.pow(g, 1/2.2) * 255);
         document.getElementById("nB").value = Math.round(Math.pow(b, 1/2.2) * 255);
     }
    &lt;/<span style="color: #bc6ec5; font-weight: bold;">script</span>&gt;

&lt;/<span style="color: #bc6ec5; font-weight: bold;">html</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GammaToLinearSpace(col.rgb);  &#19979;&#38754;&#20195;&#30721;&#26159; GammaToLinearSpace &#30340;&#27719;&#32534;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat1.xyz = u_xlat0.xyz * u_xlat1.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LinearToGammaSpace(col.rgb); &#19979;&#38754;&#20195;&#30721;&#26159; LinearToGammaSpace &#30340;&#27719;&#32534;&#20195;&#30721;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span>()
{
    u_xlat0 = <span style="color: #4f97d7; font-weight: bold;">texture2D</span>(<span style="color: #7590db;">_MainTex</span>, vs_TEXCOORD0.xy);
    u_xlat16_1.xyz = <span style="color: #4f97d7;">max</span>(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat16_2.xyz = <span style="color: #4f97d7;">log2</span>(u_xlat16_1.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat16_2.xyz = <span style="color: #4f97d7;">exp2</span>(u_xlat16_2.xyz);
    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = <span style="color: #4f97d7;">max</span>(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));
    <span style="color: #a45bad;">SV_Target0</span> = u_xlat0;
    <span style="color: #4f97d7; font-weight: bold;">return</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#26159; &#22270;&#29255;Gamma&#21644;Linear&#36716;&#25442;&#24037;&#20855;</span>
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">System.Collections</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">System.Collections.Generic</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">UnityEngine</span>;
<span style="color: #4f97d7; font-weight: bold;">using</span> <span style="color: #a45bad;">UnityEditor</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">LinearGammaConvert</span> : <span style="color: #ce537a; font-weight: bold;">MonoBehaviour</span>
{
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">_assetPathList</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt;();
    [<span style="color: #ce537a; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageLinearToGamma"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> LinearToGamma()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        GetSelectionPathList(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            ConvertBetweenLinearGamma(path, <span style="color: #a45bad;">true</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }

    [<span style="color: #ce537a; font-weight: bold;">MenuItem</span>(<span style="color: #2d9574;">"Assets/Tools/ImageGammaToLinear"</span>)]
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> GammaToLinear()
    {
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        GetSelectionPathList(_assetPathList);
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> <span style="color: #4f97d7; font-weight: bold;">in</span> _assetPathList)
        {
            ConvertBetweenLinearGamma(path, <span style="color: #a45bad;">false</span>);
        }
        _assetPathList.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">GetSelectionPathList</span>(<span style="color: #ce537a; font-weight: bold;">List</span>&lt;<span style="color: #ce537a; font-weight: bold;">string</span>&gt; <span style="color: #7590db;">pathList</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(Selection.objects!=<span style="color: #a45bad;">null</span>)
        {
            <span style="color: #4f97d7; font-weight: bold;">foreach</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">obj</span> <span style="color: #4f97d7; font-weight: bold;">in</span> Selection.objects)
            {
                <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">path</span> = AssetDatabase.<span style="color: #bc6ec5; font-weight: bold;">GetAssetPath</span>(obj);
                <span style="color: #4f97d7; font-weight: bold;">if</span>(!<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(path))
                {
                    pathList.<span style="color: #bc6ec5; font-weight: bold;">Add</span>(path);
                }
            }
        }
    }
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ConvertBetweenLinearGamma</span>(<span style="color: #ce537a; font-weight: bold;">string</span> <span style="color: #7590db;">imgPath</span>, <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isToGamma</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #ce537a; font-weight: bold;">string</span>.<span style="color: #bc6ec5; font-weight: bold;">IsNullOrEmpty</span>(imgPath)) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">textureImportor</span> = AssetImporter.<span style="color: #bc6ec5; font-weight: bold;">GetAtPath</span>(imgPath) <span style="color: #4f97d7; font-weight: bold;">as</span> <span style="color: #ce537a; font-weight: bold;">TextureImporter</span>;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (textureImportor == <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span>;

        textureImportor.isReadable = <span style="color: #a45bad;">true</span>;
        textureImportor.sRGBTexture = !isToGamma;
        textureImportor.textureCompression = TextureImporterCompression.Uncompressed;
        textureImportor.<span style="color: #bc6ec5; font-weight: bold;">SaveAndReimport</span>();

        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">texture</span> = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(imgPath);
        <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">gammaValue</span> = isToGamma ? 0.4545f : 2.2f;
        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">pixels</span> = texture.<span style="color: #bc6ec5; font-weight: bold;">GetPixels</span>();
        <span style="color: #4f97d7; font-weight: bold;">for</span>(<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">i</span>=0; i&lt;pixels.Length; i++)
        {

            pixels[i].r = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].r, gammaValue);
            pixels[i].g = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].g, gammaValue);
            pixels[i].b = Mathf.<span style="color: #bc6ec5; font-weight: bold;">Pow</span>(pixels[i].b, gammaValue);
        }
        texture.<span style="color: #bc6ec5; font-weight: bold;">SetPixels</span>(pixels);
        texture.<span style="color: #bc6ec5; font-weight: bold;">Apply</span>();
        System.IO.File.<span style="color: #bc6ec5; font-weight: bold;">WriteAllBytes</span>(imgPath, texture.<span style="color: #bc6ec5; font-weight: bold;">EncodeToTGA</span>());
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfecc5e9" class="outline-6">
<h6 id="orgfecc5e9">DetailTex 叠加到 MainTex 上为什么需要乘二？</h6>
<div class="outline-text-6" id="text-orgfecc5e9">
<p>
MainTex 颜色范围为[0-1] DetailTex 颜色范围也为[0-1], 如果将 DetailTex 制作为灰度图并且颜色值取 0.5，那么 MainTex*DetailTex*2 可以保证图片亮度不会变化。DetailTex 颜色值小于 0.5 的地方就会减低颜色亮度，大于 0.5 的地方就会提高颜色亮度。<br />
但是，当 Unity 引擎切换到线性空间，乘二是不正确的。DetailTex 转化为线性空间时，0.5 的 DetailTex 颜色值会变为 \(0.5^{2.2}=0.2176\) ,乘二后为 0.4352, 所以颜色亮度会减低。最好的解决方案是当 Unity 引擎切换到线性空间时，应该乘 \(frac{1}{0.5^{2.2}}=frac{1}{0.2176}=4.5956\)<br />
Unity 中 unity_ColorSpaceDouble 用来处理不同的颜色空间乘不同的值。<br />
</p>
</div>
</div>
<div id="outline-container-orgc8945da" class="outline-6">
<h6 id="orgc8945da">SetVector SetColor</h6>
<div class="outline-text-6" id="text-orgc8945da">
<p>
GammaSpace 下，SetVector SetColor 效果没有差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_gamma_SetValue.png" alt="01_03ct_gamma_SetValue.png" /><br />
LinearSpace 下，SetVector SetColor 效果会有明显差别。下图为设置颜色值为(0.5, 0, 0)<br />
<img src="./UnityCatLikeCoding/01_03ct_linear_SetValue.png" alt="01_03ct_linear_SetValue.png" /><br />
</p>

<p>
编辑器中设置的值和 Shader Property List 中设置的值是相同的。<br />
线性空间下，通过 SetColor 传入的值被认为是经过 Gamma=1/2.2=0.4545 编码的值，Unity 引擎会对该值进行 Gamma=2.2 的编码(对 Gamma=1/2.2 进行解码)，从而将 Gamma 空间的值转换为线性空间。所以，SetVector(0.5^2.2, 0, 0, 0) 和 SetColor(0.5, 0, 0, 0)的效果是等价的。<br />
</p>

<ul class="org-ul">
<li>官网文档说明 <a href="https://docs.unity3d.com/ScriptReference/Material.SetVector.html">https://docs.unity3d.com/ScriptReference/Material.SetVector.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc993876" class="outline-6">
<h6 id="orgc993876">参考资料</h6>
<div class="outline-text-6" id="text-orgc993876">
<ul class="org-ul">
<li>Gamma 空间是什么，为什么我们需要它 <a href="https://blog.csdn.net/qq_18229381/article/details/78053018">https://blog.csdn.net/qq_18229381/article/details/78053018</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org41de4cf" class="outline-4">
<h4 id="org41de4cf">The First Light</h4>
<div class="outline-text-4" id="text-org41de4cf">
</div>
<div id="outline-container-org1bfc9ac" class="outline-5">
<h5 id="org1bfc9ac">normal 从物体空间到世界空间的变换</h5>
<div class="outline-text-5" id="text-org1bfc9ac">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">obj to world</span>
i.normal = <span style="color: #4f97d7;">mul</span>(<span style="color: #4f97d7;">transpose</span>((<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject), v.normal);

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">float3</span> UnityObjectToWorldNormal( <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #ce537a; font-weight: bold;">float3</span> norm )
{
<span style="color: #bc6ec5;">#ifdef</span> UNITY_ASSUME_UNIFORM_SCALING
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToWorldDir</span>(norm);
<span style="color: #bc6ec5;">#else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25913;&#21464;&#24038;&#20056; &#21491;&#20056;&#39034;&#24207; &#31561;&#20215;&#20110; &#30697;&#38453;&#36716;&#32622;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mul(IT_M, norm) =&gt; mul(norm, I_M) =&gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)}</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">normalize</span>(<span style="color: #4f97d7;">mul</span>(norm, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject));
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org05e29f1" class="outline-5">
<h5 id="org05e29f1">Tags LightMode=ForwardBase</h5>
<div class="outline-text-5" id="text-org05e29f1">
<p>
定义该 Tags 才可以在 shader 中访问场景中主方向光的信息。<br />
</p>
</div>
</div>

<div id="outline-container-org1b664a6" class="outline-5">
<h5 id="org1b664a6">BlinnPhong</h5>
<div class="outline-text-5" id="text-org1b664a6">
<p>
视角不逆光时的显示效果如下：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone.png" alt="01_04fl_blinnphone.png" /><br />
</p>

<p>
视角逆光时会有显示错误。错误如下图：<br />
<img src="./UnityCatLikeCoding/01_04fl_blinnphone_error.png" alt="01_04fl_blinnphone_error.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgba1b054" class="outline-5">
<h5 id="orgba1b054">Energy Conservation</h5>
<div class="outline-text-5" id="text-orgba1b054">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Unity &#23454;&#29616;&#30340;&#33021;&#37327;&#23432;&#24658; UnityStandardUtils.cginc</span>

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1696503" class="outline-5">
<h5 id="org1696503">Specular / Metallic Workflow</h5>
<div class="outline-text-5" id="text-org1696503">
</div>
<div id="outline-container-org5da876b" class="outline-6">
<h6 id="org5da876b">Specular Workflow</h6>
<div class="outline-text-6" id="text-org5da876b">
<p>
Specular Workflow 中将 Specular Color 的强度提高来实现金属材质。将 Specular Color 的强度减弱来实现非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#40664;&#35748;&#26159; Specular Workflow</span>
<span style="color: #bc6ec5;">#ifndef</span> UNITY_SETUP_BRDF_INPUT
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT SpecularSetup
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData SpecularSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> specGloss = SpecularGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor = specGloss.rgb;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = specGloss.a;

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = EnergyConservationBetweenDiffuseAndSpecular (Albedo(i_tex), specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Diffuse/Spec Energy conservation</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> EnergyConservationBetweenDiffuseAndSpecular (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    oneMinusReflectivity = 1 - SpecularStrength(specColor);
<span style="color: #bc6ec5;">    #if</span> !UNITY_CONSERVE_ENERGY
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
<span style="color: #bc6ec5;">    #elif</span> UNITY_CONSERVE_ENERGY_MONOCHROME
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
<span style="color: #bc6ec5;">    #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524; specColor &#19981;&#26159;&#28784;&#24230;&#22270;&#65292;diffuse &#39068;&#33394;&#20250;&#26174;&#31034;&#24322;&#24120;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * (<span style="color: #ce537a; font-weight: bold;">half3</span>(1,1,1) - specColor);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">SpecularStrength</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> specular)
{
<span style="color: #bc6ec5;">    #if</span> (SHADER_TARGET &lt; 30)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: instruction count limitation</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">SM2.0: simplified SpecularStrength</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> specular.r; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Red channel - because most metals are either monocrhome or with redish/yellowish tint</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">max</span> (<span style="color: #4f97d7;">max</span> (specular.r, specular.g), specular.b);
<span style="color: #bc6ec5;">    #endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge2552ca" class="outline-6">
<h6 id="orge2552ca">Metallic Workflow</h6>
<div class="outline-text-6" id="text-orge2552ca">
<p>
Metallic Workflow 中通过金属度来实现金属和非金属材质。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#33258;&#24049;&#30340; shader &#20013;&#23450;&#20041; UNITY_SETUP_BRDF_INPUT = MetallicSetup &#26469;&#25351;&#23450;&#20351;&#29992; Metallic &#27969;&#31243;</span>
<span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_SETUP_BRDF_INPUT MetallicSetup
<span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> FragmentCommonData MetallicSetup (<span style="color: #ce537a; font-weight: bold;">float4</span> i_tex)
{
    <span style="color: #ce537a; font-weight: bold;">half2</span> metallicGloss = MetallicGloss(i_tex.xy);
    <span style="color: #ce537a; font-weight: bold;">half</span> metallic = metallicGloss.x;
    <span style="color: #ce537a; font-weight: bold;">half</span> smoothness = metallicGloss.y; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this is 1 minus the square root of real roughness m.</span>

    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity;
    <span style="color: #ce537a; font-weight: bold;">half3</span> specColor;
    <span style="color: #ce537a; font-weight: bold;">half3</span> diffColor = DiffuseAndSpecularFromMetallic (Albedo(i_tex), metallic, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> specColor, <span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">out*/</span> oneMinusReflectivity);

    FragmentCommonData o = (FragmentCommonData)0;
    o.diffColor = diffColor;
    o.specColor = specColor;
    o.oneMinusReflectivity = oneMinusReflectivity;
    o.smoothness = smoothness;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DiffuseAndSpecularFromMetallic (<span style="color: #ce537a; font-weight: bold;">half3</span> albedo, <span style="color: #ce537a; font-weight: bold;">half</span> metallic, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half3</span> specColor, <span style="color: #4f97d7; font-weight: bold;">out</span> <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusReflectivity)
{
    specColor = <span style="color: #4f97d7;">lerp</span> (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);
    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo * oneMinusReflectivity;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24120;&#37327;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">#ifdef</span> UNITY_COLORSPACE_GAMMA
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.5, 0.5, 0.5, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(2.0, 2.0, 2.0, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.22, 0.707, 0.071, 0.0) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Legacy: alpha is set to 0.0 to specify gamma mode</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear values</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceGrey <span style="color: #ce537a; font-weight: bold;">fixed4</span>(0.214041144, 0.214041144, 0.214041144, 0.5)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDouble <span style="color: #ce537a; font-weight: bold;">fixed4</span>(4.59479380, 4.59479380, 4.59479380, 2.0)
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceDielectricSpec <span style="color: #ce537a; font-weight: bold;">half4</span>(0.04, 0.04, 0.04, 1.0 - 0.04) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">standard dielectric reflectivity coef at incident angle (= 4%)</span>
<span style="color: #bc6ec5;">  #define</span> unity_ColorSpaceLuminance <span style="color: #ce537a; font-weight: bold;">half4</span>(0.0396819152, 0.458021790, 0.00609653955, 1.0) <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Legacy: alpha is set to 1.0 to specify linear mode</span>
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> OneMinusReflectivityFromMetallic(<span style="color: #ce537a; font-weight: bold;">half</span> metallic)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">We'll need oneMinusReflectivity, so</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">store (1-dielectricSpec) in unity_ColorSpaceDielectricSpec.a, then</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//                  </span><span style="color: #2aa1ae; background-color: #292e34;">= alpha - metallic * alpha</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> oneMinusDielectricSpec = unity_ColorSpaceDielectricSpec.a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org0441654" class="outline-4">
<h4 id="org0441654">Multi Lights</h4>
<div class="outline-text-4" id="text-org0441654">
</div>
<div id="outline-container-org87e3e84" class="outline-5">
<h5 id="org87e3e84">Light Coord</h5>
<div class="outline-text-5" id="text-org87e3e84">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord4 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex));
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    ( (a.<span style="color: #7590db;">_LightCoord</span>.z &gt; 0) * UnitySpotCookie(a.<span style="color: #7590db;">_LightCoord</span>) * UnitySpotAttenuate(a.<span style="color: #7590db;">_LightCoord</span>.xyz) * SHADOW_ATTENUATION(a) )
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx)
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a)
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a)
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xyz;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(a.<span style="color: #7590db;">_LightCoord</span>,a.<span style="color: #7590db;">_LightCoord</span>).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
<span style="color: #bc6ec5;">#   define</span> DECLARE_LIGHT_COORDS(idx) unityShadowCoord2 <span style="color: #7590db;">_LightCoord</span> : TEXCOORD##idx;
<span style="color: #bc6ec5;">#   define</span> COMPUTE_LIGHT_COORDS(a) a.<span style="color: #7590db;">_LightCoord</span> = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex)).xy;
<span style="color: #bc6ec5;">#   define</span> LIGHT_ATTENUATION(a)    (<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, a.<span style="color: #7590db;">_LightCoord</span>).w * SHADOW_ATTENUATION(a))
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#define</span> UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2)
<span style="color: #bc6ec5;">#define</span> LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2)
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vertex shader &#20013;&#65292;&#35745;&#31639;_LightCoord</span>
<span style="color: #bc6ec5;">#define</span> UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord)
<span style="color: #bc6ec5;">#define</span> TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8fb7075" class="outline-5">
<h5 id="org8fb7075">Light Attenuation</h5>
<div class="outline-text-5" id="text-org8fb7075">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#ifdef</span> POINT
<span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
    unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz; \
    <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25353;&#29031;&#36317;&#31163;&#30340;&#24179;&#26041;&#34928;&#20943;</span>
    <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> SPOT
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
    <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotCookie(unityShadowCoord4 LightCoord)
    {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679;&#26102;&#20174;&#40784;&#27425;&#22352;&#26631;&#31995;&#36716;&#25442;&#21040;&#27431;&#25289;&#22352;&#26631;&#31995;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20559;&#31227; 0.5 &#36825;&#26679;&#28783;&#20809;&#22352;&#26631;&#31995;&#21407;&#28857;&#23601;&#21644;&#22270;&#29255;&#20013;&#24515;&#28857;&#23545;&#24212;&#20102;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, LightCoord.xy / LightCoord.w + 0.5).w;
    }
    <span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">fixed</span> UnitySpotAttenuate(unityShadowCoord3 LightCoord)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(LightCoord, LightCoord).xx).r;
    }
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1))
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord4 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = (lightCoord.z &gt; 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz) * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = UNITY_SHADOW_ATTENUATION(input, worldPos);
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> POINT_COOKIE
    <span style="color: #ce537a; font-weight: bold;">samplerCUBE_float</span> <span style="color: #7590db;">_LightTexture0</span>;
    unityShadowCoord4x4 unity_WorldToLight;
    <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTextureB0</span>;
<span style="color: #bc6ec5;">    #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xyz
<span style="color: #bc6ec5;">    #else</span>
<span style="color: #bc6ec5;">        #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord3 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
        DECLARE_LIGHT_COORD(input, worldPos); \
        <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;RenderDoc &#25130;&#21462;_LightTextureB0 &#23545;&#24212;&#30340;&#22270;&#29255;&#36164;&#28304;&#65292;&#21457;&#29616;&#20854;&#20026;1024x1&#30340;&#20174;1&#21040;0&#34928;&#20943;&#30340;&#22270;&#29255;</span>
        <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTextureB0</span>, <span style="color: #4f97d7;">dot</span>(lightCoord, lightCoord).rr).r * <span style="color: #4f97d7;">texCUBE</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#ifdef</span> DIRECTIONAL_COOKIE
  <span style="color: #ce537a; font-weight: bold;">sampler2D_float</span> <span style="color: #7590db;">_LightTexture0</span>;
  unityShadowCoord4x4 unity_WorldToLight;
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
<span style="color: #bc6ec5;">      #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, unityShadowCoord4(worldPos, 1)).xy
<span style="color: #bc6ec5;">  #else</span>
<span style="color: #bc6ec5;">      #define</span> DECLARE_LIGHT_COORD(input, worldPos) unityShadowCoord2 lightCoord = input.<span style="color: #7590db;">_LightCoord</span>
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_LIGHT_ATTENUATION(destName, input, worldPos) \
      DECLARE_LIGHT_COORD(input, worldPos); \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> shadow = UNITY_SHADOW_ATTENUATION(input, worldPos); \
      <span style="color: #ce537a; font-weight: bold;">fixed</span> destName = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_LightTexture0</span>, lightCoord).w * shadow;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
<div id="outline-container-org10a566a" class="outline-6">
<h6 id="org10a566a">Point Light</h6>
<div class="outline-text-6" id="text-org10a566a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> lightVector = <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz - i.worldPos;
light.dir = <span style="color: #4f97d7;">normalize</span>(lightVector);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20998;&#27597;&#20013;&#21152; 1 &#26159;&#20026;&#20102;&#36991;&#20813;&#29289;&#20307;&#21040;&#20809;&#28304;&#36317;&#31163;&#23567;&#20110; 1 &#26102;&#65292;&#20809;&#29031;&#24378;&#24230;&#34987;&#25918;&#22823;</span>
<span style="color: #ce537a; font-weight: bold;">half</span> attenuation = 1 / (1 + <span style="color: #4f97d7;">dot</span>(lightVector, lightVector));
light.color = <span style="color: #7590db;">_LightColor0</span>.rgb * attenuation;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3d65484" class="outline-5">
<h5 id="org3d65484">Mixing Lights</h5>
<div class="outline-text-5" id="text-org3d65484">
<p>
通过增加 shader 变体来实现对混合灯光的支持。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5fda50" class="outline-5">
<h5 id="orgd5fda50">Cookies</h5>
<div class="outline-text-5" id="text-orgd5fda50">
<p>
Spot Light 默认支持 Cookie，Spot Light 的形状是通过 Cookie 来实现。SpotLight 的 Cookie 贴图的 Wrap 模式采用 Clamp。<br />
Direcional 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图的 Wrap 模式采用 Repeat。<br />
Point 默认不支持 Cookie，需要通过 shader 变体开启支持。其 Cookie 贴图是 Cube 贴图，Wrap 模式采用 Clamp。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#31561;&#20215;&#20110;  #pragma multi_compile_fwdadd</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile DIRECTIONAL POINT DIRECTIONAL_COOKIE POINT_COOKIE
</pre>
</div>

<ul class="org-ul">
<li>multi_compile_fwdbase 变体 <a href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org162035f" class="outline-5">
<h5 id="org162035f">Vertex Lights</h5>
<div class="outline-text-5" id="text-org162035f">
<p>
灯光数量增加后，drawcall 数量会成倍增加。Unity 可以设置逐像素光照的数量。如果将超出数量限制的光照直接不进行计算，会导致明显的显示错误，可以采用更廉价的顶点光照来代替像素光照。<br />
Unity 在 Base Pass 中实现顶点光照。引擎会寻找包含 VERTEXLIGHT_ON 关键字的 Base Pass 着色器。<br />
顶点光照只支持 点光源，方向光和聚光灯都能在顶点着色器中计算。<br />
在 Light 的 RenderMode 属性中，可以设置重要类型，Important 类型的光照总是逐像素光照，Not Important 类型的光照永远不会被当作逐像素光照，Auto 类型的光照其重要性由引擎来决定。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UnityCG.cginc</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35813;&#20989;&#25968;&#36820;&#22238;&#20102;4&#20010;&#28857;&#20809;&#28304;&#23545;&#20110;&#24403;&#21069;&#39030;&#28857;&#30340;&#32508;&#21512;&#20809;&#29031;&#39068;&#33394;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#39030;&#28857;&#20013;&#35745;&#31639; 4 &#20010;&#28857;&#20809;&#28304;&#20809;&#29031;&#65292;&#24403;&#20809;&#28304;&#25968;&#30446;&#19981;&#36275; 4 &#20010;&#26102;&#65292;&#35745;&#31639;&#28040;&#32791;&#20381;&#28982;&#26159; 4 &#20010;&#20809;&#29031;&#30340;&#35745;&#31639;&#37327;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way.</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">Shade4PointLights</span> (
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosX, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosY, <span style="color: #ce537a; font-weight: bold;">float4</span> lightPosZ,
    <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor0, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor1, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor2, <span style="color: #ce537a; font-weight: bold;">float3</span> lightColor3,
    <span style="color: #ce537a; font-weight: bold;">float4</span> lightAttenSq,
    <span style="color: #ce537a; font-weight: bold;">float3</span> pos, <span style="color: #ce537a; font-weight: bold;">float3</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">to light vectors</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightX = lightPosX - pos.x;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightY = lightPosY - pos.y;
    <span style="color: #ce537a; font-weight: bold;">float4</span> toLightZ = lightPosZ - pos.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">squared lengths</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> lengthSq = 0;
    lengthSq += toLightX * toLightX;
    lengthSq += toLightY * toLightY;
    lengthSq += toLightZ * toLightZ;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">don't produce NaNs if some vertex position overlaps with the light</span>
    lengthSq = <span style="color: #4f97d7;">max</span>(lengthSq, 0.000001);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> ndotl = 0;
    ndotl += toLightX * normal.x;
    ndotl += toLightY * normal.y;
    ndotl += toLightZ * normal.z;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">correct NdotL</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> corr = <span style="color: #4f97d7;">rsqrt</span>(lengthSq);
    ndotl = <span style="color: #4f97d7;">max</span> (<span style="color: #ce537a; font-weight: bold;">float4</span>(0,0,0,0), ndotl * corr);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">attenuation lightAttenSq &#29992;&#20110;&#25913;&#36827;&#39030;&#28857;&#20809;&#29031;&#30340;&#25928;&#26524;</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
    <span style="color: #ce537a; font-weight: bold;">float4</span> diff = ndotl * atten;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">final color</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> col = 0;
    col += lightColor0 * diff.x;
    col += lightColor1 * diff.y;
    col += lightColor2 * diff.z;
    col += lightColor3 * diff.w;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org56bdd8e" class="outline-5">
<h5 id="org56bdd8e">Spherical Harmonics</h5>
<div class="outline-text-5" id="text-org56bdd8e">
</div>
<div id="outline-container-org105801c" class="outline-6">
<h6 id="org105801c">相关数学概念</h6>
<div class="outline-text-6" id="text-org105801c">
<ul class="org-ul">
<li>球谐函数 是拉普拉斯方程的球坐标系形式解的角度部分。拉普拉斯方程在球坐标系中的表达式分离变量之后，角度部分的偏微分方程称为球函数方程。<br /></li>
<li>球坐标系 球坐标系是三维坐标系的一种，用以确定三维空间中点、线、面以及体的位置，它以坐标原点为参考点，由方位角、仰角和距离构成。球坐标系在地理学、天文学中都有着广泛应用。<br /></li>
<li>拉普拉斯方程 拉普拉斯方程为二阶偏微分方程。<br /></li>
<li>勒让德多项式<br /></li>
<li>偏微分方程 包含未知函数的偏导数(或偏微分)的方程。方程中所出现未知函数偏导数的最高阶数，称为该方程的阶。在数学、物理及工程技术中应用最广泛的，是二阶偏微分方程，习惯上把这些方程称为数学物理方程。<br /></li>
<li>偏导数 在数学中，一个多变量的函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。<br /></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orge89dfc7"></a>参考资料<br />
<div class="outline-text-7" id="text-orge89dfc7">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0">https://baike.baidu.com/item/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB">https://baike.baidu.com/item/%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB</a><br /></li>
<li><a href="https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F">https://baike.baidu.com/item/Legendre%E5%A4%9A%E9%A1%B9%E5%BC%8F</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">https://baike.baidu.com/item/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B</a><br /></li>
<li><a href="https://baike.baidu.com/item/%E5%81%8F%E5%AF%BC%E6%95%B0">https://baike.baidu.com/item/%E5%81%8F%E5%AF%BC%E6%95%B0</a><br /></li>
<li>球谐函数是什么？<a href="https://www.zhihu.com/question/26405495">https://www.zhihu.com/question/26405495</a><br /></li>
<li>Unity 渲染教程（五）：多个光源 <a href="http://gad.qq.com/program/translateview/7173934">http://gad.qq.com/program/translateview/7173934</a><br /></li>
<li>UnityShader——球谐光照 <a href="https://blog.csdn.net/NotMz/article/details/78339913">https://blog.csdn.net/NotMz/article/details/78339913</a><br /></li>
<li>球谐光照（spherical harmonic lighting）解析 <a href="https://gameinstitute.qq.com/community/detail/123183">https://gameinstitute.qq.com/community/detail/123183</a>  (该篇文章讲解通俗易懂，有道笔记中做了备份)<br /></li>
<li>球谐光照 (一)从拉普拉斯方程到球谐函数 <a href="https://zhuanlan.zhihu.com/p/66989673">https://zhuanlan.zhihu.com/p/66989673</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2f03b5f" class="outline-6">
<h6 id="org2f03b5f">原理概述</h6>
<div class="outline-text-6" id="text-org2f03b5f">
<p>
球谐函数背后的思想是你可以只用一个连续函数来描述所有入射光在某个点的效果，这个函数定义在球的表面。<br />
通常来说，这个函数是用球面坐标表示的。但是也可以使用 3D 坐标，这样我们就可以使用物体的 normal 向量对函数进行采样了。<br />
为了创建这样的函数，你必须在所有方向上对光照强度进行采样，然后将结果转换为单个连续的函数。为了达到完美模拟，你必须为表面的每个点做这样的工作。这当然是无法做到的，所以我们只能做到近似效果。<br />
</p>

<p>
首先，我们只从对象本地原点的角度定义函数。光照条件在随物体表面变化不大时效果还是可以的。小物体，或者光照比较弱或光照离物体很远时满足这种情况。幸运的是，这恰好是那些不值得逐像素计算的光照或者顶点光照。<br />
其次，我们必须近似函数自身。你可以将任何连续的函数分解为多个不同频率的函数。这些被称为波段。对于任意一个函数，你可能需要无数个波段来模拟。<br />
</p>
</div>
</div>
<div id="outline-container-org3ed044d" class="outline-6">
<h6 id="org3ed044d">Spherical Harmonics Bands</h6>
<div class="outline-text-6" id="text-org3ed044d">
<p>
第一个基带：使用一个常量颜色值是最简单近似灯光的方式。光照在各个方向上都是相同的。使用单个子函数表示，这个子函数为一个常量值。<br />
第二个基带：第二个基带引入了线性方向光，对于每一个轴向，其描述了最多的光照来自哪儿。使用三个函数表示，每个函数包含一个我们法线的坐标值，并乘上一个常量。<br />
第三个基带：第三个基带更加复杂，它有 5 个函数组成。这些函数都是二次方的，他们包含了两个法线坐标的乘积。<br />
</p>

<p>
下图列出了各个基带的子函数，每一项都需要再乘上 \(\frac{1}{2\sqrt{\pi}}\)<br />
<img src="./UnityCatLikeCoding/01_05ml_sh_param.png" alt="01_05ml_sh_param.png" /><br />
</p>

<p>
因此我们可以使用 9 个因子来近似表示任何一种光照情况，考虑到颜色有 RGB 三个分量，一共需要使用 3*9=27 个因子。<br />
</p>

<p>
下图为 unity 中传递给 shader 的球谐数据:<br />
</p>
<ul class="org-ul">
<li>unity_SHAr.rgba 存储了光照 r 分量的第一个基带和第二个基带的参数因子，unity_SHBr.rgba + unitySHC.r 存储了光照 r 分量的第三个基带的参数因子<br /></li>
<li>unity_SHAg.rgba 存储了光照 g 分量的第一个基带和第二个基带的参数因子，unity_SHBg.rgba + unitySHC.g 存储了光照 g 分量的第三个基带的参数因子<br /></li>
<li>unity_SHAb.rgba 存储了光照 b 分量的第一个基带和第二个基带的参数因子，unity_SHBb.rgba + unitySHC.b 存储了光照 b 分量的第三个基带的参数因子<br /></li>
</ul>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_05ml_unity_sh_param.png" alt="01_05ml_unity_sh_param.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcb919f5" class="outline-6">
<h6 id="orgcb919f5">ShadeSH9</h6>
<div class="outline-text-6" id="text-orgcb919f5">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL0L1</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear (L1) + constant (L0) polynomial terms</span>
    x.r = <span style="color: #4f97d7;">dot</span>(unity_SHAr,normal);
    x.g = <span style="color: #4f97d7;">dot</span>(unity_SHAg,normal);
    x.b = <span style="color: #4f97d7;">dot</span>(unity_SHAb,normal);

    <span style="color: #4f97d7; font-weight: bold;">return</span> x;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">SHEvalLinearL2</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> x1, x2;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4 of the quadratic (L2) polynomials</span>
    <span style="color: #ce537a; font-weight: bold;">half4</span> vB = normal.xyzz * normal.yzzx;
    x1.r = <span style="color: #4f97d7;">dot</span>(unity_SHBr,vB);
    x1.g = <span style="color: #4f97d7;">dot</span>(unity_SHBg,vB);
    x1.b = <span style="color: #4f97d7;">dot</span>(unity_SHBb,vB);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Final (5th) quadratic (L2) polynomial</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> vC = normal.x*normal.x - normal.y*normal.y;
    x2 = unity_SHC.rgb * vC;

    <span style="color: #4f97d7; font-weight: bold;">return</span> x1 + x2;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal should be normalized, w=1.0</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">output in active color space</span>
<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSH9</span> (<span style="color: #ce537a; font-weight: bold;">half4</span> normal)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Linear + constant polynomial terms</span>
    <span style="color: #ce537a; font-weight: bold;">half3</span> res = SHEvalLinearL0L1 (normal);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Quadratic polynomials</span>
    res += SHEvalLinearL2 (normal);

<span style="color: #bc6ec5;">#   ifdef</span> UNITY_COLORSPACE_GAMMA
        res = LinearToGammaSpace (res);
<span style="color: #bc6ec5;">#   endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> res;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdb56ec7" class="outline-6">
<h6 id="orgdb56ec7">环境光和 LightProbe</h6>
<div class="outline-text-6" id="text-orgdb56ec7">
<p>
环境光和 LightProbe 都使用了球谐光照。在 Unity 中叠加到了间接光照的 diffuse 中。<br />
环境光对应一组球谐系数。每个 LightProbe 也对应存储一组球谐系数。全局照明系统会烘培环境光探针，即使用球谐参数保存环境光参数，但是当几何体使用了光照探针和 Lightmaps 时，并不会应用环境光探针，因为环境光影响在光照探针和 Lightmaps 中已经存在了。只有当不存在光照探针和 Lightmap 时，才会使用环境光探针。<br />
</p>

<ul class="org-ul">
<li><a href="https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html">https://docs.unity3d.com/ScriptReference/RenderSettings-ambientProbe.html</a><br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Should SH (light probe / ambient) calculations be performed?</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#24320;&#21551;&#26102;&#65292;&#19981;&#25191;&#34892;SH&#35745;&#31639;&#12290;When both static and dynamic lightmaps are available, no SH evaluation is performed </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#38745;&#24577;&#21644;&#21160;&#24577;lightmaps&#20851;&#38381;&#26102;&#65292;&#19968;&#23450;&#25191;&#34892;SH&#35745;&#31639;&#12290; When static and dynamic lightmaps are not available, SH evaluation is always performed </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- &#23545;&#20110;&#20302;&#32423;LOD&#65292;&#38745;&#24577;lightmap&#21644;LightProbe&#23454;&#26102;&#20840;&#23616;&#29031;&#26126;&#21487;&#20197;&#21512;&#24182;&#22312;&#19968;&#36215;&#12290; For low level LODs, static lightmap and real-time GI from light probes can be combined together </span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">- forwardadd,shdowcaster&#31561;Pass&#19981;&#38656;&#35201;&#25191;&#34892;SH&#35745;&#31639;&#12290;Passes that don't do ambient (additive, shadowcaster etc.) should not do SH either.</span>
<span style="color: #bc6ec5;">#define</span> UNITY_SHOULD_SAMPLE_SH (defined(LIGHTPROBE_SH) &amp;&amp; !defined(UNITY_PASS_FORWARDADD) &amp;&amp; !defined(UNITY_PASS_PREPASSBASE) &amp;&amp; !defined(UNITY_PASS_SHADOWCASTER) &amp;&amp; !defined(UNITY_PASS_META))

<span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">ShadeSHPerPixel</span> (<span style="color: #ce537a; font-weight: bold;">half3</span> normal, <span style="color: #ce537a; font-weight: bold;">half3</span> ambient, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos)
{
    <span style="color: #ce537a; font-weight: bold;">half3</span> ambient_contrib = 0.0;

<span style="color: #bc6ec5;">    #if</span> UNITY_SAMPLE_FULL_SH_PER_PIXEL
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Completely per-pixel</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

            ambient_contrib += SHEvalLinearL2(<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));

            ambient += <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient_contrib);

<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace(ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #elif</span> (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Completely per-vertex</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">nothing to do here. Gamma conversion on ambient from SH takes place in the vertex shader, see ShadeSHPerVertex.</span>
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">L2 per-vertex, L0..L1 &amp; gamma-correction per-pixel</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Ambient in this case is expected to be always Linear, see ShadeSHPerVertex()</span>
<span style="color: #bc6ec5;">        #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
            <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1.0)
                ambient_contrib = SHEvalLinearL0L1_SampleProbeVolume (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0), worldPos);
            <span style="color: #4f97d7; font-weight: bold;">else</span>
                ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #else</span>
            ambient_contrib = SHEvalLinearL0L1 (<span style="color: #ce537a; font-weight: bold;">half4</span>(normal, 1.0));
<span style="color: #bc6ec5;">        #endif</span>

        ambient = <span style="color: #4f97d7;">max</span>(<span style="color: #ce537a; font-weight: bold;">half3</span>(0, 0, 0), ambient+ambient_contrib);     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">include L2 contribution in vertex shader before clamp.</span>
<span style="color: #bc6ec5;">        #ifdef</span> UNITY_COLORSPACE_GAMMA
            ambient = LinearToGammaSpace (ambient);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> ambient;
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> UnityGI UnityGI_Base(UnityGIInput data, <span style="color: #ce537a; font-weight: bold;">half</span> occlusion, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld)
{
    UnityGI o_gi;
    ResetUnityGI(o_gi);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Base pass with Lightmap support is responsible for handling ShadowMask / blending here for performance reason</span>
<span style="color: #bc6ec5;">    #if</span> defined(HANDLE_SHADOWS_BLENDING_IN_GI)
        <span style="color: #ce537a; font-weight: bold;">half</span> bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
        <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - data.worldPos, UNITY_MATRIX_V[2].xyz);
        <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
        data.atten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.light = data.light;
    o_gi.light.color *= data.atten;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;&#35843;&#29992; ShadeSHPerPixel &#26041;&#27861;&#35745;&#31639;&#29615;&#22659;&#20809; /LightProbe&#30340;&#29699;&#35856;&#20809;&#29031;&#65292;&#23558;&#32467;&#26524;&#23384;&#20648;&#21040;indirectLight.diffuse&#20013;</span>
<span style="color: #bc6ec5;">    #if</span> UNITY_SHOULD_SAMPLE_SH
        o_gi.indirect.diffuse = ShadeSHPerPixel(normalWorld, data.ambient, data.worldPos);
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Baked lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">half4</span> bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);
        <span style="color: #ce537a; font-weight: bold;">half3</span> bakedColor = DecodeLightmap(bakedColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">fixed4</span> bakedDirTex = UNITY_SAMPLE_TEX2D_SAMPLER (unity_LightmapInd, unity_Lightmap, data.lightmapUV.xy);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap (o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #else</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">not directional lightmap</span>
            o_gi.indirect.diffuse += bakedColor;

<span style="color: #bc6ec5;">            #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(SHADOWS_SCREEN)
                ResetUnityLight(o_gi.light);
                o_gi.indirect.diffuse = SubtractMainLightWithRealtimeAttenuationFromLightmap(o_gi.indirect.diffuse, data.atten, bakedColorTex, normalWorld);
<span style="color: #bc6ec5;">            #endif</span>

<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #ifdef</span> DYNAMICLIGHTMAP_ON
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Dynamic lightmaps</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> realtimeColorTex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, data.lightmapUV.zw);
        <span style="color: #ce537a; font-weight: bold;">half3</span> realtimeColor = DecodeRealtimeLightmap (realtimeColorTex);

<span style="color: #bc6ec5;">        #ifdef</span> DIRLIGHTMAP_COMBINED
            <span style="color: #ce537a; font-weight: bold;">half4</span> realtimeDirTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap, data.lightmapUV.zw);
            o_gi.indirect.diffuse += DecodeDirectionalLightmap (realtimeColor, realtimeDirTex, normalWorld);
<span style="color: #bc6ec5;">        #else</span>
            o_gi.indirect.diffuse += realtimeColor;
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

    o_gi.indirect.diffuse *= occlusion;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o_gi;
}

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb25af05" class="outline-4">
<h4 id="orgb25af05">Bumpiness</h4>
<div class="outline-text-4" id="text-orgb25af05">
</div>
<div id="outline-container-org2415d68" class="outline-5">
<h5 id="org2415d68">高度图转 normal map 的方法</h5>
<div class="outline-text-5" id="text-org2415d68">
</div>
<div id="outline-container-org65940d2" class="outline-6">
<h6 id="org65940d2">方案 1</h6>
<div class="outline-text-6" id="text-org65940d2">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 tangent 绕 z 轴旋转 90 度，就是 normal。<br /></li>
</ol>

<div class="figure">
<p><img src="./UnityCatLikeCoding/01_06bu_vector-rotation.png" alt="01_06bu_vector-rotation.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21033;&#29992; u &#26041;&#21521;&#39640;&#24230;&#21464;&#21270;&#26469;&#27714; normal</span>
<span style="color: #ce537a; font-weight: bold;">float2</span> delta = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> h1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv);
<span style="color: #ce537a; font-weight: bold;">float</span> h2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + delta);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">scale normal with 1/delta.x &#31532;&#19968;&#31181;&#24418;&#24335;&#28040;&#38500;&#20102;&#38500;&#27861;&#65292;&#32780;&#19988;&#25913;&#21892;&#20102;&#31934;&#24230;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">i.normal = float3(delta.x, h2 - h1, 0); &lt;==&gt; i.normal = float3(1, (h2 - h1)/delta.x, 0);</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(delta.x, h2 - h1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#25442; x &#21644; y &#23558; tangent &#36716;&#21270;&#20026; normal</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, delta.x, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25918;&#22823;y&#20943;&#24369;normal&#25928;&#26524;</span>
i.normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(h2 - h1, 1, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20063;&#21487;&#20197;&#21033;&#29992; v &#26041;&#21521;&#39640;&#24230;&#26469;&#21464;&#21270;&#27714; normal.&#23454;&#29616;&#26041;&#27861;&#30456;&#21516;</span>
</pre>
</div>

<p>
下图为使用该方式计算 normal 的效果图<br />
<img src="./UnityCatLikeCoding/20_01_08_HMapTangentAsNormal.png" alt="20_01_08_HMapTangentAsNormal.png" /><br />
</p>
</div>
</div>
<div id="outline-container-orgc7abfe5" class="outline-6">
<h6 id="orgc7abfe5">方案 2</h6>
<div class="outline-text-6" id="text-orgc7abfe5">
<ol class="org-ol">
<li>通过高度求出每一点的斜率。该斜率就是该点的 tangent。分别求出 u/v 方向的 tangent。<br /></li>
<li>将 u/v 方向的 tangent 进行叉乘生成 normal。<br /></li>
</ol>

<p>
下面是向量叉乘公式:<br />
<img src="./UnityCatLikeCoding/20_01_09_vectorCrossProduct.png" alt="20_01_09_vectorCrossProduct.png" /><br />
</p>

<p>
此处 tangent 向量叉乘优化：<br />
</p>
\begin{equation}  
  \begin{bmatrix}
  0\\ 
  {f_v}'\\ 
  1
  \end{bmatrix} \times 
  \begin{bmatrix}
  1\\ 
  {f_u}'\\ 
  0
  \end{bmatrix} = 
  \begin{bmatrix}
  {f_v}'*0-1*{f_u}'\\ 
  1*1-0*0 \\
  0*{f_u}'-{f_v}'*1
  \end{bmatrix} =
  \begin{bmatrix}
  -{f_u}'\\ 
  1 \\
  -{f_v}'
  \end{bmatrix}
\end{equation}

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float2</span> du = <span style="color: #ce537a; font-weight: bold;">float2</span>(<span style="color: #7590db;">_HeightMap_TexelSize</span>.x * 0.5, 0);
<span style="color: #ce537a; font-weight: bold;">float</span> u1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - du);
<span style="color: #ce537a; font-weight: bold;">float</span> u2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + du);
<span style="color: #ce537a; font-weight: bold;">float3</span> tu = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, u2 - u1, 0);

<span style="color: #ce537a; font-weight: bold;">float2</span> dv = <span style="color: #ce537a; font-weight: bold;">float2</span>(0, <span style="color: #7590db;">_HeightMap_TexelSize</span>.y * 0.5);
<span style="color: #ce537a; font-weight: bold;">float</span> v1 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv - dv);
<span style="color: #ce537a; font-weight: bold;">float</span> v2 = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_HeightMap</span>, i.uv + dv);
<span style="color: #ce537a; font-weight: bold;">float3</span> tv = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, v2 - v1, 1);

i.normal = <span style="color: #4f97d7;">cross</span>(tv, tu);
i.normal = <span style="color: #4f97d7;">normalize</span>(i.normal);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org052d351" class="outline-5">
<h5 id="org052d351">Normal 向量的插值</h5>
<div class="outline-text-5" id="text-org052d351">
<p>
Normal 贴图的 Filter，以及顶点的 Normal 向量在传递到片段着色器过程中的插值 都会导致 normal 向量不再是单位向量，所以需要重新单位化。<br />
</p>
</div>
</div>
<div id="outline-container-orgfa770a7" class="outline-5">
<h5 id="orgfa770a7">Normal 贴图存储惯例</h5>
<div class="outline-text-5" id="text-orgfa770a7">
<p>
Normal 贴图通用的惯例是将向上的方向存储到 z 分量.所以，在 shader 中采样出来 normal 向量后需要调换 y 分量和 z 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org4e40379" class="outline-5">
<h5 id="org4e40379">DXT5nm 存储 normal 贴图</h5>
<div class="outline-text-5" id="text-org4e40379">
<p>
其只存储了 normal 的 x，y 分量，丢弃掉了 z 分量。z 分量通过计算得到 \(z=\sqrt{1-x^2-y^2}\) .<br />
x 分量存储在 A 通道，y 分量存储在 G 通道。R 通道和 B 通道没有使用。<br />
DXT5 按照 4x4 个像素为一个块进行压缩。R 占用 5 位，B 占用 5 位，G 占用 6 位，A 占用 8 位。RGB 公用一个查找表，A 单独使用一个查找表。所以将 x 分量存储到 A 通道可以保持 x 分量和 y 分量的独立性。<br />
手机平台不支持 DXT5nm 格式，在手机平台 unity 仍然使用通用的 rgb 进行编码。<br />
</p>
</div>
</div>
<div id="outline-container-org2439223" class="outline-5">
<h5 id="org2439223">缩放 Normal</h5>
<div class="outline-text-5" id="text-org2439223">
<p>
只需要在单位化 normal 前，对 normal 的 x 分量和 z 分量进行缩放，就可以强化和弱化 y 分量。<br />
</p>
</div>
</div>
<div id="outline-container-org4fb76b0" class="outline-5">
<h5 id="org4fb76b0">Blending Normals</h5>
<div class="outline-text-5" id="text-org4fb76b0">
<p>
回顾使用高度图生成 normal 贴图的方法，可以知道，如果希望 normal 效果叠加，其实就是将高度叠加，也就是斜率叠加。<br />
normal 贴图中存储的值为:(s 表示单位化过程中，对各个分量的缩放)<br />
</p>
\begin{bmatrix}
-s{f_u}'\\ 
-s{f_v}'\\
s \\
\end{bmatrix}
<p>
所以叠加 MainNormalTex 和 DetailNormalTex 的高度后得到的 normal 为<br />
</p>
\begin{bmatrix}
\frac{M_x}{M_z} + \frac{D_x}{D_z} \\
\frac{M_y}{M_z} + \frac{D_y}{D_z} \\
1 \\
\end{bmatrix}

<p>
Whiteout Blending : 对上面得到的 normal 乘 \(M_zD_z\) ，然后丢弃掉对 x 和 y 分量的缩放、这样可以强化 X 和 Y 分量<br />
</p>
\begin{equation}  
  \begin{bmatrix}
  \frac{M_x}{M_z} + \frac{D_x}{D_z} \\
  \frac{M_y}{M_z} + \frac{D_y}{D_z} \\
  1 \\
  \end{bmatrix} * M_zD_z = 
  \begin{bmatrix}
    M_xD_z + D_xM_z \\
    M_yD_z + D_yM_z \\
    M_zD_z \\
  \end{bmatrix} = 
  \begin{bmatrix}
    M_x + D_x \\
    M_y + D_y \\
    M_zD_z \\
  \end{bmatrix}
\end{equation}
</div>
</div>
</div>
<div id="outline-container-orgbb8b28a" class="outline-4">
<h4 id="orgbb8b28a">Shadows</h4>
<div class="outline-text-4" id="text-orgbb8b28a">
</div>
<div id="outline-container-org063e6df" class="outline-5">
<h5 id="org063e6df">方向光阴影</h5>
<div class="outline-text-5" id="text-org063e6df">
</div>
<div id="outline-container-orgcf8167e" class="outline-6">
<h6 id="orgcf8167e">ShadowBias</h6>
<div class="outline-text-6" id="text-orgcf8167e">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc5b7f87" class="outline-6">
<h6 id="orgc5b7f87">开启屏幕空间阴影</h6>
<div class="outline-text-6" id="text-orgc5b7f87">
</div>
<ul class="org-ul">
<li><a id="org90ae6bf"></a>开启关闭的方法<br />
<div class="outline-text-7" id="text-org90ae6bf">
<ul class="org-ul">
<li>关闭 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 No Support，Tier 中取消勾选 Cascaded Shadows 。<br /></li>
<li>开启 在 ProjectSetting/Graphic 中，将 Screen Space Shadows 设置为 Built-in shader，Tier 中勾选 Cascaded Shadows 。<br /></li>
</ul>
</div>
</li>
<li><a id="org98a608b"></a>Rendering to Depth Texture<br />
<div class="outline-text-7" id="text-org98a608b">
<p>
Unity 绘制场景中物体将其深度写入到 DepthTexture<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/01_07sh_depth.png" alt="01_07sh_depth.png" /><br />
</p>
</div>
</div>
</li>
<li><a id="org6c9930c"></a>Rendering To Shadow Maps<br />
<div class="outline-text-7" id="text-org6c9930c">
<p>
Unity 在光源位置对场景进行绘制，将物体深度写入到 Shadowmap<br />
开启 shadow cascades 后，会多次绘制阴影。开启 2 级会绘制两次，开启 4 级会绘制 4 次。<br />
</p>

<p>
下图为第一个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows.png" alt="01_07sh_4cascades_shadows.png" /><br />
</p>

<p>
下图为第二个方向光视角下开启 4 级 cascades 阴影渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_2.png" alt="01_07sh_4cascades_shadows_2.png" /><br />
</p>
</div>
</li>

<li><a id="orge3184fc"></a>Collecting Shadows<br />
<div class="outline-text-7" id="text-orge3184fc">
<p>
Unity 使用 Hidden/Internal-ScreenSpaceShadows shader 绘制一个全屏的矩形，以前面得到的 DepthTexture 和 Shadowmap 为输入，对于每一个片段通过比较对应的场景摄像机的深度和光照摄像机的深度得出屏幕空间的阴影贴图。<br />
在这个过程中，Unity 通过 Filtering 来实现软阴影。<br />
</p>

<p>
下图为第一个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_1.png" alt="01_07sh_screenspace_shadows_1.png" /><br />
下图为第二个方向光对应的屏幕空间阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_screenspace_shadows_2.png" alt="01_07sh_screenspace_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="org6440205"></a>最终结果<br />
<div class="outline-text-7" id="text-org6440205">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_drawcall.png" alt="01_07sh_4cascades_drawcall.png" /><br />
</p>

<p>
下图为绘制结果：<br />
<img src="./UnityCatLikeCoding/01_07sh_4cascades_shadows_result.png" alt="01_07sh_4cascades_shadows_result.png" /><br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8f83c9a"></a>为什么 unity 要在渲染 shadowmap 和 collecting 之间切换？<br />
<div class="outline-text-8" id="text-org8f83c9a">
<p>
因为每个光源需要它自己的屏幕空间阴影贴图，但是从光源视角渲染阴影贴图所用到的 RenderTarget 可以被复用。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org7df3e80" class="outline-6">
<h6 id="org7df3e80">关闭屏幕空间阴影</h6>
<div class="outline-text-6" id="text-org7df3e80">
</div>
<ul class="org-ul">
<li><a id="org5690e07"></a>Rendering To Shadow Maps<br />
<div class="outline-text-7" id="text-org5690e07">
<p>
下图为第一个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_1.png" alt="01_07sh_noss_shadows_1.png" /><br />
下图为第二个方向光视角下渲染的阴影贴图：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_2.png" alt="01_07sh_noss_shadows_2.png" /><br />
</p>
</div>
</li>
<li><a id="orgbebdb49"></a>最终结果<br />
<div class="outline-text-7" id="text-orgbebdb49">
<p>
下图为两个方向光绘制场景时对应的 drawcall：<br />
<img src="./UnityCatLikeCoding/01_07sh_noss_shadows_3.png" alt="01_07sh_noss_shadows_3.png" /><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb97eafd" class="outline-6">
<h6 id="orgb97eafd">ShadowQuality</h6>
<div class="outline-text-6" id="text-orgb97eafd">
<p>
减低 ShadowDistance 可以提高阴影精度，但是会缩小阴影范围。<br />
设置投影类型 QualitySettings.shadowProjection = ShadowProjection.CloseFit; 可以提高阴影精度。<br />
开启 Cascade。<br />
</p>
</div>
</div>
<div id="outline-container-orgb0cc079" class="outline-6">
<h6 id="orgb0cc079">ForwardAddPass 阴影支持</h6>
<div class="outline-text-6" id="text-orgb0cc079">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#26696;1 fwd pass &#20013;&#28155;&#21152;&#22914;&#19979;&#21629;&#20196;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile_fwdadd_fullshadows

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26041;&#26696;2 fwd pass &#20013;&#20462;&#25913;Tag &#28155;&#21152; DIRECTIONAL SHADOWS_SCREEN&#21464;&#20307;</span>
<span style="color: #4f97d7; font-weight: bold;">Tags</span>
{
    <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"ForwardAdd"</span>
    <span style="color: #2d9574;">"SHADOWSUPPORT"</span>=<span style="color: #2d9574;">"true"</span>
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ DIRECTIONAL
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SCREEN
</pre>
</div>
</div>
</div>
<div id="outline-container-org8385bed" class="outline-6">
<h6 id="org8385bed">参考资料</h6>
<div class="outline-text-6" id="text-org8385bed">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc18faea" class="outline-5">
<h5 id="orgc18faea">Spot Light Shadow</h5>
</div>
<div id="outline-container-orgfaf2973" class="outline-5">
<h5 id="orgfaf2973">相关宏定义</h5>
<div class="outline-text-5" id="text-orgfaf2973">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏定义</th>
<th scope="col" class="org-left">DrawCall</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UNITY_NO_SCREENSPACE_SHADOWS</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">开启屏幕空间阴影</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">Directional 和 Spot 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE</td>
<td class="org-left">Shadows.RenderJob ShadowCaster</td>
<td class="org-left">PointLight 生成阴影贴图写入深度的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN</td>
<td class="org-left">RenderForward ForwardBasePass</td>
<td class="org-left">主 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_SCREEN DIRECTIONAL</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">第二个 Directional 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_DEPTH SPOT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Spot 开启阴影对应的宏定义</td>
</tr>

<tr>
<td class="org-left">SHADOWS_CUBE POINT</td>
<td class="org-left">RenderForward ForwardAddPass</td>
<td class="org-left">Point 开启阴影对应的宏定义</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>DIRECTIONAL SPOT POINT 3 个对应 Light 组件上的 LightType 的设置<br /></li>
<li>SHADOWS_SCREEN SHADOWS_DEPTH SHADOWS_CUBE 对应物体 Renderer 组件上的 ReceiveShadow 设置<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdcd0be7" class="outline-5">
<h5 id="orgdcd0be7">参考资料</h5>
<div class="outline-text-5" id="text-orgdcd0be7">
<ul class="org-ul">
<li>Signed Distance Field Shadow in Unity <a href="https://zhuanlan.zhihu.com/p/37918356">https://zhuanlan.zhihu.com/p/37918356</a><br /></li>
<li>Unity 平面阴影(王者荣耀阴影实现) <a href="https://zhuanlan.zhihu.com/p/42781261">https://zhuanlan.zhihu.com/p/42781261</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6b6f538" class="outline-4">
<h4 id="org6b6f538">Reflection</h4>
<div class="outline-text-4" id="text-org6b6f538">
</div>
<div id="outline-container-orgb29cd7c" class="outline-5">
<h5 id="orgb29cd7c">Environment Mapping</h5>
<div class="outline-text-5" id="text-orgb29cd7c">
</div>
<div id="outline-container-orged62eca" class="outline-6">
<h6 id="orged62eca">缺少 Indirect Specular Lighting</h6>
<div class="outline-text-6" id="text-orged62eca">
<p>
在 shader 中组合了 diffuse specular ambient 后，感觉应该可以创建出看上去真实的画面了，然而物体表面依然暗淡，闪耀的表面效果看起来不正确。闪耀的表面应该像镜子，特别是表面为金属时。（完美的镜面反射会反射所有光照，所以其不存在 diffuse.光滑度越高、金属度越高，材质越接近完美镜面。）<br />
下图为 Metallic Smoothness 取不同值时的渲染效果:<br />
<img src="./UnityCatLikeCoding/01_08re_no_indirect_spec_lighting1.png" alt="01_08re_no_indirect_spec_lighting1.png" /><br />
上图 metallic=1 时，env ambient 几乎对渲染没有任何影响，这是因为金属度越高反射率越大，反射率越大其漫反射部分就越少(参考 PhysicalTheory.org 中 金属和非金属放射光的差异 的描述)，所以 ambient 对于 metallic=1 的材质几乎没有任何影响。<br />
上图 metallic=1 Smoothness=1 时，几乎是一个黑色的球，只能看到一个很小的高光，这个很小的高光是表面将直接光源反射到了朝向我们的方向(朝向摄像机的方向)。之所以渲染结果是黑球，是因为 shader 中只包含了直接光照和间接光照的 diffuse（也就是 ambient），为了反射环境，需要添加间接光照的高光反射，即 indirectLight.specular。<br />
</p>
</div>
</div>

<div id="outline-container-org427ac3c" class="outline-6">
<h6 id="org427ac3c">Indirect Specular Lighting 特点</h6>
<div class="outline-text-6" id="text-org427ac3c">
<p>
视线和法线夹角越大，Fresnel 反射越强。表面越光滑 Fresnel 反射越强。<br />
<img src="./UnityCatLikeCoding/01_08re_fresnel_smoothness.png" alt="01_08re_fresnel_smoothness.png" /><br />
</p>

<p>
因为 Fresnel 间接反射来源于间接光照(上图中直接光照颜色为白色，间接光照的高光直接设置为了红色)，所以它产生的效果独立于直接光照，因此上图中即使处于阴影部分的边缘处 Fresnel 反射依然很强，其独立于直接光源的阴影。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i) {
  UnityIndirect indirectLight;
  indirectLight.diffuse = 0;
  indirectLight.specular = 0;

<span style="color: #bc6ec5;">  #if</span> defined(VERTEXLIGHT_ON)
    indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">  #endif</span>

<span style="color: #bc6ec5;">  #if</span> defined(FORWARD_BASE_PASS)
    indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38388;&#25509;&#39640;&#20809;&#39068;&#33394;&#35774;&#32622;&#20026;&#20102;&#32418;&#33394;</span>
    indirectLight.specular = <span style="color: #ce537a; font-weight: bold;">float3</span>(1, 0, 0);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org52421aa" class="outline-5">
<h5 id="org52421aa">Imperfect Reflections</h5>
<div class="outline-text-5" id="text-org52421aa">
<p>
模糊的反射是通过环境贴图的 mipmap 来实现的。<br />
</p>
</div>

<div id="outline-container-orgdd94a4d" class="outline-6">
<h6 id="orgdd94a4d">Metals VS Nonmetals</h6>
<div class="outline-text-6" id="text-orgdd94a4d">
<p>
金属和非金属表面都可以产生清晰的反射，但是他们看起来是不同的。镜面反射在闪耀的非电解质材质(非金属)上效果会很强，但是镜面反射并不会主导非电解质材质(非金属)的外观，他们仍然表现出大量的可见的 diffuse 反射。<br />
<img src="./UnityCatLikeCoding/01_08re_dielectric.png" alt="01_08re_dielectric.png" /><br />
</p>

<p>
金属会改变镜面反射的颜色，但是非金属则不会。这对于镜面高光和环境镜面反射都适用。下图中金属的镜面高光颜色为红色，非金属是白色。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_nonmetal.png" alt="01_08re_metal_nonmetal.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org549e3fd" class="outline-6">
<h6 id="org549e3fd">Mirrors and Shadows</h6>
<div class="outline-text-6" id="text-org549e3fd">
<p>
间接反射是独立于表面的直接照明的。这在其阴影区域会更加明显。对于非金属，这会让表面更亮一些，你依然可以看到直接光照导致的阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_nonmetal_with_shadow.png" alt="01_08re_nonmetal_with_shadow.png" /><br />
同样的规则适用于金属。但是，金属的间接反射起主导作用。因此，直接光照和阴影会随着光泽度增加而消失。完美镜面上不存在阴影。<br />
<img src="./UnityCatLikeCoding/01_08re_metal_with_shadow.png" alt="01_08re_metal_with_shadow.png" /><br />
现实世界中很少有完美的镜面。现实世界中的材质都是由金属和非金属混合而成的，可以通过调节金属度来模拟不完美的镜面材质。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org273ff62" class="outline-5">
<h5 id="org273ff62">Box Projection</h5>
<div class="outline-text-5" id="text-org273ff62">
<p>
ReflectionProbe 的 Box 区域是和世界坐标轴对齐的，它不受旋转和缩放影响。<br />
BoxProjection 原理如下图所示：<br />
<img src="./UnityCatLikeCoding/01_08re_box_projection.JPG" alt="01_08re_box_projection.JPG" /><br />
<img src="./UnityCatLikeCoding/01_08re_box_projection_3D.png" alt="01_08re_box_projection_3D.png" /><br />
<a href="./UnityCatLikeCoding/01_08re_box_projection.ggb">./UnityCatLikeCoding/01_08re_box_projection.ggb</a><br />
</p>

<p>
BoxProjection 对应代码实现如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half3</span> <span style="color: #bc6ec5; font-weight: bold;">BoxProjection</span>(<span style="color: #ce537a; font-weight: bold;">half3</span> dir, <span style="color: #ce537a; font-weight: bold;">half3</span> pos, <span style="color: #ce537a; font-weight: bold;">half4</span> cubemapPos, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMin, <span style="color: #ce537a; font-weight: bold;">half3</span> boxMax)
{
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cubemapPos.w &#25511;&#21046; BoxProjection &#26159;&#21542;&#29983;&#25928;  </span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UNITY_BRANCH &#29992;&#20110;&#24320;&#21551;&#30495;&#27491;&#30340;&#20998;&#25903;</span>
  UNITY_BRANCH
  <span style="color: #4f97d7; font-weight: bold;">if</span> (cubemapPos.w &gt; 0)
  {
    <span style="color: #ce537a; font-weight: bold;">half3</span> factors = ((dir &gt; 0 ? boxMax : boxMin) - pos) / dir;
    <span style="color: #ce537a; font-weight: bold;">half</span> realFactor = <span style="color: #4f97d7;">min</span>(<span style="color: #4f97d7;">min</span>(factors.x, factors.y), factors.z);
    <span style="color: #4f97d7; font-weight: bold;">return</span> dir * realFactor + (pos - cubemapPos);
  }
  <span style="color: #4f97d7; font-weight: bold;">return</span> dir;
}
</pre>
</div>

<ul class="org-ul">
<li>关于 UNITY_BRANCH   <a href="https://forum.unity.com/threads/correct-use-of-unity_branch.476804/">https://forum.unity.com/threads/correct-use-of-unity_branch.476804/</a><br /></li>
<li>HLSL branch flatten <a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-if</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5405186" class="outline-5">
<h5 id="org5405186">Blending Reflection Probes</h5>
<div class="outline-text-5" id="text-org5405186">
<p>
只有将 Renderer 的 reflectionProbeUsage 属性设置为 BlendProbesAndSkybox 时，反射探针才会和 Skybox 进行混合<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">enum</span> <span style="color: #ce537a; font-weight: bold;">ReflectionProbeUsage</span>
{
    <span style="color: #7590db;">Off</span> = 0,                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20851;&#38381;&#21453;&#23556;&#25506;&#38024;</span>
    <span style="color: #7590db;">BlendProbes</span> = 1,              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21482;&#21644;&#21453;&#23556;&#25506;&#38024;&#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">BlendProbesAndSkybox</span> = 2,     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21453;&#23556;&#25506;&#38024;&#21487;&#20197;&#21644; skybox &#36827;&#34892;&#28151;&#21512;</span>
    <span style="color: #7590db;">Simple</span> = 3                    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20351;&#29992;&#20854;&#20013;&#19968;&#20010;&#21453;&#23556;&#25506;&#38024;&#25110; skybox&#65292;&#19981;&#36827;&#34892;&#28151;&#21512;</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#28151;&#21512;&#21453;&#23556;&#25506;&#38024;&#30340;&#36923;&#36753;</span>
UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir)
{
    UnityIndirect indirect;
    indirect.diffuse = 0;
    indirect.specular = 0;
<span style="color: #bc6ec5;">    #if</span> defined(FORWARD_BASE_PASS)
    indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));

    <span style="color: #ce537a; font-weight: bold;">half</span> roughness = 1 - <span style="color: #7590db;">_Smoothness</span>;
    roughness *= 1.7 - 0.7 * roughness;

    <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir = <span style="color: #4f97d7;">reflect</span>(-viewDir, i.worldNormal);
    <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir1 = BoxProjection(reflectDir, i.worldPos,
        unity_SpecCube0_ProbePosition,
        unity_SpecCube0_BoxMin,
        unity_SpecCube0_BoxMax);
    <span style="color: #ce537a; font-weight: bold;">half4</span> envColor = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflectDir1, roughness*UNITY_SPECCUBE_LOD_STEPS);
    envColor.rgb = DecodeHDR(envColor, unity_SpecCube0_HDR);
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_SpecCube0_BoxMin.a &lt; 0.9999)
    {
        <span style="color: #ce537a; font-weight: bold;">half3</span> reflectDir2 = BoxProjection(reflectDir, i.worldPos,
            unity_SpecCube1_ProbePosition,
            unity_SpecCube1_BoxMin,
            unity_SpecCube1_BoxMax);
        <span style="color: #ce537a; font-weight: bold;">half4</span> envColor2 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, reflectDir2, roughness*UNITY_SPECCUBE_LOD_STEPS);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DecodeHDR &#20013;&#20195;&#30721;&#22788;&#29702;&#20102; intensity &#36923;&#36753;</span>
        envColor2.rgb = DecodeHDR(envColor2, unity_SpecCube1_HDR);
        envColor = <span style="color: #4f97d7;">lerp</span>(envColor2, envColor, unity_SpecCube0_BoxMin.a);
    }
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.specular = half3(1, 0, 0);</span>
    indirect.specular = envColor.rgb;
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org175c057" class="outline-5">
<h5 id="org175c057">Bouncing Reflections</h5>
<div class="outline-text-5" id="text-org175c057">
<p>
在 Lighting/Scene/Environment Reflections 下可以设置 Bounces 的次数。<br />
Lighting/Scene 下的数据记录在当前打开的场景文件中，每个场景的数据可以不同。<br />
EnvironmentLighting/IntensityMultiplier  当 EnvironmentLighting/Source 为 Skybox 时，该调节项控制天空球光照亮度.<br />
</p>

<p>
EnvironmentReflections/Source  指定使用天空球作为环境反射源，还是自定义环境反射源。<br />
EnvironmentReflections/IntensityMultiplier 控制反射源在场景中提供反射的因子，值为 1 时符合物理规律。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb31218d" class="outline-4">
<h4 id="orgb31218d">ComplexMaterials &amp; More Complexity</h4>
<div class="outline-text-4" id="text-orgb31218d">
</div>
<div id="outline-container-org7541232" class="outline-5">
<h5 id="org7541232">Emission</h5>
<div class="outline-text-5" id="text-org7541232">
<div class="org-src-container">
<pre class="src src-csharp">[NoScaleOffset] _EmissionMap (<span style="color: #2d9574;">"Emission"</span>, 2D) = <span style="color: #2d9574;">"black"</span> {}
_Emission (<span style="color: #2d9574;">"Emission"</span>, Color) = (0, 0, 0)

<span style="color: #bc6ec5;">#pragma</span><span style="color: #2d9574;"> shader_feature _EMISSION_MAP</span>

sampler2D _EmissionMap;
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_Emission</span>;

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmission</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
<span style="color: #bc6ec5;">  #if</span> <span style="color: #bc6ec5;">defined</span>(_EMISSION_MAP)
      <span style="color: #4f97d7; font-weight: bold;">return</span> tex2D(_EmissionMap, i.uv.xy) * _Emission;
<span style="color: #bc6ec5;">  #else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> _Emission;
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">#else</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> 0;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">MyFragmentProgram</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) : SV_TARGET 
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">color</span> = UNITY_BRDF_PBS(
                                  albedo, specularTint,
                                  oneMinusReflectivity, GetSmoothness(i),
                                  i.normal, viewDir,
                                  CreateLight(i), CreateIndirectLight(i, viewDir)
                                  );
    color.rgb += GetEmission(i);
    <span style="color: #4f97d7; font-weight: bold;">return</span> color;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1cb4bb1" class="outline-5">
<h5 id="org1cb4bb1">Smoothness &amp; Metallic Map</h5>
<div class="outline-text-5" id="text-org1cb4bb1">
<p>
将 MetallicMap 和 SmoothnessMap 存储到一张 DXT5 格式的贴图中 ，Metallic Map 放到贴图 r 通道, Smoothness Map 放到贴图 a 通道。等价于使用两张 DXT1 格式贴图分别存储。因为 DXT5 分开对 RGB 和 A 通道进行压缩。<br />
</p>
</div>
</div>

<div id="outline-container-org7000f1c" class="outline-5">
<h5 id="org7000f1c">Occlusion</h5>
<div class="outline-text-5" id="text-org7000f1c">
<div class="org-src-container">
<pre class="src src-csharp">[NoScaleOffset] _OcclusionMap (<span style="color: #2d9574;">"Occlusion"</span>, 2D) = <span style="color: #2d9574;">"white"</span> {}
_OcclusionStrength(<span style="color: #2d9574;">"Occlusion Strength"</span>, Range(0, 1)) = 1

<span style="color: #bc6ec5;">#pragma</span><span style="color: #2d9574;"> shader_feature _OCCLUSION_MAP</span>

sampler2D _OcclusionMap;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_OcclusionStrength</span>;

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(_OCCLUSION_MAP)
    <span style="color: #4f97d7; font-weight: bold;">return</span> lerp(1, tex2D(_OcclusionMap, i.uv.xy).g, _OcclusionStrength);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Occlusion &#21516;&#26102;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;&#21644;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;&#26102;&#65292;Occlusion&#25928;&#26524;&#20250;&#36807;&#24378;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026;Occlusion&#26159;&#22522;&#20110;&#29289;&#20307;&#24418;&#29366;&#30340;&#32780;&#19981;&#26159;&#29305;&#23450;&#20809;&#29031;&#30340;&#65292;&#20854;&#21482;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#20250;&#26356;&#21512;&#29702;&#19968;&#20123;&#12290;&#20985;&#30165;&#36234;&#28145;&#30340;&#22320;&#26041;&#65292;&#21508;&#20010;&#26041;&#21521;&#30340;&#38388;&#25509;&#20809;&#29031;&#20943;&#24369;&#36234;&#22810;&#65292;&#32780;&#30452;&#25509;&#20809;&#29031;&#29031;&#36827;&#20985;&#30165;&#26102;&#65292;&#36824;&#26159;&#21487;&#20197;&#21152;&#23558;&#20854;&#29031;&#20142;&#12290;</span>
<span style="color: #ce537a; font-weight: bold;">UnityLight</span> <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>) {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;atten&#30456;&#20056;&#26469;&#24433;&#21709;&#30452;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
    attenuation *= GetOcclusion(i);
    light.color = _LightColor0.rgb * attenuation;
    light.ndotl = DotClamped(i.normal, light.dir);
    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}

<span style="color: #ce537a; font-weight: bold;">UnityIndirect</span> <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (<span style="color: #ce537a; font-weight: bold;">Interpolators</span> <span style="color: #7590db;">i</span>, <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">viewDir</span>) {
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
<span style="color: #bc6ec5;">#if</span> <span style="color: #bc6ec5;">defined</span>(FORWARD_BASE_PASS)
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#8230;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">occlusion</span> = GetOcclusion(i);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#23558;Occlusion&#21644;&#38388;&#25509;&#20809;&#29031;&#30340;diffuse&#12289;specular&#30456;&#20056;&#26469;&#24433;&#21709;&#38388;&#25509;&#20809;&#29031;&#38452;&#24433;</span>
    indirectLight.diffuse *= occlusion;
    indirectLight.specular *= occlusion;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org00a77ee" class="outline-4">
<h4 id="org00a77ee">Transparency</h4>
<div class="outline-text-4" id="text-org00a77ee">
</div>
<div id="outline-container-org8d7c0f8" class="outline-5">
<h5 id="org8d7c0f8">Cutout</h5>
<div class="outline-text-5" id="text-org8d7c0f8">
<ul class="org-ul">
<li>clip 操作对于移动平台的 TBDR 来说消耗比较大，通过添加 _RENDERING_CUTOUT ShaderFeature，对于不需要 clip 的材质可以提升渲染性能。<br /></li>
<li>修改 cutout 材质的渲染队列，让其在不透明(Opaque)物体之后绘制，这样如果 cutout 材质对应的物体被不透明物体遮挡了，就可以避免对 cutout 物体的绘制，从而提高性能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org083834a" class="outline-5">
<h5 id="org083834a">Semitransparent</h5>
<div class="outline-text-5" id="text-org083834a">
<ul class="org-ul">
<li>半透明物体需要采用 Blend SrcAlpha OneMinusSrcAlpha 的混合方式，这样才能将半透明物体后面的物体透出来。<br /></li>
<li>半透明物体不能写深度缓冲区，否则半透明物体叠加在一起时，深度测试会剔除掉物体的一部分，导致渲染结果不正确。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc504db6" class="outline-5">
<h5 id="orgc504db6">RenderType tag</h5>
<div class="outline-text-5" id="text-orgc504db6">
<p>
下面是 Unity 内置 shader 的 Shader replacement tags, 在使用替换的 shader 进行渲染时，需要使用为 shader 设置的"RenderType" tag。<br />
</p>
<ul class="org-ul">
<li>Opaque: most of the shaders (Normal , Self Illuminated, Reflective, terrain shaders).<br /></li>
<li>Transparent: most semitransparent shaders (Transparent, Particle, Font, terrain additive pass shaders).<br /></li>
<li>TransparentCutout: masked transparency shaders (Transparent Cutout, two pass vegetation shaders).<br /></li>
<li>Background: Skybox shaders.<br /></li>
<li>Overlay: GUITexture, Halo, Flare shaders.<br /></li>
<li>TreeOpaque: terrain engine tree bark.<br /></li>
<li>TreeTransparentCutout: terrain engine tree leaves.<br /></li>
<li>TreeBillboard: terrain engine billboarded trees.<br /></li>
<li>Grass: terrain engine grass.<br /></li>
<li>GrassBillboard: terrain engine billboarded grass.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org73f1155" class="outline-5">
<h5 id="org73f1155">Fading vs Transparency</h5>
<div class="outline-text-5" id="text-org73f1155">
<ul class="org-ul">
<li>Fade Mode<br />
Fade Mode 中，使用的混合模式为 Blend SrcAlpha OneMinusSrcAlpha，几何体的颜色会依据 alpha 值降隐，漫反射和高光反射都会降隐。这种效果对于玻璃是不合适的，玻璃是全透明的，但是依然有清晰的高光和反射。<br /></li>
<li><p>
Transparent Mode<br />
Transparent Mode 中，使用的混合模式为 Blend One OneMinusSrcAlpha, albedo 会乘 alpha 值，因此漫反射会根据 alpha 值降隐，高光反射会影响到透明度。这种模式适用于玻璃。<br />
光线被反射后，透过半透明物体的光线会对应减少，如果所有光线都被反射，则不透明度为 1，如果没有光线被反射，则不透明度为原始值。y=kx+b 两个方程两个未知数，即可求出最终的 alpha 值。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_RENDERING_TRANSPARENT</span>)
albedo *= alpha;
alpha = 1 - oneMinusReflectivity + alpha * oneMinusReflectivity;
<span style="color: #bc6ec5;">#endif</span> 
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org891f211" class="outline-4">
<h4 id="org891f211">Semitransparent Shadows</h4>
<div class="outline-text-4" id="text-org891f211">
</div>
<div id="outline-container-orgdd7456b" class="outline-5">
<h5 id="orgdd7456b">Cutout Shadow</h5>
<div class="outline-text-5" id="text-orgdd7456b">
<p>
透贴的阴影只需要在 ShadowCaster Pass 的片段着色器中使用 clip(alpha - _Cutoff)指令将对应的片段剔除就可以了。<br />
</p>
</div>
</div>
<div id="outline-container-org737838f" class="outline-5">
<h5 id="org737838f">Transparenct Shadow</h5>
<div class="outline-text-5" id="text-org737838f">
<p>
使用 Dithering 技术来实现半透明阴影。依据 alpha 值 clip 投影表面，从而模拟出半透明阴影。下图为使用这种技术实现的阴影效果：<br />
<img src="./UnityCatLikeCoding/20_01_16_semitransparent_shadow.png" alt="20_01_16_semitransparent_shadow.png" /><br />
</p>

<p>
_DitherMaskLOD Unity 使用的 Dither 贴图的模式如下，其一共包含 16 种模式，每个模式中的小像素块是 4x4 的像素块。开始是一个全空的模式(下图最右边)，依次向左每个模式填充一个像素块，直到模式中有 7 个像素块被填充。然后图案翻转，直到所有像素被填充。<br />
<img src="./UnityCatLikeCoding/20_01_16_dither-patterns.png" alt="20_01_16_dither-patterns.png" /><br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679; _DitherMaskLOD &#29992;&#21040;&#30340;uv.z&#30340;&#33539;&#22260;&#20026;[0, 1] &#22240;&#20026;&#19968;&#20849;&#26377;16&#31181;&#27169;&#24335;&#65292;&#25152;&#20197;uv.z = 0 &#23545;&#24212;&#31532;&#19968;&#31181;&#27169;&#24335;uv.z = 1.0/16.0 = 0.0625 &#23545;&#24212;&#31532;&#20108;&#31181;&#27169;&#24335; uv.z = 0.9375 &#23545;&#24212;&#31532;15&#20013;&#27169;&#24335;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">alpha*0.9375 &#24403;alpha&#36234;&#23567;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#21491;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;0&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#24403;alpha&#36234;&#22823;&#36873;&#21462;&#30340;&#27169;&#24335;&#36234;&#38752;&#24038;&#36793;&#65292;&#21462;&#26679;&#24471;&#21040;&#30340;dither&#20540;&#20026;1&#30340;&#27010;&#29575;&#36234;&#22823;&#65292;&#20174;&#32780;&#27169;&#25311;&#20102;&#21322;&#36879;&#26126;&#30340;&#38452;&#24433;</span>
<span style="color: #ce537a; font-weight: bold;">float3</span> uv = <span style="color: #ce537a; font-weight: bold;">float3</span>(i.vpos.xy, alpha*0.9375);
<span style="color: #ce537a; font-weight: bold;">float</span> dither = <span style="color: #4f97d7;">tex3D</span>(<span style="color: #7590db;">_DitherMaskLOD</span>, uv);
<span style="color: #4f97d7;">clip</span>(dither - 0.01);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbaee981" class="outline-4">
<h4 id="orgbaee981">Deferred Shading</h4>
<div class="outline-text-4" id="text-orgbaee981">
</div>
<div id="outline-container-org41d6021" class="outline-5">
<h5 id="org41d6021">Forward Path vs Deferred Path</h5>
<div class="outline-text-5" id="text-org41d6021">
</div>
<div id="outline-container-org4442c36" class="outline-6">
<h6 id="org4442c36">DrawCall 对比</h6>
<div class="outline-text-6" id="text-org4442c36">
<p>
当场景中只有一个方向光时，Forward Path 和 Deferred Path 的 DrawCall 数目相差不多，Forward Path 因为需要单独生成 DepthTexture，在开始的 DepthPass 中多出了 48 个 DrawCall<br />
场景中有两个方向光时，Forward Path 比 Deferred Path 多出了很多 DrawCall。<br />
</p>

<p>
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall0.png" alt="20_01_16_deferred_renderring_drawcall0.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall1.png" alt="20_01_16_deferred_renderring_drawcall1.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall2.png" alt="20_01_16_deferred_renderring_drawcall2.png" /><br />
<img src="./UnityCatLikeCoding/20_01_16_deferred_renderring_drawcall3.png" alt="20_01_16_deferred_renderring_drawcall3.png" /><br />
</p>
</div>

<ul class="org-ul">
<li><a id="org0ba0fad"></a>为什么场景中存在多个光照时，Deferred Path 比 Forward Path 的 DrawCall 数目更少？<br />
<div class="outline-text-7" id="text-org0ba0fad">
<p>
为了渲染物体，shader 必须抓取物体的 mesh 数据，将其转化到正确的坐标空间中，然后将数据进行插值，最后，获取表面属性，计算光照。<br />
Forward Path 必须为照亮物体的每一个像素光源执行前面提到的步骤，因为 DepthBuffer 已经被填充，所以额外的 Pass 比第一个 Pass 消耗要少一些，而且它们不需要考虑间接光照。但是，他们依然需要重复处理第一个 Pass 已经做过的很多工作。<br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work.png" alt="01_12de_duplicate-work.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_duplicate-work1.png" alt="01_12de_duplicate-work1.png" /><br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb14260b" class="outline-6">
<h6 id="orgb14260b">GBuffer 内容</h6>
<div class="outline-text-6" id="text-orgb14260b">
<p>
<img src="./UnityCatLikeCoding/01_12de_gbuffer0.png" alt="01_12de_gbuffer0.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer1.png" alt="01_12de_gbuffer1.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer2.png" alt="01_12de_gbuffer2.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_gbuffer3.png" alt="01_12de_gbuffer3.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org46b1398" class="outline-6">
<h6 id="org46b1398">Rendering Lights</h6>
<div class="outline-text-6" id="text-org46b1398">
</div>
<ul class="org-ul">
<li><a id="org87a481c"></a>Directional Lights<br />
<div class="outline-text-7" id="text-org87a481c">
<p>
因为方向光影响所有物体，通过渲染一个覆盖整个视图的四边形来计算方向光的渲染。Unity 默认使用 Internal-DeferredShading.shader 来渲染这个四边形。(每个方向光使用一个四边形计算一次，多个方向光计算多次)<br />
下图中使用了两个方向光，其中渲染了两次：<br />
<img src="./UnityCatLikeCoding/01_12de_directional_light_rendering.png" alt="01_12de_directional_light_rendering.png" /><br />
</p>
</div>
</li>
<li><a id="org4e5f6db"></a>Spot Lights<br />
<div class="outline-text-7" id="text-org4e5f6db">
<p>
spot light 不会影响所有物体，使用一个棱锥体可以表示 Spot light 照亮的体积，所以通过渲染一个棱锥体来执行 Spot Light 的渲染，这样只有棱锥体可见区域会被渲染。如果棱锥体完全被其他物体遮挡，则不需要渲染该 spot light。如果棱锥体的任何一个片段被渲染，将会执行该 spot light 的光照计算。<br />
只有真的有物体在 spot light 照亮的体积中时，光照计算才是有意义的。在棱锥体后面的几何体是不需要渲染的，因为 spot light 照不到该几何体。<br />
为了避免渲染不必要的片段，首先使用 Internal-StencilWrite.shader 渲染棱锥体，该 Pass 会写入模板缓冲区，用来标识哪些片段需要渲染。不过当棱锥体和摄像机近平面交叉时不能使用该技术，因为此时近平面外的正面被摄像机剔除，只有反面写入了模板值。<br />
<img src="./UnityCatLikeCoding/01_12de_spot_light_rendering.png" alt="01_12de_spot_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="orgbc4adb4"></a>Point lights<br />
<div class="outline-text-7" id="text-orgbc4adb4">
<p>
point light 和 spot light 类似，只是使用球体来表示 point light 照亮的体积。<br />
<img src="./UnityCatLikeCoding/01_12de_point_light_rendering.png" alt="01_12de_point_light_rendering.png" /><br />
</p>
</div>
</li>

<li><a id="org5d598fc"></a>Q&amp;A<br />
<div class="outline-text-7" id="text-org5d598fc">
<ul class="org-ul">
<li>渲染灯光对应的物体时，为什么需要关闭正反面剔除？<br />
<ul class="org-ul">
<li>因为需要利用正反面分两次写入模板缓冲区，详细解释可以参考 <a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html">http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9ffbd28" class="outline-6">
<h6 id="org9ffbd28">Light Range</h6>
<div class="outline-text-6" id="text-org9ffbd28">
<p>
延迟渲染中，Unity 默认使用 LDR(Low Dynamic Range)渲染场景，此时颜色值被写入到 ARGB32 格式的贴图中，Unity 使用对数运算来编码颜色从而扩大存储的颜色范围。Final Deferred Pass 会将这些颜色值转化为正常范围的颜色值。可以在 Camera 中可以设置是否开启 HDR。<br />
下图为不开启和开启 HDR 对于的 RenderTarget 贴图格式：<br />
<img src="./UnityCatLikeCoding/01_12de_ldr.png" alt="01_12de_ldr.png" /><br />
<img src="./UnityCatLikeCoding/01_12de_hdr.png" alt="01_12de_hdr.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org521e665" class="outline-6">
<h6 id="org521e665">Mixing Rendering Modes</h6>
<div class="outline-text-6" id="text-org521e665">
<p>
场景中一部分物体使用的 shader 不支持延迟渲染模式时，引擎会先执行延迟渲染，将支持延迟渲染的物体绘制出来，然后再执行前向渲染，将其他不支持延迟渲染的物体绘制出来。<br />
Unity 的延迟渲染不支持半透明物体，半透明物体需要 Forward rendering 阶段来渲染(因为半透明物体意味着需要将半透明物体叠在其后面的物体上，每多一个半透物体重叠就额外需要一整套 GBuffer 来存储对应半透明物体的渲染数据)。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org35b13c3" class="outline-5">
<h5 id="org35b13c3">Support Deferred Path</h5>
<div class="outline-text-5" id="text-org35b13c3">
</div>
<div id="outline-container-org343a040" class="outline-6">
<h6 id="org343a040">创建 deferred pass</h6>
<div class="outline-text-6" id="text-org343a040">
<p>
延迟渲染需要 GPU 支持 MRT(multiple render targets).<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Pass</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Tags</span> {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34920;&#31034;&#35813;Pass&#29992;&#20110;&#24310;&#36831;&#28210;&#26579;</span>
        <span style="color: #2d9574;">"LightMode"</span> = <span style="color: #2d9574;">"Deferred"</span>
    }

    <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">    #pragma</span> target 3.0
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;GPU&#19981;&#25903;&#25345;MRT&#21017;&#25490;&#38500;&#24403;&#21069;Pass</span>
<span style="color: #bc6ec5;">    #pragma</span> exclude_renderers nomrt

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24310;&#36831;&#28210;&#26579;&#19981;&#25903;&#25345; _RENDERING_FADE&#21644; _RENDERING_TRANSPARENT</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature _ <span style="color: #7590db;">_RENDERING_CUTOUT</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_METALLIC_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature _ <span style="color: #7590db;">_SMOOTHNESS_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESS_METALLIC</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_NORMAL_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_OCCLUSION_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_MASK</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_ALBEDO_MAP</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_DETAIL_NORMAL_MAP</span>

<span style="color: #bc6ec5;">    #pragma</span> vertex MyVertexProgram
<span style="color: #bc6ec5;">    #pragma</span> fragment MyFragmentProgram

<span style="color: #bc6ec5;">    #define</span> DEFERRED_PASS

<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"MyDeferred.cginc"</span>
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd86fc27" class="outline-6">
<h6 id="orgd86fc27">deferred pass frag output</h6>
<div class="outline-text-6" id="text-orgd86fc27">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> FragmentOutput {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24310;&#36831;&#28210;&#26579;&#38656;&#35201;&#23558;&#25968;&#25454;&#20445;&#23384;&#21040;&#22810;&#20010;RenderTarget</span>
<span style="color: #bc6ec5;">    #if</span> defined(DEFERRED_PASS)
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">    #endif</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org3981aab" class="outline-6">
<h6 id="org3981aab">gbufer0123</h6>
<div class="outline-text-6" id="text-org3981aab">
<div class="org-src-container">
<pre class="src src-shader">FragmentOutput output;
<span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HDR_ON)
    color.rgb = <span style="color: #4f97d7;">exp2</span>(-color.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer0.rgb &#35760;&#24405;albedo</span>
  output.gBuffer0.rgb = albedo; 
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer0.a&#35760;&#24405;Occlusion</span>
  output.gBuffer0.a = GetOcclusion(i);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer1.rgb &#35760;&#24405;&#20102; specularColor</span>
  output.gBuffer1.rgb = specularTint;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer1.a &#35760;&#24405;&#20102;Smoothness</span>
  output.gBuffer1.a = GetSmoothness(i);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer2&#20013;&#35760;&#24405;&#20102;normal</span>
  output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal * 0.5 + 0.5, 1);
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GBuffer3&#20013;&#35760;&#24405;&#20102;Emissive &#21644; environment ambient&#65292;&#21518;&#32493;&#20809;&#29031;&#35745;&#31639;&#24471;&#21040;&#30340;&#39068;&#33394;&#37117;&#20250;&#21472;&#21152;&#21040;GBuffer3&#20013;</span>
  output.gBuffer3 = color;
<span style="color: #bc6ec5;">#else</span>
  output.color = ApplyFog(color, i);
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>为什么自己写的 DeferredPass GBuffer0 中输出了高光颜色，GBuffer1 中颜色比较暗?<br />
FrameDebug 发现 MetallicMap 的贴图使用了 Unity 的默认贴图，进一步检查发现 shader 属性列表中定义的属性名称和 shader 中使用的名称不一致。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgdf6508a" class="outline-6">
<h6 id="orgdf6508a">support LDR</h6>
<div class="outline-text-6" id="text-orgdf6508a">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
  output.gBuffer0.rgb = albedo;
  output.gBuffer0.a = GetOcclusion(i);
  output.gBuffer1.rgb = specColor;
  output.gBuffer1.a = smoothness;
  output.gBuffer2 = <span style="color: #ce537a; font-weight: bold;">float4</span>(normal * 0.5 + 0.5, 1);
<span style="color: #bc6ec5;">  #if</span> !defined(UNITY_HDR_ON)
  col.rgb = <span style="color: #4f97d7;">exp2</span>(-col.rgb);
<span style="color: #bc6ec5;">  #endif</span>
  output.gBuffer3 = col;
<span style="color: #bc6ec5;">#else</span>
  <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">return indirect.specular.rgbr;</span>
  output.color = col;
<span style="color: #bc6ec5;">#endif</span> <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DEFFERRED_PASS</span>
<span style="color: #4f97d7; font-weight: bold;">return</span> output;
</pre>
</div>
<ul class="org-ul">
<li>Tone mapping 进化论 <a href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a><br /></li>
<li>Tone Mapping 与 Gamma Correction <a href="https://zhuanlan.zhihu.com/p/79203830">https://zhuanlan.zhihu.com/p/79203830</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org35e5f94" class="outline-5">
<h5 id="org35e5f94">Deferred Reflections</h5>
<div class="outline-text-5" id="text-org35e5f94">
</div>
<div id="outline-container-org4354cf3" class="outline-6">
<h6 id="org4354cf3">Unity 内置的屏幕空间反射</h6>
<div class="outline-text-6" id="text-org4354cf3">
<p>
延迟渲染时，反射球会被渲染，反射球被投影到和反射球体积有交叉的几何体上。因此，反射球的反射不会扩展到反射球体积之外。反射球的渲染类似于灯光的渲染，只是反射球是使用正方体渲染的。<br />
多个反射球按照顺序渲染，首先 skybox 被渲染，会覆盖整个视图。然后，各个反射球被渲染，每个反射球只会覆盖其体积内的表面。多个反射球体积有重叠时，重叠区域内，先绘制的反射球会被后绘制的反射球覆盖。<br />
默认情况下，体积大的反射球会先绘制，这样体积小的反射球就可以覆盖体积大的反射球。你可以通过修改反射球的 Importance 属性值来调整它的绘制顺序。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_probe_params.png" alt="01_12de_reflection_probe_params.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org0605cab" class="outline-6">
<h6 id="org0605cab">延迟渲染使用非屏幕空间反射</h6>
<div class="outline-text-6" id="text-org0605cab">
<p>
关闭延迟渲染的屏幕空间反射后，Unity 会采用前向渲染的方式计算反射，将反射效果写入 GBuffer3 中。<br />
<img src="./UnityCatLikeCoding/01_12de_reflection_no_screen_space.png" alt="01_12de_reflection_no_screen_space.png" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3eb94b5" class="outline-4">
<h4 id="org3eb94b5">Fog</h4>
<div class="outline-text-4" id="text-org3eb94b5">
</div>
<div id="outline-container-org886e345" class="outline-5">
<h5 id="org886e345">Forward Fog</h5>
<div class="outline-text-5" id="text-org886e345">
<p>
在 LightSetting 可以设置雾相关的属性。<br />
</p>

<ul class="org-ul">
<li>ForwardPaht 中为什么天空盒子不受雾效果的影响？<br />
雾效果是在 Standard Shader 中的片段着色器中，对片段颜色进行修改来实现的。Unity 的天空盒并没有使用 Standard Shader 进行渲染，所以其不受雾影响。<br /></li>
</ul>
</div>
<div id="outline-container-orgce217af" class="outline-6">
<h6 id="orgce217af">Linear Fog</h6>
<div class="outline-text-6" id="text-orgce217af">
<p>
线性模式的雾可以设置雾生效的最小距离和最大距离。离摄像机距离小于最小距离时没有雾的效果，在最小距离到最大距离雾的效果逐渐增加到最大，大于最大距离时显示最大雾的效果（即物体完全呈现雾的颜色）<br />
</p>

<p>
LinearFog 计算公式 \(f = \frac{fogEnd - fogCoor}{fogEnd-fogStart}\) <br />
</p>
</div>
</div>
<div id="outline-container-org88e453c" class="outline-6">
<h6 id="org88e453c">Exponential Fog</h6>
<div class="outline-text-6" id="text-org88e453c">
<p>
一次指数模式的雾。<br />
</p>

<p>
ExponentialFog 计算公式 \(f = 2^{-fogCoor*fogDensity}\) <br />
</p>
</div>
</div>
<div id="outline-container-orgff4cf0e" class="outline-6">
<h6 id="orgff4cf0e">Exponential Squared Fog</h6>
<div class="outline-text-6" id="text-orgff4cf0e">
<p>
二次指数模式的雾。<br />
</p>

<p>
ExponentialSquaredFog 计算公式 \(f = 2^{-(fogCoor*fogDensity)^{2}}\) <br />
</p>
</div>
</div>
<div id="outline-container-orgac64bce" class="outline-6">
<h6 id="orgac64bce">Depth-Based Fog</h6>
<div class="outline-text-6" id="text-orgac64bce">
<p>
Unity Shader 使用裁剪空间坐标的 w 分量作为 Fog Coordinate，裁剪空间坐标的 w 分量为投影变换前摄像机坐标系下坐标的 z 分量。这种计算雾的方式也称为基于深度的雾计算。<br />
基于深度的雾计算比基于距离的雾计算效率更高。基于距离的雾比基于深度的雾效果要好，基于深度的雾在摄像机旋转视角时，雾效会变化。下图说明了其中的原理：<br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_001.png" alt="01_14fo_depth_vs_distance_001.png" /><br />
<img src="./UnityCatLikeCoding/01_14fo_depth_vs_distance_002.png" alt="01_14fo_depth_vs_distance_002.png" /><br />
</p>
</div>
</div>

<div id="outline-container-orgebada73" class="outline-6">
<h6 id="orgebada73">代码实现</h6>
<div class="outline-text-6" id="text-orgebada73">
</div>
<ul class="org-ul">
<li><a id="orgecd138c"></a>ApplyFog<br />
<div class="outline-text-7" id="text-orgecd138c">
<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv.xy  = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    o.worldNormal = <span style="color: #4f97d7;">mul</span>(v.normal, (<span style="color: #ce537a; font-weight: bold;">float3x3</span>)unity_WorldToObject);
    o.worldPos = <span style="color: #4f97d7;">mul</span>(unity_ObjectToWorld, v.vertex);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22522;&#20110;&#28145;&#24230;&#30340;&#38654;</span>
<span style="color: #bc6ec5;">#if</span> FOG_DEPTH
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL clip space z range = [-near, far]</span>
    o.worldPos.w = o.pos.z;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> tangentWorld = UnityObjectToWorldDir(v.tangent.xyz);
    <span style="color: #ce537a; font-weight: bold;">float3x3</span> tangentToWorld = MCreateTangentToWorldPerVertex(o.worldNormal, tangentWorld, v.tangent.w);
    o.tangentToWorld[0] = tangentToWorld[0];
    o.tangentToWorld[1] = tangentToWorld[1];
    o.tangentToWorld[2] = tangentToWorld[2];
    ComputeVertexLightColor(o);

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS)
    TRANSFER_SHADOW(o);
<span style="color: #bc6ec5;">    #else</span>
    UNITY_TRANSFER_SHADOW(o, 0);
<span style="color: #bc6ec5;">    #endif</span>
    COMPUTE_LIGHT_COORDS(o);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}


<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">ApplyFog</span>(<span style="color: #ce537a; font-weight: bold;">float</span> color, v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos);
<span style="color: #bc6ec5;">#if</span> FOG_DEPTH
    viewDistance = UNITY_Z_0_FAR_FROM_CLIPSPACE(i.worldPos.w);
<span style="color: #bc6ec5;">#endif</span>
    UNITY_CALC_FOG_FACTOR_RAW(viewDistance);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22810;&#20809;&#28304;&#25903;&#25345; &#21482;&#38656;&#35201;&#23545;&#31532;&#19968;&#20010;&#20809;&#28304;&#21472;&#21152;&#38654;&#30340;&#39068;&#33394;&#23601;&#21487;&#20197;&#20102;&#65292;&#20854;&#20182;&#20809;&#28304;&#21482;&#26681;&#25454;&#38654;&#30340;&#24378;&#24230;&#36827;&#34892;&#20943;&#24369;&#12290;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> fogColor = 0;
<span style="color: #bc6ec5;">#if</span> defined(FORWARD_BASE_PASS)
    fogColor = unity_FogColor.rgb;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(fogColor, color, unityFogFactor);
}
</pre>
</div>
</div>
</li>
<li><a id="org76cb545"></a>UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) 将 zclip space z value map to [0, far]<br />
<div class="outline-text-7" id="text-org76cb545">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(UNITY_REVERSED_Z)
<span style="color: #bc6ec5;">    #if</span> UNITY_REVERSED_Z == 1
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">D3d with reversed Z =&gt; z clip range is [near, 0] -&gt; remapping to [0, far]</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">max is required to protect ourselves from near plane not being correct/meaningfull in case of oblique matrices.</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(((1.0-(coord)/<span style="color: #7590db;">_ProjectionParams</span>.y)*<span style="color: #7590db;">_ProjectionParams</span>.z),0)
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">GL with reversed z =&gt; z clip range is [near, -far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">        #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) <span style="color: #4f97d7;">max</span>(-(coord), 0)
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#elif</span> UNITY_UV_STARTS_AT_TOP
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Opengl =&gt; z clip range is [-near, far] -&gt; should remap in theory but dont do it in practice to save some perf (range is close enough)</span>
<span style="color: #bc6ec5;">    #define</span> UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<ul class="org-ul">
<li>为什么此处不需要将 Z 值线性化？而从深度缓存区取出的深度值需要线性化？<br />
 ClipSpace 的 Z 值(OpenGL Clip Space Z Range=[-near,far])没有经过透视除法，所以其 Z 值本身就是线性的;<br />
深度缓冲区中的 Z 值（Depth Buffer Z Range=[0, 1]）经过了透视除法，其值不是线性的(10%近处的场景占用了 0-0.9 范围的深度)。<br />
<ul class="org-ul">
<li>Depth Testing <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a><br /></li>
<li>linear Depth Buffer(线性深度缓冲区) <a href="https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html">https://www.cnblogs.com/pulas/archive/2012/02/07/2341462.html</a><br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1417f9f"></a>UNITY_CALC_FOG_FACTOR_RAW 实现了前面的计算公式<br />
<div class="outline-text-7" id="text-org1417f9f">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(FOG_LINEAR)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = (end-z)/(end-start) = z * (-1/(end-start))+(end/(end-start))</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    (coord) * unity_FogParams.z + unity_FogParams.w
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = exp(-density*z)</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    unity_FogParams.y * (coord); \
    unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor)
<span style="color: #bc6ec5;">#elif</span> defined(FOG_EXP2)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">factor = exp(-(density*z)^2)</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = \
    unity_FogParams.x * (coord); \
    unityFogFactor = <span style="color: #4f97d7;">exp2</span>(-unityFogFactor*unityFogFactor)
<span style="color: #bc6ec5;">#else</span>
<span style="color: #bc6ec5;">  #define</span> UNITY_CALC_FOG_FACTOR_RAW(coord) <span style="color: #ce537a; font-weight: bold;">float</span> unityFogFactor = 0.0
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x = density / sqrt(ln(2)), useful for Exp2 mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">y = density / ln(2), useful for Exp mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">z = -1/(end-start), useful for Linear mode</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">w = end/(end-start), useful for Linear mode</span>
<span style="color: #ce537a; font-weight: bold;">float4</span> unity_FogParams;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org963bb07" class="outline-5">
<h5 id="org963bb07">Deferred Fog</h5>
<div class="outline-text-5" id="text-org963bb07">
</div>
<div id="outline-container-orga36f85d" class="outline-6">
<h6 id="orga36f85d">Shader Source Code</h6>
<div class="outline-text-6" id="text-orga36f85d">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Custom/DeferredFog"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">CGINCLUDE</span>
<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
    <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_CameraDepthTexture</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_FrustumCorners</span>[4];

    <span style="color: #4f97d7; font-weight: bold;">struct</span> VertexData {
        <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    };

    <span style="color: #4f97d7; font-weight: bold;">struct</span> Interpolators {
        <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
        <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
        <span style="color: #ce537a; font-weight: bold;">float3</span> ray;
<span style="color: #bc6ec5;">        #endif</span>
    };

    Interpolators <span style="color: #bc6ec5; font-weight: bold;">VertexProgram</span> (VertexData v) {
        Interpolators i;
        i.pos = <span style="color: #ce537a; font-weight: bold;">float4</span>(v.vertex.xy, 0.0, 1.0);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#30452;&#25509;&#36890;&#36807;&#19977;&#35282;&#24418;&#39030;&#28857;&#22352;&#26631;&#27714;&#30340;uv&#22352;&#26631;</span>
        i.uv = (v.vertex + 1) * 0.5;
<span style="color: #bc6ec5;">        #if</span> UNITY_UV_STARTS_AT_TOP
          i.uv= i.uv * <span style="color: #ce537a; font-weight: bold;">float2</span>(1.0, -1.0) + <span style="color: #ce537a; font-weight: bold;">float2</span>(0.0, 1.0);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558; i.uv &#26144;&#23556;&#20026;&#25968;&#32452;&#30340;&#32034;&#24341;&#20540;</span>
          i.ray = <span style="color: #7590db;">_FrustumCorners</span>[i.uv.x+2*i.uv.y]
<span style="color: #bc6ec5;">        #endif</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> i;
    }

    <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">FragmentProgram</span> (Interpolators i) : <span style="color: #a45bad;">SV_Target</span> {
        <span style="color: #ce537a; font-weight: bold;">float</span> depth = SAMPLE_DEPTH_TEXTURE(<span style="color: #7590db;">_CameraDepthTexture</span>, i.uv);
        depth = Linear01Depth(depth);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20026;&#20102;&#21644;Forward Path&#20013;&#28145;&#24230;&#38654;&#35745;&#31639;&#19968;&#30452;&#38656;&#35201;&#20943;&#25481;near , &#21442;&#32771; UNITY_Z_0_FAR_FROM_CLIPSPACE &#20989;&#25968;&#20013;&#30340;&#22788;&#29702;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">_ProjectionParams // x=1 or -1  y=near z=far w=1/far</span>
<span style="color: #bc6ec5;">        #if</span> defined(FOG_DISTANCE)
        <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = <span style="color: #4f97d7;">length</span>(depth * i.ray);
<span style="color: #bc6ec5;">        #else</span>
        <span style="color: #ce537a; font-weight: bold;">float</span> viewDistance = depth * <span style="color: #7590db;">_ProjectionParams</span>.z - <span style="color: #7590db;">_ProjectionParams</span>.y;
<span style="color: #bc6ec5;">        #endif</span>
        UNITY_CALC_FOG_FACTOR_RAW(viewDistance);
        unityFogFactor = <span style="color: #4f97d7;">saturate</span>(unityFogFactor);
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22825;&#31354;&#30418;&#28145;&#24230;&#20540;&#20026;1&#65292;&#36890;&#36807;&#19979;&#38754;&#21028;&#26029;&#65292;&#35753;&#38654;&#19981;&#24433;&#21709;&#22825;&#31354;&#30418;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (depth &gt; 0.9999)
        {
            unityFogFactor = 1;
        }
        <span style="color: #ce537a; font-weight: bold;">float3</span> color = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv).rgb;
        <span style="color: #ce537a; font-weight: bold;">float3</span> foggedColor = <span style="color: #4f97d7;">lerp</span>(unity_FogColor.rgb, color, unityFogFactor);
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">float4</span>(foggedColor, 1);
    }
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>

    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off <span style="color: #4f97d7; font-weight: bold;">ZTest</span> Always
        <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">            #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">            #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">            #pragma</span> multi_compile_fog
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">Pass</span> {
            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>

<span style="color: #bc6ec5;">            #define</span> FOG_DISTANCE
<span style="color: #bc6ec5;">            #pragma</span> vertex VertexProgram
<span style="color: #bc6ec5;">            #pragma</span> fragment FragmentProgram

<span style="color: #bc6ec5;">            #pragma</span> multi_compile_fog
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0a522a2" class="outline-6">
<h6 id="org0a522a2">Depth-Based Fog</h6>
</div>
<div id="outline-container-org25a8c2b" class="outline-6">
<h6 id="org25a8c2b">Distance Based Fog</h6>
<div class="outline-text-6" id="text-org25a8c2b">
<p>
从摄像机原点向远平面发射一条射线，如果从原点到远平面之间有物体，这射线最先接触的物体的交点到摄像机原点的距离就是我们要求的距离。<br />
从摄像机原点 O 到远平面交点 F 的射线(向量 OF)和从原点 O 到最先接触物体的交点 I 的射线(向量 OI)之间的关系为 \(OF=depth*OI\) ,其中 depth 为交点 I 对应的深度值。<br />
在 vertex shader 中设置每个顶点对应的 \(ray=\overrightarrow{OF}\) ,在 fragment shader 中就会得到各个像素对应的 OF 向量。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org193b5d1" class="outline-4">
<h4 id="org193b5d1">Deferred Lights</h4>
<div class="outline-text-4" id="text-org193b5d1">
</div>
<div id="outline-container-org892adb8" class="outline-5">
<h5 id="org892adb8">Q&amp;A</h5>
<div class="outline-text-5" id="text-org892adb8">
</div>
<div id="outline-container-org0f2e50a" class="outline-6">
<h6 id="org0f2e50a"><span class="todo TODO">TODO</span> 为什么 DeferredShading 中 Directional 对应的顶点数据不是摄像机近平面四个角，或者是摄像机和四个角连线上的点？</h6>
<div class="outline-text-6" id="text-org0f2e50a">
<p>
摄像机近平面四个角，或者是摄像机和四个角连线上的点组合出来的面片才能覆盖整个屏幕。<br />
</p>
</div>
</div>

<div id="outline-container-org399bdc1" class="outline-6">
<h6 id="org399bdc1">为什么 DeferredShading 中片段着色器返回 0，依然可以渲染出物体？</h6>
<div class="outline-text-6" id="text-org399bdc1">
<p>
DeferredShading 为了不覆盖之前 ColorBuffer 中的内容，其混合模式使用了 Blend One One, 所以当 DeferredShading 返回 0 时，其实显示的是之前绘制的内容。<br />
</p>
</div>
</div>
<div id="outline-container-org03f6610" class="outline-6">
<h6 id="org03f6610">为什么 Forward Path 和 Deferred Path 中计算 SpotLight Cookie 的方法不同？</h6>
<div class="outline-text-6" id="text-org03f6610">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ForwardShading</span>
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySpotCookie</span>(<span style="color: #ce537a; font-weight: bold;">float4</span> lightCoord)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;uv&#38656;&#35201;&#20559;&#31227;0.5</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_LightTextureB</span>, lightCoord.xy / lightCoord.w + 0.5).w;
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredShading</span>
<span style="color: #bc6ec5;">#if</span> defined(SPOT)
  <span style="color: #ce537a; font-weight: bold;">float4</span> uvCookie = <span style="color: #4f97d7;">mul</span>(unity_WorldToLight, <span style="color: #ce537a; font-weight: bold;">float4</span>(worldPos, 1));
  uvCookie.xy /= uvCookie.w;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27492;&#22788;uv&#19981;&#38656;&#35201;&#20559;&#31227;0.5 Unity&#22312;&#24341;&#25806;&#23618;&#35745;&#31639;unity_WorldToLight&#26102;&#32771;&#34385;&#20102;uv&#30340;&#20559;&#31227;&#65292;&#27492;&#22788;&#23601;&#19981;&#38656;&#35201;&#36827;&#34892;&#35745;&#31639;&#20102;&#12290;</span>
  atten *= tex2Dbias(<span style="color: #7590db;">_LightTexture0</span>, <span style="color: #ce537a; font-weight: bold;">float4</span>(uvCookie.xy, 0, -8)).w;
  atten *= uvCookie.w &lt; 0;
<span style="color: #bc6ec5;">  #if</span> defined(SHADOWS_DEPTH)
    shadowed = <span style="color: #a45bad;">true</span>;
    sAtten = CalcSAtten(sFade, worldPos);
<span style="color: #bc6ec5;">  #endif</span>
<span style="color: #bc6ec5;">#else</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc1f2489" class="outline-4">
<h4 id="orgc1f2489">Static Lighting</h4>
<div class="outline-text-4" id="text-orgc1f2489">
</div>
<div id="outline-container-org76a4669" class="outline-5">
<h5 id="org76a4669">Lightmapping 光照贴图</h5>
<div class="outline-text-5" id="text-org76a4669">
</div>
<div id="outline-container-org07ad597" class="outline-6">
<h6 id="org07ad597">简介</h6>
<div class="outline-text-6" id="text-org07ad597">
<p>
计算光照是比较昂贵的开销。虽然延迟渲染允许我们使用很多灯光，但是阴影依然是一个限制因素。如果我们的场景是动态的，我们无法避免这些计算。但是如果灯光和场景不会改变，我们就可以计算一次灯光后重用它。这样我们就可以放置很多灯光在场景中，而不需要在运行时渲染这些灯光。我们也可以使用区域灯光，这种灯光只能在烘培光照贴图的情况下使用。<br />
</p>
</div>
</div>
<div id="outline-container-orgd263f9d" class="outline-6">
<h6 id="orgd263f9d">Unity 中使用光照贴图的步骤</h6>
<div class="outline-text-6" id="text-orgd263f9d">
<ol class="org-ol">
<li>把灯光的模式从 Realtime 切换为 Baked<br />
灯光一共有三种模式<br />
<ul class="org-ul">
<li>Realtime 实时灯光<br /></li>
<li>Baked 烘培灯光<br /></li>
<li>Mixed 混合灯光(既用于实时光照计算，又用于烘培光照计算)<br /></li>
</ul></li>
<li>在 Lighting Setting 中勾选 Baked Global Illumination.设置 Lighting Mode 为 Baked Indirect<br />
Lighting Mode 一共有三种模式<br />
<ul class="org-ul">
<li>Baked Indirect <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html">https://docs.unity3d.com/Manual/LightMode-Mixed-BakedIndirect.html</a><br /></li>
<li>Shadowmask <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html</a><br /></li>
<li>Subtractive <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html">https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html</a><br /></li>
</ul></li>
<li>将场景中固定不变的物体标记为 Lightmap Static<br />
MeshRenderer 组件的 Inspector 窗口中有一个 Lightmap Static 勾选框，其修改的就是 Lightmap Static 标记<br /></li>
</ol>

<p>
当场景中只有 Baked 模式的灯光时，光照贴图提供的光照要比实时光照效果暗一些。这是因为烘培的光照贴图只有 diffuse 光照，没有 specular 光照。specular 光照依赖于视角，即 specular 和摄像机方向相关，通常来说摄像机是可变的，所以无法在光照贴图中包含摄像机相关信息。这种限制意味着，光照贴图适用于微弱的光照和不闪亮(黯淡)的表面，不适用于强烈的光照和闪耀的表面。如果你需要 specular 光照，你必须使用实时光照。所以通常你需要混合使用烘培和实时光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1ea9194"></a>Light=Baked LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Baked 模式）<br />
<div class="outline-text-7" id="text-org1ea9194">
<p>
lightmapper 会将直接光和间接光都烘培到光照贴图中。此时，引擎向 shader 中传递的_LightColor0 值为(0,0,0,0)，所以实时调节灯光强度，不会有效果。<br />
这种模式下，无论场景中有多少灯光，运行时，只渲染一次物体。<br />
</p>
</div>
</li>
<li><a id="orgf0be707"></a>Light=Mixed LightingMode=BakedIndirect（LightingSetting 中 LightingMode=BakedIndirect，场景中的灯光使用 Mixed 模式）<br />
<div class="outline-text-7" id="text-orgf0be707">
<p>
lightmapper 只会将间接光烘培到光照贴图中，所以该模式下的光照贴图比 Baked 模式下的要暗。此时，引擎会将正确的_LightColor0 传给 shader，所以实时调节灯光强度，会有效果（只会对直接光照有效果）。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdd64fde" class="outline-6">
<h6 id="orgdd64fde">Lightmapping Settings</h6>
<div class="outline-text-6" id="text-orgdd64fde">
<p>
Lightmapper 有两种<br />
</p>
<ul class="org-ul">
<li>Enlighten<br /></li>
<li>Progressive 该方式会增量式生成 lightmaps，会优先生成当前 scene view 可见的物体的 lightmap，这对于编辑是比较方便的。<br /></li>
</ul>

<p>
Directional Mode 有两种<br />
</p>
<ul class="org-ul">
<li>Directional Mode<br /></li>
<li>Non-Direction<br /></li>
</ul>

<p>
Ambient Occlusion : 它是间接光照在角落和褶皱处的阴影。它是一种人为增强效果，可以提升深度感。Ambient Occlusion 单单基于表面的隐藏程度，其不会考虑光照的真实路径。所以，和自发光表面结合使用时，会有明显错误。<br />
</p>
</div>
</div>
<div id="outline-container-org3e9539e" class="outline-6">
<h6 id="org3e9539e">Indirect Light</h6>
<div class="outline-text-6" id="text-org3e9539e">
<p>
烘培光照会考虑光照在多个表面的弹射，光子的每次弹射，都会损失一些能量，并且会被交互的材质修改颜色。Unity 在烘培间接光照时，都会考虑这些因素。<br />
</p>
</div>
</div>

<div id="outline-container-org3ffbf5e" class="outline-6">
<h6 id="org3ffbf5e">Transparency</h6>
<div class="outline-text-6" id="text-org3ffbf5e">
<p>
对于单面透明物体，需要创建 Lightmap Parameters，将 IsTransparent 参数指定为 True，将 Lightmap Parameters 指定给单面透明物体。半透明物体会让间接光照通过，而不透明物体会阻挡间接光照。<br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_error.png" alt="01_16sl_transparentObj_bake_error.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_transparentObj_bake_correct.png" alt="01_16sl_transparentObj_bake_correct.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org856b934" class="outline-5">
<h5 id="org856b934">使用光照贴图</h5>
<div class="outline-text-5" id="text-org856b934">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403;&#20351;&#29992;lightmaps&#21518;&#65292;unity &#23558;&#19981;&#20250;&#21253;&#21547;&#39030;&#28857;&#20809;&#29031;&#35745;&#31639;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ LIGHTMAP_ON VERTEXLIGHT_ON

<span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmap uv</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> tangentToWorld[3] : <span style="color: #a45bad;">TEXCOORD2</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos : <span style="color: #a45bad;">TEXCOORD5</span>;
    UNITY_SHADOW_COORDS(6)
    DECLARE_LIGHT_COORDS(7)
<span style="color: #bc6ec5;">#ifdef</span> VERTEXLIGHT_ON
    <span style="color: #ce537a; font-weight: bold;">float3</span> vertexLightColor : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">#elif</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmapUV</span>
    <span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV : <span style="color: #a45bad;">TEXCOORD8</span>;
<span style="color: #bc6ec5;">#endif</span>
};

v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

<span style="color: #bc6ec5;">#if</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22240;&#20026; lightmap&#30340;transformation&#27809;&#26377;&#34987;&#23450;&#20041;&#20026;unity_Lightmap_ST&#65292;&#25152;&#20197;&#26080;&#27861;&#20351;&#29992;TRANSFORM_TEX&#23439;</span>
    o.lightmapUV = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirectLight</span> (Interpolators i, <span style="color: #ce537a; font-weight: bold;">float3</span> viewDir) {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#if</span> defined(VERTEXLIGHT_ON)
    indirectLight.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">lightmap &#21644;&#39030;&#28857;&#20809;&#29031;&#19981;&#20250;&#21516;&#26102;&#20986;&#29616;</span>
    indirectLight.diffuse = 0;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DecodeLightmap &#20250;&#22788;&#29702;&#20809;&#29031;&#36148;&#22270;&#19981;&#21516;&#26684;&#24335;</span>
    indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">    #else</span>
    indirectLight.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.normal, 1)));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> indirectLight;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga2db716" class="outline-5">
<h5 id="orga2db716">创建光照贴图</h5>
<div class="outline-text-5" id="text-orga2db716">
</div>
<div id="outline-container-org6cb12a3" class="outline-6">
<h6 id="org6cb12a3">lightmapper 默认规则</h6>
<div class="outline-text-6" id="text-org6cb12a3">
<p>
lightmapper 不会使用实时渲染管线，所以它并不会使用我们的自己的 shader 来渲染 lightmap。<br />
lightmapper 会通过材质的 RenderType 来决定怎样对待物体表面:<br />
</p>
<ul class="org-ul">
<li>RenderType="Opaque" 不透明物体<br /></li>
<li>RenderType="Transparent" 半透明物体<br /></li>
<li>RenderType="TransparentCutout" 透贴型物体<br /></li>
</ul>

<p>
当没有贴图时，lightmapper 会通过材质的_Color 属性值的 a 分量来确定透明度，所以不能使用_MainColor _Tint 等属性名<br />
当有贴图时，lightmapper 会通过材质的_MainTex 贴图的 a 分量来确定透明度，所以不能使用_DiffuseTex _Albedo 等属性名<br />
<img src="./UnityCatLikeCoding/01_16sl_MainTexM_result.png" alt="01_16sl_MainTexM_result.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_MainTex_result.png" alt="01_16sl_MainTex_result.png" /><br />
lightmapper 会通过材质的 _Cutoff 属性值，作为透贴门槛值，所以不能使用_AlphaCutoff 等属性名<br />
</p>
</div>
</div>
<div id="outline-container-org4decf97" class="outline-6">
<h6 id="org4decf97">通过 Meta Pass 将 Albedo 和 Emission 传递给 lightmapper</h6>
<div class="outline-text-6" id="text-org4decf97">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Pass</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Name</span> <span style="color: #2d9574;">"META-MyLightmapping"</span>
    <span style="color: #4f97d7; font-weight: bold;">Tags</span>
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">LightMode &#24517;&#39035;&#20026; Meta</span>
        <span style="color: #2d9574;">"LightMode"</span>=<span style="color: #2d9574;">"Meta"</span>
    }
    <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
    <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">    #include</span> <span style="color: #2d9574;">"MyStaticLighting_Lightmapping.cginc"</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#include "MyStaticLighting_Lightmapping_Test.cginc"</span>
<span style="color: #bc6ec5;">    #pragma</span> vertex vert
<span style="color: #bc6ec5;">    #pragma</span> fragment frag
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_EMISSION</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_METALLICMAP_ON</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span> <span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>
<span style="color: #bc6ec5;">    #pragma</span> shader_feature <span style="color: #7590db;">_ALBEDODETAIL_ON</span>
    <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
}

<span style="color: #bc6ec5;">#ifndef</span> MY_STATICLIGHTING_LIGHTMAPPING
<span style="color: #bc6ec5;">#define</span> MY_STATICLIGHTING_LIGHTMAPPING

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"UnityPBSLighting.cginc"</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"UnityMetaPass.cginc"</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
{
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
};

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#define _MainTex _MainTexM</span>
<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">#define _MainTex_ST _MainTexM_ST</span>

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_Color</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_MainTex_ST</span>;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">_Cutoff</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailTex</span>;
<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_DetailTex_ST</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DetailMask</span>;
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #7590db;">_EmissionColor</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_EmissiveMap</span>;
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MetallicSmoothnessMap</span>;

v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv1.xy, unity_LightmapST, unity_LightmapST); 

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">v.vertex.xy = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">v.vertex.z = v.vertex.z &gt; 0 ? 0.0001 : 0;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.pos = UnityObjectToClipPos(v.vertex);</span>

    o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(v2f i)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Color</span>.a;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetDetailMask</span>(v2f i)
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_DetailMask</span>, i.uv.zw);
}

<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlbedo</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> albedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy);
    albedo *= <span style="color: #7590db;">_Color</span>;
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_ALBEDODETAIL_ON</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> detailAlbedo = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailTex</span>, i.uv.zw);
    albedo = <span style="color: #4f97d7;">lerp</span>(albedo, albedo*detailAlbedo*unity_ColorSpaceDouble, GetDetailMask(i));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> albedo;
}
<span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetEmissive</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> emissive = 0;
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_EMISSION</span>)
    emissive = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_EmissiveMap</span>, i.uv);
    <span style="color: #4f97d7; font-weight: bold;">if</span> (<span style="color: #4f97d7;">dot</span>(emissive, emissive) &lt; 0.001)
    {
        emissive = <span style="color: #7590db;">_EmissionColor</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        emissive = emissive * <span style="color: #7590db;">_EmissionColor</span>;
    }
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> emissive;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetMetallic</span>(v2f i)
{
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).r * <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Metallic</span>;
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetSmoothness</span>(v2f i)
{
<span style="color: #bc6ec5;">    #if</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_METALLIC</span>) &amp;&amp; defined(<span style="color: #7590db;">_METALLICMAP_ON</span>)
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MetallicSmoothnessMap</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #elif</span> defined(<span style="color: #7590db;">_SMOOTHNESSMAP_ALBEDO</span>) 
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #7590db;">_Smoothness</span>;
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span>(v2f i) : SV_TARGET
{
    UnityMetaInput o;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Emission = float3(0, 0, 1);</span>
    o.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Albedo = float3(1, 0, 0);   </span>
    <span style="color: #ce537a; font-weight: bold;">float</span> oneMinusReflectivity;
    o.Albedo = DiffuseAndSpecularFromMetallic(GetAlbedo(i), GetMetallic(i), o.SpecularColor, oneMinusReflectivity);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#25552;&#20379;&#30340;&#38388;&#25509;&#20809;&#29031;&#20250;&#36234;&#22810;, &#36234;&#31895;&#31961;&#30340;&#34920;&#38754;&#20250;&#36234;&#22810;&#21453;&#23556;Specular&#20809;&#29031;&#20986;&#21435;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> roughness = SmoothnessToRoughness(GetSmoothness(i)) * 0.5;
    o.Albedo += o.SpecularColor * roughness;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.Albedo = GetAlbedo(i);</span>
    o.SpecularColor = 0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(o);
}
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8d0f0c8" class="outline-5">
<h5 id="org8d0f0c8">Directional Lightmaps 具有方向的光照贴图</h5>
<div class="outline-text-5" id="text-org8d0f0c8">
</div>
<div id="outline-container-org90f04ee" class="outline-6">
<h6 id="org90f04ee">简介</h6>
<div class="outline-text-6" id="text-org90f04ee">
<p>
lightmapper 值使用了顶点的集合数据，它没有考虑法线贴图。光照贴图的精度太低了，无法捕捉到传统法线贴图提供的细节。这意味着静态光照将会比较平。<br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-realtime.png" alt="01_16sl_normal-maps-realtime.png" /><br />
<img src="./UnityCatLikeCoding/01_16sl_normal-maps-lightmapped.png" alt="01_16sl_normal-maps-lightmapped.png" /><br />
上面两张图是，使用法线贴图的情况下，实时光照和烘培光照的效果对比。可以看到在烘培光照中，法线贴图的影响几乎没有，画面中微弱的法线效果来自环境反射。<br />
</p>
</div>
</div>

<div id="outline-container-orgfec2e02" class="outline-6">
<h6 id="orgfec2e02">方向性</h6>
<div class="outline-text-6" id="text-orgfec2e02">
<p>
将 Directional Mode 设置为 Directional，就可以让法线贴图和烘培的光照协同工作。 在 Lighting/Lightmapping Settings/DirecionalMode 中，可以设置 Directional Mode = Directional。<br />
Directional Mode=Directional 时，unity 会生成两张光照贴图，一张就像之前一样的光照强度贴图，用于存储光照强度。新的另一张为光照方向贴图，用于存储最多的烘培光照的来源方向。<br />
</p>
</div>
</div>

<div id="outline-container-org90c67fa" class="outline-6">
<h6 id="org90c67fa">使用烘培的方向贴图</h6>
<div class="outline-text-6" id="text-org90c67fa">
<div class="org-src-container">
<pre class="src src-shader">  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24320;&#21551;&#28888;&#22521;&#26041;&#21521;&#36148;&#22270;&#30340;&#23439;&#23450;&#20041;</span>
<span style="color: #bc6ec5;">  #pragma</span> multi_compile _ DIRLIGHTMAP_COMBINED


  UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
  {
      <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
      UnityIndirect indirect;
<span style="color: #bc6ec5;">      #ifdef</span> VERTEXLIGHT_ON
      indirect.diffuse = i.vertexLightColor;
<span style="color: #bc6ec5;">      #else</span>
      indirect.diffuse = 0;
<span style="color: #bc6ec5;">      #endif</span>
      indirect.specular = 0;


<span style="color: #bc6ec5;">      #if</span> defined(FORWARD_BASE_PASS) || defined(DEFFERRED_PASS)
<span style="color: #bc6ec5;">          #if</span> defined(LIGHTMAP_ON)
              <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.diffuse = UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV);</span>
              indirect.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lightmapUV));
<span style="color: #bc6ec5;">              #if</span> defined(DIRLIGHTMAP_COMBINED)
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#37319;&#26679;&#28888;&#22521;&#30340;&#26041;&#21521;&#36148;&#22270;</span>
              <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap,i.lightmapUV);
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;Half Lambert&#35745;&#31639;Diffuse</span>
              indirect.diffuse = DecodeDirectionalLightmap(indirect.diffuse, lightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">              #endif</span>
<span style="color: #bc6ec5;">          #else</span>
              <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809;</span>
              indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">          #endif</span>
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">      #endif</span>
      <span style="color: #4f97d7; font-weight: bold;">return</span> indirect;
  }

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half3</span> DecodeDirectionalLightmap (<span style="color: #ce537a; font-weight: bold;">half3</span> color, <span style="color: #ce537a; font-weight: bold;">fixed4</span> dirTex, <span style="color: #ce537a; font-weight: bold;">half3</span> normalWorld) 
{
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">In directional (non-specular) mode Enlighten bakes dominant light</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">direction in a way, that using it for half Lambert and then dividing</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">by a "rebalancing coefficient" gives a result close to plain diffuse</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">response lightmaps, but normalmapped.</span>

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Note that dir is not unit length on purpose. Its length is</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">"directionality", like for the directional specular lightmaps.</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> halfLambert = <span style="color: #4f97d7;">dot</span>(normalWorld, dirTex.xyz - 0.5) + 0.5;

    <span style="color: #4f97d7; font-weight: bold;">return</span> color * halfLambert / <span style="color: #4f97d7;">max</span>(1e-4h, dirTex.w);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f6cefd" class="outline-5">
<h5 id="org1f6cefd">Light Probes</h5>
<div class="outline-text-5" id="text-org1f6cefd">
<p>
Lightmaps 只对静态物体起作用，对动态物体不起作用。这会导致动态物体无法融入烘培光照的场景。Unity 使用 LightProbe 来存储其所在点的烘培光照信息，LightProbe 没有使用贴图存储光照信息，其使用 Spherical Harmonics 存储这些信息。<br />
场景中的动态物体会使用 LightProbe 存储的烘培光照信息来取代全局的环境数据。<br />
</p>
</div>
<div id="outline-container-org7234506" class="outline-6">
<h6 id="org7234506">为什么 SceneView 中不显示 LightProbe？</h6>
<div class="outline-text-6" id="text-org7234506">
<p>
SceneView 下 Gizmos/3D Icon 被缩放到最小了。<br />
</p>
</div>
</div>
<div id="outline-container-org65b943d" class="outline-6">
<h6 id="org65b943d">为什么 LightProb 对于动态物体不生效？</h6>
<div class="outline-text-6" id="text-org65b943d">
<p>
两个 LightProb 是无作用的，需要让 LightProbe 形成网才能生效。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1e14a42" class="outline-5">
<h5 id="org1e14a42">Q&amp;A</h5>
<div class="outline-text-5" id="text-org1e14a42">
</div>
<div id="outline-container-org2209830" class="outline-6">
<h6 id="org2209830">使用 lightmap 时，顶点着色器中传入的 lightmap uv 是如何求得的？又是如何传入顶点着色器的？</h6>
<div class="outline-text-6" id="text-org2209830">
<ul class="org-ul">
<li>关于 3D 模型的二套 UV <a href="https://zhuanlan.zhihu.com/p/83322397">https://zhuanlan.zhihu.com/p/83322397</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbb99a98" class="outline-6">
<h6 id="orgbb99a98">什么错误导致 lightmap 中不包含 Emission 颜色？</h6>
<div class="outline-text-6" id="text-orgbb99a98">
<ul class="org-ul">
<li>缺乏 Meta Pass<br /></li>
<li><p>
Meta Pass 的 Fragment 没有按照如下方式输出<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i) : SV_TARGET
{
    UnityMetaInput surfaceData;
    surfaceData.<span style="color: #4f97d7; font-weight: bold;">Emission</span> = GetEmissive(i);
    surfaceData.Albedo = GetAlbedo(i);
    surfaceData.SpecularColor = 0;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaFragment</span>(surfaceData);
}
</pre>
</div></li>
<li>材质的 MaterialGlobalIlluminationFlags 没设置为 BakedEmissive<br /></li>
<li><p>
vertex 着色器函数中输出的 SV_POSITION 不正确<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">v2f_meta <span style="color: #bc6ec5; font-weight: bold;">vert_test</span>(VertexInput v)
{
    v2f_meta o;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">o.pos = UnityObjectToClipPos(v.vertex);  // &#36825;&#26679;&#35745;&#31639;&#24471;&#20986;&#30340;pos&#26159;&#38169;&#35823;&#30340;&#12290;</span>
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST); 
    o.uv = TexCoords(v);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}
</pre>
</div></li>
<li>unity lightmap 数据清除有 bug，清除 lightmap 后，隐藏一个物体，再烘培，检查数据是否正确。<br />
lightmap 缓存极其不稳定，有时候隐藏了烘培依然不可以，需要隐藏一个其他物体再来一次。<br /></li>
<li><del>frag 着色器的 out 标记 SV_TARGET 是否全部使用大写</del> SV_Target 也是可以的<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgfa15dbb"></a>参考资料<br />
<div class="outline-text-7" id="text-orgfa15dbb">
<ul class="org-ul">
<li><a href="https://docs.unity3d.com/Manual/MetaPass.html">https://docs.unity3d.com/Manual/MetaPass.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgf7bc968" class="outline-6">
<h6 id="orgf7bc968">Deferred Path 模式下，FrameDebug 中发现没有设置 unity_Lightmap unity_LightmapInd 参数</h6>
<div class="outline-text-6" id="text-orgf7bc968">
<p>
宏定义写错了 DEFERRED_PASS 写成了 DEFFERRED_PASS。导致采样 unity_Lightmap unity_LightmapInd 的代码没有执行到，所以引擎没将图片传给 GPU。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8b8c1f0" class="outline-4">
<h4 id="org8b8c1f0">Mixed Lighting</h4>
<div class="outline-text-4" id="text-org8b8c1f0">
</div>
<div id="outline-container-orgd31cd8c" class="outline-5">
<h5 id="orgd31cd8c">烘培光照贴图的优缺点</h5>
<div class="outline-text-5" id="text-orgd31cd8c">
</div>
<div id="outline-container-org76c232a" class="outline-6">
<h6 id="org76c232a">缺点</h6>
<div class="outline-text-6" id="text-org76c232a">
<ul class="org-ul">
<li>无法烘培高光<br /></li>
<li>烘培光照只能通过 LightProbe 对动态物体产生影响<br /></li>
<li>烘培光照无法生成实时阴影<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgfc6aa3e" class="outline-6">
<h6 id="orgfc6aa3e">优点</h6>
<div class="outline-text-6" id="text-orgfc6aa3e">
<ul class="org-ul">
<li>烘培光照包含间接光照，实时光照不包含间接光照。间接光照可以极大提升场景的真实感。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge72fd66" class="outline-5">
<h5 id="orge72fd66">Baking Indirect Light</h5>
<div class="outline-text-5" id="text-orge72fd66">
<p>
实时光照和烘培光照各有优缺点，通过下面方式可以将实时光照和烘培光照结合使用。<br />
</p>
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Baked Indirect<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，烘培光照贴图时会发生两个变化：<br />
</p>
<ol class="org-ol">
<li>lightmapper 只会将间接光照存储到光照贴图中，所以此时的光照贴图比之前要暗一些。<br /></li>
<li>lightmap 只用于为静态物体提供间接光照，静态物体的直接光照也由场景中灯光实时提供；动态物体间接光由 light probe 提供，直接光照由场景中灯光实时提供。<br /></li>
</ol>

<p>
注意:<br />
在上面的设置下，静态物体也需要实时画阴影贴图。这种模式相当于实时光照的工作再加上光照贴图实现的间接光照，所以这种模式是比较消耗性能的。<br />
</p>
</div>
</div>
<div id="outline-container-orga74f0af" class="outline-5">
<h5 id="orga74f0af">Using a Shadowmask</h5>
<div class="outline-text-5" id="text-orga74f0af">
<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Baked<br /></li>
</ol>
<p>
这样设置时，并不会生产 shadowmask，此时相当于完全烘培 （相当于 Light=Baked LightingMode=BakedIndirect 设置下的烘培）。<br />
</p>

<ol class="org-ol">
<li>Lighting/Mixed Lighting/Lighting Mode 设置为 Shadowmask<br /></li>
<li>场景中 Light 组件 Mode 选择 Mixed<br /></li>
</ol>
<p>
这样设置时，间接光照和 mixed lights 的阴影 attenuation 都会存储到光照贴图中，阴影会存储到单独的一张 shadowmask 贴图中。<br />
如果只有 1 盏灯那么 shadowmask 只会占 r 通道，shadowmask 最多 4 个通道，所以最多可以支持 4 盏灯。<br />
</p>

<p>
这种模式比 MixedLight+BakedIndirect 的优势在于静态物体不需要实时画阴影。<br />
</p>
</div>
<div id="outline-container-org1af958f" class="outline-6">
<h6 id="org1af958f">Sampling the Shadowmask</h6>
<div class="outline-text-6" id="text-org1af958f">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowFade</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">float</span> atten)
{
<span style="color: #bc6ec5;">#if</span> HANDLE_SHADOWS_BLENDING_IN_GI
    <span style="color: #ce537a; font-weight: bold;">float</span> viewZ = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - i.worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> shadowFadeDistance = UnityComputeShadowFadeDistance(i.worldPos, viewZ);
    <span style="color: #ce537a; font-weight: bold;">float</span> sFade = UnityComputeShadowFade(shadowFadeDistance);
    <span style="color: #ce537a; font-weight: bold;">float</span> bakedAtten = UnitySampleBakedOcclusion(i.lightmapUV, i.worldPos);
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(atten, bakedAtten, sFade);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_OcclusionMaskSelector &#35813;&#21521;&#37327;&#21482;&#26377;&#19968;&#20010;&#20998;&#37327;&#20250;&#34987;&#35774;&#32622;&#20026;1&#65292;&#29992;&#20110;&#21305;&#37197;&#24403;&#21069;&#34987;&#28210;&#26579;&#30340;&#28783;&#20809;</span>
<span style="color: #ce537a; font-weight: bold;">fixed</span> <span style="color: #bc6ec5; font-weight: bold;">UnitySampleBakedOcclusion</span> (<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos) {
<span style="color: #bc6ec5;">#if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_ON)
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D_SAMPLER(unity_ShadowMask, unity_Lightmap, lightmapUV.xy);
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #ce537a; font-weight: bold;">fixed4</span> rawOcclusionMask = UNITY_SAMPLE_TEX2D(unity_ShadowMask, lightmapUV.xy);
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(<span style="color: #4f97d7;">dot</span>(rawOcclusionMask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 1.0;
<span style="color: #bc6ec5;">#endif</span>
}

<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">half</span> UnityMixRealtimeAndBakedShadows (<span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> bakedShadowAttenuation, <span style="color: #ce537a; font-weight: bold;">half</span> fade)
{
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26080;&#23454;&#21160;&#24577;&#38452;&#24433;&#26102;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
<span style="color: #bc6ec5;">#if</span> !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; !defined(SHADOWS_CUBE)
    <span style="color: #4f97d7; font-weight: bold;">return</span> bakedShadowAttenuation;
<span style="color: #bc6ec5;">#endif</span>

<span style="color: #bc6ec5;">#if</span> defined (SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #if</span> defined (LIGHTMAP_SHADOW_MIXING)
        realtimeShadowAttenuation = <span style="color: #4f97d7;">saturate</span>(realtimeShadowAttenuation + fade);
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">min</span>(realtimeShadowAttenuation, bakedShadowAttenuation);
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">shadowFadeDistance&#33539;&#22260;&#20869;&#65292;&#20351;&#29992;sFadeFactor&#22312;&#23454;&#26102;&#38452;&#24433;&#21644;&#28888;&#22521;&#38452;&#24433;&#20043;&#38388;&#25554;&#20540;</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36229;&#20986;shadowFadeDistance&#21518;&#65292;&#30452;&#25509;&#20351;&#29992;&#28888;&#22521;&#30340;attenuation</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">lerp</span>(realtimeShadowAttenuation, bakedShadowAttenuation, fade);
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#else</span> <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">no shadowmask &#27809;&#26377;&#20351;&#29992;shadowmask&#26102;&#65292;&#20351;&#29992;&#23454;&#26102;&#38452;&#24433;atten+shadowFadeFactor</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">saturate</span>(realtimeShadowAttenuation + fade);
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org476c3c2" class="outline-6">
<h6 id="org476c3c2">Support Deferred Path</h6>
<div class="outline-text-6" id="text-org476c3c2">
<p>
DeferredShading 中将 ShadowMask 写入到 GBuffer4 中<br />
DeferredLighting 中读取 GBuffer4 内容，对直接光照进行衰减<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredShading (MixedLighting.shader)</span>

<span style="color: #4f97d7; font-weight: bold;">struct</span> frag_output
{
<span style="color: #bc6ec5;">#if</span> defined(DEFERRED_PASS)
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer0 : <span style="color: #a45bad;">SV_Target0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer1 : <span style="color: #a45bad;">SV_Target1</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer2 : <span style="color: #a45bad;">SV_Target2</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer3 : <span style="color: #a45bad;">SV_Target3</span>;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
        <span style="color: #ce537a; font-weight: bold;">float4</span> gBuffer4 : <span style="color: #a45bad;">SV_Target4</span>;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #ce537a; font-weight: bold;">float4</span> color : <span style="color: #a45bad;">SV_Target</span>;
<span style="color: #bc6ec5;">#endif</span>
};

frag_output <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f i)
{
    frag_output output;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWSMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT&gt;4)
        <span style="color: #ce537a; font-weight: bold;">float2</span> shadowUV = 0;
<span style="color: #bc6ec5;">        #if</span> defined(LIGHTMAP_ON)
        shadowUV = i.lightmapUV;
<span style="color: #bc6ec5;">        #endif</span>
        output.gBuffer4 = UnityGetRawBakedOcclusions(shadowUV, i.worldPos.xyz);
<span style="color: #bc6ec5;">    #endif</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DeferredLighting (MixedLighting_DeferredLighting.shader)</span>
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetShadowMaskAttenuation</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK)
    <span style="color: #ce537a; font-weight: bold;">float4</span> mask = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_CameraGBufferTexture4</span>, uv);
    atten = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(mask, unity_OcclusionMaskSelector));
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> atten;
}

UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> uv, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float</span> viewZ)
{
    UnityLight light;
    <span style="color: #ce537a; font-weight: bold;">float</span> atten = 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> sAtten = 1;
    <span style="color: #ce537a; font-weight: bold;">float</span> sFade = GetShadowFade(worldPos, viewZ);
    <span style="color: #ce537a; font-weight: bold;">bool</span> shadowed = <span style="color: #a45bad;">false</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #if</span> defined(SHADOWS_SHADOWMASK)
        shadowed = <span style="color: #a45bad;">true</span>;
<span style="color: #bc6ec5;">    #endif</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (shadowed)
    {
        <span style="color: #ce537a; font-weight: bold;">float</span> smAtten = GetShadowMaskAttenuation(uv);
        sAtten = UnityMixRealtimeAndBakedShadows(sAtten, smAtten, sFade);
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">sAtten = saturate(sAtten + sFade);</span>
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
<span style="color: #bc6ec5;">            #if</span> !defined(SHADOWS_SHADOWMASK)
            UNITY_BRANCH
            <span style="color: #4f97d7; font-weight: bold;">if</span> (sFade &gt; 0.99)
            {
                sAtten = 1;
            }
<span style="color: #bc6ec5;">            #endif</span>
<span style="color: #bc6ec5;">        #endif</span>
    }
    light.color = <span style="color: #7590db;">_LightColor</span>.rgb * atten * sAtten;
    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org16cc4da" class="outline-6">
<h6 id="org16cc4da">Distance Shadowmask Mode</h6>
<div class="outline-text-6" id="text-org16cc4da">
<p>
Unity2017 版本之前 Distance Shadowmask 在 Lighting Setting 中设置，Unity2017 版本以及之后版本在 QualitySettings 中设置。<br />
</p>

<p>
注意：<br />
这种模式下，ShadowDistance 外使用 ShadowMask（相当于 ShadowMask 模式），ShadowDistance 内使用实时阴影（相当于 MixedLight+BakedIndirect）。所以这种模式也是比较消耗性能的。<br />
</p>
</div>
</div>
<div id="outline-container-org2383d54" class="outline-6">
<h6 id="org2383d54">Multiple Lights</h6>
<div class="outline-text-6" id="text-org2383d54">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">ForwardAdd Pass &#28155;&#21152;&#22914;&#19979;&#20195;&#30721;&#65292;UNITY_LIGHT_ATTENUATION &#23601;&#21487;&#20197;&#27491;&#30830;&#24037;&#20316;&#20102;</span>
<span style="color: #bc6ec5;">#pragma</span> multi_compile _ SHADOWS_SHADOWMASK
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org294822e" class="outline-5">
<h5 id="org294822e">Subtractive Shadows</h5>
<div class="outline-text-5" id="text-org294822e">
</div>
<div id="outline-container-org700693d" class="outline-6">
<h6 id="org700693d">简介</h6>
<div class="outline-text-6" id="text-org700693d">
<p>
Subtractive mode 只适用于 forward path。Subtractive Mode 的理念是静态物体依然通过 lightmaps 照亮，并且同时将动态物体的阴影因素考虑进去，这是通过减低阴影区域光照贴图的亮度来实现的。<br />
Subtractive mode 只适用于一个方向光，因此只支持主方向光的阴影。<br />
</p>
</div>
</div>
<div id="outline-container-org5f929ae" class="outline-6">
<h6 id="org5f929ae">实现</h6>
<div class="outline-text-6" id="text-org5f929ae">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
<span style="color: #bc6ec5;">    #if</span> defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
<span style="color: #bc6ec5;">    #define</span> SUBTRACTIVE_LIGHTING 1
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>

UnityLight <span style="color: #bc6ec5; font-weight: bold;">CreateLight</span> (Interpolators i)
{
    UnityLight light;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Subtractive&#27169;&#24335;&#19979;&#65292;&#38745;&#24577;&#29289;&#20307;&#30340;&#30452;&#25509;&#20809;&#29031;&#37117;&#34987;&#28888;&#22521;&#21040;lightmap&#20013;&#20102;&#65292;&#19981;&#38656;&#35201;&#35745;&#31639;&#30452;&#25509;&#20809;&#29031;</span>
<span style="color: #bc6ec5;">    #if</span> defined(DEFERRED_PASS)  || SUBTRACTIVE_LIGHTING
        light.dir = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
        light.color = 0;
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> light;
}

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
{
<span style="color: #bc6ec5;">#if</span> SUBTRACTIVE_LIGHTING
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
    attenuation = GetShadowFade(i, attenuation);
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = 1;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
    <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
    subtractedLight = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25903;&#25345;ShadowStrength</span>
    subtractedLight = <span style="color: #4f97d7;">lerp</span>(subtractedLight, indirect.diffuse, <span style="color: #7590db;">_LightShadowData</span>.x);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38745;&#24577;&#29289;&#20307;&#19978;&#28888;&#22521;&#30340;&#38452;&#24433;&#20063;&#20250;&#26174;&#31034;unity_ShadowColor.rgb&#39068;&#33394;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">indirect.diffuse = indirect.diffuse;</span>

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21482;&#20462;&#25913;&#21160;&#24577;&#29289;&#20307;&#22312;&#38745;&#24577;&#29289;&#20307;&#19978;&#25237;&#23556;&#30340;&#38452;&#24433;</span>
    indirect.diffuse = <span style="color: #4f97d7;">min</span>(subtractedLight, indirect.diffuse);
<span style="color: #bc6ec5;">#endif</span>
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaa5cc02" class="outline-5">
<h5 id="orgaa5cc02">总结</h5>
<div class="outline-text-5" id="text-orgaa5cc02">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Realtime</th>
<th scope="col" class="org-left">Baked</th>
<th scope="col" class="org-left">Mixed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BakedIndirect - Dynamic Object</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">BakedIndirect - Static Object</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Shadowmask</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">DistanceShadowmask</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Subtractive</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org18028c2" class="outline-5">
<h5 id="org18028c2">Q&amp;A</h5>
<div class="outline-text-5" id="text-org18028c2">
</div>
<div id="outline-container-orge273f47" class="outline-6">
<h6 id="orge273f47"><span class="todo TODO">TODO</span> 如果烘培灯光和实时灯光分开，烘培灯光的 Mode 使用 Baked，实时灯光的 Mode 使用 Realtime，这样做是否合理？</h6>
</div>
<div id="outline-container-orgf121e74" class="outline-6">
<h6 id="orgf121e74">烘培灯光的情况下，如何解决静态物体无法在动态的物体上投影的问题？</h6>
</div>
<div id="outline-container-org2981309" class="outline-6">
<h6 id="org2981309">ERROR: Deferred Path 模式下，点击 Generate Lighting 没有烘培出光照贴图</h6>
<div class="outline-text-6" id="text-org2981309">
<p>
关闭 Unity，重新打开，可以解决该问题。<br />
</p>
</div>
</div>
<div id="outline-container-org3c21efa" class="outline-6">
<h6 id="org3c21efa">Deferred Path 模式下的间接光照计算是怎样的？</h6>
<div class="outline-text-6" id="text-org3c21efa">
<p>
indirect.diffuse DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。<br />
indirect.specular 的计算则分是否开启屏幕空间反射，不开启时，DeferredPath 和 ForwardPath 计算相同，会将结果直接写入 GBuffer3 中。开启时，则在屏幕空间反射时计算。<br />
</p>
</div>
</div>
<div id="outline-container-orgf849f48" class="outline-6">
<h6 id="orgf849f48">Error: 阴影轮廓处有光晕</h6>
<div class="outline-text-6" id="text-orgf849f48">
<p>
<img src="./UnityCatLikeCoding/01_17ml_shadow_error.png" alt="01_17ml_shadow_error.png" /><br />
经过检查发现是计算 Normal 时有错误，在下面代码的注释中有具体说明<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">float3</span> <span style="color: #bc6ec5; font-weight: bold;">GetNormal</span>(v2f i)
{
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal = <span style="color: #ce537a; font-weight: bold;">float3</span>(0, 1, 0);
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_NORMAL_ON</span>)
    normal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_NormalMap</span>, i.uv).wy * 2 - 1;
    normal.xy *= <span style="color: #7590db;">_BumpScale</span>;
    normal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(normal.xy, normal.xy)));
    normal = normal.xzy;
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">_NORMALDETAIL_ON</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> detailNormal;
    detailNormal.xy = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DetailNormal</span>, i.uv).wy * 2 - 1;
    detailNormal.xy *= <span style="color: #7590db;">_BumpScale</span>;
    detailNormal.z = <span style="color: #4f97d7;">sqrt</span>(1 - <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(detailNormal.xy, detailNormal.xy)));
    detailNormal = <span style="color: #4f97d7;">lerp</span>(<span style="color: #ce537a; font-weight: bold;">float3</span>(0,1,0), detailNormal.xzy, GetDetailMask(i));

    normal.x = normal.x + detailNormal.x;
    normal.y = normal.y * detailNormal.y;
    normal.z = normal.z + detailNormal.z;
<span style="color: #bc6ec5;">#endif</span>
    normal = <span style="color: #4f97d7;">normalize</span>(normal);

<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>
<span style="color: #bc6ec5;">#if</span> defined(<span style="color: #7590db;">__CALC_WORLDSPACE_NORMAL</span>)
    <span style="color: #ce537a; font-weight: bold;">float3</span> wTangent = i.tangentToWorld[0];
    <span style="color: #ce537a; font-weight: bold;">float3</span> wBinormal = i.tangentToWorld[1];
    <span style="color: #ce537a; font-weight: bold;">float3</span> wNormal = i.tangentToWorld[2];
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#20195;&#30721;&#24050;&#32463;&#23558;normal&#21521;&#19978;&#30340;&#20998;&#37327;&#20174;z&#25442;&#21040;&#20102;y&#65292;&#25152;&#20197;&#36825;&#37324;&#21644;wNormal&#30456;&#20056;&#30340;&#24212;&#35813;&#26102;normal&#30340;y&#20998;&#37327;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">normal = normalize(wTangent*normal.x + wBinormal*normal.y + wNormal*normal.z);</span>
    normal = <span style="color: #4f97d7;">normalize</span>(wTangent*normal.x + wNormal*normal.y + wBinormal*normal.z);
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> normal;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga6c6dbf" class="outline-6">
<h6 id="orga6c6dbf">Error: Subtractive 模式下动态物体的阴影很淡</h6>
<div class="outline-text-6" id="text-orga6c6dbf">

<div class="figure">
<p><img src="./UnityCatLikeCoding/01_17ml_subtractive_dynamicObj_shadow_error.png" alt="01_17ml_subtractive_dynamicObj_shadow_error.png" /><br />
</p>
</div>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">ApplySubtractiveLighting</span>(v2f i, <span style="color: #4f97d7; font-weight: bold;">inout</span> UnityIndirect indirect)
{
<span style="color: #bc6ec5;">#if</span> SUBTRACTIVE_LIGHTING
    UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos.xyz);
    attenuation = GetShadowFade(i, attenuation);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;&#39030;&#28857;&#23646;&#24615;&#25554;&#20540;&#24471;&#21040;&#30340;normal&#35745;&#31639;&#25152;&#24471;&#30340;&#38452;&#24433;&#38750;&#24120;&#28129; &#21457;&#29616;&#26159;&#22240;&#20026;&#27809;&#26377;&#23545;&#25554;&#20540;&#21518;&#30340;normal&#36827;&#34892;&#21333;&#20301;&#21270;&#23548;&#33268;&#30340;&#12290;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">float ndotl = saturate(dot(i.worldNormal, _WorldSpaceLightPos0.xyz));</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> ndotl = <span style="color: #4f97d7;">saturate</span>(<span style="color: #4f97d7;">dot</span>(<span style="color: #4f97d7;">normalize</span>(i.worldNormal), <span style="color: #7590db;">_WorldSpaceLightPos0</span>.xyz));
    <span style="color: #ce537a; font-weight: bold;">float3</span> needMinusLight = ndotl * <span style="color: #7590db;">_LightColor0</span>.rgb * (1 - attenuation);
    <span style="color: #ce537a; font-weight: bold;">float3</span> subtractedLight = indirect.diffuse - needMinusLight;
    indirect.diffuse = <span style="color: #4f97d7;">max</span>(subtractedLight, unity_ShadowColor.rgb);
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org701ca69" class="outline-4">
<h4 id="org701ca69">RealtimeGI ProbeVolumes LOD Groups</h4>
<div class="outline-text-4" id="text-org701ca69">
</div>
<div id="outline-container-orgbda86b2" class="outline-5">
<h5 id="orgbda86b2">Realtime Globall Illumination</h5>
<div class="outline-text-5" id="text-orgbda86b2">
</div>
<div id="outline-container-org8a1ed55" class="outline-6">
<h6 id="org8a1ed55">简介</h6>
<div class="outline-text-6" id="text-org8a1ed55">
<p>
烘培光照虽然对静态几何体(通过光照贴图)和动态几何体(通过光照探针)起作用，但是烘培光照无法处理动态光照(Realtime Mode Light)。Mixed Mode Light 可以实时调节一些参数，但是过多的调整会让没有改变的烘培间接光照变得很明显。所以，当你有一个室外的场景时，太阳是不能改变的，它不能像真实生活中一样东升西落在空中穿行，因为这需要不断改变全局照明，所以只能让场景冻结在某个时间点上。<br />
为了让间接光照支持光照方向的实时改变，Unity 使用 Enlighten 系统来计算实时全局照明。其就像烘培间接光一样工作，不同的是 Enlighten 实在运行时计算光照贴图和光照探针的。<br />
计算间接光在需要知道光照在静态表面之间是如何弹射的，也就是需要知道哪些表面有可能会被哪些表面在哪些角度上产生影响。计算出这些关系需要很多工作，不可能在运行时完成。所以，这些数据是由编辑器计算并存储起来，运行时 Enlighten 会利用这些数据来计算光照贴图和光照探针。即使如此，实时全局照明也适用于低分辨率的光照贴图。<br />
</p>
</div>
</div>

<div id="outline-container-org53e80a3" class="outline-6">
<h6 id="org53e80a3">Baking Realtime GI</h6>
<div class="outline-text-6" id="text-org53e80a3">
<p>
Realtime GI 使用自己的 lightmap 坐标，Unity 会基于光照贴图和物体的设置自动生成这些 UV 坐标，这些 UV 坐标值被存储到 Mesh 的第三套 UV 通道。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader">v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span>(appdata v)
{
    v2f o;
    UNITY_INITIALIZE_OUTPUT(v2f, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_LightmapST &#26159;&#28888;&#22521;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_DynamicLightmapST&#26159;&#21160;&#24577;&#20809;&#29031;&#36148;&#22270;UV&#30340;&#20559;&#31227;&#21644;&#32553;&#25918;</span>
    o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);

    o.uv.xy = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_MainTex</span>);
    o.uv.zw = TRANSFORM_TEX(v.uv, <span style="color: #7590db;">_DetailTex</span>);
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMetaVertexPosition</span> (<span style="color: #ce537a; font-weight: bold;">float4</span> vertex, <span style="color: #ce537a; font-weight: bold;">float2</span> uv1, <span style="color: #ce537a; font-weight: bold;">float2</span> uv2, <span style="color: #ce537a; font-weight: bold;">float4</span> lightmapST, <span style="color: #ce537a; font-weight: bold;">float4</span> dynlightmapST)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;unity_MetaVertexControl&#26469;&#25511;&#21046;&#24403;&#21069;&#25805;&#20316;&#30340;&#26159;&#28888;&#22521;&#20809;&#29031;GI&#36824;&#26159;&#21160;&#24577;&#20809;&#29031;GI</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.x)
    {
        vertex.xy = uv1 * lightmapST.xy + lightmapST.zw;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL right now needs to actually use incoming vertex position,</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">so use it in a very dummy way</span>
        vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
    }
    <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_MetaVertexControl.y)
    {
        vertex.xy = uv2 * dynlightmapST.xy + dynlightmapST.zw;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">OpenGL right now needs to actually use incoming vertex position,</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">so use it in a very dummy way</span>
        vertex.z = vertex.z &gt; 0 ? 1.0e-4f : 0.0f;
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityObjectToClipPos</span>(vertex);
}
</pre>
</div>
<p>
注意：<br />
烘培光照贴图和实时光照贴图都会用到 meta pass。所以当开启实时 GI 时，在打包的时候 meta pass 也会被包含进去。<br />
</p>
</div>

<ul class="org-ul">
<li><a id="org8a41b13"></a>为什么 Realtime GI 不公用静态光照贴图的模型 UV？<br /></li>
</ul>
</div>
<div id="outline-container-org64f567e" class="outline-6">
<h6 id="org64f567e">Sampling Realtime Lightmaps</h6>
<div class="outline-text-6" id="text-org64f567e">
<p>
所有的实时灯光都会对实时 GI 有贡献。但是，典型的用法是，只将主方向光作用于实时 GI，因为主方向光代表着太阳，其会在天空中移动。实时 GI 的所有功能对方向光都是有效的，实时 GI 不支持点光源和 SpotLight 的阴影。因此，当使用会投影的点光源和 SpotLight 时，最终会得到不正确的间接光照。<br />
如果你想将某个实时光从实时 GI 中排除，只需要将该灯光的 IndirectMultiplier 设置为 0。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader">UnityIndirect <span style="color: #bc6ec5; font-weight: bold;">CreateIndirect</span>(v2f i, <span style="color: #ce537a; font-weight: bold;">half3</span> viewDir, <span style="color: #ce537a; font-weight: bold;">float</span> smoothness)
{
    <span style="color: #ce537a; font-weight: bold;">float</span> occlusion = GetOcclusion(i);
    UnityIndirect indirect;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
<span style="color: #bc6ec5;">#if</span> defined(DYNAMICLIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21160;&#24577;Lightmap&#20351;&#29992;&#20102;&#21644;&#38745;&#24577;Lightmap&#19981;&#21516;&#30340;&#39068;&#33394;&#26684;&#24335;&#65292;&#38656;&#35201;&#19981;&#21516;&#30340;&#35299;&#30721;</span>
    <span style="color: #ce537a; font-weight: bold;">float3</span> dynamicLightDiffuse = DecodeRealtimeLightmap(UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, i.dynamicLightmapUV));
<span style="color: #bc6ec5;">    #if</span> defined(DIRLIGHTMAP_COMBINED)
        <span style="color: #ce537a; font-weight: bold;">float4</span> dynamicLightmapDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_DynamicDirectionality, unity_DynamicLightmap,i.dynamicLightmapUV);
        indirect.diffuse += DecodeDirectionalLightmap(dynamicLightDiffuse, dynamicLightmapDir, GetNormal(i));
<span style="color: #bc6ec5;">    #else</span>
        indirect.diffuse += dynamicLightDiffuse;
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>
<span style="color: #bc6ec5;">#if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809;</span>
    indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">#endif</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbe6c70c" class="outline-6">
<h6 id="orgbe6c70c">Emissive Light</h6>
<div class="outline-text-6" id="text-orgbe6c70c">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> EmissiveOscillator : MonoBehaviour
{
    Renderer r;
    <span style="color: #4f97d7; font-weight: bold;">Material</span> mat;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Start</span>()
    {
        r = GetComponent&lt;Renderer&gt;();
        mat = r.material;
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Update</span>()
    {
        <span style="color: #4f97d7; font-weight: bold;">Color</span> c = <span style="color: #4f97d7; font-weight: bold;">Color</span>.Lerp(<span style="color: #4f97d7; font-weight: bold;">Color</span>.white, <span style="color: #4f97d7; font-weight: bold;">Color</span>.black, Mathf.Sin(Time.time * Mathf.PI) * 0.5f + 0.5f);
        mat.SetColor(<span style="color: #2d9574;">"_EmissionColor"</span>, c);

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#23454;&#26102;GI</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#20250;&#35302;&#21457;&#20351;&#29992;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">r.UpdateGIMaterials();</span>

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#19981;&#20250;&#35302;&#21457;MetaPass&#28210;&#26579;&#29289;&#20307;&#65292;&#21482;&#26159;&#30452;&#25509;&#23558;EmissionColor&#20256;&#36882;&#32473;Enlighten</span>
        DynamicGI.SetEmissive(r, c);
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2953505" class="outline-5">
<h5 id="org2953505">Light Probe Proxy Volumes</h5>
<div class="outline-text-5" id="text-org2953505">
<p>
烘培 GI 和实时 GI 都是通过 LightProbe 作用于动态物体的。物体的位置用于插值 LightProbe 数据，插值得到的数据再应用于 GI。这对于小物体来说是可行的，但是对于大物体来说就太粗暴了。<br />
</p>

<p>
LLPV（light probe proxy volume）可以解决该问题。其会传递给 shader 一组经过插值的 LightProbe 数据，而不是一个。这些数据会存储到一张浮点型 3D 贴图中，且该贴图需要支持线性过滤模式，只有现代图形显卡才能支持。<br />
在 Graphics/TierSettings/EnableLightProbeProxyVolume 中开启 LightProbeProxyVolume。<br />
</p>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#if</span> !defined(LIGHTMAP_ON) &amp;&amp; !defined(DYNAMICLIGHTMAP_ON)
<span style="color: #bc6ec5;">    #if</span> UNITY_LIGHT_PROBE_PROXY_VOLUME
        <span style="color: #4f97d7; font-weight: bold;">if</span> (unity_ProbeVolumeParams.x == 1)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Light Probe Proxy Volume &#21482;&#20351;&#29992;&#20102;&#20004;&#20010;&#22522;&#24102;</span>
            indirect.diffuse = SHEvalLinearL0L1_SampleProbeVolume(<span style="color: #ce537a; font-weight: bold;">float4</span>(i.worldNormal, 1), i.worldPos);
            indirect.diffuse = <span style="color: #4f97d7;">max</span>(0, indirect.diffuse);
<span style="color: #bc6ec5;">            #if</span> defined(UNITY_COLORSPACE_GAMMA)
                indirect.diffuse = LinearToGammaSpace(indirect.diffuse);
<span style="color: #bc6ec5;">            #endif</span>
        }
        <span style="color: #4f97d7; font-weight: bold;">else</span>
        {
            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809; LightProbe ShadeSH9&#20013;&#24050;&#32463;&#22788;&#29702;&#20102;&#39068;&#33394;&#31354;&#38388;&#30340;&#38382;&#39064;</span>
            indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
        }
<span style="color: #bc6ec5;">    #else</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21472;&#21152;&#29615;&#22659;&#20809; LightProbe</span>
        indirect.diffuse += <span style="color: #4f97d7;">max</span>(0, ShadeSH9(<span style="color: #ce537a; font-weight: bold;">half4</span>(i.worldNormal, 1)));
<span style="color: #bc6ec5;">    #endif</span>
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0d9725b" class="outline-5">
<h5 id="org0d9725b">LOD Groups</h5>
<div class="outline-text-5" id="text-org0d9725b">
</div>
<div id="outline-container-org85f0fef" class="outline-6">
<h6 id="org85f0fef">Baked GI and Lod Group</h6>
<div class="outline-text-6" id="text-org85f0fef">
<p>
在烘培静态光照贴图时，使用的是 LOD0。即使在运行时显示的是 LOD1，此时阴影和间接光照都是烘培 LOD0 所得数据。<br />
但是 LOD1 依然会使用 lightmap，其采样的数据和 LOD0 采样的数据并不同(分布在 lightmap 贴图的不同位置)，Unity 利用烘培的 LightProbe 来计算 LOD1 的间接光照，所以烘培带有 LOD 的场景时，需要添加 LightProbe，否则 LOD1 的间接光照会变为黑色，从而显得很暗。<br />
下图是，开启 LightProbe 和关闭 LightProbe 烘焙场景得到的不同效果:<br />
</p>

<p>
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withoutLightProbe.png" alt="01_18ml_lodGroup_bake_withoutLightProbe.png" /><br />
<img src="./UnityCatLikeCoding/01_18ml_lodGroup_bake_withLightProbe.png" alt="01_18ml_lodGroup_bake_withLightProbe.png" /><br />
</p>
</div>
</div>
<div id="outline-container-org6293ddf" class="outline-6">
<h6 id="org6293ddf">Realtime GI and Lod Group</h6>
<div class="outline-text-6" id="text-org6293ddf">
<p>
当只开启 Realtime GI 时，在运行时 Lod0 依然使用实时烘培的光照贴图，而 Lod1 会使用 LightProbe 数据(运行时，选中显示 Lod1 的物体，SceneView 下可以看到其使用的 LightProbe)。<br />
在同时使用 RealtimeGI 和 BakedGI 时，Lod0 会同时使用 Realtime Lightmap 和 Baked Lightmap，而 Lod1 只会使用 Baked Lightmap，因为 lightmap 和球谐光照无法同时使用。<br />
</p>

<p>
注意：烘培和渲染 Lod 是完全独立的，如果实时 GI 比烘培 GI 更重要，可以在运行时设置 LOD1 为非 lightmap-static，这样 LOD1 就会使用 Realtime GI 的 LightProbe。<br />
</p>
</div>
</div>
<div id="outline-container-orgf404f1e" class="outline-6">
<h6 id="orgf404f1e">Cross-fading Between Lod Levels</h6>
<div class="outline-text-6" id="text-orgf404f1e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #bc6ec5;">#pragma</span> multi_compile _ LOD_FADE_CROSSFADE

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">4*64 &#22823;&#23567;&#36148;&#22270;</span>
<span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_DitherMaskLOD2D</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UnityApplyDitherCrossFade</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> vpos)
{
    vpos /= 4; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the dither mask texture is 4x4</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">unity_LODFade&#21464;&#37327;&#23384;&#20648;&#20102;&#24403;&#21069;fade&#30340;&#24635;&#37327;&#65292;&#25972;&#20010;&#36807;&#31243;&#19968;&#20849;16&#27493;(fade&#19968;&#27493;&#30340;&#20540;&#20026;1/16)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">quantized lod fade by 16 levels</span>
    vpos.y = <span style="color: #4f97d7;">frac</span>(vpos.y) * 0.0625 <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">1/16 */</span> + unity_LODFade.y;
    <span style="color: #4f97d7;">clip</span>(<span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_DitherMaskLOD2D</span>, vpos).a - 0.5);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org66028d3" class="outline-6">
<h6 id="org66028d3">Q&amp;A</h6>
<div class="outline-text-6" id="text-org66028d3">
</div>
<ul class="org-ul">
<li><a id="org42536ee"></a><span class="todo TODO">TODO</span> 为什么不将 LOD1 像 LOD0 那样处理，再渲染一次 LOD1 得到精确的亮度数据写入光照贴图中？<br /></li>
<li><a id="org8aa1c48"></a><span class="todo TODO">TODO</span> 为什么球谐光照和 lightmap 无法同时使用？<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf1559da" class="outline-4">
<h4 id="orgf1559da">GPU Instancing</h4>
<div class="outline-text-4" id="text-orgf1559da">
</div>
<div id="outline-container-org915d4a7" class="outline-5">
<h5 id="org915d4a7">Batching Instances</h5>
<div class="outline-text-5" id="text-org915d4a7">
</div>
<div id="outline-container-org2ed2b7f" class="outline-6">
<h6 id="org2ed2b7f">简介</h6>
<div class="outline-text-6" id="text-org2ed2b7f">
<p>
向 GPU 提交绘制命令会花费时间。将数据（mesh 和材质属性）提交给 GPU 也会耗费时间。<br />
Static Batching:  Unity 可以将很多静态的物体合并为一个大的静态物体，这可以减少 DrawCall，但是只有使用相同材质的物体才能以这种方式合并。这样做的代价是需要存储更多的 Mesh 数据。<br />
Dynamic Batching: 运行时 Unity 会对动态物体执行类似于 Static Batching 一样的操作，只是其只会将很多比较小的 mesh 合并为一个大的 mesh(动态合并大物体的消耗太大了)。<br />
GPU Instancing:   运行时通知 GPU 绘制同一个 mesh 多次，GPU Instancing 无法将不同的 mesh 或材质合并，但是其并不要求 mesh 必须为小 mesh。<br />
</p>

<ul class="org-ul">
<li>Draw call batching <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">https://docs.unity3d.com/Manual/DrawCallBatching.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4087eda" class="outline-6">
<h6 id="org4087eda">Support GPU Instancing</h6>
<div class="outline-text-6" id="text-org4087eda">
</div>
<ul class="org-ul">
<li><a id="org6a31a7e"></a>支持 GPU Instancing<br />
<div class="outline-text-7" id="text-org6a31a7e">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327;SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;
};

vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    vert_out o;
    UNITY_INITIALIZE_OUTPUT(vert_out, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#27714;&#35299;&#24403;&#21069;&#23454;&#20363;&#30340; Obj2World World2Obj&#30697;&#38453;</span>
    UNITY_SETUP_INSTANCE_ID(v);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
}
</pre>
</div>
</div>
</li>
<li><a id="orgfde7db1"></a>Unity 对 GPU Instancing 的封装<br />
<div class="outline-text-7" id="text-orgfde7db1">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;instanceID</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> uint unity_InstanceID;

CBUFFER_START(UnityDrawCallInfo)
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Where the current batch starts within the instanced arrays.</span>
  <span style="color: #ce537a; font-weight: bold;">int</span> unity_BaseInstanceID;
CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31995;&#32479;&#21464;&#37327;&#21517;&#31216;SV_InstanceID</span>
<span style="color: #bc6ec5;">#define</span> UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;

<span style="color: #bc6ec5;">#define</span> UNITY_SETUP_INSTANCE_ID(input) \
  unity_InstanceID = input.instanceID + unity_BaseInstanceID;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Redefine some of the built-in variables /</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">macros to make them work with instancing.</span>
UNITY_INSTANCING_CBUFFER_START(PerDraw0)
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_ObjectToWorldArray[UNITY_INSTANCED_ARRAY_SIZE];
  <span style="color: #ce537a; font-weight: bold;">float4x4</span> unity_WorldToObjectArray[UNITY_INSTANCED_ARRAY_SIZE];
UNITY_INSTANCING_CBUFFER_END

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;instance&#25968;&#25454;&#35206;&#30422;&#21407;&#22987;&#23450;&#20041;&#20869;&#23481;</span>
<span style="color: #bc6ec5;">#define</span> unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
<span style="color: #bc6ec5;">#define</span> unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</pre>
</div>

<p>
forward base pass, shadow pass, deferred pass 都支持 GPU Instancing.<br />
forward add pass 不支持 GPU Instancing.<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2f425f4" class="outline-6">
<h6 id="org2f425f4">Batch Size</h6>
<div class="outline-text-6" id="text-org2f425f4">
<p>
每个 Batch 都需要自己的矩阵数组。这些数据被发送给 GPU，然后被存储在内存缓冲区(D3D 的 ConstantBuffer,OpenGL 的 UniformBuffer)中。这些缓冲区有最大容量限制，这限制了每个 batch 的实例数量。<br />
假设台式机每个 UniformBuffer 的大小为 64KB，一个矩阵有 16 个浮点数，每个浮点数需要 4 字节存储，每个实例需要 1 个 object-to-world 变换矩阵，如果使用了法线贴图，则还需要 1 个 world-to-object 变换矩阵(用于将法线变换到世界空间)<br />
16*4*2 = 128Byte 64KB/128B=64*10240/128=512<br />
</p>

<p>
UNITY_INSTANCED_ARRAY_SIZE 默认被定义为 500, 移动平台下被定义为 250.<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36890;&#36807;&#19979;&#38754;&#30340;&#25351;&#20196;&#21487;&#20197;&#23558;&#23454;&#20363;&#25968;&#37327;&#20462;&#25913;&#20026;512</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options maxcount:512
</pre>
</div>

<ul class="org-ul">
<li>GPUInstancing <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5dab1a8" class="outline-5">
<h5 id="org5dab1a8">Mixing Material Properties</h5>
<div class="outline-text-5" id="text-org5dab1a8">
<p>
所有 DrawCall Batching 都需要物体使用相同的材质。<br />
可以通过 MaterialPropertyBlock 来修改材质属性，从而实现使用相同材质的物体可以有不同的外观，但是通过 MaterialPropertyBlock 修改材质属性，依然会导致 GPU Instancing 失败，因为不同的实例使用了不同的材质属性。<br />
只有在 shader 中定义一个被修改属性的 buffer，Unity 才会将存储在 Material Property Block 中的属性当作数组传递到 GPU(和 Unity 在 GPUInstancing 时对变换矩阵数组的操作一样)，此时 GPU Instancing 才会生效。<br />
MaterialPropertyBlock 支持 Color,Float,Matrix,Vector 类型的属性，如果想支持 Texture 类型，可以使用 TextureArray 然后添加一个 Index 属性将 Index 属性放到 InstancingBuffer 中。<br />
多个属性可以组合放在同一个 Buffer 中，需要注意每个 Buffer 有尺寸限制。另外，Buffer 都是 32 位对齐的，也就是说一个 Float 占用的空间和一个 Vector 占用空间相同。可以使用多个 Buffer，但是 Buffer 的数量也是有限制的，而且 Buffer 也是有性能消耗的。当 GPUInstancing 开启后，每个被放入 Buffer 的属性都会变为一个数组，所以应该只将每个实例都不同的属性放入 Buffer。<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">struct</span> appdata
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> normal : <span style="color: #a45bad;">NORMAL</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> tangent: <span style="color: #a45bad;">TANGENT</span>;
    <span style="color: #ce537a; font-weight: bold;">float2</span> uv1 : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> uv2 : <span style="color: #a45bad;">TEXCOORD2</span>;

};

<span style="color: #4f97d7; font-weight: bold;">struct</span> vert_out
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #ce537a; font-weight: bold;">float4</span> pos : <span style="color: #a45bad;">SV_POSITION</span>;
    <span style="color: #ce537a; font-weight: bold;">float3</span> worldNormal : <span style="color: #a45bad;">TEXCOORD1</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

<span style="color: #4f97d7; font-weight: bold;">struct</span> frag_in
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#31995;&#32479;&#21464;&#37327; SV_InstanceID</span>
    UNITY_VERTEX_INPUT_INSTANCE_ID
    <span style="color: #ce537a; font-weight: bold;">float4</span> uv : <span style="color: #a45bad;">TEXCOORD0</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>
};

vert_out <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata v)
{
    vert_out o;
    UNITY_INITIALIZE_OUTPUT(vert_out, o);
    UNITY_SETUP_INSTANCE_ID(v);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;InstanceID&#20256;&#36882;&#21040;fragment</span>
    UNITY_TRANSFER_INSTANCE_ID(v, o);
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">.......</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">GetAlpha</span>(frag_in i)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992;InstanceID&#33719;&#21462;&#24403;&#21069;&#23454;&#20363;&#30340;&#23646;&#24615;</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> alpha = UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, <span style="color: #7590db;">_Color</span>).a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, i.uv.xy).a * alpha;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shader"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#20250;&#23558; unity_LODFade &#25918;&#20837;Buffer&#65292;&#36825;&#26679;&#22312;&#35774;&#32622;LodFadeMode=CrossFade&#26102;&#65292;GPUInstancing&#19981;&#20250;&#22833;&#25928;</span>
<span style="color: #bc6ec5;">#pragma</span> instancing_options lodfade
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3882fcb" class="outline-4">
<h4 id="org3882fcb">Parallax</h4>
<div class="outline-text-4" id="text-org3882fcb">
</div>
<div id="outline-container-org1f986b9" class="outline-5">
<h5 id="org1f986b9">参考资料</h5>
<div class="outline-text-5" id="text-org1f986b9">
<ul class="org-ul">
<li>Parallax-Mapping <a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">https://learnopengl.com/Advanced-Lighting/Parallax-Mapping</a><br /></li>
<li>Learn about Parallax en <a href="https://github.com/UPBGE/upbge/issues/1009">https://github.com/UPBGE/upbge/issues/1009</a><br /></li>
<li>Learn about Parallax cn <a href="https://zhuanlan.zhihu.com/p/128682162">https://zhuanlan.zhihu.com/p/128682162</a> <br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org982d00e" class="outline-3">
<h3 id="org982d00e">Advanced Rendering</h3>
<div class="outline-text-3" id="text-org982d00e">
</div>
<div id="outline-container-org9d60a92" class="outline-4">
<h4 id="org9d60a92">Flat and Wireframe Shading</h4>
<div class="outline-text-4" id="text-org9d60a92">
</div>
<div id="outline-container-org0a9b99d" class="outline-5">
<h5 id="org0a9b99d">Barycentric Coordinates</h5>
</div>

<div id="outline-container-org658eb34" class="outline-5">
<h5 id="org658eb34">Q&amp;A</h5>
<div class="outline-text-5" id="text-org658eb34">
</div>
<div id="outline-container-org78bff50" class="outline-6">
<h6 id="org78bff50">为什么通过 ddx ddy 方式计算三角面的 normal 物体会完全变黑？</h6>
<div class="outline-text-6" id="text-org78bff50">
<p>
cross 操作需要注意向量的正反方向，将所得向量取反就可以了。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org5863c6e" class="outline-4">
<h4 id="org5863c6e">Tessellation</h4>
<div class="outline-text-4" id="text-org5863c6e">
</div>
<div id="outline-container-org5c74cbc" class="outline-5">
<h5 id="org5c74cbc">Q&amp;A</h5>
<div class="outline-text-5" id="text-org5c74cbc">
</div>
<div id="outline-container-org38ed3eb" class="outline-6">
<h6 id="org38ed3eb">ERROR: 'patchconstantfunc(function name)' attribute expected, where 'function name' is the name of the patch constant value evaluation function at &#x2026;&#x2026;</h6>
<div class="outline-text-6" id="text-org38ed3eb">
<p>
Unity_patchconstantfunc 改为 UNITY_patchconstantfunc 就可以了。<br />
</p>
</div>
</div>

<div id="outline-container-org37ce392" class="outline-6">
<h6 id="org37ce392">ERROR: 'vert': cannot convert from 'struct TessControlPoint' to 'struct appdata'</h6>
<div class="outline-text-6" id="text-org37ce392">
<p>
TessControlPoint 中成员使用了 float 类型，appdata 中使用的 half 类型。使用同一类型就可以了<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7ae509d" class="outline-4">
<h4 id="org7ae509d">Surface Displacement</h4>
</div>
<div id="outline-container-orgc6241cc" class="outline-4">
<h4 id="orgc6241cc">Bloom</h4>
<div class="outline-text-4" id="text-orgc6241cc">
</div>
<div id="outline-container-org1f9c251" class="outline-5">
<h5 id="org1f9c251">利用 Downsampling Upsampling 模糊图片的原理</h5>
<div class="outline-text-5" id="text-org1f9c251">
<ul class="org-ul">
<li><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering">https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation/bilinear-filtering</a><br /></li>
<li><a href="#orgdde54bc">No description for this link</a><br /></li>
<li>高斯模糊 <a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html">http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc0949e1" class="outline-5">
<h5 id="orgc0949e1">Q&amp;A</h5>
<div class="outline-text-5" id="text-orgc0949e1">
</div>
<div id="outline-container-org0576c75" class="outline-6">
<h6 id="org0576c75"><span class="todo TODO">TODO</span> 自定义的 Bloom 如何放到 Builtin Uber 中一起计算？在 Builtin Uber 中一起计算的好处是什么？</h6>
</div>
</div>
</div>

<div id="outline-container-orgdf337d2" class="outline-4">
<h4 id="orgdf337d2">Depth of Field</h4>
<div class="outline-text-4" id="text-orgdf337d2">
</div>
<div id="outline-container-orgbd11ad0" class="outline-5">
<h5 id="orgbd11ad0">Bokeh</h5>
<div class="outline-text-5" id="text-orgbd11ad0">
<p>
CoC(Circal Of Confusion) 决定了 Bokeh 效果在每个点上的强度，Aperture 决定了 Bokeh 的形状。图片是由很多个 Aperture 形状投影到成像平面得到的。<br />
一种创建 Bokeh 的方法是，使用每个图元的颜色为该图元渲染一个 Sprite，Sprite 的大小和不透明度都基于图元的 CoC（这种方式耗费很大，其需要大量的 Overdraw）。（该方法是将一个片段投影到多个片段上）<br />
另一种方式是，每个片段从所有可能影响该片段的图元累加颜色，这种方法不需要额外的几何体，但是需要进行多次贴图采样。<br />
</p>
</div>
</div>

<div id="outline-container-orge77f17e" class="outline-5">
<h5 id="orge77f17e">Q&amp;A</h5>
<div class="outline-text-5" id="text-orge77f17e">
</div>
<div id="outline-container-org113003b" class="outline-6">
<h6 id="org113003b"><span class="todo TODO">TODO</span> 为什么开启 MSAA 的时候，DOF 效果会错误？</h6>
</div>
</div>
</div>
<div id="outline-container-org6160ec3" class="outline-4">
<h4 id="org6160ec3">FXAA</h4>
<div class="outline-text-4" id="text-org6160ec3">
</div>
<div id="outline-container-org2dc801f" class="outline-5">
<h5 id="org2dc801f">SSAA MSAA</h5>
<div class="outline-text-5" id="text-org2dc801f">
<p>
SSAA 通过渲染更大分辨率的画面，通过 Downsampling 来消除锯齿。<br />
MSAA 一个片段中分配多个采样点 N，计算被覆盖的采样点个数 X，从而获得当前片段颜色和片段中原始颜色的混合比例（X/N 为当前片段颜色 N-X/N 为原始颜色）。<br />
</p>

<p>
MSAA 跟 SSAA 不同的地方在于，SSAA 对于所有子采样点着色，而 MSAA 只对当前像素覆盖掩码不为 0 的进行着色，顶点属性在像素的中心进行插值用于在片断程序中着色。这是 MSAA 相对于 SSAA 来说最大的好处。<br />
</p>


<div class="figure">
<p><img src="./UnityCatLikeCoding/02_06fxaa_SMAA.png" alt="02_06fxaa_SMAA.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">GLFW FrameBuffer&#24320;&#21551;MSAA</span>
glfwWindowHint(GLFW_SAMPLES, 4);
glEnable(GL_MULTISAMPLE);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Off-Screen MSAA</span>
<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">CONFIG-BUFFER</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure MSAA framebuffer</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">framebuffer</span>;
glGenFramebuffers(1, &amp;framebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a multisampled color attachment texture</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">textureColorBufferMultiSampled</span>;
glGenTextures(1, &amp;textureColorBufferMultiSampled);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled);
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGB, SCR_WIDTH, SCR_HEIGHT, GL_TRUE);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled, 0);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a (also multisampled) renderbuffer object for depth and stencil attachments</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">rbo</span>;
glGenRenderbuffers(1, &amp;rbo);
glBindRenderbuffer(GL_RENDERBUFFER, rbo);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);
glBindRenderbuffer(GL_RENDERBUFFER, 0);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

glBindFramebuffer(GL_FRAMEBUFFER, 0);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">configure second post-processing framebuffer</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">intermediateFBO</span>;
glGenFramebuffers(1, &amp;intermediateFBO);
glBindFramebuffer(GL_FRAMEBUFFER, intermediateFBO);
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create a color attachment texture</span>
<span style="color: #ce537a; font-weight: bold;">unsigned</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">screenTexture</span>;
glGenTextures(1, &amp;screenTexture);
glBindTexture(GL_TEXTURE_2D, screenTexture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, <span style="color: #a45bad;">NULL</span>);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">we only need a color buffer</span>

glBindFramebuffer(GL_FRAMEBUFFER, 0);

<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">DRAW-CALL</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">render</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">------</span>
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. draw scene as normal in multisampled buffers</span>
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DEPTH_TEST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">set transformation matrices    </span>
shader.use();
<span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span> = <span style="color: #a45bad;">glm</span>::perspective(<span style="color: #a45bad;">glm</span>::radians(camera.Zoom), (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_WIDTH / (<span style="color: #ce537a; font-weight: bold;">float</span>)SCR_HEIGHT, 0.1f, 1000.0f);
shader.setMat4(<span style="color: #2d9574;">"projection"</span>, projection);
shader.setMat4(<span style="color: #2d9574;">"view"</span>, camera.GetViewMatrix());
shader.setMat4(<span style="color: #2d9574;">"model"</span>, <span style="color: #a45bad;">glm</span>::mat4(1.0f));

glBindVertexArray(cubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. now blit multisampled buffer(s) to normal colorbuffer of intermediate FBO. Image is stored in screenTexture</span>
glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. now render quad with scene's visuals as its texture image</span>
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
glDisable(GL_DEPTH_TEST);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">draw Screen quad</span>
screenShader.use();
glBindVertexArray(quadVAO);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, screenTexture); <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">use the now resolved color attachment as the quad's texture</span>
glDrawArrays(GL_TRIANGLES, 0, 6);

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------------------------------------</span>
glfwSwapBuffers(window);
glfwPollEvents();
</pre>
</div>
</div>

<div id="outline-container-org445bc75" class="outline-6">
<h6 id="org445bc75">Q&amp;A</h6>
<div class="outline-text-6" id="text-org445bc75">
</div>
<ul class="org-ul">
<li><a id="orgcbe785f"></a>DepthBuffer 和 StencilBuffer 中的内容经过 MSAA 处理会出错，Unity 是怎么做的？<br />
<div class="outline-text-7" id="text-orgcbe785f">
<p>
MSAA 中一个像素的多个采样点拥有自己的 Depth\Stencil 值。<br />
</p>
</div>
</li>

<li><a id="org7c6191f"></a>为什么 MSAA 每个子采样点需要独立存储颜色和深度？<br />
<div class="outline-text-7" id="text-org7c6191f">
<p>
因为不同的物体可能覆盖同一个像素的不同子采样点。此时该像素会执行两次片段着色器。<br />
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org9da6269" class="outline-6">
<h6 id="org9da6269">参考资料</h6>
<div class="outline-text-6" id="text-org9da6269">
<ul class="org-ul">
<li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing</a><br /></li>
<li>深入剖析 MSAA <a href="https://www.cnblogs.com/ghl_carmack/p/8245032.html">https://www.cnblogs.com/ghl_carmack/p/8245032.html</a><br /></li>
<li><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">https://en.wikipedia.org/wiki/Multisample_anti-aliasing</a><br /></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules</a><br /></li>
<li>对多重采样（MSAA）原理的一些疑问 <a href="https://www.zhihu.com/question/58595055/answer/157756410">https://www.zhihu.com/question/58595055/answer/157756410</a> （如果丢失可以参考有道云笔记备份）<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge5f001b" class="outline-5">
<h5 id="orge5f001b">参考资源</h5>
<div class="outline-text-5" id="text-orge5f001b">
<ul class="org-ul">
<li><a href="http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html">http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbc3a765" class="outline-4">
<h4 id="orgbc3a765">Triplanar Mapping</h4>
<div class="outline-text-4" id="text-orgbc3a765">
</div>
<div id="outline-container-org58d1745" class="outline-5">
<h5 id="org58d1745">求解 Normal</h5>
<div class="outline-text-5" id="text-org58d1745">
</div>
<div id="outline-container-org48b1060" class="outline-6">
<h6 id="org48b1060">TangentNormal</h6>
<div class="outline-text-6" id="text-org48b1060">

<div class="figure">
<p><img src="./UnityCatLikeCoding/02_07tm_CalcNormal.jpg" alt="02_07tm_CalcNormal.jpg" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org6a63b0f" class="outline-6">
<h6 id="org6a63b0f">TangentNormalToWorldNormal WorldNormalToTangentNormal</h6>
<div class="outline-text-6" id="text-org6a63b0f">
<p>
tangentNormal 向上的方向始终为 z，worldNormal 向上的方向随不同投影面而变化。YZ 平面，worldNormal 向上方向在 x 轴方向；XZ 平面，worldNormal 向上在 y 轴方向；XY 平面，worldNormal 向上在 z 轴方向。<br />
tangentNormalX.xyz = worldNormal.zyx  worldNormal 向上的方向为 x 而不是 z，<br />
worldNormal.xyz = tangentNormalX.zyx  tangentNormalX 向上的方向为 z 而不是 x<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae474a1" class="outline-3">
<h3 id="orgae474a1">CustomSRP</h3>
</div>
</div>

<div id="outline-container-org4775f5b" class="outline-2">
<h2 id="org4775f5b">MyTest</h2>
<div class="outline-text-2" id="text-org4775f5b">
</div>
<div id="outline-container-org2b1c321" class="outline-3">
<h3 id="org2b1c321">TestReplaceShader</h3>
<div class="outline-text-3" id="text-org2b1c321">
</div>
<div id="outline-container-org3d95766" class="outline-4">
<h4 id="org3d95766">SetReplacementShader VS RenderWithShader</h4>
<div class="outline-text-4" id="text-org3d95766">
<p>
SetReplacementShader 修改相机渲染物体时对应物体的 shader<br />
RenderWithShader     使用相机进行额外的一次渲染，渲染时修改渲染物体对应的 shader<br />
这两个函数的参数：(Shader shader, string replacementTag)<br />
shader 即将使用的新的 shader.<br />
replacementTag 指定替换条件，具体分如下两种情况：<br />
如果 replacementTag="" 表示直接使用新的 shader。<br />
如果 replacementTag="XX" 表示，假设新 shader 的 Tag 为 Tag{ &#x2026;&#x2026; XX="xx" &#x2026;&#x2026; }，那么旧 shader 中 Tag 有相同的 XX="xx" 键值对则使用新 shader 渲染物体，否则不渲染该物体。<br />
</p>
</div>
</div>

<div id="outline-container-org5d9b0b6" class="outline-4">
<h4 id="org5d9b0b6">Q&amp;A</h4>
<div class="outline-text-4" id="text-org5d9b0b6">
</div>
<div id="outline-container-org2c6791d" class="outline-5">
<h5 id="org2c6791d">Warnning: Attempting to render from camera 'Main Camera' that is currently being used to render. Create a copy of the camera (Camera.CopyFrom) if you wish to do this. UnityEngine.Camera:RenderWithShader(Shader, String)</h5>
<div class="outline-text-5" id="text-org2c6791d">
<p>
在 OnPreRender OnPostRender 中调用 RenderWithShader 时会提示如上警告信息。这是因为引擎对相机的渲染调用还没结束，又对同一相机发出渲染的请求。<br />
在 OnGUI 中调用 RenderWithShader 不会提示如上警告信息。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org3d80cdc" class="outline-3">
<h3 id="org3d80cdc">BilinearFiltering</h3>
<div class="outline-text-3" id="text-org3d80cdc">
<p>
<a id="orgdde54bc"></a><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #bc6ec5; font-weight: bold;">BilinearFilter</span>(<span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c00</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c10</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c01</span>, <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">c11</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">tx</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">ty</span>)
{
<span style="color: #bc6ec5;">#if</span> <span style="color: #a45bad;">false</span>
    <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">a</span> = c00 * (1 - tx) + c10 * tx;
    <span style="color: #ce537a; font-weight: bold;">Color</span> <span style="color: #7590db;">b</span> = c10 * (1 - tx) + c11 * tx;
    <span style="color: #4f97d7; font-weight: bold;">return</span> (a * (1 - ty) + b * ty);
<span style="color: #bc6ec5;">#else</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> 
        (1 - tx) * (1 - ty) * c00 +
        tx * (1 - ty) * c10 +
        (1 - tx) * ty * c01 +
        tx * ty * c11;
<span style="color: #bc6ec5;">#endif</span>
}
</pre>
</div>

<ul class="org-ul">
<li>双线性过滤近似高斯模糊 <a href="https://blog.csdn.net/seizeF/article/details/90543797">https://blog.csdn.net/seizeF/article/details/90543797</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2414a76" class="outline-3">
<h3 id="org2414a76">SphereMapping</h3>
<div class="outline-text-3" id="text-org2414a76">
</div>
<div id="outline-container-org64b1bf3" class="outline-4">
<h4 id="org64b1bf3">参考资料</h4>
<div class="outline-text-4" id="text-org64b1bf3">
<ul class="org-ul">
<li>环境贴图 <a href="http://www.twinklingstar.cn/2014/1322/environment-mapping/">http://www.twinklingstar.cn/2014/1322/environment-mapping/</a><br /></li>
<li>详解球面环境映射 <a href="https://zhuanlan.zhihu.com/p/84494845">https://zhuanlan.zhihu.com/p/84494845</a><br /></li>
<li>Unity Shader-Matcap(材质捕获)使用解析 <a href="https://gameinstitute.qq.com/community/detail/128771#commit">https://gameinstitute.qq.com/community/detail/128771#commit</a><br /></li>
<li>详解双抛物面环境映射 <a href="https://zhuanlan.zhihu.com/p/40784734">https://zhuanlan.zhihu.com/p/40784734</a><br /></li>
<li><a href="http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf">http://cdn.imgtec.com/sdk-documentation/Dual+Paraboloid+Environment+Mapping.Whitepaper.pdf</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0329e0" class="outline-2">
<h2 id="orgb0329e0">Q&amp;A</h2>
<div class="outline-text-2" id="text-orgb0329e0">
</div>
<div id="outline-container-org5bd851b" class="outline-3">
<h3 id="org5bd851b">如何判断投影矩阵是否为透视投影？</h3>
<div class="outline-text-3" id="text-org5bd851b">
<p>
正交投影没有透视除法，所以其最后一行数据为 (0,0,0,1)。因此在游戏引擎中，只要判断投影矩阵是否为正交投影矩阵，如果不是正交投影矩阵，就是透视投影矩阵。<br />
OpenGL API 接受的矩阵需要列主序。<br />
Unity 中矩阵是列主序的，正交投影最后一列数据为(0,0,0,1)。底层使用一个 float matrixData[16] 数组存储。<br />
matrix[0]  matrix[1]  matrix[2]  matrix[3]<br />
matrix[4]  matrix[5]  matrix[6]  matrix[7]<br />
matrix[8]  matrix[9]  matrix[10] matrix[11]<br />
matrix[12] matrix[13] matrix[13] matrix[15]<br />
判断是否为透视投影矩阵的方法为：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">isPerspectiveMatrix</span>()
{
    <span style="color: #4f97d7; font-weight: bold;">return</span> matixData[3]!=0 || matrixData[7]!=0 || matrixData[11]!=0 || matrixData[15]!=1;
}
</pre>
</div>
<p>
FrameDebug 中显示的矩阵是行主序的：<br />
<img src="./UnityCatLikeCoding/00_matix_checker_01.png" alt="00_matix_checker_01.png" /><br />
<img src="./UnityCatLikeCoding/00_matix_checker_02.png" alt="00_matix_checker_02.png" /><br />
</p>

<ul class="org-ul">
<li>OpenGL 中矩阵的行主序与列主序 <a href="https://blog.51cto.com/31329846/2345432">https://blog.51cto.com/31329846/2345432</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgba699cb" class="outline-3">
<h3 id="orgba699cb">为什么 Unity 标准材质中只有点光源可以在顶点着色器中计算？</h3>
<div class="outline-text-3" id="text-orgba699cb">
<p>
因为 unity 就是这样实现的。其实任何光照都可以在顶点着色器中计算，在片段着色器中插值获得片段颜色。<br />
</p>
</div>
</div>
<div id="outline-container-org2e2c4fa" class="outline-3">
<h3 id="org2e2c4fa">Unity 球谐光照函数中只需要传递 normal，那么物体到光源的距离引起的光照差异是如何实现的？</h3>
<div class="outline-text-3" id="text-org2e2c4fa">
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/8997720.html">https://www.cnblogs.com/murongxiaopifu/p/8997720.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc77a5a1" class="outline-3">
<h3 id="orgc77a5a1">为什么渲染方向光的阴影贴图时需要使用正交矩阵，而点光源需要使用透视矩阵？</h3>
<div class="outline-text-3" id="text-orgc77a5a1">
<p>
对于物体来说方向光的方向都是相同的，和方向光垂直的同一平面内的点，他们对应的阴影贴图中的值应该相同，使用正交投影按照方向光方向，渲染场景中物体，将深度写入阴影贴图刚好可以满足这个要求。<br />
点光源的情况则刚好和透视投影相对应。<br />
</p>
</div>
</div>
<div id="outline-container-org95836b7" class="outline-3">
<h3 id="org95836b7">为什么点光源阴影需要绘制场景 6 次？</h3>
<div class="outline-text-3" id="text-org95836b7">
<p>
因为点光源各个方向的光照方向都不同，必须从前后左右和上下六个方向分别绘制场景，生成 Cube 阴影贴图。<br />
</p>
</div>
</div>
<div id="outline-container-orgbe40455" class="outline-3">
<h3 id="orgbe40455">Renderer.receiveShadows 是如何控制关闭接收阴影的？</h3>
<div class="outline-text-3" id="text-orgbe40455">
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #ce537a; font-weight: bold;">half</span> <span style="color: #bc6ec5; font-weight: bold;">UnityComputeForwardShadows</span>(<span style="color: #ce537a; font-weight: bold;">float2</span> lightmapUV, <span style="color: #ce537a; font-weight: bold;">float3</span> worldPos, <span style="color: #ce537a; font-weight: bold;">float4</span> screenPos)
{
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">fade value</span>
    <span style="color: #ce537a; font-weight: bold;">float</span> zDist = <span style="color: #4f97d7;">dot</span>(<span style="color: #7590db;">_WorldSpaceCameraPos</span> - worldPos, UNITY_MATRIX_V[2].xyz);
    <span style="color: #ce537a; font-weight: bold;">float</span> fadeDist = UnityComputeShadowFadeDistance(worldPos, zDist);
    <span style="color: #ce537a; font-weight: bold;">half</span>  realtimeToBakedShadowFade = UnityComputeShadowFade(fadeDist);

    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">baked occlusion if any</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35828;&#26126;&#65306;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Renderer.receiveShadows=false &#26102;&#65292;Unity &#24341;&#25806;&#20250;&#21462;&#28040; SHADOWS_SCREEN Keyword &#30340;&#23450;&#20041;&#65292;&#20174;&#32780;&#35753; shadowAttenuation=1</span>
    <span style="color: #ce537a; font-weight: bold;">half</span> realtimeShadowAttenuation = 1.0f;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">directional realtime shadow</span>
<span style="color: #bc6ec5;">    #if</span> defined (SHADOWS_SCREEN)
<span style="color: #bc6ec5;">        #if</span> defined(UNITY_NO_SCREENSPACE_SHADOWS) &amp;&amp; !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
            realtimeShadowAttenuation = unitySampleShadow(<span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));
<span style="color: #bc6ec5;">        #else</span>
            <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">Only reached when LIGHTMAP_ON is NOT defined (and thus we use interpolator for screenPos rather than lightmap UVs). See HANDLE_SHADOWS_BLENDING_IN_GI below.</span>
            realtimeShadowAttenuation = unitySampleShadow(screenPos);
<span style="color: #bc6ec5;">        #endif</span>
<span style="color: #bc6ec5;">    #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">avoid expensive shadows fetches in the distance where coherency will be good</span>
    UNITY_BRANCH
    <span style="color: #4f97d7; font-weight: bold;">if</span> (realtimeToBakedShadowFade &lt; (1.0f - 1e-2f))
    {
<span style="color: #bc6ec5;">    #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">spot realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> (defined (SHADOWS_DEPTH) &amp;&amp; defined (SPOT))
<span style="color: #bc6ec5;">            #if</span> !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
                unityShadowCoord4 spotShadowCoord = <span style="color: #4f97d7;">mul</span>(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1));
<span style="color: #bc6ec5;">            #else</span>
                unityShadowCoord4 spotShadowCoord = screenPos;
<span style="color: #bc6ec5;">            #endif</span>
            realtimeShadowAttenuation = UnitySampleShadowmap(spotShadowCoord);
<span style="color: #bc6ec5;">        #endif</span>

        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">point realtime shadow</span>
<span style="color: #bc6ec5;">        #if</span> defined (SHADOWS_CUBE)
            realtimeShadowAttenuation = UnitySampleShadowmap(worldPos - <span style="color: #7590db;">_LightPositionRange</span>.xyz);
<span style="color: #bc6ec5;">        #endif</span>

<span style="color: #bc6ec5;">    #if</span> defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT) &amp;&amp; !defined(LIGHTMAP_SHADOW_MIXING)
    }
<span style="color: #bc6ec5;">    #endif</span>

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #bc6ec5; font-weight: bold;">UnityMixRealtimeAndBakedShadows</span>(realtimeShadowAttenuation, shadowMaskAttenuation, realtimeToBakedShadowFade);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0f186c7" class="outline-3">
<h3 id="org0f186c7">为什么 FrameDebug 中显示 unity_SpecCube0 为 UnityBlackCube？</h3>
<div class="outline-text-3" id="text-org0f186c7">
<ul class="org-ul">
<li>检查是否烘培了当前场景<br /></li>
<li>检查间接光照强度<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb9f9731" class="outline-2">
<h2 id="orgb9f9731">参考资料</h2>
<div class="outline-text-2" id="text-orgb9f9731">
<p>
官网<br />
<a href="https://catlikecoding.com/">https://catlikecoding.com/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/rendering/">https://catlikecoding.com/unity/tutorials/rendering/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/">https://catlikecoding.com/unity/tutorials/advanced-rendering/</a><br />
<a href="https://catlikecoding.com/unity/tutorials/custom-srp/">https://catlikecoding.com/unity/tutorials/custom-srp/</a><br />
</p>
</div>
</div>
</div>
</body>
</html>
