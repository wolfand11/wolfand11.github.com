<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-07-07 周二 20:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Unity GUI</title>
<meta name="generator" content="Org mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="stylesheet" title="Standard" href="https://wolfand11.gitee.io/res/css/worg.css" type="text/css" />
           <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.gitee.io/res/css/worg-zenburn.css" type="text/css" />
           <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.gitee.io/res/css/worg-classic.css" type="text/css" />
           <link rel="icon" href="https://wolfand11.gitee.io/res/favicon.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.gitee.io"> HOME </a>
</div><div id="content">
<h1 class="title">Unity GUI</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org480e813">Unity GUI</a>
<ul>
<li><a href="#orgeb11044">NGUI</a>
<ul>
<li><a href="#orga89670a">UIRoot UIRect UIRect.AnchorPoint</a>
<ul>
<li><a href="#org56c4140"><span class="todo TODO">TODO</span> 多分辨率如何实现？</a></li>
</ul>
</li>
<li><a href="#orgc30a394">UIPanel-UIWidget-UIGeometry-UIDrawCall</a>
<ul>
<li><a href="#org6a09671">顶点属性如何管理？ 位置-颜色-贴图坐标 旋转-缩放</a>
<ul>
<li><a href="#org71ea685">数据记录</a></li>
<li><a href="#org7c4ba66">数据更新</a></li>
</ul>
</li>
<li><a href="#org38e8c47">渲染顺序如何管理？</a>
<ul>
<li><a href="#orgf6bad32">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org451c234"><span class="todo TODO">TODO</span> UICamera</a></li>
<li><a href="#orgf0dd305">Q&amp;A</a>
<ul>
<li><a href="#org3f3d481">material 是如何来的？shader 是如何来的？</a>
<ul>
<li><a href="#org3ec54b9">UILabel</a></li>
<li><a href="#org3efa47d">UISprite</a></li>
</ul>
</li>
<li><a href="#org2e9c709">什么时候会重新构建 UIDrawCall，如何避免？</a>
<ul>
<li><a href="#org6c425c1">重新构建 UIPanel 下的某个 drawCall</a></li>
<li><a href="#orgee87b82">重新构建 UIPanel 下的所有 drawCalls？</a></li>
<li><a href="#org29c22e2">避免 DrawCall 重新构建的方案</a></li>
<li><a href="#org1cdee97">DrawCall 的优化方法</a></li>
</ul>
</li>
<li><a href="#orgc8d9c88">如何降低 UI 的 DrawCall？</a></li>
<li><a href="#orgc9c7d2e">如何降低 UI 的 OverDraw？</a></li>
<li><a href="#org47da91d">在渲染前，NGUI 对顶点坐标数据进行 模型变换 视图变换 在哪儿进行的？</a></li>
<li><a href="#orgfc9ec6a">Mesh 是挂在 UIDrawCall 所在的 GameObject 上的，如何保证 Mesh 渲染出来的位置和 UIWidget 的位置一致？</a></li>
<li><a href="#org7841366">UIPanel 的裁剪是如何实现的？</a></li>
<li><a href="#orgcd0c78d">UIScrollView 中的 Item 有按钮时，NGUI 如何做到拖动按钮可以拖动 Item？</a></li>
<li><a href="#org78f36f2"><span class="todo TODO">TODO</span> Outline 效果是如何实现的？</a></li>
<li><a href="#orga935aba"><span class="todo TODO">TODO</span> 点击 Button 切换贴图是否会导致 UIDrawCall 重新生成？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4180237">UGUI</a>
<ul>
<li><a href="#org2ae5dee">UGUI 源码调试</a>
<ul>
<li><a href="#org76a7c48">方案 1</a>
<ul>
<li><a href="#orgdde94fd">参考资料</a></li>
</ul>
</li>
<li><a href="#orgf4a1c16">方案 2</a>
<ul>
<li><a href="#orga2051eb">参考资料</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbdb1121">UGUI 事件响应机制</a>
<ul>
<li><a href="#org5cee020">EventSystem</a></li>
<li><a href="#orge5d8f73">RaycasterManager</a>
<ul>
<li><a href="#org147d3b0">GraphicRaycaster</a></li>
<li><a href="#org6d1c5bf">Graphic.Raycast(Vector2 sp, Camera eventCamera)</a></li>
</ul>
</li>
<li><a href="#org42d2276">GraphicRegistry</a></li>
<li><a href="#orgbb6a6c6">StandaloneInputModule</a>
<ul>
<li><a href="#org399a1e1">ProcessTouchEvents</a></li>
<li><a href="#orgabc7ef8">ProcessMouseEvent</a></li>
<li><a href="#org4ea2ace">GetMousePointerEventData(int id)</a></li>
<li><a href="#orga888124">EventSystem.RaycastAll()</a></li>
<li><a href="#org0f58da1">ProcessMousePress</a></li>
<li><a href="#org2dbd77c">Tips</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7c4dc57">Q&amp;A</a>
<ul>
<li><a href="#org226f474">如何实现一个可被点击的非渲染 UI 控件？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
unity gui 相关的笔记。<br />
</p>
<div class="HTML">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>
<div id="outline-container-org480e813" class="outline-2">
<h2 id="org480e813">Unity GUI</h2>
<div class="outline-text-2" id="text-org480e813">
<ul class="org-ul">
<li>顶点属性如何管理？ 位置-颜色-贴图坐标 旋转-缩放<br /></li>
<li>渲染顺序如何管理？<br /></li>
<li>UI 事件如何处理？<br /></li>
<li>多分辨率如何实现？<br /></li>
</ul>
</div>
<div id="outline-container-orgeb11044" class="outline-3">
<h3 id="orgeb11044">NGUI</h3>
<div class="outline-text-3" id="text-orgeb11044">
</div>
<div id="outline-container-orga89670a" class="outline-4">
<h4 id="orga89670a">UIRoot UIRect UIRect.AnchorPoint</h4>
<div class="outline-text-4" id="text-orga89670a">
<p>
UIRoot 组件的作用是缩放 UI 为 2/(Screen.height)<br />
UIRect.OnAnchor 中会根据该 ui 元素的 4 个 AnchorPoint 计算出来自己的 position，如果有变化，就会更新。<br />
UIRect.GetSides 是用来获得该 ui 元素的四个角(lb lt rt rb)的坐标的<br />
AnchorPoint.GetSides 调用了 AnchorPoint 的 target.GetSides()<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Vector3</span>[] AnchorPoint.<span style="color: #bc6ec5; font-weight: bold;">GetSides</span> (<span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #7590db;">relativeTo</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (target != <span style="color: #a45bad;">null</span>)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (rect != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> rect.<span style="color: #bc6ec5; font-weight: bold;">GetSides</span>(relativeTo);
        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">cam</span> = target.GetComponent&lt;Camera&gt;();
        <span style="color: #4f97d7; font-weight: bold;">if</span> (cam != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> cam.<span style="color: #bc6ec5; font-weight: bold;">GetSides</span>(relativeTo);
    }
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">null</span>;
}
</pre>
</div>
</div>
<div id="outline-container-org56c4140" class="outline-5">
<h5 id="org56c4140"><span class="todo TODO">TODO</span> 多分辨率如何实现？</h5>
</div>
</div>

<div id="outline-container-orgc30a394" class="outline-4">
<h4 id="orgc30a394">UIPanel-UIWidget-UIGeometry-UIDrawCall</h4>
<div class="outline-text-4" id="text-orgc30a394">
</div>
<div id="outline-container-org6a09671" class="outline-5">
<h5 id="org6a09671">顶点属性如何管理？ 位置-颜色-贴图坐标 旋转-缩放</h5>
<div class="outline-text-5" id="text-org6a09671">
</div>
<div id="outline-container-org71ea685" class="outline-6">
<h6 id="org71ea685">数据记录</h6>
<div class="outline-text-6" id="text-org71ea685">
<ol class="org-ol">
<li>每个 UIWidget 包含一个 UIGeomery 来存储该 UI 的几何信息 - 顶点位置 verts 顶点贴图坐标 uvs 顶点颜色 cols，这 3 个都是 List；<br /></li>
<li>UIText UISprite 等给 UIGeometry 填充的几何数据都是本地坐标，UIGeometry 通过 ApplyTransform 生成 mRtpVerts mRtpNormal mRtpTan；<br /></li>
<li>每个 UIPanel 下包含一个 List&lt;UIDrawCall&gt; drawCalls 用来存储该 UIPanel 下所有的 DrawCall 信息；<br /></li>
<li>每个 UIDrawCall 包含了绘制需要的一切信息，如下为 UIDrawCall 的部分代码：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">widgetCount</span> = 0;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">depthStart</span> = <span style="color: #ce537a; font-weight: bold;">int</span>.MaxValue;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">depthEnd</span> = <span style="color: #ce537a; font-weight: bold;">int</span>.MinValue;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">UIPanel</span> <span style="color: #7590db;">manager</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">UIPanel</span> <span style="color: #7590db;">panel</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">Texture2D</span> <span style="color: #7590db;">clipTexture</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">alwaysOnScreen</span> = <span style="color: #a45bad;">false</span>;
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt; <span style="color: #7590db;">verts</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt;();
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt; <span style="color: #7590db;">norms</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt;();
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt; <span style="color: #7590db;">tans</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt;();
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector2&gt; <span style="color: #7590db;">uvs</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector2&gt;();
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt; <span style="color: #7590db;">uv2</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt;();
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Color&gt; <span style="color: #7590db;">cols</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Color&gt;();

<span style="color: #ce537a; font-weight: bold;">Material</span>    <span style="color: #7590db;">mMaterial</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Material used by this draw call</span>
<span style="color: #ce537a; font-weight: bold;">Texture</span>   <span style="color: #7590db;">mTexture</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Main texture used by the material</span>
<span style="color: #ce537a; font-weight: bold;">Shader</span>    <span style="color: #7590db;">mShader</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Shader used by the dynamically created material</span>
<span style="color: #ce537a; font-weight: bold;">int</span>     <span style="color: #7590db;">mClipCount</span> = 0; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Number of times the draw call's content is getting clipped</span>
<span style="color: #ce537a; font-weight: bold;">Transform</span>     <span style="color: #7590db;">mTrans</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Cached transform</span>
<span style="color: #ce537a; font-weight: bold;">Mesh</span>      <span style="color: #7590db;">mMesh</span>;      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">First generated mesh</span>
<span style="color: #ce537a; font-weight: bold;">MeshFilter</span>  <span style="color: #7590db;">mFilter</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Mesh filter for this draw call</span>
<span style="color: #ce537a; font-weight: bold;">MeshRenderer</span>  <span style="color: #7590db;">mRenderer</span>;    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Mesh renderer for this screen</span>
<span style="color: #ce537a; font-weight: bold;">Material</span>    <span style="color: #7590db;">mDynamicMat</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Instantiated material</span>
<span style="color: #ce537a; font-weight: bold;">int</span>[]       <span style="color: #7590db;">mIndices</span>;   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Cached indices</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org7c4ba66" class="outline-6">
<h6 id="org7c4ba66">数据更新</h6>
<div class="outline-text-6" id="text-org7c4ba66">
<ul class="org-ul">
<li>渲染所需数据的更新都是从 UIPanel-&gt;LateUpdate 驱动的。<br /></li>
<li>UIWidget 的 geomery 对象数据的更新<br />
UIWidget 在 UpdateGeometry 中触发 OnFill 方法。<br />
UIWidget 的子类中在 OnFill 方法内会填充 geomery 数据。例如：UILabel 是在 OnFill 中调用 NGUIText.Print()来填充 geometry 数据的。<br /></li>
<li>UIPanel 下 drawCalls 的数据更新<br />
情况 1：<br />
UIWidget 在 UpdateGeometry 中标记 drawCall 为 dirty<br />
UIPanel 在 UpdateSelf 中触发 FillDrawCall 来填充需要修改的 drawCall 的数据<br />
情况 2：<br />
UIPanel 在 FillAllDrawCall 中填充所有 drawCall 的数据<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- UIPanel</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIPanel</span>::LateUpdate()
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mUpdateFrame != Time.frameCount)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#39318;&#20808;&#26356;&#26032;&#25152;&#26377; UIPanel. list &#20026; UIPanel &#30340;&#38745;&#24577;&#21464;&#37327;&#65292;&#20854;&#20013;&#23384;&#20648;&#20102;&#25152;&#26377;&#30340; UIPanel</span>
        <span style="color: #4f97d7; font-weight: bold;">for</span> (i=0; i&lt;list.Count; i++)
        {
            list[i].<span style="color: #bc6ec5; font-weight: bold;">UpdateSelf</span>();
        }
    }
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#20854;&#27425;&#26356;&#26032;&#25152;&#26377;&#30340; draw calls&#65292;&#35753;&#23427;&#20204;&#20197;&#27491;&#30830;&#30340;&#28210;&#26579;&#39034;&#24207;&#28210;&#26579;</span>
}


<span style="color: #2aa1ae; background-color: #292e34;">/// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#24403;&#21069; panel &#20197;&#21450;&#23427;&#30340;&#25152;&#26377; widgets &#21644; draw calls</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIPanel</span>::UpdateSelf()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20462;&#25913;&#33258;&#24049;&#30340; transform matrix</span>
    UpdateTransformMatrix();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032;&#33258;&#24049;&#20197;&#21450;&#27599;&#20010; widget &#30340; layer</span>
    UpdateLayers();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#27599;&#20010; widget &#30340; UpdateTransform UpdateVisibility UpdateGeometry</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992; UpdateGeometry &#36820;&#22238; true&#65292;&#23601;&#23558;&#24403;&#21069; widget &#30340; drawCall &#26631;&#35760;&#20026; dirty</span>
    UpdateWidgets();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; DrawCall</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#22914;&#26524;&#38656;&#35201;&#37325;&#24314; DrawCall&#65288;&#20363;&#22914;&#65292;&#22312;&#19968;&#24320;&#22987;&#26174;&#31034; Panel &#30340;&#26102;&#20505;&#65289;&#65292;&#21017;&#28165;&#31354;&#25152;&#26377; DrawCall&#65292;&#35843;&#29992; FillAllDrawCall &#37325;&#26032;&#21019;&#24314;&#25152;&#26377; DrawCall</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#36941;&#21382; drawCalls &#35843;&#29992; FillDrawCall &#26356;&#26032;&#27599;&#19968;&#20010;&#34987;&#26631;&#35760;&#20026; dirty &#30340; DrawCall</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#36825;&#20010;&#36807;&#31243;&#20013;&#20250;&#35843;&#29992; widget &#30340; WriteToBuffers(drawCall.verts,drawCalls.uvs,drawCalls.cols,drawCalls.normals)</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mRebuild)
    {
        mRebuild = <span style="color: #a45bad;">false</span>;
        FillAllDrawCall();
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">foreach</span>(dc <span style="color: #4f97d7; font-weight: bold;">in</span> drawCalls)
        {
            <span style="color: #4f97d7; font-weight: bold;">if</span> (dc.isDirty &amp;&amp; !FillDrawCall(dc))
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- remove dc</span>
                }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; DrawCall</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIPanel</span>::FillAllDrawCall()
{
    <span style="color: #4f97d7; font-weight: bold;">foreach</span>(w <span style="color: #4f97d7; font-weight: bold;">in</span> widgets)
    {
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22914;&#26524;&#19981;&#33021;&#20849;&#29992;&#21069;&#38754; widget &#30340; drawCall&#65292;&#21017;&#26032;&#24314;&#19968;&#20010; drawCall</span>
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">mat texture shader &#26377;&#19968;&#20010;&#19981;&#21516;&#21017;&#19981;&#33021;&#20849;&#29992; drawCall</span>
        dc = UIDrawCall.<span style="color: #bc6ec5; font-weight: bold;">Create</span>(<span style="color: #4f97d7; font-weight: bold;">this</span>, mat, tex, sdr);
    }
}
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIPanel</span>::FillDrawCall(<span style="color: #ce537a; font-weight: bold;">UIDrawCall</span> <span style="color: #7590db;">dc</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">foreach</span>(w <span style="color: #4f97d7; font-weight: bold;">in</span> widgets)
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span>(w.drawCall == dc)
        {
            <span style="color: #2aa1ae; background-color: #292e34;">//</span>
            <span style="color: #4f97d7; font-weight: bold;">if</span> (generateNormals) w.<span style="color: #bc6ec5; font-weight: bold;">WriteToBuffers</span>(dc.verts, dc.uvs, dc.cols, dc.norms, dc.tans, generateUV2 ? dc.uv2 : <span style="color: #a45bad;">null</span>);
            <span style="color: #4f97d7; font-weight: bold;">else</span> w.<span style="color: #bc6ec5; font-weight: bold;">WriteToBuffers</span>(dc.verts, dc.uvs, dc.cols, <span style="color: #a45bad;">null</span>, <span style="color: #a45bad;">null</span>, generateUV2 ? dc.uv2 : <span style="color: #a45bad;">null</span>);
        }
    }
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-------------------------------------------------</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- UIWidget</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; widget &#30456;&#23545;&#20110; UIPanel &#26159;&#21542;&#26377;&#20301;&#32622;&#21464;&#21270; &#26356;&#26032; mMoved &#29366;&#24577;</span>
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">UIWidget</span>::UpdateTransform();
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#26356;&#26032; widget &#30340;&#21487;&#35265;&#24615;&#29366;&#24577; mIsVisibleByAlpha(widget &#30340; alpha &#26159;&#21542;&#20026; 0) mIsVisibleByPanel(widget &#26159;&#21542;&#22312;&#21487;&#35270;&#21306;&#22495;&#20869;)</span>
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">UIWidget</span>::UpdateVisibility();
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#21028;&#26029; widget &#30340;&#20960;&#20309;&#20449;&#24687;&#26159;&#21542;&#25913;&#21464; &#26356;&#26032; widget &#30340;&#20960;&#20309;&#20449;&#24687;</span>
<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">UIWidget</span>::UpdateGeometry();
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35843;&#29992;&#23558;&#33258;&#24049;&#30340; geometry-&gt;WriteToBuffers &#26041;&#27861;&#65292;&#23558; geometry &#30340;&#20960;&#20309;&#25968;&#25454;&#21152;&#21040; drawCall &#23545;&#24212;&#30340; List &#20013;</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIWidget</span>::WriteToBuffers(<span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt; <span style="color: #7590db;">v</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector2&gt; <span style="color: #7590db;">u</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Color&gt; <span style="color: #7590db;">c</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector3&gt; <span style="color: #7590db;">n</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt; <span style="color: #7590db;">t</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;Vector4&gt; <span style="color: #7590db;">u2</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
Mesh 数据更新<br />
</p>
<ol class="org-ol">
<li>UIPanel 在 FillDrawCall 或 FillAllDrawCall 中调用 UIDrawCall 的 UpdateGeometry；<br /></li>
<li>UIDrawCall 在 UpdateGeometry 中会创建 Mesh（如果已经存在，则用已存在的），并为 Mesh 设置数据。如下：<br /></li>
<li>在创建 UIDrawCall 的时候会创建一个 GameObject，并将 UIDrawCall 组件加到该 GameObject 上，MeshFilter、MeshRenderer 都会加到该 GameObject 上。<br /></li>
<li>UIDrawCall 所属的 GameObject 在编辑器的场景树中是不可见的，可以在 UIDrawCall 脚本中，开启宏定义 #define SHOW_HIDDEN_OBJECTS，来显示隐藏的 GameObject。<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIDrawCall</span>::UpdateGeometry()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1. &#21019;&#24314; MeshFilter</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mFilter == <span style="color: #a45bad;">null</span>) mFilter = gameObject.AddComponent&lt;MeshFilter&gt;();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2. &#21019;&#24314; Mesh &#22635;&#20805;&#25968;&#25454;</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mMesh == <span style="color: #a45bad;">null</span>) mMesh = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Mesh</span>();

    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetVertices</span>(verts);
    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetUVs</span>(0, uvs);
    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetColors</span>(cols);
    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetUVs</span>(1, (uv2.Count == vertexCount) ? uv2 : <span style="color: #a45bad;">null</span>);
    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetNormals</span>((norms.Count == vertexCount) ? norms : <span style="color: #a45bad;">null</span>);
    mMesh.<span style="color: #bc6ec5; font-weight: bold;">SetTangents</span>((tans.Count == vertexCount) ? tans : <span style="color: #a45bad;">null</span>);

    mFilter.mesh = mMesh;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3. &#21019;&#24314; MeshRenderer</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mRenderer == <span style="color: #a45bad;">null</span>) mRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;();
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">-- &#21019;&#24314;&#26448;&#36136;&#20026; mRenderer &#35774;&#32622;&#26448;&#36136;</span>
    UpdateMaterials();
}

<span style="color: #2aa1ae; background-color: #292e34;">//</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIDrawCall</span>::UpdateMaterials()
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Destroy the old material</span>
    NGUITools.<span style="color: #bc6ec5; font-weight: bold;">DestroyImmediate</span>(mDynamicMat);

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Create a new material</span>
    CreateMaterial();
    mDynamicMat.renderQueue = mRenderQueue;

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Update the renderer</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> (mRenderer != <span style="color: #a45bad;">null</span>)
    {
        mRenderer.sharedMaterials = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Material</span>[] { mDynamicMat };
        mRenderer.sortingLayerName = mSortingLayerName;
        mRenderer.sortingOrder = mSortingOrder;
    }
}
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org38e8c47" class="outline-5">
<h5 id="org38e8c47">渲染顺序如何管理？</h5>
<div class="outline-text-5" id="text-org38e8c47">
<ul class="org-ul">
<li><p>
Unity 中渲染顺序<br />
Unity 中渲染顺序按照一下优先级来进行<br />
</p>
<ol class="org-ol">
<li>Camera 的 depth 越小越先渲染<br /></li>
<li>Renderer 的 sortingLayer 越小越先渲染 (默认的 sortingLayer 为 Default 其值为 0)<br /></li>
<li>Renderer 的 sortingOrder 越小越先渲染（默认值为 0）<br /></li>
<li>Renderer.material.renderQueue 越小越先渲染<br /></li>
</ol>
<p>
需要注意的是先渲染不一定就在后面，因为如果开启了深度测试，可能后渲染的物体部分像素的深度值比当前帧缓存区中已经存在的像素深度值大，该物体的这部分像素就不会被渲染到帧缓存区中。<br />
</p></li>
<li><p>
NGUI 中渲染顺序<br />
</p>
<ol class="org-ol">
<li>UIDrawCall 中有 mSortingOrder、mRenderQueue<br /></li>
<li>UIDrawCall 的 mSortingOrder 会赋值给 mRenderer.sortingOrder<br /></li>
<li>UIDrawCall 的 mRenderQueue 会赋值给 mDynamicMat.renderQueue<br /></li>
<li>所有 UIPanel 都会按照 depth 来排序（在 UIPanel 的 OnInit 中会将自己添加到 list 中，并对 list 进行排序），UIPanel 下的所有 UIDrawCall 有相同的 sortingOrder，这个值为 UIPanel 在 list 中索引值。<br /></li>
<li>在 UIPanel 的 LateUpdate 中，设置初始的 preRenderQueue=2999，遍历每个 UIPanel 下的每个 UIDrawCall 依次为每个 UIDrawCall 指定 renderQueue=preRenderQueue+1<br /></li>
<li>每个 UIWidget 都会按照 depth 来排序(在 UIPanel 的 AddWidget 函数中)，在为 UIDrawCall 填充数据时（FillDrawCall/FillAllDrawCall），depth 小的 UIWidget，其数据会先被使用。<br /></li>
</ol>
<p>
所以，NGUI 中渲染顺序是通过 depth 来决定的。<br />
对于 UIPanel 来说 depth 小的先渲染，depth 相同时，先加入 list 的先渲染。<br />
对于 UIWidget 来说，UIWidget 所属 UIPanel 不同时，哪个 UIPanel 先渲染其 widget 也先渲染；UIWidget 所属 UIPanel 相同时，depth 小的先渲染，depth 相同时，先加入 UIPanel widgets 中的先渲染。<br />
</p></li>
<li>关于 Material.renderQueue<br />
该属性指定了材质的渲染队列。默认情况下材质会使用它的 shader 中指定的渲染队列。一旦通过材质设置了 renderQueue 属性就会覆盖 shader 中设置的值。<br />
渲染队列的值为正数才能正常工作；当设置材质的 renderQueue 为-1 时，表示材质渲染使用 shader 中设置的 renderQueue.<br /></li>
<li>关于 Renderer.sortingOrder<br />
该属性表示 Render 在一个层中的排序，它的值在-32768 到-32767 区间内。<br /></li>
</ul>
</div>
<div id="outline-container-orgf6bad32" class="outline-6">
<h6 id="orgf6bad32">参考链接</h6>
<div class="outline-text-6" id="text-orgf6bad32">
<p>
<a href="https://docs.unity3d.com/ScriptReference/Material-renderQueue.html">https://docs.unity3d.com/ScriptReference/Material-renderQueue.html</a><br />
<a href="http://www.cnblogs.com/Persona/p/4149086.html">http://www.cnblogs.com/Persona/p/4149086.html</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org451c234" class="outline-4">
<h4 id="org451c234"><span class="todo TODO">TODO</span> UICamera</h4>
<div class="outline-text-4" id="text-org451c234">
<p>
UICamera 中可以配置事件处理在 Update 还是 LateUpdate 中进行，通常情况下，应该在 Update 中执行事件处理，因为 UI 渲染数据的更新是在 LateUpdate 中进行的。<br />
</p>
</div>
</div>
<div id="outline-container-orgf0dd305" class="outline-4">
<h4 id="orgf0dd305">Q&amp;A</h4>
<div class="outline-text-4" id="text-orgf0dd305">
</div>
<div id="outline-container-org3f3d481" class="outline-5">
<h5 id="org3f3d481">material 是如何来的？shader 是如何来的？</h5>
<div class="outline-text-5" id="text-org3f3d481">
</div>
<div id="outline-container-org3ec54b9" class="outline-6">
<h6 id="org3ec54b9">UILabel</h6>
<div class="outline-text-6" id="text-org3ec54b9">
<p>
UILabel 中 material 来自字体。<br />
UILabel 的 shader 有通过 material 来获得<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UILabel</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">material</span>
{
    <span style="color: #4f97d7; font-weight: bold;">get</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mMat != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> mMat;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mFont != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> mFont.material;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mTrueTypeFont != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> mTrueTypeFont.material;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">null</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">set</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">base</span>.material = <span style="color: #a45bad;">value</span>;
    }
}
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">UIWidget</span>
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">Shader</span> <span style="color: #7590db;">shader</span>
{
    <span style="color: #4f97d7; font-weight: bold;">get</span>
    {
        <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">mat</span> = material;
        <span style="color: #4f97d7; font-weight: bold;">return</span> (mat != <span style="color: #a45bad;">null</span>) ? mat.shader : <span style="color: #a45bad;">null</span>;
    }
    <span style="color: #4f97d7; font-weight: bold;">set</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">throw</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">System.</span><span style="color: #bc6ec5; font-weight: bold;">NotImplementedException</span>(GetType() + <span style="color: #2d9574;">" has no shader setter"</span>);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3efa47d" class="outline-6">
<h6 id="org3efa47d">UISprite</h6>
<div class="outline-text-6" id="text-org3efa47d">
<p>
UISprite 的 material 来自 UIAtlas<br />
UISprite 的 shader 通过 material 来获得<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">Material</span> <span style="color: #7590db;">material</span>
{
    <span style="color: #4f97d7; font-weight: bold;">get</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">mat</span> = <span style="color: #4f97d7; font-weight: bold;">base</span>.material;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (mat != <span style="color: #a45bad;">null</span>) <span style="color: #4f97d7; font-weight: bold;">return</span> mat;
        <span style="color: #4f97d7; font-weight: bold;">return</span> (mAtlas != <span style="color: #a45bad;">null</span> ? mAtlas.spriteMaterial : <span style="color: #a45bad;">null</span>);
    }
    <span style="color: #4f97d7; font-weight: bold;">set</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">base</span>.material = <span style="color: #a45bad;">value</span>;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2e9c709" class="outline-5">
<h5 id="org2e9c709">什么时候会重新构建 UIDrawCall，如何避免？</h5>
<div class="outline-text-5" id="text-org2e9c709">
</div>
<div id="outline-container-org6c425c1" class="outline-6">
<h6 id="org6c425c1">重新构建 UIPanel 下的某个 drawCall</h6>
<div class="outline-text-6" id="text-org6c425c1">
<ol class="org-ol">
<li>在该 Panel 下添加新的节点，当找到该节点适用的 UIDrawCall 时，会标记 drawCall dirty，在随后的更新中会重新给该 drawCall 填充数据。<br /></li>
<li>删除或者 disable Panel 下某个 UIWidget 时，会标记该 UIWidget 的 drawCall dirty（也可能标记 UIPanel 的所有 drawCalls 都需要重新创建）<br /></li>
<li>enable Panel 下某个 UIWidget 时，会调用该 UIWidget 的 OnInit 方法，该方法会引起一下处理：<br />
<a id="org92569c6"></a><br />
<ul class="org-ul">
<li>调用 FindDrawCall，为 widget 指定 drawCall，如果没有合适的 drawCall 会 UIPanel 标记 mRebuild=true<br /></li>
<li>标记 UIWidget 的 mChanged=true，在随后的更新中会重新给该 UIWdiget 填充几何数据，标识它的 drawCall 为 dirty<br /></li>
</ul></li>
</ol>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">RemoveWidget</span> (<span style="color: #ce537a; font-weight: bold;">UIWidget</span> <span style="color: #7590db;">w</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (widgets.<span style="color: #bc6ec5; font-weight: bold;">Remove</span>(w) &amp;&amp; w.drawCall != <span style="color: #a45bad;">null</span>)
    {
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">depth</span> = w.depth;
        <span style="color: #4f97d7; font-weight: bold;">if</span> (depth == w.drawCall.depthStart || depth == w.drawCall.depthEnd)
            mRebuild = <span style="color: #a45bad;">true</span>;

        w.drawCall.isDirty = <span style="color: #a45bad;">true</span>;
        w.drawCall = <span style="color: #a45bad;">null</span>;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgee87b82" class="outline-6">
<h6 id="orgee87b82">重新构建 UIPanel 下的所有 drawCalls？</h6>
<div class="outline-text-6" id="text-orgee87b82">
<ol class="org-ol">
<li>在 UIPanel 的 OnInit 中会标记 mRebuild=true，即重新生成 drawCalls<br /></li>
<li>在该 Panel 下添加新的节点，当找不到该节点适用的 UIDrawCall 时（即 FindDrawCall 失败），会标记 mRebuild=true<br /></li>
<li><p>
修改 UIPanel 下某个 UIWidget 的 depth 时 会先调用 会标记 mRebuild=true。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #4f97d7; font-weight: bold;">if</span> (mDepth != <span style="color: #a45bad;">value</span>)
{
    <span style="color: #4f97d7; font-weight: bold;">if</span> (panel != <span style="color: #a45bad;">null</span>) panel.<span style="color: #bc6ec5; font-weight: bold;">RemoveWidget</span>(<span style="color: #4f97d7; font-weight: bold;">this</span>);
    mDepth = <span style="color: #a45bad;">value</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (panel != <span style="color: #a45bad;">null</span>)
    {
        panel.<span style="color: #bc6ec5; font-weight: bold;">AddWidget</span>(<span style="color: #4f97d7; font-weight: bold;">this</span>);

        <span style="color: #4f97d7; font-weight: bold;">if</span> (!Application.isPlaying)
        {
            panel.<span style="color: #bc6ec5; font-weight: bold;">SortWidgets</span>();
            panel.<span style="color: #bc6ec5; font-weight: bold;">RebuildAllDrawCalls</span>();
        }
    }
}
</pre>
</div></li>
<li><a href="#org92569c6">3</a><br /></li>
</ol>
</div>
</div>
<div id="outline-container-org29c22e2" class="outline-6">
<h6 id="org29c22e2">避免 DrawCall 重新构建的方案</h6>
<div class="outline-text-6" id="text-org29c22e2">
<ol class="org-ol">
<li>在 UI 制作时就将所有用到的 UI 元素拼到 prefab 中，避免动态添加 UIWidget 节点到已经显示的 UIPanel.<br /></li>
<li>如果无法避免动态添加 UI 元素，那么在所属 UIPanel 显示之前将 UIWidget 添加到 UIPanel 上.<br />
<ul class="org-ul">
<li>考虑到 UI 元素的复用，如：HeroIcon EquipIcon PropIcon<br /></li>
</ul></li>
<li>如果当前 UIPanel 下的 UI 元素已经很多，第一次构建该 UIPanel 的 DrawCall 已经很卡了，那么可以考虑为暂时不显示的 UI 元素新建另外一个 UIPanel.<br />
例如：在商店 UIPanel 下有 装备 物品 碎片三个页签，每个页签下分别有 16 个物品，此时如果共享一个 UIPanel 卡的话，可以为这三个页签分别创建一个 UIPanel.<br /></li>
<li>对于需要暂时隐藏的 UIPanel，不要使用 gameObject.SetActive(false) 或者 panel.enabled=false<br /></li>
<li>对于需要暂时隐藏的 UIWidget，不要使用 SetActive(false)或 enabled=false 的方法，该方法会将 widget 从 UIPanel 中移除。<br />
如果该 widget 所用的 DrawCall 只用来渲染该 widget，那么它的 DrawCall 也会从 UIPanel 中移除，下次再显示时，需要重新创建 UIPanel 的所有 drawCall。<br />
如果该 widget 所用的 DrawCall 还用来渲染其他 widget，那么它的 DrawCall 不会从 UIPanel 中移除，下次再显示时，需要重新填充该 DrawCall 的数据。<br />
可以将需要暂时隐藏的 UIWidget 移动到屏幕外面，下次再显示时，移动回来就可以了。也可以将需要暂时隐藏的 UIWidget 的 z 值设置为某个很大或很小的值，将 UIWidget 移到摄像机视景体外面，下次再显示时将 z 值设置为 0 就可以了。<br />
按照上面的方式，当修改 UIWidget 的 Transform 时，会标记当前 UIWidget 的 DrawCall 为 dirty，需要重新填充该 DrawCall 的数据。<br /></li>
<li>尽量不要修改 UIWidget depth。对于需要修改 UIWidget depth 的情况，可以考虑通过修改 UIPanel 的 depth 来实现，修改 UIPanel 的 depth 不会造成重新构建 DrawCall。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org1cdee97" class="outline-6">
<h6 id="org1cdee97">DrawCall 的优化方法</h6>
<div class="outline-text-6" id="text-org1cdee97">
<p>
PanelTool 可以统计每个 UIPanel 的 DrawCall 次数<br />
UIDrawCallTool 可以查看每个 Panel 的 UIDrawCall 是如何产生的<br />
根据上面两个工具定位 DrawCall 需要优化的 UI 元素，从而对其进行优化。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc8d9c88" class="outline-5">
<h5 id="orgc8d9c88">如何降低 UI 的 DrawCall？</h5>
<div class="outline-text-5" id="text-orgc8d9c88">
<p>
在 UIPanel 的 UpdateSelf 中，所有 widget 填充完自己的几何数据以后，开始遍历每个 widget 生成 UIDrawCall，当 widget 使用的 material texture shader 中任何一个和前一个不同，就会创建新的 UIDrawCall。所以，可以采用下面几种方法：<br />
</p>
<ol class="org-ol">
<li>尽量将 UI 图片打包，可以让 Sprite 共用相同的材质，贴图和 shader，从而减少 DrawCall<br /></li>
<li>尽量少使用 UIPanel，这样可以让更多的 UI 元素共用 UIDrawCall。<br />
需要注意的是 UIPanel 中所含 UIWidget 越多，重建 UIPanel 的 drawCalls 越花时间。<br /></li>
<li>尽量将同时可见的 UILabel 的 depth 调整为一样的值，这样可以让 UILabel 共用一个 UIDrawCall。尽量将共用同一个 atlas 的 UISprite 的 depth 调整为一样或者属于一个范围的，这样它们可以共用一个 atlas。为 UILabel 和 UISprite 采用不同范围的深度值。<br /></li>
<li>不同的字体会造成 UILabel 的 material、texture 不同，所以不能共用相同的 UIDrawCall。但是，字体相同大小大小不同不会影响。因此，尽量采用相同的字体，并为不同字体的 UILabel 采用不同范围的深度值。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgc9c7d2e" class="outline-5">
<h5 id="orgc9c7d2e">如何降低 UI 的 OverDraw？</h5>
<div class="outline-text-5" id="text-orgc9c7d2e">
<p>
在编辑器的 Scene 视图中，点击左上角下拉按钮，选择 Miscellaneous-OverDraw 可以查看场景中 OverDraw 的状态，分析产生 OverDraw 的 UI 界面：<br />
</p>
<ol class="org-ol">
<li>如果这些界面是暂时完全不可见的，可以修改这些界面的 z 值，将界面移除到视景体外。<br /></li>
<li>如果这些界面是不常显示的，可以将 UI 界面直接 Destroy 或者 SetActive(false)<br /></li>
<li>如果这些界面是部分显示，部分不显示的，考虑这两部分是不是可以拆分开，可以拆分的话，不显示的部分处理可以参考 1、2 这两条方案。<br /></li>
<li>UILabel 的 Outline 和 Shadow 特效创建了多个 UILabelMesh，会造成 OverDraw，尽量减少 Outline 和 Shadow 特效。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org47da91d" class="outline-5">
<h5 id="org47da91d">在渲染前，NGUI 对顶点坐标数据进行 模型变换 视图变换 在哪儿进行的？</h5>
<div class="outline-text-5" id="text-org47da91d">
<p>
在 shader 中进行，例如 UILabel 的 shader 为 Unlit - Text.shader，其内容如下<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">v2f</span> <span style="color: #bc6ec5; font-weight: bold;">vert</span> (<span style="color: #ce537a; font-weight: bold;">appdata_t</span> <span style="color: #7590db;">v</span>)
{
    <span style="color: #ce537a; font-weight: bold;">v2f</span> <span style="color: #7590db;">o</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312;&#36825;&#37324;&#36827;&#34892;&#20102; &#27169;&#22411; &#35270;&#22270; &#25237;&#24433;&#21464;&#25442;</span>
    o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
    o.texcoord = v.texcoord;
    o.color = v.color;
    <span style="color: #4f97d7; font-weight: bold;">return</span> o;
}

<span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (<span style="color: #ce537a; font-weight: bold;">v2f</span> <span style="color: #7590db;">i</span>) : SV_Target
{
    <span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #7590db;">col</span> = i.color;
    col.a *= tex2D(_MainTex, i.texcoord).a;
    <span style="color: #4f97d7; font-weight: bold;">return</span> col;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfc9ec6a" class="outline-5">
<h5 id="orgfc9ec6a">Mesh 是挂在 UIDrawCall 所在的 GameObject 上的，如何保证 Mesh 渲染出来的位置和 UIWidget 的位置一致？</h5>
<div class="outline-text-5" id="text-orgfc9ec6a">
<ol class="org-ol">
<li>UIWidget 中的 UIGeometry 记录了原始的顶点数据<br /></li>
<li>UIGeometry 通过 void ApplyTransform (Matrix4x4 widgetToPanel, bool generateNormals = true)来将原始的顶点数据变换为 UIPanel 坐标系下的顶点数据<br /></li>
<li>在 UIPanel 的 UpdateDrawCall 里面会将 panel 的 position 赋值给 drawCall 的 position，代码如下：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">UIPanel</span>::UpdateDrawCalls (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">sortOrder</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...... </span>
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">pos</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span> (isUI)
    {
        <span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #7590db;">parent</span> = cachedTransform.parent;
        pos = cachedTransform.localPosition;

        <span style="color: #4f97d7; font-weight: bold;">if</span> (clipping != UIDrawCall.Clipping.None)
        {
            pos.x = Mathf.<span style="color: #bc6ec5; font-weight: bold;">RoundToInt</span>(pos.x);
            pos.y = Mathf.<span style="color: #bc6ec5; font-weight: bold;">RoundToInt</span>(pos.y);
        }

        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#23558;&#26412;&#22320;&#22352;&#26631;&#36716;&#21270;&#20026;&#19990;&#30028;&#22352;&#26631;</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span> (parent != <span style="color: #a45bad;">null</span>) pos = parent.<span style="color: #bc6ec5; font-weight: bold;">TransformPoint</span>(pos);
        pos += drawCallOffset;
    }
    <span style="color: #4f97d7; font-weight: bold;">else</span> pos = trans.position;

    <span style="color: #ce537a; font-weight: bold;">Quaternion</span> <span style="color: #7590db;">rot</span> = trans.rotation;
    <span style="color: #ce537a; font-weight: bold;">Vector3</span> <span style="color: #7590db;">scale</span> = trans.lossyScale;

    <span style="color: #4f97d7; font-weight: bold;">for</span> (<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span> = 0; i &lt; drawCalls.Count; ++i)
    {
        <span style="color: #ce537a; font-weight: bold;">UIDrawCall</span> <span style="color: #7590db;">dc</span> = drawCalls[i];

        <span style="color: #ce537a; font-weight: bold;">Transform</span> <span style="color: #7590db;">t</span> = dc.cachedTransform;
        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#35774;&#32622; drawCall &#23545;&#35937;&#30340;&#19990;&#30028;&#22352;&#26631;</span>
        t.position = pos;
        t.rotation = rot;
        t.localScale = scale;

        dc.renderQueue = (renderQueue == RenderQueue.Explicit) ? startingRenderQueue : startingRenderQueue + i;
        dc.alwaysOnScreen = alwaysOnScreen &amp;&amp;
            (mClipping == UIDrawCall.Clipping.None || mClipping == UIDrawCall.Clipping.ConstrainButDontClip);
        dc.sortingOrder = (mSortingOrder == 0) ? sortOrder : mSortingOrder;
        dc.sortingLayerName = mSortingLayerName;
        dc.clipTexture = mClipTexture;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7841366" class="outline-5">
<h5 id="org7841366">UIPanel 的裁剪是如何实现的？</h5>
<div class="outline-text-5" id="text-org7841366">
<p>
通过 Shader 来实现，原理就是，将指定区域外的像素 alpha 值设置为 0<br />
需要注意的是对于 UIPanel 的嵌套裁剪，NGUI 是通过不同的 Shader 来实现的。例如：<br />
Unlit - Text.shader 用于不裁剪的<br />
Unlit - Text (TextureClip).shader 用于通过贴图来裁剪<br />
Unlit - Text 1.shader 一个 UIPanel 裁剪<br />
Unlit - Text 2.shader 两个 UIPanel 嵌套裁剪<br />
Unlit - Text 3.shader 三个 UIPanel 嵌套裁剪<br />
</p>
<div class="org-src-container">
<pre class="src src-shader"><span style="color: #4f97d7; font-weight: bold;">Shader</span> <span style="color: #2d9574;">"Hidden/Unlit/Transparent Colored 1"</span>
{
    <span style="color: #4f97d7; font-weight: bold;">Properties</span>
    {
        <span style="color: #7590db;">_MainTex</span> (<span style="color: #2d9574;">"Base (RGB), Alpha (A)"</span>, <span style="color: #4f97d7; font-weight: bold;">2D</span>) = <span style="color: #2d9574;">"black"</span> {}
    }

    <span style="color: #4f97d7; font-weight: bold;">SubShader</span>
    {
        <span style="color: #4f97d7; font-weight: bold;">LOD</span> 200

        <span style="color: #4f97d7; font-weight: bold;">Tags</span>
        {
            <span style="color: #2d9574;">"Queue"</span> = <span style="color: #2d9574;">"Transparent"</span>
            <span style="color: #2d9574;">"IgnoreProjector"</span> = <span style="color: #2d9574;">"True"</span>
            <span style="color: #2d9574;">"RenderType"</span> = <span style="color: #2d9574;">"Transparent"</span>
            <span style="color: #2d9574;">"DisableBatching"</span> = <span style="color: #2d9574;">"True"</span>
        }

        <span style="color: #4f97d7; font-weight: bold;">Pass</span>
        {
            <span style="color: #4f97d7; font-weight: bold;">Cull</span> Off
            <span style="color: #4f97d7; font-weight: bold;">Lighting</span> Off
            <span style="color: #4f97d7; font-weight: bold;">ZWrite</span> Off
            <span style="color: #4f97d7; font-weight: bold;">Offset</span> -1, -1
            <span style="color: #4f97d7; font-weight: bold;">Fog</span> { <span style="color: #4f97d7; font-weight: bold;">Mode</span> Off }
            <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">ColorMask RGB</span>
            <span style="color: #4f97d7; font-weight: bold;">Blend</span> SrcAlpha OneMinusSrcAlpha

            <span style="color: #4f97d7; font-weight: bold;">CGPROGRAM</span>
<span style="color: #bc6ec5;">            #pragma</span> vertex vert
<span style="color: #bc6ec5;">            #pragma</span> fragment frag

<span style="color: #bc6ec5;">            #include</span> <span style="color: #2d9574;">"UnityCG.cginc"</span>

            <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">_MainTex</span>;
            <span style="color: #ce537a; font-weight: bold;">float4</span> <span style="color: #7590db;">_ClipRange0</span> = <span style="color: #ce537a; font-weight: bold;">float4</span>(0.0, 0.0, 1.0, 1.0);
            <span style="color: #ce537a; font-weight: bold;">float2</span> <span style="color: #7590db;">_ClipArgs0</span> = <span style="color: #ce537a; font-weight: bold;">float2</span>(1000.0, 1000.0);

            <span style="color: #4f97d7; font-weight: bold;">struct</span> appdata_t
            {
                <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">POSITION</span>;
                <span style="color: #ce537a; font-weight: bold;">half4</span> color : <span style="color: #a45bad;">COLOR</span>;
                <span style="color: #ce537a; font-weight: bold;">float2</span> texcoord : <span style="color: #a45bad;">TEXCOORD0</span>;
            };

            <span style="color: #4f97d7; font-weight: bold;">struct</span> v2f
            {
                <span style="color: #ce537a; font-weight: bold;">float4</span> vertex : <span style="color: #a45bad;">SV_POSITION</span>;
                <span style="color: #ce537a; font-weight: bold;">half4</span> color : <span style="color: #a45bad;">COLOR</span>;
                <span style="color: #ce537a; font-weight: bold;">float2</span> texcoord : <span style="color: #a45bad;">TEXCOORD0</span>;
                <span style="color: #ce537a; font-weight: bold;">float2</span> worldPos : <span style="color: #a45bad;">TEXCOORD1</span>;
            };

            v2f o;

            v2f <span style="color: #bc6ec5; font-weight: bold;">vert</span> (appdata_t v)
            {
                o.vertex = <span style="color: #4f97d7;">mul</span>(UNITY_MATRIX_MVP, v.vertex);
                o.color = v.color;
                o.texcoord = v.texcoord;
                o.worldPos = v.vertex.xy * <span style="color: #7590db;">_ClipRange0</span>.zw + <span style="color: #7590db;">_ClipRange0</span>.xy;
                <span style="color: #4f97d7; font-weight: bold;">return</span> o;
            }

            <span style="color: #ce537a; font-weight: bold;">half4</span> <span style="color: #bc6ec5; font-weight: bold;">frag</span> (v2f IN) : <span style="color: #a45bad;">SV_Target</span>
            {
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Softness factor</span>
                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36229;&#20986;&#35009;&#21098;&#21306;&#22495;&#30340; factor &#20250;&#21464;&#20026;&#36127;&#20540;&#65292;&#22312;&#38543;&#21518;&#30340; clamp &#20989;&#25968;&#20013;&#20250;&#21464;&#20026; 0</span>
                <span style="color: #ce537a; font-weight: bold;">float2</span> factor = (<span style="color: #ce537a; font-weight: bold;">float2</span>(1.0, 1.0) - <span style="color: #4f97d7;">abs</span>(IN.worldPos)) * <span style="color: #7590db;">_ClipArgs0</span>;

                <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sample the texture</span>
                <span style="color: #ce537a; font-weight: bold;">half4</span> col = <span style="color: #4f97d7;">tex2D</span>(<span style="color: #7590db;">_MainTex</span>, IN.texcoord) * IN.color;
                col.a *= <span style="color: #4f97d7;">clamp</span>( <span style="color: #4f97d7;">min</span>(factor.x, factor.y), 0.0, 1.0);
                <span style="color: #4f97d7; font-weight: bold;">return</span> col;
            }
            <span style="color: #4f97d7; font-weight: bold;">ENDCG</span>
        }
    }
    ......
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcd0c78d" class="outline-5">
<h5 id="orgcd0c78d">UIScrollView 中的 Item 有按钮时，NGUI 如何做到拖动按钮可以拖动 Item？</h5>
<div class="outline-text-5" id="text-orgcd0c78d">
<p>
需要在按钮上添加 UIDragScrollView 脚本，当 UICamera 检测出 Drag 操作时，会调用被拖动对象上的 OnDrag 方法，此时就会执行 UIDragScrollView 的 OnDrag 函数，从而调到 UIScrollView 的 OnDrag 方法。UIDragScrollView 脚本做了一次转发操作。<br />
</p>
</div>
</div>
<div id="outline-container-org78f36f2" class="outline-5">
<h5 id="org78f36f2"><span class="todo TODO">TODO</span> Outline 效果是如何实现的？</h5>
</div>
<div id="outline-container-orga935aba" class="outline-5">
<h5 id="orga935aba"><span class="todo TODO">TODO</span> 点击 Button 切换贴图是否会导致 UIDrawCall 重新生成？</h5>
</div>
</div>
</div>
<div id="outline-container-org4180237" class="outline-3">
<h3 id="org4180237">UGUI</h3>
<div class="outline-text-3" id="text-org4180237">
</div>
<div id="outline-container-org2ae5dee" class="outline-4">
<h4 id="org2ae5dee">UGUI 源码调试</h4>
<div class="outline-text-4" id="text-org2ae5dee">
<p>
ugui 源码下载地址 <a href="https://bitbucket.org/Unity-Technologies/ui/downloads?tab=tags">https://bitbucket.org/Unity-Technologies/ui/downloads?tab=tags</a><br />
</p>
</div>
<div id="outline-container-org76a7c48" class="outline-5">
<h5 id="org76a7c48">方案 1</h5>
<div class="outline-text-5" id="text-org76a7c48">
<p>
删除 Unity 原始的 UGUI 插件，将 UGUI 源代码 Copy 到项目目录下。<br />
</p>
</div>
<div id="outline-container-orgdde94fd" class="outline-6">
<h6 id="orgdde94fd">参考资料</h6>
</div>
</div>

<div id="outline-container-orgf4a1c16" class="outline-5">
<h5 id="orgf4a1c16">方案 2</h5>
<div class="outline-text-5" id="text-orgf4a1c16">
<ul class="org-ul">
<li>Step1 下载 ugui 源码，重新编译 solution<br /></li>
<li>Step2 将原始 UGUI 目录从 2017.2.0f3\Editor\Data\UnityExtensions\Unity\GUISystem copy 到 2017.2.0f3\GUISystem_bak<br /></li>
<li>Step3 将第一步中编译生成的 Output 目录下的内容，覆盖到原始 GUISystem 目录下。<br /></li>
<li><p>
Step4 执行下面命令生成 UnityEngine.UI.dll.mdb<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">cli.bat &#36335;&#24452; D:\Applications\Unity\2017.2.0f3\Editor\Data\MonoBleedingEdge\bin\cli.bat</span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">pdb2mdb.exe &#36335;&#24452; D:\Applications\Unity\2017.2.0f3\Editor\Data\MonoBleedingEdge\lib\mono\4.5\pdb2mdb.exe</span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">UnityEngine.UI.dll D:\Applications\Unity\2017.2.0f3\Editor\Data\UnityExtensions\Unity\GUISystem\UnityEngine.UI.dll</span>
cli.bat pdb2mdb.exe UnityEngine.UI.dll
</pre>
</div></li>
<li>Step5 将 UnityEngine.UI.csproj 添加到自己的 Unity 项目 Solution 中。<br /></li>
</ul>
</div>

<div id="outline-container-orga2051eb" class="outline-6">
<h6 id="orga2051eb">参考资料</h6>
<div class="outline-text-6" id="text-orga2051eb">
<p>
<a href="https://www.cnblogs.com/He-Ming/p/6244379.html">https://www.cnblogs.com/He-Ming/p/6244379.html</a><br />
<a href="http://blog.csdn.net/andyqingliu/article/details/54600961">http://blog.csdn.net/andyqingliu/article/details/54600961</a><br />
<a href="https://astrangergravity.com/writing/2018/debugging-into-unitys-internals">https://astrangergravity.com/writing/2018/debugging-into-unitys-internals</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbdb1121" class="outline-4">
<h4 id="orgbdb1121">UGUI 事件响应机制</h4>
<div class="outline-text-4" id="text-orgbdb1121">
</div>
<div id="outline-container-org5cee020" class="outline-5">
<h5 id="org5cee020">EventSystem</h5>
<div class="outline-text-5" id="text-org5cee020">
<p>
EventSystem 处理 输入，射线发射，并且发送事件。<br />
</p>

<p>
EventSystem 的职责是处理 Unity 场景中的事件。一个场景中只能包含一个 EventSystem。EventSystem 和多个 Modules 合作，将状态和委托函数保存到特定的可重写的组件上。<br />
</p>

<p>
在 BaseInputModule.OnEnable/OnDisable 中调用 EventSystem.UpdateModules() 函数来获取 EventSystem 对应 GameObject 上的所有激活的 BaseInputModule 组件，从而更新 EventSystem.m_systemInputModules。<br />
</p>

<p>
在 EventSystem.Update 中会调用 EventSystem.TickModules 遍历调用每一个 BaseInputModule.UpdateModule(),该函数中每个 Module 都可以修改自己的内部状态。<br />
当每个 Module 更新完成后,当前激活的 Module 会执行 BaseInputModule.Process()<br />
关于 <a href="#org7f530a0">No description for this link</a> 。<br />
</p>
</div>
</div>

<div id="outline-container-orge5d8f73" class="outline-5">
<h5 id="orge5d8f73">RaycasterManager</h5>
<div class="outline-text-5" id="text-orge5d8f73">
<p>
通过一个 List&lt;BaseRaycaster&gt; 来维护所有的 Raycaster.<br />
在 BaseRaycater.OnEnable 中会调用 RaycasterManager.AddRaycaster(raycaster)<br />
在 BaseRaycater.OnDisable 中会调用 RaycasterManager.RemoveRaycaster(raycaster)<br />
</p>
</div>
<div id="outline-container-org147d3b0" class="outline-6">
<h6 id="org147d3b0">GraphicRaycaster</h6>
<div class="outline-text-6" id="text-org147d3b0">
<p>
<a id="orga959637"></a><br />
在 Canvas 对应的 GameObject 上挂载了 GraphicRaycaster 组件。该组件主要用于赛选出所有和射线相交的 Graphic 对象。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ce537a; font-weight: bold;">void</span> GraphicRaycaster.<span style="color: #bc6ec5; font-weight: bold;">Raycast</span>(<span style="color: #ce537a; font-weight: bold;">PointerEventData</span> <span style="color: #7590db;">eventData</span>, <span style="color: #ce537a; font-weight: bold;">List</span>&lt;RaycastResult&gt; <span style="color: #7590db;">resultAppendList</span>)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">1 &#33719;&#21462; GraphicRaycaster &#23545;&#24212;&#30340; Canvas &#25152;&#31649;&#29702;&#30340;&#25152;&#26377; Graphic</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">2 &#21019;&#24314; Ray</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">3 &#35843;&#29992; void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results)</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">&#25910;&#38598;&#25152;&#26377;&#22312;&#23556;&#32447;&#19979;&#38754;&#30340; Graphic &#23545;&#35937;&#65292;&#23558;&#23427;&#20204;&#25353;&#29031; depth &#25490;&#24207;&#21518;&#25918;&#20837; resultAppendList &#36820;&#22238;.</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//   </span><span style="color: #2aa1ae; background-color: #292e34;">Graphic.</span><span style="color: #bc6ec5; font-weight: bold;">Raycast</span><span style="color: #2aa1ae; background-color: #292e34;">(Vector2 sp, Camera eventCamera)&#29992;&#20110;&#21028;&#26029;&#23556;&#32447;&#21644; Graphic &#23545;&#35937;&#26159;&#21542;&#30456;&#20132;. &#35814;&#32454;&#20449;&#24687;&#35831;&#30475;&#19979;&#38754;&#20869;&#23481;&#12290;</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">RaycastResult &#25968;&#25454;&#32467;&#26500;</span>
<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">castResult</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">RaycastResult</span>
{
    gameObject = go,
    module = <span style="color: #4f97d7; font-weight: bold;">this</span>,
    distance = distance,
    screenPosition = eventPosition,
    index = resultAppendList.Count,
    depth = m_RaycastResults[index].depth,
    sortingLayer = canvas.sortingLayerID,
    sortingOrder = canvas.sortingOrder
};
resultAppendList.<span style="color: #bc6ec5; font-weight: bold;">Add</span>(castResult);
</pre>
</div>
<p>
关于 <a href="#org461db72">No description for this link</a>。<br />
</p>
</div>
</div>
<div id="outline-container-org6d1c5bf" class="outline-6">
<h6 id="org6d1c5bf">Graphic.Raycast(Vector2 sp, Camera eventCamera)</h6>
<div class="outline-text-6" id="text-org6d1c5bf">
<p>
<a id="org461db72"></a><br />
该函数会遍历对应 GameObject 上的所有 Components，默认情况下，指定该对象和射线相交。对于非 ICanvasRaycastFilter 类型的 Component 不进行进一步的检查(在 GraphicRaycaster.Raycast 中已经检测过点击的屏幕位置是否在 Graphic 的 RectTransform 内)。 对于 ICanvasRaycastFilter 类型的 Component,会进一步调用 ICanvasRaycastFilter.IsRaycastLocationValid 来判断射线和 GameObject 是否相交。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org42d2276" class="outline-5">
<h5 id="org42d2276">GraphicRegistry</h5>
<div class="outline-text-5" id="text-org42d2276">
<p>
通过一个 Dictionary&lt;Canvas, IndexedSet&lt;Graphic&gt;&gt; m_Graphics = new Dictionary&lt;Canvas, IndexedSet&lt;Graphic&gt;&gt;(); 来维护所有 Canvas，以及属于该 Canvas 的所有 Graphic。<br />
</p>

<p>
在 Graphic.OnTransformParentChanged/OnEnable/OnCanvasHierarchyChanged 中会调用 GraphicRegistry.RegisterGraphicForCanvas(canvas, this);<br />
在 Graphic.OnBeforeTransformParentChanged/OnDisable/OnCanvasHierarchyChanged 中会调用 GraphicRegistry.UnregisterGraphicForCanvas(currentCanvas, this);<br />
正是因为这样，当 Graphic 对象 Disable 后就不会在响应触摸事件了。<br />
</p>
</div>
</div>
<div id="outline-container-orgbb6a6c6" class="outline-5">
<h5 id="orgbb6a6c6">StandaloneInputModule</h5>
<div class="outline-text-5" id="text-orgbb6a6c6">
<p>
<a id="org7f530a0"></a><br />
StandaloneInputModule.Process() 中的几个主要处理函数:<br />
</p>
</div>
<div id="outline-container-org399a1e1" class="outline-6">
<h6 id="org399a1e1">ProcessTouchEvents</h6>
<div class="outline-text-6" id="text-org399a1e1">
<p>
处理 Touch 事件。<br />
</p>
</div>
</div>
<div id="outline-container-orgabc7ef8" class="outline-6">
<h6 id="orgabc7ef8">ProcessMouseEvent</h6>
<div class="outline-text-6" id="text-orgabc7ef8">
<p>
处理 Mouse 事件。<br />
调用 GetMousePointerEventData 获取鼠标按钮的事件数据。 详细信息请看 <a href="#org03edd38">No description for this link</a><br />
调用 ProcessMousePress ProcessMove ProcessDrag 处理点击、移动、拖动事件<br />
</p>
</div>
</div>
<div id="outline-container-org4ea2ace" class="outline-6">
<h6 id="org4ea2ace">GetMousePointerEventData(int id)</h6>
<div class="outline-text-6" id="text-org4ea2ace">
<p>
<a id="org03edd38"></a><br />
填充 PointerEventData leftData,rightData,middleData;<br />
填充所需的数据一部分来自于 BaseInput,一部分来自于 EventSystem.RaycastAll() FindFirstRaycast()<br />
</p>

<p>
例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">leftData.delta = input.mousePosition - leftData.position;
leftData.position = input.mousePosition;
leftData.scrollData = input.mouseScrollDelta;

eventSystem.<span style="color: #bc6ec5; font-weight: bold;">RaycastAll</span>(leftData, m_RaycastResultCache);
<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">raycast</span> = FindFirstRaycast(m_RaycastResultCache);
leftData.pointerCurrentRaycast = raycast;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga888124" class="outline-6">
<h6 id="orga888124">EventSystem.RaycastAll()</h6>
<div class="outline-text-6" id="text-orga888124">
<p>
该函数中遍历了 RaycasterManager 中所有的 Raycaster，调用了 Raycaster.Raycast(eventData, raycastResults)方法，来获取所有 RaycastResult 列表数据.<br />
关于 GraphicRaycaster.Raycast 请查看链接： <a href="#orga959637">No description for this link</a> 。<br />
</p>
</div>
</div>
<div id="outline-container-org0f58da1" class="outline-6">
<h6 id="org0f58da1">ProcessMousePress</h6>
<div class="outline-text-6" id="text-org0f58da1">
<p>
调用 GameObject ExecuteHierarchy&lt;T&gt;(GameObject root, BaseEventData eventData, EventFunction&lt;T&gt; callbackFunction) where T : IEventSystemHandler 来触发事件处理函数,并返回处理事件的对象。<br />
</p>

<p>
其他具体处理细节，请看源码。<br />
</p>
</div>
</div>
<div id="outline-container-org2dbd77c" class="outline-6">
<h6 id="org2dbd77c">Tips</h6>
<div class="outline-text-6" id="text-org2dbd77c">
<ul class="org-ul">
<li>BaseInput 是对 Input 的封装<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7c4dc57" class="outline-4">
<h4 id="org7c4dc57">Q&amp;A</h4>
<div class="outline-text-4" id="text-org7c4dc57">
</div>
<div id="outline-container-org226f474" class="outline-5">
<h5 id="org226f474">如何实现一个可被点击的非渲染 UI 控件？</h5>
<div class="outline-text-5" id="text-org226f474">
<p>
因为 UGUI 底层只会赛选出 Graphic 进行射线检测，所以 GEmptyGraphic 必须为 Graphic 的子类。为了避免多余的绘制，需要重新实现 SetMaterialDirty，SetVerticesDirty 使它们不标记绘制数据的修改。<br />
重新实现 OnPopulateMesh 将 mesh 清空。<br />
</p>
<div class="org-src-container">
<pre class="src src-csharp">[AddComponentMenu(<span style="color: #2d9574;">"Layout/Extensions/GEmptyGraphic"</span>)]
<span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">GEmptyGraphic</span> : <span style="color: #ce537a; font-weight: bold;">Graphic</span>
{
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">SetMaterialDirty</span>() { <span style="color: #4f97d7; font-weight: bold;">return</span>; }
    <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">SetVerticesDirty</span>() { <span style="color: #4f97d7; font-weight: bold;">return</span>; }

    <span style="color: #4f97d7; font-weight: bold;">protected</span> <span style="color: #4f97d7; font-weight: bold;">override</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">OnPopulateMesh</span>(<span style="color: #ce537a; font-weight: bold;">VertexHelper</span> <span style="color: #7590db;">vh</span>)
    {
        vh.<span style="color: #bc6ec5; font-weight: bold;">Clear</span>();
        <span style="color: #4f97d7; font-weight: bold;">return</span>;
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
