<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-16 Fri 21:13 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UnrealEngineNote</title>
<meta name="generator" content="Org Mode" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1" />
         <link rel="stylesheet" title="Standard" href="https://wolfand11.github.io/res/worg_theme/css/worg.css" type="text/css" />
         <link rel="alternate stylesheet" title="Zenburn" href="https://wolfand11.github.io/res/worg_theme/css/worg-zenburn.css" type="text/css" />
         <link rel="alternate stylesheet" title="Classic" href="https://wolfand11.github.io/res/worg_theme/css/worg-classic.css" type="text/css" />
         <link rel="icon" href="https://wolfand11.github.io/res/favicon.ico" type="image/ico" />
         <script type="text/javascript" src="https://wolfand11.github.io/res/blog-tools.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://wolfand11.github.io"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">UnrealEngineNote</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4a5e1c6">Editor</a>
<ul>
<li><a href="#org790144b">基本操作</a></li>
<li><a href="#org8c5179d">Blueprint</a>
<ul>
<li><a href="#org2522169">快捷创建节点</a></li>
<li><a href="#orgb48db3c">添加变量 get 节点</a></li>
<li><a href="#org5278737">添加变量 set 节点</a></li>
<li><a href="#org9e73d5d">快捷定义变量</a></li>
<li><a href="#orgb4c3fd0">快捷定义函数参数 和 函数返回值参数</a></li>
<li><a href="#orgae768bb">修改函数参数后，函数调用节点不刷新</a></li>
<li><a href="#org4f07fbb">快捷删除连线</a></li>
</ul>
</li>
<li><a href="#orgd9ab7fa">Level Editor</a>
<ul>
<li><a href="#org9832e8a">如何设置关卡编辑器默认预览的渲染等级</a></li>
</ul>
</li>
<li><a href="#org8f2c501">Material Blueprint</a>
<ul>
<li><a href="#org53d633e">快捷创建 Blueprint 节点</a>
<ul>
<li><a href="#orga183480">创建节点</a></li>
<li><a href="#org5b066f2">常量节点和参数类型节点的互相转化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcd90d38">Q&amp;A</a>
<ul>
<li><a href="#orgca7157d">如何删除一个指定的 C++类？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf848380">Engine Features</a>
<ul>
<li><a href="#org46e9b10">Understanding the Basics</a>
<ul>
<li><a href="#orgccfc701">Directory Structure</a>
<ul>
<li><a href="#org31231f9">Game Project Directories</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0669c11">Setting Up Your Production Pipeline</a>
<ul>
<li><a href="#org0f015dc">Collaboration in Unreal Engine 4</a></li>
</ul>
</li>
<li><a href="#org451efdc">Designing Visuals, Rendering and Graphics</a>
<ul>
<li><a href="#org4327827">Introduction</a>
<ul>
<li><a href="#orgaaf89ec">Rendering Overview</a>
<ul>
<li><a href="#org69e892c">Deferred Shading 延迟着色</a></li>
<li><a href="#orge58afd9">Lighting Paths 光照路径</a></li>
<li><a href="#orgf482ddc">Lit Translucency 带光照的半透明</a></li>
<li><a href="#orgc41bb57">Sub-Surface Shading 子表面渲染</a></li>
<li><a href="#orgc641da1">GPU Particles GPU 粒子</a></li>
<li><a href="#org20021d1">后期特效</a></li>
</ul>
</li>
<li><a href="#orge408b09">Supported Rendering Features</a></li>
</ul>
</li>
<li><a href="#org2354aca">Art Setup and Tools</a>
<ul>
<li><a href="#org52bb93e">Render Targets</a>
<ul>
<li><a href="#org5bab5cb">Blueprints and Render Targets</a></li>
</ul>
</li>
<li><a href="#org4cea887">Materials</a>
<ul>
<li><a href="#orgeb94756">Essential Material Concepts</a></li>
<li><a href="#orgbe84af9">Material Editor</a></li>
<li><a href="#org3316565">Material Inputs</a></li>
<li><a href="#org9ce9443">Material Properties</a></li>
<li><a href="#org7b93235">Instanced Materials</a></li>
<li><a href="#orgc38fe47">Material Shading Models</a></li>
<li><a href="#orgc95a7f8">Layered Materials</a></li>
<li><a href="#org42eb2b7">Material Expression Reference</a></li>
<li><a href="#org4127fe2">Material Functions</a></li>
<li><a href="#org5cd3a60">Material Parameter Collections</a></li>
<li><a href="#org3c0670b">Customized UVs</a></li>
<li><a href="#org0fe4906">Refraction Mode:Pixel Normal Offset</a></li>
<li><a href="#orgecee561">Physically Based Materials</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4d5743f">Lighting Concepts and Features</a>
<ul>
<li><a href="#orgd0df9fe">Lighting the Environment</a>
<ul>
<li><a href="#org619f682">Essentials</a></li>
<li><a href="#org12652aa">Precomputed Lighting</a></li>
<li><a href="#org0c95dfb">Dynamic Lighting</a></li>
<li><a href="#org16e5e5b">General</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5c9367b">Visuals and System Tools</a>
<ul>
<li><a href="#org299a913">Cascade Particle Systems</a>
<ul>
<li><a href="#org0575fea">Key Particle Concepts</a></li>
<li><a href="#orgc4b724b">Particle System Level of Detail</a></li>
<li><a href="#org0a2f5c7">Vector Fields</a></li>
<li><a href="#orgf66458d">Particle Lights</a></li>
<li><a href="#org21914a8">VFX Optimization Guide</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2d2e11f">Performance And Debugging</a>
<ul>
<li><a href="#org4024875"><span class="todo TODO">TODO</span> Scalability</a></li>
<li><a href="#org17ecd6f"><span class="todo TODO">TODO</span> Rendering Visualizers</a></li>
</ul>
</li>
<li><a href="#org58a46ee">Mobile Rendering and Visualization</a>
<ul>
<li><a href="#org2aed6b6">Mobile Rendering</a></li>
<li><a href="#org028cbe5">Mobile Previewer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org946e60b">Programming and Scripting</a>
<ul>
<li><a href="#org47cd703">Programing with C++</a>
<ul>
<li><a href="#org6957655">Getting Started</a>
<ul>
<li><a href="#org8317793">Programming Quick Start</a></li>
<li><a href="#org5024f49">Introduction to C++ Programming in UE4</a>
<ul>
<li><a href="#org58cf50a">Base</a></li>
<li><a href="#orgb3cc0fe">Diving Deeper</a></li>
<li><a href="#orgb95af1c">Diving Deeper Still</a></li>
<li><a href="#org0c8284b">Memory Management and Carbage Collection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgde7bd4a">Development Setup</a>
<ul>
<li><a href="#org8597019">源码编译</a></li>
<li><a href="#orgf77b509"><span class="todo TODO">TODO</span> Coding Standard</a>
<ul>
<li><a href="#orge5c33cb">Naming Conventions</a></li>
<li><a href="#org604e028">Portable Aliases for Basic C++ Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2456010">Unreal Engine Architecture</a>
<ul>
<li><a href="#orge011bac">Overview</a>
<ul>
<li><a href="#orga892cb5">表示世界中的玩家、朋友和敌人</a></li>
<li><a href="#org67acd66">使用玩家输入或 AI 逻辑控制 Pawns</a></li>
<li><a href="#org793fee2">显示玩家信息</a></li>
<li><a href="#org8e4f3c6">设置和追踪游戏的规则</a></li>
<li><a href="#org421e931">Framework Class Relationships</a></li>
</ul>
</li>
<li><a href="#org25de8c9">Gameplay Classes</a></li>
<li><a href="#orgea482fd">Gameplay Modules</a></li>
<li><a href="#org98e09f5">UFunctions</a></li>
<li><a href="#org1a27419">Interfaces</a></li>
<li><a href="#org8213981">Properties</a></li>
<li><a href="#orgef27c3a">Structs</a></li>
<li><a href="#org5367a43">Metadata Specifiers</a></li>
</ul>
</li>
<li><a href="#org960b775">Gameplay Architecture</a></li>
<li><a href="#orgb5eff80">Gameplay Guides</a></li>
<li><a href="#org84d09e5">System Guides</a>
<ul>
<li><a href="#org2bb47cf">Graphics=Programming</a></li>
</ul>
</li>
<li><a href="#org06cd875">Automated Builds</a></li>
</ul>
</li>
<li><a href="#org392e4b1">Asset Handling Reference Guides</a></li>
<li><a href="#org53fa087">Blueprint Visual Scripting</a></li>
<li><a href="#org76051b7">Class Creation Basics</a></li>
<li><a href="#org6f4945e">Gameplay Architecture</a></li>
<li><a href="#orgb348d17">Gameplay Debugger</a></li>
<li><a href="#orge01e597">Graphics Programming</a>
<ul>
<li><a href="#org3b631c2">Graphics Programming Overview</a>
<ul>
<li><a href="#orgf0ca9a5">Getting Started</a></li>
<li><a href="#org40a0c6c">Modules</a></li>
<li><a href="#org026b100">Scene representation</a>
<ul>
<li><a href="#org68f8a11">Primary scene classes</a></li>
<li><a href="#orgd066efb">Material classes</a></li>
<li><a href="#orgdd6ed1f">Primitive components and proxies</a></li>
<li><a href="#org4c9bbe9">FPrimitiveSceneProxy and FPrimitiveSceneInfo</a></li>
<li><a href="#org1890350">Important FPrimitiveSceneProxy methods</a></li>
<li><a href="#orge9e5cd7">Scene Rendering order</a></li>
<li><a href="#org6110470">Relevance</a></li>
<li><a href="#orgaacaeb1">Drawing Policies</a></li>
<li><a href="#org032a3da">Drawing Policy methods</a></li>
</ul>
</li>
<li><a href="#orgcbe7384">Rendering paths</a>
<ul>
<li><a href="#orga1096a8">Dynamic rendering path</a></li>
<li><a href="#org3204f80">Static rendering path</a></li>
</ul>
</li>
<li><a href="#org2a25542">High level Rendering order</a></li>
<li><a href="#orgf9fc846">Render Hardware Interface</a>
<ul>
<li><a href="#org8f470ca">Rendering state grouping</a></li>
<li><a href="#orgdc02323">Rendering state defaults</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf08885c">Threaded Rendering</a>
<ul>
<li><a href="#org328a4bc">Rendering thread</a>
<ul>
<li><a href="#org35f2916">Development approach</a></li>
<li><a href="#org7343f88">Thread specific data structures</a></li>
<li><a href="#orgf0c15ae">Performance considerations</a></li>
</ul>
</li>
<li><a href="#orga25131f">Inter-thread communication</a>
<ul>
<li><a href="#orgd2ed48b">Asynchronous</a></li>
<li><a href="#orgd791fae">Blocking</a></li>
<li><a href="#org1eebd7f">Rendering resources</a></li>
<li><a href="#orgf8d77fa">UObjects and Garbage Collection</a></li>
<li><a href="#org6639604">Game thread FRenderResource handling</a></li>
</ul>
</li>
<li><a href="#org010c090">Updating state vs Traversing the scene for rendering</a></li>
</ul>
</li>
<li><a href="#org38697ad">Shader Development</a>
<ul>
<li><a href="#orgdd61a70">AsyncCompute</a></li>
<li><a href="#org4d55b95">HLSL Cross Compiler</a></li>
</ul>
</li>
<li><a href="#org301b18a">Shaders In Plugins</a>
<ul>
<li><a href="#orgf200f89">Overview Shader in Plugins</a></li>
<li><a href="#orgdfb92d5">Create a New Global Shader as a Plugin</a></li>
</ul>
</li>
<li><a href="#org0f4f7ad">FShaderCache</a>
<ul>
<li><a href="#org42ee107">Overview</a></li>
<li><a href="#org6538bed">Use</a>
<ul>
<li><a href="#orgc160ad9">Integration Steps</a></li>
</ul>
</li>
<li><a href="#org5f8f0f9">Handling Updates/Invalidation</a></li>
<li><a href="#orgf65809f">Region/Stream Batching</a></li>
</ul>
</li>
<li><a href="#org6c90845">参考资料</a></li>
</ul>
</li>
<li><a href="#orgfe2738d">Slate UI Framework</a></li>
<li><a href="#org6aa1831">Programming Subsystems</a></li>
<li><a href="#org73819a5">Gameplay Tags</a></li>
<li><a href="#org084fd2a">Unreal Projects and Gameplay</a></li>
<li><a href="#orgc126e27">Spawning/Destroying an Actor Overview</a></li>
<li><a href="#orga3baa6e">OnlineSubsystem</a></li>
</ul>
</li>
<li><a href="#org1bcdc8c">Samples and Tutorials</a>
<ul>
<li><a href="#org8572c06">Templates</a></li>
<li><a href="#org851b40b">Learning Resource Projects</a>
<ul>
<li><a href="#orge905daa">Gameplay Concept Examples</a></li>
<li><a href="#orgc975b44">Example Game Projects</a></li>
<li><a href="#orgd12b2ad">Engine Feature Examples</a>
<ul>
<li><a href="#org01acc1a">Photorealistic Character</a>
<ul>
<li><a href="#orge991161">Skin Shading</a></li>
<li><a href="#orgcf4e991">Hair Shading</a></li>
<li><a href="#org135d37c">Eye Shading</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge29fa05">Community Sample Documentation</a></li>
</ul>
</li>
<li><a href="#orgc149846">Sharing and Releasing Projects</a>
<ul>
<li><a href="#org074e722">Mobile</a>
<ul>
<li><a href="#org0c3c426">Mobile Game Development</a></li>
<li><a href="#orgfbbd2de">Android Game Development</a>
<ul>
<li><a href="#org061f215">项目设置</a>
<ul>
<li><a href="#org0c55469">Package game data inside .apk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3f0ec46">iOS Game Development</a></li>
</ul>
</li>
<li><a href="#orge16e243">Virtual Reality</a></li>
<li><a href="#org69120ba">Desktop</a></li>
<li><a href="#org4193edd">Platform Tools</a></li>
</ul>
</li>
<li><a href="#org13f71de">Tutorial</a>
<ul>
<li><a href="#org10576dc">UnrealEngine 4x Example</a>
<ul>
<li><a href="#orgd2044f3">相关资源下载</a></li>
</ul>
</li>
<li><a href="#org91a98f6">Content Examples</a>
<ul>
<li><a href="#org9837e6b">参考资料</a></li>
</ul>
</li>
<li><a href="#orgd4d0550">2D Platformer with UE4</a></li>
</ul>
</li>
<li><a href="#org106bb2a">开发经验积累</a>
<ul>
<li><a href="#orgb0feca9">Blueprint</a>
<ul>
<li><a href="#org1993796">Architecture</a>
<ul>
<li><a href="#orga51b5ce">如何使用 blueprint 写公用的工具类</a>
<ul>
<li><a href="#orgee22683">方案一 使用 MacroLib 来定义公用的 Macro</a></li>
<li><a href="#orgf41f2d3">方案二 使用 Function Lib 来实现公用的 Function</a></li>
</ul>
</li>
<li><a href="#orga46b9c2">如何实现单例</a>
<ul>
<li><a href="#org9e035b7">Tips</a></li>
</ul>
</li>
<li><a href="#org2905dce">Event Dispatcher</a>
<ul>
<li><a href="#org2367d80">EventDispatcher 使用方法</a></li>
<li><a href="#org15f03a2">EventManager 实现</a></li>
</ul>
</li>
<li><a href="#orgb0de781">Blueprint 中实例创建</a>
<ul>
<li><a href="#org0fd4273">Game Instance</a></li>
<li><a href="#org37f35ac">Spawn Actor</a></li>
<li><a href="#org17c2e3f">Construct Object from class</a></li>
</ul>
</li>
<li><a href="#org3f87001">Blueprint 代码规范</a>
<ul>
<li><a href="#orgb66d722">Macro 命名规则</a></li>
<li><a href="#org3857a08">Func 命名规则</a></li>
<li><a href="#org98489fb">UI 命名规则</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge895f64">Gameplay</a>
<ul>
<li><a href="#orgeb0e671">如何设置角色出生点位置</a></li>
<li><a href="#org01b0395">如何将操纵的角色默认加入场景</a></li>
<li><a href="#org44fc776">如何方便地设置 Player Start 朝向某个物体？</a></li>
<li><a href="#orgf56587b">如何修改默认生成摄像机的速度？</a></li>
</ul>
</li>
<li><a href="#orgcaa6a96">Utility</a>
<ul>
<li><a href="#org4812554">如何在 Macro Lib/ Func Lib 中定义大小可变的数组？</a></li>
<li><a href="#org62acb63"><span class="todo TODO">TODO</span> Macro 的 Wildcard 类型</a></li>
<li><a href="#org149a1f1">封装日志打印函数</a></li>
</ul>
</li>
<li><a href="#org4e409f8">Misc</a>
<ul>
<li><a href="#org848909d">关于 WorldContext</a>
<ul>
<li><a href="#orgfe872c7"><span class="todo TODO">TODO</span> WorldContext 是什么？</a></li>
<li><a href="#org587e3e0">Macro Lib 中的 WorldContext 输入参数</a></li>
<li><a href="#org2476b1c">Func Lib 中的 WorldContext 输入参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8cd19ef">CPlusPlus</a>
<ul>
<li><a href="#org269bfe1">Q&amp;A</a>
<ul>
<li><a href="#org013c407">c++中如何打印日志到屏幕？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7590d60">UI</a>
<ul>
<li><a href="#org40cd5a2">如何动态添加 Item 到 UI 列表中？</a></li>
<li><a href="#org85d60c1">UI 事件触发顺序</a></li>
</ul>
</li>
<li><a href="#org3a9c9dd">Material</a>
<ul>
<li><a href="#orgcb04377">材质编辑器中如何预览某个节点输出的颜色？</a></li>
<li><a href="#org33cc0a2">如何修改材质属性</a></li>
<li><a href="#org7a8ae8c">材质函数中的 Parameter 参数如何暴露给材质呢？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org59044dc">参考资料</a>
<ul>
<li><a href="#orgd39b008">UE5</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
UnrealEngine note.<br />
</p>
<div class="HTML" id="org24faca6">
<p>
&lt;!&#x2013; more &#x2013;&gt;<br />
</p>

</div>

<div id="outline-container-org4a5e1c6" class="outline-2">
<h2 id="org4a5e1c6">Editor</h2>
<div class="outline-text-2" id="text-org4a5e1c6">
</div>
<div id="outline-container-org790144b" class="outline-3">
<h3 id="org790144b">基本操作</h3>
<div class="outline-text-3" id="text-org790144b">
<ul class="org-ul">
<li>视角定位到物体<br />
选中物体，按 F 按键<br /></li>
<li>物体三围修改<br />
选中物体<br />
  按 W 修改 transform<br />
  按 E 修改 Rotation<br />
  按 R 修改 Scale<br /></li>
<li>视角绕物体旋转<br />
按住 Alt 键，按住鼠标左键，移动鼠标<br /></li>
<li>视角 ZoomIn ZoomOut<br />
按住 Alt 键，按住鼠标右键，移动鼠标<br /></li>
<li>平移摄像机<br />
按住鼠标中间键，移动鼠标<br /></li>
<li>显示鼠标指针<br />
按 Shift+F1 在运行模式下显示鼠标指针<br /></li>
<li>物体和视角对齐<br />
在 Outline 窗口，右键点击物体，选择 Align to View 选项<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8c5179d" class="outline-3">
<h3 id="org8c5179d">Blueprint</h3>
<div class="outline-text-3" id="text-org8c5179d">
</div>
<div id="outline-container-org2522169" class="outline-4">
<h4 id="org2522169">快捷创建节点</h4>
<div class="outline-text-4" id="text-org2522169">
<p>
创建节点的快捷键基本上都是，长按某个键，然后在 Blueprint 中点击鼠标左键<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">节点</th>
<th scope="col" class="org-left">快捷方式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Branch</td>
<td class="org-left">长按 b</td>
</tr>

<tr>
<td class="org-left">ForEachLoop</td>
<td class="org-left">长按 f</td>
</tr>

<tr>
<td class="org-left">Sequence</td>
<td class="org-left">长按 s</td>
</tr>

<tr>
<td class="org-left">Comment</td>
<td class="org-left">按 c,不需要再 Blueprint 中点击左键</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb48db3c" class="outline-4">
<h4 id="orgb48db3c">添加变量 get 节点</h4>
<div class="outline-text-4" id="text-orgb48db3c">
<p>
按住 Ctrl 拖动变量到 blueprint, 添加变量 get 节点<br />
</p>
</div>
</div>
<div id="outline-container-org5278737" class="outline-4">
<h4 id="org5278737">添加变量 set 节点</h4>
<div class="outline-text-4" id="text-org5278737">
<p>
按住 Alt 拖动变量到 blueprint, 添加变量 set 节点<br />
</p>
</div>
</div>
<div id="outline-container-org9e73d5d" class="outline-4">
<h4 id="org9e73d5d">快捷定义变量</h4>
<div class="outline-text-4" id="text-org9e73d5d">
<p>
从别处粘贴函数到新的蓝图函数中，如果对应变量不存在，可以右击该变量节点，选择 create variable xxxx 定义类成员变量；或者选择 create local variable xxxx 定义函数局部变量。<br />
</p>
</div>
</div>
<div id="outline-container-orgb4c3fd0" class="outline-4">
<h4 id="orgb4c3fd0">快捷定义函数参数 和 函数返回值参数</h4>
<div class="outline-text-4" id="text-orgb4c3fd0">
<ul class="org-ul">
<li>定义函数输入参数    从匹配的函数参数 拉线 到 当前函数的输入参数节点，会自动定义输入参数。<br /></li>
<li>定义函数返回值参数  从匹配的变量 拉线 到 当前函数的返回值参数节点，会自动定义返回值参数。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgae768bb" class="outline-4">
<h4 id="orgae768bb">修改函数参数后，函数调用节点不刷新</h4>
<div class="outline-text-4" id="text-orgae768bb">
<ul class="org-ul">
<li>右键点击函数调用节点 选择 Refresh Nodes 手动刷新<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4f07fbb" class="outline-4">
<h4 id="org4f07fbb">快捷删除连线</h4>
<div class="outline-text-4" id="text-org4f07fbb">
<p>
长按 Alt 键，点击要删除的连线。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd9ab7fa" class="outline-3">
<h3 id="orgd9ab7fa">Level Editor</h3>
<div class="outline-text-3" id="text-orgd9ab7fa">
</div>
<div id="outline-container-org9832e8a" class="outline-4">
<h4 id="org9832e8a">如何设置关卡编辑器默认预览的渲染等级</h4>
<div class="outline-text-4" id="text-org9832e8a">
<p>
在关卡编辑器中，Setting 菜单中进行设置。如下图所示：<br />
<img src="UnrealEngineNote/001_preview_rendering_level_setting.jpg" alt="001_preview_rendering_level_setting.jpg" /><br />
</p>
<ul class="org-ul">
<li>参考资料<br />
<a href="https://docs.unrealengine.com/latest/INT/Platforms/Mobile/Previewer/index.html#platformmaterialqualitysettings">https://docs.unrealengine.com/latest/INT/Platforms/Mobile/Previewer/index.html#platformmaterialqualitysettings</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8f2c501" class="outline-3">
<h3 id="org8f2c501">Material Blueprint</h3>
<div class="outline-text-3" id="text-org8f2c501">
</div>
<div id="outline-container-org53d633e" class="outline-4">
<h4 id="org53d633e">快捷创建 Blueprint 节点</h4>
<div class="outline-text-4" id="text-org53d633e">
</div>
<div id="outline-container-orga183480" class="outline-5">
<h5 id="orga183480">创建节点</h5>
<div class="outline-text-5" id="text-orga183480">
<p>
创建节点的快捷键基本上都是，长按某个键，然后在 Blueprint 中点击鼠标左键<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">节点</th>
<th scope="col" class="org-left">快捷方式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1 维常量</td>
<td class="org-left">长按 1</td>
</tr>

<tr>
<td class="org-left">2 维常量</td>
<td class="org-left">长按 2</td>
</tr>

<tr>
<td class="org-left">3 维常量</td>
<td class="org-left">长按 3</td>
</tr>

<tr>
<td class="org-left">4 维常量</td>
<td class="org-left">长按 4</td>
</tr>

<tr>
<td class="org-left">Add</td>
<td class="org-left">长按 a</td>
</tr>

<tr>
<td class="org-left">Multiply</td>
<td class="org-left">长按 m</td>
</tr>

<tr>
<td class="org-left">TextureSample</td>
<td class="org-left">长按 m</td>
</tr>

<tr>
<td class="org-left">TexCoord</td>
<td class="org-left">长按 u</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5b066f2" class="outline-5">
<h5 id="org5b066f2">常量节点和参数类型节点的互相转化</h5>
<div class="outline-text-5" id="text-org5b066f2">
<p>
右键点击常量节点 执行 Convert to Parameter<br />
右键点击参数类型节点 执行 Convert to Constant<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcd90d38" class="outline-3">
<h3 id="orgcd90d38">Q&amp;A</h3>
<div class="outline-text-3" id="text-orgcd90d38">
</div>
<div id="outline-container-orgca7157d" class="outline-4">
<h4 id="orgca7157d">如何删除一个指定的 C++类？</h4>
<div class="outline-text-4" id="text-orgca7157d">
<p>
为了从你的项目中删除一个 C++类，请遵循以下步骤：<br />
</p>
<ol class="org-ol">
<li>关闭 Visual Studio<br /></li>
<li>关闭 UE4 编辑器<br /></li>
<li>在文件管理器（explorer）中从你的硬盘移除相应的.cpp 和.h 文件<br /></li>
<li>移除 Binaries 文件夹中的所有内容<br /></li>
<li>右键点击.uproject 文件然后点击生成 Visual Studio 项目文件（Generate Visual Studio Project Files）<br /></li>
<li>返回到你的正常工作中<br /></li>
</ol>
<p>
如果一个错误信息弹出，告诉你要在启动 UE4 编辑器的时候重新编译项目，点击“是”。<br />
</p>

<p>
参考资料 <a href="http://gad.qq.com/program/translateview/7190281">http://gad.qq.com/program/translateview/7190281</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf848380" class="outline-2">
<h2 id="orgf848380">Engine Features</h2>
<div class="outline-text-2" id="text-orgf848380">
</div>
<div id="outline-container-org46e9b10" class="outline-3">
<h3 id="org46e9b10">Understanding the Basics</h3>
<div class="outline-text-3" id="text-org46e9b10">
</div>
<div id="outline-container-orgccfc701" class="outline-4">
<h4 id="orgccfc701">Directory Structure</h4>
<div class="outline-text-4" id="text-orgccfc701">
<p>
UE4 目录结构 <a href="https://docs.unrealengine.com/latest/INT/Engine/Basics/DirectoryStructure/index.html">https://docs.unrealengine.com/latest/INT/Engine/Basics/DirectoryStructure/index.html</a><br />
</p>
</div>

<div id="outline-container-org31231f9" class="outline-5">
<h5 id="org31231f9">Game Project Directories</h5>
<div class="outline-text-5" id="text-org31231f9">
<p>
对于游戏项目来说，只需要上传 Config Content Source 三个目录<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Directory</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Binaries</td>
<td class="org-left">包含执行文件或其他编译阶段创建的文件</td>
</tr>

<tr>
<td class="org-left">Config</td>
<td class="org-left">游戏项目的默认配置</td>
</tr>

<tr>
<td class="org-left">Content</td>
<td class="org-left">包含游戏或引擎的内容，资源包或者地图</td>
</tr>

<tr>
<td class="org-left">External dependencies</td>
<td class="org-left">显示引擎的公共头文件，只在 VisualStudio 中显示</td>
</tr>

<tr>
<td class="org-left">Intermediate</td>
<td class="org-left">由 UnrealBuildTool 生成的文件。这些文件可以被删除后，重新构建</td>
</tr>

<tr>
<td class="org-left">Saved</td>
<td class="org-left">包含引擎生成的文件，如配置文件或日志文件。这些文件可以被删除后，重新构建</td>
</tr>

<tr>
<td class="org-left">Source</td>
<td class="org-left">包含游戏模块对象类文件</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Classes 包含游戏对象类定义 (.h 文件)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Private 包含私有的游戏对象类的实现 (.cpp 文件)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Public 包含公共的游戏对象类的实现 (.cpp 文件)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div id="outline-container-org0669c11" class="outline-3">
<h3 id="org0669c11">Setting Up Your Production Pipeline</h3>
<div class="outline-text-3" id="text-org0669c11">
</div>
<div id="outline-container-org0f015dc" class="outline-4">
<h4 id="org0f015dc">Collaboration in Unreal Engine 4</h4>
<div class="outline-text-4" id="text-org0f015dc">
<p>
Source Control <a href="https://docs.unrealengine.com/latest/INT/Engine/UI/SourceControl/index.html">https://docs.unrealengine.com/latest/INT/Engine/UI/SourceControl/index.html</a><br />
Collaboration in Unreal Engine 4    <a href="https://docs.unrealengine.com/latest/INT/Engine/Basics/SourceControl/index.html">https://docs.unrealengine.com/latest/INT/Engine/Basics/SourceControl/index.html</a><br />
Source Control Inside Unreal Editor <a href="https://docs.unrealengine.com/latest/INT/Engine/Basics/SourceControl/InEditor/index.html">https://docs.unrealengine.com/latest/INT/Engine/Basics/SourceControl/InEditor/index.html</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org451efdc" class="outline-3">
<h3 id="org451efdc">Designing Visuals, Rendering and Graphics</h3>
<div class="outline-text-3" id="text-org451efdc">
</div>
<div id="outline-container-org4327827" class="outline-4">
<h4 id="org4327827">Introduction</h4>
<div class="outline-text-4" id="text-org4327827">
</div>
<div id="outline-container-orgaaf89ec" class="outline-5">
<h5 id="orgaaf89ec">Rendering Overview</h5>
<div class="outline-text-5" id="text-orgaaf89ec">
<p>
虚幻 4 的渲染系统是全新的。DirectX11 管线包含延迟渲染，全局光照，带光照的半透明物体，后期处理，以及利用矢量场的 GPU 离子模拟<br />
</p>
</div>
<div id="outline-container-org69e892c" class="outline-6">
<h6 id="org69e892c">Deferred Shading 延迟着色</h6>
<div class="outline-text-6" id="text-org69e892c">
<p>
在虚幻 4 中，所有光照都是延迟应用的，相对地在虚幻 3 中使用的是正向光照路径。材质将它们的属性写入 GBuffers 中，在光照阶段，读取每个像素的材质属性并使用它们来执行光照计算。<br />
</p>
</div>
</div>
<div id="outline-container-orge58afd9" class="outline-6">
<h6 id="orge58afd9">Lighting Paths 光照路径</h6>
<div class="outline-text-6" id="text-orge58afd9">
<p>
在 UE4 中有三种光照路径：<br />
</p>
<ul class="org-ul">
<li>Fully dynamic<br /></li>
<li>Partially static<br /></li>
<li>Fully static<br /></li>
</ul>
<p>
这些在质量、性能以及游戏中可变性方面有不同的权衡。游戏根据自身需求选择最合适的。<br />
</p>
</div>
</div>
<div id="outline-container-orgf482ddc" class="outline-6">
<h6 id="orgf482ddc">Lit Translucency 带光照的半透明</h6>
<div class="outline-text-6" id="text-orgf482ddc">
<p>
半透明的光照和渲染是在一个单独的正向阶段进行的，从而可以保证和其他半透明正确的混合，这在多个阶段的光照技术中无法实现。<br />
半透明物体可以在固体世界或者自身或者其他半透明物体上投射出阴影。<br />
</p>
</div>
</div>
<div id="outline-container-orgc41bb57" class="outline-6">
<h6 id="orgc41bb57">Sub-Surface Shading 子表面渲染</h6>
<div class="outline-text-6" id="text-orgc41bb57">
<p>
材质包含了新的渲染模型 MLM_Subsurface，该模型用于蜡烛或翡翠等表现为固体，但是光照在内部会散射。这种渲染模型比皮肤渲染质量要低，性能要求也低。<br />
</p>
</div>
</div>
<div id="outline-container-orgc641da1" class="outline-6">
<h6 id="orgc641da1">GPU Particles GPU 粒子</h6>
<div class="outline-text-6" id="text-orgc641da1">
<p>
UE4 支持在 GPU 上模拟粒子。传统的 CPU 系统支持每帧渲染数千个粒子。GPU 模拟支持数十万个粒子。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd75b3db"></a>矢量场<br />
<div class="outline-text-7" id="text-orgd75b3db">
<p>
矢量场是一个能对粒子运动产生统一影响的矢量网格。矢量场被作为 Actor 放置在世界中，而且可以像其他 Actor 一样被平移，旋转和缩放。并且它们是动态的，可以在任何时候被移动。<br />
矢量场也可以在 Cascade 内使用，这样可以将它的作用限制在相关的粒子发射器中。当粒子进入矢量场的边界时，粒子的运动会受矢量场影响。当粒子离开该边界时，矢量场对粒子的影响消失。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org20021d1" class="outline-6">
<h6 id="org20021d1">后期特效</h6>
<div class="outline-text-6" id="text-org20021d1">
</div>
<ul class="org-ul">
<li><a id="org37a9c30"></a>环境遮挡<br /></li>
<li><a id="org0d51f39"></a>环境立方体贴图<br /></li>
<li><a id="org03b875b"></a>光溢出（泛光）Bloom<br />
<div class="outline-text-7" id="text-org03b875b">
<p>
当裸眼看非常亮的物体并且它的背景比较暗时，会看到泛光现象。其产生的原因是，光在视网膜上或者在电影胶片上或者相机前面乳白色玻璃滤镜上的散射。<br />
</p>
</div>
</li>
<li><a id="org5f3316a"></a>泛光遮罩 Bloom Dirt Mask<br /></li>
<li><a id="org4b083e8"></a>眼睛适应 Eye Adaptation(Automatic Exposure)<br />
<div class="outline-text-7" id="text-org4b083e8">
<p>
控制场景曝光自动调节，来再现人眼在明亮和黑暗环境下切换时的效果。<br />
勾选 Project Settings/Rendering/Default Settings/Auto Exposure 选项来开启关闭该功能。<br />
</p>
</div>
</li>
<li><a id="orgfd8dc27"></a>镜头光晕 Lens Flare<br /></li>
<li><a id="org4fafaae"></a>色调映射 Tone Mapping<br />
<div class="outline-text-7" id="text-org4fafaae">
<p>
色调映射可以平移和修改被渲染场景的颜色，从而改变最终结果。<br />
</p>
</div>
</li>
<li><a id="org2ec12eb"></a>Vignette<br />
<div class="outline-text-7" id="text-org2ec12eb">
<p>
随着距离视口中心越远，被渲染场景的亮度越低。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge408b09" class="outline-5">
<h5 id="orge408b09">Supported Rendering Features</h5>
<div class="outline-text-5" id="text-orge408b09">
<ul class="org-ul">
<li><a href="https://docs.unrealengine.com/en-US/RenderingAndGraphics/SupportedRenderingFeatures/index.html">https://docs.unrealengine.com/en-US/RenderingAndGraphics/SupportedRenderingFeatures/index.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2354aca" class="outline-4">
<h4 id="org2354aca">Art Setup and Tools</h4>
<div class="outline-text-4" id="text-org2354aca">
</div>
<div id="outline-container-org52bb93e" class="outline-5">
<h5 id="org52bb93e">Render Targets</h5>
<div class="outline-text-5" id="text-org52bb93e">
<p>
在 UE4 中，非常广泛地使用了 Render Targets 来实现各种不同的任务。从为延迟渲染存储各种 buffers 到辅助显示各种复杂的效果，可以利用 Render Target 来实现各种有趣和有用的效果。<br />
</p>
</div>
<div id="outline-container-org5bab5cb" class="outline-6">
<h6 id="org5bab5cb">Blueprints and Render Targets</h6>
<div class="outline-text-6" id="text-org5bab5cb">
</div>
<ul class="org-ul">
<li><a id="org9117cc9"></a>Blueprint and Render Targets How To's<br />
<ul class="org-ul">
<li><a id="org5049717"></a>Creating Textures Using Blueprints and RenderTargets<br /></li>
<li><a id="org2e661a0"></a>Creating a Height Field Painter With Blueprints and RenderTargets<br /></li>
<li><a id="org7806e0f"></a>Creating a Fluid surface with Blueprints and RenderTargets<br />
<div class="outline-text-8" id="text-org7806e0f">
<ul class="org-ul">
<li>通过偏移 UV 坐标，来偏移采样点。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6758ce4"></a>参考资料<br />
<div class="outline-text-9" id="text-org6758ce4">
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/zenny-chen/archive/2012/12/23/2830113.html">https://www.cnblogs.com/zenny-chen/archive/2012/12/23/2830113.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4cea887" class="outline-5">
<h5 id="org4cea887">Materials</h5>
<div class="outline-text-5" id="text-org4cea887">
<p>
材质是一种资源，它可以被应用于网格来控制场景视觉上看到的样子。从高层次上来看，可以将材质设当作应用到物体上的“绘画”。但是这样也会有一些误解，因为材质定义的是组成该物体所用的表面类型。<br />
用更专业的术语来说，材质用来计算光和表面如何交互。<br />
</p>
</div>
<div id="outline-container-orgeb94756" class="outline-6">
<h6 id="orgeb94756">Essential Material Concepts</h6>
<div class="outline-text-6" id="text-orgeb94756">
<p>
材质是决定物体和关卡表现的决定因素之一。这部分文档的作用是以快速和高层次的方法来创建自己的材质。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3c25844"></a>Material Expression Nodes and Networks<br />
<div class="outline-text-7" id="text-org3c25844">
<p>
材质不是通过代码来创建的，而是在材质编辑器中用可视化脚本节点（被称为材质表达式）的网络来创建的。每个节点包含一段 HLSL 代码，来执行一个特殊的任务。创建材质其实就是通过可视化脚本来创建 HLSL 代码。<br />
</p>
</div>
</li>
<li><a id="org735d331"></a>Working with Colors and Numbers<br /></li>
<li><a id="org606d175"></a>Textures<br />
<div class="outline-text-7" id="text-org606d175">
<p>
贴图是材质的组件，而不是最终的结果。<br />
创建好贴图并将其导入 Unreal 编辑器后，就可以通过特殊的材质表达式节点（例如，Texture Sample 节点）将贴图引入材质中。<br />
</p>
</div>
</li>
<li><a id="orgd6ca994"></a>Properties and Inputs<br />
<div class="outline-text-7" id="text-orgd6ca994">
<ul class="org-ul">
<li>Material Properties<br />
<a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/MaterialProperties/index.html">https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/MaterialProperties/index.html</a><br /></li>
<li>Material Inputs<br />
<a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/MaterialInputs/index.html">https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/MaterialInputs/index.html</a><br /></li>
</ul>
</div>
</li>
<li><a id="orgde06345"></a>Applying Materials to Surface<br />
<div class="outline-text-7" id="text-orgde06345">
<p>
对于不同类型的表面，应用材质的方式有些许变化<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org48b7bc0"></a>Meshes<br /></li>
<li><a id="orgb4b72de"></a>Brush Surfaces<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgbe84af9" class="outline-6">
<h6 id="orgbe84af9">Material Editor</h6>
<div class="outline-text-6" id="text-orgbe84af9">
<p>
菜单 Window / HLSL Code 可以显示材质编辑器对应的 HLSL 代码。<br />
</p>
</div>
</div>
<div id="outline-container-org3316565" class="outline-6">
<h6 id="org3316565">Material Inputs</h6>
<div class="outline-text-6" id="text-org3316565">
</div>
<ul class="org-ul">
<li><a id="orgf081547"></a>Inputs and Material Settings<br />
<div class="outline-text-7" id="text-orgf081547">
<p>
对于每种类型的材质，并非所有的输入都是有用的。例如，在开发一个光照函数时（应用于光的材质）你只能在该材质上使用 Emissive Color 输入，因为其他的输入（例如，金属度，粗燥度）是不可应用的。<br />
下面是三类可控制的主要属性：<br />
</p>
<ul class="org-ul">
<li>BlendMode 主要控制如何和后面的像素混合<br /></li>
<li>Shading Model 主要定义如何计算应用该材质的表面的光照<br /></li>
<li>Material Domain 主要控制材质的应用领域。例如，材质是否是表面的一部分，或者是一个光照函数，或者是一个后期处理材质。<br /></li>
</ul>
</div>
</li>
<li><a id="org045cdf3"></a>Base Color<br />
<div class="outline-text-7" id="text-org045cdf3">
<p>
Base Color 定义材质的整体颜色。<br />
</p>
</div>
</li>
<li><a id="org0518433"></a>Metallic<br />
<div class="outline-text-7" id="text-org0518433">
<p>
Metallic 定义表面像金属的程度。其取值范围为[0,1]，0 表示非金属，1 表示金属。当创建混合表面时，需要用到 0-1 之间的值，例如：腐蚀的金属、生锈的金属、有污垢的金属等。<br />
</p>
</div>
</li>
<li><a id="org2e3b0b5"></a>Specular<br />
<div class="outline-text-7" id="text-org2e3b0b5">
<p>
大多数情况下，Specular 保持 0.5 默认值即可。<br />
Specular 取值范围为[0,1]，用于缩放非金属表面的高光总量。该输入参数对于金属表面无作用。<br />
</p>
</div>
</li>
<li><a id="orga714452"></a>Roughness<br />
<div class="outline-text-7" id="text-orga714452">
<p>
Roughness 控制材质的粗燥度。粗燥的材质比光滑的材质分散反射光到跟多的方向。该参数影响反射是否模糊或者尖锐，高光点是否宽泛或集中。<br />
0 表示镜面反射，1 表示完全的漫反射<br />
</p>
</div>
</li>
<li><a id="orgb92c691"></a>Emissive Color<br />
<div class="outline-text-7" id="text-orgb92c691">
<p>
Emissive Color 控制材质的哪些部分因为发射线而光亮。理论上该输入参数应该接收到一个遮罩贴图，除了发热的区域，其大部分为黑色。<br />
</p>
</div>
</li>
<li><a id="org0e60593"></a>Opacity 不透明度<br />
<div class="outline-text-7" id="text-org0e60593">
<p>
当使用 Translucent Blend Mode 时，会使用 Opacity 输入参数。其取值范围为[0,1]，0 表示完全透明，1 表示完全不透明。<br />
</p>
</div>
</li>
<li><a id="org2931269"></a>Opacity Mask<br />
<div class="outline-text-7" id="text-org2931269">
<p>
当使用 Masked Blend Mode 时，才可以使用 Opacity Mask 输入参数。在遮罩模式下，材质要么全部透明，要么完全不透明，没有中间情况。这对于定义复杂的固体表面非常有用，例如锁链围墙，线网等。不透明部分依然会执行光照。<br />
</p>
</div>
</li>
<li><a id="org594063d"></a>Normal<br />
<div class="outline-text-7" id="text-org594063d">
<p>
Normal 输入参数，接受一张法线贴图，其为表面的每个像素提供了重要的物理细节。<br />
</p>
</div>
</li>
<li><a id="org542485d"></a>World Position Offset<br />
<div class="outline-text-7" id="text-org542485d">
<p>
World Position Offset 允许在世界空间中，对网格的顶点进行操作。这对于物体移动、变形、旋转等其他效果非常有用。这对于环境动画非常有用。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3fbe690"></a>Tips<br />
<div class="outline-text-8" id="text-org3fbe690">
<p>
如果使用 World Position Offset 扩展物体超出它原始的边界，此时渲染器使用依然是它原始的边界。这就意味着剔除和阴影可能会出错。你应该设置网格的 Scale Bounds 属性来补偿这种错误，这样会增加绘制性能也会导致阴影错误。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgc0fc230"></a>World Displacement &amp; Tessellation Multiplier<br />
<div class="outline-text-7" id="text-orgc0fc230">
<p>
World Displacement 和 World Position Offset 很像，只是 World Displacement 使用 Tessellation 顶点而不是网格的基础顶点。将材质的 Tessellation 属性设置为非 None，才可以使用该输入。<br />
Tessellation Multiplier 控制表面细分曲面的总量。需要时，可以加入更多的细节。将材质的 Tessellation 属性设置为非 None，才可以使用该输入。<br />
</p>
</div>
</li>
<li><a id="org7af2a50"></a>Subsurface Color<br />
<div class="outline-text-7" id="text-org7af2a50">
<p>
当 Shading Model 属性设置为 Subsurface 时，该输入参数才可用。该输入参数用来模拟光进入表面后，颜色的变化。例如，人类角色的皮肤有红色的子表面颜色，来模拟皮肤下的血液。<br />
</p>
</div>
</li>
<li><a id="org146c06f"></a>Ambient Occlusion<br />
<div class="outline-text-7" id="text-org146c06f">
<p>
环境遮蔽用于模拟发生在表面缝隙处的自阴影。通常该输入参数和一张 AO 贴图映射相连。<br />
</p>
</div>
</li>
<li><a id="org544c0ee"></a>Refraction 折射<br />
<div class="outline-text-7" id="text-org544c0ee">
<p>
Refraction 输入接收一张贴图或者一个值，来模拟表面的折射率。这对于玻璃、水等物质很有用，它们折射进入其中的光。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">物质类型</th>
<th scope="col" class="org-right">折射率</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">空气</td>
<td class="org-right">1.0</td>
</tr>

<tr>
<td class="org-left">水</td>
<td class="org-right">1.33</td>
</tr>

<tr>
<td class="org-left">冰</td>
<td class="org-right">1.31</td>
</tr>

<tr>
<td class="org-left">玻璃</td>
<td class="org-right">1.52</td>
</tr>

<tr>
<td class="org-left">钻石</td>
<td class="org-right">2.42</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgc3a872e"></a>Clear Coat (透明图层)<br />
<div class="outline-text-7" id="text-orgc3a872e">
<p>
Clear Coat 着色模型用于更好地模拟多层材质，这种材质表面有有一层很薄的透明层。此外，Clear Coat 着色模型既可以用于金属表面，也可用于非金属表面。事实上，这种着色模型专门用于模拟覆盖在无色金属上的二级平滑颜色的薄膜。<br />
Clear Coat 材质的例子包括丙烯酸或漆的透明图层，以及金属上的颜色薄膜如易拉罐或车漆。<br />
Clear Coat 着色模型在主材质节点上开启了两个新的输入参数。<br />
</p>
<ul class="org-ul">
<li>Clear Coat<br />
透明图层的总量，0 表示标准的着色模型，1 表示完全的 Clear Coat 模型。<br /></li>
<li>Clear Coat Roughness<br />
clear coat 层的粗糙度。当该值比较小时，准确度比较高。该值比较大时，准确度就比较低了。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9ce9443" class="outline-6">
<h6 id="org9ce9443">Material Properties</h6>
<div class="outline-text-6" id="text-org9ce9443">
</div>
<ul class="org-ul">
<li><a id="org253f539"></a>Physical Material<br />
<div class="outline-text-7" id="text-org253f539">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Plys Material</td>
<td class="org-left">材质关联的物理材质。物理材质提供了一系列物理属性的定义，例如，碰撞时有多少能量保留等其他物理方面的属性。物理材质对于材质的可视性展示没有影响</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orga86431d"></a>Material<br />
<ul class="org-ul">
<li><a id="org8c31556"></a>Material Domain<br />
<div class="outline-text-8" id="text-org8c31556">
<p>
该属性指定材质将被如何使用。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Surface</td>
<td class="org-left">该设置定义材质将被用于物体表面。金属、塑料、皮肤、或其他物理表面。</td>
</tr>

<tr>
<td class="org-left">Deferred Decal</td>
<td class="org-left">当制作贴花材质时，需要使用该设置</td>
</tr>

<tr>
<td class="org-left">Light Function</td>
<td class="org-left">当创建一个和光照函数配合使用的材质时，使用该设置</td>
</tr>

<tr>
<td class="org-left">Post Process</td>
<td class="org-left">制作后期效果材质时，使用该设置</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org56511ec"></a>Blend Mode<br />
<div class="outline-text-8" id="text-org56511ec">
<p>
混合模式指定当前材质的输出(Source color)和已经绘制好的背景内容(Destination Color)如何混合。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BLEND_Opaque</td>
<td class="org-left">FinalColor=SourceColor</td>
</tr>

<tr>
<td class="org-left">BLEND_Masked</td>
<td class="org-left">当 OpacityMask&gt;OpacityMaskClipValue 时，FinalColor=SourceColor,否则像素将被丢弃.该混合模式和光照兼容</td>
</tr>

<tr>
<td class="org-left">BLEND_Translucent</td>
<td class="org-left">FinalColor=SourceColorOpaity+DestColor*(1-Opacity).该混合模式和动态光照不兼容。</td>
</tr>

<tr>
<td class="org-left">BLEND_Additive</td>
<td class="org-left">FinalColor=SourceColor+DestColor.该混合模式和动态光照不兼容。</td>
</tr>

<tr>
<td class="org-left">BLEND_Modulate</td>
<td class="org-left">FinalColor=SourceColor*DestColor.该混合模式和动态光照或雾不兼容，除非该材质为贴花材质。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgfc0d38a"></a>Decal Blend Mode<br />
<div class="outline-text-8" id="text-orgfc0d38a">
<p>
定义了贴花材质阶段，GBuffer 通道如何被修改。只有 MaterialDomain==MD_DeferredDecal 时可用。<br />
</p>
</div>
</li>
<li><a id="org591b775"></a>Decal Response<br />
<div class="outline-text-8" id="text-org591b775">
<p>
定义材质对 DBuffer 贴花如何作出反应（影响表现、性能以及贴图采样的使用）。在基本对象（例如静态网格）上可以禁用非 DBuffer 贴花。<br />
</p>
</div>
</li>
<li><a id="org5d2dfca"></a>Shading Model<br />
<div class="outline-text-8" id="text-org5d2dfca">
<p>
着色模型决定了材质输入如何被组合起来产生最终的颜色。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Unlit</td>
<td class="org-left">材质通过 Emissive 和 Opacity 输入来定义。它对光照没有反应。</td>
</tr>

<tr>
<td class="org-left">Default Lit</td>
<td class="org-left">默认的光照模型。对于大多数固体来说非常完美</td>
</tr>

<tr>
<td class="org-left">Subsurface</td>
<td class="org-left">用于次表面散射材质，例如蜡或冰。会激活次表面颜色输入</td>
</tr>

<tr>
<td class="org-left">Preintegrated Skin</td>
<td class="org-left">用于类人皮肤材质。会激活次表面颜色输入</td>
</tr>

<tr>
<td class="org-left">Clear Coat</td>
<td class="org-left">用于在表层有一层透明层的材质。例如车漆。会激活 ClearCoat 和 ClearCoatRoughness 输入</td>
</tr>

<tr>
<td class="org-left">Subsurface Profile</td>
<td class="org-left">用于类人皮肤材质。需要使用 Subsurface Profile</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org2609a56"></a>Opacity Mask Clip Value<br />
<div class="outline-text-8" id="text-org2609a56">
<p>
OpacityMask 输入会引用该值来裁剪每个像素。<br />
</p>
</div>
</li>
<li><a id="org9d719a2"></a>Two Sided<br />
<div class="outline-text-8" id="text-org9d719a2">
<p>
在背面，法线将会反转，这意味着光照将会在正面和背面都进行计算。该选项通常用于树叶，用来防止多边形数目翻倍。双面在静态光照下不能正确工作，因为网格对于光照贴图映射依然只使用一套 UV。结果，双面材质对于静态光照时，在两面的渲染是相同的。<br />
</p>
</div>
</li>
<li><a id="org3a35e8b"></a>Tangent Space Normal<br />
<div class="outline-text-8" id="text-org3a35e8b">
<p>
切线空间法线是从物体表面计算得来的。世界空间法线使用世界坐标系统来计算像素角度。<br />
从可视效果上来看，切空间法线主要是蓝色，世界空间法线更多是彩虹色。<br />
</p>
</div>
</li>
<li><a id="orgf40ad2d"></a>Decal Blend Mode<br />
<div class="outline-text-8" id="text-orgf40ad2d">
<p>
当 Material Domain 属性设置为 Deferred Decal 时，通过该选项来设置混合模式。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Transluent 半透明</td>
<td class="org-left">贴花会混合 BaseColor，Metallic，Specular，Roughness，Emissive Color，Normal.使用该选项可以混合完全分开的材质</td>
</tr>

<tr>
<td class="org-left">Stain 斑点</td>
<td class="org-left">只混合 BaseColor 和 Opacity。对于只改变颜色的贴花很有用，例如墙上干燥了的喷绘。</td>
</tr>

<tr>
<td class="org-left">Normal</td>
<td class="org-left">只混合 Normal 和 Opacity。对于在表面添加裂缝很有用</td>
</tr>

<tr>
<td class="org-left">Emissive</td>
<td class="org-left">只混合 Emissive 和 Opacity。对于使原来不发光的物体发光很有用。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org481c686"></a>Use Material Attributes<br />
<div class="outline-text-8" id="text-org481c686">
<p>
勾选该选择框，将会使材质的主节点浓缩为只用一个名称为“Material Sttributes”输入的节点。当需要利用分层材质来混合多个材质 或 使用材质属性表达式节点来定义多个材质类型时，会非常有用。<br />
</p>
</div>
</li>
<li><a id="org5614284"></a>Subsurface Profile 次表面轮廓<br /></li>
<li><a id="org233b500"></a>Num Customized UVs<br />
<div class="outline-text-8" id="text-org233b500">
<p>
设置 Customized UV 输入的数目。不连接 Customized UV 输入时，将会传递顶点的 UV。<br />
</p>
</div>
</li>
<li><a id="orga34a0d6"></a>Generate Spherical Particle Normal's<br />
<div class="outline-text-8" id="text-orga34a0d6">
<p>
生成球形粒子法线<br />
</p>
</div>
</li>
<li><a id="org3d2d6a5"></a>Emissive (Dynamic Area Light)<br />
<div class="outline-text-8" id="text-org3d2d6a5">
<p>
如果勾选，材质的 Emissive color 会被注入光线传播体积<br />
</p>
</div>
</li>
<li><a id="org9325d45"></a>Wire Frame<br />
<div class="outline-text-8" id="text-org9325d45">
<p>
开启网格的线框显示。<br />
</p>
</div>
</li>
<li><a id="org7e7fa3c"></a>Refraction Bias<br />
<div class="outline-text-8" id="text-org7e7fa3c">
<p>
该属性会偏移折射测试的深度。当折射值导致不希望的附近的物体渲染到材质表面上时，可以使用该选项进行调节。<br />
只有当一些表达式节点连接到 Refraction input 时，该选项才可使用。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org7a6af59"></a>Translucency<br />
<ul class="org-ul">
<li><a id="org7fd0b85"></a>Separate Translucency<br />
<div class="outline-text-8" id="text-org7fd0b85">
<p>
该选项指示材质将在 Separate Translucency Pass 被渲染。这意味着将不受 DOF 影响，并且需要在.INI 文件中设置 bAllowSeparateTranslucency.<br />
</p>
</div>
</li>
<li><a id="orge70e3d9"></a>Responsive AA(Ant aliasing)<br />
<div class="outline-text-8" id="text-orge70e3d9">
<p>
小的移动的物体，特别是粒子特效，有时候会被反锯齿移除。设置该属性为 true，会使用另一个不同的反锯齿算法。<br />
</p>
</div>
</li>
<li><a id="orga19a281"></a>Translucency Lighting Mode<br />
<div class="outline-text-8" id="text-orga19a281">
<p>
该材质中 Translucency 所使用的光照模式。对于利用半透明的粒子系统非常有用。例如，自阴影烟或蒸汽。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Volumetric NonDirectional</td>
<td class="org-left">光照按照体积计算，没有方向性。对于烟灰尘等粒子效果可使用该选项。这是非常节省的光照方法，但是没有考虑材质的法线。</td>
</tr>

<tr>
<td class="org-left">Volumetric Directional</td>
<td class="org-left">光照按照体积计算，有方向性，所以会考虑材质的法线。</td>
</tr>

<tr>
<td class="org-left">Volumetric PerVertex NonDirectional</td>
<td class="org-left">只会在顶点上计算光照，所以片段着色器的消耗很小。</td>
</tr>

<tr>
<td class="org-left">Volumetric PerVertex Directional</td>
<td class="org-left">同上</td>
</tr>

<tr>
<td class="org-left">Surface Translucency Volume</td>
<td class="org-left">光照按照表面计算。光照在体积中会累积，所以结果会模糊，片段着色器消耗很小。玻璃、水等半透明表面使用该选项。只支持漫反射光照。</td>
</tr>

<tr>
<td class="org-left">Surface Forward Shading</td>
<td class="org-left">光照按照表面计算。玻璃、水等半透明表面使用该选项。因为使用了正向渲染来实现，所以支持本地光照的镜面高光，但是不支持其他延迟特性。最昂贵的半透明光照方法</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgc3844cf"></a>Translucency Directional Lighting Intensity<br />
<div class="outline-text-8" id="text-orgc3844cf">
<p>
对于半透明物体,人为增加法线在光照结果上的影响。当该选项的值比 1 越大时，对法线的影响越大，值比 1 越小时，光照越趋近于环境光。<br />
</p>
</div>
</li>
<li><a id="orgb4fbce8"></a>Disable Depth Test<br />
<div class="outline-text-8" id="text-orgb4fbce8">
<p>
允许材质关闭深度测试，这对于半透明混合模式很有意义。关闭深度测试会明显减慢渲染，因为 Z 剔除没有剔除任何像素。<br />
</p>
</div>
</li>
<li><a id="org99104b9"></a>Use Translucency Vertex Fog<br />
<div class="outline-text-8" id="text-org99104b9">
<p>
该选项为 True 时，半透明材质会被雾化。默认值为 true。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org8e1aee4"></a>Translucency Self Shadowing<br />
<div class="outline-text-7" id="text-org8e1aee4">
<p>
半透明自阴影是获得体积照亮的半透明物体的很好方法，例如柱形的烟或蒸汽。自阴影分为两个主要部分：自阴影密度和第二自阴影密度。两部分的存在就可以允许各种变化。你可以分别定义每个密度，从而在整个自阴影中获得有趣的模式。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Translucent Shadow Density Scale</td>
<td class="org-left">设置有该半透明材质投影到其他表面的阴影的密度。这和阴影的主缩放行为很像；如果为 0，则没有阴影。如果为 1 或更大，则产生的阴影和自阴影会更暗</td>
</tr>

<tr>
<td class="org-left">Translucent Self Shadow Density Scale</td>
<td class="org-left">设置投影到自身的阴影的密度。</td>
</tr>

<tr>
<td class="org-left">Translucent Self Shadow 2nd Density Scale</td>
<td class="org-left">设置 2nd 自阴影密度。介于自阴影密度和 2nd 自阴影密度之间的内部梯度值会被创建。</td>
</tr>

<tr>
<td class="org-left">Translucent Self Shadow 2nd Opacity</td>
<td class="org-left">设置 2nd 自阴影不透明值。用来调整自阴影和 2nd 自阴影之间的梯度效果。</td>
</tr>

<tr>
<td class="org-left">Translucent Backsattering Exponent</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Translucent Multiple Scattering Extinction</td>
<td class="org-left">对有半透明体积阴影的物体提供的消光值（该值基本上等于阴影颜色）。</td>
</tr>

<tr>
<td class="org-left">Translucent Shadow Start Offset</td>
<td class="org-left">这是在半透明体中产生的自阴影的世界空间的偏移值。值越大阴影离光源越远。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgc8369d7"></a>Usage<br />
<div class="outline-text-7" id="text-orgc8369d7">
<p>
Usage 标记用于控制材质将被应用于的物体的类型。当编译材质时，这些设置允许引擎为每个应用编译特定的版本。只有在使用 Surface Material Domain 设置时，这些设置才可用。<br />
</p>
</div>
</li>
<li><a id="orgae4df69"></a>Mobile<br />
<div class="outline-text-7" id="text-orgae4df69">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Fully Rough 完全粗糙</td>
<td class="org-left">强制材质为完全粗糙，这样可以节省大量着色指令以及一个贴图采样</td>
</tr>

<tr>
<td class="org-left">Use Lightmap Directionality</td>
<td class="org-left">这将使用光照贴图方向性以及每个像素的法线。如果禁用该选项，从光照贴图的光照将没有方向性，但是更节省</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgf2a4dca"></a>Tessellation<br />
<div class="outline-text-7" id="text-orgf2a4dca">
<p>
细分曲面特性允许在运行时为网格添加更多的物理细节。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org267b5c3"></a>Tessellation Mode<br />
<div class="outline-text-8" id="text-org267b5c3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性值</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">No Tessellation</td>
<td class="org-left">网格不会细分曲面。有效禁用该特性</td>
</tr>

<tr>
<td class="org-left">Flat Tessellation</td>
<td class="org-left">细分曲面的简单形式。添加更多三角形使网格不平滑</td>
</tr>

<tr>
<td class="org-left">PN Triangles</td>
<td class="org-left">利用简单的基于样条的细分曲面，这种方式比较昂贵，但是有更好的细节</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2d306c4"></a>Enable Crack Free Displacement<br />
<div class="outline-text-8" id="text-org2d306c4">
<p>
开启移位算法来修复可能出现在网格上的裂缝。该选项比较昂贵，所以如果在移位时看不到任何裂缝，应该将该选项设置为 False<br />
</p>
</div>
</li>
<li><a id="org1c18bf8"></a>Enable Adaptive Tessellation<br />
<div class="outline-text-8" id="text-org1c18bf8">
<p>
该细分曲面方法试图为每个三角维持相同数目的像素。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgbc68459"></a>Post Process Material<br />
<div class="outline-text-7" id="text-orgbc68459">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Blendable Location</td>
<td class="org-left">如果材质被用作后期处理，该属性允许你控制该材质的计算时在色调调节之前还是之后。</td>
</tr>

<tr>
<td class="org-left">Blendable Priority</td>
<td class="org-left">这是优先值。用于指定后期处理材质的优先级。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgf48c3a2"></a>Lightmass 光照系统<br />
<div class="outline-text-7" id="text-orgf48c3a2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Cast Shadow as Masked</td>
<td class="org-left">如果为 True，照亮半透明物体时将会产生阴影，就像使用遮罩光照模型。这对于在半透明物体上产生清晰的阴影。</td>
</tr>

<tr>
<td class="org-left">Diffuse Boost</td>
<td class="org-left">材质的漫反射组件在静态光上的影响总量的乘数</td>
</tr>

<tr>
<td class="org-left">Export Resolution Scale</td>
<td class="org-left">材质属性被导出时，分辨率的乘数。需要增加细节时，应该增大该值</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2f55579"></a>Material Interface<br />
<div class="outline-text-7" id="text-org2f55579">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Preview Mesh</td>
<td class="org-left">设置用于预览材质的静态网格</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orged91cec"></a>Thumbnail 缩略图<br />
<div class="outline-text-7" id="text-orged91cec">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Primitive Type</td>
<td class="org-left">设置缩略图预览中使用的形状图元类型</td>
</tr>

<tr>
<td class="org-left">Preview Mesh</td>
<td class="org-left">设置缩略图预览中使用的网格。当 Primitive Type 为 TPT None 时才可用</td>
</tr>

<tr>
<td class="org-left">Orbit Pitch</td>
<td class="org-left">设置围绕物体的轨道摄像机的俯仰</td>
</tr>

<tr>
<td class="org-left">Orbit Yaw</td>
<td class="org-left">设置围绕物体的轨道摄像机的偏航</td>
</tr>

<tr>
<td class="org-left">Orbit Zoom</td>
<td class="org-left">从资源到边界球体距离的偏移值</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7b93235" class="outline-6">
<h6 id="org7b93235">Instanced Materials</h6>
<div class="outline-text-6" id="text-org7b93235">
<p>
在虚幻 4 中，材质实例化用于改变材质的表现而不遭受昂贵的材质重新编译。典型的材质不编译的话是不能够被编辑或修改的。然而，一个实例化的材质可以在不被编译的情况下被修改。特定类型的实例化材质甚至可以在游戏中被修改，从而可以响应游戏中的事件。这使得美术元素的视觉效果非常灵活。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5eaff79"></a>Instances and Parameters<br />
<div class="outline-text-7" id="text-org5eaff79">
<p>
默认情况下并不是所有的材质特性都可以被编辑。指定需要被编辑的材质属性为参数，才可以使材质实例可以被编辑。<br />
</p>
</div>
</li>
<li><a id="orgf06b3cd"></a>Constant and Dynamic Instances<br />
<div class="outline-text-7" id="text-orgf06b3cd">
<p>
在虚幻 4 中有两类材质实例：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org22a078f"></a>Material Instance Constant<br />
<div class="outline-text-8" id="text-org22a078f">
<p>
只可以在运行前计算一次。<br />
可以在 Content Browser 中创建 Material Instance Constants，通过 Material Instance Editor 对其进行编辑。<br />
</p>
</div>
</li>
<li><a id="org9d25fea"></a>Material Instance Dynamic<br />
<div class="outline-text-8" id="text-org9d25fea">
<p>
可以在运行时计算和编辑。<br />
无论是通过参数化材质还是常量材质实例，都需要在脚本中创建动态材质实例。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org1b74581"></a>Technical Application<br />
<div class="outline-text-7" id="text-org1b74581">
<p>
为了允许在基础图元上应用非实例材质，使用了 MaterialInterface 抽象基类。该类是材质的表达式和参数值的接口。Material 类是 MaterialInterface 的子类，它定义了表达式和参数的默认值。<br />
顺便一提，如果你想一个蓝图的变量可以接受 Material 或 Material Instance Constant，你需要保证该变量的类型为 MaterialInterface<br />
</p>
</div>
</li>
<li><a id="org5b7d839"></a>Instancing a Material in the Editor<br /></li>
<li><a id="org3a8c2dc"></a>Parameter Groups<br />
<div class="outline-text-7" id="text-org3a8c2dc">
<p>
参数表达式有一个 Group 属性，这样在材质实例编辑器中查看时，这些参数表达式可以被有效地组织。<br />
</p>
</div>
</li>
<li><a id="org224577d"></a>Creating Parameterized Materials<br />
<div class="outline-text-7" id="text-org224577d">
<p>
在材质编辑器中，使用任何一类参数表达式，就可以为材质添加参数。给参数一个唯一的名称，赋于一个组别，并给定一个默认值。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6ea462b"></a>Scalar Parameters<br />
<div class="outline-text-8" id="text-org6ea462b">
<p>
标量参数只包含单个浮点值。<br />
</p>
</div>
</li>
<li><a id="org5605d6e"></a>Vector Parameters<br />
<div class="outline-text-8" id="text-org5605d6e">
<p>
矢量参数包含 4 通道的矢量值，或 4 个浮点值。<br />
</p>
</div>
</li>
<li><a id="org3dfd872"></a>Texture Parameters<br />
<div class="outline-text-8" id="text-org3dfd872">
<p>
有多种可用的贴图参数。每种都特别对应一种它所接受的贴图类型或它被使用的方式。依据不同贴图类型会生成不同的着色器代码,所以每种特定的贴图类型需要一个不同的表达式。<br />
</p>
<ul class="org-ul">
<li>TextureSampleParameter2D 接受基础的 Texture2D<br /></li>
<li>TextureSampleParameterCube 接受一个 TextureCube 或 cubemap<br /></li>
<li>TextureSampleParameterFlipbook<br /></li>
<li>TextureSampleParameterMeshSubUV<br /></li>
<li>TextureSampleParameterMeshSubUV<br /></li>
<li>TextureSampleParameterMovie<br /></li>
<li>TextureSampleParameterSubUV<br /></li>
</ul>
</div>
</li>
<li><a id="org8687400"></a>Static Parameters<br />
<div class="outline-text-8" id="text-org8687400">
<p>
静态参数在编译时被应用，所以它能生成更优化的代码。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgc38fe47" class="outline-6">
<h6 id="orgc38fe47">Material Shading Models</h6>
<div class="outline-text-6" id="text-orgc38fe47">
</div>
<ul class="org-ul">
<li><a id="orgbdc8ac2"></a>Subsurface Shading Model<br />
<div class="outline-text-7" id="text-orgbdc8ac2">
<p>
MLM_Subsurface 次表面着色模型用于蜡或玉石等表现为不透明物体，但是光照在其内部可以散射，允许光在表面的另一次显示。<br />
次表面散射通常用于创建真实的人类皮肤。这种效果质量比较低，但是比通常的皮肤着色要更节省性能。<br />
</p>
</div>
</li>
<li><a id="org22fd238"></a>Subsurface Profile Shading Model<br />
<div class="outline-text-7" id="text-org22fd238">
<p>
次表面轮廓着色是 UE4 提供的专门用于渲染真实皮肤或蜡表面的着色方法。它和次表面着色方法类似。但是，在渲染上有一个基本的不同，次表面轮廓是基于屏幕空间的。这是因为在屏幕空间可以更有效显示在人类皮肤上看到的精细的子表面效果，在很少的情况下(例如，在耳朵处)，才能看到次级的反向散射效果。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org70fa1c1"></a>技术细节<br />
<div class="outline-text-8" id="text-org70fa1c1">
<p>
次表面轮廓着色模型和 Lit 模型相差不多。大多数效果是在光照计算之后的后处理阶段进行的。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgc95a7f8" class="outline-6">
<h6 id="orgc95a7f8">Layered Materials</h6>
<div class="outline-text-6" id="text-orgc95a7f8">
<p>
分层材质可以被认为是材质中包含材质。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org51c4175"></a>Blend Types<br />
<div class="outline-text-7" id="text-org51c4175">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Material Layer Blend Functions</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">MatLayerBlend_AO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_BaseColorOverride</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_BreakBaseColor</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_BreakNormal</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Decal</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Decal_UV3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Emissive</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_GlobalNormal</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_LightmassReplace</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_ModulateRoughness</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_NormalBlend</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_NormalFlatten</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_RoughnessOverride</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Simple</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Stain</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Standard</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_Tint</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_TintAllChannels</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MatLayerBlend_TopNormal</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org19b264d"></a>Instancing Layered Materials<br /></li>
<li><a id="orgbf958aa"></a>警告<br />
<div class="outline-text-7" id="text-orgbf958aa">
<p>
多层材质可以将多个材质压缩为一个材质，虽然可以减少 drawcall 次数，但是会增加系统消耗，以致于在移动平台上无法使用。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org42eb2b7" class="outline-6">
<h6 id="org42eb2b7">Material Expression Reference</h6>
<div class="outline-text-6" id="text-org42eb2b7">
<p>
每个材质表达式都是一个自包含的黑匣子。它输出一组一个或多个特定的值，或者在一个或多个输入上执行一个操作然后将操作结果输出。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0b00ded"></a>Parameters<br />
<div class="outline-text-7" id="text-org0b00ded">
<p>
有些材质表达式是参数，这意味着它们的值可以被修改(有时候，可以在动态运行时修改)。<br />
</p>
</div>
</li>
<li><a id="orgdb1e28c"></a>Expression Types<br />
<ul class="org-ul">
<li><a id="orge0747f0"></a>Atmosphere<br />
<ul class="org-ul">
<li><a id="orgad0d4d6"></a>Atmospheric Fog Color<br />
<div class="outline-text-9" id="text-orgad0d4d6">
<p>
该表达式允许你查询世界空间任意位置的大气雾颜色。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org31e04f5"></a>Color<br />
<ul class="org-ul">
<li><a id="org8108167"></a>Desaturation<br />
<div class="outline-text-9" id="text-org8108167">
<p>
对输入值进行减饱和。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orga19a102"></a>Constants<br />
<ul class="org-ul">
<li><a id="org6481d99"></a>Constant<br />
<div class="outline-text-9" id="text-org6481d99">
<p>
该表达式输出一个浮点值。<br />
</p>
</div>
</li>
<li><a id="orge3cb195"></a>Constant2Vector Constant3Vector Constant4Vector<br />
<div class="outline-text-9" id="text-orge3cb195">
<p>
该表达式输出 2/3/4 个浮点值。<br />
</p>
</div>
</li>
<li><a id="orgf1e7213"></a>Distance Cull Fade<br />
<div class="outline-text-9" id="text-orgf1e7213">
<p>
该表达式输出一个标量值，其从黑色渐变为白色，可以用于逐渐显示对象当它进入剔除距离内时。需要注意的是，其不支持逐渐隐藏对象。<br />
</p>
</div>
</li>
<li><a id="org26cc9ee"></a><span class="todo TODO">TODO</span> ParticleColor<br /></li>
<li><a id="orge57a191"></a>Vertex Color<br />
<div class="outline-text-9" id="text-orge57a191">
<p>
就是顶点的颜色。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgdded9c9"></a>Coordinates<br /></li>
<li><a id="org00d768d"></a>Custom<br /></li>
<li><a id="orgc45b2b8"></a>Depth<br /></li>
<li><a id="orgae89e09"></a>Font<br /></li>
<li><a id="org1a15a63"></a>Functions<br /></li>
<li><a id="orga56ee2a"></a>Material Attributes<br /></li>
<li><a id="orgf2db32f"></a>Math<br /></li>
<li><a id="orgbcbc694"></a>Parameters<br /></li>
<li><a id="orge719812"></a>Particles<br /></li>
<li><a id="org09a8b9a"></a>Landscapes<br /></li>
<li><a id="org41f1029"></a>Texture<br /></li>
<li><a id="orgcbb1f65"></a>Utility<br />
<ul class="org-ul">
<li><a id="orgd9c2a48"></a>SphereMask<br />
<div class="outline-text-9" id="text-orgd9c2a48">
<p>
实现源代码：<br />
Engine\Source\Runtime\Engine\Classes\Materials\MaterialExpressionSphereMask.h<br />
Engine\Source\Runtime\Engine\Private\Materials\MaterialExpressions.cpp<br />
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgaaee6f3"></a>VectorOps<br /></li>
<li><a id="org94d150e"></a>Vector<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org4127fe2" class="outline-6">
<h6 id="org4127fe2">Material Functions</h6>
<div class="outline-text-6" id="text-org4127fe2">
<p>
材质函数是材质图的一些小片段，它可以被存储到包内，并且可以被多个材质重复利用。材质函数将复杂的网络抽象为单个节点，从而让美术人员的材质创建工作更简单。<br />
最重要的是，对一个函数的修改对所有使用它的网络生效，所以，对一个函数做修复或改动，就不需要再对多个材质进行编辑了。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org12f3225"></a>Material Functions Overview<br />
<div class="outline-text-7" id="text-org12f3225">
<p>
材质函数就如程序设计语言中的函数一样，其是对多个表达式的抽象。<br />
勾选材质函数的属性 Expose To Library，就可以在 Material Function Library 中看到该材质函数。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3e1bf6d"></a>和材质函数相关的节点<br />
<ul class="org-ul">
<li><a id="orgb171c6a"></a>MaterialFunctionCall<br />
<div class="outline-text-9" id="text-orgb171c6a">
<p>
材质函数调用节点。<br />
通过该节点允许在一个材质或函数中使用另一个已经存在的函数。<br />
</p>
</div>
</li>
<li><a id="orge148515"></a>FunctionInput FunctionOutput<br /></li>
<li><a id="orgfc427b0"></a>TextureObject<br />
<div class="outline-text-9" id="text-orgfc427b0">
<p>
在材质函数中，为贴图函数的输入提供一个默认贴图。需要和 TextureSample 配合使用。<br />
</p>
</div>
</li>
<li><a id="org16e6944"></a>TextureObjectParameter<br />
<div class="outline-text-9" id="text-org16e6944">
<p>
定义贴图参数或输出贴图对象。在材质中，使用贴图输入调用一个函数时使用。<br />
</p>
</div>
</li>
<li><a id="org04f3acf"></a>StaticSwitch<br />
<div class="outline-text-9" id="text-org04f3acf">
<p>
基于输入值，在编译时从两个输入中选择一个。<br />
</p>
</div>
</li>
<li><a id="org0891f35"></a>StaticBool<br />
<div class="outline-text-9" id="text-org0891f35">
<p>
需要和 StaticSwitch 配合使用。<br />
</p>
</div>
</li>
<li><a id="org21f2a5a"></a>StaticBoolParameter<br />
<div class="outline-text-9" id="text-org21f2a5a">
<p>
需要和 StaticSwitch 配合使用。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org5c28b25"></a>Previewing<br />
<div class="outline-text-8" id="text-org5c28b25">
<p>
编辑材质函数时，预览窗口可以显示任何一个选中的节点。<br />
函数的输入节点有一个内置的预览值，用来预览输入值。<br />
选中函数输入节点的 UsePreviewValueAsDefault 属性时，PreviewValue 相当于函数的默认参数。<br />
</p>
</div>
</li>
<li><a id="orgdfc028f"></a>Propagation<br />
<div class="outline-text-8" id="text-orgdfc028f">
<p>
当函数的输入或输出被删除，并且这样修改的被传播后，所有链接到被删除的连接点的链接将被破坏。<br />
</p>
</div>
</li>
<li><a id="org4a0b734"></a>Default Material Functions<br />
<div class="outline-text-8" id="text-org4a0b734">
<p>
UE4 自带的材质函数在 Engine Content/Functions/目录下可以找到<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org01a1b6b"></a>Creating Material Functions<br /></li>
<li><a id="orga591c00"></a>Editing Material Functions<br /></li>
<li><a id="org36f7f21"></a>Using Material Functions<br /></li>
<li><a id="org907e372"></a>Funtions Reference<br />
<ul class="org-ul">
<li><a id="org1e7a426"></a>Blends<br /></li>
<li><a id="orgb3d8399"></a>Gradient<br /></li>
<li><a id="org4f02f1e"></a>Image Adjustment<br /></li>
<li><a id="orgadad9bf"></a>Math<br /></li>
<li><a id="orge39ca37"></a>Misc<br /></li>
<li><a id="org3fd0def"></a>Opacity<br /></li>
<li><a id="orgcd2d586"></a>Particles<br /></li>
<li><a id="org4c69813"></a>PivotPainterTool 1.0 Material Functions<br /></li>
<li><a id="org5813c79"></a>Procedurals<br /></li>
<li><a id="org187b099"></a>Reflections<br /></li>
<li><a id="orga0701d2"></a>Shading<br /></li>
<li><a id="orgb6a83c8"></a>Texturing<br /></li>
<li><a id="org6dc0b16"></a>VectorOps<br /></li>
<li><a id="org6779f2f"></a>WorldPositionOffset<br /></li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org5cd3a60" class="outline-6">
<h6 id="org5cd3a60">Material Parameter Collections</h6>
<div class="outline-text-6" id="text-org5cd3a60">
<p>
MaterialParameterCollection 是一种资源，其可用于存储任意的标量或矢量参数，这些参数可以在任意材质中被引用。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org860a10f"></a>Using Material Parameter Collections in Materials<br />
<div class="outline-text-7" id="text-org860a10f">
<p>
通过 Collection Parameter 表达式，可以在材质中引用 Materials Parameter Collections 资源<br />
</p>
</div>
</li>
<li><a id="org04ed56d"></a>Limitations and Performance Characteristics<br />
<div class="outline-text-7" id="text-org04ed56d">
<p>
在 MaterialParameterCollection 中更新值比在多个材质实例中设置多个不同参数要更加高效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3c0670b" class="outline-6">
<h6 id="org3c0670b">Customized UVs</h6>
<div class="outline-text-6" id="text-org3c0670b">
<p>
UV Coordinate 节点既可以在顶点着色器上也可以在片段着色器上执行，CustomizedUVs 的特点是只在顶点着色器上执行，要比在片段着色器上执行更高效。<br />
CustomizedUVs 目前还不支持 Sprite particles.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge59a808"></a>Non-Linear Math<br />
<div class="outline-text-7" id="text-orge59a808">
<p>
一般的规则是如果你进行的计算所使用的每个顶点的属性值是常量或者是线性变化的量，那么该计算在顶点着色器中进行和在片段着色器中进行所的到的结果是相同的。线性变化意味着操作结果是直线，没有曲线，例如乘法和加法。对一个变量进行平方、sine、cosine、length 等操作其结果将不是线性的。<br />
</p>
</div>
</li>
<li><a id="orgb1b6253"></a>Linear Math<br />
<div class="outline-text-7" id="text-orgb1b6253">
<p>
通过一个参数来缩放（乘法运算）UVs，这样的操作在顶点着色器和片段着色器中有相同的结果。<br />
</p>
</div>
</li>
<li><a id="org33bd8b9"></a>How it works<br /></li>
<li><a id="org5d7b9ff"></a>Mobile Specific<br />
<div class="outline-text-7" id="text-org5d7b9ff">
<p>
对贴图坐标执行任何操作后的任何贴图采样，都会导致该过程变慢。这被称作 dependent texture fetches。可以使用 customized UV 输入来将对 UV 坐标的操作放在顶点着色器中，从而避免片段着色器中对 UV 坐标进行操作。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org893f956"></a>关于 dependent texture fetches<br />
<div class="outline-text-8" id="text-org893f956">
<p>
<a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/BestPracticesforShaders/BestPracticesforShaders.html">https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/BestPracticesforShaders/BestPracticesforShaders.html</a><br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org0fe4906" class="outline-6">
<h6 id="org0fe4906">Refraction Mode:Pixel Normal Offset</h6>
<div class="outline-text-6" id="text-org0fe4906">
<p>
Pixel Normal Offset 是非物理折射模型。适用于大的平表面，例如：水面。<br />
Index of Refraction 是物理折射模型。它基于光线在不同介质之间传播时如何折射。当场景中的颜色从屏幕外读取时，它会引起穿帮。适用于小的物体，例如：玻璃罐。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb352830"></a>参考资料<br />
<div class="outline-text-7" id="text-orgb352830">
<p>
通用折射模拟 <a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter19.html">https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter19.html</a><br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgecee561" class="outline-6">
<h6 id="orgecee561">Physically Based Materials</h6>
<div class="outline-text-6" id="text-orgecee561">
</div>
<ul class="org-ul">
<li><a id="org6d5ee2b"></a>Base Color<br />
<div class="outline-text-7" id="text-org6d5ee2b">
<p>
Base Color 定义了材质的整体颜色。在现实世界中，可以使用偏光滤镜拍摄的照片就是 Base Color(偏振可以移除非金属的镜面高光)。<br />
</p>
</div>
</li>
<li><a id="org4c244cf"></a>Roughness<br />
<div class="outline-text-7" id="text-org4c244cf">
<p>
粗糙度控制着材质的粗糙程度。<br />
</p>
</div>
</li>
<li><a id="org3538fd5"></a>Metallic<br />
<div class="outline-text-7" id="text-org3538fd5">
<p>
通常情况下材质的金属度为 0（非金属）或 1（金属），只有在创建混合的表面时，才需要 0 到 1 之间的值。<br />
</p>
</div>
</li>
<li><a id="orge5e6d07"></a>Specular<br />
<div class="outline-text-7" id="text-orge5e6d07">
<p>
大多数情况下，应该保持镜面高光为默认值 0.5。<br />
Specular 用于缩放非金属材质表面的镜面高光总量。其对金属材质无作用。<br />
对于漫反射比较强的材质，你可能会倾向于将其 Specular 设置为 0，千万不要这样做。所有的材质都有镜面高光。对于漫反射比较强的材质，你正真需要做的是增加它们的粗糙度。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4d5743f" class="outline-4">
<h4 id="org4d5743f">Lighting Concepts and Features</h4>
<div class="outline-text-4" id="text-org4d5743f">
</div>
<div id="outline-container-orgd0df9fe" class="outline-5">
<h5 id="orgd0df9fe">Lighting the Environment</h5>
<div class="outline-text-5" id="text-orgd0df9fe">
</div>
<div id="outline-container-org619f682" class="outline-6">
<h6 id="org619f682">Essentials</h6>
<div class="outline-text-6" id="text-org619f682">
</div>
<ul class="org-ul">
<li><a id="orgfa66b3f"></a>Lighting Basics<br />
<ul class="org-ul">
<li><a id="org73bfcc6"></a>Intensity<br />
<div class="outline-text-8" id="text-org73bfcc6">
<p>
亮度定义了灯光照出的能量的多少。该值的单位是 明流 。1700 lumens 对应 100W 灯泡。<br />
</p>
</div>
</li>
<li><a id="org5fa85c2"></a>Attenuation Radius<br />
<div class="outline-text-8" id="text-org5fa85c2">
<p>
灯光的衰减半径对性能有重要影响，所以应该谨慎使用大的衰减半径值。<br />
</p>
</div>
</li>
<li><a id="orge06f6ec"></a>Source Radius and Length<br />
<div class="outline-text-8" id="text-orge06f6ec">
<p>
光源半径和光源长度值得特别提一提，因为它们定义了表面上高光点的尺寸。<br />
灯光的 Min Roughness 属性可以减弱 Source Radius 和 Source Length 的作用。<br />
Source Radius 对预计算光照有影响，Source Radius 越大形成的阴影越柔和。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgea41463"></a>Light Mobility<br />
<div class="outline-text-7" id="text-orgea41463">
<p>
对于每个灯光，在 Transform 类属性下，都有一个 Mobility 属性。该属性有三个设置，Static、Stationary、以及 Movable，每种设置都会改变灯光的工作方式以及它们在性能上的影响。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org23e914c"></a>Static Lights<br />
<div class="outline-text-8" id="text-org23e914c">
<p>
完全静止的灯光，在运行时不会有任何负担。<br />
动态的物体不能和静态灯光整合在一起，所以静态灯光的适用性是有局限的。<br />
因为静态灯光只使用光照贴图，它们的阴影是在运行游戏之前烘培的。这意味着它们不能投影动态的对象。但对于静态物体，其可以制造区域（重叠）阴影。<br />
</p>

<ul class="org-ul">
<li>注意 静态的光照可以照亮场景中动态的物体，其中间接光照是通过 VLM（Volumetric Lightmaps）和 ILC(Indirect Lighting Cache) 来实现的。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orge8c8836"></a>Lightmap Resolution<br />
<div class="outline-text-9" id="text-orge8c8836">
<p>
Lightmap Resolution 允许你控制静态灯光制造的烘培光照的细节。<br />
在 Static Mesh 组件上，光照贴图分辨率既可以在 Static Mesh 资源上设置，也可以通过选中 Override Lightmap Res，并设置其值。值越大分辨率越高，编译所花时间也越长，内存占用越多。<br />
在 Brush 表面上，光照贴图分辨率通过 Lightmap Resolution 属性来设置。这里设置的其实是密度，所以值越小分辨率越高。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgf143ee8"></a>Stationary lights<br />
<div class="outline-text-8" id="text-orgf143ee8">
<p>
在运行时，可以修改灯光颜色、亮度。但是不能移动，旋转或者修改影响的尺寸。<br />
需要注意的是运行时对亮度的修改只会影响到直接光照。因为，间接光照是通过 Lightmass 预计算的，所以其不会受影响。<br />
从 Stationary Lights 产生的所有间接光照和阴影都被存储在 Lightmap 中。直接阴影被存储在 Shadowmap 中。这些光照使用了 Distance Field Shadows,这意味着它们的阴影在光照贴图分辨率相当低的情况下依然会保持清晰。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org87fcb73"></a>Direct Lighting 直接光照<br />
<div class="outline-text-9" id="text-org87fcb73">
<p>
Stationary 的直接光通过延迟着色来动态渲染。<br />
</p>
</div>
</li>
<li><a id="orgd78b000"></a>Direct Shadowing 直接阴影<br />
<div class="outline-text-9" id="text-orgd78b000">
<p>
实时的光照阴影是主要的性能消耗。完全动态的光照阴影通常要比无阴影的动态光照消耗近 20 倍多的性能。Stationary 光照在静态物体上可以使用静态阴影。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgedcfba4"></a>Static Shadowing<br />
<ul class="org-ul">
<li><a id="orga9103de"></a>On Opaque<br />
<div class="outline-text-11" id="text-orga9103de">
<p>
在构建光照期间，Lightmass 会为 Stationary Lights 在静态对象上生成距离场阴影贴图(Distance field shadow maps)。距离场阴影贴图即使在分辨率比较低的情况下也可以提供非常精确的阴影变化，并且其运行时性能消耗很小。就像光照贴图一样，距离场阴影贴图要求所有使用静态光照的 StaticMeshes 具有唯一的非环绕的 UV 坐标。<br />
只能有 4 个或更少的重叠的 Stationary Lights 可以有静态阴影。因为这些光照必须被分配到阴影贴图的不同通道。一旦达到通道的限制，额外的 Stationary lights 将以严重的性能成本使用全场景动态阴影。<br />
View Mode 下的 StationaryLightOverlap 视图模式，可以用来可视化 Stationary Lights 的重叠情况。无法申请到通道的灯光的 icon 会变为红色的 X。<br />
</p>
</div>
</li>
<li><a id="org3b020f4"></a>On Translution<br />
<div class="outline-text-11" id="text-org3b020f4">
<p>
使用 Stationary Light，半透明体也只花便宜的消耗就可以接受阴影。Lightmass 会从静态几何体预计算阴影深度贴图，然后在运行时将其应用于半透明体。<br />
这种形式的阴影非常粗糙，其只在米的规模上计算阴影。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org83eaab5"></a>Dynamic Shadowing<br />
<div class="outline-text-10" id="text-org83eaab5">
<p>
动态阴影必须整合到来自于距离场阴影的世界静态阴影中。这是通过每个运动物体的阴影来完成的。每个运动物体都会从 Stationary 创建两个动态阴影：一个用来处理静态世界投影到该物体上的阴影，另一个用来处理该物体投影到世界的阴影。在这种设置下，Stationary Lights 的唯一阴影消耗来自于动态物体的影响。当动态物体足够多时，使用 Movable Light 会更高效。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org751b560"></a>Directional Light dynamic shadowing 定向光动态阴影<br />
<div class="outline-text-11" id="text-org751b560">
<p>
Directional Stationary Light(定向固定光照)比较特殊，它通过 Cascaded Shadow Maps 支持全场景的阴影，同时也支持静态阴影。这在有很多动态植物的场景中非常有用，你希望在角色周围有可移动的阴影，但是不想花费性能通过很多级阴影来覆盖比较大的视野。动态的阴影随着距离增大渐变为静态阴影，这样几乎无法区分阴影变化。<br />
为了设置该选项，只需要修改设置为 Stationary 的方向光的属性: Dynamic Shadow Distance StationaryLight.将该选项设置为阴影渐变发生的距离。<br />
</p>

<p>
即使在方向光上使用 Cascaded Shadow Maps 时，可移动组件依然会为每个对象创建阴影。这对于小的 Dynamic Shadow Distance 是有用的，但是对于比较大的 Dynamic Shadow Distance 会承受不必要的消耗。关闭灯光上 Use Inset Shadows For Movable Object 属性可以禁用为每个对象创建阴影，从而节省性能消耗。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgd0c1e7b"></a>Indirect Lighting 间接光照<br />
<div class="outline-text-9" id="text-orgd0c1e7b">
<p>
就像 Static Light 一样，StationaryLight 将间接光照存储在光照贴图中。在运行时，不能修改间接光照。这意味着，即使光照的 Visible 选项未勾选，它的间接光照在创建光照时依然会被放入光照贴图中。光照上的 IndirectLightingIntensity 属性用来缩放或禁用给定灯光的间接光照。<br />
</p>

<p>
有一个后期处理量 IndirectLightingIntensity 可以用来缩放所有灯光光照贴图的光照贡献。该值可以在运行时进行修改。<br />
</p>
</div>
</li>
<li><a id="org95607df"></a>Use Area Shadows for Stationary Lights<br />
<div class="outline-text-9" id="text-org95607df">
<p>
区域阴影是指离阴影投射体越远的阴影越柔和。<br />
在 4.9 或更后面的版本中，通过 Use Area Shadows for Stationary　Light 选项来控制区域阴影的开启。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgb937c2f"></a>Movable Lights<br />
<div class="outline-text-8" id="text-orgb937c2f">
<p>
完全动态的灯光，在运行时，可以修改其所有的属性。动态光照不会被烘培到光照贴图中，目前动态光照还不支持间接光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8884166"></a>Shadowing<br />
<div class="outline-text-9" id="text-org8884166">
<p>
Movable Lights 设置为触发阴影时会使用全场景动态阴影，这会有显著的性能消耗。性能消耗主要取决于被光照影响的网格数目，以及这些网格的三角形数目。所以，半径大的 movable light 要比半径小的 movable light 消耗很多倍的性能。<br />
</p>
</div>
</li>
<li><a id="orgf9702e0"></a>Shadow Map Caching<br />
<ul class="org-ul">
<li><a id="org2fc7409"></a>Performance<br />
<div class="outline-text-10" id="text-org2fc7409">
<p>
使用 r.Shadow.WholeSceneShadowCacheMb 来控制用于阴影贴图缓存的最大内存量<br />
</p>
</div>
</li>
<li><a id="orgc86f3ba"></a>Limitations<br />
<div class="outline-text-10" id="text-orgc86f3ba">
<p>
默认情况下当物体满足下面要求时，才可以缓存阴影贴图:<br />
</p>
<ul class="org-ul">
<li>物体的 Mobility 属性被设置为 Static 或 Stationary<br /></li>
<li>场景中使用的材质没有使用 World Position Offset 属性<br /></li>
<li>灯光必须是点光灯或聚光灯，它的 Mobility 属性必须为 Movable，并且开启了 Shadow Casting<br /></li>
<li>灯光必须保持在一个位置<br /></li>
<li>使用了动画 Tessellation 或 Pixel Depth Offset 的材质会引起穿帮，因为它们的阴影深度会被缓存<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org570b7c3"></a>Types of Lights<br />
<div class="outline-text-7" id="text-org570b7c3">
<p>
UE4 中有四种灯光类型：方向光灯，点光灯，聚光灯以及天空灯。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge88b38f"></a>Directional Lights<br />
<div class="outline-text-8" id="text-orge88b38f">
<p>
Directional Light 用于模拟从无限远处发射出的光照。这意味着由这种光照投射的阴影将是平行的，这种光照是模拟太阳光的理想选择。<br />
</p>
</div>
</li>
<li><a id="orgaca6355"></a>Sky Light<br />
<ul class="org-ul">
<li><a id="orgd07124e"></a>Scene Capture<br />
<div class="outline-text-9" id="text-orgd07124e">
<p>
应该用 Sky Light 来代替环境立方体贴图用于表示天空的光照，因为 Sky Lights 支持本地阴影，可以避免门内区域被天空光照点亮。<br />
</p>
</div>
</li>
<li><a id="orgaf64809"></a>Mobility<br />
<ul class="org-ul">
<li><a id="orgcf4fd21"></a>Static Sky Light<br />
<div class="outline-text-10" id="text-orgcf4fd21">
<p>
这是移动平台唯一支持的 Sky Light.<br />
只有场景中设置为 Static 或 Stationary 的物体和灯光才会被 Static SkyLight 捕捉和使用来计算光照。再者，只有材质贡献的发光才会被 Static SkyLight 捕捉，从而避免来回的循环。因此，需要确保 skybox 的材质设置为 Unlit.<br />
</p>
</div>
</li>
<li><a id="org1b3b12b"></a>Stationary Sky Light<br />
<div class="outline-text-10" id="text-org1b3b12b">
<p>
设置为 Stationary 的 Sky Light，和设置为 Static 的一样，它们都会使用 Lightmass 烘培的阴影。就像其他类型的 Stationary Light,Sky Light 的亮度或颜色可以在运行时通过 Blueprints 或 Sequencer 来进行修改。但是，间接光照是烘培到贴图中的，无法在运行时修改。<br />
</p>
</div>
</li>
<li><a id="orgc877968"></a>Movable Sky Light<br />
<div class="outline-text-10" id="text-orgc877968">
<p>
Movable Sky Light 没有使用任何形式的预计算。它会抓取任何类型的物体和光照（无论是静态、静止还是动态）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org15c2456"></a>Distance Field Ambient Occlusion<br />
<div class="outline-text-11" id="text-org15c2456">
<p>
Movable Sky Light 的阴影是通过 Distance Field Ambient Occlusion 来提供的。Distance Field Ambient Occlustion 来自于 Signed Distance Field Volumes。Signed Distance Field Volumes 会在每个刚体周围生成。<br />
距离场环境遮蔽（Distance Field Ambient Occlustion）支持动态场景的改变，在动态场景中，刚体网格可以被移动或隐藏。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org528902f"></a>Precomputed Sky Light<br />
<ul class="org-ul">
<li><a id="org75d2edc"></a>Improved Static Sky Light Directionality<br />
<div class="outline-text-10" id="text-org75d2edc">
<p>
4.18 之前，Lightmass 使用一个三阶球谐函数来表示静态天空光，其不会捕捉细节，可以用于表示日出或日落。现在，使用一个过滤的立方体贴图来表示，默认情况下会导致更高的分辨率。<br />
在一个高度封闭的场景中，可以看出使用 Sky Light 立方体贴图，会有更多的明亮度和颜色变化。<br />
</p>
</div>
</li>
<li><a id="org7e8b919"></a><span class="todo TODO">TODO</span> Camera Obsura<br /></li>
<li><a id="orgf130d0b"></a><span class="todo TODO">TODO</span> Bent Normal for Stationary Sky Lights<br /></li>
</ul>
</li>

<li><a id="orgbec093e"></a>Shadowing from Movable Objects<br />
<div class="outline-text-9" id="text-orgbec093e">
<p>
移动物体投射到环境上的柔和阴影可以通过骨骼网格的 Capsule Shadows 或者通过 刚体网格的距离场间接阴影来得到。这需要独立的配置来使其正常工作。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgaf8bc4d"></a>Shadow Casting<br />
<ul class="org-ul">
<li><a id="org1421293"></a>Static Lights<br />
<div class="outline-text-8" id="text-org1421293">
<p>
Static Light 投射完全静止的阴影和光照，这意味着它们对于动态的物体没有任何影响。<br />
</p>
</div>
</li>
<li><a id="org35a970d"></a>Directional Light Cascading Shadow Maps<br />
<div class="outline-text-8" id="text-org35a970d">
<p>
Directional Stationary Light 比较特殊，它通过 Cascaded Shadow Maps 支持全场景的阴影，同时也支持静止的阴影。这对于有很多植物动画的场景来说非常有用，你希望玩家周围的阴影可以移动，但是又不希望耗费很多来让很多层级覆盖很大范围的可视范围。<br />
</p>
</div>
</li>
<li><a id="org3d794a1"></a>Stationary Light Shadows<br />
<div class="outline-text-8" id="text-org3d794a1">
<p>
动态物体必须整合到从距离场得来的世界静态阴影中，这是通过 Per Object 阴影来完成的。每个可移动的物体从 Stationary Light 会创建两个阴影：一个处理静态世界投射到物体上的阴影，另一个处理物体投射到世界上的阴影。<br />
</p>
</div>
</li>
<li><a id="orgf135e0f"></a>Dynamic Shadows<br />
<div class="outline-text-8" id="text-orgf135e0f">
<p>
动态光投射完全动态的阴影。其光照数据不会被烘培到光照贴图中。<br />
</p>
</div>
</li>
<li><a id="org0bbf57b"></a>Preview Shadows<br />
<div class="outline-text-8" id="text-org0bbf57b">
<p>
在编译光照之前，阴影预览只在编辑器不播放模式时生效，编辑器在播放模式下并不生效。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orga384c22"></a>Lighting Quick Start Guide<br /></li>
</ul>
</div>
<div id="outline-container-org12652aa" class="outline-6">
<h6 id="org12652aa">Precomputed Lighting</h6>
<div class="outline-text-6" id="text-org12652aa">
</div>
<ul class="org-ul">
<li><a id="org805270f"></a>Lightmass Global Illumination<br />
<div class="outline-text-7" id="text-org805270f">
<p>
Lightmass 使用复杂的光照交互（例如，区域阴影和漫反射互相反射）创建光照贴图。它用于预计算 Stationary Light 和 Static Light 的部分光照贡献。<br />
编辑器和 Lightmass 之间的通讯是由 Swarm Agent 来处理的。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4b42fab"></a>Features for Static and Stationary lights<br />
<ul class="org-ul">
<li><a id="orgd254f33"></a>Diffuse Interreflection<br />
<div class="outline-text-9" id="text-orgd254f33">
<p>
到目前为止 Diffuse Interreflection 是最重要的全局照明效果。<br />
通过提高 Primitive、材质或关卡的 DiffuseBoost 参数，来增加漫反射效果。<br />
</p>
</div>
</li>
<li><a id="org30f5771"></a>Character lighting<br />
<div class="outline-text-9" id="text-org30f5771">
<p>
Lightmass 将 Lightmass Importance Volume 分为独立的 3D 格子，在其中放入采样器，默认情况下采样器的密度比较低。在朝上的表面上面，角色可能在其上行走，则采样器密度会比较高。每个光采样器只捕捉来自所有方向的间接光照，但是不会捕捉直接光照。<br />
</p>
</div>
</li>
<li><a id="org017286a"></a>Ambient Occlusion<br />
<div class="outline-text-9" id="text-org017286a">
<p>
Lightmass 会自动计算详细的间接阴影，为了艺术目的或为了增强真实感，夸大间接阴影会非常有用。<br />
Ambient Occlusion 就是物体从均匀明亮的上半球（例如，一个阴暗的天空）获得的间接阴影。Lightmass 支持计算 Ambient Occlusion,将其应用于直接和间接照明,并将其烘培到光照贴图中。<br />
当 Num Indirect Lighting Bounces 参数大于 0 时，就光照构建所花时间而言，Ambient Occlusion 几乎不消耗时间。<br />
</p>

<p>
Num Indirect Lighting Bounces 参数在 World Setting 中的 Lightmass 设置中进行设置。<br />
</p>
</div>
</li>
<li><a id="org38af43b"></a><span class="todo TODO">TODO</span> Masked shadows<br /></li>
</ul>
</li>
<li><a id="org04d5bd6"></a>Features for Stationary Lights Only<br />
<ul class="org-ul">
<li><a id="orgc72fd16"></a>Bent Normal sky occlusion<br />
<div class="outline-text-9" id="text-orgc72fd16">
<ul class="org-ul">
<li>参考资料 <a href="http://blog.csdn.net/bugrunner/article/details/7272902">http://blog.csdn.net/bugrunner/article/details/7272902</a><br /></li>
</ul>
</div>
</li>
<li><a id="org88a32c7"></a>Distance field shadowmaps<br />
<div class="outline-text-9" id="text-org88a32c7">
<p>
Lightmass 会为 Stationary Lights 计算距离场阴影贴图。距离场阴影即使在低分辨率的情况下，也可以很好的维持弯曲形状，但是，它们不支持区域阴影和半透明阴影。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org49a4d83"></a>Features for Static Lights Only<br />
<ul class="org-ul">
<li><a id="org34f1ebe"></a>Area lights and shadows<br />
<div class="outline-text-9" id="text-org34f1ebe">
<p>
使用 Lightmass，所有 Static Lights 默认情况下都为区域光照。点光源和聚光灯的形状为球形，半径通过 Light Source Radius 来设置。方向光的形状为盘子，放置于场景边上。阴影柔和度主要由两个因素来控制,其中一个是光源的尺寸（光源尺寸越大阴影越柔和），另一是接受阴影的地方和投影者之间的距离（距离越大阴影越柔和）。<br />
</p>

<p>
大多数情况下，光源和几何体不应该相交。光源和几何体相交后，光照会从几何体内部相各个方向发出。<br />
</p>
</div>
</li>
<li><a id="org1b6b256"></a>Translucent shadows<br />
<div class="outline-text-9" id="text-org1b6b256">
<p>
灯光经过半透明材质(该材质被应用于静态网格)时会丢失一些能量，从而产生半透明阴影。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8124ec5"></a>Translucent shadow color<br />
<div class="outline-text-10" id="text-org8124ec5">
<p>
通过材质的光线的量被称作透射量，对于每个颜色通道其范围为 0 到 1。0 表示完全不透明，1 表示入射光线通过完全不受影响。目前材质的输入参数中不包含 Transmission，所以目前通过其他材质输入参数来实现：<br />
</p>
<ul class="org-ul">
<li>Lit materials<br />
<ul class="org-ul">
<li>BLEND_Translucent and BLEND_Additive: Transmission = Lerp(White, BaseColor, Opacity)<br /></li>
<li>BLEND_Modulate: Transmission = BaseColor<br /></li>
</ul></li>
<li>Unlit materials<br />
<ul class="org-ul">
<li>BLEND_Translucent and BLEND_Additive: Transmission = Lerp(White, Emissive, Opacity)<br /></li>
<li>BLEND_Modulate: Transmission = Emissive<br /></li>
</ul></li>
</ul>
<p>
这意味着不透明度为 0 的材质将不会过滤入射光，也就不会有半透明阴影。不透明度为 1 的材质将会使用材质的 Emissive 或 Base Color 来过滤入射光线。需要注意的是间接光照有时候会冲淡半透明阴影并使它们的饱和度比半透明材质的 Emissive 或 Base Color 要少。<br />
</p>
</div>
</li>
<li><a id="org91803d5"></a>Translucent shadow sharpness<br />
<div class="outline-text-10" id="text-org91803d5">
<p>
有很多因素影响半透明阴影的清晰度。<br />
光源越小，半透明阴影越清晰。<br />
光照贴图分辨率越高，阴影越清晰。<br />
</p>

<p>
间接光照也会受到半透明材质影响。半透明材质根据 Transmisssion 来过滤通过的光照，然后，被过滤后的光照在场景中继续弹射。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org6be1bdd"></a>Getting the Best Quality with Lightmass<br />
<ul class="org-ul">
<li><a id="orgf350af4"></a>Making lighting noticeable<br />
<ul class="org-ul">
<li><a id="orgf45c15d"></a>Diffuse Textures<br />
<div class="outline-text-10" id="text-orgf45c15d">
<p>
因为 pixel color = BaseColor * Lighting，所以 BaseColor 直接影响光照有多明显。高对比度或偏暗的漫反射贴图会使光照很不明显，低对比度，中等亮度漫反射贴图会让光照细节展示出来。<br />
</p>
</div>
</li>
<li><a id="org6abc66f"></a>Lighting Setup<br />
<div class="outline-text-10" id="text-org6abc66f">
<ul class="org-ul">
<li>避免使用环境光照。像 Ambient cubemap 这样的环境光照会在场景中添加一个常数环境项，这会减低间接光照区域的对比度。<br /></li>
<li>设置光照让直接光照区域和间接光照区域有很高对比度。这样的对比度会更容易看出阴影的过度在哪儿，会让关卡更有深度感。<br /></li>
<li>设置光照让明亮区域不要太明亮，让黑暗区域不要完全黑暗，而是可以看到引人注意的细节。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org211fd40"></a>Improving lighting quality<br />
<ul class="org-ul">
<li><a id="orga956d09"></a>Lightmap resolution<br />
<div class="outline-text-10" id="text-orga956d09">
<p>
使用高分辨率的光照贴图是获得丰富细节、高质量光照的最好方法。<br />
</p>
</div>
</li>
<li><a id="org8308e04"></a>Lightmass Solver quality<br />
<div class="outline-text-10" id="text-org8308e04">
<p>
Lightmass Solver 设置会依据构建质量自动设置，光照构建质量在 Build/Lighting Quality 菜单中进行设置。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org6597fa5"></a>Getting the Best Lighting Build Times<br />
<div class="outline-text-8" id="text-org6597fa5">
<p>
有很多中方法可以改进 Lightmass 构建的时间：<br />
</p>
<ul class="org-ul">
<li>只在高频光照区域使用高分辨率光照贴图。对于不受直接光照和尖锐间接阴影影响的 Brush 表面和静态网格减低光照贴图分辨率。<br /></li>
<li>对于玩家看不到的表面使用最低分辨率的光照贴图<br /></li>
<li>使用 Lightmass Importance Volume 来包含可玩区域(玩家活动的区域)。<br /></li>
<li>在整个地图上对光照贴图分辨率进行优化，从而使不同网格的构建时间更加均衡。光照构建时间永远不会比构建最慢的物体快，无论有多少机器来执行构建。避免连续的巨大的网格使用高分辨率光照贴图来围绕关卡的一大部分。如果将其分解为模块化的多片，你将会获得更快的构建时间，特别是如果构建机器是多核机器。<br /></li>
<li>拥有很多自遮挡的网格会花费更多的构建时间，例如，一块拥有多个平行层的地毯，其构建时间要比一个平坦的地面要更长。<br /></li>
</ul>

<p>
点击 Build/Lighting Info/Lighting StaticMesh Info 可以打开 Statistics 面板。在该面板中，选择 Lighting Build Info 可以查看光照构建信息。<br />
</p>
</div>
</li>
<li><a id="orgc47dc83"></a>Lightmass Settings<br />
<ul class="org-ul">
<li><a id="org9fec320"></a>Lightmass Importance Volume<br /></li>
<li><a id="orgadc065f"></a>World Settings<br />
<div class="outline-text-9" id="text-orgadc065f">
<p>
点击 Settings/World Settings 来设置 World Settings 相关参数。<br />
</p>
</div>
</li>
<li><a id="orge6c3f94"></a>Light Settings<br />
<div class="outline-text-9" id="text-orge6c3f94">
<p>
在灯光的属性中，和 Lightmass 相关的参数在 Lightmass 组中。<br />
</p>
</div>
</li>
<li><a id="orga1a34d5"></a>Primitive Component Settings<br />
<div class="outline-text-9" id="text-orga1a34d5">
<p>
在笔刷的属性中，和 Lightmass 相关的参数在 Lightmass 组中。<br />
</p>
</div>
</li>
<li><a id="org679d406"></a>Base Material Settings<br />
<div class="outline-text-9" id="text-org679d406">
<p>
在材质的属性中，和 Lightmass 相关的参数在 Lightmass 组中。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org0145d9e"></a>Volumetric Lightmaps<br />
<div class="outline-text-7" id="text-org0145d9e">
<p>
从现在开始(从 4.18 版本开始) Volumetric Lightmaps 将会取代 Indirect Lighting Cache 和 Volume Lighting Samples。<br />
可以在 World Settings/Lightmass Settings 中设置 Volume Lighting Method 参数为 VLM Sparse Volume Lighting Samples 来重新开启 Indirect Lighting Cache。<br />
Lightmass 会为静态物体上的间接光照生成光照贴图。但是，动态物体也需要一种方法接收到间接光照。这是通过存储空间中所有点的预计算光照来实现的，这些光照在构建光照时被存储到 Volumetric Lightmap 中，在运行时，对这些数据进行插值来得出动态物体的间接光照。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga48b397"></a>How It Works<br />
<div class="outline-text-8" id="text-orga48b397">
<p>
从高层次来看，Volumetric Lightmaps 系统按照如下方式工作：<br />
</p>
<ul class="org-ul">
<li>Lightmass 会在整个关卡中放置光照采样，在构建光照时会为这些采样器计算间接光照。<br /></li>
<li>当渲染一个动态物体时，Volumetric Lightmap 会被插值给每个被渲染的像素，从而为被渲染的像素提供预计算的间接光照。<br /></li>
<li>如果没有构建的光照可用（意味着该物体是一个新物体或者已经被移动了太多），则只有在光照被重新构建之后，通过插值 Volumetric Lightmap 为静态物体提供光照才会执行。<br /></li>
</ul>
<p>
当放置了 一个 Lightmass Importance Volume 后，Volumetric Lightmap 会创建由 4x4x4 个单元（光照采样）组成的多个砖块。当 Lightmass 运行时，采样单元会被放置到整个 Lightmass Importance Volume，在静态几何体周围，其会使用更多采样单元来捕捉更好的间接光照结果。<br />
每个采样单元使用一个三阶球谐函数来存储来自所有方向的入射光线。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org6ba63ca"></a>Indirect Lighting Cache<br />
<div class="outline-text-7" id="text-org6ba63ca">
<p>
从 4.18 版本开始, Volumetric Lightmaps 已经取代 Indirect Lighting Cache 和 Volume Lighting Samples。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org35b12d2"></a>How It Works<br />
<div class="outline-text-8" id="text-org35b12d2">
<p>
从高层次来看：<br />
</p>
<ul class="org-ul">
<li>Lightmass 会在整个关卡中放置光照采样，在构建光照时会为这些采样器计算间接光照。<br /></li>
<li>当渲染一个动态物体时，Indirect Lighting Cache 检查对于该物体是否存在可用的光照，如果存在则直接使用。<br /></li>
<li>如果没有可用的光照（该动态物体是新的或者被移动太多了），Indirect Lighting Cache 会从预计算光照采样插值生成光照。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org93b44af"></a>Reflection Environment<br />
<div class="outline-text-7" id="text-org93b44af">
<p>
Reflection Environment 特性为关卡中每个区域都提供了高效的光泽反射。很多重要的材质（例如金属）都会依赖由 Reflection Environment 提供的来自各个方向的反射。该特性是面向 Consoles 和中端 PC 平台的，所以，其必须运行的很快。动态物体的反射和尖锐反射也得到了支持，但是需要额外的内存消耗。<br />
</p>
</div>
</li>
<li><a id="orgc44192b"></a>Static Lights<br /></li>
<li><a id="orgf81500e"></a>Stationary lights<br /></li>
<li><a id="orgdf21364"></a>Precomputed Lighting Scenarios<br />
<div class="outline-text-7" id="text-orgdf21364">
<p>
UE4 已经支持在场景中使用不同的 Precomputed Lighting Scenarios(预计算光照情景)。这就允许一个关卡保持和显示多种光照配置，这样就可以获得灵活的动态光照，而且只消耗固定的光照预计算。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8063efd"></a>参考资料<br />
<div class="outline-text-8" id="text-org8063efd">
<ul class="org-ul">
<li><a href="https://answers.unrealengine.com/questions/512084/who-can-explain-of-lighting-scenario-feature.html">https://answers.unrealengine.com/questions/512084/who-can-explain-of-lighting-scenario-feature.html</a><br /></li>
<li><a href="https://www.youtube.com/watch?v=PbayGU6fehY">https://www.youtube.com/watch?v=PbayGU6fehY</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgcd4d893"></a>Lightmass Portals<br />
<div class="outline-text-7" id="text-orgcd4d893">
<p>
当使用 Skylight 或者 HDR 图片来照亮关卡时，你可能会遇到各种问题，这是因为 Lightmass 无法知道场景中的光照来自何处。为了帮助 Lightmass 了解光照来自何处，你可以将 Lightmass Portals Actors 放置到对光照来说重要的区域。<br />
当 Lightmass 构建光照时，Lightmass Portals 告诉 Lightmass，有更多的光线应该来自于其（Lightmass Portal）所在区域，从而产生更高质量的光照和阴影。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0c95dfb" class="outline-6">
<h6 id="org0c95dfb">Dynamic Lighting</h6>
<div class="outline-text-6" id="text-org0c95dfb">
</div>
<ul class="org-ul">
<li><a id="org1587955"></a>Movable Lights<br /></li>
<li><a id="org555a2e5"></a>Light Functions<br />
<div class="outline-text-7" id="text-org555a2e5">
<p>
本质上来说，Light Functions 是一种材质，其可用于过滤光照的亮度。<br />
需要注意的是，不可以通过 Light Functions 修改灯光的颜色，只能通过灯光的 Light Color 属性来修改其颜色。Static Lights 不能使用 Light Functions，因为该特性只能用于非光照贴图的灯光（例如 Stationary 或 Movable 灯光）<br />
</p>
</div>
</li>
<li><a id="orgc2891e2"></a><span class="todo TODO">TODO</span> Light Propagation Volumes<br />
<div class="outline-text-7" id="text-orgc2891e2">
<p>
Light Propagation Volumes 目前(2017-11-30)还是开发版的特性，在正式产品中还不可用。<br />
</p>
</div>
</li>
<li><a id="org990018b"></a>Mesh Distance Fields<br />
<div class="outline-text-7" id="text-org990018b">
<p>
UE4 利用距离场的强大力量来实现游戏中 Static Mesh Actors 的动态环境遮蔽和阴影。除此之外，Actor 的网格距离场表示可被用于其他一些特性，例如 GPU 粒子碰撞，甚至可以使用材质编辑器创建动态流动的地图等等。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgf745c04"></a>How does it work?<br />
<div class="outline-text-8" id="text-orgf745c04">
<p>
为每个静态的网格创建 Signed Distance Field 来表示网格的表面。它存储了每一点距离最近表面的距离，网格内部的点存储的距离为负值。<br />
SDF 的第一个性质是，在进行射线跟踪时，因为已知到最近表面的距离，因此你可以安全地忽略空白空间（有时候称这种方法为 Sphere Tracing）。这样就可以使用很少的步骤判定出交叉点。通过射线追踪一个距离场，就可以得出可见性，也就是说如果射线和网格交叉，则说明光照被投影了。<br />
SDF 的第二个性质是，通过追踪经过遮挡物的距离最近的射线，可以不花费额外消耗就可以计算出近似的圆锥形交叉区域。这样的近似法就可以利用距离场来实现软阴影和天空遮蔽。这个性质是距离场环境遮蔽特性的关键，很少数目的圆锥体就可以为接收点的整个半球计算柔和的可见性。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org238ffbd"></a>Scene Representation<br />
<div class="outline-text-9" id="text-org238ffbd">
<p>
选中 Show &gt; Visualize &gt; Mesh Distance Fields 可以可视化预览 Mesh Distance Fields。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org79bbca0"></a>Quality<br />
<div class="outline-text-10" id="text-org79bbca0">
<p>
双击指定 Static Mesh 打开 Static Mesh 编辑器，通过 Build Settings/Distance Field Resolution Scale 参数来设置该 Static Mesh 对应的体贴图分辨率。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgdfbdc47"></a>Ray Traced Distance Field Soft Shadows<br /></li>
<li><a id="orgfb673c9"></a>Distance Field Ambient Occlusion<br /></li>
<li><a id="org69b71b5"></a>Contact Shadows<br /></li>
<li><a id="org9eb53d9"></a>Capsule Shadows<br /></li>
</ul>
</div>
<div id="outline-container-org16e5e5b" class="outline-6">
<h6 id="org16e5e5b">General</h6>
<div class="outline-text-6" id="text-org16e5e5b">
</div>
<ul class="org-ul">
<li><a id="orgfdbe505"></a>Volumetric Fog<br /></li>
<li><a id="orgdf4f5e2"></a>Ambient Occlusion<br /></li>
<li><a id="org7889cbb"></a>Light Shafts<br /></li>
<li><a id="orgc4b71c1"></a>Ambient Cubemaps<br /></li>
<li><a id="org150d78f"></a>Lit Translucency<br /></li>
<li><a id="org8332e0f"></a>Bump Mapping w/o Tangent Space<br /></li>
<li><a id="org9c51bfb"></a>IES Light Profiles<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5c9367b" class="outline-4">
<h4 id="org5c9367b">Visuals and System Tools</h4>
<div class="outline-text-4" id="text-org5c9367b">
</div>
<div id="outline-container-org299a913" class="outline-5">
<h5 id="org299a913">Cascade Particle Systems</h5>
<div class="outline-text-5" id="text-org299a913">
</div>
<div id="outline-container-org0575fea" class="outline-6">
<h6 id="org0575fea">Key Particle Concepts</h6>
<div class="outline-text-6" id="text-org0575fea">
</div>
<ul class="org-ul">
<li><a id="orgfb92f80"></a><span class="todo TODO">TODO</span> A Modular Approach to Particle Effects<br />
<ul class="org-ul">
<li><a id="orge98c2af"></a>Default Modules<br /></li>
<li><a id="org3715c1b"></a>Module Categories<br /></li>
<li><a id="org466a8cb"></a>Initial vs Over Life<br /></li>
<li><a id="org407794d"></a>Module Time Calculation<br /></li>
</ul>
</li>
<li><a id="org01f02f9"></a>Emitters, Particles Systems, and Emitter Actors<br />
<div class="outline-text-7" id="text-org01f02f9">
<ul class="org-ul">
<li>Modules   定义了粒子的行为，并且它们被放置在 Emitters 中。<br /></li>
<li>Emitters  用于发射特定类型的粒子来实现某个效果，任意数目的 Emitters 可以被放置到一个 Particle System 中。<br /></li>
<li>Particle System   是可以在 Content Browser 中创建的资源。它可以被一个 Emitter Actor 引用。<br /></li>
<li>Emitter Actor     是可以放置在关卡中的物体，其控制在场景中的何处以及如何使用粒子。<br /></li>
</ul>
</div>
</li>
<li><a id="org706eed5"></a>Particle Calculation<br />
<div class="outline-text-7" id="text-org706eed5">
<ul class="org-ul">
<li>在发射器列表中，Emitters（发射器）被从左到右计算<br /></li>
<li>在 Modules 栈中，Modules 被从上到下计算<br /></li>
</ul>
</div>
</li>
<li><a id="org4e76b71"></a><span class="todo TODO">TODO</span> Emitter Types<br /></li>
<li><a id="org30103a1"></a>Parameters<br />
<div class="outline-text-7" id="text-org30103a1">
<p>
参数是一种属性类型，它可以向（或从）其他系统（例如：Blueprints,Matinee,material）发送（或接收）数据。在 Cascade 中，几乎任何一个属性都可以被赋值给一个参数。<br />
相对地，在粒子系统中可以添加 Parameter Modules（参数模块），其可以反过来驱动场景中的其他事物。<br />
在 Cascade 中，参数是通过 Distributions 的方式来创建的。Distributions 是处理一个属性中数据的方式。<br />
</p>
</div>
</li>
<li><a id="org27b5c58"></a>Lit Particles<br />
<div class="outline-text-7" id="text-org27b5c58">
<p>
粒子系统可以被设置为接收光照，但是需要一些特殊的设置：<br />
</p>
<ul class="org-ul">
<li>确保材质使用了除 unlit 以外的光照模型。使用 DefaultLit 光照模型，才可以访问法线贴图，高光贴图等等。<br /></li>
<li>在 Cascade 中，LOD/LODSettings 属性组中，设置 bLit 属性  (然而，并没有找到该属性)<br /></li>
</ul>
</div>
</li>
<li><a id="org6870f83"></a><span class="todo TODO">TODO</span> Levels of Detail(LODs)<br />
<ul class="org-ul">
<li><a id="org52c6e2d"></a>参考资料<br />
<div class="outline-text-8" id="text-org52c6e2d">
<ul class="org-ul">
<li>SubUV Tutorial <a href="https://wiki.unrealengine.com/SubUV_Particle_(Tutorial)">https://wiki.unrealengine.com/SubUV_Particle_(Tutorial)</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0aad3b5"></a><span class="todo TODO">TODO</span> Distributions<br /></li>
</ul>
</div>
<div id="outline-container-orgc4b724b" class="outline-6">
<h6 id="orgc4b724b">Particle System Level of Detail</h6>
<div class="outline-text-6" id="text-orgc4b724b">
<p>
LOD 0 表示距离最近<br />
</p>
</div>
</div>
<div id="outline-container-org0a2f5c7" class="outline-6">
<h6 id="org0a2f5c7">Vector Fields</h6>
<div class="outline-text-6" id="text-org0a2f5c7">
</div>
<ul class="org-ul">
<li><a id="orgafcea37"></a>问题解决<br />
<ul class="org-ul">
<li><a id="orgca11a57"></a>Globle Vector Fields 不起作用<br />
<div class="outline-text-8" id="text-orgca11a57">
<p>
解决方案 1： 在粒子特效编辑器中，执行 Set Fixed Bounds 命令<br />
解决方案 2： 在粒子特效编辑器中，检查 Required Modules 的 Use Local Space 属性是否为 Disabled<br />
</p>

<ul class="org-ul">
<li><a href="https://answers.unrealengine.com/questions/300639/global-vector-fields.html">https://answers.unrealengine.com/questions/300639/global-vector-fields.html</a><br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org549b9f8"></a>参考资料<br />
<div class="outline-text-7" id="text-org549b9f8">
<ul class="org-ul">
<li>Vector Fields Editor   <a href="https://github.com/isathar/Blender_UE4_VectorFieldEditor">https://github.com/isathar/Blender_UE4_VectorFieldEditor</a><br /></li>
<li>Vector Fields Res for Unreal <a href="https://realtimevfx.com/t/free-vector-fields-for-unreal/1531">https://realtimevfx.com/t/free-vector-fields-for-unreal/1531</a><br /></li>
<li>Creating Vector Fields <a href="https://wiki.unrealengine.com/Creating_Vector_Fields_(Tutorial)">https://wiki.unrealengine.com/Creating_Vector_Fields_(Tutorial)</a><br /></li>
<li>Local Vector Fields    <a href="https://wiki.unrealengine.com/Local_Vector_Fields_(Tutorial)">https://wiki.unrealengine.com/Local_Vector_Fields_(Tutorial)</a><br /></li>
<li>Global Vector Fields   <a href="https://wiki.unrealengine.com/Global_Vector_Fields_(Tutorial)">https://wiki.unrealengine.com/Global_Vector_Fields_(Tutorial)</a><br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf66458d" class="outline-6">
<h6 id="orgf66458d">Particle Lights</h6>
<div class="outline-text-6" id="text-orgf66458d">
<p>
Particle Lights 会为每个粒子添加一个灯光，所以对性能影响比较大。<br />
应该使用范围比较大的、少量数目的粒子；或者使用范围比较小的、适度数目的粒子。<br />
</p>
</div>
</div>
<div id="outline-container-org21914a8" class="outline-6">
<h6 id="org21914a8">VFX Optimization Guide</h6>
<div class="outline-text-6" id="text-org21914a8">
</div>
<ul class="org-ul">
<li><a id="org5cfc05c"></a>Common Offenders For Poor Effectes Performance<br />
<ul class="org-ul">
<li><a id="orgdf15704"></a>Overdraw<br />
<div class="outline-text-8" id="text-orgdf15704">
<p>
粒子所覆盖的屏幕空间总量，以及在这些粒子上执行的命令的数量。Overdraw = Number of Layers * 受影响的像素数目。(GPU)<br />
</p>
</div>
</li>
<li><a id="orgce96adf"></a>Tick Time<br />
<div class="outline-text-8" id="text-orgce96adf">
<p>
游戏线程更新所有粒子系统所花费的总时间。(Game Thread)<br />
</p>
</div>
</li>
<li><a id="org3bd5a00"></a>Draw Calls<br />
<div class="outline-text-8" id="text-org3bd5a00">
<p>
为 GPU 做的状态配置准备。（Render Thread）<br />
</p>
</div>
</li>
<li><a id="orgdb3c98a"></a>Bounds Calculation<br />
<div class="outline-text-8" id="text-orgdb3c98a">
<p>
更新一个效果的边界所消耗的总时间，这个边界用于依据摄像机视景体来确定粒子的可见性。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org5266c94"></a>Core Systems For Effect Performance<br />
<ul class="org-ul">
<li><a id="org5545e9d"></a>GPU<br />
<div class="outline-text-8" id="text-org5545e9d">
<p>
将像素绘制到屏幕上所花费的总时间。(Overdraw)<br />
</p>
</div>
</li>
<li><a id="org3f673e9"></a>Game Thread<br />
<div class="outline-text-8" id="text-org3f673e9">
<p>
更新粒子系统行为所花费的总时间。(Tick Time)<br />
</p>
</div>
</li>
<li><a id="org6f528c0"></a>Render Thread<br />
<div class="outline-text-8" id="text-org6f528c0">
<p>
打包粒子几何以及相关的 Draw Call 所花费的总时间。(Draw Calls)<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2d2e11f" class="outline-4">
<h4 id="org2d2e11f">Performance And Debugging</h4>
<div class="outline-text-4" id="text-org2d2e11f">
</div>
<div id="outline-container-org4024875" class="outline-5">
<h5 id="org4024875"><span class="todo TODO">TODO</span> Scalability</h5>
</div>
<div id="outline-container-org17ecd6f" class="outline-5">
<h5 id="org17ecd6f"><span class="todo TODO">TODO</span> Rendering Visualizers</h5>
</div>
</div>
<div id="outline-container-org58a46ee" class="outline-4">
<h4 id="org58a46ee">Mobile Rendering and Visualization</h4>
<div class="outline-text-4" id="text-org58a46ee">
</div>
<div id="outline-container-org2aed6b6" class="outline-5">
<h5 id="org2aed6b6">Mobile Rendering</h5>
</div>
<div id="outline-container-org028cbe5" class="outline-5">
<h5 id="org028cbe5">Mobile Previewer</h5>
</div>
</div>
</div>
</div>
<div id="outline-container-org946e60b" class="outline-2">
<h2 id="org946e60b">Programming and Scripting</h2>
<div class="outline-text-2" id="text-org946e60b">
</div>
<div id="outline-container-org47cd703" class="outline-3">
<h3 id="org47cd703">Programing with C++</h3>
<div class="outline-text-3" id="text-org47cd703">
<ul class="org-ul">
<li><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/index.html">https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/index.html</a><br /></li>
</ul>
</div>
<div id="outline-container-org6957655" class="outline-4">
<h4 id="org6957655">Getting Started</h4>
<div class="outline-text-4" id="text-org6957655">
</div>
<div id="outline-container-org8317793" class="outline-5">
<h5 id="org8317793">Programming Quick Start</h5>
</div>
<div id="outline-container-org5024f49" class="outline-5">
<h5 id="org5024f49">Introduction to C++ Programming in UE4</h5>
<div class="outline-text-5" id="text-org5024f49">
<ul class="org-ul">
<li><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/IntroductionToCPP/index.htlm">https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/IntroductionToCPP/index.htlm</a><br /></li>
</ul>
</div>
<div id="outline-container-org58cf50a" class="outline-6">
<h6 id="org58cf50a">Base</h6>
<div class="outline-text-6" id="text-org58cf50a">
</div>
<ul class="org-ul">
<li><a id="orgf5d892e"></a>C++暴露属性给 Blueprint<br />
<div class="outline-text-7" id="text-orgf5d892e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5; font-weight: bold;">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span style="color: #2d9574;">"Damage"</span>)
<span style="color: #ce537a; font-weight: bold;">int32</span> <span style="color: #7590db;">TotalDamage</span>;

<span style="color: #bc6ec5; font-weight: bold;">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span style="color: #2d9574;">"Damage"</span>)
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">DamageTimeInSeconds</span>;

<span style="color: #bc6ec5; font-weight: bold;">UPROPERTY</span>(BlueprintReadOnly, VisibleAnywhere, Transient, Category = <span style="color: #2d9574;">"Damage"</span>)
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">DamagePerSecond</span>;
</pre>
</div>
</div>
</li>
<li><a id="org3b347b9"></a>Blueprint 调用 C++函数<br />
<div class="outline-text-7" id="text-org3b347b9">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5; font-weight: bold;">UFUNCTION</span>(BlueprintCallable, Category=<span style="color: #2d9574;">"Damage"</span>)
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalculateValues</span>();
</pre>
</div>
</div>
</li>
<li><a id="org1460a34"></a>C++调用 Blueprint 函数<br />
<div class="outline-text-7" id="text-org1460a34">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MyActor.h</span>
<span style="color: #bc6ec5; font-weight: bold;">UCLASS</span>()
class <span style="color: #ce537a; font-weight: bold;">QUICKSTARTCPLUSPLUS_API</span> <span style="color: #7590db;">AMyActor</span> : public AActor
{
    GENERATED_BODY()
    
public: 
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Sets default values for this actor's properties</span>
    AMyActor();

    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">......</span>

<span style="color: #a45bad;">public</span>:
    UFUNCTION(BlueprintImplementableEvent, Category = <span style="color: #2d9574;">"Damage"</span>)
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalledFromCppV1</span>();

    UFUNCTION(BlueprintNativeEvent, Category = <span style="color: #2d9574;">"Damage"</span>)
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalledFromCppV2</span>();
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CalledFromCppV2_Implementation</span>();
};

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">MyActor.cpp</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AMyActor</span>::CalledFromCppV2_Implementation()
{
    GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, <span style="color: #2d9574;">"CalledFromCppV2 Cpp"</span>);
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb3cc0fe" class="outline-6">
<h6 id="orgb3cc0fe">Diving Deeper</h6>
<div class="outline-text-6" id="text-orgb3cc0fe">
</div>
<ul class="org-ul">
<li><a id="orgf50b00e"></a>Gameplay Classes:Objects,Actors,and Components<br />
<ul class="org-ul">
<li><a id="org55baa92"></a>Unreal Objects(UObject)<br />
<div class="outline-text-8" id="text-org55baa92">
<p>
Unreal Engine 内置的基础块被称为 UObject。该类和 UClass 配合，提供了一系列重要的基础服务：<br />
</p>
<ul class="org-ul">
<li>属性和方法的反射<br /></li>
<li>属性的序列化<br /></li>
<li>垃圾回收<br /></li>
<li>按照名字查找 UObjects<br /></li>
<li>为属性配置值<br /></li>
<li>为属性和方法提供网络支持<br /></li>
</ul>

<p>
每个派生自 UObject 的类，都会为该类创建一个对应的 UClass 单例，单例中存储了类中所有的元数据。<br />
</p>
</div>
</li>
<li><a id="orgf42286d"></a>AActor<br />
<div class="outline-text-8" id="text-orgf42286d">
<p>
AActor 属于 Gameplay 系统的部分对象。AActor 既可以由设计师放置到关卡中，也可以由 Gameplay 系统在运行时创建出来。所有可以放置到关卡中的对象都是从该类扩展出来的。例如：AStaticMeshActor,ACameraActor,以及 APointLight.AActors 可以通过 gameplay 代码显式地销毁，也可以在其所属的关卡从内存中卸载时，通过标准的垃圾回收机制销毁。AActors 的主要负责的是你游戏对象的高级行为。AActors 也是网络通讯中可以复制的基本类型。在网络复制中，AActors 可以向它所拥有的 UActorComponents 发送消息，如果这些 UActorComponent 需要网络支持。<br />
</p>

<p>
AActors 有它们自己的行为（通过继承来指定），但是它们也扮演着容器的角色，其容纳了一个 UActorComponents 组成的层级结构（通过组合来指定）。这是通过 AActor 的 RootComponent 成员来实现的，其中包含了一个 UActorComponent,而该 UActorComponent 又可以包含很多其他的 UActorComponent。在 AActor 可以被放置到关卡中之前，AActor 必须包含至少一个 USceneComponent，其包含了 AActor 的变换、旋转和缩放。<br />
</p>

<p>
AActors 包含一系列的事件，它们会在 AActor 的生命周期内被调用：<br />
</p>
<ul class="org-ul">
<li>BeginPlay 当对象第一次进入 Gameplay 空间时，被调用<br /></li>
<li>Tick      每一帧都会被调用<br /></li>
<li>EndPlay   当对象离开 Gameplay 空间时，被调用<br /></li>
</ul>

<p>
在游戏中生成一个 Actor 要比创建普通对象要复杂，这是因为 AActor 需要在一些运行时系统进行注册，从而提供其所需。Actor 的初始化位置和旋转需要设置，物理系统需要知道它，负责通知 Actor 进行 tick 的管理者需要知道它，等等。UWorld::SpawnActor()专门用于生成 Actor。一旦 Actor 被成功生成，它的 BeginPlay 就会被调用，Tick 会在下一帧中被调用。<br />
</p>
</div>
</li>
<li><a id="orgf9d3b61"></a>UActorComponent<br />
<div class="outline-text-8" id="text-orgf9d3b61">
<p>
UActorComponent 有它们自己的行为，并且它们的职责通常是可以在很多不同类型 AActor 之间共享的功能，例如 提供可视化的 Mesh，粒子特效，摄像机透视，以及物理交互等等。<br />
AActor 相当于 Unity3D 中的 GameObject。UActorComponnet 相当于 Unity3D 中的 Component。<br />
</p>
</div>
</li>
<li><a id="orgcbb8dfc"></a>UStruct<br />
<div class="outline-text-8" id="text-orgcbb8dfc">
<p>
使用 UStruct 不需要从任何特定的类扩展，只需要使用 USTRUCT() 来标记 struct 就可以了。不像 UObject，UStructs 不会被垃圾回收。如果你动态创建了 UStruct 实例，你必须自己管理它们的生命周期。UStruct 主要用于简单的老的数据类型，其在 UObject 的反射支持下，可以在 Unreal 编辑器中进行编辑，可使用 Blueprint 进行操纵，可以序列化等等。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgb95af1c" class="outline-6">
<h6 id="orgb95af1c">Diving Deeper Still</h6>
<div class="outline-text-6" id="text-orgb95af1c">
</div>
<ul class="org-ul">
<li><a id="orga90efbe"></a>Unreal Reflection System<br />
<div class="outline-text-7" id="text-orga90efbe">
<p>
UE4 使用自己实现的反射来支持动态特性（垃圾回收，序列化，网络复制，以及 Blueprint/C++交互）。这些特性都是可选的，这意味着你必须为你的类型添加正确的标记，否则 Unreal 将会忽略它们，并且不生成反射数据。<br />
</p>
<ul class="org-ul">
<li>UCLASS()   用于告诉 Unreal 为一个类生成反射数据。这个类必须从 UObject 派生<br /></li>
<li>USTRUCT()  用于告诉 Unreal 为一个结构体生成反射数据。<br /></li>
<li>GENERATED_BODY() UE4 会使用为该类生成的所有必要的样板代码代替这句话<br /></li>
<li>UPROPERTY()  用于标记一个 UCLASS 或 USTRUCT 的成员变量可被用作 UPROPERTY。<br /></li>
<li>UFUNCTION()  用于标记一个 UCLASS 或 USTRUCT 的成员方法可被用作 UFUNCTION。<br /></li>
</ul>

<p>
Unreal 会将所有生成的反射数据放置到 XXX.generated.h 头文件中。必须在对应类定义的头文件中包含该生成的头文件。<br />
</p>
</div>
</li>
<li><a id="orgfe23119"></a>Object/Actor Iterators<br />
<ul class="org-ul">
<li><a id="org2bdfec6"></a>UObject 及其 派生类对象的遍历<br />
<div class="outline-text-8" id="text-org2bdfec6">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#24403;&#21069;&#25152;&#26377; UObject &#31867;&#22411;&#30340;&#23454;&#20363;</span>
<span style="color: #4f97d7; font-weight: bold;">for</span> (TObjectIterator&lt;UObject&gt; It; It; ++It)
{
    <span style="color: #ce537a; font-weight: bold;">UObject</span>* <span style="color: #7590db;">CurrentObject</span> = *It;
    UE_LOG(LogTemp, Log, TEXT(<span style="color: #2d9574;">"Found UObject named: %s"</span>), *CurrentObject-&gt;GetName());
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36941;&#21382;&#24403;&#21069;&#25152;&#26377; UMyClass &#31867;&#22411;&#30340;&#23454;&#20363;</span>
<span style="color: #4f97d7; font-weight: bold;">for</span> (TObjectIterator&lt;UMyClass&gt; It; It; ++It)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tips:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#22312; PIE &#20013;&#20351;&#29992;&#23545;&#35937;&#36845;&#20195;&#22120;&#20250;&#23548;&#33268;&#19981;&#21487;&#39044;&#26399;&#30340;&#32467;&#26524;&#65292;&#22240;&#20026;&#32534;&#36753;&#22120;&#24050;&#32463;&#21152;&#36733;&#65292;&#25152;&#20197;&#23545;&#35937;&#36845;&#20195;&#22120;&#19981;&#20165;&#20250;&#36820;&#22238;&#20026;&#20320;&#28216;&#25103;&#19990;&#30028;&#23454;&#20363;&#21019;&#24314;&#30340; UObject &#23545;&#35937;&#65292;&#20063;&#20250;&#36820;&#22238;&#37027;&#20123;&#21482;&#34987;&#32534;&#36753;&#22120;&#20351;&#29992;&#30340; UObject &#23545;&#35937;&#12290;</span>


</pre>
</div>
</div>
</li>
<li><a id="org74bf8ab"></a>AActor 及其 派生类对象的遍历<br />
<div class="outline-text-8" id="text-org74bf8ab">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">APlayerController</span>* <span style="color: #7590db;">MyPC</span> = GetMyPlayerControllerFromSomewhere();
<span style="color: #ce537a; font-weight: bold;">UWorld</span>* <span style="color: #7590db;">World</span> = MyPC-&gt;GetWorld();

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Like object iterators, you can provide a specific class to get only objects that are</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">or derive from that class</span>
<span style="color: #4f97d7; font-weight: bold;">for</span> (TActorIterator&lt;AEnemy&gt; It(World); It; ++It)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org0c8284b" class="outline-6">
<h6 id="org0c8284b">Memory Management and Carbage Collection</h6>
<div class="outline-text-6" id="text-org0c8284b">
</div>
<ul class="org-ul">
<li><a id="orgc9f21d3"></a>UObjects and Garbage Collection<br />
<div class="outline-text-7" id="text-orgc9f21d3">
<p>
在垃圾收集器中，有一个概念叫做根集合。根集合是一个对象列表，这些对象是收集器知道的永远不会被垃圾回收的对象。如果从根集合中任何一个对象到某个对象有一条引用路径，那么该对象就不会被垃圾回收，如果不存在这样的路径，那么该对象将会在垃圾收集器下次执行时被回收。引擎按照一定的时间间隔执行垃圾回收。<br />
</p>

<p>
任何存储在 UPROPERTY 中的 UObject 指针，都被认作一个引用。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5; font-weight: bold;">UCLASS</span>()
<span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">MyGCType</span> : public UObject
{
    GENERATED_BODY()
};

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">CreateDoomedObject</span>()
{
      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">DoomedObject &#19981;&#23646;&#20110;&#26681;&#38598;&#21512;&#65292;&#20063;&#27809;&#26377;&#23384;&#20648;&#22312; UPROPERTY &#20013;&#65292;&#25152;&#20197;&#20250;&#34987;&#22403;&#22334;&#22238;&#25910;</span>
    <span style="color: #ce537a; font-weight: bold;">MyGCType</span>* <span style="color: #7590db;">DoomedObject</span> = NewObject&lt;MyGCType&gt;();
}
</pre>
</div>
</div>
</li>
<li><a id="orgeb46c75"></a>Actors and Garbage Collection<br />
<div class="outline-text-7" id="text-orgeb46c75">
<p>
Actors 不会被通常的垃圾收集回收，Actors 会自动添加到根集合中。一旦生成，你在其上必须手动调用 Destroy(). 它们不会被立即删除，而是在下次垃圾收集阶段被清除，可以通过 IsPendingKill() 方法来检查一个 UObject 对象是否在等待被删除。<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #bc6ec5; font-weight: bold;">UCLASS</span>()
<span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">AMyActor</span> : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY()
    <span style="color: #ce537a; font-weight: bold;">MyGCType</span>* <span style="color: #7590db;">SafeObject</span>;

    <span style="color: #ce537a; font-weight: bold;">MyGCType</span>* <span style="color: #7590db;">DoomedObject</span>;

    AMyActor(<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">FObjectInitializer</span>&amp; <span style="color: #a45bad;">ObjectInitializer</span>)
        : Super(ObjectInitializer)
    {
        SafeObject = NewObject&lt;MyGCType&gt;();
        DoomedObject = NewObject&lt;MyGCType&gt;();
    }
};

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">SpawnMyActor</span>(<span style="color: #ce537a; font-weight: bold;">UWorld</span>* <span style="color: #7590db;">World</span>, <span style="color: #ce537a; font-weight: bold;">FVector</span> <span style="color: #7590db;">Location</span>, <span style="color: #ce537a; font-weight: bold;">FRotator</span> <span style="color: #7590db;">Rotation</span>)
{
    World-&gt;SpawnActor&lt;AMyActor&gt;(Location, Rotation);
}

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#24403; UObject &#34987;&#22403;&#22334;&#25910;&#38598;&#21518;&#65292;&#25152;&#26377;&#24341;&#29992;&#23427;&#30340; UPROPERTY &#37117;&#20250;&#34987;&#35774;&#32622;&#20026; nullptr</span>
<span style="color: #4f97d7; font-weight: bold;">if</span> (MyActor-&gt;SafeObject != nullptr)
{
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Use SafeObject</span>
}
</pre>
</div>
</div>
</li>
<li><a id="org6412725"></a>UStructs<br />
<div class="outline-text-7" id="text-org6412725">
<p>
就像前面提到的，UStructs 主要用作轻量级版本的 UObject。因此，UStructs 不能被垃圾收集。如果你必须使用 UStructs 的动态实例，你可以使用智能指针代替，我们在后面会谈。<br />
</p>
</div>
</li>
<li><a id="orgc6e4fd5"></a>Non-UObject References<br />
<div class="outline-text-7" id="text-orgc6e4fd5">
<p>
通常 Non-UObject 也可以添加一个到对象的引用从而防止垃圾回收。想要这样做的话，你的对象必须从 FGCObject 派生并且从写它的 AddReferencedObjects。<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ce537a; font-weight: bold;">class</span> <span style="color: #7590db;">FMyNormalClass</span> : public FGCObject
{
<span style="color: #a45bad;">public</span>:
    <span style="color: #ce537a; font-weight: bold;">UObject</span>* <span style="color: #7590db;">SafeObject</span>;

    FMyNormalClass(<span style="color: #ce537a; font-weight: bold;">UObject</span>* <span style="color: #a45bad;">Object</span>)
        : SafeObject(Object)
    {
    }

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AddReferencedObjects</span>(FReferenceCollector&amp; Collector) override
    {
          <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20351;&#29992; FReferenceCollector &#25163;&#21160;&#28155;&#21152;&#19968;&#20010;&#24378;&#24341;&#29992;&#21040; UObject&#12290;&#24403;&#23545;&#35937;&#34987;&#21024;&#38500;&#26102;&#65292;&#23427;&#30340;&#26512;&#26500;&#20989;&#25968;&#20250;&#34987;&#25191;&#34892;&#65292;&#35813;&#23545;&#35937;&#23558;&#33258;&#21160;&#28165;&#38500;&#23427;&#28155;&#21152;&#30340;&#25152;&#26377;&#24341;&#29992;&#12290;</span>
        Collector.AddReferencedObject(SafeObject);
    }
};
</pre>
</div>
</div>
</li>
<li><a id="org5864a0c"></a>Class Naming Prefixes<br />
<div class="outline-text-7" id="text-org5864a0c">
<ul class="org-ul">
<li>从 AActor 派生的类使用前缀 A,例如：AController<br /></li>
<li>从 UObject 派生的类使用前缀 U,例如：UComponent<br /></li>
<li>枚举类型使用前缀 E,例如：ENortificationType<br /></li>
<li>接口类通常使用前缀 I，例如：IAbilitySystemInterface<br /></li>
<li>Template 类使用前缀 T,例如：TArray<br /></li>
<li>从 SWidget 派生的类使用前缀 S,例如：SButton<br /></li>
<li>其他的类使用 F 前缀，例如 FVector<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgde7bd4a" class="outline-4">
<h4 id="orgde7bd4a">Development Setup</h4>
<div class="outline-text-4" id="text-orgde7bd4a">
</div>
<div id="outline-container-org8597019" class="outline-5">
<h5 id="org8597019">源码编译</h5>
<div class="outline-text-5" id="text-org8597019">
<p>
编译步骤在 github 仓库的 README 中有详细描述。<br />
</p>

<ul class="org-ul">
<li>源码地址<br />
<a href="https://github.com/EpicGames/UnrealEngine">https://github.com/EpicGames/UnrealEngine</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf77b509" class="outline-5">
<h5 id="orgf77b509"><span class="todo TODO">TODO</span> Coding Standard</h5>
<div class="outline-text-5" id="text-orgf77b509">
</div>
<div id="outline-container-orge5c33cb" class="outline-6">
<h6 id="orge5c33cb">Naming Conventions</h6>
<div class="outline-text-6" id="text-orge5c33cb">
<ul class="org-ul">
<li>名字中的第一个字母都大写，单词之间没有下划线。<br /></li>
<li>类型名加大写字母前缀<br />
<ol class="org-ol">
<li>模板类使用前缀 T<br /></li>
<li>UObject 子类使用前缀 U<br /></li>
<li>AActor 子类使用前缀 A<br /></li>
<li>SWidget 子类使用前缀 S<br /></li>
<li>抽象接口类使用前缀 I<br /></li>
<li>枚举使用前缀 E<br /></li>
<li>Boolean 变量使用前缀 b<br /></li>
<li>大部分其他的类使用前缀 F，然而一些子系统使用其他字母前缀<br /></li>
<li>类型定义应该使用适合于对应类型的前缀：struct 的类型定义前缀使用 F，UObject 的类型定义前缀使用 U<br /></li>
<li>特定模板实例的类型定义不再是模板，应该使用对应的前缀：typedef TArray&lt;FMyType&gt; FArrayOfMyTypes;<br /></li>
<li>大多数情况下 UnrealHeaderTool 需要正确的前缀，所以提供正确的前缀很重要。<br /></li>
</ol></li>
<li>类型和变量的名字使用名词<br /></li>
<li>方法的名字是动词，用来描述方法的效果，或者当该方法没有效果时，描述方法的返回值<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org604e028" class="outline-6">
<h6 id="org604e028">Portable Aliases for Basic C++ Types</h6>
<div class="outline-text-6" id="text-org604e028">
<p>
在 integer 宽度不重要的地方，可以使用 c++ 的 int 和 unsigned int 类型（它们在不同平台内存占用大小是不同的）。在序列化时，依然必须使用显式尺寸的类型。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2456010" class="outline-4">
<h4 id="org2456010">Unreal Engine Architecture</h4>
<div class="outline-text-4" id="text-org2456010">
</div>
<div id="outline-container-orge011bac" class="outline-5">
<h5 id="orge011bac">Overview</h5>
<div class="outline-text-5" id="text-orge011bac">
<ul class="org-ul">
<li><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/index.html">https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/index.html</a><br /></li>
</ul>

<p>
Actors 是 AActor 派生类的实例，AActor 是所有可放置到游戏世界中的游戏性对象的基类。Objects 是 UObject 派生类的实例，UObject 是 Unreal 引擎所有对象的基类，包括 Actors。Actors 指继承结构中由 AActor 类的对象，而 Objects 指继承结构中没有 AActor 类的对象。<br />
</p>

<p>
基础的 gameplay 类包含了表示玩家、盟友、敌人的功能，还有用于控制这些 avatar 的控制类，以及创建 HUD 显示和玩家摄像机的类。最后，GameMode GameState PlayerState 这些类设定了游戏规则，并且追踪游戏和玩家如何被处理。Actors 既可以被放置到关卡中，可以被可以在需要的时候被生成出来。<br />
</p>
</div>
<div id="outline-container-orga892cb5" class="outline-6">
<h6 id="orga892cb5">表示世界中的玩家、朋友和敌人</h6>
<div class="outline-text-6" id="text-orga892cb5">
<ul class="org-ul">
<li>Pawn  属于 Actor，其可以是游戏世界中的一个代理。Pawn 可以被 Controller 处理，其增加了一些功能以便接受输入，其可以做各种类似玩家的事情。Pawn 可能不是类人的角色。<br /></li>
<li>Character 属于类人的 Pawn。其默认就会包含一个 CapsuleComponent 和一个 CharacterMovementComponent。其可以做类似人一样的移动，其可以跨越网络复现平滑的移动，其还包含了一些动画相关的功能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org67acd66" class="outline-6">
<h6 id="org67acd66">使用玩家输入或 AI 逻辑控制 Pawns</h6>
<div class="outline-text-6" id="text-org67acd66">
<ul class="org-ul">
<li>Controller 属于 Actor，用于指导一个 Pawn。Controller 可以处理一个 Pawn 来控制该 Pawn。<br /></li>
<li>PlayerController 是 Pawn 和人类玩家之间的接口。PlayerController 用于表达人类玩家的意志。<br /></li>
<li>AIController 通过 AIController，可以用一个模拟的意志来控制一个 Pawn<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org793fee2" class="outline-6">
<h6 id="org793fee2">显示玩家信息</h6>
<div class="outline-text-6" id="text-org793fee2">
<ul class="org-ul">
<li>HUD (heads-up display) 头顶信息显示用于显示血量、弹药、枪的准心等信息<br /></li>
<li>Camera PlayerCameraManager 是玩家的眼球，用于管理眼球的行为。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8e4f3c6" class="outline-6">
<h6 id="org8e4f3c6">设置和追踪游戏的规则</h6>
<div class="outline-text-6" id="text-org8e4f3c6">
<ul class="org-ul">
<li>GameMode   游戏的概念被一分为二。GameMode 和 GameState 共同定义了 Game。其包含了游戏规则，胜利条件。其通常仅存在于服务器上。游戏过程中，GameMode 中通常不会有很多数据发生改变，也绝对不应有客户端需要了解的临时数据。<br /></li>
<li>GameState  其中包含了游戏的状态，其应该包含一个连入游戏的玩家列表，分数，象棋游戏中每个子的位置，或者在开放世界中，一个你需要完成的任务列表。GameState 存在于服务器上，所有的客户端都可以自由复制以保持所有机器都处于最新状态。<br /></li>
<li>PlayerState 其保存了游戏参与者的状态。非玩家 AI 不应该有 PlayerState。存在于所有机器上的所有玩家 PlayerState 数据可以自由复制来保持同步。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org421e931" class="outline-6">
<h6 id="org421e931">Framework Class Relationships</h6>
<div class="outline-text-6" id="text-org421e931">

<div id="org1f522b7" class="figure">
<p><img src="./UnrealEngineNote/unreal_architecture_GameFramework.jpg" alt="unreal_architecture_GameFramework.jpg" /><br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org25de8c9" class="outline-5">
<h5 id="org25de8c9">Gameplay Classes</h5>
</div>
<div id="outline-container-orgea482fd" class="outline-5">
<h5 id="orgea482fd">Gameplay Modules</h5>
</div>
<div id="outline-container-org98e09f5" class="outline-5">
<h5 id="org98e09f5">UFunctions</h5>
</div>
<div id="outline-container-org1a27419" class="outline-5">
<h5 id="org1a27419">Interfaces</h5>
</div>
<div id="outline-container-org8213981" class="outline-5">
<h5 id="org8213981">Properties</h5>
</div>
<div id="outline-container-orgef27c3a" class="outline-5">
<h5 id="orgef27c3a">Structs</h5>
</div>
<div id="outline-container-org5367a43" class="outline-5">
<h5 id="org5367a43">Metadata Specifiers</h5>
</div>
</div>
<div id="outline-container-org960b775" class="outline-4">
<h4 id="org960b775">Gameplay Architecture</h4>
</div>
<div id="outline-container-orgb5eff80" class="outline-4">
<h4 id="orgb5eff80">Gameplay Guides</h4>
</div>
<div id="outline-container-org84d09e5" class="outline-4">
<h4 id="org84d09e5">System Guides</h4>
<div class="outline-text-4" id="text-org84d09e5">
</div>
<div id="outline-container-org2bb47cf" class="outline-5">
<h5 id="org2bb47cf">Graphics=Programming</h5>
<div class="outline-text-5" id="text-org2bb47cf">
<p>
<a href="#orge01e597">参考Graphics Programming</a><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org06cd875" class="outline-4">
<h4 id="org06cd875">Automated Builds</h4>
</div>
</div>
<div id="outline-container-org392e4b1" class="outline-3">
<h3 id="org392e4b1">Asset Handling Reference Guides</h3>
</div>
<div id="outline-container-org53fa087" class="outline-3">
<h3 id="org53fa087">Blueprint Visual Scripting</h3>
</div>
<div id="outline-container-org76051b7" class="outline-3">
<h3 id="org76051b7">Class Creation Basics</h3>
</div>
<div id="outline-container-org6f4945e" class="outline-3">
<h3 id="org6f4945e">Gameplay Architecture</h3>
</div>
<div id="outline-container-orgb348d17" class="outline-3">
<h3 id="orgb348d17">Gameplay Debugger</h3>
</div>
<div id="outline-container-orge01e597" class="outline-3">
<h3 id="orge01e597">Graphics Programming</h3>
<div class="outline-text-3" id="text-orge01e597">
</div>
<div id="outline-container-org3b631c2" class="outline-4">
<h4 id="org3b631c2">Graphics Programming Overview</h4>
<div class="outline-text-4" id="text-org3b631c2">
</div>
<div id="outline-container-orgf0ca9a5" class="outline-5">
<h5 id="orgf0ca9a5">Getting Started</h5>
<div class="outline-text-5" id="text-orgf0ca9a5">
<p>
Unreal 中和渲染相关的代码很多，从 FDeferredShadingSceneRenderer::Render 着手开始了解是一个不错的开始。FDeferredShadingSceneRenderer::Render 是在渲染线程中开始渲染新的一帧的地方。也可以做一个 gpu 命令的 profile，通读一下绘制事件。然后，在 Visual Studio 中按照绘制事件名称来查找对应的 C++实现。<br />
</p>

<p>
渲染相关的有用的 Console 命令：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Console Command</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">stat unit</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
渲染相关的有用的 命令行：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Commandline</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org40a0c6c" class="outline-5">
<h5 id="org40a0c6c">Modules</h5>
<div class="outline-text-5" id="text-org40a0c6c">
<p>
渲染代码被放在自己的模块中，其被编译为一个 dll 从而避免整体的编译。这样就可以快速迭代，当我们修改了渲染代码后，不需要链接整个程序。渲染模块依赖于 Engine 模块，因为它的很多回调函数在 Engine 模块中。引擎模块通常通过 IRenderModule 或 FSceneInterface 接口来调用 Renderer 中方法.<br />
</p>
</div>
</div>
<div id="outline-container-org026b100" class="outline-5">
<h5 id="org026b100">Scene representation</h5>
<div class="outline-text-5" id="text-org026b100">
<p>
在 UE4 中，场景是由基元组件和存储在 FScene 中的各种数据结构的列表来定义的。通过维护一个八叉树来加速空间查找。<br />
</p>
</div>
<div id="outline-container-org68f8a11" class="outline-6">
<h6 id="org68f8a11">Primary scene classes</h6>
<div class="outline-text-6" id="text-org68f8a11">
<p>
在 UE4 中有一个渲染线程(Render Thread)，它和游戏线程(Game Thread)同步执行。大多数在渲染线程和游戏线程建立桥梁的类依据它的状态所有权属于哪个线程被分为两个部分。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Class</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UWorld</td>
<td class="org-left">包含了可以互相交互的 Actors 和 Components 集合。 关卡（Levels）可以被流化到 world 中，也可以被流化出 world。程序中可以激活多个 world</td>
</tr>

<tr>
<td class="org-left">ULevel</td>
<td class="org-left">Actors 和 Components 集合，它们被同时加载和卸载。并且存储在同一个地图文件中，</td>
</tr>

<tr>
<td class="org-left">USceneComponent</td>
<td class="org-left">任何需要添加到 FScene 的对象的基类，例如 lights，meshes，fog 等等</td>
</tr>

<tr>
<td class="org-left">UPrimitiveComponent</td>
<td class="org-left">任何可以被渲染或可以和物理交互的对象的基类。也作为可视性剔除的粒度以及渲染属性的说明（例如，投射阴影等等）。和 UObjects 一样，游戏线程拥有的变量和状态，渲染线程不能直接访问</td>
</tr>

<tr>
<td class="org-left">ULightComponent</td>
<td class="org-left">表示一个光源。渲染器有责任计算和添加光源的贡献到场景中。</td>
</tr>

<tr>
<td class="org-left">FScene</td>
<td class="org-left">渲染器版本的 UWorld。只有将对象添加到 FScene 中，该对象对于渲染器来说才存在。将对象添加到 FScene 被称为注册组件。渲染线程拥有 FScene 的全部状态，游戏线程不能直接修改。</td>
</tr>

<tr>
<td class="org-left">FPrimitiveSceneProxy</td>
<td class="org-left">渲染版本的 UPrimitiveComponent,为渲染线程镜像 UPrimitiveComponent 状态。存在于 Engine 模块并且被子类化来支持不同类型的 Primitives（skeletal，rigid，BSP 等等）。实现了很多比较重要的函数，例如 GetViewRelevance DrawDynamicElements 等等</td>
</tr>

<tr>
<td class="org-left">FPrimitiveSceneInfo</td>
<td class="org-left">内部的渲染状态（特别是对 FRendererModule 的实现），其对应一个 UPrimitiveComponent 和 FPrimitiveSceneProxy。存在于渲染模块，所以引擎模块看不到它</td>
</tr>

<tr>
<td class="org-left">FSceneView</td>
<td class="org-left">FScene 的当个视图的引擎表示。可以使用不同的 view 在不同的地方调用 FSceneRenderer::Render 来渲染一个场景(从而支持编辑器的多个视口)。也可以使用不同的视图通过同一个 FSceneRenderer::Render 调用来渲染场景（从而支持游戏中的分屏）。每一帧都会创建一个新的 View</td>
</tr>

<tr>
<td class="org-left">FViewInfo</td>
<td class="org-left">视图的内部渲染表示，存在于渲染模块</td>
</tr>

<tr>
<td class="org-left">FSceneViewState</td>
<td class="org-left">ViewState 存储了一个 view 的私有的渲染信息，这些信息被不同的帧使用。在游戏中，每个 ULocalPlayer 都有一个 ViewState</td>
</tr>

<tr>
<td class="org-left">FSceneRenderer</td>
<td class="org-left">每一帧都会创建的类，用于封装帧之间的临时变量</td>
</tr>
</tbody>
</table>

<p>
下表按照所属模块列出主要的类<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Engine Module</th>
<th scope="col" class="org-left">Renderer Module</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UWorld</td>
<td class="org-left">FScene</td>
</tr>

<tr>
<td class="org-left">UPrimitiveComponent/FPrimitiveSceneProxy</td>
<td class="org-left">FPrimitiveSceneInfo</td>
</tr>

<tr>
<td class="org-left">FSceneView</td>
<td class="org-left">FViewInfo</td>
</tr>

<tr>
<td class="org-left">ULocalPlayer</td>
<td class="org-left">FSceneViewState</td>
</tr>

<tr>
<td class="org-left">ULightComponent/FLightSceneProxy</td>
<td class="org-left">FLightSceneInfo</td>
</tr>
</tbody>
</table>

<p>
下表按照所属线程列出主要的类<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Game Thread</th>
<th scope="col" class="org-left">Rendering Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UWorld</td>
<td class="org-left">FScene</td>
</tr>

<tr>
<td class="org-left">UPrimitiveComponent</td>
<td class="org-left">FPrimitiveSceneProxy/FPrimitiveSceneInfo</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">FSceneView/FViewInfo</td>
</tr>

<tr>
<td class="org-left">ULocalPlayer</td>
<td class="org-left">FSceneViewState</td>
</tr>

<tr>
<td class="org-left">ULightComponent</td>
<td class="org-left">FLightSceneProxy/FLightSceneInfo</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgd066efb" class="outline-6">
<h6 id="orgd066efb">Material classes</h6>
<div class="outline-text-6" id="text-orgd066efb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Class</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">FMaterial</td>
<td class="org-left">渲染使用的材质的接口。提供对材质属性（例如，混合模式）的访问。包含一个着色器地图，渲染器用于获取独立的着色器</td>
</tr>

<tr>
<td class="org-left">FMaterialResource</td>
<td class="org-left">UMaterial 的 FMaterial 接口的实现</td>
</tr>

<tr>
<td class="org-left">FMaterialRenderProxy</td>
<td class="org-left">渲染线程的材质表示。提供对 FMaterial 接口以及每一个当前标量、矢量以及贴图参数的访问</td>
</tr>

<tr>
<td class="org-left">UMaterialInterface</td>
<td class="org-left">[抽象类] 材质功能的游戏线程接口。用于获取用于渲染的 FMaterialRenderProxy 和作为来源的 UMaterial</td>
</tr>

<tr>
<td class="org-left">UMaterial</td>
<td class="org-left">材质资源。创作为一个节点图。计算材质属性用于渲染，设置混合模式等等</td>
</tr>

<tr>
<td class="org-left">UMaterialInstance</td>
<td class="org-left">[抽象类] UMateiral 的实例。使用 UMaterial 中的节点图，但是提供不同的参数（标量，矢量，贴图，静态开关）。每个实例有一个父 UMaterialInterface。所以一个材质实例的父亲可以是一个 UMaterial 或另一个 UMaterialInstance。这将会创建一个链，最终指向一个 UMaterial</td>
</tr>

<tr>
<td class="org-left">UMaterialInstanceConstant</td>
<td class="org-left">UMaterialInstance 只能在 Editor 中被修改。可以提供 scalar vector texture 以及静态开关参数</td>
</tr>

<tr>
<td class="org-left">UMaterialInstanceDynamic</td>
<td class="org-left">UMaterialInstance 可以在运行时被修改。可以提供 scalar vector texture 参数。不能提供静态开关参数，并且不能是另一个 UMaterialInstance 的父亲</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgdd6ed1f" class="outline-6">
<h6 id="orgdd6ed1f">Primitive components and proxies</h6>
<div class="outline-text-6" id="text-orgdd6ed1f">
<p>
Primitive 组件是可见性和相关判定的基本单元。例如，遮挡和视景体剔除会在每一个元组件上发生。所以在设计一个系统时，思考将一个组件设计为多大很重要。每个组件都有一个边界，其会被各种操作所使用，例如，剔除、投影以及光照影响的判定。<br />
</p>

<p>
组件只有被注册了以后，在场景中才可见。游戏线程修改了一个组件的属性后，必须在该组件上调用 MarkRenderStateDirty()，才能将改变传播到渲染线程。<br />
</p>
</div>
</div>
<div id="outline-container-org4c9bbe9" class="outline-6">
<h6 id="org4c9bbe9">FPrimitiveSceneProxy and FPrimitiveSceneInfo</h6>
<div class="outline-text-6" id="text-org4c9bbe9">
<p>
FPrimitiveSceneProxy 是渲染线程版本的 UPrimitiveComponent。其用于依据不同类型的组件来子类化。它存在于 Engine 模块，并且在渲染阶段，会调用函数。<br />
</p>

<p>
FPrimitiveSceneInfo 是元组件的状态，对渲染模块是私有的。<br />
</p>
</div>
</div>
<div id="outline-container-org1890350" class="outline-6">
<h6 id="org1890350">Important FPrimitiveSceneProxy methods</h6>
<div class="outline-text-6" id="text-org1890350">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GetViewRelevance</td>
<td class="org-left">在帧的开始时，从 InitViews 中调用，返回一个填充后的 FPrimitiveViewRelevance</td>
</tr>

<tr>
<td class="org-left">DrawDynamicElements</td>
<td class="org-left">在该 Proxy 关联的任何阶段被调用，从而绘制该 Proxy。只有在该 Proxy 被指示为动态相关时才调用</td>
</tr>

<tr>
<td class="org-left">DrawStaticElements</td>
<td class="org-left">当该 Primitive 被附加到游戏线程时，调用该函数来提交 Proxy 对应的 StaticMesh 元素。只有在该 Proxy 被指示为静态相关时才调用</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge9e5cd7" class="outline-6">
<h6 id="orge9e5cd7">Scene Rendering order</h6>
<div class="outline-text-6" id="text-orge9e5cd7">
<p>
渲染器按照它希望组合到 RenderTarget 中的数据的顺序来处理场景。例如，Depth Pass 是唯一在 BasePass 之前渲染的 Pass，所以，分级的 Z-buffer 将被填充从而减低 Base pass 的渲染消耗。<br />
这个渲染顺序是由 Order Pass 函数静态定义的，该函数在 C++中被调用。<br />
</p>
</div>
</div>
<div id="outline-container-org6110470" class="outline-6">
<h6 id="org6110470">Relevance</h6>
<div class="outline-text-6" id="text-org6110470">
<p>
FPrimitiveViewRelevance 记录了什么效果（当然也包括什么 pass）对该 Primitive 有关联。一个 Primitive 可以包含多个元素，这些元素有不同的关联，所以 FPrimitiveViewRelevance 相当于所有元素关联关系的一个逻辑 OR。这意味着一个 Primitive 既可以包含不透明关联又可以包含半透明关联，或者动态和静态关联；它们不是互相排斥的。<br />
</p>

<p>
FPrimitiveViewRelevance 使用 bStaticRelevance 和 bDynamicRelevance 指示了一个 Primitive 是否需要使用动态和（或）静态渲染路径。<br />
</p>
</div>
</div>
<div id="outline-container-orgaacaeb1" class="outline-6">
<h6 id="orgaacaeb1">Drawing Policies</h6>
<div class="outline-text-6" id="text-orgaacaeb1">
<p>
绘制策略包含通过特定着色器渲染网格的逻辑。它们使用 FVertexFactory 接口来抽象网格类型，以及 FMaterial 接口来抽象材质细节。在底层，一个绘制策略负责一组网格材质着色器和一个顶点工厂，绑定顶点工厂的缓冲区到 RHI（渲染硬件接口），绑定网格材质着色器到 RHI，设置合适的着色器参数，然后触发 RHI 的绘制调用。<br />
</p>
</div>
</div>
<div id="outline-container-org032a3da" class="outline-6">
<h6 id="org032a3da">Drawing Policy methods</h6>
<div class="outline-text-6" id="text-org032a3da">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Constructor</td>
<td class="org-left">从给定的顶点工厂和材质着色器地图，查找合适的着色器，并存储这些引用</td>
</tr>

<tr>
<td class="org-left">CreateBoundShaderState</td>
<td class="org-left">为绘制策略创建一个绑定到 RHI 的着色器状态</td>
</tr>

<tr>
<td class="org-left">Matches/Compare</td>
<td class="org-left">提供方法来对静态绘制列表中的绘制策略进行排序。Matches 必须在 DrawShared 依赖的所有因素上进行比较</td>
</tr>

<tr>
<td class="org-left">DrawShared</td>
<td class="org-left">设置公共的 RHI 状态，这些状态对于从 Matches 函数返回 true 的绘制策略是一致的。例如，大多数绘制策略按照材质和顶点工厂排序，所以只依赖于材质的着色器参数可以被设置，顶点工厂特有的顶点缓冲区可以被绑定。如果可以代替 SetMeshRenderState 的话，应该总是在此处设置状态，因为在静态渲染路径中，DrawShared 调用次数比较少。</td>
</tr>

<tr>
<td class="org-left">SetMeshRenderState</td>
<td class="org-left">设置 Mesh 特有的 RHI 状态，或者任何没有在 DrawShared 中设置的状态。该函数比 DrawShared 调用次数多很多，所以性能比较敏感。</td>
</tr>

<tr>
<td class="org-left">DrawMesh</td>
<td class="org-left">真正地触发 RHI 的绘制调用</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgcbe7384" class="outline-5">
<h5 id="orgcbe7384">Rendering paths</h5>
<div class="outline-text-5" id="text-orgcbe7384">
<p>
UE4 提供了动态的渲染路径，它提供了更多的控制，但是进过该路径比较慢。UE4 也提供了静态渲染路径，它以尽可能接近渲染硬件接口层的效率缓存了场景遍历。这两种渲染路径的不同基本上都在高层次上，因为在底层，它们都使用了绘制策略。每一个绘制阶段（也就是每一个绘制策略）都需要支持处理两种渲染路径。<br />
</p>
</div>
<div id="outline-container-orga1096a8" class="outline-6">
<h6 id="orga1096a8">Dynamic rendering path</h6>
<div class="outline-text-6" id="text-orga1096a8">
<p>
动态渲染路径使用 TDynamicPrimitiveDrawer 并且在每一个 PrimitiveSceneProxy 上调用 DrawDynamicElements 来进行渲染。需要使用动态渲染路径进行渲染的基元集合是通过 FViewInfo::VisibleDynamicPrimitives 来跟踪的。每一个渲染阶段都需要在该集合上进行迭代，在每个基元代理上调用 DrawDynamicElements。基元代理的 DrawDynamicElements 需要组装它所需要的足够多的 FMeshElements，然后使用 DrawRichMesh 或 TDynamicPrimitiveDrawer::DrawMesh 将它们提交。最后，创建一个新的临时的绘制策略，来调用 CreateBoundShaderState,DrawShared,SetMeshRenderState,以及最终调用 DrawMesh。<br />
动态渲染路径提供了很多的灵活性，因为每个代理在 DrawDynamicElements 中都有一个回调函数，在该回调函数中可以执行组件类型特有的逻辑。动态渲染路径有很小的插入开销，但是遍历消耗很高，因为它没有状态排序，也没有任何缓存。<br />
</p>
</div>
</div>
<div id="outline-container-org3204f80" class="outline-6">
<h6 id="org3204f80">Static rendering path</h6>
<div class="outline-text-6" id="text-org3204f80">
<p>
使用静态绘制列表来实现静态渲染路径。当网格附加到场景时，会将它们插入到静态绘制列表。在插入期间，会调用代理上的 DrawStaticElements 函数来收集 FStaticMeshElements。随后，随 CreateBoundShderState 的结果创建并存储一个绘制策略。这个新创建的绘制策略会被按照它的 Compare 和 Matches 函数进行排序并且插入到绘制列表的合适位置（相关代码在 TStaticMeshDrawList::AddMesh）。在 InitViews 中，一个位数组包含静态绘制列表的可见性数据，该位数组会被初始化并传递给 TStaticMeshDrawList::DrawVisible，此处时绘制列表正真被绘制的地方。对于所有的互相匹配的绘制策略 DrawShared 只被调用一次，而 SetMeshRenderState 和 DrawMesh 会被每一个 FStaticMeshElement 调用一次（相关代码在 TStaticMeshDrawList::DrawElement）。<br />
</p>

<p>
静态渲染路径会将很多工作移到附加时间。这很显著地加速了渲染中场景的遍历。静态绘制列表渲染在渲染线程要快 3 倍多，这就允许在场景中放置更多的静态网格。因为静态绘制列表在附加时间会缓存数据，它们只能缓存视图独立的状态。很少重新连接但是经常需要渲染的基元是静态绘制列表很好的候选人。<br />
</p>

<p>
静态绘制路径会暴露 bug，因为它对于一系列状态只调用一次 DrawShared。这些 bug 很难被定位到，因为它们依赖于渲染顺序和场景中网格联接的顺序。特定的渲染模式，例如，只有光照，无光照，等等会强制所有的基元都使用动态渲染路径，所以如果当强制使用动态渲染路径时，一个 bug 就不见了，那么很有可能就是因为一个绘制策略的 DrawShared 或 Matches 函数实现不正确。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2a25542" class="outline-5">
<h5 id="org2a25542">High level Rendering order</h5>
<div class="outline-text-5" id="text-org2a25542">
<p>
下面是从 FDeferredShadingSceneRenderer::Render 开始渲染一帧的控制流描述。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operation</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GSceneRenderTargets.Allocate</td>
<td class="org-left">如果需要，就重新分配全局场景渲染目标，使其对于当前视图来说足够大</td>
</tr>

<tr>
<td class="org-left">InitViews</td>
<td class="org-left">通过各种剔除方法来初始化图元可见性，设置这帧可见的动态阴影，对于整个场景阴影和预阴影按需求交叉阴影锥体和场景</td>
</tr>

<tr>
<td class="org-left">PrePass/Depth only pass</td>
<td class="org-left">RenderPrePass/FDepthDrawingPolicy.只输出深度值到深度缓冲区中。这个阶段可以在多个模式下起作用：disabled，occlusion only,complete depths,基于激活的特性需要什么。通常该阶段的目的是初始化 Hierarchical Z 来减少 Base 阶段的着色消耗，尤其是昂贵的片段着色器</td>
</tr>

<tr>
<td class="org-left">Base pass</td>
<td class="org-left">RenderBasePass/TBasePassDrawingPolicy.渲染不透明和遮罩材质，输出材质属性到 GBuffer.Lightmap 贡献和天空光也会在此处计算并放入场景颜色</td>
</tr>

<tr>
<td class="org-left">Issue Occlusion Queries/BeginOcclusionTests</td>
<td class="org-left">开始潜在的遮挡查询，这将会在下一帧中的 InitViews 中被使用。这是通过渲染围绕被查询物体的边界盒来完成的，有时候将边界盒分组，合在一起来减少 draw call。</td>
</tr>

<tr>
<td class="org-left">Lighting</td>
<td class="org-left">混合使用标准的延迟和平铺延迟着色，每个光照的阴影贴图被渲染，并且光照贡献会被累计到场景颜色中。光照也会累积到半透明光照体中。</td>
</tr>

<tr>
<td class="org-left">Fog</td>
<td class="org-left">雾和空气是基于每像素在延迟阶段为不透明表面进行计算的。</td>
</tr>

<tr>
<td class="org-left">Translucency</td>
<td class="org-left">半透明会被累积到一个离屏渲染目标，在该渲染目标中雾被应用于每个顶点，所以其可以集成到场景中。光照半透明在一个单独阶段计算最终光照来保证混合正确。</td>
</tr>

<tr>
<td class="org-left">Post Processing</td>
<td class="org-left">使用 GBuffers 应用各种后期处理效果。半透明被组合到场景中。</td>
</tr>
</tbody>
</table>

<p>
这是一个相当简单的高层视图。具体细节，可以查阅相关代码或者查看 profilegpu 的日志输出。<br />
</p>
</div>
</div>
<div id="outline-container-orgf9fc846" class="outline-5">
<h5 id="orgf9fc846">Render Hardware Interface</h5>
<div class="outline-text-5" id="text-orgf9fc846">
<p>
RHI 是平台相关的图形 API 之上的一个薄层。UE4 中的 RHI 抽象层尽可能的底层，意图可以通过平台无关的代码实现大多数特性，并且在所有支持该特性的平台上可以正常工作。<br />
</p>

<p>
特性集合被量化到 ERHIFeatureLevel 中来保持较低的复杂度。如果一个平台不能支持一个特性等级要求的所有特性，就必须将该平台的特性等级减低，直到其可以支持所有特性。<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Feature Level</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SM5</td>
<td class="org-left">通常对应于 D3D11 Shader Model 5,除去 OpenGL4.3 中只可以使用 16 个贴图的限制。支持细分着色器，计算着色器以及立方体贴图数组。支持延迟渲染路径。</td>
</tr>

<tr>
<td class="org-left">SM4</td>
<td class="org-left">对应于 D3D11 Shader Model 4,基本和 SM5 相同，除去不支持细分着色器，计算着色器以及立方体贴图数组。支持延迟渲染路径。不支持人眼适应，因为其使用了计算着色器。</td>
</tr>

<tr>
<td class="org-left">ES2</td>
<td class="org-left">对应于大多数 OpenGL ES2 移动设备所支持的特性。使用一个消减的正向渲染路径。</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org8f470ca" class="outline-6">
<h6 id="org8f470ca">Rendering state grouping</h6>
<div class="outline-text-6" id="text-org8f470ca">
<p>
渲染状态按照它所影响的管线的部位不同来分组。例如，RHISetDepthState 集合包含所有对深度缓冲区有影响的状态。<br />
</p>
</div>
</div>
<div id="outline-container-orgdc02323" class="outline-6">
<h6 id="orgdc02323">Rendering state defaults</h6>
<div class="outline-text-6" id="text-orgdc02323">
<p>
因为有很多渲染状态，所以每次绘制时去设置所有这些状态很不实际。UE4 中有一个隐式的状态集合，它们的值被设置为默认值（所以当它们的值被修改后，必须恢复为默认值）。没有隐式默认值的状态集合有：<br />
</p>
<ul class="org-ul">
<li>RHISetRenderTargets<br /></li>
<li>RHISetBoundShaderState<br /></li>
<li>RHISetDepthState<br /></li>
<li>RHISetBlendState<br /></li>
<li>RHISetRasterizerState<br /></li>
<li>由 RHISetBoundShaderState 设置的着色器的所有依赖<br /></li>
</ul>

<p>
所有其他状态都被假定使用其默认值(例如 默认的模板状态是通过 RHISetStencilState( TStaticStencilState&lt;&gt;::GetRHI()) 来设置的 )。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf08885c" class="outline-4">
<h4 id="orgf08885c">Threaded Rendering</h4>
<div class="outline-text-4" id="text-orgf08885c">
</div>
<div id="outline-container-org328a4bc" class="outline-5">
<h5 id="org328a4bc">Rendering thread</h5>
<div class="outline-text-5" id="text-org328a4bc">
<p>
在 UE4 中，整个渲染操作都在渲染线程中，它要比游戏线程滞后 1 到 2 帧。<br />
当处理渲染事物时，你必须很小心地考虑每一次内存读写，以确保线程安全，并且行为确定。当函数行为依赖于两个线程不同的执行速度时，这被称为竞态条件。避免竞态条件非常重要，因为它们很难再现，并且可能依赖于机器、平台、调试器或者配置。这类 bug 很难被调试，修复这类 bug 所花费的时间要比容易复现的 bug 多 10 倍。<br />
</p>
</div>
<div id="outline-container-org35f2916" class="outline-6">
<h6 id="org35f2916">Development approach</h6>
<div class="outline-text-6" id="text-org35f2916">
<p>
无法耗尽一切测试来查找竞态条件。认识到无法通过猜测和检查或者消极的 bug 修复来创建可靠的多线程代码。最好的方式是完全理解游戏线程和渲染线程的交互，并使用机制来保证确定性。你应该能够解释事件的顺序，这样就会使每个交互都是确定的，否则你很可能创建了竞态条件。<br />
</p>
</div>
</div>
<div id="outline-container-org7343f88" class="outline-6">
<h6 id="org7343f88">Thread specific data structures</h6>
<div class="outline-text-6" id="text-org7343f88">
<p>
因此，一个很好的想法是将数据分开到不同的结构体中，它们属于不同的线程，这样哪个线程可以修改哪些数据就很明显了。对于函数也是这样的。最好是只在同一个线程里面调用一个函数，否则将会变得很复杂。UE4 的大部分都是按照这种方式组织的,例如，UPrimitiveComponent 是游戏线程中任何事物的基类，它可以被渲染，可以投射阴影，有自己的可见性状态，等等。渲染线程永远都不能直接修改 UPrimitiveComponnet 的内存，因为游戏线程可能在任意时候去写它的成员。渲染线程有自己的类 FPrimitiveSceneProxy 来表示相同的功能.在 FPrimitiveSceneProxy 被创建和注册之后，游戏线程永远不能修改其成员的内存。UActorComponnet::RegisterComponent 添加一个组件到场景并创建一个 FPrimitiveSceneProxy 对象，使其对渲染器可见。一旦该组件被注册，如果它是可见的，将为每个所需的 pass 调用 FPrimitiveSceneProxy::DrawDynamicElements。<br />
</p>
</div>
</div>
<div id="outline-container-orgf0c15ae" class="outline-6">
<h6 id="orgf0c15ae">Performance considerations</h6>
<div class="outline-text-6" id="text-orgf0c15ae">
<p>
游戏线程会在每个 Tick() 之后阻塞，直到渲染线程只落后一帧或两帧。因此，在游戏期间，渲染线程落后很多，将主线程阻塞直到渲染线程完全刚上是无法接受的。在加载阶段或者垃圾回收个别物体时，阻塞也是一个馊主意，因此 UE4 支持异步流化关卡。对于各种操作有很多异步机制来避免阻塞。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga25131f" class="outline-5">
<h5 id="orga25131f">Inter-thread communication</h5>
<div class="outline-text-5" id="text-orga25131f">
</div>
<div id="outline-container-orgd2ed48b" class="outline-6">
<h6 id="orgd2ed48b">Asynchronous</h6>
<div class="outline-text-6" id="text-orgd2ed48b">
<p>
两个线程之间主要通过 ENQUEUE_UNIQUE_RENDER_COMMAND_XXXPARAMETER 宏来进行通讯。这个宏会创建一个局部类，该类包含一个 Execute 虚函数，其中包含你输入到宏中的代码。游戏线程将命令插入到渲染命令队列，渲染线程在执行时会调用 Execute 函数。<br />
FRenderCommandFence 提供了一种方便的方式在游戏线程中追踪渲染线程的进度。游戏线程调用 FRenderCommandFence::BeginFence 来开启栅栏，游戏线程可以调用 FRenderCommandFence::Wait 来阻塞自己，直到渲染线程处理该栅栏，或者可以通过检查 GetNumPendingFences 来轮询渲染线程的进度。当 GetNumPendingFences 返回 0 时，表示渲染线程已经处理该栅栏。<br />
</p>
</div>
</div>
<div id="outline-container-orgd791fae" class="outline-6">
<h6 id="orgd791fae">Blocking</h6>
<div class="outline-text-6" id="text-orgd791fae">
<p>
FlushRenderingCommands 是标准的方法用于阻塞游戏线程直到渲染线程赶上。这对于离线的操作（编辑器的操作）非常有用，这些操作会修改被渲染线程访问的内存。<br />
</p>
</div>
</div>
<div id="outline-container-org1eebd7f" class="outline-6">
<h6 id="org1eebd7f">Rendering resources</h6>
<div class="outline-text-6" id="text-org1eebd7f">
<p>
FRenderResource 提供了基础渲染资源接口，并且为初始化和释放提供了钩子。任何继承自 FRenderResource 的类（FVertexBuffer，FIndexBuffer 等等）需要在渲染使用之前被初始化，需要在删除之前被释放。FRenderResource::InitResource 只能在渲染线程中被调用，在游戏线程可以调用一个帮助函数（BeginInitResource）来入队一个渲染命令来调用 FRenderResource::InitResource。RHI 函数只能在渲染线程中调用（除了一些创建设备、视口等的函数）。<br />
</p>
</div>
</div>
<div id="outline-container-orgf8d77fa" class="outline-6">
<h6 id="orgf8d77fa">UObjects and Garbage Collection</h6>
<div class="outline-text-6" id="text-orgf8d77fa">
<p>
垃圾回收发生在游戏线程并且在 UObjects 上进行操作。游戏线程可能删除一个 UObject，同时渲染线程在处理一个命令，而该命令引用了被删除的 UObject。因此，渲染线程应该永远不解引用一个 UObject 指针，除非有机制可以保证 UObject 不被删除直到渲染线程不再引用它。UPrimitiveComponent 就是一个例子，它使用一个 FRenderCommandFence 调用 DetachFence 来防止 GC 在渲染线程处理该分离命令之前删除 UObject。<br />
</p>
</div>
</div>
<div id="outline-container-org6639604" class="outline-6">
<h6 id="org6639604">Game thread FRenderResource handling</h6>
<div class="outline-text-6" id="text-org6639604">
<p>
需要考虑游戏线程、渲染线程资源交互的两种共同的情形，静态资源(在加载期间或者编辑器中修改，例如索引缓冲区)和动态资源（需要使用游戏线程模拟的最近结果在每一帧中进行更新）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd8738fa"></a>Static resources<br />
<div class="outline-text-7" id="text-orgd8738fa">
<p>
下面是在 UE4 中，静态资源的交互如何被处理，以 USkeletalMesh 为例来说明：<br />
</p>
<ul class="org-ul">
<li>USkeletalMesh::PostLoad<br /></li>
</ul>
</div>
</li>
<li><a id="org9fc0069"></a>Dynamic resources<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org010c090" class="outline-5">
<h5 id="org010c090">Updating state vs Traversing the scene for rendering</h5>
</div>
</div>
<div id="outline-container-org38697ad" class="outline-4">
<h4 id="org38697ad">Shader Development</h4>
<div class="outline-text-4" id="text-org38697ad">
</div>
<div id="outline-container-orgdd61a70" class="outline-5">
<h5 id="orgdd61a70">AsyncCompute</h5>
</div>
<div id="outline-container-org4d55b95" class="outline-5">
<h5 id="org4d55b95">HLSL Cross Compiler</h5>
</div>
</div>
<div id="outline-container-org301b18a" class="outline-4">
<h4 id="org301b18a">Shaders In Plugins</h4>
<div class="outline-text-4" id="text-org301b18a">
</div>
<div id="outline-container-orgf200f89" class="outline-5">
<h5 id="orgf200f89">Overview Shader in Plugins</h5>
</div>
<div id="outline-container-orgdfb92d5" class="outline-5">
<h5 id="orgdfb92d5">Create a New Global Shader as a Plugin</h5>
</div>
</div>
<div id="outline-container-org0f4f7ad" class="outline-4">
<h4 id="org0f4f7ad">FShaderCache</h4>
<div class="outline-text-4" id="text-org0f4f7ad">
</div>
<div id="outline-container-org42ee107" class="outline-5">
<h5 id="org42ee107">Overview</h5>
<div class="outline-text-5" id="text-org42ee107">
<p>
FShaderCache 提供了各种机制来减低游戏中 shader 的卡顿。它支持 OpenGLDrv 和 MetalRHI 渲染硬件接口，并且在 Mac Linux 以及 Windows 平台都可以工作。<br />
</p>

<p>
下面是用于开启和关闭 FShaderCache 功能的一系列控制台命令。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Console Command</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">r.UseShaderCaching</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.UseShaderDrawLog</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.UseShaderPredraw</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.PredrawBatchTime</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.UseShaderBinaryCache</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.UseAsyncShaderPrecompilation</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.TargetPrecompileFrameTime</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.AccelPredrawBatchTime</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.AccelTargetPrecompileFrameTime</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r.InitialShaderLoadTime</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org6538bed" class="outline-5">
<h5 id="org6538bed">Use</h5>
<div class="outline-text-5" id="text-org6538bed">
<p>
在开发机器上开启 r.UseShaderCaching 和 r.UseShaderDrawLog，缓存就可以被填充。开启 r.UseShaderCaching 和 r.UseShaderPredraw,用户就可以消耗缓存中内容。r.UseShaderDrawLog 会增加显著的固定的负荷，所以应该避免在正式产品中开启它。<br />
</p>
</div>
<div id="outline-container-orgc160ad9" class="outline-6">
<h6 id="orgc160ad9">Integration Steps</h6>
<div class="outline-text-6" id="text-orgc160ad9">
<p>
尽管有一系列控制命令可以用来减少卡顿，但是依然有一个推荐的开启选项的优先级顺序来最大化性能同时避免额外的工作。<br />
</p>
<ol class="org-ol">
<li>在项目配置中为所有用户开启 r.UseShaderCaching 和 r.UseShaderPredraw<br /></li>
<li>如果可以，只为内部构建开启 r.UseShaderDrawLog，并确保着色器绘制状态在最终 QA 阶段会被记录下来。如果不可行的话（例如，游戏非常大，或者是游戏为流媒体形式的），就为所有用户开启该选项。<br /></li>
</ol>

<p>
测试上面的设置是否可以将卡顿减到可接受等级，进一步的优化需要更多的工作并且有很明显的副作用。<br />
</p>
<ul class="org-ul">
<li>TODO<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5f8f0f9" class="outline-5">
<h5 id="org5f8f0f9">Handling Updates/Invalidation</h5>
<div class="outline-text-5" id="text-org5f8f0f9">
<p>
当需要更新缓存并且可写缓存不可用时，游戏应该指定一个新的 GameVersion。在初始化 RHI 之前调用 FShaderCache::SetGameVersion。这将会导致生成新的缓存，前一个版本的缓存会被忽略。此时你无法继承前一版本的缓存条目。<br />
</p>
</div>
</div>
<div id="outline-container-orgf65809f" class="outline-5">
<h5 id="orgf65809f">Region/Stream Batching</h5>
<div class="outline-text-5" id="text-orgf65809f">
<p>
对于流式游戏，或者缓存变得很大的游戏，可以调用 FShaderCache::SetStreamingKey 为游戏区域或流式关卡分配唯一值(Steaming Key)。记录的绘制状态将被链接到激活的 Streaming Key。这就可以限制只对激活的 Streaming Key 需要的绘制状态进行预绘制。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org6c90845" class="outline-4">
<h4 id="org6c90845">参考资料</h4>
<div class="outline-text-4" id="text-org6c90845">
<ul class="org-ul">
<li>图形编程的官网文档 en <a href="https://docs.unrealengine.com/latest/INT/Programming/Rendering/index.html">https://docs.unrealengine.com/latest/INT/Programming/Rendering/index.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfe2738d" class="outline-3">
<h3 id="orgfe2738d">Slate UI Framework</h3>
</div>
<div id="outline-container-org6aa1831" class="outline-3">
<h3 id="org6aa1831">Programming Subsystems</h3>
</div>
<div id="outline-container-org73819a5" class="outline-3">
<h3 id="org73819a5">Gameplay Tags</h3>
</div>
<div id="outline-container-org084fd2a" class="outline-3">
<h3 id="org084fd2a">Unreal Projects and Gameplay</h3>
</div>
<div id="outline-container-orgc126e27" class="outline-3">
<h3 id="orgc126e27">Spawning/Destroying an Actor Overview</h3>
</div>
<div id="outline-container-orga3baa6e" class="outline-3">
<h3 id="orga3baa6e">OnlineSubsystem</h3>
</div>
</div>
<div id="outline-container-org1bcdc8c" class="outline-2">
<h2 id="org1bcdc8c">Samples and Tutorials</h2>
<div class="outline-text-2" id="text-org1bcdc8c">
</div>
<div id="outline-container-org8572c06" class="outline-3">
<h3 id="org8572c06">Templates</h3>
</div>
<div id="outline-container-org851b40b" class="outline-3">
<h3 id="org851b40b">Learning Resource Projects</h3>
<div class="outline-text-3" id="text-org851b40b">
</div>
<div id="outline-container-orge905daa" class="outline-4">
<h4 id="orge905daa">Gameplay Concept Examples</h4>
</div>
<div id="outline-container-orgc975b44" class="outline-4">
<h4 id="orgc975b44">Example Game Projects</h4>
</div>
<div id="outline-container-orgd12b2ad" class="outline-4">
<h4 id="orgd12b2ad">Engine Feature Examples</h4>
<div class="outline-text-4" id="text-orgd12b2ad">
</div>
<div id="outline-container-org01acc1a" class="outline-5">
<h5 id="org01acc1a">Photorealistic Character</h5>
<div class="outline-text-5" id="text-org01acc1a">
</div>
<div id="outline-container-orge991161" class="outline-6">
<h6 id="orge991161">Skin Shading</h6>
</div>
<div id="outline-container-orgcf4e991" class="outline-6">
<h6 id="orgcf4e991">Hair Shading</h6>
</div>
<div id="outline-container-org135d37c" class="outline-6">
<h6 id="org135d37c">Eye Shading</h6>
</div>
</div>
</div>
</div>
<div id="outline-container-orge29fa05" class="outline-3">
<h3 id="orge29fa05">Community Sample Documentation</h3>
</div>
</div>
<div id="outline-container-orgc149846" class="outline-2">
<h2 id="orgc149846">Sharing and Releasing Projects</h2>
<div class="outline-text-2" id="text-orgc149846">
</div>
<div id="outline-container-org074e722" class="outline-3">
<h3 id="org074e722">Mobile</h3>
<div class="outline-text-3" id="text-org074e722">
</div>
<div id="outline-container-org0c3c426" class="outline-4">
<h4 id="org0c3c426">Mobile Game Development</h4>
</div>
<div id="outline-container-orgfbbd2de" class="outline-4">
<h4 id="orgfbbd2de">Android Game Development</h4>
<div class="outline-text-4" id="text-orgfbbd2de">
</div>
<div id="outline-container-org061f215" class="outline-5">
<h5 id="org061f215">项目设置</h5>
<div class="outline-text-5" id="text-org061f215">
</div>
<div id="outline-container-org0c55469" class="outline-6">
<h6 id="org0c55469">Package game data inside .apk</h6>
<div class="outline-text-6" id="text-org0c55469">
<p>
该选项控制是否将游戏数据内置到.apk 中<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f0ec46" class="outline-4">
<h4 id="org3f0ec46">iOS Game Development</h4>
</div>
</div>
<div id="outline-container-orge16e243" class="outline-3">
<h3 id="orge16e243">Virtual Reality</h3>
</div>
<div id="outline-container-org69120ba" class="outline-3">
<h3 id="org69120ba">Desktop</h3>
</div>
<div id="outline-container-org4193edd" class="outline-3">
<h3 id="org4193edd">Platform Tools</h3>
</div>
</div>

<div id="outline-container-org13f71de" class="outline-2">
<h2 id="org13f71de">Tutorial</h2>
<div class="outline-text-2" id="text-org13f71de">
</div>
<div id="outline-container-org10576dc" class="outline-3">
<h3 id="org10576dc">UnrealEngine 4x Example</h3>
<div class="outline-text-3" id="text-org10576dc">
</div>
<div id="outline-container-orgd2044f3" class="outline-4">
<h4 id="orgd2044f3">相关资源下载</h4>
<div class="outline-text-4" id="text-orgd2044f3">
<ul class="org-ul">
<li><a href="https://www.packtpub.com/game-development/unreal-engine-4x-example">https://www.packtpub.com/game-development/unreal-engine-4x-example</a><br /></li>
<li><a href="https://drive.google.com/drive/folders/0ByC3Ab7YyAMsd1ZGaWxJSlo1Z1U">https://drive.google.com/drive/folders/0ByC3Ab7YyAMsd1ZGaWxJSlo1Z1U</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org91a98f6" class="outline-3">
<h3 id="org91a98f6">Content Examples</h3>
<div class="outline-text-3" id="text-org91a98f6">
</div>
<div id="outline-container-org9837e6b" class="outline-4">
<h4 id="org9837e6b">参考资料</h4>
<div class="outline-text-4" id="text-org9837e6b">
<ul class="org-ul">
<li><a href="https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/index.html">https://docs.unrealengine.com/latest/INT/Resources/ContentExamples/index.html</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd4d0550" class="outline-3">
<h3 id="orgd4d0550">2D Platformer with UE4</h3>
<div class="outline-text-3" id="text-orgd4d0550">
<ul class="org-ul">
<li>目录 <a href="https://nerd-time.com/tag/platformer/">https://nerd-time.com/tag/platformer/</a><br /></li>
<li>Part1 <a href="https://nerd-time.com/ue4-2d-platformer-paper2d/">https://nerd-time.com/ue4-2d-platformer-paper2d/</a><br /></li>
<li>Part2 <a href="https://nerd-time.com/ue4-2d-platformer-player-controller/">https://nerd-time.com/ue4-2d-platformer-player-controller/</a><br /></li>
<li>Part3 <a href="https://nerd-time.com/ue4-2d-platformer-bp-component/">https://nerd-time.com/ue4-2d-platformer-bp-component/</a><br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org106bb2a" class="outline-2">
<h2 id="org106bb2a">开发经验积累</h2>
<div class="outline-text-2" id="text-org106bb2a">
</div>
<div id="outline-container-orgb0feca9" class="outline-3">
<h3 id="orgb0feca9">Blueprint</h3>
<div class="outline-text-3" id="text-orgb0feca9">
</div>
<div id="outline-container-org1993796" class="outline-4">
<h4 id="org1993796">Architecture</h4>
<div class="outline-text-4" id="text-org1993796">
</div>
<div id="outline-container-orga51b5ce" class="outline-5">
<h5 id="orga51b5ce">如何使用 blueprint 写公用的工具类</h5>
<div class="outline-text-5" id="text-orga51b5ce">
</div>
<div id="outline-container-orgee22683" class="outline-6">
<h6 id="orgee22683">方案一 使用 MacroLib 来定义公用的 Macro</h6>
<div class="outline-text-6" id="text-orgee22683">
<ul class="org-ul">
<li>优点 1  可以利用 Macro 输出参数类型 Exec 实现遍历<br /></li>
<li>优点 2  效率比函数调用高，Macro 代码会在调用处展开<br /></li>
<li>缺点 1  调试的时候不能查看变量值<br /></li>
<li>缺点 2  无法获得 WorldContext、GameInstance 对象，所以在 Macro 中实现方法是有限制的。<br /></li>
<li>缺点 3  Macro 中无法调用 Function Lib，所以对于需要在 Macro 中调用的函数，只能也使用 Macro 实现。<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgf41f2d3" class="outline-6">
<h6 id="orgf41f2d3">方案二 使用 Function Lib 来实现公用的 Function</h6>
<div class="outline-text-6" id="text-orgf41f2d3">
<ul class="org-ul">
<li>优点 1 性能影响可控<br /></li>
<li>优点 2 可以获得 WorldContext、GameInstance 对象，所以在 FunctionLib 中实现方法时没有限制。<br /></li>
<li>缺点 1 无法实现遍历<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga46b9c2" class="outline-5">
<h5 id="orga46b9c2">如何实现单例</h5>
<div class="outline-text-5" id="text-orga46b9c2">
<p>
通过 GameInstance 来实现单例。<br />
</p>
<ul class="org-ul">
<li>以 GameInstance 类为基类创建蓝图 BP_GInstance (名字可以任意，此处使用 BP_GInstance)<br /></li>
<li>在 Project Setting 中设置 Game Instance Class 为 BP_GInstance<br /></li>
<li>在蓝图中 通过 GetGameInstance 获取 GameInstance 对象，然后通过 Cast To BP_GInstance 就可以获得 BP_GInstance 类型的对象了<br /></li>
</ul>
</div>
<div id="outline-container-org9e035b7" class="outline-6">
<h6 id="org9e035b7">Tips</h6>
<div class="outline-text-6" id="text-org9e035b7">
<p>
Macro 中无法获得 WorldContext 对象，也无法调用 GetGameInstance 方法。因此在 Macro 中无法获得 GameInstance 对象，也就无法将 GameInstance 的成员函数封装为 Macro。<br />
Function Lib 中可以获得 WorldContext 对象，也可以调用 GetGameInstance 方法。因此可以在 Function Lib 中获得 GameInstance 对象，从而将 GameInstance 的成员函数封装为 FunctionLib 函数。<br />
</p>

<p>
综合来说，对于需要传入 Delegate 的情况只能使用 Macro，需要在 Macro 中调用的函数也只能使用 Macro 来实现，因为 Macro 中无法调用 Func Lib 中的函数，除此以外的其他函数都应该采用 FunctionLib 来实现.<br />
</p>

<p>
补充说明：Macro 中主要是无法调用 GetGameInstance 方法，WorldContext 输入参数是可以省略的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2905dce" class="outline-5">
<h5 id="org2905dce">Event Dispatcher</h5>
<div class="outline-text-5" id="text-org2905dce">
</div>
<div id="outline-container-org2367d80" class="outline-6">
<h6 id="org2367d80">EventDispatcher 使用方法</h6>
<div class="outline-text-6" id="text-org2367d80">
<ul class="org-ul">
<li>EventDispatcher 使用方法 <a href="https://www.youtube.com/watch?v=9uweDnKGbG8">https://www.youtube.com/watch?v=9uweDnKGbG8</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org15f03a2" class="outline-6">
<h6 id="org15f03a2">EventManager 实现</h6>
<div class="outline-text-6" id="text-org15f03a2">
<ul class="org-ul">
<li>Step1 定义一个单例 BP_GEventMgr (父类选择 Object)<br /></li>
<li>Step2 所有消息都在 BP_GEventMgr 的 Event Dispatchers 中进行定义  （例如：BP_GEventMgr 中定义的 UI_CharBeautyParamUpdate）<br /></li>
<li>Step3.1 在处理消息的地方绑定消息处理函数 (例如：BP_Char_CharCtrl 的 Event BeginPlay 中调用 BP_GEventMgr 的 Bind Event to UI_CharBeautyParamUpdate 方法)<br /></li>
<li>Step3.2 在触发消息的地方调用 BP_GEventMgr 的消息触发函数 (例如：BP_UI_CharBeautySubItem 中调用 Call UI_CharBeautyParamUpdate)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb0de781" class="outline-5">
<h5 id="orgb0de781">Blueprint 中实例创建</h5>
<div class="outline-text-5" id="text-orgb0de781">
</div>
<div id="outline-container-org0fd4273" class="outline-6">
<h6 id="org0fd4273">Game Instance</h6>
<div class="outline-text-6" id="text-org0fd4273">
<p>
// Game Instance 是全局唯一的 切换 Level 状态依然不变，引擎会自动创建 Game Instance<br />
</p>
</div>
</div>
<div id="outline-container-org37f35ac" class="outline-6">
<h6 id="org37f35ac">Spawn Actor</h6>
<div class="outline-text-6" id="text-org37f35ac">
<p>
// SpawnActor 可以创建 Actor 类的实例<br />
</p>
</div>
</div>
<div id="outline-container-org17c2e3f" class="outline-6">
<h6 id="org17c2e3f">Construct Object from class</h6>
<div class="outline-text-6" id="text-org17c2e3f">
<p>
// Construct Object from class 可以创建 Object 类的实例<br />
需要注意的是该函数的 参数的意义：<br />
</p>
<ul class="org-ul">
<li>Outer 参数是新创建的 Object 的持有者<br /></li>
<li>Return Value 参数是创建的 Object<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3f87001" class="outline-5">
<h5 id="org3f87001">Blueprint 代码规范</h5>
<div class="outline-text-5" id="text-org3f87001">
</div>
<div id="outline-container-orgb66d722" class="outline-6">
<h6 id="orgb66d722">Macro 命名规则</h6>
<div class="outline-text-6" id="text-orgb66d722">
<p>
Macro_XXType_MacroFuncName  例如: Macro_TOOL_Log<br />
因为 Macro 在函数中展开，所以要明确标识 Macro<br />
</p>
</div>
</div>
<div id="outline-container-org3857a08" class="outline-6">
<h6 id="org3857a08">Func 命名规则</h6>
<div class="outline-text-6" id="text-org3857a08">
<p>
XXType_FuncName  例如: TOOL_Log<br />
因为 Func 容易重名，所以需要通过 Type 来区分名称<br />
</p>
</div>
</div>
<div id="outline-container-org98489fb" class="outline-6">
<h6 id="org98489fb">UI 命名规则</h6>
<div class="outline-text-6" id="text-org98489fb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命名规则</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">XXXPanel</td>
<td class="org-left">表示一级大面板</td>
</tr>

<tr>
<td class="org-left">XXXSubPanel</td>
<td class="org-left">表示 1 级小面板</td>
</tr>

<tr>
<td class="org-left">XXXL2SubPanel</td>
<td class="org-left">表示 2 级小面板</td>
</tr>

<tr>
<td class="org-left">XXXItem</td>
<td class="org-left">表示一级 List Item</td>
</tr>

<tr>
<td class="org-left">XXXSubItem</td>
<td class="org-left">表示 Item 中的 1 级子面板</td>
</tr>

<tr>
<td class="org-left">XXXL2SubItem</td>
<td class="org-left">表示 Item 中的 2 级子面板</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-orge895f64" class="outline-4">
<h4 id="orge895f64">Gameplay</h4>
<div class="outline-text-4" id="text-orge895f64">
</div>
<div id="outline-container-orgeb0e671" class="outline-5">
<h5 id="orgeb0e671">如何设置角色出生点位置</h5>
<div class="outline-text-5" id="text-orgeb0e671">
<p>
在场景中添加一个 Player Start<br />
<a href="http://aigo.iteye.com/blog/2265400">http://aigo.iteye.com/blog/2265400</a><br />
</p>
</div>
</div>
<div id="outline-container-org01b0395" class="outline-5">
<h5 id="org01b0395">如何将操纵的角色默认加入场景</h5>
<div class="outline-text-5" id="text-org01b0395">
<p>
将操纵的角色拖入到场景中，设置角色的 Pawn/AutoPossessPlayer 属性为 Player 0<br />
</p>
</div>
</div>
<div id="outline-container-org44fc776" class="outline-5">
<h5 id="org44fc776">如何方便地设置 Player Start 朝向某个物体？</h5>
<div class="outline-text-5" id="text-org44fc776">
<ul class="org-ul">
<li>Step 1 移动摄像机面对该物体<br /></li>
<li>Step 2 在 World Outliner 中右键点击 Player Start 对象，选择 Snap to View<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf56587b" class="outline-5">
<h5 id="orgf56587b">如何修改默认生成摄像机的速度？</h5>
<div class="outline-text-5" id="text-orgf56587b">
<ul class="org-ul">
<li>Create Default Pawn Actor Blueprint<br /></li>
<li>Open the blueprint<br /></li>
<li>Selected MovementComponent In Components<br /></li>
<li>Change Properties In Detail (Floating Pawn Movement Group)<br />
<ul class="org-ul">
<li>Max Speed<br /></li>
<li>Acceleration<br /></li>
<li>Deceleration<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcaa6a96" class="outline-4">
<h4 id="orgcaa6a96">Utility</h4>
<div class="outline-text-4" id="text-orgcaa6a96">
</div>
<div id="outline-container-org4812554" class="outline-5">
<h5 id="org4812554">如何在 Macro Lib/ Func Lib 中定义大小可变的数组？</h5>
<div class="outline-text-5" id="text-org4812554">
<ul class="org-ul">
<li>通过 MakeArray 创建的数组为大小固定的数组，在该数组上调用 Add 后，Array 的 Length 并没有增加<br /></li>
<li>在 Func Lib 的函数中定义一个数组类型的局部变量， 在该数组上调用 Add 后，Array 的 Length 会增加<br /></li>
<li>在 Macro Lib 的函数中使用 LocalArrayOfXXX 定义一个数组类型的局部变量，在该数组上调用 Add 后，Array 的 Length 会增加。但是，LocalArrayOfWildcards 会报错，<br />
<ul class="org-ul">
<li>The type of  Variable  is undetermined.  Connect something to  Local Array of Wildcards  to imply a specific type. 这个是 UE 的 bug，详情请参考 Fix Unreal BUG.md 文档内容。<br /></li>
</ul></li>

<li>总的来说，应该尽量避免在 Macro 中使用大小可变的数组，相关的函数应该通过在 Func Lib 来实现。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org62acb63" class="outline-5">
<h5 id="org62acb63"><span class="todo TODO">TODO</span> Macro 的 Wildcard 类型</h5>
</div>
<div id="outline-container-org149a1f1" class="outline-5">
<h5 id="org149a1f1">封装日志打印函数</h5>
<div class="outline-text-5" id="text-org149a1f1">
<p>
因为 Macro Lib 中无法调用 Func Lib 中的函数，所以日志打印函数采用 Macro Lib 函数来实现，这样日志打印函数就更通用了。<br />
日志打印函数命名为 Macro_TOOL_Log<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4e409f8" class="outline-4">
<h4 id="org4e409f8">Misc</h4>
<div class="outline-text-4" id="text-org4e409f8">
</div>
<div id="outline-container-org848909d" class="outline-5">
<h5 id="org848909d">关于 WorldContext</h5>
<div class="outline-text-5" id="text-org848909d">
</div>
<div id="outline-container-orgfe872c7" class="outline-6">
<h6 id="orgfe872c7"><span class="todo TODO">TODO</span> WorldContext 是什么？</h6>
</div>
<div id="outline-container-org587e3e0" class="outline-6">
<h6 id="org587e3e0">Macro Lib 中的 WorldContext 输入参数</h6>
<div class="outline-text-6" id="text-org587e3e0">
<ul class="org-ul">
<li>在 Macro_TOOL_Log 中调用 PrintString 函数时，可以省略 WorldContext 输入参数<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2476b1c" class="outline-6">
<h6 id="org2476b1c">Func Lib 中的 WorldContext 输入参数</h6>
<div class="outline-text-6" id="text-org2476b1c">
<ul class="org-ul">
<li>在 GInstance_StaticFunc 中，调用 GetGameInstance 时，可以省略 WorldContext 输入参数<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org8cd19ef" class="outline-3">
<h3 id="org8cd19ef">CPlusPlus</h3>
<div class="outline-text-3" id="text-org8cd19ef">
</div>
<div id="outline-container-org269bfe1" class="outline-4">
<h4 id="org269bfe1">Q&amp;A</h4>
<div class="outline-text-4" id="text-org269bfe1">
</div>
<div id="outline-container-org013c407" class="outline-5">
<h5 id="org013c407">c++中如何打印日志到屏幕？</h5>
<div class="outline-text-5" id="text-org013c407">
<p>
如下所示：<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">AMyActor.cpp</span>

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"Engine.h"</span>

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">AMyActor</span>::BeginPlay()
{
    Super::BeginPlay();

    GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, <span style="color: #2d9574;">"HelloWorld!"</span>);
}
</pre>
</div>

<ul class="org-ul">
<li><a href="https://answers.unrealengine.com/questions/149374/is-gengine-dead.html">https://answers.unrealengine.com/questions/149374/is-gengine-dead.html</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7590d60" class="outline-3">
<h3 id="org7590d60">UI</h3>
<div class="outline-text-3" id="text-org7590d60">
</div>
<div id="outline-container-org40cd5a2" class="outline-4">
<h4 id="org40cd5a2">如何动态添加 Item 到 UI 列表中？</h4>
<div class="outline-text-4" id="text-org40cd5a2">
<p>
通过 AddChild 方法<br />
</p>
<ul class="org-ul">
<li>参考资料 <a href="https://wiki.unrealengine.com/UMG,_Create_Scrollable_List_of_Clickable_Buttons_From_Dynamic_Array">https://wiki.unrealengine.com/UMG,_Create_Scrollable_List_of_Clickable_Buttons_From_Dynamic_Array</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org85d60c1" class="outline-4">
<h4 id="org85d60c1">UI 事件触发顺序</h4>
<div class="outline-text-4" id="text-org85d60c1">
<ul class="org-ul">
<li>Panel AfterCreate BeforeAdd<br /></li>
<li>Panel Pre Construct<br /></li>
<li>Panel Construct<br /></li>
<li>Panel AfterAdd<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3a9c9dd" class="outline-3">
<h3 id="org3a9c9dd">Material</h3>
<div class="outline-text-3" id="text-org3a9c9dd">
</div>
<div id="outline-container-orgcb04377" class="outline-4">
<h4 id="orgcb04377">材质编辑器中如何预览某个节点输出的颜色？</h4>
<div class="outline-text-4" id="text-orgcb04377">
<ul class="org-ul">
<li>方案 1： 点击该节点 右上角上的三角按钮 就会展示该节点的预览图。<br /></li>
<li>方案 2： 如果该节点右上角没有三角按钮 可以添加一个 Subtract 节点，连接 Subtract 节点的输入 A 到当前节点的输出，设置 Subtract 节点的输入 B 为 0，点击 Subtract 节点右上角的三角按钮。<br /></li>
<li>方案 3： 右键点击节点 选择 Start Previewing Node。在预览窗口就会展示该节点的输入效果。<br /></li>
<li>方案 4： 使用 DebugXXX 节点。例如：DebugFloat3Values<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org33cc0a2" class="outline-4">
<h4 id="org33cc0a2">如何修改材质属性</h4>
<div class="outline-text-4" id="text-org33cc0a2">
<p>
可以参考，ContentExamples/Animation/1.2 AnimationBlueprint 中操作杆按钮颜色修改的实现方式。<br />
</p>
</div>
</div>
<div id="outline-container-org7a8ae8c" class="outline-4">
<h4 id="org7a8ae8c">材质函数中的 Parameter 参数如何暴露给材质呢？</h4>
<div class="outline-text-4" id="text-org7a8ae8c">
<p>
Material Function 中的 Parameter 参数会自动在 Material 的 Instance 中暴露出来，和 Material 的 Parameter 没有什么不同。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org59044dc" class="outline-2">
<h2 id="org59044dc">参考资料</h2>
<div class="outline-text-2" id="text-org59044dc">
</div>
<div id="outline-container-orgd39b008" class="outline-3">
<h3 id="orgd39b008">UE5</h3>
<div class="outline-text-3" id="text-orgd39b008">
<ul class="org-ul">
<li>UE5 渲染技术简介：Nanite 篇 <a href="https://zhuanlan.zhihu.com/p/382687738">https://zhuanlan.zhihu.com/p/382687738</a><br /></li>
<li>Brief Analysis of Nanite <a href="https://www.notion.so/Brief-Analysis-of-Nanite-94be60f292434ba3ae62fa4bcf7d9379">https://www.notion.so/Brief-Analysis-of-Nanite-94be60f292434ba3ae62fa4bcf7d9379</a><br /></li>
<li>A Macro View of Nanite <a href="http://www.elopezr.com/a-macro-view-of-nanite/">http://www.elopezr.com/a-macro-view-of-nanite/</a><br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="vssue"></div>
        <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css">
        <script src="https://unpkg.com/vue@2.7.10/dist/vue.runtime.min.js"></script>
        <script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>
        <script>
          new Vue({
            el: '#vssue',
            render: h => h('Vssue', {
              props: {
                // 在这里设置当前页面对应的 Issue 标题
                title: 'UnrealEngineNote',

                // 在这里设置你使用的平台的 OAuth App 配置
                options: {
                    owner: 'wolfand11',
                    repo: 'blog_comments',
                    clientId: 'a02b49185d85859cb92c',
                    clientSecret: '6f123085c6f1ce339e2517d24e5b099fa1dc9c85', // 只有在使用某些平台时需要
                },
              }
            })
          })
        </script>
</div>
</body>
</html>