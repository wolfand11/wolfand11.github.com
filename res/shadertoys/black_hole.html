<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Local Shadertoy</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background-color: black; }
    canvas { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// Vertex shader: full‑screen quad
const vsSource = `
attribute vec4 a_position;
void main() {
  gl_Position = a_position;
}
`;

// Fragment shader: Shadertoy-style
const fsSource = `
precision highp float;

uniform vec3  iResolution;
uniform float iTime;
uniform float iTimeDelta;
uniform int   iFrame;
uniform vec4  iMouse;

//void mainImage(out vec4 fragColor, in vec2 fragCoord) {
//    // --- Your Shadertoy code goes here ---
//    fragColor = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);
//}

void mainImage(out vec4 O, in vec2 F)
{
    //Iterator and attenuation (distance-squared)
    float i = .2, a;
    //Resolution for scaling and centering
    vec2 r = iResolution.xy,
         //Centered ratio-corrected coordinates
         p = ( F+F - r ) / r.y / .7,
         //Diagonal vector for skewing
         d = vec2(-1,1),
         //Blackhole center
         b = p - i*d,
         //Rotate and apply perspective
         c = p * mat2(1, 1, d/(.1 + i/dot(b,b))),
         //Rotate into spiraling coordinates
         v = c * mat2(cos(.5*log(a=dot(c,c)) + iTime*i + vec4(0,33,11,0)))/i,
         //Waves cumulative total for coloring
         w;
    
    //Loop through waves
    for(float i=0.2; i<9.; i+=1.0)
    {
        //Distort coordinates
        v = v + .7* sin(v.yx*i+iTime) / i + .5;
        w = w + 1.+sin(v);
    }
    //Acretion disk radius
    i = length( sin(v/.3)*.4 + c*(3.+d) );
    //Red/blue gradient
    O = 1. - exp( -exp( c.x * vec4(.6,-.4,-1,0) )
                   //Wave coloring
                   /  w.xyyx
                   //Acretion disk brightness
                   / ( 2. + i*i/4. - i )
                   //Center darkness
                   / ( .5 + 1. / a )
                   //Rim highlight
                   / ( .03 + abs( length(p)-.7 ) )
             );
}

void main() {
  vec4 color;
  mainImage(color, gl_FragCoord.xy);
  gl_FragColor = color;
}
`;

// Basic WebGL setup
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');
if (!gl) alert('WebGL not supported');

function resize() {
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(innerWidth * dpr);
  const h = Math.floor(innerHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0, 0, w, h);
  }
}
window.addEventListener('resize', resize);

// Compile helpers
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error("shader error: "+gl.getShaderInfoLog(s));
  }
  return s;
}
const vs = compile(gl.VERTEX_SHADER, vsSource);
const fs = compile(gl.FRAGMENT_SHADER, fsSource);

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);

// Full‑screen quad
const positionLoc = gl.getAttribLocation(prog, 'a_position');
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,  1,-1, -1, 1,
  -1, 1,  1,-1,  1, 1,
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const iResolutionLoc = gl.getUniformLocation(prog, 'iResolution');
const iTimeLoc       = gl.getUniformLocation(prog, 'iTime');
const iTimeDeltaLoc  = gl.getUniformLocation(prog, 'iTimeDelta');
const iFrameLoc      = gl.getUniformLocation(prog, 'iFrame');
const iMouseLoc      = gl.getUniformLocation(prog, 'iMouse');

// Mouse handling
let mouse = [0,0,0,0];
let isDown = false;
canvas.addEventListener('mousedown', e => {
  isDown = true;
  mouse[0] = e.clientX * (window.devicePixelRatio || 1);
  mouse[1] = (innerHeight - e.clientY) * (window.devicePixelRatio || 1);
  mouse[2] = mouse[0];
  mouse[3] = mouse[1];
});
canvas.addEventListener('mouseup', () => { isDown = false; });
canvas.addEventListener('mousemove', e => {
  if (isDown) {
    mouse[0] = e.clientX * (window.devicePixelRatio || 1);
    mouse[1] = (innerHeight - e.clientY) * (window.devicePixelRatio || 1);
  }
});

// Render loop
let startTime = performance.now() / 1000;
let lastTime = startTime;
let frame = 0;

function render() {
  resize();
  const now = performance.now() / 1000;
  const t = now - startTime;
  const dt = now - lastTime;
  lastTime = now;

  gl.uniform3f(iResolutionLoc, canvas.width, canvas.height, 1.0);
  gl.uniform1f(iTimeLoc, t);
  gl.uniform1f(iTimeDeltaLoc, dt);
  gl.uniform1i(iFrameLoc, frame++);
  gl.uniform4f(iMouseLoc, mouse[0], mouse[1], mouse[2], mouse[3]);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
